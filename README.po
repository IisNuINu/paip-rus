#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/README.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-08-13 09:22+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/README.md:3
msgid "# *Paradigms of Artificial Intelligence Programming* "
msgstr "# *Парадигмы программирования искусственного интеллекта* "

#: in/README.md:5
msgid "![PAIP](https://norvig.com/paip-cover.gif)"
msgstr ""

#: in/README.md:7
msgid "# Table of Contents"
msgstr "# Содержание"

#: in/README.md:405
msgid ""
"- Preface\n"
"  * Why Lisp?  Why Common Lisp?\n"
"  * Outline of the Book\n"
"  * How to use This Book\n"
"  * Supplementary Texts and Reference Books\n"
"  * A Note on Exercises\n"
"  * Acknowledgments\n"
"- **Part I  Introduction to Common Lisp**\n"
"- **1  Introduction to Lisp**\n"
"  * 1.1  Symbolic Computation\n"
"  * 1.2  Variables\n"
"  * 1.3  Special Forms\n"
"  * 1.4  Lists\n"
"  * 1.5  Defining New Functions\n"
"  * 1.6  Using Functions\n"
"  * 1.7  Higher-Order Functions\n"
"  * 1.8  Other Data Types\n"
"  * 1.9  Summary:  The Lisp Evaluation Rule\n"
"  * 1.10  What Makes Lisp Different?\n"
"  * 1.11  Exercises\n"
"  * 1.12  Answers\n"
"- **2  A Simple Lisp Program**\n"
"  * 2.1  A Grammar for a Subset of English\n"
"  * 2.2  A Straightforward Solution\n"
"  * 2.3  A Rule-Based Solution\n"
"  * 2.4  Two paths to Follow\n"
"  * 2.5  Changing the Grammar without Changing the Program\n"
"  * 2.6  Using the Same Data for Several Programs\n"
"  * 2.7  Exercises\n"
"  * 2.8  Answers\n"
"- **3  Overview of Lisp**\n"
"  * 3.1  A Guide to Lisp Style\n"
"  * 3.2  Special Forms\n"
"      * Special Forms for Definitions\n"
"      * Special Forms for Conditionals\n"
"      * Special Forms for Dealing with Variables and Places\n"
"      * Functions and Special Forms for Repetition\n"
"      * Repetition through Recursion\n"
"      * Other Special Forms\n"
"      * Macros\n"
"      * Backquote Notation\n"
"  * 3.3  Functions on Lists\n"
"  * 3.4  Equality and Internal Representation\n"
"  * 3.5  Functions on Sequences\n"
"  * 3.6  Functions for Maintaining Tables\n"
"  * 3.7  Functions on Trees\n"
"  * 3.8  Functions on Numbers\n"
"  * 3.9  Functions on Sets\n"
"  * 3.10  Destructive Functions\n"
"  * 3.11 Overview of Data types\n"
"  * 3.12  Input/Output\n"
"  * 3.13  Debugging tools\n"
"  * 3.14  Antibugging Tools\n"
"      * Timing Tools\n"
"  * 3.15  Evaluation\n"
"  * 3.16  Closures\n"
"  * 3.17  Special Variables\n"
"  * 3.18  Multiple Values\n"
"  * 3.19  More about Parameters\n"
"  * 3.20  The Rest of Lisp\n"
"  * 3.21  Exercises\n"
"  * 3.22  Answers\n"
"- **Part II  Early AI Programs**\n"
"- **4  GPS:  The General problem Solver**\n"
"  * 4.1  Stage 1:  Description\n"
"  * 4.2  Stage 2:  Specification\n"
"  * 4.3  Stage 3:  Implementation\n"
"  * 4.4  Stage 4:  Test\n"
"  * 4.5  Stage 5:  Analysis, or &quot;We Lied about the G&quot;\n"
"  * 4.6  The Running Around the Block Problem\n"
"  * 4.7  The Clobbered Sibling Goal Problem\n"
"  * 4.8  The Leaping before You Look Problem\n"
"  * 4.9  The recursive Subgoal problem\n"
"  * 4.10  The Lack of Intermediate Information Problem\n"
"  * 4.11  GPS Version 2:  A More General problem Solver\n"
"  * 4.12  The New Domain problem:  Monkey and Bananas\n"
"  * 4.13  The Maze Searching Domain\n"
"  * 4.14  The Blocks World Domain\n"
"      * The Sussman Anomaly\n"
"  * 4.15  Stage 5 Repeated:  Analysis of Version 2\n"
"  * 4.16  The Not Looking after You Don&#39;t Leap Problem\n"
"  * 4.17  The Lack of Descriptive Power Problem\n"
"  * 4.18  The Perfect Information Problem\n"
"  * 4.19  The Interacting Goals Problem\n"
"  * 4.20  The End of GPS\n"
"  * 4.21  History and References\n"
"  * 4.22 Exercises\n"
"  * 4.23  Answers\n"
"- **5  Eliza:  Dialog with a Machine**\n"
"  * 5.1  Describing and Specifying Eliza\n"
"  * 5.2  Pattern Matching\n"
"  * 5.3  Segment Pattern Matching\n"
"  * 5.4  The Eliza Program:  A Rule-Based Translator\n"
"  * 5.5  History and References\n"
"  * 5.6  Exercises\n"
"  * 5.7  Answers\n"
"- **6  Building Software Tools**\n"
"  * 6.1  An Interactive Interpreter Tool\n"
"  * 6.2  A Pattern-Matching Tool\n"
"  * 6.3  A Rule-Based Translator Tool\n"
"  * 6.4  A Set of Searching Tools\n"
"      * Searching Trees\n"
"      * Guiding the Search\n"
"      * Search Paths\n"
"      * Guessing versus Guaranteeing a Good Solution\n"
"      * Searching Graphs\n"
"  * 6.5  GPS as Search\n"
"  * 6.6  History and References\n"
"  * 6.7  Exercises\n"
"  * 6.8  Answers\n"
"- **7  Student:  Solving Algebra Word Problems**\n"
"  * 7.1  Translating English into Equations\n"
"  * 7.2  Solving Algebraic Equations\n"
"  * 7.3  Examples\n"
"  * 7.4  History and References\n"
"  * 7.5  Exercises\n"
"  * 7.6  Answers\n"
"- **8  Symbolic Mathematics:  A Simplification Program**\n"
"  * 8.1  Converting Infix to Prefix Notation\n"
"  * 8.2  Simplification Rules\n"
"  * 8.3  Associativity and Commutativity\n"
"  * 8.4  Logs, Trig, and Differentiation\n"
"  * 8.5  Limits of Rule-Based Approaches\n"
"  * 8.6  Integration\n"
"  * 8.7  History and References\n"
"  * 8.8. Exercises\n"
"- **Part III  Tools and Techniques**\n"
"- **9  Efficiency Issues**\n"
"  * 9.1  Caching Results of Previous Computations:   Memoization\n"
"  * 9.2  Compiling One Language into Another\n"
"  * 9.3  Delaying Computation\n"
"  * 9.4  Indexing Data\n"
"  * 9.5  Instrumentation:  Deciding What to Optimize\n"
"  * 9.6  A Case Study in Efficiency:  The SIMPLIFY Program\n"
"      * Memoization\n"
"      * Indexing\n"
"      * Compilation\n"
"      * The Single-Rule Compiler\n"
"      * The Rule-Set Compiler\n"
"  * 9.7  History and References\n"
"  * 9.8  Exercises\n"
"  * 9.9  Answers\n"
"- **10  Low-Level Efficiency Issues**\n"
"  * 10.1  use Declarations\n"
"  * 10.2  Avoid Generic Functions\n"
"  * 10.3  Avoid Complex Argument Lists\n"
"  * 10.4  Avoid Unnecessary Consing\n"
"      * Avoid Consing:  Unique Lists\n"
"      * Avoid Consing:  Multiple Values\n"
"      * Avoid Consing:  Resources\n"
"  * 10.5  Use the Right Data Structures\n"
"      * The Right Data Structure:  Variables\n"
"      * The Right Data Structure:  Queues\n"
"      * The Right Data Structure:  Tables\n"
"  * 10.6  Exercises\n"
"  * 10.7  Answers\n"
"- **11  Logic Programming**\n"
"  * 11.1  Idea 1:  A Uniform Data Base\n"
"  * 11.2  Idea 2:  Unification of Logic Variables\n"
"      * Programming with Prolog\n"
"  * 11.3  Idea 3:  Automatic Backtracking\n"
"      * Approaches to Backtracking\n"
"      * Anonymous Variables\n"
"  * 11.4  The Zebra Puzzle\n"
"  * 11.5  The Synergy of Backtracking and Unification\n"
"  * 11.6  Destructive Unification\n"
"  * 11.7  Prolog in Prolog\n"
"  * 11.8  Prolog Compared to Lisp\n"
"  * 11.9  History and References\n"
"  * 11.10  Exercises\n"
"  * 11.11  Answers\n"
"- **12  Compiling Logic programs**\n"
"  * 12.1  A prolog Compiler\n"
"  * 12.2  Fixing the Errors in the Compiler\n"
"  * 12.3  Improving the Compiler\n"
"  * 12.4  Improving the Compilation of Unification\n"
"  * 12.5  Further Improvements to Unification\n"
"  * 12.6  The User Interface to the Compiler\n"
"  * 12.7  Benchmarking the Compiler\n"
"  * 12.8  Adding More Primitives\n"
"  * 12.9  The Cut\n"
"  * 12.10  &quot;Real&quot; Prolog\n"
"  * 12.11 History and References\n"
"  * 12.12  Exercises\n"
"  * 12.13  Answers\n"
"- **13  Object-Oriented Programming**\n"
"  * 13.1  Object-Oriented Programming\n"
"  * 13.2  Objects\n"
"  * 13.3  Generic Functions\n"
"  * 13.4  Classes\n"
"  * 13.5  Delegation\n"
"  * 13.6  Inheritance\n"
"  * 13.7  CLOS:  The Common Lisp Object System\n"
"  * 13.8  A CLOS Example:  Searching Tools\n"
"      * Best-First Search\n"
"  * 13.9  Is CLOS Object-Oriented?\n"
"  * 13.10  Advantages of Object-Oriented programming\n"
"  * 13.11  History and References\n"
"  * 13.12  Exercises\n"
"- **14  Knowledge Representation and Reasoning**\n"
"  * 14.1  A Taxonomy of Representation Languages\n"
"  * 14.2  Predicate Calculus and its Problems\n"
"  * 14.3  A Logical Language: Prolog\n"
"  * 14.4  Problems with Prolog&#39;s Expressiveness\n"
"  * 14.5  Problems with Predicate Calculus&#39;s Expressiveness\n"
"  * 14.6  Problems with Completeness\n"
"  * 14.7  Problems with Efficiency:  Indexing\n"
"  * 14.8  A Solution to the Indexing Problem\n"
"  * 14.9  A Solution to the Completeness Problem\n"
"  * 14.10  Solutions to the Expressiveness Problems\n"
"      * Higher-Order Predications\n"
"      * Improvements\n"
"      * A Frame Language\n"
"      * Possible Worlds:  Truth, Negation, and Disjunction\n"
"      * Unification, Equality, Types, and Skolem Constants\n"
"  * 14.11  History and References\n"
"  * 14.12  Exercises\n"
"  * 14.13  Answers\n"
"- **Part IV  Advanced AI Programs**\n"
"- **15  Symbolic Mathematics with Canonical Forms**\n"
"  * 15.1  A Canonical Form for Polynomials\n"
"  * 15.2  Differentiating Polynomials\n"
"  * 15.3  Converting between Infix and Prefix\n"
"  * 15.4  Benchmarking the Polynomial Simplifier\n"
"  * 15.5  A Canonical Form for Rational Expressions\n"
"  * 15.6  Extending Rational Expressions\n"
"  * 15.7  History and References\n"
"  * 15.8  Exercises\n"
"  * 15.9  Answers\n"
"- **16  Expert Systems**\n"
"  * 16.1  Dealing with Uncertainty\n"
"  * 16.2  Caching Derived Facts\n"
"  * 16.3  Asking Questions\n"
"  * 16.4  Contexts Instead of Variables\n"
"  * 16.5  Backward-Chaining Revisited\n"
"  * 16.6  Interacting with the Expert\n"
"  * 16.7  Interacting with the Client\n"
"  * 16.8  MYCIN, A Medical Expert System\n"
"  * 16.9  Alternatives to Certainty Factors\n"
"  * 16.10  History and References\n"
"  * 16.11  Exercises\n"
"  * 16.12  Answers\n"
"- **17  Line-Diagram Labeling by Constraint Satisfaction**\n"
"  * 17.1  The Line-Labeling Problem\n"
"  * 17.2  Combining Constraints and Searching\n"
"  * 17.3  Labeling Diagrams\n"
"  * 17.4  Checking Diagrams for Errors\n"
"  * 17.5  History and References\n"
"  * 17.6  Exercises\n"
"- **18  Search and the Game of Othello**\n"
"  * 18.1  The Rules of the Game\n"
"  * 18.2  Representation Choices\n"
"  * 18.3  Evaluating Positions\n"
"  * 18.4  Searching Ahead:  Minimax\n"
"  * 18.5  Smarter Searching:  Alpha-Beta Search\n"
"  * 18.6  An Analysis of Some Games\n"
"  * 18.7  The Tournament Version of Othello\n"
"  * 18.8  Playing a Series of Games\n"
"  * 18.9  More Efficient Searching\n"
"  * 18.10  It Pays to Precycle\n"
"  * 18.11  Killer Moves\n"
"  * 18.12  Championship Programs:  Iago and Bill\n"
"      * Mobility\n"
"      * Edge Stability\n"
"      * Combining the Factors\n"
"  * 18.13  Other Techniques\n"
"      * Interative Deepening\n"
"      * Forward Pruning\n"
"      * Nonspeculative Forward Pruning\n"
"      * Aspiration Search\n"
"      * Think-Ahead\n"
"      * Hashing and Opening Book Moves\n"
"      * The End Game\n"
"      * Metareasoning\n"
"      * Learning\n"
"  * 18.14  History and References\n"
"  * 18.15  Exercises\n"
"  * 18.16  Answers\n"
"- **19  Introduction to Natural Language**\n"
"  * 19.1  Parsing with a Phrase-Structure Grammar\n"
"  * 19.2  Extending the Grammar and Recognizing Ambiguity\n"
"  * 19.3  More Efficient parsing\n"
"  * 19.4  The Unknown-Word Problem\n"
"  * 19.5  Parsing into a Semantic Representation\n"
"  * 19.6  Parsing with Preferences\n"
"  * 19.7  The Problem with Context-Free Phrase-Structure Rules\n"
"  * 19.8  History and References\n"
"  * 19.9  Exercises\n"
"  * 19.10  Answers\n"
"- **20  Unification Grammars**\n"
"  * 20.1  Parsing as Deduction\n"
"  * 20.2  Definite Clause Grammars\n"
"  * 20.3  A Simple Grammar In DCG Format\n"
"  * 20.4  A DCG Grammar with Quantifiers\n"
"  * 20.5  Preserving Quantifier Scope Ambiguity\n"
"  * 20.6  Long-Distance Dependencies\n"
"  * 20.7  Augmenting DCG Rules\n"
"  * 20.8  History and References\n"
"  * 20.9  Exercises\n"
"  * 20.10  Answers\n"
"- **21  A Grammar of English**\n"
"  * 21.1  Noun Phrases\n"
"  * 21.2  Modifiers\n"
"  * 21.3  Noun Modifiers\n"
"  * 21.4  Determiners\n"
"  * 21.5  Verb Phrases\n"
"  * 21.6  Adverbs\n"
"  * 21.7  Clauses\n"
"  * 21.8  Sentences\n"
"  * 21.9  XPs\n"
"  * 21.10  Word Categories\n"
"  * 21.11  The Lexicon\n"
"      * Verbs\n"
"      * Auxiliary Verbs\n"
"      * Nouns\n"
"      * Pronouns\n"
"      * Names\n"
"      * Adjectives\n"
"      * Adverbs\n"
"      * Articles\n"
"      * Cardinal and Ordinal Numbers\n"
"      * Prepositions\n"
"  * 21.12  Supporting the Lexicon\n"
"  * 21.13  Other Primitives\n"
"  * 21.14  Examples\n"
"  * 21.15  History and References\n"
"  * 21.16  Exercises\n"
"- **Part V  The Rest of Lisp**\n"
"- **22  Scheme:  An Uncommon Lisp**\n"
"  * 22.1  A Scheme Interpreter\n"
"  * 22.2  Syntactic Extension with Macros\n"
"  * 22.3  A Properly Tail-Recursive Interpreter\n"
"  * 22.4  Throw, Catch, and Call/cc\n"
"  * 22.5  An interpreter Supporting Call/cc\n"
"  * 22.6  History and References\n"
"  * 22.7  Exercises\n"
"  * 22.8  Answers\n"
"- **23  Compiling Lisp**\n"
"  * 23.1  A Properly Tail-Recursive Lisp Compiler\n"
"  * 23.2  Introducing Call/cc\n"
"  * 23.3  The Abstract Machine\n"
"  * 23.4  A Peephole Optimizer\n"
"  * 23.5  Languages with Different Lexical Conventions\n"
"  * 23.6  History and References\n"
"  * 23.7  Exercises\n"
"  * 23.8  Answers\n"
"- **24  ANSI Common Lisp**\n"
"  * 24.1  Packages\n"
"  * The Seven Name Spaces\n"
"  * 24.2  Conditions and Error Handling\n"
"      * Signaling Errors\n"
"      * Handling Errors\n"
"  * 24.3  Pretty Printing\n"
"  * 24.4  Series\n"
"  * 24.5  The Loop Macro\n"
"      * Anatomy of a Loop\n"
"      * Iteration Control (26.6)\n"
"      * End-Test Control (26.7)\n"
"      * Value Accumulation (26.8)\n"
"      * Variable Initialization (26.9)\n"
"      * Conditional Execution (26.10)\n"
"      * Unconditional Execution (26.11)\n"
"      * Miscellaneous Features (26.12)\n"
"  * 24.6  Sequence Functions\n"
"      * Once-only:  A Lesson in Macrology\n"
"      * Avoid Overusing Macros\n"
"      * MAP-INTO\n"
"      * REDUCE with :key\n"
"  * 24.7  Exercises\n"
"  * 24.8  Answers\n"
"- **25  Troubleshooting**\n"
"  * 25.1  Nothing Happens\n"
"  * 25.2  Change to Variable Has No Effect\n"
"  * 25.3  Change to Function Has No Effect\n"
"  * 25.4  Values Change &quot;by Themselves&quot;\n"
"  * 25.5  Built-In Functions Don&#39;t Find Elements\n"
"  * 25.6  Multiple Values Are Lost\n"
"  * 25.7  Declarations Are Ignored\n"
"  * 25.8  My Lisp Does the Wrong Thing\n"
"  * 25.9  How to Find the Function You Want\n"
"  * 25.10  Syntax of LOOP\n"
"  * 25.11  Syntax of COND\n"
"  * 25.12  Syntax of CASE\n"
"  * 25.13  Syntax of LET and LET*\n"
"  * 25.14  Problems with Macros\n"
"  * 25.15  A Style Guide to Lisp\n"
"      * When to Define a Function\n"
"      * When to Define a Special Variable\n"
"      * When to Bind a Lexical Variable\n"
"      * How to Choose a Name\n"
"      * Deciding on the Order of Parameters\n"
"  * 25.16  Dealing with Files, Packages, and Systems\n"
"  * 25.17  Portability Problems\n"
"  * 25.18  Exercises\n"
"  * 25.19  Answers\n"
"- Appendix\n"
"- Bibliography\n"
"- Index"
msgstr ""
"- Предисловие\n"
"  * Почему Lisp? Почему Common Lisp?\n"
"  * Набросок книги\n"
"  * Как пользоваться этой книгой\n"
"  * Дополнительные тексты и справочники\n"
"  * Примечание по упражнениям\n"
"  * Благодарности\n"
"- **Часть I  Введение в Common Lisp**\n"
"- **1  Введение в Lisp**\n"
"  * 1.1  Символьные вычисления\n"
"  * 1.2  Переменные\n"
"  * 1.3  Специальные Формы\n"
"  * 1.4  списки\n"
"  * 1.5  Определение Новых Функций\n"
"  * 1.6  Использование Функций\n"
"  * 1.7  Функции Высшего Порядка\n"
"  * 1.8  Другие Типы Данных/\n"
"  * 1.9  Резюме: Правило Вычисления(Оценки) в Lisp\n"
"  * 1.10 Что Делает Лисп - Особенным?\n"
"  * 1.11 упражнения\n"
"  * 1.12 ответы\n"
"- **2  Простая Лисп Программа**\n"
"  * 2.1  Грамматика для подмножества английского языка\n"
"  * 2.2  Простое Решение\n"
"  * 2.3  Решение, Основанное На Правилах\n"
"  * 2.4  два пути следования\n"
"  * 2.5  изменение грамматики без изменения программы\n"
"  * 2.6  использование одних и тех же данных для нескольких программ\n"
"  * 2.7  упражнения\n"
"  * 2.8  ответы\n"
"- **3  Обзор Lisp**\n"
"  * 3.1  руководство по стилю Lisp\n"
"  * 3.2  Специальные Формы\n"
"      * Специальные формы для определений\n"
"      * Специальные формы для условий\n"
"      * Специальные формы для работы с переменными и местами\n"
"      * Функции и специальные формы для повторения\n"
"      * Повторение через рекурсию\n"
"      * Другие Специальные Формы\n"
"      * Макросы\n"
"      * Нотация Обратной Кавычки(Backquote)\n"
"  * 3.3  функции на списках\n"
"  * 3.4  равенство и внутреннее представителение\n"
"  * 3.5  функции на последовательностях\n"
"  * 3.6  функции для поддержки таблиц\n"
"  * 3.7  функции на деревьях\n"
"  * 3.8  функции работы с числами\n"
"  * 3.9  функции работы с множествами\n"
"  * 3.10 Разрушающие(Деструктивные) Функции\n"
"  * 3.11 обзор типов данных\n"
"  * 3.12 Ввод/Вывод\n"
"  * 3.13 инструменты отладки\n"
"  * 3.14 Инструменты борьбы  с ошибками\n"
"      * Инструменты Синхронизации\n"
"  * 3.15 Вычисление(оценка)\n"
"  * 3.16 Замыкания\n"
"  * 3.17 Специальные Переменные\n"
"  * 3.18 Множественные Значения\n"
"  * 3.19 подробнее о параметрах\n"
"  * 3.20 остальная часть Лиспа\n"
"  * 3.21 упражнения\n"
"  * 3.22 ответы\n"
"- **Часть II  Ранние программы искусственного интеллекта**\n"
"- **4  GPS:  Универсальный решатель проблем(General problem Solver)**\n"
"  * 4.1  Этап 1: Описание\n"
"  * 4.2  Этап 2: Спецификация\n"
"  * 4.3  Этап 3: Реализация\n"
"  * 4.4  Этап 4: Испытание\n"
"  * 4.5  Этап 5: Анализ, или &quot;мы солгали о G&quot;\n"
"  * 4.6  проблема блока - бег по кругу\n"
"  * 4.7  Проблема брат ломающий цель.\n"
"  * 4.8  проблема просмотре, прыжок перед вами\n"
"  * 4.9  проблема рекурсивная подцель\n"
"  * 4.10  проблема отсутствия промежуточной информации\n"
"  * 4.11  GPS Версия 2: более общий решатель проблем\n"
"  * 4.12  новая доменная проблема: обезьяна и бананы\n"
"  * 4.13  Домен Поиска Лабиринта\n"
"  * 4.14  Домен Мира Блоков(Blocks World)\n"
"      *  Аномалия Сассмана\n"
"  * 4.15 повторение этапа 5: Анализ версии 2\n"
"  * 4.16 отсутствие присмотра за вами не является проблемой прыжка\n"
"  * 4.17 проблема отсутствия описательной мощности\n"
"  * 4.18 Идеальная Информационная Проблема\n"
"  * 4.19 Проблема Взаимодействующих Целей\n"
"  * 4.20 Завершение GPS\n"
"  * 4.21 история и ссылки\n"
"  * 4.22 упражнения\n"
"  * 4.23 ответы\n"
"- **5  Элиза: Диалог с машиной **\n"
"   * 5.1  Описание и Спецификация Элизы\n"
"   * 5.2  Сопоставление с образцом\n"
"   * 5.3  Сопоставление сегментов образцов\n"
"   * 5.4  Программа Элиза: Преобразователь на основе правил\n"
"   * 5.5  История и ссылки\n"
"   * 5.6  Упражнения\n"
"   * 5.7  Ответы\n"
"- **6 Построение Программных Средств**\n"
"   * 6.1  Интерактивный Инструмент Интерпретатора\n"
"   * 6.2  Инструмент Сопоставления с образцом\n"
"   * 6.3  Инструмент Преобразования На Основе Правил\n"
"   * 6.4  набор инструментов поиска\n"
"       *  Поиск по Дереву\n"
"       *  Руководство поиском\n"
"       *  поиск пути\n"
"       *  Угадывание против гарантирования хорошего решения\n"
"       *  Поиск по Графу\n"
"   * 6.5  GPS как поиск\n"
"   * 6.6  истории и литературы\n"
"   * 6.7  упражнения\n"
"   * 6.8  ответы\n"
"- **7  Student:  Решение алгебраических задач со словами **\n"
"   * 7.1  Перевод английского языка в уравнения\n"
"   * 7.2  Решение алгебраических уравнений\n"
"   * 7.3  Примеры\n"
"   * 7.4  История и ссылки\n"
"   * 7.5  Упражнения\n"
"   * 7.6  Ответы\n"
"- **8  Символьная математика: программа упрощения **\n"
"   * 8.1  Преобразование инфиксной в префиксную нотацию\n"
"   * 8.2  Правила упрощения\n"
"   * 8.3  Ассоциативность и коммутативность\n"
"   * 8.4  Логарифмы(Logs), Тригонометрия(Trig), и Дифференциалы(Diff)\n"
"   * 8.5  Пределы подход основанный на правилах\n"
"   * 8.6  Интегрирование\n"
"   * 8.7  История и ссылки\n"
"   * 8.8  упражнения\n"
"- **Part III  Инструменты и Техники**\n"
"- **9  Вопросы эффективности**\n"
"   * 9.1. Кэширование результатов предыдущих вычислений: запоминание\n"
"   * 9.2  Компиляция одного языка на другой\n"
"   * 9.3  Задержка вычислений\n"
"   * 9.4  Индексация данных\n"
"   * 9.5  Инструментарий: решение, что оптимизировать\n"
"   * 9.6  Пример эффективности: программа SIMPLIFY(упрощение)\n"
"       *  Запоминание результатов(Memoization)\n"
"       *  Индексирование\n"
"       *  Компиляция \n"
"       *  Компилятор с одним правилом\n"
"       *  Компилятор с набором правил\n"
"   * 9.7  История и ссылки\n"
"   * 9.8  Упражнения\n"
"   * 9.9  Ответы\n"
"- **10  Проблемы Эффективности на Низком Уровне **\n"
"   * 10.1  Используйте Обявлений(Declarations)\n"
"   * 10.2  Избегайте Общих Функций\n"
"   * 10.3  Избегайте Сложных Списков Аргументов\n"
"   * 10.4  Избегайте Ненужного создания списков(Consing)\n"
"        * Избегайте лишних списков: Уникальные Списки\n"
"        * Избегайте лишних списков: множественные Значения\n"
"        * Избегайте лишних списков: Ресурсы\n"
"   * 10.5  Используйте правильные структуры данных\n"
"        * Правильная Структура Данных: Переменные\n"
"        * Правильная Структура Данных: Очередь\n"
"        * Правильная Структура Данных: Таблицы\n"
"   * 10.6  упражнения\n"
"   * 10.7  ответы\n"
"- **11  Логическое программирование**\n"
"   * 11.1  Идея 1: Единая База Данных\n"
"   * 11.2  Идея 2: унификация логических переменных\n"
"       * Программирование с помощью пролога\n"
"   * 11.3  Идея 3: Автоматическая Трасировка вызовов\n"
"       * Подходы к обратному отслеживанию\n"
"       * Анонимные Переменные\n"
"   * 11.4  Головоломка Зебра\n"
"   * 11.5  Синергия трассировки вызовов и унификации\n"
"   * 11.6  Разрушающая Унификация\n"
"   * 11.7  Пролог В прологе\n"
"   * 11.8  пролог в сравнении с Lisp\n"
"   * 11.9  история и литература\n"
"   * 11.10 упражнения\n"
"   * 11.11 ответы\n"
"- **12  Компиляция Логических Программ**\n"
"  * 12.1  Компилятор Пролога\n"
"  * 12.2  Исправление ошибок в компиляторе\n"
"  * 12.3  совершенствование компилятора\n"
"  * 12.4  совершенствование компиляции, унификация\n"
"  * 12.5  дальнейшее совершенствование унификации\n"
"  * 12.6  пользовательский интерфейс компилятора\n"
"  * 12.7  измерение скорости компилятора\n"
"  * 12.8  Добавление Дополнительных Примитивов\n"
"  * 12.9  Разрез(Cut)\n"
"  * 12.10 &quot;Реальный&quot; Пролог\n"
"  * 12.11 история и ссылки\n"
"  * 12.12 упражнения\n"
"  * 12.13 ответы\n"
"- **13  Объектно-Ориентированное Программирование**\n"
"  * 13.1  Объектно-Ориентированное Программирование\n"
"  * 13.2  Объекты\n"
"  * 13.3  Обобщенные Функции\n"
"  * 13.4  Классы\n"
"  * 13.5  Делегирование\n"
"  * 13.6  наследование\n"
"  * 13.7  CLOS: система объектов Common Lisp\n"
"  * 13.8  пример CLOS: инструменты поиска\n"
"      *  Поиск По Первому Наилучшему(Best-First)\n"
"  * 13.9  является ли CLOS объектно-ориентированным?\n"
"  * 13.10 преимущества объектно-ориентированного программирования\n"
"  * 13.11 история и ссылки\n"
"  * 13.12 упражнения\n"
"- **14 Представление знаний и рассуждение**\n"
"  * 14.1  таксономия языков представления\n"
"  * 14.2  исчисление предикатов и его проблемы\n"
"  * 14.3  Логический Язык: Пролог\n"
"  * 14.4  проблемы с выразительностью пролога\n"
"  * 14.5  проблемы с выразительностью исчисления предикатов\n"
"  * 14.6  проблемы с полнотой\n"
"  * 14.7  проблемы с эффективностью: индексация\n"
"  * 14.8  решение проблемы индексации\n"
"  * 14.9  решение проблемы полноты\n"
"  * 14.10 решения проблем выразительности\n"
"      * Предикаты Более Высокого Порядка\n"
"      * Усовершенствованния\n"
"      * Язык Фреймов\n"
"      * Возможные миры: истина, отрицание и дизъюнкция\n"
"      * Унификация, равенство, типы и константы Сколема\n"
"  * 14.11 истории и литературы\n"
"  * 14.12 упражнения\n"
"  * 14.13 ответов\n"
"- **Part IV  Продвинутые программы искусственного интеллекта**\n"
"- **15 символическая математика с каноническими формами**\n"
"  * 15.1  каноническая форма для многочленов\n"
"  * 15.2  Дифференцирование Полиномов\n"
"  * 15.3  преобразование между Инфиксной и Префиксной формой\n"
"  * 15.4  сравнительный анализ полиномиального Упростеля\n"
"  * 15.5  каноническая форма для рациональных выражений\n"
"  * 15.6  Расширение Рациональных Выражений\n"
"  * 15.7  история и литература\n"
"  * 15.8  упражнения\n"
"  * 15.9  ответов\n"
"- **16  Экспертные Системы**\n"
"  * 16.1  Работа с неопределенностью\n"
"  * 16.2  Кэширование Производных(Выведенных) Фактов\n"
"  * 16.3  Задавать Вопросы\n"
"  * 16.4  контексты вместо переменных\n"
"  * 16.5  Повторный просмотр Обратной Цепочки\n"
"  * 16.6  взаимодействие с экспертом\n"
"  * 16.7  взаимодействие с клиентом\n"
"  * 16.8  MYCIN, медицинская экспертная система\n"
"  * 16.9  альтернативы определенным факторам\n"
"  * 16.10 история и литература\n"
"  * 16.11 упражнения\n"
"  * 16.12 ответы\n"
"- **17  Маркированные линейные диаграммы по удовлетворению ограничений**\n"
"  * 17.1  Проблема Линейной Маркировки\n"
"  * 17.2  комбинирование ограничений и поиск\n"
"  * 17.3  Схемы Маркировки\n"
"  * 17.4  проверка диаграмм на наличие ошибок\n"
"  * 17.5  история и литература\n"
"  * 17.6  упражнения\n"
"- **18  Поиск и игра Отелло**\n"
"  * 18.1  правила игры\n"
"  * 18.2  Выбор Представления\n"
"  * 18.3  Вычисление(Оценка) Позиций\n"
"  * 18.4  Поиск Впереди: Минимакс\n"
"  * 18.5  Интеллектуальный Поиск: Альфа-Бета-Поиск\n"
"  * 18.6  анализ некоторых игр\n"
"  * 18.7  турнирная версия Отелло\n"
"  * 18.8  игра в серию игр\n"
"  * 18.9  Более Эффективный Поиск\n"
"  * 18.10 это платит за Предцикл\n"
"  * 18.11 Убийственные Ходы\n"
"  * 18.12 чемпионские программы: Яго и Билл\n"
"      * Мобильность\n"
"      * Стабильность Края\n"
"      * Комбинирование факторов\n"
"  * 18.13 Другие Методы\n"
"      * Интерактивное Углубление\n"
"      * Прямая Обрезка\n"
"      * Неспецифическая Прямая Обрезка\n"
"      * Поиск Устремленности\n"
"      * думать наперед\n"
"      * Хеширование и открытие книжных ходов\n"
"      * Конец Игры\n"
"      * Метареазонирование\n"
"      * Обучение\n"
"  * 18.14 история и ссылки\n"
"  * 18.15 упражнения\n"
"  * 18.16 ответы\n"
"- **19  Введение в Естественные Языки**\n"
"  * 19.1  Синтаксический разбор с грамматикой структуры фразы\n"
"  * 19.2  расширение грамматики и признание двусмысленности\n"
"  * 19.3  более эффективный синтаксический анализ\n"
"  * 19.4  Проблема Неизвестного Слова\n"
"  * 19.5  синтаксический анализ в семантическое представление\n"
"  * 19.6  синтаксический анализ с предпочтениями\n"
"  * 19.7  проблема с контекстно-свободными правилами построения фраз\n"
"  * 19.8  история и ссылки\n"
"  * 19.9  упражнения\n"
"  * 19.10 ответы\n"
"- **20  Унификация Грамматики**\n"
"  * 20.1  синтаксический анализ как дедукция\n"
"  * 20.2  Определенние Грамматики  Предложений\n"
"  * 20.3  простая грамматика в формате DCG\n"
"  * 20.4  грамматика DCG с Кванторами\n"
"  * 20.5  Сохранение неопределенности квантификатора\n"
"  * 20.6  Зависимости На Больших Расстояниях\n"
"  * 20.7  расширение правил DCG\n"
"  * 20.8  история и литература\n"
"  * 20.9  упражнения\n"
"  * 20.10 ответы\n"
"- **21 Грамматика английского языка **\n"
"   * 21.1 Фразы существительных\n"
"   * 21.2 Модификаторы\n"
"   * 21.3 Модификаторы существительных\n"
"   * 21.4 Определители\n"
"   * 21,5 Глагольные фразы\n"
"   * 21,6 Наречия\n"
"   * 21,7 Предложения\n"
"   * 21,8 Изречения\n"
"   * 21,9 XPs\n"
"   * 21.10 Категории слов\n"
"   * 21.11 Лексикон\n"
"       * Глаголы\n"
"       * Вспомогательные глаголы\n"
"       * Существительные\n"
"       * Местоимения\n"
"       * Имена\n"
"       * Прилагательные\n"
"       * Наречия\n"
"       * Артикли\n"
"       * Кардинальные и Порядковые Числа\n"
"       * Предлоги\n"
"   * 21.12 Поддержка лексики\n"
"   * 21.13 Другие примитивы\n"
"   * 21.14 Примеры\n"
"   * 21.15 История и ссылки\n"
"   * 21.16 Упражнение\n"
"- **Part V  Остальная часть Лиспа **\n"
"- ** 22 Scheme: необычный Лисп **\n"
"   * 22.1 Интерпретатор Scheme\n"
"   * 22.2 Синтаксическое расширение с помощью макросов\n"
"   * 22.3 Правильный интерпретатор хвостовой рекурсии\n"
"   * 22.4 Throw, Catch и Call/cc\n"
"   * 22.5 Интерпретатор поддерживающий Call/CC\n"
"   * 22.6 История и ссылки\n"
"   * 22.7 Упражнения\n"
"   * 22.8 ответы\n"
"- **23  Компиляция Лисп**\n"
"   * 23.1. Правильно обрабатывающий хвостовую рекурсию компилятор Lisp\n"
"   * 23.2 Введение в Call/CC\n"
"   * 23.3 Абстрактная машина\n"
"   * 23.4 Оптимизатор Peephole(Смотрового отверстия)\n"
"   * 23.5 Языки с различными лексическими соглашениями\n"
"   * 23.6 История и ссылки\n"
"   * 23.7 Упражнения\n"
"   * 23.8 ответы\n"
"- **24  ANSI Common Lisp**\n"
"   * 24.1  Пакеты\n"
"       * Семь Пространств Имен\n"
"   * 24.2 Условия и обработка ошибок\n"
"       * Сигналы об шибках\n"
"       * Обработка ошибок\n"
"   * 24.3 Симпатичная печать\n"
"   * 24,4 Последовательности\n"
"   * 24.5 Макрос Loop(петля)\n"
"       * Анатомия Loop\n"
"       * Контроль итераций (26.6)\n"
"       * Контроль проверки завершения (26.7)\n"
"       * Значение Аккумулятора (26.8)\n"
"       * Инициализация переменной (26,9)\n"
"       * Условное исполнение (26.10)\n"
"       * Безусловное выполнение (26.11)\n"
"       * Разные особенности (26.12)\n"
"   * 24.6 Функции работы с последовательностями\n"
"       * Один раз: урок науки о макросах(Macrology)\n"
"       * Избегайте чрезмерного использования макросов\n"
"       * MAP-INTO\n"
"       * REDUCE с :key\n"
"   * 24.7 Упражнения\n"
"   * 24.8 ответы\n"
"- **25  Решение проблем**\n"
"   * 25.1  Ничего Не Происходит\n"
"   * 25.2  изменение переменной не имеет никакого эффекта\n"
"   * 25.3  изменение функции не имеет никакого эффекта\n"
"   * 25.4  значения меняются \"сами по себе\".;\n"
"   * 25.5  встроенные функции не находят элементы\n"
"   * 25.6  Несколько Значений Теряются\n"
"   * 25.7  Декларации Игнорируются\n"
"   * 25.8  мой Лисп делает что-то не так\n"
"   * 25.9  как найти нужную функцию\n"
"   * 25.10 синтаксис LOOP\n"
"   * 25.11 синтаксис COND\n"
"   * 25.12 синтаксис CASE\n"
"   * 25.13 синтаксис LET и LET*\n"
"   * 25.14 проблемы с макросами\n"
"   * 25.15 руководство по стилю Lisp\n"
"       * Для определения функции\n"
"       * Когда следует определить специальную переменную\n"
"       * Когда связывать лексическую переменную\n"
"       * Как выбрать имя\n"
"       * Принятие решения о порядке следования параметров\n"
"   * 25.16 работа с файлами, пакетами и системами\n"
"   * 25.17 Проблемы Переносимости\n"
"   * 25.18 упражнения\n"
"   * 25.19 ответы\n"
"- Приложение\n"
"- Библиография\n"
"- Индекс"
