#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter11.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-04 09:39+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter11.md:3
msgid ""
"# Chapter 11\n"
"## Logic Programming"
msgstr ""
"# Глава 11\n"
"## Логическое Программирование"

#: in/chapter11.md:5
msgid ""
"> A language that doesn't affect the way you think about programming is not "
"worth knowing."
msgstr ""
"> Не стоит знать язык, который не влияет на ваше представление о "
"программировании."

#: in/chapter11.md:7
msgid "> -Alan Perlis"
msgstr ""

#: in/chapter11.md:14
msgid ""
"Lisp is the major language for AI work, but it is by no means the only one.\n"
"The other strong contender is Prolog, whose name derives from \"programming "
"in logic.\"[1](#fn0015) The idea behind logic programming is that the "
"programmer should state the relationships that describe a problem and its "
"solution.\n"
"These relationships act as constraints on the algorithms that can solve the "
"problem, but the system itself, rather than the programmer, is responsible "
"for the details of the algorithm.\n"
"The tension between the \"programming\" and \"logic\" will be covered in "
"[chapter 14](B9780080571157500145.xhtml), but for now it is safe to say that "
"Prolog is an approximation to the ideal goal of logic programming.\n"
"Prolog has arrived at a comfortable niche between a traditional programming "
"language and a logical specification language.\n"
"It relies on three important ideas:"
msgstr ""
"Lisp-это основной язык для работы с ИИ, но он ни в коем случае не "
"единственный.\n"
"Другой сильный соперник-Пролог, название которого происходит от "
"\"программирование основанное на логике\". [1](#fn0015) идея логического "
"программирования заключается в том, что программист должен сформулировать "
"отношения, описывающие проблему и ее решение.\n"
"Эти отношения действуют как ограничения на алгоритмы, которые могут решить "
"проблему, но сама система, а не программист, отвечает за детали алгоритма.\n"
"Напряженность между \"программированием\" и \"логикой\" будет рассмотрена в "
"[главе 14](B9780080571157500145.xhtml), но пока можно с уверенностью "
"сказать, что пролог является приближением к идеальной цели логического "
"программирования.\n"
"Пролог занял удобную нишу между традиционным языком программирования и "
"языком логических спецификаций.\n"
"Он опирается на три важные идеи:"

#: in/chapter11.md:19
msgid ""
"*   Prolog encourages the use of a single *uniform data base.* Good "
"compilers provide efficient access to this data base, reducing the need for "
"vectors, hash tables, property lists, and other data structures that the "
"Lisp programmer must deal with in detail.\n"
"Because it is based on the idea of a data base, Prolog is *relational,* "
"while Lisp (and most languages) are *functional.* In Prolog we would "
"represent a fact like \"the population of San Francisco is 750,000\" as a "
"relation.\n"
"In Lisp, we would be inclined to write a function, `population,` which takes "
"a city as input and returns a number.\n"
"Relations are more flexible; they can be used not only to find the "
"population of San Francisco but also, say, to find the cities with "
"populations over 500,000."
msgstr ""
"*   Prolog поощряет использование единой *унифицированной/универсальной/"
"единой базы данных. Хорошие компиляторы обеспечивают эффективный доступ к "
"этой базе данных, уменьшая потребность в векторах, хэш-таблицах, списках "
"свойств и других структурах данных, с которыми программист Lisp должен иметь "
"дело подробно.\n"
"Потому что он основан на идее баз данных, Пролог *реляционнен*, в то время "
"как Лисп (и многие языки) *функциональны.* В прологе мы будем представлять "
"то, как \"население Сан-Франциско составляет 750000\" как отношение.\n"
"В Лиспе мы были бы склонны написать функцию `population(население), которая "
"принимает город в качестве входных данных и возвращает число.\n"
"Отношения более гибкие; их можно использовать не только для поиска населения "
"Сан-Франциско, но и, скажем, для поиска городов с населением более 500 000 "
"человек."

#: in/chapter11.md:25
msgid ""
"*   Prolog provides *logic variables* instead of \"normal\" variables.\n"
"A logic variable is bound by *unification* rather than by assignment.\n"
"Once bound, a logic variable can never change.\n"
"Thus, they are more like the variables of mathematics.\n"
"The existence of logic variables and unification allow the logic programmer "
"to state equations that constrain the problem (as in mathematics), without "
"having to state an order of evaluation (as with assignment statements)."
msgstr ""
"*   Пролог предоставляет *логические переменные* вместо \"обычных\" "
"переменных.\n"
"Логическая переменная связана с *унификацией/универсальностью*, а не с "
"присвоением.\n"
"Однажды связанная логическая переменная никогда не может измениться.\n"
"Таким образом, они больше похожи на переменные математики.\n"
"Существование логических переменных и унификация(единая база данных) "
"позволяют логическому программисту формулировать уравнения, ограничивающие "
"задачу (как в математике), без необходимости указывать порядок вычислений "
"(как в операторах присваивания)."

#: in/chapter11.md:35
msgid ""
"*   Prolog provides *automatic backtracking.* In Lisp each function call "
"returns a single value (unless the programmer makes special arrangements to "
"have it return multiple values, or a list of values).\n"
"In Prolog, each query leads to a search for relations in the data base that "
"satisfy the query.\n"
"If there are several, they are considered one at a time.\n"
"If a query involves multiple relations, as in \"what city has a population "
"over 500,000 and is a state capital?,\" Prolog will go through the "
"population relation to find a city with a population over 500,000.\n"
"For each one it finds, it then checks the `capital` relation to see if the "
"city is a capital.\n"
"If it is, Prolog prints the city; otherwise it *backtracks,* trying to find "
"another city in the `population` relation.\n"
"So Prolog frees the programmer from worrying about both how data is stored "
"and how it is searched.\n"
"For some problems, the naive automatic search will be too inefficient, and "
"the programmer will have to restate the problem.\n"
"But the ideal is that Prolog programs state constraints on the solution, "
"without spelling out in detail how the solutions are achieved."
msgstr ""
"*   Prolog обеспечивает *автоматический поиск с возвратом.* В Лиспе каждый "
"вызов функции возвращает одно значение (если только программист не принимает "
"специальные меры, чтобы он возвращал несколько значений или список "
"значений).\n"
"В Prolog каждый запрос приводит к поиску отношений в базе данных, которые "
"удовлетворяют запросу.\n"
"Если их несколько, они считаются по одному.\n"
"Если запрос включает несколько отношений, например, \"какой город с "
"населением более 500 000 и является столицей штата?\", Prolog просмотрит "
"отношение \"население\", чтобы найти город с населением более 500 000 "
"человек.\n"
"Затем для каждого найденного города он проверяет отношение \"capital"
"\"(столица), чтобы узнать, является ли город столицей.\n"
"Если это так, Prolog печатает город; в противном случае он *возвращается "
"назад,* пытается найти другой город в отношении \"население\".\n"
"Таким образом, Prolog освобождает программиста от забот как о том, как "
"хранятся данные, так и о том, как их искать.\n"
"Для некоторых проблем наивный автоматический поиск будет слишком "
"неэффективным, и программисту придется переформулировать проблему.\n"
"Но в идеале программа Prolog устанавливает ограничения для решения, не "
"указывая в деталях, как решения достигаются."

#: in/chapter11.md:40
msgid ""
"This chapter serves two purposes: it alerts the reader to the possibility of "
"writing certain programs in Prolog rather than Lisp, and it presents "
"implementations of the three important Prolog ideas, so that they may be "
"used (independently or together) within Lisp programs.\n"
"Prolog represents an interesting, different way of looking at the "
"programming process.\n"
"For that reason it is worth knowing.\n"
"In subsequent chapters we will see several useful applications of the Prolog "
"approach."
msgstr ""
"Эта глава служит двум целям: она предупреждает читателя о возможности "
"написания определенных программ на Prolog, а не на Lisp, и представляет "
"реализации трех важных идей Prolog, чтобы их можно было использовать "
"(независимо или вместе) в программах на Lisp.\n"
"Пролог представляет собой интересный, иной взгляд на процесс "
"программирования.\n"
"По этой причине это стоит знать.\n"
"В следующих главах мы увидим несколько полезных приложений подхода Пролога."

#: in/chapter11.md:42
msgid "## 11.1 Idea 1: A Uniform Data Base"
msgstr "## 11.1 Идея 1: Единая/Универсальная база данных"

#: in/chapter11.md:47
msgid ""
"The first important Prolog idea should be familiar to readers of this book: "
"manipulating a stored data base of assertions.\n"
"In Prolog the assertions are called *clauses,* and they can be divided into "
"two types: *facts,* which state a relationship that holds between some "
"objects, and *rules,* which are used to state contingent facts.\n"
"Here are representations of two facts about the population of San Francisco "
"and the capital of California.\n"
"The relations are `population` and `capital,` and the objects that "
"participate in these relations are `SF, 750000`, `Sacramento,` and `CA`:"
msgstr ""
"Первая важная идея Пролога должна быть знакома читателям этой книги: "
"манипулирование хранимой базой данных утверждений.\n"
"В Прологе утверждения называются *предложениями*(clauses), и их можно "
"разделить на два типа: *факты*(facts), которые устанавливают отношения, "
"которые имеют место между некоторыми объектами, и *правила*(rules), которые "
"используются для утверждения случайных фактов.\n"
"Вот изображения двух фактов о населении Сан-Франциско и столицы Калифорнии.\n"
"Отношениями являются \"население\" и \"столица\", а объектами, которые "
"участвуют в этих отношениях, являются `SF, 750000`, `Sacramento` и `CA`:"

#: in/chapter11.md:52
msgid ""
"```lisp\n"
"(population SF 750000)\n"
"(capital Sacramento CA)\n"
"```"
msgstr ""

#: in/chapter11.md:56
msgid ""
"We are using Lisp syntax, because we want a Prolog interpreter that can be "
"embedded in Lisp.\n"
"The actual Prolog notation would be `population` (`sf, 750000`).\n"
"Here are some facts pertaining to the `likes` relation:"
msgstr ""
"Мы используем синтаксис Лиспа, потому что нам нужен интерпретатор Пролога, "
"который можно встроить в Лисп.\n"
"Реальная нотация Пролога будет `population` (`sf, 750000`).\n"
"Вот несколько фактов, касающихся отношения `likes`(любит):"

#: in/chapter11.md:63
msgid ""
"```lisp\n"
"(likes Kim Robin)\n"
"(likes Sandy Lee)\n"
"(likes Sandy Kim)\n"
"(likes Robin cats)\n"
"```"
msgstr ""

#: in/chapter11.md:68
msgid ""
"These facts could be interpreted as meaning that Kim likes Robin, Sandy "
"likes both Lee and Kim, and Robin likes cats.\n"
"We need some way of telling Lisp that these are to be interpreted as Prolog "
"facts, not a Lisp function call.\n"
"We will use the macro <- to mark facts.\n"
"Think of this as an assignment arrow which adds a fact to the data base:"
msgstr ""
"Эти факты можно истолковать как означающие, что Ким нравится Робин, Сэнди "
"нравятся и Ли, и Ким, а Робин любит кошек.\n"
"Нам нужен какой-то способ сообщить Лиспу, что они должны интерпретироваться "
"как факты Пролога, а не как вызов функции Лисп.\n"
"Мы будем использовать макрос <-, чтобы отмечать факты.\n"
"Думайте об этом как о стрелке назначения/присваивания, которая добавляет "
"факт в базу данных:"

#: in/chapter11.md:75
msgid ""
"```lisp\n"
"(<- (likes Kim Robin))\n"
"(<- (likes Sandy Lee))\n"
"(<- (likes Sandy Kim))\n"
"(<- (likes Robin cats))\n"
"```"
msgstr ""

#: in/chapter11.md:82
msgid ""
"One of the major differences between Prolog and Lisp hinges on the "
"difference between relations and functions.\n"
"In Lisp, we would define a function `likes`, so that (`likes 'Sandy`) would "
"return the list (`Lee Kim`).\n"
"If we wanted to access the information the other way, we would define "
"another function, say, `likers-of`, so that (`likers-of 'Lee`) returns "
"(`Sandy`).\n"
"In Prolog, we have a single `likes` relation instead of multiple functions.\n"
"This single relation can be used as if it were multiple functions by posing "
"different queries.\n"
"For example, the query (`likes Sandy ?who`) succeeds with `?who` bound to "
"`Lee or Kim`, and the query (`likes ?who Lee`) succeeds with `?who` bound to "
"`Sandy.`"
msgstr ""
"Одно из основных различий между Prolog и Lisp зависит от разницы между "
"отношениями и функциями.\n"
"В Лиспе мы бы определили функцию `любит`, чтобы (` любит 'Sandy`) возвращал "
"список (`Lee Kim`).\n"
"Если бы мы хотели получить доступ к информации другим способом, мы бы "
"определили другую функцию, скажем, `likers-of`, чтобы (` likers-of 'Lee`) "
"возвращал (`Sandy`).\n"
"В Прологе у нас есть одно отношение `likes` вместо нескольких функций.\n"
"Это единственное отношение можно использовать, как если бы оно было "
"множеством функций, создавая разные запросы.\n"
"Например, запрос (`likes Sandy ?who`) удовлетворяется с помощью `?who`, "
"привязанному к `Lee или Kim`, а запрос (` like ?who `Lee`) удовлетворяется с "
"`?Who` привязанному к `Sandy`."

#: in/chapter11.md:85
msgid ""
"The second type of clause in a Prolog data base is the *rule.* Rules state "
"contingent facts.\n"
"For example, we can represent the rule that Sandy likes anyone who likes "
"cats as follows:"
msgstr ""
"Второй тип предложения в базе данных Пролога - это  *правило.* Правила "
"устанавливают условные факты.\n"
"Например, мы можем представить правило, согласно которому Сэнди любит всех, "
"кто любит кошек, следующим образом:"

#: in/chapter11.md:89
msgid ""
"```lisp\n"
"(<- (likes Sandy ?x) (likes ?x cats))\n"
"```"
msgstr ""

#: in/chapter11.md:95
msgid ""
"This can be read in two ways.\n"
"Viewed as a logical assertion, it is read, \"For any x, Sandy likes x if x "
"likes cats.\" This is a *declarative* interpretation.\n"
"Viewed as a piece of a Prolog program, it is read, \"If you ever want to "
"show that Sandy likes some x, one way to do it is to show that x likes cats."
"\" This is a *procedural* interpretation.\n"
"It is called a *backward-chaining* interpretation, because one reasons "
"backward from the goal (Sandy likes x) to the premises (x likes cats).\n"
"The symbol <- is appropriate for both interpretations: it is an arrow "
"indicating logical implication, and it points backwards to indicate backward "
"chaining."
msgstr ""
"Это можно прочесть двояко.\n"
"Рассматриваемое как логическое утверждение, оно читается: \"Для любого x "
"Сэнди любит x, если x любит кошек\". Это *декларативная* интерпретация.\n"
"Рассматриваемое как часть программы на Прологе, оно читается так: \"Если вы "
"когда-нибудь захотите показать, что Сэнди нравится какой-то x, один из "
"способов сделать это - показать, что x любит кошекА\". Это *процедурная* "
"интерпретация. \n"
"Она называется интерпретацией *обратной цепочки*, потому что человек "
"рассуждает в обратном направлении от цели (Сэнди любит x) к предпосылкам (x "
"любит кошек).\n"
"Символ <- подходит для обеих интерпретаций: это стрелка, указывающая на "
"логический смысл, и она указывает назад, чтобы указать обратную цепочку."

#: in/chapter11.md:100
msgid ""
"It is possible to give more than one procedural interpretation to a "
"declarative form.\n"
"(We did that in [chapter 1](B9780080571157500017.xhtml), where grammar rules "
"were used to generate both strings of words and parse trees.) The rule above "
"could have been interpreted procedurally as \"If you ever find out that some "
"`x` likes cats, then conclude that Sandy likes `x`.\" This would be *forward "
"chaining:* reasoning from a premise to a conclusion.\n"
"It turns out that Prolog does backward chaining exclusively.\n"
"Many expert systems use forward chaining exclusively, and some systems use a "
"mixture of the two."
msgstr ""
"Декларативная форма может дать более одной процедурной интерпретации.\n"
"(Мы сделали это в [главе 1](B9780080571157500017.xhtml), где правила "
"грамматики использовались для генерации как строк слов, так и деревьев "
"синтаксического анализа.) Приведенное выше правило могло быть "
"интерпретировано процедурно как \"Если вы когда-нибудь обнаружите, что какой-"
"то `x` любит кошек, значит, Сэнди любит `x` \". Это будет *прямая цепочка:* "
"рассуждение от предпосылки к выводу.\n"
"Оказывается, Пролог выполняет исключительно обратную цепочку.\n"
"Многие экспертные системы используют исключительно прямую цепочку, а "
"некоторые системы используют их сочетание."

#: in/chapter11.md:103
msgid ""
"The leftmost expression in a clause is called the *head*, and the remaining "
"ones are called the *body.* In this view, a fact is just a rule that has no "
"body; that is, a fact is true no matter what.\n"
"In general, then, the form of a clause is:"
msgstr ""
"Крайнее левое выражение в предложении называется *заголовком*, а остальные - "
"*телом*. В этом представлении факт - это просто правило, не имеющее тела; то "
"есть факт верен, несмотря ни на что.\n"
"В общем, формулировка предложения следующая:"

#: in/chapter11.md:105
msgid "(<- *head body*...)"
msgstr ""

#: in/chapter11.md:108
msgid ""
"A clause asserts that the head is true only if all the goals in the body are "
"true.\n"
"For example, the following clause says that Kim likes anyone who likes both "
"Lee and Kim:"
msgstr ""
"В предложении утверждается, что голова верна только в том случае, если все "
"цели в теле верны.\n"
"Например, в следующем пункте говорится, что Ким нравятся все, кому нравятся "
"и Ли, и Ким:"

#: in/chapter11.md:112
msgid ""
"```lisp\n"
"(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))\n"
"```"
msgstr ""

#: in/chapter11.md:114
msgid "This can be read as:"
msgstr "Это можно читать так:"

#: in/chapter11.md:116
msgid "*For any* x, *deduce that*`Kim likes x`"
msgstr ""
"*For any* x, *deduce that*`Kim likes x`(*Для любого* x, *вывести, что* `Ким "
"любит x`)"

#: in/chapter11.md:118
msgid "*if it can be proved that*`x likes Lee`*and* x `likes Kim.`"
msgstr ""
"*if it can be proved that*`x likes Lee`*and* x `likes Kim.` (*если можно "
"доказать, что* `x любит Ли` *и* x `любит Ким`.)"

#: in/chapter11.md:120
msgid "## 11.2 Idea 2: Unification of Logic Variables"
msgstr "## 11.2 Идея 2: Унификация логических переменных"

#: in/chapter11.md:125
msgid ""
"Unification is a straightforward extension of the idea of pattern matching.\n"
"The pattern-matching functions we have seen so far have always matched a "
"pattern (an expression containing variables) against a constant expression "
"(one with no variables).\n"
"In unification, two patterns, each of which can contain variables, are "
"matched against each other.\n"
"Here's an example of the difference between pattern matching and unification:"
msgstr ""
"Унификация - это прямое расширение идеи сопоставления с образцом.\n"
"Функции сопоставления с образцом, которые мы видели до сих пор, всегда "
"сопоставляли образец (выражение, содержащее переменные) с постоянным "
"выражением (без переменных).\n"
"При унификации два образца(шаблона), каждый из которых может содержать "
"переменные, сопоставляются друг с другом.\n"
"Вот пример разницы между сопоставлением с образцом и объединением:"

#: in/chapter11.md:127
msgid "`> (pat-match '(?x + ?y) '(2 + 1))`=> `((?Y . 1) (?X . 2))`"
msgstr ""

#: in/chapter11.md:129
msgctxt "in/chapter11.md:129"
msgid "`> (unify '(?x + 1) '(2 + ?y))`=> `((?Y . 1) (?X . 2))`"
msgstr ""

#: in/chapter11.md:135
msgid ""
"Within the unification framework, variables (such as `?x` and `?y` above) "
"are called *logic variables.* Like normal variables, a logic variable can be "
"assigned a value, or it can be unbound.\n"
"The difference is that a logic variable can never be altered.\n"
"Once it is assigned a value, it keeps that value.\n"
"Any attempt to unify it with a different value leads to failure.\n"
"It is possible to unify a variable with the same value more than once, just "
"as it was possible to do a pattern match of `(?x + ?x`) with (`2 + 2`)."
msgstr ""
"В рамках унификации переменные (например, `?x` и `?y` выше) называются "
"*логическими переменными*. Как и обычным переменным, логической переменной "
"может быть присвоено значение или она может быть несвязанной.\n"
"Разница в том, что логическая переменная никогда не может быть изменена.\n"
"Как только ей присвоено значение, она сохраняет это значение.\n"
"Любая попытка унифицировать его с другим значением приводит к неудаче.\n"
"Можно объединить(унифицировать) переменную с одним и тем же значением более "
"одного раза, точно так же, как можно было выполнить сопоставление с образцом "
"(?x + ?x) с (`2 + 2`)."

#: in/chapter11.md:140
msgid ""
"The difference between simple pattern matching and unification is that "
"unification allows two variables to be matched against each other.\n"
"The two variables remain unbound, but they become equivalent.\n"
"If either variable is subsequently bound to a value, then both variables "
"adopt that value.\n"
"The following example equates the variables `?x` and `?y` by binding `?x` to "
"`?y`:"
msgstr ""
"Разница между простым сопоставлением с образцом и унификацией заключается в "
"том, что унификация позволяет сравнивать/сопоставлять две переменные друг с "
"другом.\n"
"Две переменные останутся несвязанными, но становятся эквивалентными.\n"
"Если какая-либо переменная впоследствии связывается со значением, то обе "
"переменные принимают это значение.\n"
"В следующем примере переменные `?x` и `?y` сравниваются путем привязки `?x` "
"к `?y`:"

#: in/chapter11.md:142
msgid "`> (unify '(f ?x) '(f ?y))`=> `((?X . ?Y))`"
msgstr ""

#: in/chapter11.md:147
msgid ""
"Unification can be used to do some sophisticated reasoning.\n"
"For example, if we have two equations, *a* + *a* = 0 and *x* + *y* = *y,* "
"and if we know that these two equations unify, then we can conclude that "
"*a*, *x,* and *y* are all 0.\n"
"The version of `unify` we will define shows this result by binding `?y` to "
"`0`, `?x` to `?y`, and `?a` to `?x`.\n"
"We will also define the function `unifier`, which shows the structure that "
"results from unifying two structures."
msgstr ""
"Унификацию(Объединение) можно использовать для сложных рассуждений.\n"
"Например, если у нас есть два уравнения, *a* + *a* = 0 и *x* + *y* = *y* и "
"если мы знаем, что эти два уравнения объединяются(унифицируются), то мы "
"можем заключить, что *a*, *x* и *y* равны 0.\n"
"Версия `unify`, которую мы определим, показывает этот результат путем "
"привязки `?y` к `0`,`?x` к `?y` и `?a` к `?x`.\n"
"Мы также определим функцию `unifier`, которая показывает структуру, "
"полученную в результате объединения(унификации) двух структур."

#: in/chapter11.md:149
msgid "`> (unify '(?a + ?a = 0) '(?x + ?y = ?y))`=>"
msgstr ""

#: in/chapter11.md:153
msgid ""
"```lisp\n"
"((?Y . 0) (?X . ?Y) (?A . ?X))\n"
"```"
msgstr ""

#: in/chapter11.md:155
msgid "`> (unifier '(?a + ?a = 0) '(?x + ?y = ?y))`=> `(0 + 0 = 0)`"
msgstr ""

#: in/chapter11.md:160
msgid ""
"To avoid getting carried away by the power of unification, it is a good idea "
"to take stock of exactly what unification provides.\n"
"It *does* provide a way of stating that variables are equal to other "
"variables or expressions.\n"
"It does *not* provide a way of automatically solving equations or applying "
"constraints other than equality.\n"
"The following example makes it clear that unification treats the symbol + "
"only as an uninterpreted atom, not as the addition operator:"
msgstr ""
"Чтобы не увлечься силой унификации(объединения), рекомендуется "
"проанализировать, что именно дает унификация.\n"
"Она *действительно* предоставляет способ заявить, что переменные равны "
"другим переменным или выражениям.\n"
"Она *не* обеспечивает способ автоматического решения уравнений или "
"применения ограничений, отличных от равенства.\n"
"Следующий пример проясняет, что при унификации символ + рассматривается "
"только как неинтерпретированный атом, а не как оператор сложения:"

#: in/chapter11.md:162
msgid "`> (unifier '(?a + ?a = 2) '(?x + ?y = ?y))`=> `(2 + 2 = 2)`"
msgstr ""

#: in/chapter11.md:164
msgid ""
"Before developing the code for `unify`, we repeat here the code taken from "
"the pattern-matching utility ([chapter 6](B9780080571157500066.xhtml)):"
msgstr ""
"Перед разработкой кода для `unify`, мы повторяем здесь код, взятый из "
"утилиты сопоставления с образцом ([глава 6](B9780080571157500066.xhtml)):"

#: in/chapter11.md:196
msgid ""
"```lisp\n"
"(defconstant fail nil \"Indicates pat-match failure\")\n"
"(defconstant no-bindings '((t . t))\n"
"  \"Indicates pat-match success, with no variables.\")\n"
"(defun variable-p (x)\n"
"  \"Is x a variable (a symbol beginning with '?')?\"\n"
"  (and (symbolp x) (equal (char (symbol-name x) 0) #\\?)))\n"
"(defun get-binding (var bindings)\n"
"  \"Find a (variable . value) pair in a binding list.\"\n"
"  (assoc var bindings))\n"
"(defun binding-val (binding)\n"
"  \"Get the value part of a single binding.\"\n"
"  (cdr binding))\n"
"(defun lookup (var bindings)\n"
"  \"Get the value part (for var) from a binding list.\"\n"
"  (binding-val (get-binding var bindings)))\n"
"(defun extend-bindings (var val bindings)\n"
"  \"Add a (var . value) pair to a binding list.\"\n"
"  (cons (cons var val)\n"
"              ;; Once we add a \"real\" binding,\n"
"              ;; we can get rid of the dummy no-bindings\n"
"              (if (and (eq bindings no-bindings))\n"
"                      nil\n"
"                      bindings)))\n"
"(defun match-variable (var input bindings)\n"
"  \"Does VAR match input? Uses (or updates) and returns bindings.\"\n"
"  (let ((binding (get-binding var bindings)))\n"
"  (cond ((not binding) (extend-bindings var input bindings))\n"
"              ((equal input (binding-val binding)) bindings)\n"
"              (t fail))))\n"
"```"
msgstr ""

#: in/chapter11.md:199
msgid ""
"The `unify` function follows; it is identical to `pat-match` (as defined on "
"page 180) except for the addition of the line marked `***`.\n"
"The function `unify-variable` also follows `match-variable` closely:"
msgstr ""
"Далее следует функция `unify`; она идентична `pat-match` (как определено на "
"стр. 180), за исключением добавления строки, отмеченной `***`.\n"
"Функция `unify-variable` также следует за функцией `match-variable`:"

#: in/chapter11.md:218
msgid ""
"```lisp\n"
"(defun unify (x y &optional (bindings no-bindings))\n"
"  \"See if x and y match with given bindings.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"              ((variable-p x) (unify-variable x y bindings))\n"
"              ((variable-p y) (unify-variable y x bindings)) ;***\n"
"              ((eql x y) bindings)\n"
"              ((and (consp x) (consp y))\n"
"                (unify (rest x) (rest y)\n"
"                              (unify (first x) (first y) bindings)))\n"
"              (t fail)))\n"
"(defun unify-variable (var x bindings)\n"
"  \"Unify var with x, using (and maybe extending) bindings.\"\n"
"  ;; Warning - buggy version\n"
"  (if (get-binding var bindings)\n"
"    (unify (lookup var bindings) x bindings)\n"
"    (extend-bindings var x bindings)))\n"
"```"
msgstr ""

#: in/chapter11.md:221
msgid ""
"Unfortunately, this definition is not quite right.\n"
"It handles simple examples:"
msgstr ""
"К сожалению, это определение не совсем верное.\n"
"Оно обрабатывает простые примеры:"

#: in/chapter11.md:223
msgctxt "in/chapter11.md:223"
msgid "`> (unify '(?x + 1) '(2 + ?y))`=> `((?Y . 1) (?X . 2))`"
msgstr ""

#: in/chapter11.md:225
msgid "`> (unify '?x '?y)`=> `((?X . ?Y))`"
msgstr ""

#: in/chapter11.md:227
msgid "`> (unify '(?x ?x) '(?y ?y))`=> `((?Y . ?Y) (?X . ?Y))`"
msgstr ""

#: in/chapter11.md:229
msgid "but there are several pathological cases that it can't contend with:"
msgstr ""
"но есть несколько патологических случаев, с которыми оно не может бороться:"

#: in/chapter11.md:235
msgid ""
"```lisp\n"
"> (unify '(?x ?x ?x) '(?y ?y ?y))\n"
">>Trap #043622 (PDL-OVERFLOW REGULAR)\n"
"The regular push-down list has overflowed.\n"
"```"
msgstr ""

#: in/chapter11.md:237
msgctxt "in/chapter11.md:237"
msgid "`While in the function GET-BINDING`<= `UNIFY-VARIABLE`<= `UNIFY`"
msgstr ""

#: in/chapter11.md:241
msgid ""
"The problem here is that once `?y` gets bound to itself, the call to `unify` "
"inside `unify-variable` leads to an infinite loop.\n"
"But matching `?y` against itself must always succeed, so we can move the "
"equality test in `unify` before the variable test.\n"
"This assumes that equal variables are `eql`, a valid assumption for "
"variables implemented as symbols (but be careful if you ever decide to "
"implement variables some other way)."
msgstr ""
"Проблема здесь в том, что как только `?y` привязывается к самому себе, вызов "
"`unify` внутри `unify-variable` приводит к бесконечному циклу.\n"
"Но сопоставление `?y` с самим собой всегда должно быть успешным, поэтому мы "
"можем переместить проверку равенства в `unify` перед проверкой переменной.\n"
"Это предполагает, что равные переменные - это `eql`, допустимое "
"предположение для переменных, реализованных как символы (но будьте "
"осторожны, если вы когда-нибудь решите реализовать переменные каким-либо "
"другим способом)."

#: in/chapter11.md:254
msgid ""
"```lisp\n"
"(defun unify (x y &optional (bindings no-bindings))\n"
"  \"See if x and y match with given bindings.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"    ((eql x y) bindings) ;*** moved this line\n"
"    ((variable-p x) (unify-variable x y bindings))\n"
"    ((variable-p y) (unify-variable y x bindings))\n"
"    ((and (consp x) (consp y))\n"
"    (unify (rest x) (rest y)\n"
"            (unify (first x) (first y) bindings)))\n"
"      (t fail)))\n"
"```"
msgstr ""

#: in/chapter11.md:256
msgid "Here are some test cases:"
msgstr "Вот несколько тестов:"

#: in/chapter11.md:258
msgid "`> (unify '(?x ?x) '(?y ?y))`=> `((?X . ?Y))`"
msgstr ""

#: in/chapter11.md:260
msgid "`> (unify '(?x ?x ?x) '(?y ?y ?y))`=> `((?X . ?Y))`"
msgstr ""

#: in/chapter11.md:262
msgid "`> (unify '(?x ?y) '(?y ?x))`=> `((?Y . ?X) (?X . ?Y))`"
msgstr ""

#: in/chapter11.md:268
msgid ""
"```lisp\n"
"> (unify '(?x ?y a) '(?y ?x ?x))\n"
">>Trap #043622 (PDL-OVERFLOW REGULAR)\n"
"The regular push-down list has overflowed.\n"
"```"
msgstr ""

#: in/chapter11.md:270
msgctxt "in/chapter11.md:270"
msgid "`While in the function GET-BINDING`<= `UNIFY-VARIABLE`<= `UNIFY`"
msgstr ""

#: in/chapter11.md:276
msgid ""
"We have pushed off the problem but not solved it.\n"
"Allowing both `(?Y . ?X`) and (`?X . ?Y`) in the same binding list is as bad "
"as allowing (`?Y . ?Y`).\n"
"To avoid the problem, the policy should be never to deal with bound "
"variables, but rather with their values, as specified in the binding list.\n"
"The function `unify-variable` fails to implement this policy.\n"
"It does have a check that gets the binding for var when it is a bound "
"variable, but it should also have a check that gets the value of `x`, when "
"`x` is a bound variable:"
msgstr ""
"Мы отодвинули проблему, но не решили ее.\n"
"Разрешить и `(?y . ?y)`, и `(?x . ?y)` в одном списке привязки так же плохо, "
"как разрешить `(?y . ?y)`.\n"
"Чтобы избежать этой проблемы, политика не должна иметь дело с привязанными "
"переменными, а должна иметь дело с их значениями, как указано в списке "
"привязки.\n"
"Функция `unify-variable` не может реализовать эту политику.\n"
"У неё есть проверка, которая получает привязку для var, когда это связанная "
"переменная, но также должна быть проверка, которая получает значение `x`, "
"когда` x` является связанной переменной:"

#: in/chapter11.md:286
msgid ""
"```lisp\n"
"(defun unify-variable (var x bindings)\n"
"  \"Unify var with x, using (and maybe extending) bindings.\"\n"
"  (cond ((get-binding var bindings)\n"
"      (unify (lookup var bindings) x bindings))\n"
"    ((and (variable-p x) (get-binding x bindings)) ;***\n"
"      (unify var (lookup x bindings) bindings)) ;***\n"
"    (t (extend-bindings var x bindings))))\n"
"```"
msgstr ""

#: in/chapter11.md:288
msgid "Here are some more test cases:"
msgstr "Вот еще несколько тестовых примеров:"

#: in/chapter11.md:290
msgid "`> (unify '(?x ?y) '(?y ?x))`=> `((?X . ?Y))`"
msgstr ""

#: in/chapter11.md:292
msgctxt "in/chapter11.md:292"
msgid "`> (unify '(?x ?y a) '(?y ?x ?x))`=> `((?Y . A) (?X . ?Y))`"
msgstr ""

#: in/chapter11.md:295
msgid ""
"It seems the problem is solved.\n"
"Now let's try a new problem:"
msgstr ""
"Вроде проблема решена.\n"
"Теперь попробуем новую задачу:"

#: in/chapter11.md:297
msgctxt "in/chapter11.md:297"
msgid "`> (unify '?x '(f ?x))`=> `((?X F ?X))`"
msgstr ""

#: in/chapter11.md:302
msgid ""
"Here `((?X F ?X))` really means `((?X . ((F ?X))))`, so `?X` is bound to "
"(`F ?X`).\n"
"This represents a circular, infinite unification.\n"
"Some versions of Prolog, notably Prolog II ([Giannesini et al.\n"
"1986](B9780080571157500285.xhtml#bb0460)), provide an interpretation for "
"such structures, but it is tricky to define the semantics of infinite "
"structures."
msgstr ""
"Здесь `((?X F ?X))` действительно означает `((?X . ((F ?X))))`, поэтому `?X` "
"связан с (`F ?X`).\n"
"Это представляет собой круговое, бесконечное унифицирование/объединение.\n"
"Некоторые версии Пролога, особенно Пролог II ([Giannesini et al.\n"
"1986] (B9780080571157500285.xhtml # bb0460)), предоставляют интерпретацию "
"таких структур, но определить семантику бесконечных структур сложно."

#: in/chapter11.md:308
msgid ""
"The easiest way to deal with such infinite structures is just to ban them.\n"
"This ban can be realized by modifying the unifier so that it fails whenever "
"there is an attempt to unify a variable with a structure containing that "
"variable.\n"
"This is known in unification circles as the *occurs check.* In practice the "
"problem rarely shows up, and since it can add a lot of computational "
"complexity, most Prolog systems have ignored the occurs check.\n"
"This means that these systems can potentially produce unsound answers.\n"
"In the final version of `unify` following, a variable is provided to allow "
"the user to turn occurs checking on or off."
msgstr ""
"Самый простой способ справиться с такими бесконечными структурами - просто "
"запретить их.\n"
"Этот запрет может быть реализован путем модификации унификатора(unifier) "
"так, чтобы он терпел неудачу при каждой попытке унифицировать переменную со "
"структурой, содержащей эту переменную.\n"
"Это известно в кругах унификации как *(проверка происхождения/occurs check)."
"* На практике проблема возникает редко, и, поскольку она может добавить "
"много вычислительной сложности, большинство систем Prolog проигнорировали "
"проверку происхождения.\n"
"Это означает, что эти системы потенциально могут давать неверные ответы.\n"
"В последней версии `unify` предоставляется переменная, позволяющая "
"пользователю включать или отключать проверку происхождения."

#: in/chapter11.md:311
msgid ""
"```lisp\n"
"(defparameter *occurs-check* t \"Should we do the occurs check?\")"
msgstr ""

#: in/chapter11.md:322
msgid ""
"(defun unify (x y &optional (bindings no-bindings))\n"
"  \"See if x and y match with given bindings.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"        ((eql x y) bindings)\n"
"        ((variable-p x) (unify-variable x y bindings))\n"
"        ((variable-p y) (unify-variable y x bindings))\n"
"        ((and (consp x) (consp y))\n"
"         (unify (rest x) (rest y)\n"
"                (unify (first x) (first y) bindings)))\n"
"        (t fail)))"
msgstr ""

#: in/chapter11.md:332
msgid ""
"(defun unify-variable (var x bindings)\n"
"  \"Unify var with x, using (and maybe extending) bindings.\"\n"
"  (cond ((get-binding var bindings)\n"
"         (unify (lookup var bindings) x bindings))\n"
"        ((and (variable-p x) (get-binding x bindings))\n"
"         (unify var (lookup x bindings) bindings))\n"
"        ((and *occurs-check* (occurs-check var x bindings))\n"
"         fail)\n"
"        (t (extend-bindings var x bindings))))"
msgstr ""

#: in/chapter11.md:342
msgid ""
"(defun occurs-check (var x bindings)\n"
"  \"Does var occur anywhere inside x?\"\n"
"  (cond ((eq var x) t)\n"
"        ((and (variable-p x) (get-binding x bindings))\n"
"         (occurs-check var (lookup x bindings) bindings))\n"
"        ((consp x) (or (occurs-check var (first x) bindings)\n"
"                       (occurs-check var (rest x) bindings)))\n"
"        (t nil)))\n"
"```"
msgstr ""

#: in/chapter11.md:348
msgid ""
"Now we consider how `unify` will be used.\n"
"In particular, one thing we want is a function for substituting a binding "
"list into an expression.\n"
"We originally chose association lists as the implementation of bindings "
"because of the availability of the function `sublis`.\n"
"Ironically, `sublis` won't work any more, because variables can be bound to "
"other variables, which are in turn bound to expressions.\n"
"The `function subst-bindings` acts like `sublis`, except that it substitutes "
"recursive bindings."
msgstr ""
"Теперь мы рассмотрим, как будет использоваться `unify`.\n"
"В частности, нам нужна функция для замены(подстановки) списка привязки в "
"выражение.\n"
"Первоначально мы выбрали списки ассоциаций в качестве реализации привязок из-"
"за доступности функции `sublis`.\n"
"По иронии судьбы, `sublis` больше не будет работать, потому что переменные "
"могут быть привязаны к другим переменным, которые, в свою очередь, привязаны "
"к выражениям.\n"
"Функция `subst-bindings` действует как `sublis`, за исключением того, что "
"заменяет рекурсивные привязки."

#: in/chapter11.md:362
msgid ""
"```lisp\n"
"(defun subst-bindings (bindings x)\n"
"  \"Substitute the value of variables in bindings into x,\n"
"  taking recursively bound variables into account.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"        ((eq bindings no-bindings) x)\n"
"        ((and (variable-p x) (get-binding x bindings))\n"
"         (subst-bindings bindings (lookup x bindings)))\n"
"        ((atom x) x)\n"
"        (t (reuse-cons (subst-bindings bindings (car x))\n"
"                       (subst-bindings bindings (cdr x))\n"
"                       x))))\n"
"```"
msgstr ""

#: in/chapter11.md:364
msgid "Now let's try `unify` on some examples:"
msgstr "Теперь давайте попробуем `unify` на нескольких примерах:"

#: in/chapter11.md:366
msgctxt "in/chapter11.md:366"
msgid "`> (unify '(?x ?y a) '(?y ?x ?x))`=> `((?Y . A) (?X . ?Y))`"
msgstr ""

#: in/chapter11.md:368
msgid "`> (unify '?x '(f ?x))`=> `NIL`"
msgstr ""

#: in/chapter11.md:370
msgid "`> (unify '(?x ?y) '((f ?y) (f ?x)))`=> `NIL`"
msgstr ""

#: in/chapter11.md:372
msgid "`> (unify '(?x ?y ?z) '((?y ?z) (?x ?z) (?x ?y)))`=> `NIL`"
msgstr ""

#: in/chapter11.md:374
msgid "`> (unify 'a 'a)`=> `((T . T))`"
msgstr ""

#: in/chapter11.md:377
msgid ""
"Finally, the function `unifier` calls `unify` and substitutes the resulting "
"binding list into one of the arguments.\n"
"The choice of `x` is arbitrary; an equal result would come from substituting "
"the binding list into `y`."
msgstr ""
"Наконец, функция `unifier` вызывает `unify` и подставляет полученный список "
"привязки в один из аргументов.\n"
"Выбор `x` произвольный; такой же результат будет при подстановке списка "
"привязки на `y`."

#: in/chapter11.md:383
msgid ""
"```lisp\n"
"(defun unifier (x y)\n"
" \"Return something that unifies with both x and y (or fail).\"\n"
" (subst-bindings (unify x y) x))\n"
"```"
msgstr ""

#: in/chapter11.md:385
msgid "Here are some examples of `unifier`:"
msgstr "Вот несколько примеров `unifier`:"

#: in/chapter11.md:387
msgid "`> (unifier '(?x ?y a) '(?y ?x ?x))`=> `(A A A)`"
msgstr ""

#: in/chapter11.md:391
msgid ""
"```lisp\n"
"> (unifier '((?a * ?x ^ 2) + (?b * ?x) + ?c)\n"
"```"
msgstr ""

#: in/chapter11.md:393
msgid "`                '(?z + (4 * 5) + 3))`=>"
msgstr ""

#: in/chapter11.md:397
msgid ""
"```lisp\n"
"((?A * 5 ^ 2) + (4 * 5) + 3)\n"
"```"
msgstr ""

#: in/chapter11.md:399
msgid "When *`occurs-check`* is false, we get the following answers:"
msgstr ""
"Когда *`occurs-check`(проверка происхождени)* это false, мы получаем "
"следующие ответы:"

#: in/chapter11.md:401
msgctxt "in/chapter11.md:401"
msgid "`> (unify '?x '(f ?x))`=> `((?X F ?X))`"
msgstr ""

#: in/chapter11.md:403
msgid "`> (unify '(?x ?y) '((f ?y) (f ?x)))`=> `((?Y F ?X) (?X F ?Y))`"
msgstr ""

#: in/chapter11.md:407
msgid ""
"```lisp\n"
"> (unify '(?x ?y ?z) '((?y ?z) (?x ?z) (?x ?y))) => ((?Z ?X ?Y) (?Y ?X ?Z) (?"
"X ?Y  ?Z))\n"
"```"
msgstr ""

#: in/chapter11.md:409
msgid "### Programming with Prolog"
msgstr "### Программирование с помощью Prolog"

#: in/chapter11.md:413
msgid ""
"The amazing thing about Prolog clauses is that they can be used to express "
"relations that we would normally think of as \"programs,\" not \"data.\" For "
"example, we can define the `member` relation, which holds between an item "
"and a list that contains that item.\n"
"More precisely, an item is a member of a list if it is either the first "
"element of the list or a member of the rest of the list.\n"
"This definition can be translated into Prolog almost Verbatim:"
msgstr ""
"В предложениях Пролога замечательно то, что их можно использовать для "
"выражения отношений, которые мы обычно воспринимаем как \"программы\", а не "
"как \"данные\". Например, мы можем определить отношение \"member(участник/"
"член)\", которое имеет место между элементом и списком, содержащим этот "
"элемент.\n"
"Точнее, элемент является членом списка, если он является либо первым "
"элементом списка(first), либо членом остальной части списка(member rest).\n"
"Это определение можно почти дословно перевести на Пролог:"

#: in/chapter11.md:418
msgid ""
"```lisp\n"
"(<- (member ?item (?item . ?rest)))\n"
"(<- (member ?item (?x . ?rest)) (member ?item ?rest))\n"
"```"
msgstr ""

#: in/chapter11.md:422
msgid ""
"Of course, we can write a similar definition in Lisp.\n"
"The most visible difference is that Prolog allows us to put patterns in the "
"head of a clause, so we don't need recognizers like `consp` or accessors "
"like `first` and `rest`.\n"
"Otherwise, the Lisp definition is similar:[2](#fn0020)"
msgstr ""
"Конечно, мы можем написать подобное определение на Лиспе.\n"
"Наиболее заметное различие заключается в том, что Prolog позволяет нам "
"помещать шаблоны в заголовок предложения, поэтому нам не нужны "
"распознаватели, такие как `consp` или аксессоры, такие как `first` и "
"`rest`.\n"
"В остальном определение Лиспа аналогично: [2](# fn0020)"

#: in/chapter11.md:429
msgid ""
"```lisp\n"
"(defun lisp-member (item list)\n"
"  (and (consp list)\n"
"  (or (eql item (first list))\n"
"    (lisp-member item (rest list)))))\n"
"```"
msgstr ""

#: in/chapter11.md:431
msgid ""
"If we wrote the Prolog code without taking advantage of the pattern feature, "
"it would look more like the Lisp version:"
msgstr ""
"Если бы мы написали код Пролога, не используя возможности работы с образцом, "
"он был бы больше похож на версию Лиспа:"

#: in/chapter11.md:439
msgid ""
"```lisp\n"
"(<- (member ?item ?list)\n"
"  (= ?list (?item . ?rest)))\n"
"(<- (member ?item ?list)\n"
"  (= ?list (?x . ?rest))\n"
"  (member ?item ?rest))\n"
"```"
msgstr ""

#: in/chapter11.md:441
msgid ""
"If we define or in Prolog, we would write a version that is clearly just a "
"syntactic variant of the Lisp version."
msgstr ""
"Если мы определим или в Прологе, мы напишем версию, которая явно является "
"синтаксическим вариантом версии Лиспа."

#: in/chapter11.md:448
msgid ""
"```lisp\n"
"(<- (member ?item ?list)\n"
"  (= ?list (?first . ?rest))\n"
"  (or (= ?item ?first)\n"
"  (member ?item ?rest)))\n"
"```"
msgstr ""

#: in/chapter11.md:452
msgid ""
"Let's see how the Prolog version of `member` works.\n"
"Imagine that we have a Prolog interpreter that can be given a query using "
"the macro ?-, and that the definition of `member` has been entered.\n"
"Then we would see:"
msgstr ""
"Давайте посмотрим, как работает версия `member` на языке Prolog.\n"
"Представьте, что у нас есть интерпретатор Пролога, которому можно задать "
"запрос с помощью макроса ?-, и что было введено определение `member`.\n"
"Тогда мы увидим:"

#: in/chapter11.md:460
msgid ""
"```lisp\n"
"> (?- (member 2 (1 2 3)))\n"
"Yes;\n"
"> (?- (member 2 (1 2 3 2 1)))\n"
"Yes;\n"
"Yes;\n"
"```"
msgstr ""

#: in/chapter11.md:464
msgid ""
"The answer to the first query is \"yes\" because 2 is a member of the rest "
"of the list.\n"
"In the second query the answer is \"yes\" twice, because 2 appears in the "
"list twice.\n"
"This is a little surprising to Lisp programmers, but there still seems to be "
"a fairly close correspondence between Prolog's and Lisp's `member.` However, "
"there are things that the Prolog `member` can do that Lisp cannot:"
msgstr ""
"Ответ на первый вопрос - \"да\", потому что 2 является членом остальной "
"части списка.\n"
"Во втором запросе дважды ответ \"да\", потому что 2 появляется в списке "
"дважды.\n"
"Это немного удивительно для программистов на Лиспе, но все еще кажется "
"довольно близкое соответствие между `member` Пролога и Lisp. Однако есть "
"вещи, которые `member` Пролога может делать, а Lisp не может:"

#: in/chapter11.md:471
msgid ""
"```lisp\n"
"> (?- (member ?x (1 2 3)))\n"
"?X = 1;\n"
"?X = 2;\n"
"?X = 3;\n"
"```"
msgstr ""

#: in/chapter11.md:478
msgid ""
"Here `member` is used not as a predicate but as a generator of elements in a "
"list.\n"
"While Lisp functions always map from a specified input (or inputs) to a "
"specified output, Prolog relations can be used in several ways.\n"
"For `member,` we see that the first argument, `?x`, can be either an input "
"or an output, depending on the goal that is specified.\n"
"This power to use a single specification as a function going in several "
"different directions is a very flexible feature of Prolog.\n"
"(Unfortunately, while it works very well for simple relations like `member,` "
"in practice it does not work well for large programs.\n"
"It is very difficult to, say, design a compiler and automatically have it "
"work as a disassembler as well.)"
msgstr ""
"Здесь `member` используется не как предикат, а как генератор элементов в "
"списке.\n"
"В то время как функции Lisp всегда сопоставляются с заданным входом (или "
"входами) с заданным выходом, отношения Пролога могут использоваться "
"несколькими способами.\n"
"Для `member` мы видим, что первый аргумент, `?x`, может быть либо входом, "
"либо выходом, в зависимости от указанной цели.\n"
"Эта возможность использовать одну спецификацию как функцию, работающую в "
"нескольких разных направлениях, является очень гибкой функцией Prolog.\n"
"(К сожалению, хотя она очень хорошо работает для простых отношений, таких "
"как `member`, на практике она не работает для больших программ.\n"
"Например, очень сложно разработать компилятор и автоматически заставить его "
"работать как дизассемблер.)"

#: in/chapter11.md:484
msgid ""
"Now we turn to the implementation of the Prolog interpreter, as summarized "
"in [figure 11.1](#f0010).\n"
"The first implementation choice is the representation of rules and facts.\n"
"We will build a single uniform data base of clauses, without distinguishing "
"rules from facts.\n"
"The simplest representation of clauses is as a cons cell holding the head "
"and the body.\n"
"For facts, the body will be empty."
msgstr ""
"Теперь перейдем к реализации интерпретатора Пролога, как показано на [рис. "
"11.1](#f0010).\n"
"Первый вариант реализации - это представление правил и фактов.\n"
"Мы построим единую базу данных предложений, не отделяя правила от фактов.\n"
"Простейшее представление предложений - это cons-ячейка, содержащая голову и "
"тело.\n"
"Для фактов тело будет пустым."

#: in/chapter11.md:489
msgid ""
"| []()                                             |\n"
"|--------------------------------------------------|\n"
"| ![f11-01](images/chapter11/f11-01.jpg)           |\n"
"| Figure 11.1: Glossary for the Prolog Interpreter |"
msgstr ""
"| []()                                             |\n"
"|--------------------------------------------------|\n"
"| ![f11-01](images/chapter11/f11-01.jpg)           |\n"
"| Рисунок 11.1: Глоссарий интерпретатора Пролога |"

#: in/chapter11.md:491
msgid "(ed: this should be a markdown table)"
msgstr ""

#: in/chapter11.md:497
msgid ""
"```lisp\n"
";; Clauses are represented as (head . body) cons cells\n"
"(defun clause-head (clause) (first clause))\n"
"(defun clause-body (clause) (rest clause))\n"
"```"
msgstr ""

#: in/chapter11.md:503
msgid ""
"The next question is how to index the clauses.\n"
"Recall the procedural interpretation of a clause: when we want to prove the "
"head, we can do it by proving the body.\n"
"This suggests that clauses should be indexed in terms of their heads.\n"
"Each clause will be stored on the property list of the predicate of the head "
"of the clause.\n"
"Since the data base is now distributed across the property list of various "
"symbols, we represent the entire data base as a list of symbols stored as "
"the value of `*db-predicates*`."
msgstr ""
"Следующий вопрос - как проиндексировать предложения.\n"
"Вспомните процедурную интерпретацию предложения: когда мы хотим доказать "
"голову, мы можем сделать это, доказав тело.\n"
"Это говорит о том, что предложения следует индексировать по их заголовкам.\n"
"Каждое предложение будет хранить в списке свойств предиката заголовк "
"предложения.\n"
"Поскольку база данных теперь распределена по списку свойств различных "
"символов, мы представляем всю базу данных как список символов, хранящихся "
"как значение `*db-predicates*`."

#: in/chapter11.md:508
msgid ""
"```lisp\n"
";; Clauses are stored on the predicate's plist\n"
"(defun get-clauses (pred) (get pred 'clauses))\n"
"(defun predicate (relation) (first relation))"
msgstr ""

#: in/chapter11.md:512
msgid ""
"(defvar *db-predicates* nil\n"
"  \"A list of all predicates stored in the database.\")\n"
"```"
msgstr ""

#: in/chapter11.md:517
msgid ""
"Now we need a way of adding a new clause.\n"
"The work is split up into the macro <-, which provides the user interface, "
"and a function, add-clause, that does the work.\n"
"It is worth defining a macro to add clauses because in effect we are "
"defining a new language: Prolog-In-Lisp.\n"
"This language has only two syntactic constructs: the <- macro to add "
"clauses, and the ?- macro to make queries."
msgstr ""
"Теперь нам нужен способ добавления нового предложения.\n"
"Работа разделена на макрос <-, который обеспечивает пользовательский "
"интерфейс, и функцию add-clause, которая выполняет эту работу.\n"
"Стоит определить макрос для добавления предложений, потому что фактически мы "
"определяем новый язык: Prolog-In-Lisp.\n"
"В этом языке есть только две синтаксические конструкции: макрос <- для "
"добавления предложений и макрос ?- для выполнения запросов."

#: in/chapter11.md:522
msgid ""
"```lisp\n"
"(defmacro <- (&rest clause)\n"
"  \"Add a clause to the data base.\"\n"
"  `(add-clause ',clause))"
msgstr ""

#: in/chapter11.md:533
msgid ""
"(defun add-clause (clause)\n"
"  \"Add a clause to the data base, indexed by head's predicate.\"\n"
"  ;; The predicate must be a non-variable symbol.\n"
"  (let ((pred (predicate (clause-head clause))))\n"
"    (assert (and (symbolp pred) (not (variable-p pred))))\n"
"    (pushnew pred *db-predicates*)\n"
"    (setf (get pred 'clauses)\n"
"          (nconc (get-clauses pred) (list clause)))\n"
"    pred))\n"
"```"
msgstr ""

#: in/chapter11.md:535
msgid ""
"Now all we need is a way to remove clauses, and the data base will be "
"complete."
msgstr ""
"Теперь все, что нам нужно, - это способ удалить предложения, и база данных "
"будет полной."

#: in/chapter11.md:540
msgid ""
"```lisp\n"
"(defun clear-db ()\n"
"  \"Remove all clauses (for all predicates) from the data base.\"\n"
"  (mapc #'clear-predicate *db-predicates*))"
msgstr ""

#: in/chapter11.md:545
msgid ""
"(defun clear-predicate (predicate)\n"
"  \"Remove the clauses for a single predicate.\"\n"
"  (setf (get predicate 'clauses) nil))\n"
"```"
msgstr ""

#: in/chapter11.md:554
msgid ""
"A data base is useless without a way of getting data out, as well as putting "
"it in.\n"
"The function prove will be used to prove that a given goal either matches a "
"fact that is in the data base directly or can be derived from the rules.\n"
"To prove a goal, first find all the candidate clauses for that goal.\n"
"For each candidate, check if the goal unifies with the head of the clause.\n"
"If it does, try to prove all the goals in the body of the clause.\n"
"For facts, there will be no goals in the body, so success will be "
"immediate.\n"
"For rules, the goals in the body need to be proved one at a time, making "
"sure that bindings from the previous step are maintained.\n"
"The implementation is straightforward:"
msgstr ""
"База данных бесполезна без способа извлечения данных, а также их "
"размещения.\n"
"Функция prove будет использоваться, чтобы доказать, что данная цель либо "
"соответствует факту, который находится в базе данных напрямую, либо может "
"быть получена из правил.\n"
"Чтобы доказать цель, сначала найдите все предложения-кандидаты для этой "
"цели.\n"
"Для каждого кандидата проверьте, совпадает ли цель с заголовком "
"предложения.\n"
"Если это так, постарайтесь доказать все цели в теле предложения.\n"
"Для фактов, в теле не будет целей, поэтому успех будет "
"немедленным(непосредственным).\n"
"Для правил, цели в теле нужно подтверждать по одной, следя за тем, чтобы "
"привязки из предыдущего шага сохранялись.\n"
"Реализация проста:"

#: in/chapter11.md:563
msgid ""
"```lisp\n"
"(defun prove (goal bindings)\n"
"  \"Return a list of possible solutions to goal.\"\n"
"  (mapcan #'(lambda (clause)\n"
"              (let ((new-clause (rename-variables clause)))\n"
"                (prove-all (clause-body new-clause)\n"
"                           (unify goal (clause-head new-clause) "
"bindings))))\n"
"          (get-clauses (predicate goal))))"
msgstr ""

#: in/chapter11.md:572
msgid ""
"(defun prove-all (goals bindings)\n"
"  \"Return a list of solutions to the conjunction of goals.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"        ((null goals) (list bindings))\n"
"        (t (mapcan #'(lambda (goal1-solution)\n"
"                       (prove-all (rest goals) goal1-solution))\n"
"                   (prove (first goals) bindings)))))\n"
"```"
msgstr ""

#: in/chapter11.md:578
msgid ""
"The tricky part is that we need some way of distinguishing a variable `?x` "
"in one clause from another variable `?x` in another clause.\n"
"Otherwise, a variable used in two different clauses in the course of a proof "
"would have to take on the same value in each clause, which would be a "
"mistake.\n"
"Just as arguments to a function can have different values in different "
"recursive calls to the function, so the variables in a clause are allowed to "
"take on different values in different recursive uses.\n"
"The easiest way to keep variables distinct is just to rename all variables "
"in each clause before it is used.\n"
"The function `rename-variables` does this:[3](#fn0025)"
msgstr ""
"Сложность состоит в том, что нам нужен способ отличить переменную `?x` в "
"одном предложении от другой переменной `?x` в другом предложении.\n"
"В противном случае переменная, используемая в двух разных предложениях в "
"ходе доказательства, должна была бы принимать одно и то же значение в каждом "
"предложении, что было бы ошибкой.\n"
"Так же, как аргументы функции могут иметь разные значения при разных "
"рекурсивных вызовах функции, переменные в предложении могут принимать разные "
"значения в разных рекурсивных применениях.\n"
"Самый простой способ сохранить различия между переменными - просто "
"переименовать все переменные в каждом предложении перед его использованием.\n"
"Функция `rename-variables` делает следующее: [3](#fn0025)"

#: in/chapter11.md:586
msgid ""
"```lisp\n"
"(defun rename-variables (x)\n"
"  \"Replace all variables in x with new ones.\"\n"
"  (sublis (mapcar #'(lambda (var) (cons var (gensym (string var))))\n"
"                  (variables-in x))\n"
"          x))\n"
"```"
msgstr ""

#: in/chapter11.md:590
msgid ""
"`Rename - variables` makes use of `gensym,` a function that generates a new "
"symbol each time it is called.\n"
"The symbol is not interned in any package, which means that there is no "
"danger of a programmer typing a symbol of the same name.\n"
"The predicate `variables-in` and its auxiliary function are defined here:"
msgstr ""
"`rename-variables` использует функцию gensym, которая генерирует новый "
"символ при каждом вызове.\n"
"Этот символ не интернирован ни в одном пакете, что означает, что нет "
"опасности, что программист напечатает символ с тем же именем.\n"
"Здесь определены предикат `variables-in` и его вспомогательная функция:"

#: in/chapter11.md:595
msgid ""
"```lisp\n"
"(defun variables-in (exp)\n"
"  \"Return a list of all the variables in EXP.\"\n"
"  (unique-find-anywhere-if #'variable-p exp))"
msgstr ""

#: in/chapter11.md:610
msgid ""
"(defun unique-find-anywhere-if (predicate tree\n"
"                                &optional found-so-far)\n"
"  \"Return a list of leaves of tree satisfying predicate,\n"
"  with duplicates removed.\"\n"
"  (if (atom tree)\n"
"      (if (funcall predicate tree)\n"
"          (adjoin tree found-so-far)\n"
"          found-so-far)\n"
"      (unique-find-anywhere-if\n"
"        predicate\n"
"        (first tree)\n"
"        (unique-find-anywhere-if predicate (rest tree)\n"
"                                 found-so-far))))\n"
"```"
msgstr ""

#: in/chapter11.md:615
msgid ""
"Finally, we need a nice interface to the proving functions.\n"
"We will use `?-` as a macro to introduce a query.\n"
"The query might as well allow a conjunction of goals, so `?-` will call "
"`prove-all`.\n"
"Together, `<-` and `?-` define the complete syntax of our Prolog-In-Lisp "
"language."
msgstr ""
"Наконец, нам нужен хороший интерфейс для функций доказательства.\n"
"Мы будем использовать `?-` в качестве макроса для ввода запроса.\n"
"С таким же успехом запрос может допускать сочетание целей, поэтому `?-` "
"вызовет `prove-all`(доказывать все).\n"
"Вместе `<-` и `?-` определяют полный синтаксис нашего языка Prolog-In-Lisp."

#: in/chapter11.md:619
msgid ""
"```lisp\n"
"(defmacro ?- (&rest goals) '(prove-all ',goals no-bindings))\n"
"```"
msgstr ""

#: in/chapter11.md:621
msgid "Now we can enter all the clauses given in the prior example:"
msgstr ""
"Теперь мы можем ввести все предложения, приведенные в предыдущем примере:"

#: in/chapter11.md:631
msgid ""
"```lisp\n"
"(<- (likes Kim Robin))\n"
"(<- (likes Sandy Lee))\n"
"(<- (likes Sandy Kim))\n"
"(<- (likes Robin cats))\n"
"(<- (likes Sandy ?x) (likes ?x cats))\n"
"(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))\n"
"(<- (likes ?x ?x))\n"
"```"
msgstr ""

#: in/chapter11.md:633
msgid "To ask whom Sandy likes, we would use:"
msgstr "Чтобы спросить, кого любит Сэнди, мы воспользуемся:"

#: in/chapter11.md:643
msgid ""
"```lisp\n"
"> (?- (likes Sandy ?who))\n"
"(((?WHO . LEE))\n"
"  ((?WHO . KIM))\n"
"  ((?X2856 . ROBIN) (?WHO .?X2856))\n"
"  ((?X2860 . CATS) (?X2857 CATS) (?X2856 . SANDAY) (?WHO ?X2856)\n"
"  ((?X2865 . CATS) (?X2856 ?X2865)((?WHO . ?X2856))\n"
"  (?WHO . SANDY) (?X2867 . SANDAY)))\n"
"```"
msgstr ""

#: in/chapter11.md:649
msgid ""
"Perhaps surprisingly, there are six answers.\n"
"The first two answers are Lee and Kim, because of the facts.\n"
"The next three stem from the clause that Sandy likes everyone who likes "
"cats.\n"
"First, Robin is an answer because of the fact that Robin likes cats.\n"
"To see that Robin is the answer, we have to unravel the bindings: `?who` is "
"bound to `?x2856`, which is in turn bound to Robin."
msgstr ""
"Возможно вы удивитесь, но существует шесть ответов.\n"
"Первые два ответа - Ли и Ким, потому что факты.\n"
"Следующие три проистекают из предложения, что Сэнди любит всех, кто любит "
"кошек.\n"
"Во-первых, Робин - это ответ, потому что Робин любит кошек.\n"
"Чтобы увидеть, что Робин является ответом, мы должны распутать привязки:  `?"
"who` привязан к `?x2856`, который, в свою очередь, привязан к Robin."

#: in/chapter11.md:659
msgid ""
"Now we're in for some surprises: Sandy is listed, because of the following "
"reasoning: (1) Sandy likes anyone/thing who likes cats, (2) cats like cats "
"because everyone likes  themselves, (3) therefore Sandy likes cats, and (4) "
"therefore Sandy likes Sandy.\n"
"Cats is an answer because of step (2), and finally, Sandy is an answer "
"again, because of the clause about liking oneself.\n"
"Notice that the result of the query is a list of solutions, where each "
"solution corresponds to a different way of proving the query true.\n"
"Sandy appears twice because there are two different ways of showing that "
"Sandy likes Sandy.\n"
"The order in which solutions appear is determined by the order of the "
"search.\n"
"Prolog searches for solutions in a top-down, left-to-right fashion.\n"
"The clauses are searched from the top down, so the first clauses entered are "
"the first ones tried.\n"
"Within a clause, the body is searched left to right.\n"
"In using the (`likes Kim ?x`) clause, Prolog would first try to find an `x` "
"who likes Lee, and then see if `x` likes Kim."
msgstr ""
"Теперь нас ждут некоторые сюрпризы: Сэнди внесена в список по следующим "
"причинам: (1) Сэнди любит всех/тех, кто любит кошек, (2) кошки любят кошек, "
"потому что все любят себя, (3) поэтому Сэнди любит кошек, и (4) поэтому "
"Сэнди нравится Сэнди.\n"
"Кошки - это ответ из-за шага (2), и, наконец, Сэнди - это снова ответ из-за "
"пункта о симпатии к себе.\n"
"Обратите внимание, что результатом запроса является список решений, где "
"каждое решение соответствует разному способу подтверждения истинности "
"запроса.\n"
"Сэнди появляется дважды, потому что есть два разных способа показать, что "
"Сэнди нравится Сэнди.\n"
"Порядок появления решений определяется порядком поиска.\n"
"Prolog ищет решения сверху вниз, слева направо.\n"
"Поиск по предложениям выполняется сверху вниз, поэтому первые введенные "
"предложения являются первыми опробованными.\n"
"В конкретном предложении поиск выполняется слева направо.\n"
"При использовании предложения (`likes Kim ?x`) Prolog сначала пытается найти "
"`x`, которому нравится Ли, а затем посмотреть, нравится ли `x` Ким."

#: in/chapter11.md:663
msgid ""
"The output from `prove-all` is not very pretty.\n"
"We can fix that by defining a new function, `top-level-prove,` which calls "
"`prove-all` as before, but then passes the list of solutions to `show-prolog-"
"solutions,` which prints them in a more readable format.\n"
"Note that `show-prolog-solutions` returns no values: `(values).` This means "
"the read-eval-print loop will not print anything when `(values)` is the "
"result of a top-level call."
msgstr ""
"Результат от `prove-all` не очень красивый.\n"
"Мы можем исправить это, определив новую функцию `top-level-prove`, которая, "
"как и раньше, вызывает `prove-all`, но затем передает список решений в `show-"
"prolog-solutions`, которая распечатывает их в более читаемом виде.\n"
"Обратите внимание, что `show-prolog-solutions` не возвращает значений: "
"`(values)`. Это означает, что цикл read-eval-print не будет печатать ничего, "
"если `(values)` является результатом вызова верхнего уровня."

#: in/chapter11.md:666
msgid ""
"```lisp\n"
"(defmacro ?- (&rest goals) `(top-level-prove ',goals))"
msgstr ""

#: in/chapter11.md:672
msgid ""
"(defun top-level-prove (goals)\n"
"  \"Prove the goals, and print variables readably.\"\n"
"  (show-prolog-solutions\n"
"    (variables-in goals)\n"
"    (prove-all goals no-bindings)))"
msgstr ""

#: in/chapter11.md:680
msgid ""
"(defun show-prolog-solutions (vars solutions)\n"
"  \"Print the variables in each of the solutions.\"\n"
"  (if (null solutions)\n"
"      (format t \"~&No.\")\n"
"      (mapc #'(lambda (solution) (show-prolog-vars vars solution))\n"
"            solutions))\n"
"  (values))"
msgstr ""

#: in/chapter11.md:690
msgid ""
"(defun show-prolog-vars (vars bindings)\n"
"  \"Print each variable with its binding.\"\n"
"  (if (null vars)\n"
"      (format t \"~&Yes\")\n"
"      (dolist (var vars)\n"
"        (format t \"~&~a = ~a\" var\n"
"                (subst-bindings bindings var))))\n"
"  (princ \";\"))\n"
"```"
msgstr ""

#: in/chapter11.md:692
msgid "Now let's try some queries:"
msgstr "Теперь попробуем несколько запросов:"

#: in/chapter11.md:708
msgid ""
"```lisp\n"
"> (?- (likes Sandy ?who))\n"
"?WHO = LEE;\n"
"?WHO = KIM;\n"
"?WHO = ROBIN;\n"
"?WHO = SANDY;\n"
"?WHO = CATS;\n"
"?WHO = SANDY;\n"
"> (?- (likes ?who Sandy))\n"
"?WHO = SANDY;\n"
"?WHO = KIM;\n"
"?WHO = SANDY;\n"
"> (?- (likes Robin Lee))\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:714
msgid ""
"The first query asks again whom Sandy likes, and the second asks who likes "
"Sandy.\n"
"The third asks for confirmation of a fact.\n"
"The answer is \"no,\" because there are no clauses or facts that say Robin "
"likes Lee.\n"
"Here's another example, a list of pairs of people who are in a mutual liking "
"relation.\n"
"The last answer has an uninstantiated variable, indicating that everyone "
"likes themselves."
msgstr ""
"Первый вопрос снова спрашивает, кому нравится Сэнди, а второй спрашивает, "
"кому нравится Сэнди.\n"
"Третий просит подтверждения факта.\n"
"Ответ - \"no\", потому что нет никаких предложений или фактов, говорящих о "
"том, что Робин любит Ли.\n"
"Вот еще один пример - список пар людей, которые находятся в отношениях "
"взаимных симпатий.\n"
"Последний ответ содержит неустановленную переменную, указывающую на то, что "
"все любят себя."

#: in/chapter11.md:730
msgid ""
"```lisp\n"
"> (?- (likes ?x ?y) (likes ?y ?x))\n"
"?Y = KIM\n"
"?X = SANDY;\n"
"?Y = SANDY\n"
"?X = SANDY;\n"
"?Y = SANDY\n"
"?X = SANDY;\n"
"?Y = SANDY\n"
"?X = KIM;\n"
"?Y = SANDY\n"
"?X = SANDY;\n"
"?Y = ?X3251\n"
"?X = ?X3251;\n"
"```"
msgstr ""

#: in/chapter11.md:732
msgid ""
"It makes sense in Prolog to ask open-ended queries like \"what lists is 2 a "
"member of ?\" or even \"what items are elements of what lists?\""
msgstr ""
"В Прологе имеет смысл задавать открытые(open-ended) запросы, такие как "
"\"what lists is 2 a member of ?\"(в какие списки входит ?) или даже \"what "
"items are elements of what lists?\"(какие элементы входят в какие списки?)"

#: in/chapter11.md:737
msgid ""
"```lisp\n"
"(?- (member 2 ?list))\n"
"(?- (member ?item ?list))\n"
"```"
msgstr ""

#: in/chapter11.md:741
msgid ""
"These queries are valid Prolog and will return solutions, but there will be "
"an infinite number of them.\n"
"Since our interpreter collects all the solutions into a single list before "
"showing any of them, we will never get to see the solutions.\n"
"The next section shows how to write a new interpreter that fixes this "
"problem."
msgstr ""
"Эти запросы являются действительным Прологом и вернут решения, но их будет "
"бесконечное количество.\n"
"Поскольку наш интерпретатор собирает все решения в один список перед тем, "
"как показать какое-либо из них, мы никогда не увидим решения.\n"
"В следующем разделе показано, как написать новый интерпретатор, решающий эту "
"проблему."

#: in/chapter11.md:745
msgid ""
"**Exercise  11.1 [m]** The representation of relations has been a list whose "
"first element is a symbol.\n"
"However, for relations with no arguments, some people prefer to write `(<- p "
"q r)` rather than `(<- (p) (q) (r))`.\n"
"Make changes so that either form is acceptable."
msgstr ""
"** Упражнение 11.1 [m] ** Отношения представляются списком, первым элементом "
"которого является символ.\n"
"Однако для отношений без аргументов некоторые люди предпочитают писать `(<- "
"p q r)`, а не `(<- (p) (q) (r))`.\n"
"Внесите изменения, чтобы любая форма была приемлемой."

#: in/chapter11.md:748
msgid ""
"**Exercise  11.2 [m]** Some people find the < - notation difficult to read.\n"
"Define macros `rule` and `fact` so that we can write:"
msgstr ""
"** Упражнение 11.2 [m] ** Некоторым людям трудно читать обозначение <-.\n"
"Определите макросы rule и fact, чтобы мы могли написать:"

#: in/chapter11.md:753
msgid ""
"```lisp\n"
"(fact (likes Robin cats))\n"
"(rule (likes Sandy ?x) if (likes ?x cats))\n"
"```"
msgstr ""

#: in/chapter11.md:755
msgid "## 11.3 Idea 3: Automatic Backtracking"
msgstr "## 11.3 Идея 3: Автоматический возврат"

#: in/chapter11.md:766
msgid ""
"The Prolog interpreter implemented in the last section solves problems by "
"returning a list of all possible solutions.\n"
"We'll call this a *batch* approach, because the answers are retrieved in one "
"uninterrupted batch of processing.\n"
"Sometimes that is just what you want, but other times a single solution will "
"do.\n"
"In real Prolog, solutions are presented one at a time, as they are found.\n"
"After each solution is printed, the user has the option of asking for more "
"solutions, or stopping.\n"
"This is an *incremental* approach.\n"
"The incremental approach will be faster when the desired solution is one of "
"the first out of many alternatives.\n"
"The incremental approach will even work when there is an infinite number of "
"solutions.\n"
"And if that is not enough, the incremental approach can be implemented so "
"that it searches depth-first.\n"
"This means that at any point it will require less storage space than the "
"batch approach, which must keep all solutions in memory at once."
msgstr ""
"Интерпретатор Пролога, реализованный в последнем разделе, решает проблемы, "
"возвращая список всех возможных решений.\n"
"Мы будем называть этот подход *batch*(пакетным), потому что ответы "
"извлекаются за один непрерывный пакет обработки.\n"
"Иногда это именно то, что вам нужно, но в других случаях достаточно одного "
"решения.\n"
"В реальном Прологе решения представляются по одному по мере их нахождения.\n"
"После того, как каждое решение напечатано, пользователь может запросить "
"дополнительные решения или остановиться.\n"
"Это \"инкрементный\" подход.\n"
"Постепенный подход будет быстрее, если желаемое решение будет одним из "
"первых из многих альтернатив.\n"
"Пошаговый подход будет работать даже при бесконечном количестве решений.\n"
"А если этого недостаточно, можно реализовать инкрементный подход, при "
"котором поиск будет выполняться сначала в глубину.\n"
"Это означает, что в любой момент для этого потребуется меньше места для "
"хранения, чем при пакетном подходе, при котором все решения должны "
"одновременно храниться в памяти."

#: in/chapter11.md:773
msgid ""
"In this section we implement an incremental Prolog interpreter.\n"
"One approach would be to modify the interpreter of the last section to use "
"pipes rather than lists.\n"
"With pipes, unnecessary computation is delayed, and even infinite lists can "
"be expressed in a finite amount of time and space.\n"
"We could change to pipes simply by changing the `mapcan` in `prove` and "
"`prove-all` to `mappend-pipe` (page 286).\n"
"The books by [Winston and Horn (1988)](B9780080571157500285.xhtml#bb1410) "
"and by [Abelson and Sussman (1985)](B9780080571157500285.xhtml#bb0010) take "
"this approach.\n"
"We take a different one."
msgstr ""
"Один из подходов - изменить интерпретатор последнего раздела для "
"использования каналов(pipes), а не списков.\n"
"С каналами ненужные вычисления задерживаются, и даже бесконечные списки "
"могут быть выражены за конечное количество времени и пространства.\n"
"Мы могли бы перейти на каналы, просто изменив `mapcan` в `prove` и `prove-"
"all` на `mappend-pipe` (стр. 286).\n"
"В книгах [Winston and Horn (1988)] (B9780080571157500285.xhtml#bb1410) и "
"[Abelson and Sussman (1985)] (B9780080571157500285.xhtml#bb0010) "
"используется этот подход.\n"
"Мы возьмем другой подход."

#: in/chapter11.md:782
msgid ""
"The first step is a version of `prove` and `prove-all` that return a single "
"solution rather than a list of all possible solutions.\n"
"This should be reminiscent of `achieve` and `achieve-all` from `gps` "
"([chapter 4](B9780080571157500042.xhtml)).\n"
"Unlike `gps`, recursive subgoals and clobbered sibling goals are not checked "
"for.\n"
"However, `prove` is required to search systematically through all solutions, "
"so it is passed an additional parameter: a list of other goals to achieve "
"after achieving the first goal.\n"
"This is equivalent to passing a continuation to `prove`.\n"
"The result is that if `prove` ever succeeds, it means the entire top-level "
"goal has succeeded.\n"
"If it fails, it just means the program is backtracking and trying another "
"sequence of choices.\n"
"Note that `prove` relies on the fact that `fail` is `nil`, because of the "
"way it uses some."
msgstr ""
"Первый шаг - это варианты `prove`  и `prove-all`, которые возвращают "
"единственное решение, а не список всех возможных решений.\n"
"Это должно напоминать `achieve` и `achieve-all` из \"gps\" ([глава 4]"
"(B9780080571157500042.xhtml)).\n"
"В отличие от `gps`, рекурсивные подцели и достигнутые родственные цели не "
"проверяются.\n"
"Однако для систематического поиска по всем решениям требуется `prove`, "
"поэтому ей передается дополнительный параметр: список других целей, которых "
"нужно достичь после достижения первой цели.\n"
"Это эквивалентно передаче продолжения в `prove`.\n"
"В результате, если `prove` когда-либо будет успешно, это означает, что вся "
"цель верхнего уровня достигнута.\n"
"Если это не удается, это просто означает, что программа возвращается и "
"пытается выполнить другую последовательность вариантов.\n"
"Обратите внимание, что `prove` полагается на то, что `fail` равно `nil`, "
"потому что она использует some."

#: in/chapter11.md:798
msgid ""
"```lisp\n"
"(defun prove-all (goals bindings)\n"
"  \"Find a solution to the conjunction of goals.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"              ((null goals) bindings)\n"
"              (t (prove (first goals) bindings (rest goals)))))\n"
"(defun prove (goal bindings other-goals)\n"
"  \"Return a list of possible solutions to goal.\"\n"
"  (some #'(lambda (clause)\n"
"                      (let ((new-clause (rename-variables clause)))\n"
"                          (prove-all\n"
"                              (append (clause-body new-clause) other-goals)\n"
"                      (unify goal (clause-head new-clause) bindings))))\n"
"  (get-clauses (predicate goal))))\n"
"```"
msgstr ""

#: in/chapter11.md:807
msgid ""
"If `prove` does succeed, it means a solution has been found.\n"
"If we want more solutions, we need some way of making the process fail, so "
"that it will backtrack and try again.\n"
"One way to do that is to extend every query with a goal that will print out "
"the variables, and ask the user if the computation should be continued.\n"
"If the user says yes, then the goal *fails,* and backtracking starts.\n"
"If the user says no, the goal succeeds, and since it is the final goal, the "
"computation ends.\n"
"This requires a brand new type of goal: one that is not matched against the "
"data base, but rather causes some procedure to take action.\n"
"In Prolog, such procedures are called *primitives,* because they are built-"
"in to the language, and new ones may not be defined by the user.\n"
"The user may, of course, define non-primitive procedures that call upon the "
"primitives."
msgstr ""
"Если `prove` действительно успешно, это означает, что решение было найдено.\n"
"Если мы хотим больше решений, нам нужен какой-то способ сделать процесс "
"неудачным, чтобы он вернулся(откатился назад) и попробовал снова.\n"
"Один из способов сделать это - расширить каждый запрос с целью распечатать "
"переменные и спросить пользователя, следует ли продолжить вычисление.\n"
"Если пользователь говорит \"yes/да\", то цель *терпит неудачу* и начинается "
"возврат.\n"
"Если пользователь говорит \"no/нет\", цель выполняется, а поскольку это "
"конечная цель, вычисление завершается.\n"
"Для этого требуется совершенно новый тип цели: цель, которая не "
"сопоставляется с базой данных, а скорее заставляет некоторую процедуру "
"предпринимать действия.\n"
"В Прологе такие процедуры называются *примитивами*, потому что они встроены "
"в язык, а новые не могут быть определены пользователем.\n"
"Пользователь, конечно, может определять непримитивные процедуры, которые "
"вызывают примитивы."

#: in/chapter11.md:811
msgid ""
"In our implementation, primitives will be represented as Lisp functions.\n"
"A predicate can be represented either as a list of clauses (as it has been "
"so far) or as a single primitive.\n"
"Here is a version of `prove` that calls primitives when appropriate:"
msgstr ""
"В нашей реализации примитивы будут представлены как функции Лиспа.\n"
"Предикат может быть представлен либо как список предложений (как это было до "
"сих пор), либо как единичный примитив.\n"
"Вот версия `verify`, которая при необходимости вызывает примитивы:"

#: in/chapter11.md:829
msgid ""
"```lisp\n"
"(defun prove (goal bindings other-goals)\n"
"  \"Return a list of possible solutions to goal.\"\n"
"  (let ((clauses (get-clauses (predicate goal))))\n"
"      (if (listp clauses)\n"
"              (some\n"
"                  #'(lambda (clause)\n"
"                          (let ((new-clause (rename-variables clause)))\n"
"                              (prove-all\n"
"                                (append (clause-body new-clause) other-"
"goals)\n"
"                                (unify goal (clause-head new-clause) "
"bindings))))\n"
"                  clauses)\n"
"              ;; The predicate's \"clauses\" can be an atom:\n"
"              ;; a primitive function to call\n"
"              (funcall clauses (rest goal) bindings\n"
"                                other-goals))))\n"
"```"
msgstr ""

#: in/chapter11.md:832
msgid ""
"Here is the version of `top-level-prove` that adds the primitive goal `show-"
"prolog-vars` to the end of the list of goals.\n"
"Note that this version need not call `show-prolog-solutions` itself, since "
"the printing will be handled by the primitive for `show-prolog-vars`."
msgstr ""
"Вот версия `top-level-prove`, которая добавляет примитивную цель `show-"
"prolog-vars` в конец списка целей.\n"
"Обратите внимание, что эта версия не должна вызывать саму `show-prolog-"
"solutions`, так как печать будет обрабатываться примитивом для `show-prolog-"
"vars`"

#: in/chapter11.md:840
msgid ""
"```lisp\n"
"(defun top-level-prove (goals)\n"
"  (prove-all '(,@goals (show-prolog-vars ,@(variables-in goals)))\n"
"                        no-bindings)\n"
"  (format t \"~&No.\")\n"
"  (values))\n"
"```"
msgstr ""

#: in/chapter11.md:844
msgid ""
"Here we define the primitive `show-prolog-vars`.\n"
"All primitives must be functions of three arguments: a list of arguments to "
"the primitive relation (here a list of variables to show), a binding list "
"for these arguments, and a list of pending goals.\n"
"A primitive should either return `fail` or call `prove-all` to continue."
msgstr ""
"Здесь мы определяем примитивный `show-prolog-vars`.\n"
"Все примитивы должны быть функциями трех аргументов: списка аргументов "
"отношения примитивов (здесь список переменных для отображения), списка "
"привязки для этих аргументов и списка ожидающих целей.\n"
"Примитив должен либо вернуть `fail`, либо вызвать `prove-all` для "
"продолжения."

#: in/chapter11.md:858
msgid ""
"```lisp\n"
"(defun show-prolog-vars (vars bindings other-goals)\n"
"  \"Print each variable with its binding.\n"
"  Then ask the user if more solutions are desired.\"\n"
"  (if (null vars)\n"
"          (format t \"~&Yes\")\n"
"          (dolist (var vars)\n"
"              (format t \"~&~a = ~a\" var\n"
"                              (subst-bindings bindings var))))\n"
"  (if (continue-p)\n"
"          fail\n"
"          (prove-all other-goals bindings)))\n"
"```"
msgstr ""

#: in/chapter11.md:860
msgid ""
"Since primitives are represented as entries on the `clauses` property of "
"predicate symbols, we have to register `show- prolog - vars` as a primitive "
"like this:"
msgstr ""
"Поскольку примитивы представлены в виде записей в свойстве предикатных "
"символов `clauses`, мы должны зарегистрировать `show-prolog-vars` как "
"примитив, подобный этому:"

#: in/chapter11.md:864
msgid ""
"```lisp\n"
"(setf (get 'show-prolog-vars 'clauses) 'show-prolog-vars)\n"
"```"
msgstr ""

#: in/chapter11.md:866
msgid ""
"Finally, the Lisp predicate `continue-p` asks the user if he or she wants to "
"see more solutions:"
msgstr ""
"Наконец, предикат Лиспа `continue-p` спрашивает пользователя, хочет ли он "
"увидеть больше решений:"

#: in/chapter11.md:873
msgid ""
"```lisp\n"
"(defun continue-p ()\n"
"  \"Ask user if we should continue looking for solutions.\"\n"
"  (case (read-char)\n"
"    (#\\; t)\n"
"```"
msgstr ""

#: in/chapter11.md:876
msgid ""
"`    (#\\.\n"
"nil)`"
msgstr ""

#: in/chapter11.md:883
msgid ""
"```lisp\n"
"    (#\\newline (continue-p))\n"
"    (otherwise\n"
"      (format t \" Type ; to see more or . to stop\")\n"
"      (continue-p))))\n"
"```"
msgstr ""

#: in/chapter11.md:888
msgid ""
"This version works just as well as the previous version on finite problems.\n"
"The only difference is that the user, not the system, types the semicolons.\n"
"The advantage is that we can now use the system on infinite problems as "
"well.\n"
"First, we'll ask what lists 2 is a member of :"
msgstr ""
"Эта версия работает так же хорошо, как и предыдущая, с конечными задачами.\n"
"Единственное отличие состоит в том, что точки с запятой вводит пользователь, "
"а не система.\n"
"Преимущество состоит в том, что теперь мы можем использовать систему и для "
"решения бесконечных задач.\n"
"Сначала мы спросим, в какие списки входит 2:"

#: in/chapter11.md:897
msgid ""
"```lisp\n"
"> (?- (member 2 ?list))\n"
"?LIST = (2 . ?REST3302);\n"
"?LIST = (?X3303 2 . ?REST3307);\n"
"?LIST = (?X3303 ?X3308 2 . ?REST3312);\n"
"?LIST = (?X3303 ?X3308 ?X3313 2 . ?REST3317).\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:901
msgid ""
"The answers mean that 2 is a member of any list that starts with 2, or whose "
"second element is 2, or whose third element is 2, and so on.\n"
"The infinite computation was halted when the user typed a period rather than "
"a semicolon.\n"
"The \"no\" now means that there are no more answers to be printed; it will "
"appear if there are no answers at all, if the user types a period, or if all "
"the answers have been printed."
msgstr ""
"Ответы означают, что 2 является членом любого списка, который начинается с "
"2, или чей второй элемент равен 2, или чей третий элемент равен 2, и так "
"далее.\n"
"Бесконечное вычисление было остановлено, когда пользователь ввел точку, а не "
"точку с запятой.\n"
"Ответ \"no\"(нет) означает, что больше нет ответов для печати; он появится, "
"если ответов нет вообще, если пользователь вводит точку или если все ответы "
"были напечатаны."

#: in/chapter11.md:904
msgid ""
"We can ask even more abstract queries.\n"
"The answer to the next query says that an item is an element of a list when "
"it is the the first element, or the second, or the third, or the fourth, and "
"so on."
msgstr ""
"Мы можем задавать и более абстрактные вопросы.\n"
"Ответ на следующий запрос говорит, что элемент является элементом списка, "
"когда он является первым элементом, или вторым, или третьим, или четвертым, "
"и так далее."

#: in/chapter11.md:917
msgid ""
"```lisp\n"
"> (?- (member ?item ?list))\n"
"?ITEM = ?ITEM3318\n"
"?LIST = (?ITEM3318 . ?REST3319);\n"
"?ITEM = ?ITEM3323\n"
"?LIST = (?X3320 ?ITEM3323 . ?REST3324);\n"
"?ITEM = ?ITEM3328\n"
"?LIST = (?X3320 ?X3325 ?ITEM3328 . ?REST3329);\n"
"?ITEM = ?ITEM3333\n"
"?LIST = (?X3320 ?X3325 ?X3330 ?ITEM3333 . ?REST3334).\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:919
msgid "Now let's add the definition of the relation length:"
msgstr "Теперь добавим определение отношение длины(length):"

#: in/chapter11.md:924
msgid ""
"```lisp\n"
"(<- (length () 0))\n"
"(<- (length (?x . ?y) (1  + ?n)) (length ?y ?n))\n"
"```"
msgstr ""

#: in/chapter11.md:926
msgid ""
"Here are some queries showing that length can be used to find the second "
"argument, the first, or both:"
msgstr ""
"Вот несколько запросов, показывающих, что длина(length) может использоваться "
"для поиска второго аргумента, первого или обоих:"

#: in/chapter11.md:943
msgid ""
"```lisp\n"
"> (?- (length (a b c d) ?n))\n"
"?N = (1  + (1  + (1  + (1  + 0))));\n"
"No.\n"
"> (?- (length ?list (1  + (1  + 0))))\n"
"?LIST = (?X3869 ?X3872);\n"
"No.\n"
"> (?- (length ?list ?n))\n"
"?LIST = NIL\n"
"?N = 0;\n"
"?LIST = (?X3918)\n"
"?N = (1  + 0);\n"
"?LIST = (?X3918 ?X3921)\n"
"?N = (1  + (1  + 0)).\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:947
msgid ""
"The next two queries show the two lists of length two with a as a member.\n"
"Both queries give the correct answer, a two-element list that either starts "
"or ends with a.\n"
"However, the behavior after generating these two solutions is quite "
"different."
msgstr ""
"Следующие два запроса показывают два списка длины два с a в качестве члена.\n"
"Оба запроса дают правильный ответ - список из двух элементов, который "
"начинается или заканчивается на a.\n"
"Однако поведение после создания этих двух решений совершенно разное."

#: in/chapter11.md:957
msgid ""
"```lisp\n"
"> (?- (length ?l (1  + (1  + 0))) (member a ?l))\n"
"?L = (A ?X4057);\n"
"?L = (?Y4061 A);\n"
"No.\n"
"> (?- (member a ?l) (length ?l (1  + (1  + 0))))\n"
"?L = (A ?X4081);\n"
"?L = (?Y4085 A);[Abort]\n"
"```"
msgstr ""

#: in/chapter11.md:960
msgid ""
"In the first query, length only generates one possible solution, the list "
"with two unbound elements.\n"
"`member` takes this solution and instantiates either the first or the second "
"element to a."
msgstr ""
"В первом запросе length генерирует только одно возможное решение - список с "
"двумя несвязанными элементами.\n"
"`member` берет это решение и создает экземпляр первого или второго элемента "
"a."

#: in/chapter11.md:965
msgid ""
"In the second query, `member` keeps generating potential solutions.\n"
"The first two partial solutions, where a is the first or second member of a "
"list of unknown length, are extended by `length` to yield the solutions "
"where the list has length two.\n"
"After that, `member` keeps generating longer and longer lists, which "
"`length` keeps rejecting.\n"
"It is implicit in the definition of `member` that subsequent solutions will "
"be longer, but because that is not explicitly known, they are all generated "
"anyway and then explicitly tested and rejected by `length.`"
msgstr ""
"Во втором запросе member продолжает генерировать потенциальные решения.\n"
"Первые два частичных решения, где a - первый или второй член списка "
"неизвестной длины, расширяются на `length`, чтобы получить решения, у "
"которых список имеет длину два.\n"
"После этого member генерирует все более длинные списки, которые length "
"отвергает.\n"
"В определении элемента неявно подразумевается, что последующие решения будут "
"длиннее, но поскольку это явно не известно, все они все равно генерируются, "
"а затем явно проверяются и отклоняются с помощью параметра length."

#: in/chapter11.md:970
msgid ""
"This example reveals the limitations of Prolog as a pure logic-programming "
"language.\n"
"It turns out the user must be concerned not only about the logic of the "
"problem but also with the flow of control.\n"
"Prolog is smart enough to backtrack and find all solutions when the search "
"space is small enough, but when it is infinite (or even very large), the "
"programmer still has a responsibility to guide the flow of control.\n"
"It is possible to devise languages that do much more in terms of automatic "
"flow of control.[4](#fn0030) Prolog is a convenient and efficient middle "
"ground between imperative languages and pure logic."
msgstr ""
"Этот пример показывает ограничения Prolog как чистого языка логического "
"программирования.\n"
"Оказывается, пользователь должен заботиться не только о логике проблемы, но "
"и о потоке управления.\n"
"Prolog достаточно умен, чтобы возвращаться и находить все решения, когда "
"пространство поиска достаточно мало, но когда оно бесконечно (или даже очень "
"велико), программист по-прежнему несет ответственность за управление потоком "
"управления.\n"
"Можно разработать языки, которые делают гораздо больше с точки зрения "
"автоматического потока управления. [4](#fn0030) Пролог - это удобный и "
"эффективный промежуточный вариант между императивными языками и чистой "
"логикой."

#: in/chapter11.md:972
msgid "### Approaches to Backtracking"
msgstr "### Подходы к возврату(Backtracking)"

#: in/chapter11.md:979
msgid ""
"Suppose you are asked to make a \"small\" change to an existing program.\n"
"The problem is that some function, `f`, which was thought to be single-"
"valued, is now known to return two or more valid answers in certain "
"circumstances.\n"
"In other words, `f` is nondeterministic.\n"
"(Perhaps `f` is `sqrt`, and we now want to deal with negative numbers).\n"
"What are your alternatives as a programmer?\n"
"Five possibilities can be identified:"
msgstr ""
"Предположим, вас просят внести \"небольшое\" изменение в существующую "
"программу.\n"
"Проблема в том, что некоторая функция `f`, которая считалась "
"однозначной(возвращающей одно значение), как теперь стало известно, при "
"определенных обстоятельствах возвращает два или более правильных ответа.\n"
"Другими словами, `f` недетерминирована.\n"
"(Возможно, `f` это `sqrt`, и теперь мы хотим иметь дело с отрицательными "
"числами).\n"
"Какие у вас есть альтернативы как программиста?\n"
"Можно выделить пять возможностей:"

#: in/chapter11.md:983
msgid ""
"*   Guess.\n"
"Choose one possibility and discard the others.\n"
"This requires a means of making the right guesses, or recovering from wrong "
"guesses."
msgstr ""
"*   Угадывание.\n"
"Выберем одну возможность и отбросим остальные.\n"
"Для этого нужны средства, позволяющие делать правильные предположения или "
"отказываться от неправильных предположений."

#: in/chapter11.md:987
msgid ""
"*   Know.\n"
"Sometimes you can provide additional information that is enough to decide "
"what the right choice is.\n"
"This means changing the calling function(s) to provide the additional "
"information."
msgstr ""
"*   Знание\n"
"Иногда вы можете предоставить дополнительную информацию, которой достаточно, "
"чтобы решить, какой выбор будет правильным.\n"
"Это означает изменение вызывающих функций для предоставления дополнительной "
"информации."

#: in/chapter11.md:990
msgid ""
"*   Return a list.\n"
"This means that the calling function(s) must be changed to expect a list of "
"replies."
msgstr ""
"*   Вернуть список.\n"
"Это означает, что вызывающую функцию(-и) необходимо изменить, чтобы она "
"ожидала в ответ список."

#: in/chapter11.md:993
msgid ""
"*   Return a *pipe,* as defined in [section 9.3](B9780080571157500091."
"xhtml#s0020).\n"
"Again, the calling function(s) must be changed to expect a pipe."
msgstr ""
"*   Вернуть *канал*(pipe), как определено в [разделе 9.3]"
"(B9780080571157500091.xhtml#s0020).\n"
"Опять же, вызывающие функции должны быть изменены для ожидания канала."

#: in/chapter11.md:997
msgid ""
"*   Guess and save.\n"
"Choose one possibility and return it, but record enough information to allow "
"computing the other possibilities later.\n"
"This requires saving the current state of the computation as well as some "
"information on the remaining possibilities."
msgstr ""
"*   Угадать и сохранить.\n"
"Выберите одну возможность и верните ее, но запишите достаточно информации, "
"чтобы позже можно было вычислить другие возможности.\n"
"Это требует сохранения текущего состояния вычислений, а также некоторой "
"информации об оставшихся возможностях."

#: in/chapter11.md:1004
msgid ""
"The last alternative is the most desirable.\n"
"It is efficient, because it doesn't require computing answers that are never "
"used.\n"
"It is unobtrusive, because it doesn't require changing the calling function "
"(and the calling function's calling function) to expect a list or pipe of "
"answers.\n"
"Unfortunately, it does have one major difficulty: there has to be a way of "
"packaging up the current state of the computation and saving it away so that "
"it can be returned to when the first choice does not work.\n"
"For our Prolog interpreter, the current state is succinctly represented as a "
"list of goals.\n"
"In other problems, it is not so easy to summarize the entire state."
msgstr ""
"Последняя альтернатива наиболее желательна.\n"
"Она эффективна, потому что не требует вычисления ответов, которые никогда не "
"используются.\n"
"Она ненавязчива, поскольку не требует изменения вызывающей функции (и "
"вызывающей функции вызывающей функции) для ожидания списка или канала(pipe) "
"для ответов.\n"
"К сожалению, у него есть одна серьезная трудность: должен быть способ "
"упаковать текущее состояние вычисления и сохранить его, чтобы его можно было "
"вернуть, когда первый вариант не сработает.\n"
"Для нашего интерпретатора Пролога текущее состояние кратко представлено в "
"виде списка целей.\n"
"В других задачах не так-то просто подвести итоги всего состояния."

#: in/chapter11.md:1007
msgid ""
"We will see in [section 22.4](B9780080571157500224.xhtml#s0025) that the "
"Scheme dialect of Lisp provides a function, `call-with-current-"
"continuation`, that does exactly what we want: it packages the current state "
"of the computation into a function, which can be stored away and invoked "
"later.\n"
"Unfortunately, there is no corresponding function in Common Lisp."
msgstr ""
"В [разделе 22.4](B9780080571157500224.xhtml#s0025) мы увидим, что диалект "
"Scheme в Lisp предоставляет функцию `call-with-current-continuation`, "
"которая делает именно то, что мы хотим: она упаковывает текущее состояние "
"вычислений в функцию, которую можно сохранить и вызывать позже.\n"
"К сожалению, в Common Lisp нет соответствующей функции."

#: in/chapter11.md:1009
msgid "### Anonymous Variables"
msgstr "### Анонимные переменные"

#: in/chapter11.md:1013
msgid ""
"Before moving on, it is useful to introduce the notion of an *anonymous "
"variable.* This is a variable that is distinct from all others in a clause "
"or query, but which the programmer does not want to bother to name.\n"
"In real Prolog, the underscore is used for anonymous variables, but we will "
"use a single question mark.\n"
"The definition of `member` that follows uses anonymous variables for "
"positions within terms that are not needed within a clause:"
msgstr ""
"Прежде чем двигаться дальше, полезно ввести понятие *анонимной переменной*. "
"Это переменная, которая отличается от всех других в предложении или запросе, "
"но программист не хочет давать ей имя.\n"
"В реальном Прологе нижнее подчеркивание используется для анонимных "
"переменных, но мы будем использовать одиночный знак вопроса.\n"
"В последующем определении `member` используются анонимные переменные для "
"обозначения позиций внутри терминов, которые не нужны в предложении:"

#: in/chapter11.md:1017
msgid ""
"```lisp\n"
"(<- (member ?item (?item . ?)))\n"
"```"
msgstr ""

#: in/chapter11.md:1020
msgid ""
"`(<- (member ?item (?\n"
". ?rest)) (member ?item ?rest))`"
msgstr ""

#: in/chapter11.md:1025
msgid ""
"However, we also want to allow several anonymous variables in a clause but "
"still be able to keep each anonymous variable distinct from all other "
"variables.\n"
"One way to do that is to replace each anonymous variable with a unique "
"variable.\n"
"The function `replace-?-vars` uses `gensym` to do just that.\n"
"It is installed in the top-level macros `<-` and `?-` so that all clauses "
"and queries get the proper treatment."
msgstr ""
"Однако мы также хотим разрешить несколько анонимных переменных в "
"предложении, но при этом иметь возможность сохранять каждую анонимную "
"переменную отдельно от всех других переменных.\n"
"Один из способов сделать это - заменить каждую анонимную переменную "
"уникальной переменной.\n"
"Функция `replace-?-vars` использует для этого `gensym`.\n"
"Она устанавливается в макросы верхнего уровня `<-` и `?-`, чтобы все "
"предложения и запросы обрабатывались должным образом."

#: in/chapter11.md:1041
msgid ""
"```lisp\n"
"(defmacro <- (&rest clause)\n"
"  \"Add a clause to the data base.\"\n"
"  '(add-clause ',(replace-?-vars clause)))\n"
"(defmacro ?- (&rest goals)\n"
"  \"Make a query and print answers.\"\n"
"  '(top-level-prove '.(replace-?-vars goals)))\n"
"(defun replace-?-vars (exp)\n"
"  \"Replace any ? within exp with a var of the form ?123.\"\n"
"  (cond ((eq exp '?) (gensym \"?\"))\n"
"              ((atom exp) exp)\n"
"              (t (reuse-cons (replace-?-vars (first exp))\n"
"                                            (replace-?-vars (rest exp))\n"
"                                            exp))))\n"
"```"
msgstr ""

#: in/chapter11.md:1044
msgid ""
"A named variable that is used only once in a clause can also be considered "
"an anonymous variable.\n"
"This is addressed in a different way in [section 12.3](B9780080571157500121."
"xhtml#s0020)."
msgstr ""
"Именованная переменная, которая используется в предложении только один раз, "
"также может считаться анонимной переменной.\n"
"Это решается другим способом в [раздел 12.3](B9780080571157500121."
"xhtml#s0020)."

#: in/chapter11.md:1046
msgid "## 11.4 The Zebra Puzzle"
msgstr "## 11.4 Загадка(Puzzle) зебры"

#: in/chapter11.md:1049
msgid ""
"Here is an example of something Prolog is very good at: a logic puzzle.\n"
"There are fifteen facts, or constraints, in the puzzle:"
msgstr ""
"Вот пример того, в чем Prolog очень хорош: логическая головоломка.\n"
"В головоломке есть пятнадцать фактов или ограничений:"

#: in/chapter11.md:1052
msgid ""
"1.  There are five houses in a line, each with an owner, a pet, a cigarette, "
"a drink, and a color.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  There are five houses in a line, each with an owner, a pet, a cigarette, "
"a drink, and a color.(В линию пять домов, в каждом есть хозяин, домашнее "
"животное, сигарета, напиток и цвет.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1055
msgid ""
"2.  The Englishman lives in the red house.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  The Englishman lives in the red house.(Англичанин живет в красном "
"доме.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1058
msgid ""
"3.  The Spaniard owns the dog.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  The Spaniard owns the dog.(Собака принадлежит испанцу.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1061
msgid ""
"4.  Coffee is drunk in the green house.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Coffee is drunk in the green house.(В зеленом доме пьют кофе.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1064
msgid ""
"5.  The Ukrainian drinks tea.\n"
"!!!(p) {:.numlist}"
msgstr ""
"5.  The Ukrainian drinks tea.(Украинец пьет чай.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1067
msgid ""
"6.  The green house is immediately to the right of the ivory house.\n"
"!!!(p) {:.numlist}"
msgstr ""
"6.  The green house is immediately to the right of the ivory house."
"(Оранжерея находится справа от дома из слоновой кости.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1070
msgid ""
"7.  The Winston smoker owns snails.\n"
"!!!(p) {:.numlist}"
msgstr ""
"7.  The Winston smoker owns snails.(Курильщик Winston владеет улитками.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1073
msgid ""
"8.  Kools are smoked in the yellow house.\n"
"!!!(p) {:.numlist}"
msgstr ""
"8.  Kools are smoked in the yellow house.(В желтом доме курят кулы.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1076
msgid ""
"9.  Milk is drunk in the middle house.\n"
"!!!(p) {:.numlist}"
msgstr ""
"9.  Milk is drunk in the middle house.(В среднем доме пьют молоко.)\n"
"!!!(p) {:.numlist}"

#: in/chapter11.md:1079
msgid ""
"10.  The Norwegian lives in the first house on the left.\n"
"!!!(p) {:.numlista}"
msgstr ""
"10.  The Norwegian lives in the first house on the left.(Норвежец живет в "
"первом доме слева.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1082
msgid ""
"11.  The man who smokes Chesterfields lives next to the man with the fox.\n"
"!!!(p) {:.numlista}"
msgstr ""
"11.  The man who smokes Chesterfields lives next to the man with the fox."
"(Мужчина, который курит Честерфилд, живет рядом с человеком с лисой.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1085
msgid ""
"12.  Kools are smoked in the house next to the house with the horse.\n"
"!!!(p) {:.numlista}"
msgstr ""
"12.  Kools are smoked in the house next to the house with the horse.(В доме "
"рядом с домом с лошадью коптят/курят кулы.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1088
msgid ""
"13.  The Lucky Strike smoker drinks orange juice.\n"
"!!!(p) {:.numlista}"
msgstr ""
"13.  The Lucky Strike smoker drinks orange juice.(Курильщик Lucky Strike "
"пьет апельсиновый сок.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1091
msgid ""
"14.  The Japanese smokes Parliaments.\n"
"!!!(p) {:.numlista}"
msgstr ""
"14.  The Japanese smokes Parliaments.(Японцы курят парламенты.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1094
msgid ""
"15.  The Norwegian lives next to the blue house.\n"
"!!!(p) {:.numlista}"
msgstr ""
"15.  The Norwegian lives next to the blue house.(Норвежец живет рядом с "
"синим домом.)\n"
"!!!(p) {:.numlista}"

#: in/chapter11.md:1098
msgid ""
"The questions to be answered are: who drinks water and who owns the zebra?\n"
"To solve this puzzle, we first define the relations `nextto` (for \"next to"
"\") and `iright` (for \"immediately to the right of\").\n"
"They are closely related to `member,` which is repeated here."
msgstr ""
"Необходимо ответить на следующие вопросы: who drinks water and who owns the "
"zebra?(кто пьет воду и кому принадлежит зебра?)\n"
"Чтобы решить эту загадку, мы сначала определяем отношения `nextto` (для "
"\"рядом с\" - \"next to\") и `iright` (для \"непосредственно справа от\" - "
"\"immediately to the right of\").\n"
"Они тесно связаны с отношением `member`, которое здесь повторяется."

#: in/chapter11.md:1100
msgid "(<- `(member ?item (?item . ?rest)))`"
msgstr ""

#: in/chapter11.md:1102
msgid "(<- `(member ?item (?x . ? rest)) (member ?item ?rest))`"
msgstr ""

#: in/chapter11.md:1104
msgid "(<- `(nextto ?x ?y ?list) (iright ?x ?y ?list))`"
msgstr ""

#: in/chapter11.md:1106
msgid "(<- `(nextto ?x ?y ?list) (iright ?y ?x ?list))`"
msgstr ""

#: in/chapter11.md:1108
msgid "(<- `(iright ?left ?right (?left ?right . ?rest)))`"
msgstr ""

#: in/chapter11.md:1110
msgid "(<- `(iright ?left ?right (?x . ?rest))`"
msgstr ""

#: in/chapter11.md:1114
msgid ""
"```lisp\n"
"      (iright ?left ?right ?rest))\n"
"```"
msgstr ""

#: in/chapter11.md:1116
msgid "(<- `(= ?x ?x))`"
msgstr ""

#: in/chapter11.md:1121
msgid ""
"We also defined the identity relation, =.\n"
"It has a single clause that says that any x is equal to itself.\n"
"One might think that this implements eq or equal.\n"
"Actually, since Prolog uses unification to see if the two arguments of a "
"goal each unify with `?x`, this means that = is unification."
msgstr ""
"Мы также определили отношение тождества =.\n"
"В нем есть одно предложение, в котором говорится, что любой x равен самому "
"себе.\n"
"Можно подумать, что это реализует eq или equal.\n"
"Фактически, поскольку Пролог использует унификацию, чтобы увидеть, "
"объединяются/унифицируются ли каждый из двух аргументов цели с помощью `?x`, "
"это означает, что = является унификацией/объединением."

#: in/chapter11.md:1127
msgid ""
"Now we are ready to define the zebra puzzle with a single (long) clause.\n"
"The variable `?h` represents the list of five houses, and each house is "
"represented by a term of the form (house *nationality pet cigarette drink "
"color*).\n"
"The variable `?w` is the water drinker, and `?z` is the zebra owner.\n"
"Each of the 15 constraints in the puzzle is listed in the `body` of `zebra,` "
"although constraints 9 and 10 have been combined into the first one.\n"
"Consider constraint 2, \"The Englishman lives in the `red` house.\" This is "
"interpreted as \"there is a house whose nationality is Englishman and whose "
"color is `red,` and which is a member of the list of houses\": in other "
"words, `(member (house englishman ? ? ? red) ?h).` The other constraints are "
"similarly straightforward."
msgstr ""
"Теперь мы готовы определить головоломку \"зебра\" с помощью одного "
"(длинного) предложения.\n"
"Переменная \"?h\" представляет список из пяти домов, и каждый дом "
"представлен термином в форме (house *nationality pet cigarette drink color*)-"
"(дом *национальность питомец сигарета напиток цвепт*).\n"
"Переменная `?w` - пьющий воду, а `?z` - владелец зебры.\n"
"Каждое из 15 ограничений в головоломке перечислено в `теле` `зебры`, хотя "
"ограничения 9 и 10 были объединены в первое(одно).\n"
"Рассмотрим ограничение 2: \"The Englishman lives in the `red` house."
"\"(Англичанин живет в `красном` доме). Оно интерпретируется как \"есть дом, "
"национальность которого - англичанин, цвет - красный, и который входит в "
"список домов\": другими словами, `(member (house englishman ? ? ? red) ?h).` "
"Остальные ограничения также просты."

#: in/chapter11.md:1155
msgid ""
"```lisp\n"
"(<- (zebra ?h ?w ?z)\n"
"  ;; Each house is of the form:\n"
"  ;; (house nationality pet cigarette drink house-color)\n"
"  (= ?h ((house norwegian ? ? ? ?)                                    ;1,10\n"
"                ?\n"
"                (house ? ? ? "
"milk ?) ? ?))                                  ; 9\n"
"  (member (house englishman ? ? ? red) ?h)                    ; 2\n"
"  (member (house spaniard dog ? ? ?) ?h)                        ; 3\n"
"  (member (house ? ? ? coffee green) ?h)                        ; 4\n"
"  (member (house ukrainian ? ? tea ?) ?h)                      ; 5\n"
"  (iright (house ? ? ? ? ivory)                                          ; "
"6\n"
"                  (house 1111 green) ?h)\n"
"  (member (house ? snails winston ? ?) ?h)                    ; 7\n"
"  (member (house ? ? kools ? yellow) ?h)                        ; 8\n"
"  (nextto (house ? ? chesterfield ? ?)                            ;11\n"
"                  (house ? fox ? ? ?) ?h)\n"
"  (nextto (house ? ? "
"kools ? ?)                                          ;12\n"
"                  (house ? horse ? ? ?) ?h)\n"
"  (member (house ? ? luckystrike orange-juice ?) ?h);13\n"
"  (member (house japanese ? parliaments ? ?) ?h)        ;14\n"
"  (nextto (house norwegian ? ? ? ?)                                  ;15\n"
"                  (house ? ? ? ? blue) ?h)\n"
"  ;; Now for the questions:\n"
"  (member (house ?w ? ? water ?) ?h)                                ;Q1\n"
"  (member (house ?z zebra ? ? ?) ?h))                              ;Q2\n"
"```"
msgstr ""

#: in/chapter11.md:1157
msgid "Here's the query and solution to the puzzle:"
msgstr "Вот вопрос и решение загадки:"

#: in/chapter11.md:1169
msgid ""
"```lisp\n"
"> (?- (zebra ?houses ?water-drinker ?zebra-owner))\n"
"?HOUSES = ((HOUSE NORWEGIAN FOX KOOLS WATER YELLOW)\n"
"                      (HOUSE UKRAINIAN HORSE CHESTERFIELD TEA BLUE)\n"
"                      (HOUSE ENGLISHMAN SNAILS WINSTON MILK RED)\n"
"                      (HOUSE SPANIARD DOG LUCKYSTRIKE ORANGE-JUICE IVORY)\n"
"                      (HOUSE JAPANESE ZEBRA PARLIAMENTS COFFEE GREEN))\n"
"?WATER-DRINKER = NORWEGIAN\n"
"?ZEBRA-OWNER = JAPANESE.\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:1173
msgid ""
"This took 278 seconds, and profiling (see page 288) reveals that the "
"function prove was called 12,825 times.\n"
"A call to prove has been termed a *logical inference, so* our system is "
"performing 12825/278 = 46 logical inferences per second, or LIPS.\n"
"Good Prolog systems perform at 10,000 to 100,000 LIPS or more, so this is "
"barely limping along."
msgstr ""
"Это заняло 278 секунд, а профилирование (см. Стр. 288) показывает, что "
"функция proof вызывалась 12825 раз.\n"
"Вызов prove(доказательства) был назван *логическим выводом, поэтому* наша "
"система выполняет 12825/278 = 46 логических выводов в секунду, или LIPS.\n"
"Хорошие системы Prolog работают со скоростью от 10 000 до 100 000 LIPS или "
"более, так что эта едва ли не прихрамывает."

#: in/chapter11.md:1178
msgid ""
"Small changes to the problem can greatly affect the search time.\n"
"For example, the relation nextto holds when the first house is immediately "
"right of the second, or when the second is immediately right of the first.\n"
"It is arbitrary in which order these clauses are listed, and one might think "
"it would make no difference in which order they were listed.\n"
"In fact, if we reverse the order of these two clauses, the execution time is "
"roughly cut in half."
msgstr ""
"Небольшие изменения в проблеме могут сильно повлиять на время поиска.\n"
"Например, отношение nextto выполняется, когда первый дом находится "
"непосредственно справа от второго или когда второй находится непосредственно "
"справа от первого.\n"
"Порядок перечисления этих пунктов произвольный, и можно подумать, что не "
"имеет значения, в каком порядке они перечислены.\n"
"Фактически, если мы изменим порядок этих двух предложений, время выполнения "
"сократится примерно вдвое."

#: in/chapter11.md:1180
msgid "## 11.5 The Synergy of Backtracking and Unification"
msgstr "## 11.5 Синергия поиска с возвратом и унификации/объединения"

#: in/chapter11.md:1184
msgid ""
"Prolog's backward chaining with backtracking is a powerful technique for "
"generating the possible solutions to a problem.\n"
"It makes it easy to implement a *generate-and-test* strategy, where possible "
"solutions are considered one at a time, and when a candidate solution is "
"rejected, the next is suggested.\n"
"But generate-and-test is only feasible when the space of possible solutions "
"is small."
msgstr ""
"Обратная цепочка с обратным отслеживанием в Prolog - мощный метод для "
"генерации возможных решений проблемы.\n"
"Это упрощает реализацию стратегии *создать и тестировать(проверить)*, при "
"которой возможные решения рассматриваются по одному, а когда решение-"
"кандидат отклоняется, предлагается следующее.\n"
"Но создание и тестирование возможно только тогда, когда пространство "
"возможных решений невелико."

#: in/chapter11.md:1196
msgid ""
"In the zebra puzzle, there are five attributes for each of the five houses.\n"
"Thus there are 5!5, or over 24 billion candidate solutions, far too many to "
"test one at a time.\n"
"It is the concept of unification (with the corresponding notion of a logic "
"variable) that makes generate-and-test feasible on this puzzle.\n"
"Instead of enumerating complete candidate solutions, unification allows us "
"to specify *partial* candidates.\n"
"We start out knowing that there are five houses, with the Norwegian living "
"on the far left and the milk drinker in the middle.\n"
"Rather than generating all complete candidates that satisfy these two "
"constraints, we leave the remaining information vague, by unifying the "
"remaining houses and attributes with anonymous logic variables.\n"
"The next constraint (number 2) places the Englishman in the red house.\n"
"Because of the way `member` is written, this first tries to place the "
"Englishman in the leftmost house.\n"
"This is rejected, because Englishman and Norwegian fail to unify, so the "
"next possibility is considered, and the Englishman is placed in the second "
"house.\n"
"But no other features of the second house are specified-we didn't have to "
"make separate guesses for the Englishman's house being green, yellow, and so "
"forth.\n"
"The search continues, filling in only as much as is necessary and backing up "
"whenever a unification fails."
msgstr ""
"В головоломке с зеброй для каждого из пяти домов есть пять атрибутов.\n"
"Таким образом, существует 5!5 или более 24 миллиардов возможных решений, "
"слишком много, чтобы тестировать по одному.\n"
"Именно концепция унификации (с соответствующим понятием логической "
"переменной) делает возможным создание и тестирование этой головоломки.\n"
"Вместо того, чтобы перечислять полные варианты решений, унификация позволяет "
"нам указать *частичные*  кандидаты.\n"
"Мы начинаем с того, что узнаём, что есть пять домов, где норвежец живет "
"слева, а пьющий молоко посередине.\n"
"Вместо того, чтобы генерировать всех полных кандидатов, удовлетворяющих этим "
"двум ограничениям, мы оставляем оставшуюся информацию неопределенной, "
"объединяя оставшиеся дома и атрибуты с анонимными логическими переменными.\n"
"Следующее ограничение (номер 2) помещает англичанина в красный дом.\n"
"Из-за того, как написано `member`, сначала пытается поместить англичанина в "
"крайний левый дом.\n"
"Это отклоняется, потому что англичанин и норвежец не могут "
"объединиться(унифицироваться/unify), поэтому рассматривается следующая "
"возможность, и англичанин помещается во второй дом.\n"
"Но никакие другие особенности второго дома не указаны - нам не нужно было "
"делать отдельные предположения о том, что дом англичанина зеленый, желтый и "
"так далее.\n"
"Поиск продолжается, заполняя ровно столько, сколько необходимо, и делая "
"резервные копии всякий раз, когда объединение(унификация) не удается."

#: in/chapter11.md:1200
msgid ""
"For this problem, unification serves the same purpose as the delay macro "
"(page 281).\n"
"It allows us to delay deciding the value of some attribute as long as "
"possible, but to immediately reject a solution that tries to give two "
"different values to the same attribute.\n"
"That way, we save time if we end up backtracking before the computation is "
"made, but we are still able to fill in the value later on."
msgstr ""
"В этой проблеме унификация служит той же цели, что и макрос задержки(delay) "
"(стр. 281).\n"
"Это позволяет нам отложить определение значения некоторого атрибута как "
"можно дольше, но немедленно отклонить решение, которое пытается присвоить "
"два разных значения одному и тому же атрибуту.\n"
"Таким образом, мы сэкономим время, если в конечном итоге возвращаемся до "
"того, как вычисление будет выполнено, но мы все равно сможем заполнить "
"значение позже."

#: in/chapter11.md:1203
msgid ""
"It is possible to extend unification so that it is doing more work, and "
"backtracking is doing less work.\n"
"Consider the following computation:"
msgstr ""
"Можно расширить унификацию, чтобы она выполняла больше работы, а при "
"возврате выполнялось меньше работы.\n"
"Рассмотрим следующее вычисление:"

#: in/chapter11.md:1209
msgid ""
"```lisp\n"
"(?- (length ?l 4)\n"
"        (member d ?l) (member a ?l) (member c ?l) (member b ?l)\n"
"        (= ?l (a b c d)))\n"
"```"
msgstr ""

#: in/chapter11.md:1216
msgid ""
"The first two lines generate permutations of the list (`d a c b`), and the "
"third line tests for a permutation equal to (`a b c d`).\n"
"Most of the work is done by backtracking.\n"
"An alternative is to extend unification to deal with lists, as well as "
"constants and variables.\n"
"Predicates like `length` and `member` would be primitives that would have to "
"know about the representation of lists.\n"
"Then the first two lines of the above program would `set ?l` to something "
"like `#s (list :length 4 :members (d a c d))`.\n"
"The third line would be a call to the extended unification procedure, which "
"would further specify `?l` to be something like:"
msgstr ""
"Первые две строки генерируют перестановки списка (`d a c b`), а третья "
"строка проверяет перестановку, равную (`a b c d`).\n"
"Большая часть работы выполняется путем возврата(backtracking).\n"
"Альтернативой является расширение унификации для работы со списками, а также "
"константами и переменными.\n"
"Предикаты, такие как `length` и `member`, будут примитивами, которые должны "
"знать о представлении списков.\n"
"Затем в первых двух строках приведенной выше программы для `set ?l` будет "
"указано что-то вроде `#s (list :length 4 :members (d a c d))`.\n"
"Третья строка будет вызовом расширенной процедуры унификации, которая будет "
"дополнительно определять `?l` чем-то вроде:"

#: in/chapter11.md:1220
msgid ""
"```lisp\n"
"#s(list :length 4 imembers (d a c d) :order (abc d))\n"
"```"
msgstr ""

#: in/chapter11.md:1222
msgid ""
"By making the unification procedure more complex, we eliminate the need for "
"backtracking entirely."
msgstr ""
"Усложняя процедуру унификации, мы полностью устраняем необходимость в "
"обратном отслеживании."

#: in/chapter11.md:1224
msgid ""
"**Exercise  11.3 [s]** Would a unification algorithm that delayed `member` "
"tests be a good idea or a bad idea for the zebra puzzle?"
msgstr ""
"**Упражнение 11.3 [s]** Будет ли алгоритм унификации, который откладывает "
"тесты \"member\", хорошей или плохой идеей для головоломки зебра?"

#: in/chapter11.md:1226
msgid "## 11.6 Destructive Unification"
msgstr "## 11.6 Разрушающая унификация/объединение"

#: in/chapter11.md:1234
msgid ""
"As we saw in [section 11.2](#s0015), keeping track of a binding list of "
"variables is a little tricky.\n"
"It is also prone to inefficiency if the binding list grows large, because "
"the list must be searched linearly, and because space must be allocated to "
"hold the binding list.\n"
"An alternative implementation is to change `unify` to a destructive "
"operation.\n"
"In this approach, there are no binding lists.\n"
"Instead, each variable is represented as a structure that includes a field "
"for its binding.\n"
"When the variable is unified with another expression, the variable's binding "
"field is modified to point to the expression.\n"
"Such variables will be called `vars` to distinguish them from the "
"implementation of variables as symbols starting with a question mark, `vars` "
"are defined with the following code:"
msgstr ""
"Как мы видели в [раздел 11.2](#s0015), отслеживать список привязки "
"переменных немного сложно.\n"
"Кроме того, это может привести к неэффективности, если список привязок "
"становится большим, потому что список должен просматриваться линейно, и "
"потому что для хранения списка привязок необходимо выделить пространство.\n"
"Альтернативная реализация - заменить `unify` на деструктивную операцию.\n"
"В этом подходе нет списков привязок.\n"
"Вместо этого каждая переменная представлена как структура, которая включает "
"поле для ее привязки.\n"
"Когда переменная объединяется(унифицируется) с другим выражением, поле "
"привязки переменной изменяется, чтобы указывать на выражение.\n"
"Такие переменные будут называться `vars`, чтобы отличать их от реализации "
"переменных в виде символов, начинающихся с вопросительного знака, `vars` "
"определяются следующим кодом:"

#: in/chapter11.md:1240
msgid ""
"```lisp\n"
"(defconstant unbound \"Unbound\")\n"
"(defstruct var name (binding unbound))\n"
"(defun bound-p (var) (not (eq (var-binding var) unbound)))\n"
"```"
msgstr ""

#: in/chapter11.md:1243
msgid ""
"The macro deref gets at the binding of a variable, returning its argument "
"when it is an unbound variable or a non-variable expression.\n"
"It includes a loop because a variable can be bound to another variable, "
"which in turn is bound to the ultimate value."
msgstr ""
"Макрос deref достигает привязки переменной, возвращая ее аргумент, если это "
"несвязанная(unbound) переменная или выражение без переменной.\n"
"Он включает цикл, потому что переменная может быть привязана к другой "
"переменной, которая, в свою очередь, привязана к конечному значению."

#: in/chapter11.md:1247
msgid ""
"Normally, it would be considered bad practice to implement deref as a macro, "
"since it could be implemented as an inline function, provided the caller was "
"willing to write `(setf x (deref x))` instead of `(deref x)`.\n"
"However, deref will appear in code generated by some versions of the Prolog "
"compiler that will be presented in the next section.\n"
"Therefore, to make the generated code look neater, I have allowed myself the "
"luxury of the `deref` macro."
msgstr ""
"Обычно считается плохой практикой реализовать deref как макрос, поскольку он "
"может быть реализован как встроенная функция, при условии, что вызывающий "
"желает написать `(setf x (deref x))` вместо `(deref x)`.\n"
"Однако deref будет появляться в коде, сгенерированном некоторыми версиями "
"компилятора Prolog, который будет представлен в следующем разделе.\n"
"Поэтому, чтобы сгенерированный код выглядел более аккуратно, я позволил себе "
"роскошь макроса `deref`."

#: in/chapter11.md:1255
msgid ""
"```lisp\n"
"(defmacro deref (exp)\n"
"  \"Follow pointers for bound variables.\"\n"
"  '(progn (loop while (and (var-p ,exp) (bound-p ,exp))\n"
"                        do (setf ,exp (var-binding ,exp)))\n"
"                  ,exp))\n"
"```"
msgstr ""

#: in/chapter11.md:1258
msgid ""
"The function `unify!` below is the destructive version of `unify`.\n"
"It is a predicate that returns true for success and false for failure, and "
"has the side effect of altering variable bindings."
msgstr ""
"Функция `unify!` ниже является деструктивной версией `unify`.\n"
"Это предикат, который возвращает истину в случае успеха и ложь в случае "
"неудачи и имеет побочный эффект изменения привязок переменных."

#: in/chapter11.md:1261
msgid ""
"`(defun unify!\n"
"(x y)`"
msgstr ""

#: in/chapter11.md:1266
msgid ""
"```lisp\n"
"  \"Destructively unify two expressions\"\n"
"  (cond ((eql (deref x) (deref y)) t)\n"
"```"
msgstr ""

#: in/chapter11.md:1269
msgid ""
"`              ((var-p x) (set-binding!\n"
"x y))`"
msgstr ""

#: in/chapter11.md:1272
msgid ""
"`              ((var-p y) (set-binding!\n"
"y x))`"
msgstr ""

#: in/chapter11.md:1276
msgid ""
"```lisp\n"
"              ((and (consp x) (consp y))\n"
"```"
msgstr ""

#: in/chapter11.md:1279
msgid ""
"`              (and (unify!\n"
"(first x) (first y))`"
msgstr ""

#: in/chapter11.md:1282
msgid ""
"`                        (unify!\n"
"(rest x) (rest y))))`"
msgstr ""

#: in/chapter11.md:1286
msgid ""
"```lisp\n"
"              (t nil)))\n"
"```"
msgstr ""

#: in/chapter11.md:1289
msgctxt "in/chapter11.md:1289"
msgid ""
"`(defun set-binding!\n"
"(var value)`"
msgstr ""

#: in/chapter11.md:1292
msgid ""
"`  \"Set var's binding to value.\n"
"Always succeeds (returns t).\"`"
msgstr ""

#: in/chapter11.md:1297
msgid ""
"```lisp\n"
"  (setf (var-binding var) value)\n"
"  t)\n"
"```"
msgstr ""

#: in/chapter11.md:1299
msgid "To make `vars` easier to read, we can install a :`print-function`:"
msgstr "Чтобы упростить чтение `vars`, мы можем установить: `print-function`:"

#: in/chapter11.md:1310
msgid ""
"```lisp\n"
"(defstruct (var (:print-function print-var))\n"
"      name (binding unbound))\n"
"  (defun print-var (var stream depth)\n"
"      (if (or (and (numberp *print-level*)\n"
"                        (>= depth *print-level*))\n"
"              (var-p (deref var)))\n"
"        (format stream \"?~a\" (var-name var))\n"
"        (write var :stream stream)))\n"
"```"
msgstr ""

#: in/chapter11.md:1319
msgid ""
"This is the first example of a carefully crafted : `print-function`.\n"
"There are three things to notice about it.\n"
"First, it explicitly writes to the stream passed as the argument.\n"
"It does not write to a default stream.\n"
"Second, it checks the variable `depth` against `*print-level*`, and prints "
"just the variable name when the depth is exceeded.\n"
"Third, it uses `write` to print the bindings.\n"
"This is because write pays attention to the current values of `*print-"
"escape*, *print-pretty*`, and `soon`.\n"
"Other printing functions such as `prinl` or `print` do not pay attention to "
"these variables."
msgstr ""
"Это первый пример тщательно продуманной: `print-function`.\n"
"Следует отметить три вещи.\n"
"Во-первых, она явно записывает в поток, переданный в качестве аргумента.\n"
"Она не записывает в поток по умолчанию.\n"
"Во-вторых, она проверяет переменную `depth` на `*print-level*` и печатает "
"только имя переменной при превышении глубины.\n"
"В-третьих, она использует `write` для печати привязок.\n"
"Это связано с тем, что write обращает внимание на текущие значения `*print-"
"escape*, *print-pretty*` и `soon`.\n"
"Другие функции печати, такие как `prinl` или `print`, не обращают внимания "
"на эти переменные."

#: in/chapter11.md:1321
msgid ""
"Now, for backtracking purposes, we want to make `set-binding!` keep track of "
"the bindings that were made, so they can be undone later:"
msgstr ""
"Теперь, для целей обратного отслеживания(backtracking), мы хотим, чтобы `set-"
"binding!` отслеживал сделанные привязки, чтобы их можно было отменить позже:"

#: in/chapter11.md:1325
msgid ""
"```lisp\n"
"(defvar *trall* (make-array 200 :fill-pointer 0 :adjustable t))\n"
"```"
msgstr ""

#: in/chapter11.md:1328
msgctxt "in/chapter11.md:1328"
msgid ""
"`(defun set-binding!\n"
"(var value)`"
msgstr ""

#: in/chapter11.md:1332
msgid ""
"```lisp\n"
"  \"Set var's binding to value, after saving the variable\n"
"```"
msgstr ""

#: in/chapter11.md:1335
msgid ""
"`  in the trail.\n"
"Always returns t.\"`"
msgstr ""

#: in/chapter11.md:1342
msgid ""
"```lisp\n"
"  (unless (eq var value)\n"
"      (vector-push-extend var *trail*)\n"
"      (setf (var-binding var) value))\n"
"  t)\n"
"```"
msgstr ""

#: in/chapter11.md:1345
msgid ""
"`(defun undo-bindings!\n"
"(old-trail)`"
msgstr ""

#: in/chapter11.md:1351
msgid ""
"```lisp\n"
"  \"Undo all bindings back to a given point in the trail.\"\n"
"  (loop until (= (fill-pointer *trail*) old-trail)\n"
"      do (setf (var-binding (vector-pop *trail*)) unbound)))\n"
"```"
msgstr ""

#: in/chapter11.md:1359
msgid ""
"Now we need a way of making new variables, where each one is distinct.\n"
"That could be done by `gensym-ing` a new name for each variable, but a "
"quicker solution is just to increment a counter.\n"
"The constructor function ? is defined to generate a new variable with a name "
"that is a new integer.\n"
"This is not strictly necessary; we could have just used the automatically "
"provided constructor `make-var`.\n"
"However, I thought that the operation of providing new anonymous variable "
"was different enough from providing a named variable that it deserved its "
"own function.\n"
"Besides, `make-var` may be less efficient, because it has to process the "
"keyword arguments.\n"
"The function ? has no arguments; it just assigns the default values "
"specified in the slots of the `var` structure."
msgstr ""
"Теперь нам нужен способ создания новых переменных, каждая из которых "
"отличается.\n"
"Это можно сделать, задав новое имя для каждой переменной, но более быстрое "
"решение - просто увеличить счетчик.\n"
"Функция конструктора ? определена для создания новой переменной с именем, "
"которое является новым целым числом.\n"
"Это не обязательно; мы могли бы просто использовать автоматически "
"предоставленный конструктор `make-var`.\n"
"Однако я думал, что операция предоставления новой анонимной переменной "
"достаточно отличается от предоставления именованной переменной, что "
"заслуживает своей собственной функции.\n"
"Кроме того, `make-var` может быть менее эффективной, потому что она должна "
"обрабатывать аргументы ключевого слова.\n"
"Функция ? не имеет аргументов; она просто присваивает значения по умолчанию, "
"указанные в слотах структуры `var`."

#: in/chapter11.md:1367
msgid ""
"```lisp\n"
"(defvar *var-counter* 0)\n"
"(defstruct (var (:constructor ? ())\n"
"                      (:print-function print-var))\n"
"  (name (incf *var-counter*))\n"
"  (binding unbound))\n"
"```"
msgstr ""

#: in/chapter11.md:1370
msgid ""
"A reasonable next step would be to use destructive unification to make a "
"more efficient interpreter.\n"
"This is left as an exercise, however, and instead we put the interpreter "
"aside, and in the next chapter develop a compiler."
msgstr ""
"Следующим разумным шагом было бы использовать деструктивную унификацию для "
"создания более эффективного интерпретатора.\n"
"Однако это оставлено как упражнение, и вместо этого мы отложим интерпретатор "
"и в следующей главе разработаем компилятор."

#: in/chapter11.md:1372
msgid "## 11.7 Prolog in Prolog"
msgstr "## 11.7 Пролог на Прологе"

#: in/chapter11.md:1379
msgid ""
"As stated at the start of this chapter, Prolog has many of the same features "
"that make Lisp attractive for program development.\n"
"Just as it is easy to write a Lisp interpreter in Lisp, it is easy to write "
"a Prolog interpreter in Prolog.\n"
"The following Prolog metainterpreter has three main relations.\n"
"The relation clause is used to store clauses that make up the rules and "
"facts that are to be interpreted.\n"
"The relation `prove` is used to prove a goal.\n"
"It calls `prove`-`all`, which attempts to prove a list of goals, `prove`-"
"`all` succeeds in two ways: (1) if the list is empty, or (2) if there is "
"some clause whose head matches the first goal, and if we can prove the body "
"of that clause, followed by the remaining goals:"
msgstr ""
"Как было сказано в начале этой главы, Prolog имеет многие из тех же функций, "
"которые делают Lisp привлекательным для разработки программ.\n"
"Так же, как легко написать интерпретатор Лиспа на Лиспе, так же легко "
"написать интерпретатор Пролога на Прологе.\n"
"Следующий метаинтерпретатор Пролога имеет три основных отношения.\n"
"Предложение отношения используется для хранения предложений, которые "
"составляют правила и факты, которые должны быть интерпретированы.\n"
"Отношение `prove`(доказательство) используется для доказательства цели.\n"
"Он вызывает `prove`-`all`, которая пытается доказать список целей, `prove`-"
"`all` успешна двумя способами: (1) если список пуст, или (2) если есть какое-"
"то предложение, head совпадает с первой целью, и, если мы сможем доказать "
"телом этого предложения, следующие за ним оставшиеся цели:"

#: in/chapter11.md:1388
msgid ""
"```lisp\n"
"(<- (prove ?goal) (prove-all (?goal)))\n"
"(<- (prove-all nil))\n"
"(<- (prove-all (?goal . !!!(char) Ã®goals))\n"
"        (clause (<- ?goal . ?body))\n"
"        (concat ?body ?goals ?new-goals)\n"
"        (prove-all ?new-goals))\n"
"```"
msgstr ""

#: in/chapter11.md:1390
msgid "Now we add two clauses to the data base to define the member relation:"
msgstr ""
"Теперь мы добавляем в базу данных два предложения, чтобы определить "
"отношение членства(member):"

#: in/chapter11.md:1394
msgid ""
"```lisp\n"
"(<- (clause (<- (mem ?x (?x . ?y)))))\n"
"```"
msgstr ""

#: in/chapter11.md:1397
msgid ""
"`(<- (clause (<- (mem ?x (?\n"
". ?z)) (mem ?x ?z))))`"
msgstr ""

#: in/chapter11.md:1399
msgid "Finally, we can prove a goal using our interpreter:"
msgstr "Наконец, мы можем доказать цель с помощью нашего интерпретатора:"

#: in/chapter11.md:1407
msgid ""
"```lisp\n"
"(?- (prove (mem ?x (1 2 3))))\n"
"?X = 1;\n"
"?X = 2;\n"
"?X = 3;\n"
"No.\n"
"```"
msgstr ""

#: in/chapter11.md:1409
msgid "## 11.8 Prolog Compared to Lisp"
msgstr "## 11.8 Пролог по сравнению с Лиспом"

#: in/chapter11.md:1412
msgid ""
"Many of the features that make Prolog a successful language for AI (and for "
"program development in general) are the same as Lisp's features.\n"
"Let's reconsider the list of features that make Lisp different from "
"conventional languages (see page 25) and see what Prolog has to offer:"
msgstr ""
"Многие из функциональных возможностей, которые делают Prolog успешным языком "
"для ИИ (и для разработки программ в целом), такие же, как и возможности "
"Lisp.\n"
"Давайте пересмотрим список возможностей, которые отличают Lisp от обычных "
"языков (см. Стр.25), и посмотрим, что может предложить Prolog:"

#: in/chapter11.md:1418
msgid ""
"*   *Built-in Support for Lists (and other data types).* New data types can "
"be created easily using lists or structures (structures are preferred).\n"
"Support for reading, printing, and accessing components is provided "
"automatically.\n"
"Numbers, symbols, and characters are also supported.\n"
"However, because logic variables cannot be altered, certain data structures "
"and operations are not provided.\n"
"For example, there is no way to update an element of a vector in Prolog."
msgstr ""
"*   *Встроенная поддержка списков (и других типов данных).* Новые типы "
"данных можно легко создавать с помощью списков или структур (предпочтительны "
"структуры).\n"
"Поддержка чтения, печати и доступа к компонентам предоставляется "
"автоматически.\n"
"Также поддерживаются числа, символьные знаки и символы.\n"
"Однако, поскольку логические переменные не могут быть изменены, некоторые "
"структуры данных и операции не предусмотрены.\n"
"Например, в Прологе нет возможности обновить элемент вектора."

#: in/chapter11.md:1421
msgid ""
"*   *Automatic Storage Management.* The programmer can allocate new objects "
"without worrying about reclaiming them.\n"
"Reclaiming is usually faster in Prolog than in Lisp, because most data can "
"be stack-allocated instead of heap-allocated."
msgstr ""
"*   *Автоматическое управление хранилищем.* Программист может размещать "
"новые объекты, не беспокоясь об их восстановлении.\n"
"Восстановление обычно происходит быстрее в Прологе, чем в Лиспе, потому что "
"большая часть данных может быть размещена в стеке, а не в куче."

#: in/chapter11.md:1425
msgid ""
"*   *Dynamic Typing.* Declarations are not required.\n"
"Indeed, there is no standard way to make type declarations, although some "
"implementations allow for them.\n"
"Some Prolog systems provide only fixnums, so that eliminates the need for a "
"large class of declarations."
msgstr ""
"*   *Динамический ввод.* Объявления(Декларации) не требуются.\n"
"В самом деле, стандартного способа объявления типов не существует, хотя "
"некоторые реализации позволяют это.\n"
"Некоторые системы Prolog предоставляют только фиксированные числа(fixnums), "
"что устраняет необходимость в большом классе объявлений."

#: in/chapter11.md:1428
msgid ""
"*   *First-Class Functions.* Prolog has no equivalent of `lambda,` but the "
"built-in predicate `call` allows a term-a piece of data-to be called as a "
"goal.\n"
"Although backtracking choice points are not first-class objects, they can be "
"used in a way very similar to continuations in Lisp."
msgstr ""
"*   *Функции первого класса.* В Прологе нет эквивалента лямбда, но "
"встроенный предикат `call` позволяет вызвать термин - часть данных - как "
"цель.\n"
"Хотя точки выбора с возвратом не являются объектами первого класса, их можно "
"использовать способом, очень похожим на продолжения в Лиспе."

#: in/chapter11.md:1432
msgid ""
"*   *Uniform Syntax.* Like Lisp, Prolog has a uniform syntax for both "
"programs and data.\n"
"This makes it easy to write interpreters and compilers in Prolog.\n"
"While Lisp's prefix-operator list notation is more uniform, Prolog allows "
"infix and postfix operators, which may be more natural for some applications."
msgstr ""
"*   *Единый синтаксис.* Как и Лисп, Пролог имеет единый синтаксис как для "
"программ, так и для данных.\n"
"Это упрощает написание интерпретаторов и компиляторов на Прологе.\n"
"В то время как нотация списка префиксных операторов в Лиспе более "
"единообразна, Пролог допускает инфиксные и постфиксные операторы, что может "
"быть более естественным для некоторых приложений."

#: in/chapter11.md:1435
msgid ""
"*   *Interactive Environment.* Expressions can be immediately evaluated.\n"
"High-quality Prolog systems offer both a compiler and interpreter, along "
"with a host of debugging tools."
msgstr ""
"*   *Интерактивная среда.* Выражения могут быть немедленно вычислены.\n"
"Высококачественные системы Prolog предлагают как компилятор, так и "
"интерпретатор, а также множество инструментов отладки."

#: in/chapter11.md:1440
msgid ""
"*   *Extensibility.* Prolog syntax is extensible.\n"
"Because programs and data share the same format, it is possible to write the "
"equivalent of macros in Prolog and to define embedded languages.\n"
"However, it can be harder to ensure that the resulting code will be compiled "
"efficiently.\n"
"The details of Prolog compilation are implementation-dependent."
msgstr ""
"*   *Расширяемость.* Синтаксис Пролога расширяемый.\n"
"Поскольку программы и данные используют один и тот же формат, можно написать "
"эквивалент макроса в Prolog и определить встроенные языки.\n"
"Однако может быть труднее гарантировать, что полученный код будет эффективно "
"скомпилирован.\n"
"Детали компиляции Пролога зависят от реализации."

#: in/chapter11.md:1444
msgid ""
"To put things in perspective, consider that Lisp is at once one of the "
"highest-level languages available and a universal assembly language.\n"
"It is a high-level language because it can easily capture data, functional, "
"and control abstractions.\n"
"It is a good assembly language because it is possible to write Lisp in a "
"style that directly reflects the operations available on modern computers."
msgstr ""
"Чтобы взглянуть на вещи в перспективе, примите во внимание, что Лисп "
"является одновременно одним из языков самого высокого уровня и универсальным "
"языком ассемблера.\n"
"Это язык высокого уровня, потому что он может легко захватывать данные, "
"функциональные и управляющие абстракции.\n"
"Это хороший язык ассемблера, потому что можно писать на Lisp в стиле, "
"который напрямую отражает операции, доступные на современных компьютерах."

#: in/chapter11.md:1451
msgid ""
"Prolog is generally not as efficient as an assembly language, but it can be "
"more concise as a specification language, at least for some problems.\n"
"The user writes specifications: lists of axioms that describe the "
"relationships that can hold in the problem domain.\n"
"If these specifications are in the right form, Prolog's automatic "
"backtracking can find a solution, even though the programmer does not "
"provide an explicit algorithm.\n"
"For other problems, the search space will be too large or infinite, or "
"Prolog's simple depth-first search with backup will be too inflexible.\n"
"In this case, Prolog must be used as a programming language rather than a "
"specification language.\n"
"The programmer must be aware of Prolog's search strategy, using it to "
"implement an appropriate algorithm for the problem at hand."
msgstr ""
"Пролог, как правило, не так эффективен, как язык ассемблера, но может быть "
"более кратким в качестве языка спецификации, по крайней мере, для некоторых "
"проблем.\n"
"Пользователь пишет спецификации: списки аксиом, которые описывают отношения, "
"которые могут иметь место в проблемной области.\n"
"Если эти спецификации имеют правильную форму, автоматический поиск с "
"возвратом в Prolog может найти решение, даже если программист не "
"предоставляет явного алгоритма.\n"
"Для других проблем пространство поиска будет слишком большим или "
"бесконечным, или простой поиск в глубину Prolog с возвратами будет слишком "
"негибким.\n"
"В этом случае Prolog следует использовать как язык программирования, а не "
"как язык спецификации.\n"
"Программист должен знать стратегию поиска Пролога, используя ее для "
"реализации подходящего алгоритма для решения данной проблемы."

#: in/chapter11.md:1459
msgid ""
"Prolog, like Lisp, has suffered unfairly from some common myths.\n"
"It has been thought to be an inefficient language because early "
"implementations were interpreted, and because it has been used to write "
"interpreters.\n"
"But modern compiled Prolog can be quite efficient (see [Warren et al.\n"
"1977](B9780080571157500285.xhtml#bb1335) and Van Roy 1990).\n"
"There is a temptation to see Prolog as a solution in itself rather than as a "
"programming language.\n"
"Those who take that view object that Prolog's depth-first search strategy "
"and basis in predicate calculus is too inflexible.\n"
"This objection is countered by Prolog programmers who use the facilities "
"provided by the language to build more powerful search strategies and "
"representations, just as one would do in Lisp or any other language."
msgstr ""
"Пролог, как и Лисп, несправедливо пострадал от некоторых распространенных "
"мифов.\n"
"Считалось, что это неэффективный язык, потому что ранние реализации были "
"интерпретируемыми, и потому что он использовался для написания "
"интерпретаторов.\n"
"Но современный скомпилированный Пролог может быть довольно эффективным (см. "
"[Warren et al.\n"
"1977] (B9780080571157500285.xhtml#bb1335) и Ван Рой 1990).\n"
"Есть соблазн рассматривать Prolog как решение само по себе, а не как язык "
"программирования.\n"
"Те, кто придерживается этой точки зрения, возражают, что стратегия поиска в "
"глубину Пролога и основа исчисления предикатов слишком негибкие.\n"
"С этим возражением не согласны программисты Пролога, которые используют "
"возможности, предоставляемые языком, для построения более мощных стратегий "
"поиска и представлений, точно так же, как это можно было бы сделать в Лиспе "
"или любом другом языке."

#: in/chapter11.md:1461
msgid "## 11.9 History and References"
msgstr "## 11.9 История и Ссылки"

#: in/chapter11.md:1466
msgid ""
"Cordell [Green (1968)](B9780080571157500285.xhtml#bb0490) was the first to "
"articulate the view that mathematical results on theorem proving could be "
"used to make deductions and thereby answer queries.\n"
"However, the major technique in use at the time, resolution theorem proving "
"(see [Robinson 1965](B9780080571157500285.xhtml#bb0995)), did not adequately "
"constrain search, and thus was not practical.\n"
"The idea of goal-directed computing was developed in Carl Hewitt's work "
"(1971) on the planner language for robot problem solving.\n"
"He suggested that the user provide explicit hints on how to control "
"deduction."
msgstr ""

#: in/chapter11.md:1475
msgid ""
"At about the same time and independently, Alain Colmerauer was developing a "
"system to perform natural language analysis.\n"
"His approach was to weaken the logical language so that computationally "
"complex statements (such as logical dis-junctions) could not be made.\n"
"Colmerauer and his group implemented the first Prolog interpreter using "
"Algol-W in the summer of 1972 (see [Roussel 1975](B9780080571157500285."
"xhtml#bb1005)).\n"
"It was Roussel's wife, Jacqueline, who came up with the name Prolog as an "
"abbreviation for \"programmation en logique.\" The first large Prolog "
"program was their natural language system, also completed that year "
"([Colmerauer et al.\n"
"1973](B9780080571157500285.xhtml#bb0255)).\n"
"For those who read English better than French, [Colmerauer (1985)]"
"(B9780080571157500285.xhtml#bb0245) presents an overview of Prolog.\n"
"Robert Kowalski is generally considered the coinventer of Prolog.\n"
"His 1974 article outlines his approach, and his 1988 article is a historical "
"review on the early logic programming work."
msgstr ""

#: in/chapter11.md:1490
msgid ""
"There are now dozens of text books on Prolog.\n"
"In my mind, six of these stand out.\n"
"Clocksin and Mellish's *Programming in Prolog* (1987) was the first and "
"remains one of the best.\n"
"Sterling and Shapiro's *The Art of Prolog* (1986) has more substantial "
"examples but is not as complete as a reference.\n"
"An excellent overview from a slightly more mathematical perspective is "
"Pereira and Shieber's *Prolog and Natural-Language Analysis* (1987).\n"
"The book is worthwhile for its coverage of Prolog alone, and it also "
"provides a good introduction to the use of logic programming for language "
"under-standing (see part V for more on this subject).\n"
"O'Keefe's *The Craft of Prolog* (1990) shows a number of advanced "
"techniques.\n"
"O'Keefe is certainly one of the most influential voices in the Prolog "
"community.\n"
"He has definite views on what makes for good and bad coding style and is not "
"shy about sharing his opinions.\n"
"The reader is warned that this book evolved from a set of notes on the "
"Clocksin and Mellish book, and the lack of organization shows in places.\n"
"However, it contains advanced material that can be found nowhere else.\n"
"Another collection of notes that has been organized into a book is Coelho "
"and Cotta's *Prolog by Example.* Published in 1988, this is an update of "
"their 1980 book, *How to Solve it in Prolog.* The earlier book was an "
"underground classic in the field, serving to educate a generation of Prolog "
"programmers.\n"
"Both versions include a wealth of examples, unfortunately with little "
"documentation and many typos.\n"
"Finally, Ivan Bratko's *Prolog Programming for Artificial Intelligence* "
"(1990) covers some introductory AI material from the Prolog perspective."
msgstr ""

#: in/chapter11.md:1498
msgid ""
"Maier and Warren's *Computing with Logic* (1988) is the best reference for "
"those interested in implementing Prolog.\n"
"It starts with a simple interpreter for a variable-free version of Prolog, "
"and then moves up to the full language, adding improvements to the "
"interpreter along the way.\n"
"(Note that the second author, David S.\n"
"Warren of Stonybrook, is different from David H.\n"
"D.\n"
"Warren, formerly at Edinburgh and now at Bristol.\n"
"Both are experts on Prolog.)"
msgstr ""

#: in/chapter11.md:1502
msgid ""
"Lloyd's *Foundations of Logic Programming* (1987) provides a theoretical "
"explanation of the formal semantics of Prolog and related languages.\n"
"[Lassez et al.\n"
"(1988)](B9780080571157500285.xhtml#bb0705) and [Knight (1989)]"
"(B9780080571157500285.xhtml#bb0625) provide overviews of unification."
msgstr ""

#: in/chapter11.md:1506
msgid ""
"There have been many attempts to extend Prolog to be closer to the ideal of "
"Logic Programming.\n"
"The language MU-Prolog and NU-Prolog ([Naish 1986](B9780080571157500285."
"xhtml#bb0890)) and Prolog III ([Colmerauer 1990](B9780080571157500285."
"xhtml#bb0250)) are particularly interesting.\n"
"The latter includes a systematic treatment of the &ne; relation and an "
"interpretation of infinite trees."
msgstr ""

#: in/chapter11.md:1508
msgid "## 11.10 Exercises"
msgstr "## 11.10 Упражнения"

#: in/chapter11.md:1511
msgid ""
"**Exercise  11.4 [m]** It is somewhat confusing to see \"no\" printed after "
"one or more valid answers have appeared.\n"
"Modify the program to print \"no\" only when there are no answers at all, "
"and \"no more\" in other cases."
msgstr ""

#: in/chapter11.md:1517
msgid ""
"**Exercise  11.5 [h]** At least six books (Abelson and Sussman 1985, "
"[Charniak and McDermott 1985](B9780080571157500285.xhtml#bb0175), Charniak "
"et al.\n"
"1986, [Hennessey 1989](B9780080571157500285.xhtml#bb0530), [Wilensky 1986]"
"(B9780080571157500285.xhtml#bb1390), and [Winston and Horn 1988]"
"(B9780080571157500285.xhtml#bb1410)) present unification algorithms with a "
"common error.\n"
"They all have problems unifying (`?x ?y a`) with (`?y ?x ?x`).\n"
"Some of these texts assume that `unify`will be called in a context where no "
"variables are shared between the two arguments.\n"
"However, they are still suspect to the bug, as the following example points "
"out:"
msgstr ""

#: in/chapter11.md:1522
msgid ""
"```lisp\n"
"> (unify '(f (?x ?y a) (?y ?x ?x)) '(f ?z ?z))\n"
"((?Y . A) (?X . ?Y) (?Z ?X ?Y A))\n"
"```"
msgstr ""

#: in/chapter11.md:1527
msgid ""
"Despite this subtle bug, I highly recommend each of the books to the "
"reader.\n"
"It is interesting to compare different implementations of the same "
"algorithm.\n"
"It turns out there are more similarities than differences.\n"
"This indicates two things: (1) there is a generally agreed-upon style for "
"writing these functions, and (2) good programmers sometimes take advantage "
"of opportunities to look at other's code."
msgstr ""

#: in/chapter11.md:1534
msgid ""
"The question is : Can you give an informal proof of the correctness of the "
"algorithm presented in this chapter?\n"
"Start by making a clear statement of the specification.\n"
"Apply that to the other algorithms, and show where they go wrong.\n"
"Then see if you can prove that the `unify` function in this chapter is "
"correct.\n"
"Failing a complete proof, can you at least prove that the algorithm will "
"always terminate?\n"
"See [Norvig 1991](B9780080571157500285.xhtml#bb0915) for more on this "
"problem."
msgstr ""

#: in/chapter11.md:1544
msgid ""
"**Exercise  11.6 [h]** Since logic variables are so basic to Prolog, we "
"would like them to be efficient.\n"
"In most implementations, structures are not the best choice for small "
"objects.\n"
"Note that variables only have two slots: the name and the binding.\n"
"The binding is crucial, but the name is only needed for printing and is "
"arbitrary for most variables.\n"
"This suggests an alternative implementation.\n"
"Each variable will be a cons cell of the variable's binding and an arbitrary "
"marker to indicate the type.\n"
"This marker would be checked by `variable-p`.\n"
"Variable names can be stored in a hash table that is cleared before each "
"query.\n"
"Implement this representation for variables and compare it to the structure "
"representation."
msgstr ""

#: in/chapter11.md:1547
msgid ""
"**Exercise  11.7 [m]** Consider the following alternative implementation for "
"anonymous variables: Leave the macros <- and ?- alone, so that anonymous "
"variables are allowed in assertions and queries.\n"
"Instead, change `unify` so that it lets anything match against an anonymous "
"variable:"
msgstr ""

#: in/chapter11.md:1561
msgid ""
"```lisp\n"
"(defun unify (x y &optional (bindings no-bindings))\n"
"  \"See if x and y match with given bindings.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"              ((eql x y) bindings)\n"
"              ((or (eq x '?) (eq y '?)) bindings)      ;***\n"
"              ((variable-p x) (unify-variable x y bindings))\n"
"              ((variable-p y) (unify-variable y x bindings))\n"
"              ((and (consp x) (consp y))\n"
"                (unify (rest x) (rest y)\n"
"                          (unify (first x) (first y) bindings)))\n"
"              (t fail)))\n"
"```"
msgstr ""

#: in/chapter11.md:1565
msgid ""
"Is this alternative correct?\n"
"If so, give an informal proof.\n"
"If not, give a counterexample."
msgstr ""

#: in/chapter11.md:1567
msgid ""
"**Exercise  11.8 [h]** Write a version of the Prolog interpreter that uses "
"destructive unification instead of binding lists."
msgstr ""

#: in/chapter11.md:1571
msgid ""
"**Exercise  11.9 [m]** Write Prolog rules to express the terms father, "
"mother, son, daughter, and grand- versions of each of them.\n"
"Also define parent, child, wife, husband, brother, sister, uncle, and aunt.\n"
"You will need to decide which relations are primitive (stored in the Prolog "
"data base) and which are derived by rules."
msgstr ""

#: in/chapter11.md:1573
msgid ""
"For example, here's a definition of grandfather that says that G is the "
"grandfather of C if G is the father of some P, who is the parent of C:"
msgstr ""

#: in/chapter11.md:1579
msgid ""
"```lisp\n"
"(<- (grandfather ?g ?c)\n"
"        (father ?g ?p)\n"
"        (parent ?p ?c))\n"
"```"
msgstr ""

#: in/chapter11.md:1581
msgid ""
"**Exercise 11.10 [m]** The following problem is presented in [Wirth 1976]"
"(B9780080571157500285.xhtml#bb1415):"
msgstr ""

#: in/chapter11.md:1587
msgid ""
"*I married a widow (let's call her W) who has a grown-up daughter (call her "
"D).\n"
"My father (F), who visited us often, fell in love with my step-daughter and "
"married her.\n"
"Hence my father became my son-in-law and my step-daughter became my mother.\n"
"Some months later, my wife gave birth to a son (S1), who became the brother-"
"in-law of my father, as well as my uncle.\n"
"The wife of my father, that is, my step-daughter, also had a son (S2).*"
msgstr ""

#: in/chapter11.md:1589
msgid ""
"Represent this situation using the predicates defined in the previous "
"exercise, verify its conclusions, and prove that the narrator of this tale "
"is his own grandfather."
msgstr ""

#: in/chapter11.md:1591
msgid "**Exercise 11.11 [d]** Recall the example:"
msgstr ""

#: in/chapter11.md:1593
msgid "`> (?- (length (a b` c `d) ?n))`"
msgstr ""

#: in/chapter11.md:1597
msgid ""
"```lisp\n"
"?N = (1  + (1  + (1  + (1  + 0))));\n"
"```"
msgstr ""

#: in/chapter11.md:1601
msgid ""
"It is possible to produce 4 instead of `(1+ (1+ (1+ (1+ 0))))` by extending "
"the notion of unification.\n"
"[A&iuml;t-Kaci et al.\n"
"1987](B9780080571157500285.xhtml#bb0025) might give you some ideas how to do "
"this."
msgstr ""

#: in/chapter11.md:1605
msgid ""
"**Exercise  11.12 [h]** The function `rename-variables` was necessary to "
"avoid confusion between the variables in the first argument to `unify` and "
"those in the second argument.\n"
"An alternative is to change the `unify` so that it takes two binding lists, "
"one for each argument, and keeps them separate.\n"
"Implement this alternative."
msgstr ""

#: in/chapter11.md:1607
msgid "## 11.11 Answers"
msgstr "## 11.11 Ответы"

#: in/chapter11.md:1611
msgid ""
"**Answer 11.9** We will choose as primitives the unary predicates `male` and "
"`female` and the binary predicates `child` and `married`.\n"
"The former takes the child first; the latter takes the husband first.\n"
"Given these primitives, we can make the following definitions:"
msgstr ""

#: in/chapter11.md:1630
msgid ""
"```lisp\n"
"(<- (father ?f ?e)    (male ?f) (parent ?f ?c))\n"
"(<- (mother ?m ?c)    (female ?m) (parent ?m c))\n"
"(<- (son ?s ?p)      (male ?s) (parent ?p ?s))\n"
"(<- (daughter ?s ?p)    (male ?s) (parent ?p ?s))\n"
"(<- (grandfather ?g ?c) (father ?g ?p) (parent ?p ?c))\n"
"(<- (grandmother ?g ?c) (mother ?g ?p) (parent ?p ?c))\n"
"(<- (grandson ?gs ?gp) (son ?gs ?p) (parent ?gp ?p))\n"
"(<- (granddaughter ?gd ?gp) (daughter ?gd ?p) (parent ?gp ?p))\n"
"(<- (parent ?p ?c)    (child ?c ?p))\n"
"(<- (wife ?w ?h)      (married ?h ?w))\n"
"(<- (husband ?h ?w)    (married ?h ?w))\n"
"(<- (sibling ?x ?y)    (parent ?p ?x) (parent ?p ?y))\n"
"(<- (brother ?b ?x)      (male ?b) (sibling ?b ?x))\n"
"(<- (sister ?s ?x)        (female ?s) (sibling ?s ?x))\n"
"(<- (uncle ?u ?n)        (brother ?u ?p) (parent ?p ?n))\n"
"(<- (aunt ?a ?n)        (sister ?a ?p) (parent ?p ?n  ))\n"
"```"
msgstr ""

#: in/chapter11.md:1633
msgid ""
"Note that there is no way in Prolog to express a *true* definition.\n"
"We would like to say that \"P is the parent of C if and only if C is the "
"child of P,\" but Prolog makes us express the biconditional in one direction "
"only."
msgstr ""

#: in/chapter11.md:1637
msgid ""
"**Answer 11.10** Because we haven't considered step-relations in the prior "
"definitions, we have to extend the notion of parent to include step-"
"parents.\n"
"The definitions have to be written very carefully to avoid infinite loops.\n"
"The strategy is to structure the defined terms into a strict hierarchy: the "
"four primitives are at the bottom, then parent is defined in terms of the "
"primitives, then the other terms are defined in terms of parent and the "
"primitives."
msgstr ""

#: in/chapter11.md:1639
msgid "We also provide a definition for son-in-law:"
msgstr ""

#: in/chapter11.md:1645
msgid ""
"```lisp\n"
"(<- (parent ?p ?c) (married ?p ?w) (child ?c ?w))\n"
"(<- (parent ?p ?c) (married ?h ?p) (child ?c ?w))\n"
"(<- (son-in-law ?s ?p) (parent ?p ?w) (married ?s ?w))\n"
"```"
msgstr ""

#: in/chapter11.md:1648
msgid ""
"Now we add the information from the story.\n"
"Note that we only use the four primitives male, female, married, and child:"
msgstr ""

#: in/chapter11.md:1659
msgid ""
"```lisp\n"
"(<- (male I)) (<- (male F)) (<- (male S1)) (<- (male S2))\n"
"(<- (female W)) (<- (female D))\n"
"(<- (married I W))\n"
"(<- (married F D))\n"
"(<- (child D W))\n"
"(<- (child I F))\n"
"(<- (child S1 I))\n"
"(<- (child S2 F))\n"
"```"
msgstr ""

#: in/chapter11.md:1661
msgid "Now we are ready to make the queries:"
msgstr ""

#: in/chapter11.md:1668
msgid ""
"```lisp\n"
"> (?- (son-in-law F I)) Yes.\n"
"> (?- (mother D I)) Yes.\n"
"> (?- (uncle S1 I)) Yes.\n"
"> (?- (grandfather I I)) Yes.\n"
"```"
msgstr ""

#: in/chapter11.md:1670
msgid "----------------------"
msgstr ""

#: in/chapter11.md:1673
msgid ""
"[1](#xfn0015) Actually, *programmation en logique*, since it was invented by "
"a French group (see page 382).\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter11.md:1677
msgid ""
"[2](#xfn0020) Actually, this is more like the Lisp `find` than the Lisp "
"`member`.\n"
"In this chapter we have adopted the traditional Prolog definition of "
"`member`.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter11.md:1680
msgid ""
"[3](#xfn0025) See exercise 11.12 for an alternative approach.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter11.md:1683
msgid ""
"[4](#xfn0030) See the MU-Prolog and NU-Prolog languages ([Naish 1986]"
"(B9780080571157500285.xhtml#bb0890)).\n"
"!!!(p) {:.ftnote1}"
msgstr ""
