#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter23.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-03-16 01:18+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter23.md:3
msgid ""
"# Chapter 23\n"
"## Compiling Lisp"
msgstr ""
"# Глава 23\n"
"## Компиляция Lisp"

#: in/chapter23.md:7
msgid ""
"Many textbooks show simple interpreters for Lisp, because they are simple to "
"write, and because it is useful to know how an interpreter works.\n"
"Unfortunately, not as many textbooks show how to write a compiler, even "
"though the same two reasons hold.\n"
"The simplest compiler need not be much more complex than an interpreter."
msgstr ""
"Во многих учебниках показаны простые интерпретаторы Лиспа, потому что они "
"просты в написании и потому, что полезно знать, как работает интерпретатор.\n"
"К сожалению, не так много учебников показывают, как писать компилятор, хотя "
"по тем же двум причинам.\n"
"Самый простой компилятор не должен быть намного сложнее интерпретатора."

#: in/chapter23.md:14
msgid ""
"One thing that makes a compiler more complex is that we have to describe the "
"output of the compiler: the instruction set of the machine we are compiling "
"for.\n"
"For the moment let's assume a stack-based machine.\n"
"The calling sequence on this machine for a function call with *n* arguments "
"is to push the *n* arguments onto the stack and then push the function to be "
"called.\n"
"A `\"CALL *n*\"` instruction saves the return point on the stack and goes to "
"the first instruction of the called function.\n"
"By convention, the first instruction of a function will always be `\"ARGS *n*"
"\"`, which pops *n* arguments off the stack, putting them in the new "
"function's environment, where they can be accessed by `LVAR` and `LSET` "
"instructions.\n"
"The function should return with a `RETURN` instruction, which resets the "
"program counter and the environment to the point of the original `CALL` "
"instruction."
msgstr ""
"Одна вещь, которая делает компилятор более сложным, заключается в том, что "
"мы должны описывать вывод компилятора: набор инструкций машины, для которой "
"мы компилируем.\n"
"На данный момент давайте предположим, что это машина на основе стека.\n"
"Последовательность вызова на этом компьютере для вызова функции с *n* "
"аргументами состоит в том, чтобы поместить *n* аргументов в стек, а затем "
"поместить туда функцию, которая будет вызвана.\n"
"Инструкция `\"CALL *n*\"` сохраняет точку возврата в стеке и переходит к "
"первой инструкции вызываемой функции.\n"
"По соглашению, первая инструкция функции всегда будет `\"ARGS *n*\"`, "
"которая выталкивает *n* аргументов из стека, помещая их в окружающую среду "
"новой функции, где к ним могут получить доступ инструкции `LVAR` и `LSET`.\n"
"Функция должна возвращаться с инструкцией `RETURN`, которая сбрасывает "
"счетчик программы и окружение до точки исходной инструкции `CALL`."

#: in/chapter23.md:20
msgid ""
"In addition, our machine has three `JUMP` instructions; one that branches "
"unconditionally, and two that branch depending on if the top of the stack is "
"nil or non-nil.\n"
"There is also an instruction for popping unneeded values off the stack, and "
"for accessing and altering global variables.\n"
"The instruction set is shown in [figure 23.1](#f0010).\n"
"A glossary for the compiler program is given in [figure 23.2](#f0015).\n"
"A summary of a more complex version of the compiler appears on [page 795]"
"(#p795)."
msgstr ""
"Кроме того, наша машина имеет три инструкции `JUMP`; одна, переходящая "
"безусловно, и две, которые выполняют переход в зависимости от того, является "
"ли вершина стека нулевой или ненулевой.\n"
"Также есть инструкция для удаления ненужных значений из стека, а также для "
"доступа и изменения глобальных переменных.\n"
"Набор команд показан на [рисунке 23.1](#f0010).\n"
"Словарь для программы компилятора приведен на [рисунке 23.2](# f0015).\n"
"Краткое описание более сложной версии компилятора приведено на [страница 795]"
"(#p795)."

#: in/chapter23.md:25
msgid ""
"| []() |\n"
"|---|\n"
"| ![f23-01](images/chapter23/f23-01.jpg) |\n"
"| Figure 23.1: Instruction Set for Hypothetical Stack Machine |"
msgstr ""
"| []() |\n"
"|---|\n"
"| ![f23-01](images/chapter23/f23-01.jpg) |\n"
"| Рисунок 23.1: Набор Инструкций для гипотетической Стековой Машины |"

#: in/chapter23.md:27
msgctxt "in/chapter23.md:27"
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter23.md:32
msgid ""
"| []() |\n"
"|---|\n"
"| ![f23-02](images/chapter23/f23-02.jpg) |\n"
"| Figure 23.2: Glossary for the Scheme Compiler |"
msgstr ""

#: in/chapter23.md:34
msgctxt "in/chapter23.md:34"
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter23.md:37
msgid "As an example, the procedure"
msgstr "Например, процедура"

#: in/chapter23.md:41
msgid ""
"```lisp\n"
"(lambda () (if (= x y) (f (g x)) (h x y (h 1 2))))\n"
"```"
msgstr ""

#: in/chapter23.md:43
msgid "should compile into the following instructions:"
msgstr "должна скомпилироваться в следующие инструкции:"

#: in/chapter23.md:67
msgctxt "in/chapter23.md:67"
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `GVAR`   | `=`  |\n"
"|       | `CALL`   | `2`  |\n"
"|       | `FJUMP`  | `L1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `G`  |\n"
"|       | `CALL`   | `1`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALL`   | `1`  |\n"
"|       | `JUMP`   | `L2` |\n"
"| `L1:` | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `CONST`  | `1`  |\n"
"|       | `CONST`  | `2`  |\n"
"|       | `GVAR`   | `H`  |\n"
"|       | `CALL`   | `2`  |\n"
"|       | `GVAR`   | `H`  |\n"
"|       | `CALL`   | `3`  |\n"
"| `L2:` | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:71
msgid ""
"The first version of the Scheme compiler is quite simple.\n"
"It mimics the structure of the Scheme evaluator.\n"
"The difference is that each case generates code rather than evaluating a "
"subexpression:"
msgstr ""
"Первая версия компилятора Scheme довольно проста.\n"
"Он имитирует структуру вычислителя(evaluator) Scheme.\n"
"Разница в том, что каждый случай генерирует код, а не вычисляет подвыражения:"

#: in/chapter23.md:90
msgid ""
"```lisp\n"
"(defun comp (x env)\n"
"  \"Compile the expression x into a list of instructions\"\n"
"  (cond\n"
"    ((symbolp x) (gen-var x env))\n"
"    ((atom x) (gen 'CONST x))\n"
"    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))\n"
"    ((case (first x)\n"
"       (QUOTE  (gen 'CONST (second x)))\n"
"       (BEGIN  (comp-begin (rest x) env))\n"
"       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))\n"
"       (IF     (comp-if (second x) (third x) (fourth x) env))\n"
"       (LAMBDA (gen 'FN (comp-lambda (second x) (rest (rest x)) env)))\n"
"       ;; Procedure application:\n"
"       ;; Compile args, then fn, then the call\n"
"       (t      (seq (mappend #'(lambda (y) (comp y env)) (rest x))\n"
"                    (comp (first x) env)\n"
"                              (gen 'call (length (rest x)))))))))"
msgstr ""

#: in/chapter23.md:92
msgid "```"
msgstr ""

#: in/chapter23.md:97
msgid ""
"The compiler `comp` has the same nine cases-in fact the exact same structure-"
"as the interpreter `interp` from [chapter 22](B9780080571157500224.xhtml).\n"
"Each case is slightly more complex, so the three main cases have been made "
"into separate functions: `comp-begin`, `comp-if`, and `comp-lambda.` A "
"`begin` expression is compiled by compiling each argument in turn but making "
"sure to pop each value but the last off the stack after it is computed.\n"
"The last element in the `begin` stays on the stack as the value of the whole "
"expression.\n"
"Note that the function `gen` generates a single instruction (actually a list "
"of one instruction), and `seq` makes a sequence of instructions out of two "
"or more subsequences."
msgstr ""
"Компилятор `comp` имеет те же девять вариантов - фактически ту же самую "
"структуру - что и интерпретатор `interp` из [главы 22](B9780080571157500224."
"xhtml).\n"
"Каждый случай немного сложнее, поэтому три основных случая были разделены на "
"отдельные функции: `comp-begin`, `comp-if` и `comp-lambda`. \n"
"Выражение `begin` компилируется путем компиляции каждого аргумента по "
"очереди, но обязательно выталкивает каждое значение, кроме последнего, из "
"стека после его вычисления.\n"
"Последний элемент в `begin` остается в стеке как значение всего выражения. \n"
"Обратите внимание, что функция `gen` генерирует одну инструкцию (фактически "
"список из одной инструкции), а `seq` создает последовательность инструкций "
"из двух или более подпоследовательностей."

#: in/chapter23.md:107
msgid ""
"```lisp\n"
"(defun comp-begin (exps env)\n"
"  \"Compile a sequence of expressions, popping all but the last.\"\n"
"  (cond ((null exps) (gen 'CONST nil))\n"
"        ((length=1 exps) (comp (first exps) env))\n"
"        (t (seq (comp (first exps) env)\n"
"                (gen 'POP)\n"
"                (comp-begin (rest exps) env)))))\n"
"```"
msgstr ""

#: in/chapter23.md:109
msgid ""
"An `if` expression is compiled by compiling the predicate, then part, and "
"else part, and by inserting appropriate branch instructions."
msgstr ""
"Выражение `if` компилируется путем компиляции предиката, части then(затем) и "
"части иначе(else), а также путем вставки соответствующих инструкций "
"ветвления."

#: in/chapter23.md:120
msgid ""
"```lisp\n"
"(defun comp-if (pred then else env)\n"
"  \"Compile a conditional expression.\"\n"
"  (let ((L1 (gen-label))\n"
"        (L2 (gen-label)))\n"
"    (seq (comp pred env) (gen 'FJUMP L1)\n"
"         (comp then env) (gen 'JUMP L2)\n"
"         (list L1) (comp else env)\n"
"         (list L2))))\n"
"```"
msgstr ""

#: in/chapter23.md:123
msgid ""
"Finally, a `lambda` expression is compiled by compiling the body, "
"surrounding it with one instruction to set up the arguments and another to "
"return from the function, and then storing away the resulting compiled code, "
"along with the environment.\n"
"The data type `fn` is implemented as a structure with slots for the body of "
"the code, the argument list, and the name of the function (for printing "
"purposes only)."
msgstr ""
"Наконец, `lambda`- выражение компилируется путем компиляции тела, окружая "
"его одной инструкцией для установки аргументов и другой для возврата из "
"функции, а затем сохраняя полученный скомпилированный код вместе с "
"окружающей средой(environment).\n"
"Тип данных `fn` реализован в виде структуры со слотами для тела кода, списка "
"аргументов и имени функции (только для целей печати)."

#: in/chapter23.md:127
msgid ""
"```lisp\n"
"(defstruct (fn (:print-function print-fn))\n"
"  code (env nil) (name nil) (args nil))"
msgstr ""

#: in/chapter23.md:140
msgid ""
"(defun comp-lambda (args body env)\n"
"  \"Compile a lambda form into a closure with compiled code.\"\n"
"  (assert (and (listp args) (every #'symbolp args)) ()\n"
"          \"Lambda arglist must be a list of symbols, not ~a\" args)\n"
"  ;; For now, no &rest parameters.\n"
"  ;; The next version will support Scheme's version of &rest\n"
"  (make-fn\n"
"    :env env :args args\n"
"    :code (seq (gen 'ARGS (length args))\n"
"               (comp-begin body (cons args env))\n"
"               (gen 'RETURN))))\n"
"```"
msgstr ""

#: in/chapter23.md:146
msgid ""
"The advantage of compiling over interpreting is that much can be decided at "
"compile time.\n"
"For example, the compiler can determine if a variable reference is to a "
"global or lexical variable, and if it is to a lexical variable, exactly "
"where that lexical variable is stored.\n"
"This computation is done only once by the compiler, but it has to be done "
"each time the expression is encountered by the interpreter.\n"
"Similarly, the compiler can count up the number of arguments once and for "
"all, while the interpreter must go through a loop, counting up the number of "
"arguments, and testing for the end of the arguments after each one is "
"interpreted.\n"
"So it is clear that the compiler can be more efficient than the interpreter."
msgstr ""
"Преимущество компиляции перед интерпретацией состоит в том, что многое можно "
"решить во время компиляции.\n"
"Например, компилятор может определить, относится ли ссылка к глобальной "
"переменной или к лексической переменной, и если это ссылка на лексическую "
"переменную, где именно эта лексическая переменная хранится.\n"
"Это вычисление выполняется компилятором только один раз, но оно должно "
"выполняться каждый раз, когда выражение встречается в интерпретаторе.\n"
"Точно так же компилятор может подсчитать количество аргументов раз и "
"навсегда, в то время как интерпретатор должен пройти цикл, подсчитывая "
"количество аргументов и проверяя конец аргументов после интерпретации "
"каждого из них."

#: in/chapter23.md:150
msgid ""
"Another advantage is that the compiler can be more robust.\n"
"For example, in `comp-lambda,` we check that the parameter list of a lambda "
"expression is a list containing only symbols.\n"
"It would be too expensive to make such checks in an interpreter, but in a "
"compiler it is a worthwhile trade-off to check once at compile time for "
"error conditions rather than checking repeatedly at run time."
msgstr ""
"Еще одно преимущество состоит в том, что компилятор может быть более "
"надежным.\n"
"Например, в `comp-lambda` мы проверяем, что список параметров лямбда-"
"выражения является списком, содержащим только символы.\n"
"Было бы слишком дорого делать такие проверки в интерпретаторе, но в "
"компиляторе стоит проверить один раз во время компиляции на наличие условий "
"ошибки, а не повторно проверять во время выполнения."

#: in/chapter23.md:152
msgid ""
"Before we show the rest of the compiler, here's a useful top-level interface "
"to `comp`:"
msgstr ""
"Прежде чем мы покажем остальную часть компилятора, вот полезный интерфейс "
"верхнего уровня для `comp`:"

#: in/chapter23.md:155
msgid ""
"```lisp\n"
"(defvar *label-num* 0)"
msgstr ""

#: in/chapter23.md:160
msgid ""
"(defun compiler (x)\n"
"  \"Compile an expression as if it were in a parameterless lambda.\"\n"
"  (setf *label-num* 0)\n"
"  (comp-lambda '() (list x) nil))"
msgstr ""

#: in/chapter23.md:166
msgid ""
"(defun comp-show (x)\n"
"  \"Compile an expression and show the resulting code\"\n"
"   (show-fn (compiler x))\n"
"  (values))\n"
"```"
msgstr ""

#: in/chapter23.md:170
msgid ""
"Now here's the code to generate individual instructions and sequences of "
"instructions.\n"
"A sequence of instructions is just a list, but we provide the function `seq` "
"rather than using `append` directly for purposes of data abstraction.\n"
"A label is just an atom."
msgstr ""
"Теперь вот код для генерации отдельных инструкций и последовательностей "
"инструкций.\n"
"Последовательность инструкций - это просто список, но мы предоставляем "
"функцию `seq` вместо того, чтобы напрямую использовать `append` для целей "
"абстракции данных.\n"
"label - это просто атом."

#: in/chapter23.md:175
msgid ""
"```lisp\n"
"(defun gen (opcode &rest args)\n"
"  \"Return a one-element list of the specified instruction.\"\n"
"  (list (cons opcode args)))"
msgstr ""

#: in/chapter23.md:179
msgid ""
"(defun seq (&rest code)\n"
"  \"Return a sequence of instructions\"\n"
"  (apply #'append code))"
msgstr ""

#: in/chapter23.md:184
msgid ""
"(defun gen-label (&optional (label 'L))\n"
"  \"Generate a label (a symbol of the form Lnnn)\"\n"
"  (intern (format nil \"~a~d\" label (incf *label-num*))))\n"
"```"
msgstr ""

#: in/chapter23.md:189
msgid ""
"Environments are now represented as lists of frames, where each frame is a "
"sequence of variables.\n"
"Local variables are referred to not by their name but by two integers: the "
"index into the list of frames and the index into the individual frame.\n"
"As usual, the indexes are zero-based.\n"
"For example, given the code:"
msgstr ""
"Окружающие среды теперь представлены в виде списков кадров(frames), где "
"каждый кадр представляет собой последовательность переменных.\n"
"На локальные переменные ссылаются не по их имени, а по двум целым числам: "
"индекс в списке фреймов и индекс в отдельном фрейме.\n"
"Как обычно, индексы отсчитываются от нуля.\n"
"Например, данный код:"

#: in/chapter23.md:199
msgid ""
"```lisp\n"
"(let ((a 2.0)\n"
"          (b 2.1))\n"
"  (let ((c 1.0)\n"
"            (d 1.1))\n"
"    (let ((e 0.0)\n"
"          (f 0.1))\n"
"      (+ a b c d e f))))\n"
"```"
msgstr ""

#: in/chapter23.md:203
msgid ""
"the innermost environment is `((e f) (c d) (a b))`.\n"
"The function `in-env-p` tests if a variable appears in an environment.\n"
"If this environment were called `env`, then `(in-env-p 'f env)` would return "
"`(0 1)` and `(in-env-p 'x env)` would return `nil`."
msgstr ""
"самая внутренняя окружающая среда - это `((e f) (c d) (a b))`.\n"
"Функция `in-env-p` проверяет, появляется ли переменная в среде.\n"
"Если бы эта среда была названа `env`, то `(in-env-p 'f env)` вернула бы `(0 "
"1)`, а `(in-env-p' x env)` вернула бы `nil`."

#: in/chapter23.md:211
msgid ""
"```lisp\n"
"(defun gen-var (var env)\n"
"  \"Generate an instruction to reference a variable's value.\"\n"
"  (let ((p (in-env-p var env)))\n"
"    (if p\n"
"        (gen 'LVAR (first p) (second p) \";\" var)\n"
"        (gen 'GVAR var))))"
msgstr ""

#: in/chapter23.md:224
msgid ""
"(defun gen-set (var env)\n"
"  \"Generate an instruction to set a variable to top-of-stack.\"\n"
"  (let ((p (in-env-p var env)))\n"
"    (if p\n"
"        (gen 'LSET (first p) (second p) \";\" var)\n"
"        (gen 'GSET var))))(def-scheme-macro define (name &rest body)\n"
"  (if (atom name)\n"
"      `(name! (set! ,name . ,body) ',name)\n"
"      (scheme-macro-expand\n"
"         `(define ,(first name)\n"
"            (lambda ,(rest name) . ,body)))))\n"
"```"
msgstr ""

#: in/chapter23.md:230
msgid ""
"Finally, we have some auxiliary functions to print out the results, to "
"distinguish bet\n"
"ween labels and instructions, and to determine the index of a variable in an "
"environme\n"
"nt.\n"
"Scheme functions now are implemented as structures, which must have a field "
"for the code, and one for the environment.\n"
"In addition, we provide a field for the name of the function and for the "
"argument list; these are used only for debugging purposes, We'll adopt the "
"convention that the `define` macro sets the function's name field, by "
"calling `name` ! (which is not part of standard Scheme)."
msgstr ""
"Наконец, у нас есть несколько вспомогательных функций для распечатки "
"результатов, для различения меток и инструкций и для определения индекса "
"переменной в среде.\n"
"Функции Scheme теперь реализованы в виде структур, которые должны иметь поле "
"для кода и поле для окружающей среды.\n"
"Кроме того, мы предоставляем поле для имени функции и для списка аргументов; "
"они используются только для целей отладки. \n"
"Мы примем соглашение, согласно которому макрос `define` устанавливает поле "
"имени функции, вызывая `name`! (которая не является частью стандартной "
"схемы)."

#: in/chapter23.md:237
msgid ""
"```lisp\n"
"(defun name! (fn name)\n"
"  \"Set the name field of fn, if it is an un-named fn.\"\n"
"  (when (and (fn-p fn) (null (fn-name fn)))\n"
"    (setf (fn-name fn) name))\n"
"  name)"
msgstr ""

#: in/chapter23.md:240
msgid ""
";; This should also go in init-scheme-interp:\n"
"(set-global-var! 'name! #'name!)"
msgstr ""

#: in/chapter23.md:244
msgid ""
"(defun print-fn (fn &optional (stream *standard-output*) depth)\n"
"  (declare (ignore depth))\n"
"  (format stream \"{~a}\" (or (fn-name fn) '??)))"
msgstr ""

#: in/chapter23.md:262
msgid ""
"(defun show-fn (fn &optional (stream *standard-output*) (depth 0))\n"
"  \"Print all the instructions in a function.\n"
"  If the argument is not a function, just princ it,\n"
"  but in a column at least 8 spaces wide.\"\n"
"  (if (not (fn-p fn))\n"
"      (format stream \"~8a\" fn)\n"
"      (progn\n"
"        (fresh-line)\n"
"        (incf depth 8)\n"
"        (dolist (instr (fn-code fn))\n"
"          (if (label-p instr)\n"
"              (format stream \"~a:\" instr)\n"
"              (progn\n"
"                (format stream \"~VT\" depth)\n"
"                (dolist (arg instr)\n"
"                  (show-fn arg stream depth))\n"
"                (fresh-line)))))))"
msgstr ""

#: in/chapter23.md:264
msgid "(defun label-p (x) \"Is x a label?\" (atom x))"
msgstr ""

#: in/chapter23.md:270
msgid ""
"(defun in-env-p (symbol env)\n"
"  \"If symbol is in the environment, return its index numbers.\"\n"
"  (let ((frame (find symbol env :test #'find)))\n"
"    (if frame (list (position frame env) (position symbol frame)))))\n"
"```"
msgstr ""

#: in/chapter23.md:272
msgid "Now we are ready to show the compiler at work:"
msgstr "Теперь мы готовы показать компилятор в работе:"

#: in/chapter23.md:276
msgid ""
"```\n"
"> (comp-show '(if (= x y) (f (g x)) (h x y (h 1 2))))\n"
"```"
msgstr ""

#: in/chapter23.md:300
msgctxt "in/chapter23.md:300"
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `GVAR`   | `=`  |\n"
"|       | `CALL`   | `2`  |\n"
"|       | `FJUMP`  | `L1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `G`  |\n"
"|       | `CALL`   | `1`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALL`   | `1`  |\n"
"|       | `JUMP`   | `L2` |\n"
"| `L1:` | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `CONST`  | `1`  |\n"
"|       | `CONST`  | `2`  |\n"
"|       | `GVAR`   | `H`  |\n"
"|       | `CALL`   | `2`  |\n"
"|       | `GVAR`   | `H`  |\n"
"|       | `CALL`   | `3`  |\n"
"| `L2:` | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:302
msgid ""
"This example should give the reader a feeling for the code generated by the "
"compiler."
msgstr ""
"Этот пример должен дать читателю представление о коде, созданном "
"компилятором."

#: in/chapter23.md:305
msgid ""
"Another reason a compiler has an advantage over an interpreter is that the "
"compiler can afford to spend some time trying to find a more efficient "
"encoding of an expression, while for the interpreter, the overhead of "
"searching for a more efficient interpretation usually offsets any advantage "
"gained.\n"
"Here are some places where a compiler could do better than an interpreter "
"(although our compiler currently does not):"
msgstr ""
"Другая причина, по которой компилятор имеет преимущество перед "
"интерпретатором, заключается в том, что компилятор может позволить себе "
"потратить некоторое время на попытки найти более эффективное кодирование "
"выражения, в то время как для интерпретатора накладные расходы на поиск "
"более эффективной интерпретации обычно сводят на нет любое полученное "
"преимущество. .\n"
"Вот несколько мест, где компилятор мог бы работать лучше, чем интерпретатор "
"(хотя наш компилятор в настоящее время этого не делает):"

#: in/chapter23.md:309
msgid ""
"```\n"
"> (comp-show '(begin \"doc\" (write x) y))\n"
"```"
msgstr ""

#: in/chapter23.md:321
msgid ""
"| []() |          |         |\n"
"|------|----------|---------|\n"
"|      | `ARGS`   | `0`     |\n"
"|      | `CONST`  | `doc`   |\n"
"|      | `POP`    |         |\n"
"|      | `GVAR`   | `X`     |\n"
"|      | `GVAR`   | `WRITE` |\n"
"|      | `CALL`   | `1`     |\n"
"|      | `POP`    |         |\n"
"|      | `GVAR`   | `Y`     |\n"
"|      | `RETURN` |         |"
msgstr ""

#: in/chapter23.md:325
msgid ""
"In this example, code is generated to push the constant \"`doc`\" on the "
"stack and then immediately pop it off.\n"
"If we have the compiler keep track of what expressions are compiled \"for "
"value\"-as y is the value of the expression above-and which are only "
"compiled \"for effect,\" then we can avoid generating any code at all for a "
"reference to a constant or variable for effect.\n"
"Here's another example:"
msgstr ""
"В этом примере генерируется код, который помещает константу `\"doc\"` в "
"стек, а затем немедленно удаляет ее.\n"
"Если у нас есть компилятор, отслеживающий, какие выражения компилируются "
"\"для значения\" - поскольку y - это значение выражения выше - и какие "
"компилируются только \"для эффекта\", то мы можем вообще избежать генерации "
"кода для ссылки на константы или переменные для эффекта.\n"
"Вот еще пример:"

#: in/chapter23.md:329
msgctxt "in/chapter23.md:329"
msgid ""
"```\n"
"> (comp-show '(begin (+ (* a x) (f x)) x))\n"
"```"
msgstr ""

#: in/chapter23.md:345
msgid ""
"| []()     |     |\n"
"|----------|-----|\n"
"| `ARGS`   | `0` |\n"
"| `GVAR`   | `A` |\n"
"| `GVAR`   | `X` |\n"
"| `GVAR`   | `*` |\n"
"| `CALL`   | `2` |\n"
"| `GVAR`   | `X` |\n"
"| `GVAR`   | `F` |\n"
"| `CALL`   | `1` |\n"
"| `GVAR`   | `+` |\n"
"| `CALL`   | `2` |\n"
"| `POP`    |     |\n"
"| `GVAR`   | `X` |\n"
"| `RETURN` |     |"
msgstr ""

#: in/chapter23.md:349
msgid ""
"In this expression, if we can be assured that + and * refer to the normal "
"arithmetic functions, then we can compile this as if it were `(begin (f x) "
"x)`.\n"
"Furthermore, it is reasonable to assume that + and * will be instructions in "
"our machine that can be invoked inline, rather than having to call out to a "
"function.\n"
"Many compilers spend a significant portion of their time optimizing "
"arithmetic operations, by taking into account associativity, commutativity, "
"distributivity, and other properties."
msgstr ""
"В этом выражении, если мы можем быть уверены, что + и * относятся к обычным "
"арифметическим функциям, то мы можем скомпилировать его, как если бы это "
"было `(begin (f x) x)`.\n"
"Более того, разумно предположить, что + и * будут инструкциями на нашей "
"машине, которые можно выполнить непосредственно, а не вызывать функцию.\n"
"Многие компиляторы тратят значительную часть своего времени на оптимизацию "
"арифметических операций, принимая во внимание ассоциативность, "
"коммутативность, распределительность и другие свойства."

#: in/chapter23.md:352
msgid ""
"Besides arithmetic, compilers often have expertise in conditional "
"expressions.\n"
"Consider the following:"
msgstr ""
"Помимо арифметики, компиляторы часто проводят экспертизу в условных "
"выражениях.\n"
"Рассмотреть следующее:"

#: in/chapter23.md:356
msgid ""
"```\n"
"> (comp-show '(if (and p q) x y))\n"
"```"
msgstr ""

#: in/chapter23.md:370
msgid ""
"| []()  |          |       |\n"
"|-------|----------|-------|\n"
"|       | `ARGS`   | `0`   |\n"
"|       | `GVAR`   | `P`   |\n"
"|       | `FJUMP`  | `L3`  |\n"
"|       | `GVAR`   | `Q`   |\n"
"|       | `JUMP`   | `L4`  |\n"
"| `L3:` | `GVAR`   | `NIL` |\n"
"| `L4:` | `FJUMP`  | `L1`  |\n"
"|       | `GVAR`   | `X`   |\n"
"|       | `JUMP`   | `L2`  |\n"
"| `L1:` | `GVAR`   | `Y`   |\n"
"| `L2:` | `RETURN` |       |"
msgstr ""

#: in/chapter23.md:378
msgid ""
"Note that `(and p q)` macro-expands to `(if p q nil)`.\n"
"The resulting compiled code is correct, but inefficient.\n"
"First, there is an unconditional jump to `L4`, which labels a conditional "
"jump to `L1`.\n"
"This could be replaced with a conditional jump to `L1`.\n"
"Second, at `L3` we load `NIL` and then jump on nil to `L1`.\n"
"These two instructions could be replaced by an unconditional jump to `L1`.\n"
"Third, the `FJUMP` to `L3` could be replaced by an `FJUMP` to `L1`, since we "
"now know that the code at `L3` unconditionally goes to `L1`."
msgstr ""
"Обратите внимание, что `(and p q)` макро-расширяется до `(if p q nil)`.\n"
"Полученный скомпилированный код корректен, но неэффективен.\n"
"Во-первых, существует безусловный переход к `L4`, который обозначает "
"условный переход к `L1`.\n"
"Это можно было бы заменить условным переходом к `L1`.\n"
"Во-вторых, на `L3` мы загружаем `NIL`, а затем переходим при nil к `L1`.\n"
"Эти две инструкции могут быть заменены безусловным переходом к `L1`.\n"
"В-третьих, `FJUMP` к `L3` можно заменить на `FJUMP` к `L1`, так как теперь "
"мы знаем, что код в `L3` безоговорочно переходит к `L1`."

#: in/chapter23.md:381
msgid ""
"Finally, some compilers, particularly Lisp compilers, have expertise in "
"function calling.\n"
"Consider the following:"
msgstr ""
"Наконец, некоторые компиляторы, особенно компиляторы Lisp, проводят "
"экспертизу вызова функций.\n"
"Рассмотреть следующее:"

#: in/chapter23.md:385
msgid ""
"```\n"
"> (comp-show '(f (g x y)))\n"
"```"
msgstr ""

#: in/chapter23.md:396
msgid ""
"| []() |          |     |\n"
"| ---  |----------|-----|\n"
"|      | `ARGS`   | `0` |\n"
"|      | `GVAR`   | `X` |\n"
"|      | `GVAR`   | `Y` |\n"
"|      | `GVAR`   | `G` |\n"
"|      | `CALL`   | `2` |\n"
"|      | `GVAR`   | `F` |\n"
"|      | `CALL`   | `1` |\n"
"|      | `RETURN` |     |"
msgstr ""

#: in/chapter23.md:400
msgid ""
"Here we call `g` and when `g` returns we call `f` , and when `f` returns we "
"return from this function.\n"
"But this last return is wasteful; we push a return address on the stack, and "
"then pop it off, and return to the next return address.\n"
"An alternative function-calling protocol involves pushing the return address "
"before calling `g,` but then not pushing a return address before calling `f;"
"` when `f` returns, it returns directly to the calling function, whatever "
"that is."
msgstr ""
"Здесь мы вызываем `g` и когда `g` возвращается мы вызываем `f` , а когда `f` "
"возвращаеся мы вернемся из этой функции.\n"
"Но это последнее возвращение является расточительным; мы помещаем адрес "
"возврата в стек, а затем убираем его и возвращаемся к следующему адресу "
"возврата.\n"
"Альтернативный протокол вызова функции включает в себя помещение в стек "
"адреса возврата перед вызовом `g`, но затем не помещать в стек адрес "
"возврата перед вызовом `f;` когда `f` возвращается, он вернется "
"непосредственно к вызывающей функции, какой бы она ни была."

#: in/chapter23.md:405
msgid ""
"Such an optimization looks like a small gain; we basically eliminate a "
"single instruction.\n"
"In fact, the implications of this new protocol are enormous: we can now "
"invoke a recursive function to an arbitrary depth without growing the stack "
"at all-as long as the recursive call is the last statement in the function "
"(or in a branch of the function when there are conditionals).\n"
"A function that obeys this constraint on its recursive calls is known as a "
"*properly tail-recursive* function.\n"
"This subject was discussed in [section 22.3.](B9780080571157500224."
"xhtml#s0020)"
msgstr ""
"Такая оптимизация выглядит небольшим выигрышем; мы в основном исключаем "
"единственную инструкцию.\n"
"Фактически, последствия этого нового протокола огромны: теперь мы можем "
"вызывать рекурсивную функцию до произвольной глубины без увеличения стека "
"вообще - до тех пор, пока рекурсивный вызов является последним оператором в "
"функции (или в ветви функция, когда есть условные выражения).\n"
"Функция, которая подчиняется этому ограничению на свои рекурсивные вызовы, "
"известна как *правильная хвосто- рекурсивная* функция.\n"
"Эта тема обсуждалась в [разделе 22.3.](B9780080571157500224.xhtml#s0020)"

#: in/chapter23.md:408
msgid ""
"All the examples so far have only dealt with global variables.\n"
"Here's an example using local variables:"
msgstr ""
"До сих пор все примеры касались только глобальных переменных.\n"
"Вот пример использования локальных переменных:"

#: in/chapter23.md:412
msgid ""
"```\n"
"> (comp-show '((lambda (x) ((lambda (y z) (f x y z)) 3 x)) 4))\n"
"```"
msgstr ""

#: in/chapter23.md:433
msgid ""
"| []()     |          |          |     |     |     |     |\n"
"|----------|----------|----------|-----|-----|-----|-----|\n"
"| `ARGS`   | `0`      |          |     |     |     |     |\n"
"| `CONST`  | `4`      |          |     |     |     |     |\n"
"| `FN`     |          |          |     |     |     |     |\n"
"|          | `ARGS`   | `1`      |     |     |     |     |\n"
"|          | `CONST`  | `3`      |     |     |     |     |\n"
"|          | `LVAR`   | `0`      | `0` | ;   | `X` |     |\n"
"|          | `FN`     |          |     |     |     |     |\n"
"|          |          | `ARGS`   | `2` |     |     |     |\n"
"|          |          | `LVAR`   | `1` | `0` | ;   | `X` |\n"
"|          |          | `LVAR`   | `0` | `0` | ;   | `Y` |\n"
"|          |          | `LVAR`   | `0` | `1` | `;` | `Z` |\n"
"|          |          | `GVAR`   | `F` |     |     |     |\n"
"|          |          | `CALL`   | `3` |     |     |     |\n"
"|          |          | `RETURN` |     |     |     |     |\n"
"|          | `CALL`   | `2`      |     |     |     |     |\n"
"|          | `RETURN` |          |     |     |     |     |\n"
"| `CALL`   | `1`      |          |     |     |     |     |\n"
"| `RETURN` |          |          |     |     |     |     |"
msgstr ""

#: in/chapter23.md:441
msgid ""
"The code is indented to show nested functions.\n"
"The top-level function loads the constant 4 and an anonymous function, and "
"calls the function.\n"
"This function loads the constant 3 and the local variable `x`, which is the "
"first (0th) element in the top (0th) frame.\n"
"It then calls the double-nested function on these two arguments.\n"
"This function loads `x, y`, and `z: x` is now the 0th element in the next-to-"
"top (1st) frame, and `y` and `z` are the 0th and 1st elements of the top "
"frame.\n"
"With all the arguments in place, the function `f` is finally called.\n"
"Note that no continuations are stored-`f` can return directly to the caller "
"of this function."
msgstr ""
"Код имеет отступ для отображения вложенных функций.\n"
"Функция верхнего уровня загружает константу 4 и анонимную функцию и вызывает "
"функцию.\n"
"Эта функция загружает константу 3 и локальную переменную `x`, которая "
"является первым (0-м) элементом в верхнем (0-м) кадре.\n"
"Затем он вызывает функцию с двойной вложенностью для этих двух аргументов.\n"
"Эта функция загружает `x, y`, и `z: x` теперь является 0-м элементом "
"следующего (первого) кадра, а `y` и `z` являются 0-м и 1-м элементами "
"верхнего кадра.\n"
"Со всеми аргументами, наконец, вызывается функция `f`.\n"
"Обратите внимание, что никакие продолжения не сохраняются - `f` может "
"возвращаться непосредственно вызывающей эту функцию стороне."

#: in/chapter23.md:443
msgid ""
"However, all this explicit manipulation of environments is inefficient; in "
"this case we could have compiled the whole thing by simply pushing 4, 3, and "
"4 on the stack and calling `f`."
msgstr ""
"Однако все эти явные манипуляции с окружением неэффективны; в этом случае мы "
"могли бы скомпилировать все, просто поместив 4, 3 и 4 в стек и вызвав `f`."

#: in/chapter23.md:445
msgid "## 23.1 A Properly Tail-Recursive Lisp Compiler"
msgstr "## 23.1 Правильный хвосто-рекурсивный компилятор Лиспа"

#: in/chapter23.md:450
msgid ""
"In this section we describe a new version of the compiler, first by showing "
"examples of its output, and then by examining the compiler itself, which is "
"summarized in [figure 23.3](#f0020).\n"
"The new version of the compiler also makes use of a different function "
"calling sequence, using two new instructions, `CALLJ` and `SAVE`.\n"
"As the name implies, `SAVE` saves a return address on the stack.\n"
"The `CALLJ` instruction no longer saves anything; it can be seen as an "
"unconditional jump-hence the `J` in its name."
msgstr ""
"В этом разделе мы описываем новую версию компилятора, сначала показывая "
"примеры его вывода, а затем исследуя сам компилятор, который кратко описан "
"на [рис. 23.3](#f0020).\n"
"В новой версии компилятора также используется другая последовательность "
"вызова функций с использованием двух новых инструкций, `CALLJ` и `SAVE`.\n"
"Как следует из названия, `SAVE` сохраняет адрес возврата в стеке.\n"
"Инструкция `CALLJ` больше ничего не сохраняет; её можно рассматривать как "
"безусловный переход - отсюда и буква `J` в её названии."

#: in/chapter23.md:455
msgid ""
"| []() |\n"
"|---|\n"
"| ![f23-03](images/chapter23/f23-03.jpg) |\n"
"| Figure 23.3: Glossary of the Scheme Compiler, Second Version |"
msgstr ""

#: in/chapter23.md:457
msgctxt "in/chapter23.md:457"
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter23.md:459
msgid "First, we see how nested function calls work:"
msgstr "Сначала мы посмотрим, как работают вызовы вложенных функций:"

#: in/chapter23.md:463
msgid ""
"```\n"
"> (comp-show '(f (g x)))\n"
"```"
msgstr ""

#: in/chapter23.md:473
msgid ""
"| []()  |         |      |\n"
"|-------|---------|------|\n"
"|       | `ARGS`  | `0`  |\n"
"|       | `SAVE`  | `K1` |\n"
"|       | `GVAR`  | `X`  |\n"
"|       | `GVAR`  | `G`  |\n"
"|       | `CALLJ` | `1`  |\n"
"| `K1:` | `GVAR`  | `F`  |\n"
"|       | `CALLJ` | `1`  |"
msgstr ""

#: in/chapter23.md:477
msgid ""
"The continuation point `K1` is saved so that g can return to it, but then no "
"continuation is saved for f, so f returns to whatever continuation is on the "
"stack.\n"
"Thus, there is no need for an explicit `RETURN` instruction.\n"
"The final `CALL` is like an unconditional branch."
msgstr ""
"Точка продолжения `K1` сохраняется, чтобы g мог вернуться к ней, но тогда "
"продолжение для f не сохраняется, поэтому f возвращается к любому "
"продолжению, находящемуся в стеке.\n"
"Таким образом, нет необходимости в явной инструкции `RETURN`.\n"
"Последний `CALL` подобен безусловному переходу."

#: in/chapter23.md:479
msgid ""
"The following example shows that all functions but the last `(f)` need a "
"continuation point:"
msgstr ""
"В следующем примере показано, что все функции, кроме последней `(f)`, "
"нуждаются в точке продолжения:"

#: in/chapter23.md:483
msgid ""
"```\n"
"> (comp-show '(f (g (h x) (h y))))\n"
"```"
msgstr ""

#: in/chapter23.md:500
msgid ""
"| []()  |         |      |\n"
"|-------|---------|------|\n"
"|       | `ARGS`  | `0`  |\n"
"|       | `SAVE`  | `K1` |\n"
"|       | `SAVE`  | `K2` |\n"
"|       | `GVAR`  | `X`  |\n"
"|       | `GVAR`  | `H`  |\n"
"|       | `CALLJ` | `1`  |\n"
"| `K2:` | `SAVE`  | `K3` |\n"
"|       | `GVAR`  | `Y`  |\n"
"|       | `GVAR`  | `H`  |\n"
"|       | `CALLJ` | `1`  |\n"
"| `K3:` | `GVAR`  | `G`  |\n"
"|       | `CALLJ` | `2`  |\n"
"| `K1:` | `GVAR`  | `F`  |\n"
"|       | `CALLJ` | `1`  |"
msgstr ""

#: in/chapter23.md:505
msgid ""
"This code first computes `(h x)` and returns to `K2`.\n"
"Then it computes `(h y)` and returns to `K3`.\n"
"Next it calls `g` on these two values, and returns to `K1` before "
"transferring to `f`.\n"
"Since whatever `f` returns will also be the final value of the function we "
"are compiling, there is no need to save a continuation point for `f` to "
"return to."
msgstr ""
"Этот код сначала вычисляет `(h x)` и возвращается к `K2`.\n"
"Затем он вычисляет `(h y)` и возвращается к `K3`.\n"
"Затем он вызывает `g` для этих двух значений и возвращается к `K1` перед "
"переходом к `f`.\n"
"Поскольку все, что возвращает `f`, также будет окончательным значением "
"функции, которую мы компилируем, нет необходимости сохранять точку "
"продолжения для возврата `f`."

#: in/chapter23.md:507
msgid ""
"In the next example we see that unneeded constants and variables in `begin` "
"expressions are ignored:"
msgstr ""
"В следующем примере мы видим, что ненужные константы и переменные в "
"выражениях `begin` игнорируются:"

#: in/chapter23.md:511
msgid ""
"```\n"
"> (comp-show '(begin \"doc\" x (f x) y))\n"
"```"
msgstr ""

#: in/chapter23.md:522
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `SAVE`   | `K1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALLJ`  | `1`  |\n"
"| `K1:` | `POP`    |      |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:527
msgid ""
"One major flaw with the first version of the compiler is that it could pass "
"data around, but it couldn't actually *do* anything to the data objects.\n"
"We fix that problem by augmenting the machine with instructions to do "
"arithmetic and other primitive operations.\n"
"Unneeded primitive operations, like variables constants, and arithmetic "
"operations are ignored when they are in the nonfinal position within "
"`begins`.\n"
"Contrast the following two expressions:"
msgstr ""
"Одним из основных недостатков первой версии компилятора является то, что она "
"могла передавать данные, но на самом деле она не могла ничего *делать* с "
"объектами данных.\n"
"Мы исправляем эту проблему, дополнив машину инструкциями для выполнения "
"арифметических и других примитивных операций.\n"
"Ненужные примитивные операции, такие как переменные, константы и "
"арифметические операции, игнорируются, когда они находятся в нефинальной "
"позиции в пределах `begin`.\n"
"Сравните два следующих выражения:"

#: in/chapter23.md:531
msgctxt "in/chapter23.md:531"
msgid ""
"```\n"
"> (comp-show '(begin (+ (* a x) (f x)) x))\n"
"```"
msgstr ""

#: in/chapter23.md:542
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `SAVE`   | `K1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALLJ`  | `1`  |\n"
"| `K1:` | `POP`    |      |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:544
msgid "| `> (comp-show '(begin (+ (* a x) (f x))))` |"
msgstr ""

#: in/chapter23.md:557
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `A`  |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `*`      |      |\n"
"|       | `SAVE`   | `K1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALLJ`  | `1`  |\n"
"| `K1:` | `+`      |      |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:562
msgid ""
"The first version of the compiler was context-free, in that it compiled all "
"equivalent expressions equivalently, regardless of where they appeared.\n"
"A properly tail-recursive compiler needs to be context-sensitive: it must "
"compile a call that is the final value of a function differently than a call "
"that is used as an intermediate value, or one whose value is ignored.\n"
"In the first version of the compiler, `comp-lambda` was responsible for "
"generating the `RETURN` instruction, and all code eventually reached that "
"instruction.\n"
"To make sure the `RETURN` was reached, the code for the two branches of `if` "
"expressions had to rejoin at the end."
msgstr ""
"Первая версия компилятора была контекстно-свободной в том смысле, что она "
"эквивалентно компилировала все эквивалентные выражения, независимо от того, "
"где они появились.\n"
"Компилятор с правильной хвостовой рекурсией должен быть контекстно-"
"зависимым: он должен компилировать вызов, который является конечным "
"значением функции, иначе, чем вызов, который используется в качестве "
"промежуточного значения или значение которого игнорируется.\n"
"В первой версии компилятора `comp-lambda` отвечал за генерацию инструкции "
"`RETURN`, и весь код в конечном итоге достигал этой инструкции.\n"
"Чтобы убедиться, что `RETURN` был достигнут, код для двух ветвей выражения "
"`if` должен был воссоединиться в конце."

#: in/chapter23.md:564
msgid ""
"In the tail-recursive compiler, each piece of code is responsible for "
"inserting its own `RETURN` instruction or implicitly returning by calling "
"another function without saving a continuation point."
msgstr ""
"В компиляторе с хвостовой рекурсией каждый фрагмент кода отвечает за вставку "
"собственной инструкции `RETURN` или неявный возврат путем вызова другой "
"функции без сохранения точки продолжения."

#: in/chapter23.md:569
msgid ""
"We keep track of these possibilities with two flags.\n"
"The parameter `val?` is true when the expression we are compiling returns a "
"value that is used elsewhere.\n"
"The parameter `more?` is false when the expression represents the final "
"value, and it is true when there is more to compute.\n"
"In summary, there are three possibilities:"
msgstr ""
"Мы отслеживаем эти возможности с помощью двух флагов.\n"
"Параметр `val?` истинен, когда выражение, которое мы компилируем, возвращает "
"значение, которое используется в другом месте.\n"
"Параметр `more?` является ложным, когда выражение представляет окончательное "
"значение, и истинным, когда необходимо еще вычислять.\n"
"Таким образом, есть три возможности:"

#: in/chapter23.md:576
msgid ""
"| `val?` | `more?` | example: the `X` in:          |\n"
"|--------|---------|-------------------------------|\n"
"| true   | true    | `(if X y z)`*or*`(f X y)`     |\n"
"| true   | false   | `(if p X z)`*or*`(begin y X)` |\n"
"| false  | true    | `(begin X y)`                 |\n"
"| false  | false   | *impossible*                  |"
msgstr ""

#: in/chapter23.md:578
msgid "The code for the compiler employing these conventions follows:"
msgstr "Код для компилятора, использующего эти соглашения, следующий:"

#: in/chapter23.md:598
msgid ""
"```lisp\n"
"(defun comp (x env)\n"
"  \"Compile the expression x into a list of instructions\"\n"
"  (cond\n"
"    ((symbolp x) (gen-var x env))\n"
"    ((atom x) (gen 'CONST x))\n"
"    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))\n"
"    ((case (first x)\n"
"       (QUOTE  (gen 'CONST (second x)))\n"
"       (BEGIN  (comp-begin (rest x) env))\n"
"       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))\n"
"       (IF     (comp-if (second x) (third x) (fourth x) env))\n"
"       (LAMBDA (gen 'FN (comp-lambda (second x) (rest (rest x)) env)))\n"
"       ;; Procedure application:\n"
"       ;; Compile args, then fn, then the call\n"
"       (t      (seq (mappend #'(lambda (y) (comp y env)) (rest x))\n"
"                    (comp (first x) env)\n"
"                              (gen 'call (length (rest x)))))))))\n"
"```"
msgstr ""

#: in/chapter23.md:601
msgid ""
"Here we've added one more case: `t` and `nil` compile directly into "
"primitive instructions, rather than relying on them being bound as global "
"variables.\n"
"(In real Scheme, the Boolean values are `#t` and `#f`, which need not be "
"quoted, the empty list is `()`, which must be quoted, and `t` and `nil` are "
"ordinary symbols with no special significance.)"
msgstr ""
"Здесь мы добавили еще один случай: `t` и `nil` компилируются непосредственно "
"в примитивные инструкции, а не полагаются на их привязку как глобальные "
"переменные.\n"
"(В реальной Scheme логические значения - это `# t` и `#f`, которые не нужно "
"заключать в кавычки, пустой список - это `()`, который должен быть заключен "
"в кавычки, а `t` и `nil` - обычные символы. без особого значения.)"

#: in/chapter23.md:605
msgid ""
"I've also added some error checking for the number of arguments supplied to "
"quote, `set!` and `if`.\n"
"Note that it is reasonable to do more error checking in a compiler than in "
"an interpreter, since the checking need be done only once, not each time "
"through.\n"
"The function to check arguments is as follows:"
msgstr ""
"Я также добавил проверку на ошибки количества аргументов, передаваемых в "
"`quote`, `set!` и `if`.\n"
"Обратите внимание, что в компиляторе разумно выполнять больше проверок "
"ошибок, чем в интерпретаторе, поскольку проверка должна выполняться только "
"один раз, а не каждый раз.\n"
"Функция проверки аргументов следующая:"

#: in/chapter23.md:615
msgid ""
"```lisp\n"
"(defun arg-count (form min &optional (max min))\n"
"  \"Report an error if form has wrong number of args.\"\n"
"  (let ((n-args (length (rest form))))\n"
"    (assert (<= min n-args max) (form)\n"
"      \"Wrong number of arguments for ~a in ~a:\n"
"       ~d supplied, ~d~@[ to ~d~] expected\"\n"
"      (first form) form n-args min (if (/= min max) max))))\n"
"```"
msgstr ""

#: in/chapter23.md:617
msgid ""
"**Exercise  23.1 [m]** Modify the compiler to check for additional compile-"
"time errors suggested by the following erroneous expression:"
msgstr ""
"**Exercise  23.1 [m]** Измените компилятор, чтобы проверить наличие "
"дополнительных ошибок времени компиляции, совершенных следующим ошибочным "
"выражением:"

#: in/chapter23.md:621
msgid ""
"```lisp\n"
"(cdr (+ (list x y) 'y (3 x) (car 3 x)))\n"
"```"
msgstr ""

#: in/chapter23.md:623
msgid ""
"The tail-recursive compiler still has the familiar nine cases, but I have "
"introduced `comp-var, comp-const, comp-if,` and `comp-funcall` to handle the "
"increased complexity introduced by the `var?` and `more?` parameters."
msgstr ""
"Хвостово-рекурсивный компилятор по-прежнему имеет девять известных случаев, "
"но я ввел `comp-var`, `comp-const`, `comp-if` и `comp-funcall`, чтобы "
"справиться с повышенной сложностью, вызванной параметрами `var?` и `more?`."

#: in/chapter23.md:627
msgid ""
"Let's go through the `comp-` functions one at a time.\n"
"First, `comp-begin` and `comp-list` just handle and pass on the additional "
"parameters.\n"
"`comp-list` will be used in `comp-funcall`, a new function that will be "
"introduced to compile a procedure application."
msgstr ""
"Давайте рассмотрим функции `comp-` по очереди.\n"
"Во-первых, `comp-begin` и `comp-list` просто обрабатывают и передают "
"дополнительные параметры.\n"
"`comp-list` будет использоваться в `comp-funcall`, новой функции, которая "
"будет введена для компиляции применения процедуры."

#: in/chapter23.md:636
msgid ""
"```lisp\n"
"(defun comp-begin (exps env val? more?)\n"
"  \"Compile a sequence of expressions,\n"
"  returning the last one as the value.\"\n"
"  (cond ((null exps) (comp-const nil val? more?))\n"
"        ((length=1 exps) (comp (first exps) env val? more?))\n"
"        (t (seq (comp (first exps) env nil t)\n"
"                (comp-begin (rest exps) env val? more?)))))"
msgstr ""

#: in/chapter23.md:643
msgid ""
"(defun comp-list (exps env)\n"
"  \"Compile a list, leaving them all on the stack.\"\n"
"  (if (null exps) nil\n"
"      (seq (comp (first exps) env t t)\n"
"           (comp-list (rest exps) env))))\n"
"```"
msgstr ""

#: in/chapter23.md:649
msgid ""
"Then there are two trivial functions to compile variable access and "
"constants.\n"
"If the value is not needed, these produce no instructions at all.\n"
"If there is no more to be done, then these functions have to generate the "
"return instruction.\n"
"This is a change from the previous version of `comp`, where the caller "
"generated the return instruction.\n"
"Note I have extended the machine to include instructions for the most common "
"constants: t, nil, and some small integers."
msgstr ""
"Затем есть две тривиальные функции для компиляции доступа к переменным и "
"константам.\n"
"Если значение не требуется, они не производят никаких инструкций вообще.\n"
"Если больше ничего не нужно делать, то эти функции должны генерировать "
"инструкцию возврата.\n"
"Это изменение по сравнению с предыдущей версией `comp`, где вызывающий "
"генерировал инструкцию возврата.\n"
"Обратите внимание, что я расширил машину, чтобы включить инструкции для "
"наиболее распространенных констант: t, nil и некоторых небольших целых чисел."

#: in/chapter23.md:657
msgid ""
"```lisp\n"
"(defun comp-const (x val? more?)\n"
"  \"Compile a constant expression.\"\n"
"  (if val? (seq (if (member x '(t nil -1 0 1 2))\n"
"                    (gen x)\n"
"                    (gen 'CONST x))\n"
"                (unless more? (gen 'RETURN)))))"
msgstr ""

#: in/chapter23.md:662
msgid ""
"(defun comp-var (x env val? more?)\n"
"  \"Compile a variable reference.\"\n"
"  (if val? (seq (gen-var x env) (unless more? (gen 'RETURN)))))\n"
"```"
msgstr ""

#: in/chapter23.md:669
msgid ""
"The remaining two functions are more complex.\n"
"First consider `comp-if` . Rather than blindly generating code for the "
"predicate and both branches, we will consider some special cases.\n"
"First, it is clear that `(if t x y)` can reduce to `x` and `(if nil x y)` "
"can reduce to `y`.\n"
"It is perhaps not as obvious that `(if p x x)` can reduce to `(begin p x)`, "
"or that the comparison of equality between the two branches should be done "
"on the object code, not the source code.\n"
"Once these trivial special cases have been considered, we're left with three "
"more cases: `(if p x nil), (if p nil y),` and `(if p x y)`.\n"
"The pattern of labels and jumps is different for each."
msgstr ""
"Оставшиеся две функции более сложны.\n"
"Сначала рассмотрим `comp-if`. Вместо того чтобы слепо генерировать код для "
"предиката и обеих ветвей, мы рассмотрим некоторые частные случаи(case).\n"
"Во-первых, ясно, что `(if t x y)` можно свести к `x` и `(if nil x y)` можно "
"свести к `y`.\n"
"Возможно, не так очевидно, что `(if p x x)` может быть сведено к `(begin p "
"x)`, или что сравнение equality на равенство между двумя ветвями должно "
"выполняться на объектном коде, а не на исходном коде.\n"
"Когда эти тривиальные частные случаи были рассмотрены, у нас осталось еще "
"три случая: `(if р х nil), (if p nil y)` и `(if p x y)`.\n"
"Шаблон меток и переходов для каждого из них различен."

#: in/chapter23.md:705
msgid ""
"```lisp\n"
"(defun comp-if (pred then else env val? more?)\n"
"  \"Compile a conditional (IF) expression.\"\n"
"  (cond\n"
"    ((null pred)          ; (if nil x y) ==> y\n"
"     (comp else env val? more?))\n"
"    ((constantp pred)     ; (if t x y) ==> x\n"
"     (comp then env val? more?))\n"
"    ((and (listp pred)    ; (if (not p) x y) ==> (if p y x)\n"
"          (length=1 (rest pred))\n"
"          (primitive-p (first pred) env 1)\n"
"          (eq (prim-opcode (primitive-p (first pred) env 1)) 'not))\n"
"     (comp-if (second pred) else then env val? more?))\n"
"    (t (let ((pcode (comp pred env t t))\n"
"             (tcode (comp then env val? more?))\n"
"             (ecode (comp else env val? more?)))\n"
"         (cond\n"
"           ((equal tcode ecode) ; (if p x x) ==> (begin p x)\n"
"            (seq (comp pred env nil t) ecode))\n"
"           ((null tcode)  ; (if p nil y) ==> p (TJUMP L2) y L2:\n"
"            (let ((L2 (gen-label)))\n"
"              (seq pcode (gen 'TJUMP L2) ecode (list L2)\n"
"                   (unless more? (gen 'RETURN)))))\n"
"           ((null ecode)  ; (if p x) ==> p (FJUMP L1) x L1:\n"
"            (let ((L1 (gen-label)))\n"
"              (seq pcode (gen 'FJUMP L1) tcode (list L1)\n"
"                   (unless more? (gen 'RETURN)))))\n"
"           (t             ; (if p x y) ==> p (FJUMP L1) x L1: y\n"
"                          ; or p (FJUMP L1) x (JUMP L2) L1: y L2:\n"
"            (let ((L1 (gen-label))\n"
"                  (L2 (if more? (gen-label))))\n"
"              (seq pcode (gen 'FJUMP L1) tcode\n"
"                   (if more? (gen 'JUMP L2))\n"
"                   (list L1) ecode (if more? (list L2))))))))))\n"
"```"
msgstr ""

#: in/chapter23.md:708
msgid ""
"Here are some examples of `if` expressions.\n"
"First, a very simple example:"
msgstr ""
"Вот несколько примеров выражений типа `if`.\n"
"Во-первых, очень простой пример:"

#: in/chapter23.md:712
msgid ""
"```\n"
"> (comp-show '(if p (+ x y) (* x y)))\n"
"```"
msgstr ""

#: in/chapter23.md:726
msgid ""
"| []()   |          |      |\n"
"|--------|----------|------|\n"
"|        | `ARGS`   | `0`  |\n"
"|        | `GVAR`   | `P`  |\n"
"|        | `FJUMP`  | `L1` |\n"
"|        | `GVAR`   | `X`  |\n"
"|        | `GVAR`   | `Y`  |\n"
"|        | `+`      |      |\n"
"|        | `RETURN` |      |\n"
"| `L1 :` | `GVAR`   | `X`  |\n"
"|        | `GVAR`   | `Y`  |\n"
"|        | `*`      |      |\n"
"|        | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:730
msgid ""
"Each branch has its own `RETURN` instruction.\n"
"But note that the code generated is sensitive to its context.\n"
"For example, if we put the same expression inside a `begin` expression, we "
"get something quite different:"
msgstr ""
"Каждая ветвь имеет свою собственную инструкцию `RETURN`.\n"
"Но обратите внимание, что генерируемый код чувствителен к его контексту.\n"
"Например, если мы поместим одно и то же выражение в выражение `begin`, мы "
"получим нечто совершенно другое:"

#: in/chapter23.md:734
msgid ""
"```\n"
"> (comp-show '(begin (if p (+ x y) (* x y)) z))\n"
"```"
msgstr ""

#: in/chapter23.md:740
msgid ""
"| []() |          |     |\n"
"|------|----------|-----|\n"
"|      | `ARGS`   | `0` |\n"
"|      | `GVAR`   | `Z` |\n"
"|      | `RETURN` |     |"
msgstr ""

#: in/chapter23.md:745
msgid ""
"What happens here is that `(+ x y)` and `(* x y)`, when compiled in a "
"context where the value is ignored, both resuit in no generated code.\n"
"Thus, the `if` expression reduces to `(if p nil nil)`, which is compiled "
"like `(begin p nil)`, which also generates no code when not evaluated for "
"value, so the final code just references `z`.\n"
"The compiler can only do this optimization because it knows that `+` and `*` "
"are side-effect-free operations.\n"
"Consider what happens when we replace + with `f` :"
msgstr ""
"Здесь происходит то, что `(+ x y)` и `(* x y)`, скомпилированные в "
"контексте, где значение игнорируется, оба повторяются в не генерируемом "
"коде.\n"
"Таким образом, `if` выражение сводится к `(if p nil nil)`, который  "
"компирируется как `(begin p nil)`, который также не генерирует никакого "
"кода, когда не вычисляется для значения, поэтому окончательный код просто "
"ссылается на `z`.\n"
"Компилятор может выполнить эту оптимизацию только потому, что он знает, что `"
"+` и `*` -это операции без побочных эффектов.\n"
"Рассмотрим, что происходит, когда мы заменяем + на `f`:"

#: in/chapter23.md:749
msgid ""
"```\n"
"> (comp-show '(begin (if p (f x) (* x x)) z))\n"
"```"
msgstr ""

#: in/chapter23.md:762
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `P`  |\n"
"|       | `FJUMP`  | `L2` |\n"
"|       | `SAVE`   | `K1` |\n"
"|       | `GVAR`   | `X`  |\n"
"|       | `GVAR`   | `F`  |\n"
"|       | `CALLJ`  | `1`  |\n"
"| `K1:` | `POP`    |      |\n"
"| `L2:` | `GVAR`   | `Z`  |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:764
msgid ""
"Here we have to call `(f x)` if `p` is true (and then throw away the value "
"returned), but we don't have to compute `(* x x)` when `p` is false."
msgstr ""
"Здесь мы имеем вызов `(f x)` если `p` равно истине (а затем выбросывающий "
"возвращенное значение), но нам не нужно вычислять `(* x x)`, когда `p` ложно "

#: in/chapter23.md:775
msgid ""
"These examples have inadvertently revealed some of the structure of `comp-"
"funcall`, which handles five cases.\n"
"First, it knows some primitive functions that have corresponding "
"instructions and compiles these instructions inline when their values are "
"needed.\n"
"If the values are not needed, then the function can be ignored, and just the "
"arguments can be compiled.\n"
"This assumes true functions with no side effects.\n"
"If there are primitive operations with side effects, they too can be "
"compiled inline, but the operation can never be ignored.\n"
"The next case is when the function is a lambda expression of no arguments.\n"
"We can just compile the body of the lambda expression as if it were a "
"`begin` expression.\n"
"Nonprimitive functions require a function call.\n"
"There are two cases: when there is more to compile we have to save a "
"continuation point, and when we are compiling the final value of a function, "
"we can just branch to the called function.\n"
"The whole thing looks like this:"
msgstr ""
"Эти примеры непреднамеренно выявили некоторую структуру `comp-funcall`, "
"которая обрабатывает пять случаев.\n"
"Во-первых, она знает некоторые примитивные функции, которые имеют "
"соответствующие инструкции, и компилирует эти инструкции встраиваемыми, "
"когда необходимы их значения.\n"
"Если значения не нужны, то функция может быть проигнорирована, и только "
"аргументы могут быть скомпилированы.\n"
"Это предполагает истинные функции без каких-либо побочных эффектов.\n"
"Если есть примитивные операции с побочными эффектами, они тоже могут быть "
"скомпилированы встроенно, но эта операция никогда не может быть "
"проигнорирована.\n"
"Следующий случай - это когда функция является лямбда-выражением без "
"аргументов.\n"
"Мы можем просто скомпилировать тело лямбда-выражения, как если бы это было "
"выражение `begin`.\n"
"Непримитивные функции требуют вызова функции.\n"
"Есть два случая: когда нужно скомпилировать больше, мы должны сохранить "
"точку продолжения, и когда мы компилируем конечное значение функции, мы "
"можем просто ответвляться(переходить) на вызываемую функцию.\n"
"Все это выглядит примерно так:"

#: in/chapter23.md:807
msgid ""
"```lisp\n"
"(defun comp-funcall (f args env val? more?)\n"
"  \"Compile an application of a function to arguments.\"\n"
"  (let ((prim (primitive-p f env (length args))))\n"
"    (cond\n"
"      (prim  ; function compilable to a primitive instruction\n"
"       (if (and (not val?) (not (prim-side-effects prim)))\n"
"           ;; Side-effect free primitive when value unused\n"
"           (comp-begin args env nil more?)\n"
"           ;; Primitive with value or call needed\n"
"           (seq (comp-list args env)\n"
"                (gen (prim-opcode prim))\n"
"                (unless val? (gen 'POP))\n"
"                (unless more? (gen 'RETURN)))))\n"
"      ((and (starts-with f 'lambda) (null (second f)))\n"
"       ;; ((lambda () body)) => (begin body)\n"
"       (assert (null args) () \"Too many arguments supplied\")\n"
"       (comp-begin (rest2 f) env val? more?))\n"
"      (more? ; Need to save the continuation point\n"
"       (let ((k (gen-label 'k)))\n"
"         (seq (gen 'SAVE k)\n"
"              (comp-list args env)\n"
"              (comp f env t t)\n"
"              (gen 'CALLJ (length args))\n"
"              (list k)\n"
"              (if (not val?) (gen 'POP)))))\n"
"      (t     ; function call as rename plus goto\n"
"       (seq (comp-list args env)\n"
"            (comp f env t t)\n"
"            (gen 'CALLJ (length args)))))))\n"
"```"
msgstr ""

#: in/chapter23.md:818
msgid ""
"The support for primitives is straightforward.\n"
"The `prim` data type has five slots.\n"
"The first holds the name of a symbol that is globally bound to a primitive "
"operation.\n"
"The second, `n-args`, is the number of arguments that the primitive "
"requires.\n"
"We have to take into account the number of arguments to each function "
"because we want `(+ x y)` to compile into a primitive addition instruction, "
"while `(+ x y z)` should not.\n"
"It will compile into a call to the + function instead.\n"
"The `opcode` slot gives the opcode that is used to implement the primitive.\n"
"The `always` field is true if the primitive always returns non-nil, `false` "
"if it always returns nil, and nil otherwise.\n"
"It is used in exercise 23.6.\n"
"Finally, the `side-effects` field says if the function has any side effects, "
"like doing I/O or changing the value of an object."
msgstr ""
"Поддержка примитивов проста.\n"
"Тип данных `prim` имеет пять слотов.\n"
"Первый содержит имя символа, глобально связанного с примитивной операцией.\n"
"Второй, `n-args`, - это число аргументов, требующихся примитиву.\n"
"Мы должны учитывать количество аргументов для каждой функции, потому что мы "
"хотим, чтобы `(+ x y)` компилировалась в примитивную инструкцию сложения, в "
"то время как `(+ x y z)` нет.\n"
"Вместо этого она будет компилироваться в вызов функции +.\n"
"Слот `opcode` дает код операции, который используется для реализации "
"примитива.\n"
"Поле `always`  истинно, если примитив всегда возвращает не-nil значение, "
"`ложно`, если оно всегда возвращает nil, и nil в противном случае.\n"
"Оно используется в упражнении 23.6.\n"
"Наконец, поле `side-effects` указывает, есть ли у функции какие-либо "
"побочные эффекты, такие как выполнение ввода-вывода или изменение значения "
"объекта."

#: in/chapter23.md:822
msgid ""
"```lisp\n"
"(defstruct (prim (:type list))\n"
"  symbol n-args opcode always side-effects)"
msgstr ""

#: in/chapter23.md:834
msgid ""
"(defparameter *primitive-fns*\n"
"  '((+ 2 + true nil) (- 2 - true nil) (* 2 * true nil) (/ 2 / true nil)\n"
"    (< 2 < nil nil) (> 2 > nil nil) (<= 2 <= nil nil) (>= 2 >= nil nil)\n"
"    (/= 2 /= nil nil) (= 2 = nil nil)\n"
"    (eq? 2 eq nil nil) (equal? 2 equal nil nil) (eqv? 2 eql nil nil)\n"
"    (not 1 not nil nil) (null? 1 not nil nil) (cons 2 cons true nil)\n"
"    (car 1 car nil nil) (cdr 1 cdr nil nil)  (cadr 1 cadr nil nil)\n"
"    (list 1 list1 true nil) (list 2 list2 true nil) (list 3 list3 true nil)\n"
"    (read 0 read nil t) (write 1 write nil t) (display 1 display nil t)\n"
"    (newline 0 newline nil t) (compiler 1 compiler t nil)\n"
"    (name! 2 name! true t) (random 1 random true nil)))"
msgstr ""

#: in/chapter23.md:843
msgid ""
"(defun primitive-p (f env n-args)\n"
"  \"F is a primitive if it is in the table, and is not shadowed\n"
"  by something in the environment, and has the right number of args.\"\n"
"  (and (not (in-env-p f env))\n"
"       (find f *primitive-fns*\n"
"             :test #'(lambda (f prim)\n"
"                       (and (eq f (prim-symbol prim))\n"
"                            (= n-args (prim-n-args prim)))))))"
msgstr ""

#: in/chapter23.md:850
msgid ""
"(defun list1 (x) (list x))\n"
"(defun list2 (x y) (list x y))\n"
"(defun list3 (x y z) (list x y z))\n"
"(defun display (x) (princ x))\n"
"(defun newline () (terpri))\n"
"```"
msgstr ""

#: in/chapter23.md:853
msgid ""
"These optimizations only work if the symbols are permanently bound to the "
"global values given here.\n"
"We can enforce that by altering `gen-set` to preserve them as constants:"
msgstr ""
"Эти оптимизации работают только в том случае, если символы постоянно "
"привязаны к глобальным значениям, приведенным здесь.\n"
"Мы можем обеспечить это, изменив `gen-set`, чтобы сохранить их как константы:"

#: in/chapter23.md:864
msgid ""
"```lisp\n"
"(defun gen-set (var env)\n"
"  \"Generate an instruction to set a variable to top-of-stack.\"\n"
"  (let ((p (in-env-p var env)))\n"
"    (if p\n"
"        (gen 'LSET (first p) (second p) \";\" var)\n"
"        (if (assoc var *primitive-fns*)\n"
"            (error \"Can't alter the constant ~a\" var)\n"
"            (gen 'GSET var)))))\n"
"```"
msgstr ""

#: in/chapter23.md:869
msgid ""
"Now an expression like `(+ x 1)` will be properly compiled using the + "
"instruction rather than a subroutine call, and an expression like `(set ! + "
"*)` will be flagged as an error when + is a global variable, but allowed "
"when it has been locally bound.\n"
"However, we still need to be able to handle expressions like `(set ! add +)` "
"and then `(add x y)`.\n"
"Thus, we need some function object that + will be globally bound to, even if "
"the compiler normally optimizes away references to that function.\n"
"The function `init-scheme-comp` takes care of this requirement:"
msgstr ""
"Теперь выражение типа `(+ x 1)` будет правильно скомпилировано с "
"использованием инструкции +, а не вызова подпрограммы, и выражение типа "
"`(set ! + *)` будет помечено как ошибка, если + является глобальной "
"переменной, но разрешено, если он был локально привязан.\n"
"Однако нам все еще нужно уметь обрабатывать такие выражения, как `(set! add "
"+)`, а затем `(add x y)`.\n"
"Таким образом, нам нужен некоторый объект функции, к которому + будет "
"глобально привязан, даже если компилятор обычно оптимизирует ссылки на эту "
"функцию.\n"
"Функция `init-scheme-comp` заботится об этом требовании:"

#: in/chapter23.md:879
msgid ""
"```lisp\n"
"(defun init-scheme-comp ()\n"
"  \"Initialize the primitive functions.\"\n"
"  (dolist (prim *primitive-fns*)\n"
"     (setf (get (prim-symbol prim) 'global-val)\n"
"           (new-fn :env nil :name (prim-symbol prim)\n"
"                   :code (seq (gen 'PRIM (prim-symbol prim))\n"
"                              (gen 'RETURN))))))\n"
"```"
msgstr ""

#: in/chapter23.md:883
msgid ""
"There is one more change to make-rewriting `comp-lambda`.\n"
"We still need to get the arguments off the stack, but we no longer generate "
"a `RETURN` instruction, since that is done by `comp-begin`, if necessary.\n"
"At this point we'll provide a hook for a peephole optimizer, which will be "
"introduced in [section 23.4](#s0025), and for an assembler to convert the "
"assembly language to machine code, `new-fn` provides this interface, but for "
"now, `new-fn` acts just like `make-fn`."
msgstr ""
"Нужно внести еще одно изменение - переписать `comp-lambda`.\n"
"Нам все еще нужно извлечь аргументы из стека, но мы больше не генерируем "
"инструкцию `RETURN`, так как это делается `comp-begin`, если это "
"необходимо.\n"
"На этом этапе мы предоставим hook для подсматривающего(peephole) "
"оптимизатора, который будет представлен в [разделе 23.4](#s0025), и для "
"ассемблера, чтобы преобразовать язык ассемблера в машинный код, `new-fn` "
"предоставляет этот интерфейс, но пока `new-fn` действует точно так же, как "
"`make-fn`."

#: in/chapter23.md:889
msgid ""
"We also need to account for the possibility of rest arguments in a lambda "
"list.\n"
"A new function, `gen-rgs`, generates the single instruction to load the "
"arguments of the stack.\n"
"It introduces a new instruction, `ARGS`., into the abstract machine.\n"
"This instruction works just like `ARGS`, except it also conses any remaining "
"arguments on the stack into a list and stores that list as the value of the "
"rest argument.\n"
"With this innovation, the new version of `comp-lambda` looks like this:"
msgstr ""
"Мы также должны учитывать возможность rest аргументов в лямбда-списке.\n"
"Новая функция, `gen-rgs`, генерирует единственную инструкцию для загрузки "
"аргументов стека.\n"
"Она вводит новую инструкцию, `ARGS`., в абстрактную машину.\n"
"Эта инструкция работает точно так же, как `ARGS`, за исключением того, что "
"она также сохраняет все оставшиеся в стеке аргументы в список и сохраняет "
"этот список как значение аргумента rest.\n"
"С этим нововведением новая версия `comp-lambda` выглядит следующим образом:"

#: in/chapter23.md:898
msgid ""
"```lisp\n"
"(defun comp-lambda (args body env)\n"
"  \"Compile a lambda form into a closure with compiled code.\"\n"
"  (new-fn :env env :args args\n"
"          :code (seq (gen-args args 0)\n"
"                     (comp-begin body\n"
"                                 (cons (make-true-list args) env)\n"
"                                 t nil))))"
msgstr ""

#: in/chapter23.md:906
msgid ""
"(defun gen-args (args n-so-far)\n"
"  \"Generate an instruction to load the arguments.\"\n"
"  (cond ((null args) (gen 'ARGS n-so-far))\n"
"        ((symbolp args) (gen 'ARGS. n-so-far))\n"
"        ((and (consp args) (symbolp (first args)))\n"
"         (gen-args (rest args) (+ n-so-far 1)))\n"
"        (t (error \"Illegal argument list\"))))"
msgstr ""

#: in/chapter23.md:913
msgid ""
"(defun make-true-list (dotted-list)\n"
"  \"Convert a possibly dotted list into a true, non-dotted list.\"\n"
"  (cond ((null dotted-list) nil)\n"
"        ((atom dotted-list) (list dotted-list))\n"
"        (t (cons (first dotted-list)\n"
"                 (make-true-list (rest dotted-list))))))"
msgstr ""

#: in/chapter23.md:919
msgid ""
"(defun new-fn (&key code env name args)\n"
"  \"Build a new function.\"\n"
"  (assemble (make-fn :env env :name name :args args\n"
"                     :code (optimize code))))\n"
"```"
msgstr ""

#: in/chapter23.md:922
msgid ""
"`new-fn` includes calls to an assembler and an optimizer to generate actual "
"machine code.\n"
"For the moment, both will be identity functions:"
msgstr ""
"`new-fn` включает вызовы ассемблера и оптимизатора для генерации "
"фактического машинного кода.\n"
"На данный момент обе функции будут идентичными:"

#: in/chapter23.md:927
msgid ""
"```lisp\n"
"(defun optimize (code) code)\n"
"(defun assemble (fn) fn)\n"
"```"
msgstr ""

#: in/chapter23.md:929
msgid "Here are some more examples of the compiler at work:"
msgstr "Вот еще несколько примеров работы компилятора:"

#: in/chapter23.md:933
msgid ""
"```\n"
"> (comp-show '(if (null? (car l)) (f (+ (* a x) b)) (g (/ x 2))))\n"
"```"
msgstr ""

#: in/chapter23.md:952
msgid ""
"| []()  |         |         |     |\n"
"|-------|---------|---------|-----|\n"
"|       | `ARGS`  | `0`     |     |\n"
"|       | `GVAR`  | `L`     |     |\n"
"|       | `CAR`   |         |     |\n"
"|       | `FJUMP` | `L1`    |     |\n"
"|       | `GVAR`  | `X`     |     |\n"
"|       | `2`     |         |     |\n"
"|       | /       |         |     |\n"
"|       | `GVAR`  | `G`     |     |\n"
"|       | `CALLJ` | `1`     |     |\n"
"| `L1:` | `GVAR`  | `A`     |     |\n"
"|       |         | `GVAR`  | `X` |\n"
"|       |         | `*`     |     |\n"
"|       |         | `GVAR`  | `B` |\n"
"|       |         | `+`     |     |\n"
"|       |         | `GVAR`  | `F` |\n"
"|       |         | `CALLJ` | `1` |"
msgstr ""

#: in/chapter23.md:954
msgid ""
"There is no need to save any continuation points in this code, because the "
"only calls to nonprimitive functions occur as the final values of the two "
"branches of the function."
msgstr ""
"В этом коде нет необходимости сохранять какие-либо точки продолжения, "
"поскольку единственные вызовы непримитивных функций происходят как конечные "
"значения двух ветвей функции."

#: in/chapter23.md:958
msgid ""
"```lisp\n"
"> (comp-show '(define (lastl l)\n"
"```"
msgstr ""

#: in/chapter23.md:961
msgid ""
"`                            (if (null?\n"
"(cdr l)) (car l)`"
msgstr ""

#: in/chapter23.md:965
msgid ""
"```lisp\n"
"                                    (last1 (cdr l)))))\n"
"```"
msgstr ""

#: in/chapter23.md:985
msgid ""
"| []()  |          |          |     |     |     |     |\n"
"|-------|----------|----------|-----|-----|-----|-----|\n"
"|       | `ARGS`   | `0`      |     |     |     |     |\n"
"|       | `FN`     |          |     |     |     |     |\n"
"|       | `ARGS`   | `1`      |     |     |     |     |\n"
"|       | `LVAR`   | `0`      | `0` | `;` | `L` |     |\n"
"|       | `CDR`    |          |     |     |     |     |\n"
"|       | `FJUMP`  | `L1`     |     |     |     |     |\n"
"|       | `LVAR`   | `0`      | `0` | `;` | `L` |     |\n"
"|       | `CDR`    |          |     |     |     |     |\n"
"|       | `GVAR`   | `LAST1`  |     |     |     |     |\n"
"|       | `CALLJ`  | `1`      |     |     |     |     |\n"
"| `L1:` |          | `LVAR`   | `0` | `0` | `;` | `L` |\n"
"|       |          | `CAR`    |     |     |     |     |\n"
"|       |          | `RETURN` |     |     |     |     |\n"
"|       | `GSET`   | `LAST1`  |     |     |     |     |\n"
"|       | `CONST`  | `LAST1`  |     |     |     |     |\n"
"|       | `NAME!`  |          |     |     |     |     |\n"
"|       | `RETURN` |          |     |     |     |     |"
msgstr ""

#: in/chapter23.md:988
msgid ""
"The top-level function just assigns the nested function to the global "
"variable `last1`.\n"
"Since `last1` is tail-recursive, it has only one return point, for the "
"termination case, and just calls itself without saving continuations until "
"that case is executed."
msgstr ""
"Функция верхнего уровня просто присваивает вложенную функцию глобальной "
"переменной `last1`.\n"
"Поскольку `last1` является хвосто-рекурсивной, она имеет только одну точку "
"возврата для случая завершения и просто вызывает себя без сохранения "
"продолжений до тех пор, пока этот случай не будет выполнен."

#: in/chapter23.md:991
msgid ""
"Contrast that to the non-tail-recursive definition of `length` below.\n"
"It is not tail-recursive because before it calls `length` recursively, it "
"must save a continuation point, `K1`, so that it will know where to return "
"to to add 1."
msgstr ""
"Сравните это с приведенным ниже не хвосто-рекурсивным определением "
"`length`.\n"
"Она не является хвостово-рекурсивной, потому что перед рекурсивным вызовом "
"`length` она должна сохранить точку продолжения, `K1`, чтобы знать, куда "
"вернуться, чтобы добавить 1."

#: in/chapter23.md:995
msgid ""
"```lisp\n"
"> (comp-show '(define (length l)\n"
"```"
msgstr ""

#: in/chapter23.md:998
msgid ""
"`                                (if (null?\n"
"l) 0 (+  1 (length (cdr l))))))`"
msgstr ""

#: in/chapter23.md:1020
msgid ""
"| []()  |          |          |          |     |     |     |\n"
"|-------|----------|----------|----------|-----|-----|-----|\n"
"|       | `ARGS`   | `0`      |          |     |     |     |\n"
"|       | `FN`     |          |          |     |     |     |\n"
"|       |          | `ARGS`   | `1`      |     |     |     |\n"
"|       |          | `LVAR`   | `0`      | `0` | `;` | `L` |\n"
"|       |          | `FJUMP`  | `L2`     |     |     |     |\n"
"|       |          | `1`      |          |     |     |     |\n"
"|       |          | `SAVE`   | `K1`     |     |     |     |\n"
"|       |          | `LVAR`   | `0`      | `0` | `;` | `L` |\n"
"|       |          | `CDR`    |          |     |     |     |\n"
"|       |          | `GVAR`   | `LENGTH` |     |     |     |\n"
"|       |          | `CALLJ`  | `1`      |     |     |     |\n"
"| `K1:` |          | `+`      |          |     |     |     |\n"
"|       |          | `RETURN` |          |     |     |     |\n"
"| `L2`  |          | `0`      |          |     |     |     |\n"
"|       |          | `RETURN` |          |     |     |     |\n"
"|       | `GSET`   | `LENGTH` |          |     |     |     |\n"
"|       | `CONST`  | `LENGTH` |          |     |     |     |\n"
"|       | `NAME!`  |          |          |     |     |     |\n"
"|       | `RETURN` |          |          |     |     |     |"
msgstr ""

#: in/chapter23.md:1022
msgid "Of course, it is possible to write `length` in tail-recursive fashion:"
msgstr "Конечно, можно написать `length` в хвостовой рекурсивной манере:"

#: in/chapter23.md:1027
msgid ""
"```lisp\n"
"> (comp-show '(define (length l)\n"
"                            (letrec ((len (lambda (l n)\n"
"```"
msgstr ""

#: in/chapter23.md:1030
msgid ""
"`                                                            (if (null?\n"
"l) n`"
msgstr ""

#: in/chapter23.md:1035
msgid ""
"```lisp\n"
"                                                                    (len "
"(rest l) (+ n l))))))\n"
"                                (len l 0))))\n"
"```"
msgstr ""

#: in/chapter23.md:1070
msgid ""
"| []()  |          |          |         |          |        |     |       "
"|       |\n"
"|-------|----------|----------|---------|----------|--------|-----|-------|-------|\n"
"|       | `ARGS`   | `0`      |         |          |        |     |       "
"|       |\n"
"|       | `FN`     |          |         |          |        |     |       "
"|       |\n"
"|       |          | `ARGS`   | `1`     |          |        |     |       "
"|       |\n"
"|       |          | `NIL`    |         |          |        |     |       "
"|       |\n"
"|       |          | `FN`     |         |          |        |     |       "
"|       |\n"
"|       |          |          | `ARGS`  | `1`      |        |     |       "
"|       |\n"
"|       |          |          | `FN`    |          |        |     |       "
"|       |\n"
"|       |          |          |         | `ARGS`   | `2`    |     |       "
"|       |\n"
"|       |          |          |         | `LVAR`   | `0`    | `0` | `;`   | "
"`L`   |\n"
"|       |          |          |         | `FJUMP`  | `L2`   |     |       "
"|       |\n"
"|       |          |          |         | `SAVE`   | `K1`   |     |       "
"|       |\n"
"|       |          |          |         | `LVAR`   | `0`    | `0` | `;`   | "
"`L`   |\n"
"|       |          |          |         | `GVAR`   | `REST` |     |       "
"|       |\n"
"|       |          |          |         | `CALLJ`  | `1`    |     |       "
"|       |\n"
"| `K1:` |          |          |         | `LVAR`   | `0`    | `1` | `;`   | "
"`N`   |\n"
"|       |          |          |         | `1`      |        |     |       "
"|       |\n"
"|       |          |          |         | `+`      |        |     |       "
"|       |\n"
"|       |          |          |         | `LVAR`   | `1`    | `0` | `;`   | "
"`LEN` |\n"
"|       |          |          |         | `CALLJ`  | `2`    |     |       "
"|       |\n"
"| `L2:` |          |          |         | `LVAR`   | `0`    | `1` | `;`   | "
"`N`   |\n"
"|       |          |          |         | `RETURN` |        |     |       "
"|       |\n"
"|       |          |          | `LSET`  | `0`      | `0`    | `;` | `LEN` "
"|       |\n"
"|       |          |          | `POP`   |          |        |     |       "
"|       |\n"
"|       |          |          | `LVAR`  | `1`      | `0`    | `;` | `L`   "
"|       |\n"
"|       |          |          | `0`     |          |        |     |       "
"|       |\n"
"|       |          |          | `LVAR`  | `0`      | `0`    | `;` | `LEN` "
"|       |\n"
"|       |          |          | `CALLJ` | `2`      |        |     |       "
"|       |\n"
"|       |          | `CALLJ`  | `1`     |          |        |     |       "
"|       |\n"
"|       | `GSET`   | `LENGTH` |         |          |        |     |       "
"|       |\n"
"|       | `CONST`  | `LENGTH` |         |          |        |     |       "
"|       |\n"
"|       | `NAME!`  |          |         |          |        |     |       "
"|       |\n"
"|       | `RETURN` |          |         |          |        |     |       "
"|       |"
msgstr ""

#: in/chapter23.md:1072
msgid "Let's look once again at an example with nested conditionals:"
msgstr ""
"Давайте еще раз рассмотрим пример с вложенными условными обозначениями:"

#: in/chapter23.md:1076
msgid ""
"```\n"
"> (comp-show '(if (not (and p q (not r))) x y))\n"
"```"
msgstr ""

#: in/chapter23.md:1095
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `P`  |\n"
"|       | `FJUMP`  | `L3` |\n"
"|       | `GVAR`   | `Q`  |\n"
"|       | `FJUMP`  | `L1` |\n"
"|       | `GVAR`   | `R`  |\n"
"|       | `NOT`    |      |\n"
"|       | `JUMP`   | `L2` |\n"
"| `L1:` | `NIL`    |      |\n"
"| `L2:` | `JUMP`   | `L4` |\n"
"| `L3:` | `NIL`    |      |\n"
"| `L4:` | `FJUMP`  | `L5` |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `RETURN` |      |\n"
"| `L5:` | `GVAR`   | `X`  |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:1101
msgid ""
"Here the problem is with multiple `JUMP`s and with not recognizing "
"negation.\n"
"If `p` is false, then the and expression is false, and the whole predicate "
"is true, so we should return `x`.\n"
"The code does in fact return `x`, but it first jumps to `L3`, loads `NIL`, "
"and then does an `FJUMP` that will always jump to `L5`.\n"
"Other branches have similar inefficiencies.\n"
"A sufficiently clever compiler should be able to generate the following code:"
msgstr ""
"Здесь проблема заключается в множественном `JUMP` и в нераспознавании "
"отрицания.\n"
"Если `p` ложно, то выражение `and` ложно, а весь предикат истинен, поэтому "
"мы должны вернуть `x`.\n"
"Код делает на самом деле возврат `х`, но сначала он прыгает на `L3`, "
"загружает `NIL`, а затем делает `FJUMP`, который всегда будет прыгать на "
"`L5`.\n"
"Другие ветви обладают аналогичной неэффективностью.\n"
"Достаточно умный компилятор должен уметь генерировать следующий код:"

#: in/chapter23.md:1115
msgid ""
"| []()  |          |      |\n"
"|-------|----------|------|\n"
"|       | `ARGS`   | `0`  |\n"
"|       | `GVAR`   | `P`  |\n"
"|       | `FJUMP`  | `L1` |\n"
"|       | `GVAR`   | `Q`  |\n"
"|       | `FJUMP`  | `L1` |\n"
"|       | `GVAR`   | `R`  |\n"
"|       | `TJUMP`  | `L1` |\n"
"|       | `GVAR`   | `Y`  |\n"
"|       | `RETURN` |      |\n"
"| `L1:` | `GVAR X` |      |\n"
"|       | `RETURN` |      |"
msgstr ""

#: in/chapter23.md:1117
msgid "## 23.2 Introducing Call/cc"
msgstr "## 23.2 Введение Call/cc"

#: in/chapter23.md:1126
msgid ""
"Now that the basic compiler works, we can think about how to implement `call/"
"cc` in our compiler.\n"
"First, remember that `call/cc` is a normal function, not a special form.\n"
"So we could define it as a primitive, in the manner of `car` and `cons`.\n"
"However, primitives as they have been defined only get to see their "
"arguments, and `call/cc` will need to see the run-time stack, in order to "
"save away the current continuation.\n"
"One choice is to install `call/cc` as a normal Scheme nonprimitive function "
"but to write its body in assembly code ourselves.\n"
"We need to introduce one new instruction, `CC`, which places on the stack a "
"function (to which we also have to write the assembly code by hand) that "
"saves the current continuation (the stack) in its environment, and, when "
"called, fetches that continuation and installs it, by setting the stack back "
"to that value.\n"
"This requires one more instruction, `SET-CC`.\n"
"The details of this, and of all the other instructions, are revealed in the "
"next section."
msgstr ""
"Теперь, когда базовый компилятор работает, мы можем подумать о том, как "
"реализовать `call/cc` в нашем компиляторе.\n"
"Во-первых, помните, что `call/cc` - это нормальная(обычная) функция, а не "
"специальная форма.\n"
"Таким образом, мы могли бы определить её как примитивную, на манер `car` и "
"`cons`.\n"
"Однако примитивы в том виде, в каком они были определены, могут видеть "
"только свои аргументы, а `call/cc` должна будет видеть стек времени "
"выполнения, чтобы сохранить текущее продолжение.\n"
"Один из вариантов - установить `call/cc` как обычную Непримитивную функцию "
"Scheme, но написать ее тело в ассемблерном коде самостоятельно.\n"
"Нам нужно ввести одну новую инструкцию, `CC`, которая помещает в стек "
"функцию (к которой мы также должны написать ассемблерный код вручную), "
"которая сохраняет текущее продолжение (стек) в своей среде окружения и при "
"вызове извлекает это продолжение и устанавливает его, возвращая стеку это "
"значение.\n"
"Для этого требуется еще одна инструкция, `SET-CC`.\n"
"Подробности этой и всех других инструкций раскрываются в следующем разделе."

#: in/chapter23.md:1128
msgid "## 23.3 The Abstract Machine"
msgstr "## 23.3 Абстрактная Машина"

#: in/chapter23.md:1133
msgid ""
"So far we have defined the instruction set of a mythical abstract machine "
"and generated assembly code for that instruction set.\n"
"It's now time to actually execute the assembly code and hence have a useful "
"compiler.\n"
"There are several paths we could pursue: we could implement the machine in "
"hardware, software, or microcode, or we could translate the assembly code "
"for our abstract machine into the assembly code of some existing machine.\n"
"Each of these approaches has been taken in the past."
msgstr ""
"До сих пор мы определяли набор команд мифической абстрактной машины и "
"генерировали ассемблерный код для этого набора команд.\n"
"Теперь пришло время фактически выполнить ассемблерный код и, следовательно, "
"иметь полезный компилятор.\n"
"Есть несколько путей, которые мы могли бы использовать: мы могли бы "
"реализовать машину в аппаратном, программном обеспечении или микрокоде, или "
"мы могли бы перевести ассемблерный код для нашей абстрактной машины в "
"ассемблерный код какой-либо существующей машины.\n"
"Каждый из этих подходов уже применялся в прошлом."

#: in/chapter23.md:1137
msgid ""
"**Hardware.** If the abstract machine is simple enough, it can be "
"implemented directly in hardware.\n"
"The Scheme-79 and Scheme-81 Chips ([Steele and Sussman 1980]"
"(B9780080571157500285.xhtml#bb1180); [Batali et al.\n"
"1982](B9780080571157500285.xhtml#bb0070)) were VLSI implementations of a "
"machine designed specifically to run Scheme."
msgstr ""
"**Железо.** *Если абстрактная машина достаточно проста, она может быть "
"реализована непосредственно в аппаратном обеспечении.\n"
"Чипы Scheme-79 и Scheme-81 ([Стилл и Sussman 1980](B9780080571157500285."
"xhtml#bb1180); [Batali et al.\n"
"1982](B9780080571157500285.xhtml#bb0070)) были СБИС-реализациями машины, "
"разработанной специально для запуска Scheme.(B9780080571157500285."
"xhtml#bb1180); "

#: in/chapter23.md:1144
msgid ""
"**Macro-Assembler.** In the translation or macro-assembler approach, each "
"instruction in the abstract machine language is translated into one or more "
"instructions in the host computer's instruction set.\n"
"This can be done either directly or by generating assembly code and passing "
"it to the host computer's assembler.\n"
"In general this will lead to code expansion, because the host computer "
"probably will not provide direct support for Scheme's data types.\n"
"Thus, whereas in our abstract machine we could write a single instruction "
"for addition, with native code we might have to execute a series of "
"instructions to check the type of the arguments, do an integer add if they "
"are both integers, a floating-point add if they are both floating-point "
"numbers, and so on.\n"
"We might also have to check the result for overflow, and perhaps convert to "
"bignum representation.\n"
"Compilers that generate native code often include more sophisticated data-"
"flow analysis to know when such checks are required and when they can be "
"omitted."
msgstr ""
"**Макроассемблер.** в подходе трансляции или макроассемблера каждая "
"инструкция на абстрактном машинном языке переводится в одну или несколько "
"инструкций в наборе команд целевого компьютера.\n"
"Это может быть сделано либо непосредственно, либо путем генерации кода "
"сборки и передачи его ассемблеру целевого компьютера.\n"
"В общем случае это приведет к расширению кода, поскольку целевой компьютер, "
"вероятно, не будет обеспечивать прямую поддержку типов данных схемы.\n"
"Таким образом, в то время как в нашей абстрактной машине мы могли бы "
"написать одну инструкцию для сложения, с машинным кодом нам, возможно, "
"придется выполнить серию инструкций, чтобы проверить тип аргументов, сделать "
"целочисленное сложение, если они оба являются целыми числами, сложение с "
"плавающей запятой, если они оба являются числами с плавающей запятой, и так "
"далее.\n"
"Возможно, нам также придется проверить результат на переполнение и, "
"возможно, преобразовать его в представление bignum.\n"
"Компиляторы, генерирующие машинный код, часто включают более сложный анализ "
"потока данных, чтобы знать, когда такие проверки необходимы, а когда их "
"можно пропустить."

#: in/chapter23.md:1154
msgid ""
"**Microcode.** The MIT Lisp Machine project, unlike the Scheme Chip, "
"actually resulted in working machines.\n"
"One important decision was to go with microcode instead of a single chip.\n"
"This made it easy to change the system as experienced was gained, and as the "
"host language was changed from ZetaLisp to Common Lisp.\n"
"The most important architectural feature of the Lisp Machine was the "
"inclusion of tag bits on each word to specify data types.\n"
"Also important was microcode to implement certain frequently used generic "
"operations.\n"
"For example, in the Symbolics 3600 Lisp Machine, the microcode for addition "
"simultaneously did an integer add, a floating-point add, and a check of the "
"tag bits.\n"
"If both arguments turned out to be either integers or floating-point "
"numbers, then the appropriate result was taken.\n"
"Otherwise, a trap was signaled, and a converison routine was entered.\n"
"This approach makes the compiler relatively simple, but the trend in "
"architecture is away from highly microcoded processors toward simpler (RISC) "
"processors."
msgstr ""
"**Микрокод.** проект MIT Lisp Machine, в отличие от чипов Scheme, фактически "
"привел к рабочим машинам.\n"
"Одним из важных решений было использование микрокода вместо одиночного "
"чипа.\n"
"Это позволило легко изменить систему по мере накопления опыта, а также по "
"мере изменения языка хоста с ZetaLisp на Common Lisp.\n"
"Наиболее важной архитектурной особенностью Lisp машины было включение битов "
"тегов в каждое слово для указания типов данных.\n"
"Также важным был микрокод для реализации некоторых часто используемых "
"универсальных операций.\n"
"Например, в Lisp машине Symbolics 3600  микрокод для сложения одновременно "
"выполнял сложение целого числа, сложение с плавающей запятой и проверку "
"битов тега.\n"
"Если оба аргумента оказывались либо целыми числами, либо числами с плавающей "
"запятой, то принимался соответствующий результат.\n"
"В противном случае был подан сигнал о ловушке, и выполнялся вход в процедуру "
"конверсии.\n"
"Этот подход делает компилятор относительно простым, но тенденция в "
"архитектуре уходит от высоко микрокодированных процессоров к более простым "
"(RISC) процессорам."

#: in/chapter23.md:1157
msgid ""
"**Software.** We can remove many of these problems with a technique known as "
"*byte-code assembly.* Here we translate the instructions into a vector of "
"bytes and then interpret the bytes with a byte-code interpreter.\n"
"This gives us (almost) the machine we want; it solves the code expansion "
"problem, but it may be slower than native code compilation, because the byte-"
"code interpreter is written in software, not hardware or microcode."
msgstr ""
"**Программное обеспечение.** Мы можем устранить многие из этих проблем с "
"помощью технологии, известной как *сбокра байт-кода.* Здесь мы переводим "
"инструкции в вектор байтов, а затем интерпретируем байты с помощью "
"интерпретатора байт-кода.\n"
"Это дает нам (почти) машину, которую мы хотим; это решает проблему "
"расширения кода, но это может быть медленнее, чем компиляция в нативный "
"кода(код хост машины), потому что интерпретатор байт-кода написан в "
"программном обеспечении, а не аппаратном или микрокоде."

#: in/chapter23.md:1168
msgid ""
"Each opcode is a single byte (we have less than 256 opcodes, so this will "
"work).\n"
"The instructions with arguments take their arguments in the following bytes "
"of the instruction stream.\n"
"So, for example, a `CALL` instruction occupies two bytes; one for the opcode "
"and one for the argument count.\n"
"This means we have imposed a limit of 256 arguments to a function call.\n"
"An `LVAR` instruction would take three bytes; one for the opcode, one for "
"the frame offset, and one for the offset within the frame.\n"
"Again, we have imposed 256 as the limit on nesting level and variables per "
"frame.\n"
"These limits seem high enough for any code written by a human, but remember, "
"not only humans write code.\n"
"It is possible that some complex macro may expand into something with more "
"than 256 variables, so a full implementation would have some way of "
"accounting for this.\n"
"The `GVAR` and `CONST` instructions have to refer to an arbitrary object; "
"either we can allocate enough bytes to fit a pointer to this object, or we "
"can add a `constants` field to the `fn` structure, and follow the "
"instructions with a single-byte index into this vector of constants.\n"
"This latter approach is more common."
msgstr ""
"Каждый код операции представляет собой один байт (у нас есть менее 256 кодов "
"операций, так что это будет работать).\n"
"Инструкции с аргументами принимают свои аргументы в следующих байтах потока "
"команд.\n"
"Так, например, инструкция `CALL` занимает два байта: один для кода операции "
"и один для количества аргументов.\n"
"Это означает, что мы установили ограничение в 256 аргументов для вызова "
"функции.\n"
"Инструкция `LVAR` будет занимать три байта: один для кода операции, один для "
"смещения кадра и один для смещения внутри кадра.\n"
"Опять же, мы установили 256 в качестве ограничения на уровень вложенности и "
"переменные на кадр.\n"
"Эти ограничения кажутся достаточно высокими для любого кода, написанного "
"человеком, но помните, что не только люди пишут код.\n"
"Вполне возможно, что какой-то сложный макрос может расшириться до чего-то с "
"более чем 256 переменными, поэтому полная реализация будет иметь некоторый "
"способ учета этого.\n"
"Инструкции `GVAR` и `CONST` должны ссылаться на произвольный объект; либо мы "
"можем выделить достаточно байтов, чтобы поместить указатель на этот объект, "
"либо мы можем добавить поле `constants` в структуру `fn` и следовать  "
"инструкциям с однобайтовым индексом в этот вектор констант.\n"
"Этот последний подход более распространен."

#: in/chapter23.md:1171
msgid ""
"We can now handle branches by changing the program counter to an index into "
"the code vector.\n"
"(It seems severe to limit functions to 256 bytes of code; a two-byte label "
"allows for 65536 bytes of code per function.) In summary, the code is more "
"compact, branching is efficient, and dispatching can be fast because the "
"opcode is a small integer, and we can use a branch table to go to the right "
"piece of code for each instruction."
msgstr ""
"Теперь мы можем обрабатывать ветви, изменяя счетчик программы на индекс в "
"кодовом векторе.\n"
"(Ограничение функций до 256 байт кода кажется суровым; двухбайтовая метка "
"позволяет использовать 65536 байт кода для каждой функции.) Таким образом, "
"код более компактен, ветвление эффективно, а диспетчеризация может быть "
"быстрой, потому что код операции-это маленькое целое число, и мы можем "
"использовать таблицу ветвей, чтобы перейти к нужному фрагменту кода для "
"каждой инструкции."

#: in/chapter23.md:1176
msgid ""
"Another source of inefficiency is implementing the stack as a list, and "
"consing up new cells every time something is added to the stack.\n"
"The alternative is to implement the stack as a vector with a fill-pointer.\n"
"That way a push requires no consing, only a change to the pointer (and a "
"check for overflow).\n"
"The check is worthwhile, however, because it allows us to detect infinite "
"loops in the user's code."
msgstr ""
"Другим источником неэффективности является реализация стека в виде списка и "
"создание новых ячеек каждый раз, когда что-то добавляется в стек.\n"
"Альтернативой является реализация стека в виде вектора с указателем "
"заполнения.\n"
"Таким образом, push не требует никакого консинга(создания списка), а только "
"изменения указателя (и проверки на переполнение).\n"
"Однако эта проверка имеет смысл, поскольку позволяет обнаружить бесконечные "
"циклы в коде пользователя."

#: in/chapter23.md:1180
msgid ""
"Here follows an assembler that generates a sequence of instructions (as a "
"vector).\n"
"This is a compromise between byte codes and the assembly language format.\n"
"First, we need some accessor functions to get at parts of an instruction:"
msgstr ""
"Далее следует ассемблер, который генерирует последовательность инструкций (в "
"виде вектора).\n"
"Это компромисс между байтовыми кодами и форматом языка ассемблера.\n"
"Во - первых, нам нужны некоторые функции доступа, чтобы добраться до частей "
"инструкции:"

#: in/chapter23.md:1187
msgid ""
"```lisp\n"
"(defun opcode (instr) (if (label-p instr) :label (first instr)))\n"
"(defun args (instr) (if (listp instr) (rest instr)))\n"
"(defun arg1 (instr) (if (listp instr) (second instr)))\n"
"(defun arg2 (instr) (if (listp instr) (third instr)))\n"
"(defun arg3 (instr) (if (listp instr) (fourth instr)))"
msgstr ""

#: in/chapter23.md:1190
msgid ""
"(defsetf arg1 (instr) (val) `(setf (second ,instr) ,val))\n"
"```"
msgstr ""

#: in/chapter23.md:1192
msgid ""
"Now we write the assembler, which already is integrated into the compiler "
"with a hook in `new-fn`."
msgstr ""
"Теперь мы пишем ассемблер, который уже интегрирован в компилятор с хуком в "
"`new-fn`."

#: in/chapter23.md:1202
msgid ""
"```lisp\n"
"(defun assemble (fn)\n"
"  \"Turn a list of instructions into a vector.\"\n"
"  (multiple-value-bind (length labels)\n"
"      (asm-first-pass (fn-code fn))\n"
"    (setf (fn-code fn)\n"
"          (asm-second-pass (fn-code fn)\n"
"                           length labels))\n"
"    fn))"
msgstr ""

#: in/chapter23.md:1212
msgid ""
"(defun asm-first-pass (code)\n"
"  \"Return the labels and the total code length.\"\n"
"  (let ((length 0)\n"
"        (labels nil))\n"
"    (dolist (instr code)\n"
"      (if (label-p instr)\n"
"          (push (cons instr length) labels)\n"
"          (incf length)))\n"
"    (values length labels)))"
msgstr ""

#: in/chapter23.md:1226
msgid ""
"(defun asm-second-pass (code length labels)\n"
"  \"Put code into code-vector, adjusting for labels.\"\n"
"  (let ((addr 0)\n"
"        (code-vector (make-array length)))\n"
"    (dolist (instr code)\n"
"      (unless (label-p instr)\n"
"        (if (is instr '(JUMP TJUMP FJUMP SAVE))\n"
"            (setf (arg1 instr)\n"
"                  (cdr (assoc (arg1 instr) labels))))\n"
"        (setf (aref code-vector addr) instr)\n"
"        (incf addr)))\n"
"    code-vector))\n"
"```"
msgstr ""

#: in/chapter23.md:1228
msgid ""
"If we want to be able to look at assembled code, we need a new printing "
"function:"
msgstr ""
"Если мы хотим иметь возможность смотреть на ассемблерный код, нам нужна "
"новая функция печати:"

#: in/chapter23.md:1248
msgid ""
"```lisp\n"
"(defun show-fn (fn &optional (stream *standard-output*) (indent 2))\n"
"  \"Print all the instructions in a function.\n"
"  If the argument is not a function, just princ it,\n"
"  but in a column at least 8 spaces wide.\"\n"
"  ;; This version handles code that has been assembled into a vector\n"
"  (if (not (fn-p fn))\n"
"      (format stream \"~8a\" fn)\n"
"      (progn\n"
"        (fresh-line)\n"
"        (dotimes (i (length (fn-code fn)))\n"
"          (let ((instr (elt (fn-code fn) i)))\n"
"            (if (label-p instr)\n"
"                (format stream \"~a:\" instr)\n"
"                (progn\n"
"                  (format stream \"~VT~2d: \" indent i)\n"
"                  (dolist (arg instr)\n"
"                    (show-fn arg stream (+ indent 8)))\n"
"                  (fresh-line))))))))"
msgstr ""

#: in/chapter23.md:1250
msgid "(defstruct ret-addr fn pc env)"
msgstr ""

#: in/chapter23.md:1256
msgid ""
"(defun is (instr op)\n"
"  \"True if instr's opcode is OP, or one of OP when OP is a list.\"\n"
"  (if (listp op)\n"
"      (member (opcode instr) op)\n"
"      (eq (opcode instr) op)))"
msgstr ""

#: in/chapter23.md:1258
msgid "(defun top (stack) (first stack))"
msgstr ""

#: in/chapter23.md:1271
msgid ""
"(defun machine (f)\n"
"  \"Run the abstract machine on the code for f.\"\n"
"  (let* ((code (fn-code f))\n"
"         (pc 0)\n"
"         (env nil)\n"
"         (stack nil)\n"
"         (n-args 0)\n"
"         (instr nil))\n"
"    (loop\n"
"       (setf instr (elt code pc))\n"
"       (incf pc)\n"
"       (case (opcode instr)"
msgstr ""

#: in/chapter23.md:1281
msgid ""
"         ;; Variable/stack manipulation instructions:\n"
"         (LVAR   (push (elt (elt env (arg1 instr)) (arg2 instr))\n"
"                       stack))\n"
"         (LSET   (setf (elt (elt env (arg1 instr)) (arg2 instr))\n"
"                       (top stack)))\n"
"         (GVAR   (push (get (arg1 instr) 'global-val) stack))\n"
"         (GSET   (setf (get (arg1 instr) 'global-val) (top stack)))\n"
"         (POP    (pop stack))\n"
"         (CONST  (push (arg1 instr) stack))"
msgstr ""

#: in/chapter23.md:1286
msgid ""
"         ;; Branching instructions:\n"
"         (JUMP   (setf pc (arg1 instr)))\n"
"         (FJUMP  (if (null (pop stack)) (setf pc (arg1 instr))))\n"
"         (TJUMP  (if (pop stack) (setf pc (arg1 instr))))"
msgstr ""

#: in/chapter23.md:1327
msgid ""
"         ;; Function call/return instructions:\n"
"         (SAVE   (push (make-ret-addr :pc (arg1 instr)\n"
"                                      :fn f :env env)\n"
"                       stack))\n"
"         (RETURN ;; return value is top of stack; ret-addr is second\n"
"          (setf f (ret-addr-fn (second stack))\n"
"                code (fn-code f)\n"
"                env (ret-addr-env (second stack))\n"
"                pc (ret-addr-pc (second stack)))\n"
"          ;; Get rid of the ret-addr, but keep the value\n"
"          (setf stack (cons (first stack) (rest2 stack))))\n"
"         (CALLJ  (pop env)                 ; discard the top frame\n"
"                 (setf f  (pop stack)\n"
"                       code (fn-code f)\n"
"                       env (fn-env f)\n"
"                       pc 0\n"
"                       n-args (arg1 instr)))\n"
"         (ARGS   (assert (= n-args (arg1 instr)) ()\n"
"                         \"Wrong number of arguments:~\n"
"                         ~d expected, ~d supplied\"\n"
"                         (arg1 instr) n-args)\n"
"                 (push (make-array (arg1 instr)) env)\n"
"                 (loop for i from (- n-args 1) downto 0 do\n"
"                       (setf (elt (first env) i) (pop stack))))\n"
"         (ARGS.  (assert (>= n-args (arg1 instr)) ()\n"
"                         \"Wrong number of arguments:~\n"
"                         ~d or more expected, ~d supplied\"\n"
"                         (arg1 instr) n-args)\n"
"                 (push (make-array (+ 1 (arg1 instr))) env)\n"
"                 (loop repeat (- n-args (arg1 instr)) do\n"
"                       (push (pop stack) (elt (first env) (arg1 instr))))\n"
"                 (loop for i from (- (arg1 instr) 1) downto 0 do\n"
"                       (setf (elt (first env) i) (pop stack))))\n"
"         (FN     (push (make-fn :code (fn-code (arg1 instr))\n"
"                                :env env) stack))\n"
"         (PRIM   (push (apply (arg1 instr)\n"
"                              (loop with args = nil repeat n-args\n"
"                                    do (push (pop stack) args)\n"
"                                    finally (return args)))\n"
"                       stack))"
msgstr ""

#: in/chapter23.md:1335
msgid ""
"         ;; Continuation instructions:\n"
"         (SET-CC (setf stack (top stack)))\n"
"         (CC     (push (make-fn\n"
"                         :env (list (vector stack))\n"
"                         :code '((ARGS 1) (LVAR 1 0 \";\" stack) (SET-CC)\n"
"                                 (LVAR 0 0) (RETURN)))\n"
"                       stack))"
msgstr ""

#: in/chapter23.md:1339
msgid ""
"         ;; Nullary operations:\n"
"         ((SCHEME-READ NEWLINE) ; *** fix, gat, 11/9/92\n"
"          (push (funcall (opcode instr)) stack))"
msgstr ""

#: in/chapter23.md:1343
msgid ""
"         ;; Unary operations:\n"
"         ((CAR CDR CADR NOT LIST1 COMPILER DISPLAY WRITE RANDOM)\n"
"          (push (funcall (opcode instr) (pop stack)) stack))"
msgstr ""

#: in/chapter23.md:1349
msgid ""
"         ;; Binary operations:\n"
"         ((+ - * / < > <= >= /= = CONS LIST2 NAME! EQ EQUAL EQL)\n"
"          (setf stack (cons (funcall (opcode instr) (second stack)\n"
"                                     (first stack))\n"
"                            (rest2 stack))))"
msgstr ""

#: in/chapter23.md:1355
msgid ""
"         ;; Ternary operations:\n"
"         (LIST3\n"
"          (setf stack (cons (funcall (opcode instr) (third stack)\n"
"                                     (second stack) (first stack))\n"
"                            (rest3 stack))))"
msgstr ""

#: in/chapter23.md:1359
msgid ""
"         ;; Constants:\n"
"         ((T NIL -1 0 1 2)\n"
"          (push (opcode instr) stack))"
msgstr ""

#: in/chapter23.md:1363
msgid ""
"         ;; Other:\n"
"         ((HALT) (RETURN (top stack)))\n"
"         (otherwise (error \"Unknown opcode: ~a\" instr))))))"
msgstr ""

#: in/chapter23.md:1378
msgid ""
"(defun init-scheme-comp ()\n"
"  \"Initialize values (including call/cc) for the Scheme compiler.\"\n"
"  (set-global-var! 'exit\n"
"    (new-fn :name 'exit :args '(val) :code '((HALT))))\n"
"  (set-global-var! 'call/cc\n"
"    (new-fn :name 'call/cc :args '(f)\n"
"            :code '((ARGS 1) (CC) (LVAR 0 0 \";\" f)\n"
"            (CALLJ 1)))) ; *** Bug fix, gat, 11/9/92\n"
"  (dolist (prim *primitive-fns*)\n"
"     (setf (get (prim-symbol prim) 'global-val)\n"
"           (new-fn :env nil :name (prim-symbol prim)\n"
"                   :code (seq (gen 'PRIM (prim-symbol prim))\n"
"                              (gen 'RETURN))))))\n"
"```"
msgstr ""

#: in/chapter23.md:1382
msgid ""
"Here's the Scheme top level.\n"
"Note that it is written in Scheme itself; we compile the definition of the "
"read-eval-print loop,[1](#fn0010) load it into the machine, and then start "
"executing it.\n"
"There's also an interface to compile and execute a single expression, `comp-"
"go`."
msgstr ""
"Вот верхний уровень Scheme.\n"
"Обратите внимание, что он написан на самой Scheme; мы компилируем "
"определение цикла read-eval-print, [1](#fn0010) загружаем его в машину, а "
"затем начинаем выполнять.\n"
"Существует также интерфейс для компиляции и выполнения единичного выражения "
"`comp-go`."

#: in/chapter23.md:1391
msgid ""
"```lisp\n"
"(defconstant scheme-top-level\n"
"  '(begin (define (scheme)\n"
"            (newline)\n"
"            (display \"=> \")\n"
"            (write ((compiler (read))))\n"
"            (scheme))\n"
"          (scheme)))"
msgstr ""

#: in/chapter23.md:1396
msgid ""
"(defun scheme ()\n"
"  \"A compiled Scheme read-eval-print loop\"\n"
"  (init-scheme-comp)\n"
"  (machine (compiler scheme-top-level)))"
msgstr ""

#: in/chapter23.md:1401
msgid ""
"(defun comp-go (exp)\n"
"  \"Compile and execute the expression.\"\n"
"  (machine (compiler `(exit ,exp))))\n"
"```"
msgstr ""

#: in/chapter23.md:1409
msgid ""
"**Exercise  23.2 [m]** This implementation of the machine is wasteful in its "
"representation of environments.\n"
"For example, consider what happens in a tail-recursive function.\n"
"Each `ARG` instruction builds a new frame and pushes it on the environment.\n"
"Then each `CALL` pops the latest frame off the environment.\n"
"So, while the stack does not grow with tail-recursive calls, the heap "
"certainly does.\n"
"Eventually, we will have to garbage-collect all those unused frames (and the "
"cons cells used to make lists out of them).\n"
"How could we avoid or limit this garbage collection?"
msgstr ""
"**Exercise  23.2 [m]** Эта реализация машины расточительна в своем "
"представлении сред окружения.\n"
"Например, рассмотрим, что происходит в хвостово-рекурсивной функции.\n"
"Каждая инструкция `ARG` строит новый фрейм и помещает его в окружение.\n"
"Затем каждый `CALL` извлекает последний кадр из окружающей среды.\n"
"Таким образом, хотя стек не растет с хвостовыми рекурсивными вызовами, куча "
"определенно растет.\n"
"В конце концов, нам придется собрать(убрать мусор) все эти неиспользуемые "
"кадры (и ячейки cons, используемые для составления списков из них).\n"
"Как мы могли бы избежать или ограничить эту сборку мусора?"

#: in/chapter23.md:1411
msgid "## 23.4 A Peephole Optimizer"
msgstr "## 23.4 Подглядывающий(Peephole) Опримизатор "

#: in/chapter23.md:1414
msgid ""
"In this section we investigate a simple technique that will generate "
"slightly better code in cases where the compiler gives inefficient sequences "
"of instructions.\n"
"The idea is to look at short sequences of instructions for prespecified "
"patterns and replace them with equivalent but more efficient instructions."
msgstr ""
"В этом разделе мы исследуем простую технику, которая будет генерировать "
"немного лучший код в тех случаях, когда компилятор дает неэффективные "
"последовательности инструкций.\n"
"Идея состоит в том, чтобы посмотреть на короткие последовательности "
"инструкций для заранее определенных шаблонов и заменить их эквивалентными, "
"но более эффективными инструкциями."

#: in/chapter23.md:1416
msgid ""
"In the following example, `comp-if` has already done some source-level "
"optimization, such as eliminating the `(f x)` call."
msgstr ""
"В следующем примере `comp-if` уже произвел некоторую оптимизацию на уровне "
"исходного кода, например устранил вызов `(f x)`."

#: in/chapter23.md:1420
msgctxt "in/chapter23.md:1420"
msgid ""
"```\n"
"> (comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x))\n"
"```"
msgstr ""

#: in/chapter23.md:1431
msgid ""
"| []() |          |     |\n"
"|------|----------|-----|\n"
"| `0:` | `ARGS`   | `0` |\n"
"| 1:   | 1        |     |\n"
"| `2:` | `FJUMP`  | `6` |\n"
"| `3:` | `2`      |     |\n"
"| `4:` | `GSET`   | `X` |\n"
"| `5:` | `POP`    |     |\n"
"| `6:` | `GVAR`   | `X` |\n"
"| `7:` | `RETURN` |     |"
msgstr ""

#: in/chapter23.md:1437
msgid ""
"But the generated code could be made much better.\n"
"This could be done with more source-level optimizations to transform the "
"expression into `(set!\n"
"x 2)`.\n"
"Alternatively, it could also be done by looking at the preceding instruction "
"sequence and transforming local inefficiencies.\n"
"The optimizer presented in this section is capable of generating the "
"following code:"
msgstr ""
"Но сгенерированный код можно было бы сделать намного лучше.\n"
"Это можно было бы сделать с помощью дополнительных оптимизаций исходного "
"уровня для преобразования выражения в `(set! x 2)'.\n"
"В качестве альтернативы это можно было бы также сделать, рассмотрев "
"предыдущую последовательность инструкций и трансформировав локальные "
"неэффективности.\n"
"Оптимизатор, представленный в этом разделе, способен генерировать следующий "
"код:"

#: in/chapter23.md:1441
msgctxt "in/chapter23.md:1441"
msgid ""
"```\n"
"> (comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x))\n"
"```"
msgstr ""

#: in/chapter23.md:1448
msgid ""
"| []() |          |     |\n"
"|------|----------|-----|\n"
"| `0:` | `ARGS`   | `0` |\n"
"| 1:   | 2        |     |\n"
"| `2:` | `GSET`   | `X` |\n"
"| `3:` | `RETURN` |     |"
msgstr ""

#: in/chapter23.md:1452
msgid ""
"The function `optimize` is implemented as a data-driven function that looks "
"at the opcode of each instruction and makes optimizations based on the "
"following instructions.\n"
"To be more specific, `optimize` takes a list of assembly language "
"instructions and looks at each instruction in order, trying to apply an "
"optimization.\n"
"If any changes at all are made, then `optimize` will be called again on the "
"whole instruction list, because further changes might be triggered by the "
"first round of changes."
msgstr ""
"Функция `optimize` реализована как функция управляемая данными, которая "
"просматривает код операции каждой инструкции и производит оптимизацию на "
"основе последующих инструкций.\n"
"Чтобы быть более конкретным, `optimize` берет список инструкций языка "
"ассемблера и просматривает каждую инструкцию по порядку, пытаясь применить "
"оптимизацию.\n"
"Если какие-либо изменения вообще будут внесены, то `оптимизация` будет "
"вызвана снова во всем списке команд, потому что дальнейшие изменения могут "
"быть вызваны первым раундом изменений."

#: in/chapter23.md:1466
msgid ""
"```lisp\n"
"(defun optimize (code)\n"
"  \"Perform peephole optimization on assembly code.\"\n"
"  (let ((any-change nil))\n"
"    ;; Optimize each tail\n"
"    (loop for code-tail on code do\n"
"          (setf any-change (or (optimize-1 code-tail code)\n"
"                               any-change)))\n"
"    ;; If any changes were made, call optimize again\n"
"    (if any-change\n"
"        (optimize code)\n"
"        code)))\n"
"```"
msgstr ""

#: in/chapter23.md:1473
msgid ""
"The function `optimize-1` is responsible for each individual attempt to "
"optimize.\n"
"It is passed two arguments: a list of instructions starting at the current "
"one and going to the end of the list, and a list of all the instructions.\n"
"The second argument is rarely used.\n"
"The whole idea of a peephole optimizer is that it should look at only a few "
"instructions following the current one.\n"
"`optimize-1` is data-driven, based on the opcode of the first instruction.\n"
"Note that the optimizer functions do their work by destructively modifying "
"the instruction sequence, *not* by consing up and returning a new sequence."
msgstr ""
"Функция `optimize-1` отвечает за каждую отдельную попытку оптимизации.\n"
"Ей передаются два аргумента: список инструкций, начинающихся с текущей и "
"идущих до конца списка, и список всех инструкций.\n"
"Второй аргумент используется редко.\n"
"Вся идея подглядывающего(peephole) оптимизатора  состоит в том, что он "
"должен смотреть только на несколько инструкций, следующих за текущей.\n"
"`optimize-1` управляется данными, основанными на коде операции первой "
"инструкции.\n"
"Обратите внимание, что функции оптимизатора выполняют свою работу путем "
"деструктивного изменения последовательности команд, а не путем сохранения и "
"возврата новой последовательности."

#: in/chapter23.md:1484
msgid ""
"```lisp\n"
"(defun optimize-1 (code all-code)\n"
"  \"Perform peephole optimization on a tail of the assembly code.\n"
"  If a change is made, return true.\"\n"
"  ;; Data-driven by the opcode of the first instruction\n"
"  (let* ((instr (first code))\n"
"         (optimizer (get-optimizer (opcode instr))))\n"
"    (when optimizer\n"
"      (funcall optimizer instr code all-code))))\n"
"```"
msgstr ""

#: in/chapter23.md:1487
msgid ""
"We need a table to associate the individual optimizer functions with the "
"opcodes.\n"
"Since opcodes include numbers as well as symbols, an `eql` hash table is an "
"appropriate choice:"
msgstr ""
"Нам нужна таблица, чтобы связать отдельные функции оптимизатора с кодами "
"операций.\n"
"Поскольку коды операций включают в себя числа, а также символы, хэш-таблица "
"`eql` является подходящим выбором:"

#: in/chapter23.md:1490
msgid ""
"```lisp\n"
"(let ((optimizers (make-hash-table :test #'eql)))"
msgstr ""

#: in/chapter23.md:1494
msgid ""
"  (defun get-optimizer (opcode)\n"
"    \"Get the assembly language optimizer for this opcode.\"\n"
"    (gethash opcode optimizers))"
msgstr ""

#: in/chapter23.md:1499
msgid ""
"  (defun put-optimizer (opcode fn)\n"
"    \"Store an assembly language optimizer for this opcode.\"\n"
"    (setf (gethash opcode optimizers) fn)))\n"
"```"
msgstr ""

#: in/chapter23.md:1501
msgid ""
"We could now build a table with `put-optimizer`, but it is worth defining a "
"macro to make this a little neater:"
msgstr ""
"Теперь мы могли бы построить таблицу с помощью `put-optimizer`, но стоит "
"определить макрос, чтобы сделать это немного аккуратнее:"

#: in/chapter23.md:1509
msgid ""
"```lisp\n"
"(defmacro def-optimizer (opcodes args &body body)\n"
"  \"Define assembly language optimizers for these opcodes.\"\n"
"  (assert (and (listp opcodes) (listp args) (= (length args) 3)))\n"
"  `(dolist (op ',opcodes)\n"
"     (put-optimizer op #'(lambda ,args .,body))))\n"
"```"
msgstr ""

#: in/chapter23.md:1512
msgid ""
"Before showing example optimizer functions, we will introduce three "
"auxiliary functions.\n"
"`gen1` generates a single instruction, `target` finds the code sequence that "
"a jump instruction branches to, and `next-instr` finds the next actual "
"instruction in a sequence, skipping labels."
msgstr ""
"Прежде чем показать пример функции оптимизатора, мы представим три "
"вспомогательные функции.\n"
"`gen1` генерирует одну инструкцию, `target` находит кодовую "
"последовательность, к которой ветвится команда перехода, а `next-instr` "
"находит следующую фактическую инструкцию в последовательности, пропуская "
"метки."

#: in/chapter23.md:1518
msgid ""
"```lisp\n"
"(defun gen1 (&rest args) \"Generate a single instruction\" args)\n"
"(defun target (instr code) (second (member (arg1 instr) code)))\n"
"(defun next-instr (code) (find-if (complement #'label-p) code))\n"
"```"
msgstr ""

#: in/chapter23.md:1520
msgid ""
"Here are six optimizer functions that implement a few important peephole "
"optimizations."
msgstr ""
"Вот шесть функций оптимизатора, которые реализуют несколько важных "
"оптимизаций подглядывающего оптимизатора."

#: in/chapter23.md:1528
msgid ""
"```lisp\n"
"(def-optimizer (:LABEL) (instr code all-code)\n"
"  ;; ... L ... => ... ... ;if no reference to L\n"
"  (when (not (find instr all-code :key #'arg1))\n"
"    (setf (first code) (second code)\n"
"          (rest code) (rest2 code))\n"
"    t))"
msgstr ""

#: in/chapter23.md:1537
msgid ""
"(def-optimizer (GSET LSET) (instr code all-code)\n"
"  ;; ex: (begin (set! x y) (if x z))\n"
"  ;; (SET X) (POP) (VAR X) ==> (SET X)\n"
"  (when (and (is (second code) 'POP)\n"
"             (is (third code) '(GVAR LVAR))\n"
"             (eq (arg1 instr) (arg1 (third code))))\n"
"    (setf (rest code) (nthcdr 3 code))\n"
"    t))"
msgstr ""

#: in/chapter23.md:1546
msgid ""
"(def-optimizer (JUMP CALL CALLJ RETURN) (instr code all-code)\n"
"  ;; (JUMP L1) ...dead code... L2 ==> (JUMP L1) L2\n"
"  (setf (rest code) (member-if #'label-p (rest code)))\n"
"  ;; (JUMP L1) ... L1 (JUMP L2) ==> (JUMP L2)  ... L1 (JUMP L2)\n"
"  (when (and (is instr 'JUMP)\n"
"             (is (target instr code) '(JUMP RETURN))\n"
"    (setf (first code) (copy-list (target instr code)))\n"
"    t)))"
msgstr ""

#: in/chapter23.md:1552
msgid ""
"(def-optimizer (TJUMP FJUMP) (instr code all-code)\n"
"  ;; (FJUMP L1) ... L1 (JUMP L2) ==> (FJUMP L2) ... L1 (JUMP L2)\n"
"  (when (is (target instr code) 'JUMP)\n"
"    (setf (second instr) (arg1 (target instr code)))\n"
"    t))"
msgstr ""

#: in/chapter23.md:1566
msgid ""
"(def-optimizer (T -1 0 1 2) (instr code all-code)\n"
"  (case (opcode (second code))\n"
"    (NOT ;; (T) (NOT) ==> NIL\n"
"     (setf (first code) (gen1 'NIL)\n"
"           (rest code) (rest2 code))\n"
"     t)\n"
"    (FJUMP ;; (T) (FJUMP L) ... => ...\n"
"     (setf (first code) (third code)\n"
"           (rest code) (rest3 code))\n"
"     t)\n"
"    (TJUMP ;; (T) (TJUMP L) ... => (JUMP L) ...\n"
"     (setf (first code) (gen1 'JUMP (arg1 (next-instr code))))\n"
"     t)))"
msgstr ""

#: in/chapter23.md:1581
msgid ""
"(def-optimizer (NIL) (instr code all-code)\n"
"  (case (opcode (second code))\n"
"    (NOT ;; (NIL) (NOT) ==> T\n"
"     (setf (first code) (gen1 'T)\n"
"           (rest code) (rest2 code))\n"
"     t)\n"
"    (TJUMP ;; (NIL) (TJUMP L) ... => ...\n"
"     (setf (first code) (third code)\n"
"             (rest code) (rest3 code))\n"
"     t)\n"
"    (FJUMP ;; (NIL) (FJUMP L) ==> (JUMP L)\n"
"     (setf (first code) (gen1 'JUMP (arg1 (next-instr code))))\n"
"     t)))\n"
"```"
msgstr ""

#: in/chapter23.md:1583
msgid "## 23.5 Languages with Different Lexical Conventions"
msgstr "## 23.5 Языки с отличными лексическими соглашениями"

#: in/chapter23.md:1587
msgid ""
"This chapter has shown how to evaluate a language with Lisp-like syntax, by "
"writing a read-eval-print loop where only the `eval` needs to be replaced.\n"
"In this section we see how to make the `read` part slightly more general.\n"
"We still read Lisp-like syntax, but the lexical conventions can be slightly "
"different."
msgstr ""
"В этой главе показано, как вычислять язык с Лисп-подобным синтаксисом, "
"написав цикл read-eval-print, где нужно заменить только `eval`.\n"
"В этом разделе мы увидим, как сделать часть `read` немного более общей.\n"
"Мы все еще читаем Лисп-подобный синтаксис, но лексические соглашения могут "
"немного отличаться."

#: in/chapter23.md:1591
msgid ""
"The Lisp function `read` is driven by an object called the *readtable,* "
"which is stored in the special variable `*readtable*.` This table associates "
"some action to take with each of the possible characters that can be read.\n"
"The entry in the readtable for the character `#\\(`, for example, would be "
"directions to read a list.\n"
"The entry for `#\\;` would be directions to ignore every character up to the "
"end of the line."
msgstr ""
"Функция Lisp `read` управляется объектом, называемым *readtable*, который "
"хранится в специальной переменной `*readtable*.` Эта таблица связывает "
"некоторые действия с каждым из возможных символьных знаков, которые могут "
"быть прочитаны.\n"
"Например, запись в таблице чтения(readtable) для символа `#\\(`,  будет "
"содержать указания для чтения списка.\n"
"Запись для `#\\;` будет содержать указания игнорировать каждый символьный "
"знак до конца строки."

#: in/chapter23.md:1593
msgid ""
"Because the readtable is stored in a special variable, it is possible to "
"alter completely the way read works just by dynamically rebinding this "
"variable."
msgstr ""
"Поскольку readtable хранится в специальной переменной, можно полностью "
"изменить способ чтения, просто динамически повторно привязав эту переменную."

#: in/chapter23.md:1598
msgid ""
"The new function `scheme - read` temporarily changes the readtable to a new "
"one, the Scheme readtable.\n"
"It also accepts an optional argument, the stream to read from, and it "
"returns a special marker on end of file.\n"
"This can be tested for with the predicate `eof-object?`.\n"
"Note that once `scheme-read` is installed as the value of the Scheme `symbol-"
"read` we need do no more-`scheme-read` will always be called when "
"appropriate (by the top level of Scheme, and by any user Scheme program)."
msgstr ""
"Новая функция `scheme-read` временно изменяет таблицу чтения на новую, "
"Scheme readtable.\n"
"Она также принимает необязательный аргумент, поток для чтения, и возвращает "
"специальный маркер в конце файла.\n"
"Это можно проверить с помощью предиката `eof-object?`.\n"
"Обратите внимание, что после установки `scheme-read` в качестве  Scheme  "
"значения `symbol-read` нам больше ничего не нужно делать - `scheme-read` "
"всегда будет вызываться при необходимости (верхним уровнем Scheme и любой "
"пользовательской программой Scheme)."

#: in/chapter23.md:1603
msgid ""
"```lisp\n"
"(defconstant eof \"EoF\")\n"
"(defun eof-object? (x) (eq x eof))\n"
"(defvar *scheme-readtable* (copy-readtable))"
msgstr ""

#: in/chapter23.md:1608
msgid ""
"(defun scheme-read (&optional (stream *standard-input*))\n"
"  (let ((*readtable* *scheme-readtable*))\n"
"    (read stream nil eof)))\n"
"```"
msgstr ""

#: in/chapter23.md:1614
msgid ""
"The point of having a special `eof` constant is that it is unforgeable.\n"
"The user cannot type in a sequence of characters that will be read as "
"something `eq` to `eof`.\n"
"In Common Lisp, but not Scheme, there is an escape mechanism that makes "
"`eof` forgable.\n"
"The user can type `#.eof` to get the effect of an end of file.\n"
"This is similar to the `^D` convention in UNIX systems, and it can be quite "
"handy."
msgstr ""
"Смысл наличия специальной константы `eof` заключается в том, что она не "
"может быть использована.\n"
"Пользователь не может ввести последовательность знаков, которая будет "
"читаться как что-то от `eq` до `eof`.\n"
"В Common Lisp, но не в Scheme, есть escape механизм, который делает `eof` "
"поддающимся подделке.\n"
"Пользователь может ввести `#.eof`, чтобы получить эффект конца файла.\n"
"Это похоже на соглашение `^D` в системах UNIX, и это может быть довольно "
"удобно."

#: in/chapter23.md:1619
msgid ""
"So far the Scheme readtable is just a copy of the standard readtable.\n"
"The next step in implementing `scheme-read` is to alter `*scheme-"
"readtable*`, adding read macros for whatever characters are necessary.\n"
"Here we define macros for `#t` and `#f` (the true and false values), for "
"`#d` (decimal numbers) and for the backquote read macro (called quasiquote "
"in Scheme).\n"
"Note that the backquote and comma characters are defined as read macros, but "
"the `@` in ,`@` is processed by reading the next character, not by a read "
"macro on `@`."
msgstr ""
"До сих пор readtable  Scheme является просто копией стандартной readtable.\n"
"Следующим шагом в реализации `scheme-read` является изменение `*scheme-"
"readtable*`, добавление макросов чтения для любых необходимых символьных "
"знаков.\n"
"Здесь мы определяем макросы для `#t` и `#f` (истинных и ложных значений), "
"для `#d`(десятичные числа) и для обратной кавычки макроса чтения (так "
"называемый quasiquote в Scheme).\n"
"Обратите внимание, что знаки обратной кавычки и запятой определяются как "
"макросы чтения, но `@` в `,@` обрабатывается чтением следующего символьного "
"знака, а не макросом чтения для `@`"

#: in/chapter23.md:1624
msgid ""
"```lisp\n"
"(set-dispatch-macro-character #\\# #\\t\n"
"  #'(lambda (&rest ignore) t)\n"
"  *scheme-readtable*)"
msgstr ""

#: in/chapter23.md:1628
msgid ""
"(set-dispatch-macro-character #\\# #\\f\n"
"  #'(lambda (&rest ignore) nil)\n"
"  *scheme-readtable*)"
msgstr ""

#: in/chapter23.md:1637
msgid ""
"(set-dispatch-macro-character #\\# #\\d\n"
"  ;; In both Common Lisp and Scheme,\n"
"  ;; #x, #o and #b are hexidecimal, octal, and binary,\n"
"  ;; e.g. #xff = #o377 = #b11111111 = 255\n"
"  ;; In Scheme only, #d255 is decimal 255.\n"
"  #'(lambda (stream &rest ignore)\n"
"      (let ((*read-base* 10)) (scheme-read stream)))\n"
"  *scheme-readtable*)"
msgstr ""

#: in/chapter23.md:1641
msgid ""
"(set-macro-character #\\`\n"
"  #'(lambda (s ignore) (list 'quasiquote (scheme-read s)))\n"
"  nil *scheme-readtable*)"
msgstr ""

#: in/chapter23.md:1651
msgid ""
"(set-macro-character #\\,\n"
"   #'(lambda (stream ignore)\n"
"       (let ((ch (read-char stream)))\n"
"         (if (char= ch #\\@)\n"
"             (list 'unquote-splicing (read stream))\n"
"             (progn (unread-char ch stream)\n"
"                    (list 'unquote (read stream))))))\n"
"   nil *scheme-readtable*)\n"
"```"
msgstr ""

#: in/chapter23.md:1653
msgid "Finally, we install `scheme-read` and `eof-object?` as primitives:"
msgstr ""
"Наконец, мы устанавливаем  `scheme-read` и `eof-object?` как примитивы:"

#: in/chapter23.md:1667
msgid ""
"```lisp\n"
"(defparameter *primitive-fns*\n"
"  '((+ 2 + true) (- 2 - true) (* 2 * true) (/ 2 / true)\n"
"    (< 2 <) (> 2 >) (<= 2 <=) (>= 2 >=) (/= 2 /=) (= 2 =)\n"
"    (eq? 2 eq) (equal? 2 equal) (eqv? 2 eql)\n"
"    (not 1 not) (null? 1 not)\n"
"    (car 1 car) (cdr 1 cdr)  (cadr 1 cadr) (cons 2 cons true)\n"
"    (list 1 list1 true) (list 2 list2 true) (list 3 list3 true)\n"
"    (read 0 scheme-read nil t) (eof-object? 1 eof-object?) ;***\n"
"    (write 1 write nil t) (display 1 display nil t)\n"
"    (newline 0 newline nil t) (compiler 1 compiler t)\n"
"    (name! 2 name! true t) (random 1 random true nil)))\n"
"```"
msgstr ""

#: in/chapter23.md:1670
msgid ""
"Here we test `scheme-read`.\n"
"The characters in italics were typed as a response to the `scheme-read`."
msgstr ""
"Здесь мы тестируем `scheme-read`.\n"
"Знаки, выделенные курсивом, были напечатаны в ответ на `scheme-read`."

#: in/chapter23.md:1679
msgid ""
"```lisp\n"
"> (scheme-read) #*t*\n"
"T\n"
"> (scheme-read) #f\n"
"NIL\n"
"> (scheme-read) *'(a,b,@cd)*\n"
"(QUASIQUOTE (A (UNQUOTE B) (UNQUOTE-SPLICING C) D))\n"
"```"
msgstr ""

#: in/chapter23.md:1683
msgid ""
"The final step is to make quasi quote a macro that expands into the proper "
"sequence of calls to `cons`, `list`, and `append`.\n"
"The careful reader will keep track of the difference between the form "
"returned by `scheme-read` (something starting with `quasiquote`), the "
"expansion of this form with the Scheme macro `quasiquote` (which is "
"implemented with the Common Lisp function `quasi-q`), and the eventual "
"evaluation of the expansion.\n"
"In an environment where `b` is bound to the number 2 and `c` is bound to the "
"list `(c1 c2)`, we might have:"
msgstr ""
"Последний шаг состоит в том, чтобы сделать quasiquote макрокомандой, которая "
"расширяется в надлежащую последовательность вызовов `cons`, `list` и "
"`append`.\n"
"Внимательный читатель будет отслеживать разницу между формой, возвращаемой "
"`scheme-read` (нечто, начинающееся с `quasiquote`), расширением этой формы с "
"помощью макроса Scheme `quasiquote` (который реализуется с помощью функции "
"Common Lisp `quasi-q`) и окончательного вычисления расширения.\n"
"В среде, где `b` привязано к числу 2, а `c` привязано к списку `(c1 c2)`, мы "
"могли бы иметь:"

#: in/chapter23.md:1690
msgid ""
"| []()       |                                                       |\n"
"|------------|-------------------------------------------------------|\n"
"| Typed:     | `'(a ,b ,@c d)`                                       |\n"
"| Read:      | `(quasiquote (a (unquote b) (unquote-splicing c) d))` |\n"
"| Expanded:  | `(cons 'a (cons b (append c '(d))))`                  |\n"
"| Evaluated: | `(a 2 c1 c2 d)`                                       |"
msgstr ""

#: in/chapter23.md:1694
msgid ""
"The implementation of the `quasiquote` macro is modeled closely on the one "
"given in Charniak et al.'s *Artificial Intelligence Programming.* I added "
"support for vectors.\n"
"In `combine-quasiquote` I add the trick of reusing the old cons cell `x` "
"rather than consing together `left` and `right` when that is possible.\n"
"However, the implementation still wastes cons cells-a more efficient version "
"would pass back multiple values rather than consing `quote` onto a list, "
"only to strip it off again."
msgstr ""
"Реализация макроса `quasiquote` очень похожа на макрокоманду, приведенную в "
"книге Charniak et al.'s `Программирование искусственного интеллекта`. Я "
"добавил поддержку векторов.\n"
"В `comb-quasiquote` я добавляю трюк с повторным использованием старой cons-"
"ячейки `x` вместо создания ячейки списка(cons) для `left` и `right`, когда "
"это возможно.\n"
"Однако реализация по-прежнему тратит впустую cons-ячейки - более эффективная "
"версия будет передавать обратно несколько значений, а не использовать "
"`quote` в списке, только чтобы затем снова удалить его."

#: in/chapter23.md:1697
msgid ""
"```lisp\n"
"(setf (scheme-macro 'quasiquote) 'quasi-q)"
msgstr ""

#: in/chapter23.md:1718
msgid ""
"(defun quasi-q (x)\n"
"  \"Expand a quasiquote form into append, list, and cons calls.\"\n"
"  (cond\n"
"    ((vectorp x)\n"
"     (list 'apply 'vector (quasi-q (coerce x 'list))))\n"
"    ((atom x)\n"
"     (if (constantp x) x (list 'quote x)))\n"
"    ((starts-with x 'unquote)\n"
"     (assert (and (rest x) (null (rest2 x))))\n"
"     (second x))\n"
"    ((starts-with x 'quasiquote)\n"
"     (assert (and (rest x) (null (rest2 x))))\n"
"     (quasi-q (quasi-q (second x))))\n"
"    ((starts-with (first x) 'unquote-splicing)\n"
"     (if (null (rest x))\n"
"         (second (first x))\n"
"         (list 'append (second (first x)) (quasi-q (rest x)))))\n"
"    (t (combine-quasiquote (quasi-q (car x))\n"
"                           (quasi-q (cdr x))\n"
"                           x))))"
msgstr ""

#: in/chapter23.md:1731
msgid ""
"(defun combine-quasiquote (left right x)\n"
"  \"Combine left and right (car and cdr), possibly re-using x.\"\n"
"  (cond ((and (constantp left) (constantp right))\n"
"         (if (and (eql (eval left) (first x))\n"
"                  (eql (eval right) (rest x)))\n"
"             (list 'quote x)\n"
"             (list 'quote (cons (eval left) (eval right)))))\n"
"        ((null right) (list 'list left))\n"
"        ((starts-with right 'list)\n"
"         (list* 'list left (rest right)))\n"
"        (t (list 'cons left right))))\n"
"```"
msgstr ""

#: in/chapter23.md:1734
msgid ""
"Actually, there is a major problem with the `quasiquote` macro, or more "
"accurately, in the entire approach to macro-expansion based on textual "
"substitution.\n"
"Suppose we wanted a function that acted like this:"
msgstr ""
"На самом деле, есть большая проблема с макросом `quasiquote`, или, точнее, "
"во всем подходе к макрорасширению, основанному на текстовой подстановке.\n"
"Предположим, нам нужна функция, которая работала бы так:"

#: in/chapter23.md:1739
msgid ""
"```lisp\n"
"(extrema '(3 1 10 5 20 2))\n"
"((max 20) (min 1))\n"
"```"
msgstr ""

#: in/chapter23.md:1741
msgid "We could write the Scheme function:"
msgstr "Мы могли бы написать функцию Scheme:"

#: in/chapter23.md:1745
msgid ""
"```lisp\n"
"(define (extrema list)\n"
"```"
msgstr ""

#: in/chapter23.md:1748
msgid ""
"`      ;; Given a list of numbers.\n"
"return an a-list`"
msgstr ""

#: in/chapter23.md:1753
msgid ""
"```lisp\n"
"      ;; with max and min values\n"
"      '((max ,(apply max list)) (min ,(apply min list))))\n"
"```"
msgstr ""

#: in/chapter23.md:1755
msgid "After expansion of the quasiquote, the definition of `extrema` will be:"
msgstr "После расширения quasiquote определение `extrema` будет таким:"

#: in/chapter23.md:1762
msgid ""
"```lisp\n"
"(define extrema\n"
"      (lambda (list)\n"
"          (list (list 'max (apply max list))\n"
"                      (list 'min (apply min list)))))\n"
"```"
msgstr ""

#: in/chapter23.md:1769
msgid ""
"The problem is that `list` is an argument to the function `extrema`, and the "
"argument shadows the global definition of `list` as a function.\n"
"Thus, the function will fail.\n"
"One way around this dilemma is to have the macro-expansion use the global "
"value of `list` rather than the symbol `list` itself.\n"
"In other words, replace the `'list` in `quasi-q` with (`get-global-var "
"'list`).\n"
"Then the expansion can be used even in an environment where `list` is "
"locally bound.\n"
"One has to be careful, though: if this tack is taken, then `comp-funcall` "
"should be changed to recognize function constants, and to do the right thing "
"with respect to primitives."
msgstr ""
"Проблема в том, что `list` является аргументом функции `extrema`, и этот "
"аргумент затеняет глобальное определение `list` как функции.\n"
"Таким образом, функция выйдет из строя.\n"
"Один из способов обойти эту дилемму - сделать так, чтобы макрорасширение "
"использовало глобальное значение `list`, а не сам символ `list`.\n"
"Другими словами, замените `'list'` в `quasi-q` на (` get-global-var "
"'list`).\n"
"Тогда расширение можно использовать даже в среде, где `list` привязан "
"локально.\n"
"Однако следует быть осторожным: если будет предпринята эта тактика, то нужно "
"изменить `comp-funcall`, чтобы распознавать константы функций и делать "
"правильные вещи в отношении примитивов."

#: in/chapter23.md:1773
msgid ""
"It is problems like these that made the designers of Scheme admit that they "
"don't know the best way to specify macros, so there is no standard macro "
"definition mechanism in Scheme.\n"
"Such problems rarely come up in Common Lisp because functions and variables "
"have different name spaces, and because local function definitions (with "
"`flet` or `labels`) are not widely used.\n"
"Those who do define local functions tend not to use already established "
"names like `list` and `append.`"
msgstr ""
"Именно такие проблемы заставили разработчиков Scheme признать, что они не "
"знают, как лучше всего определять макросы, поэтому в Scheme нет стандартного "
"механизма определения макросов.\n"
"Такие проблемы редко возникают в Common Lisp, потому что функции и "
"переменные имеют разные пространства имен и потому что определения локальных "
"функций (с `flet` или` labels`) широко не используются.\n"
"Те, кто действительно определяет локальные функции, обычно не используют уже "
"установленные имена, такие как `list` и `append`."

#: in/chapter23.md:1775
msgid "## 23.6 History and References"
msgstr "## 23.6 История и Ссылки"

#: in/chapter23.md:1778
msgid ""
"Guy Steele's 1978 MIT master's thesis on the language Scheme, rewritten as "
"Steele 1983, describes an innovative and influential compiler for Scheme, "
"called RABBIT.\n"
"[2](#fn0015) A good article on an \"industrial-strength\" Scheme compiler "
"based on this approach is described in [Kranz et al.'s 1986]"
"(B9780080571157500285.xhtml#bb0675) paper on ORBIT, the compiler for the T "
"dialect of Scheme."
msgstr ""

#: in/chapter23.md:1782
msgid ""
"Abelson and Sussman's *Structure and Interpretation of Computer Programs* "
"(1985) contains an excellent chapter on compilation, using slightly "
"different techniques and compiling into a somewhat more confusing machine "
"language.\n"
"Another good text is [John Allen's *Anatomy of Lisp* (1978)]"
"(B9780080571157500285.xhtml#bb0040).\n"
"It presents a very clear, simple compiler, although it is for an older, "
"dynamically scoped dialect of Lisp and it does not address tail-recursion or "
"`call/cc`."
msgstr ""

#: in/chapter23.md:1784
msgid ""
"The peephole optimizer described here is based on the one in [Masinter and "
"Deutsch 1980](B9780080571157500285.xhtml#bb0780)."
msgstr ""

#: in/chapter23.md:1786
msgid "## 23.7 Exercises"
msgstr "## 23.7 Упражнения"

#: in/chapter23.md:1790
msgid ""
"**Exercise  23.3 [h]** Scheme's syntax for numbers is slightly different "
"from Common Lisp's.\n"
"In particular, complex numbers are written like `3+4i` rather than `#c(3 "
"4)`.\n"
"How could you make `scheme-read` account for this?"
msgstr ""

#: in/chapter23.md:1792
msgid ""
"**Exercise  23.4 [m]** Is it possible to make the core Scheme language even "
"smaller, by eliminating any of the five special forms `(quote, begin, set!, "
"if, lambda)` and replacing them with macros?"
msgstr ""

#: in/chapter23.md:1794
msgid ""
"**Exercise  23.5 [m]** Add the ability to recognize internal defines (see "
"[page 779](B9780080571157500224.xhtml#p779))."
msgstr ""

#: in/chapter23.md:1800
msgid ""
"**Exercise  23.6 [h]** In `comp-if` we included a special case for `(if t x "
"y)` and `(if nil x y)`.\n"
"But there are other cases where we know the value of the predicate.\n"
"For example, `(if (*a b) x y)` can also reduce to `x`.\n"
"Arrange for these optimizations to be made.\n"
"Note the `prim-always` field of the `prim structure` has been provided for "
"this purpose."
msgstr ""

#: in/chapter23.md:1802
msgid ""
"**Exercise  23.7 [m]** Consider the following version of the quicksort "
"algorithm for sorting a vector:"
msgstr ""

#: in/chapter23.md:1813
msgid ""
"```lisp\n"
"(define (sort-vector vector test)\n"
"      (define (sort lo hi)\n"
"              (if (>= lo hi)\n"
"                        vector\n"
"                        (let ((pivot (partition vector lo hi test)))\n"
"                                (sort lo pivot)\n"
"                        (sort (+ pivot 1) hi))))\n"
"      (sort 0 (- (vector-length vector 1))))\n"
"```"
msgstr ""

#: in/chapter23.md:1816
msgid ""
"Here the function `partition` takes a vector, two indices into the vector, "
"and a comparison function, `test`.\n"
"It modifies the vector and returns an index, `pivot`, such that all elements "
"of the vector below `pivot` are less than all elements at `pivot` or above."
msgstr ""

#: in/chapter23.md:1819
msgid ""
"It is well known that quicksort takes time proportional to *n* log *n* to "
"sort a vector of *n* elements, if the pivots are chosen well.\n"
"With poor pivot choices, it can take time proportional to *n*2."
msgstr ""

#: in/chapter23.md:1822
msgid ""
"The question is, what is the space required by quicksort?\n"
"Besides the vector itself, how much additional storage must be temporarily "
"allocated to sort a vector?"
msgstr ""

#: in/chapter23.md:1825
msgid ""
"Now consider the following modified version of quicksort.\n"
"What time and space complexity does it have?"
msgstr ""

#: in/chapter23.md:1839
msgid ""
"```lisp\n"
"(define (sort-vector vector test)\n"
"      (define (sort lo hi)\n"
"          (if (>= lo hi)\n"
"                  vector\n"
"                  (let ((pivot (partition vector lo hi)))\n"
"                        (if (> (- hi pivot) (- pivot lo))\n"
"                                  (begin (sort lo pivot)\n"
"                                                      (sort (+ pivot 1) "
"hi))\n"
"                                  (begin (sort (+ pivot 1) hi)\n"
"                                                      (sort lo pivot))))))\n"
"      (sort 0 (- (vector-length vector 1))))\n"
"```"
msgstr ""

#: in/chapter23.md:1841
msgid ""
"The next three exercises describe extensions that are not part of the Scheme "
"standard."
msgstr ""

#: in/chapter23.md:1849
msgid ""
"**Exercise  23.8 [h]** The set!\n"
"special form is defined only when its first argument is a symbol.\n"
"Extend `set!` to work like `setf` when the first argument is a list.\n"
"That is, `(set!\n"
"(car x) y)` should expand into something like `((setter car) y x)`, where "
"`(setter car)` evaluates to the primitive procedure `set-car!`.\n"
"You will need to add some new primitive functions, and you should also "
"provide a way for the user to define new `set!` procedures.\n"
"One way to do that would be with a `setter` function for `set!`, for example:"
msgstr ""

#: in/chapter23.md:1852
msgid ""
"`(set!\n"
"(setter third)`"
msgstr ""

#: in/chapter23.md:1855
msgid ""
"`            (lambda (val list) (set-car!\n"
"(cdr (cdr list)) val)))`"
msgstr ""

#: in/chapter23.md:1858
msgid ""
"**Exercise  23.9 [m]** It is a curious asymmetry of Scheme that there is a "
"special notation for lambda expressions within `define` expressions, but not "
"within `let`.\n"
"Thus, we see the following:"
msgstr ""

#: in/chapter23.md:1860
msgid "`(define square (lambda (x) (* x x)))`*;is the same as*"
msgstr ""

#: in/chapter23.md:1864
msgid ""
"```lisp\n"
"(define (square x) (* x x))\n"
"```"
msgstr ""

#: in/chapter23.md:1866
msgid "`(let ((square (lambda (x) (* x x)))) ...) ;`*is not the same as*"
msgstr ""

#: in/chapter23.md:1868
msgid ""
"`(let (((square x) (* x x))) ...) ;`*                          <= illegal!*"
msgstr ""

#: in/chapter23.md:1872
msgid ""
"Do you think this last expression should be legal?\n"
"If so, modify the macros for `let, let*`, and `letrec` to allow the new "
"syntax.\n"
"If not, explain why it should not be included in the language."
msgstr ""

#: in/chapter23.md:1881
msgid ""
"**Exercise  23.10 [m]** Scheme does not define `funcall`, because the normal "
"function-call syntax does the work of funcall.\n"
"This suggests two problems.\n"
"(1) Is it possible to define `funcall` in Scheme?\n"
"Show a definition or explain why there can't be one.\n"
"Would you ever have reason to use `funcall` in a Scheme program?\n"
"(2) Scheme does define `apply`, as there is no syntax for an application.\n"
"One might want to extend the syntax to make `(+ . numbers)` equivalent to "
"`(apply + numbers)`.\n"
"Would this bea good idea?"
msgstr ""

#: in/chapter23.md:1885
msgid ""
"**Exercise  23.11 [d]** Write a compiler that translates Scheme to Common "
"Lisp.\n"
"This will involve changing the names of some procedures and special forms, "
"figuring out a way to map Scheme's single name space into Common Lisp's "
"distinct function and variable name spaces, and dealing with Scheme's "
"continuations.\n"
"One possibility is to translate a `call/cc` into a `catch` and `throw`, and "
"disallow dynamic continuations."
msgstr ""

#: in/chapter23.md:1887
msgid "## 23.8 Answers"
msgstr "## 23.8 Ответы"

#: in/chapter23.md:1895
msgid ""
"**Answer 23.2** We can save frames by making a resource for frames, as was "
"done on page 337.\n"
"Unfortunately, we can't just use the def resource macro as is, because we "
"need a separate resource for each size frame.\n"
"Thus, a two-dimensional array or a vector of vectors is necessary.\n"
"Furthermore, one must be careful in determining when a frame is no longer "
"needed, and when it has been saved and may be used again.\n"
"Some compilers will generate a special calling sequence for a tail-recursive "
"call where the environment can be used as is, without discarding and then "
"creating a new frame for the arguments.\n"
"Some compilers have varied and advanced representations for environments.\n"
"An environment may never be represented explicitly as a list of frames; "
"instead it may be represented implicitly as a series of values in registers."
msgstr ""

#: in/chapter23.md:1898
msgid ""
"**Answer 23.3** We could read in Scheme expressions as before, and then "
"convert any symbols that looked like complex numbers into numbers.\n"
"The following routines do this without consing."
msgstr ""

#: in/chapter23.md:1903
msgid ""
"```lisp\n"
"(defun scheme-read (&optional (stream *standard-input*))\n"
"  (let ((*readtable* *scheme-readtable*))\n"
"    (convert-numbers (read stream nil eof))))"
msgstr ""

#: in/chapter23.md:1916
msgid ""
"(defun convert-numbers (x)\n"
"  \"Replace symbols that look like Scheme numbers with their values.\"\n"
"  ;; Don't copy structure, make changes in place.\n"
"  (typecase x\n"
"    (cons   (setf (car x) (convert-numbers (car x)))\n"
"            (setf (cdr x) (convert-numbers (cdr x)))\n"
"        x) ; *** Bug fix, gat, 11/9/92\n"
"    (symbol (or (convert-number x) x))\n"
"    (vector (dotimes (i (length x))\n"
"              (setf (aref x i) (convert-numbers (aref x i))))\n"
"        x) ; *** Bug fix, gat, 11/9/92\n"
"    (t x)))"
msgstr ""

#: in/chapter23.md:1927
msgid ""
"(defun convert-number (symbol)\n"
"  \"If str looks like a complex number, return the number.\"\n"
"  (let* ((str (symbol-name symbol))\n"
"         (pos (position-if #'sign-p str))\n"
"         (end (- (length str) 1)))\n"
"    (when (and pos (char-equal (char str end) #\\i))\n"
"      (let ((re (read-from-string str nil nil :start 0 :end pos))\n"
"            (im (read-from-string str nil nil :start pos :end end)))\n"
"        (when (and (numberp re) (numberp im))\n"
"          (complex re im))))))"
msgstr ""

#: in/chapter23.md:1930
msgid ""
"(defun sign-p (char) (find char \"+-\"))\n"
"```"
msgstr ""

#: in/chapter23.md:1935
msgid ""
"Actually, that's not quite good enough, because a Scheme complex number can "
"have multiple signs in it, as in `3.\n"
"4e- 5+6.\n"
"7e+8i`, and it need not have two numbers, as in `3i` or `4+i` or just `+  "
"i`.\n"
"The other problem is that complex numbers can only have a lowercase `i`, but "
"read does not distinguish between the symbols `3+4i` and `3+4I`."
msgstr ""

#: in/chapter23.md:1937
msgid "**Answer 23.4** Yes, it is possible to implement `begin` as a macro:"
msgstr ""

#: in/chapter23.md:1942
msgid ""
"```lisp\n"
"(setf (scheme-macro 'begin)\n"
"                #'(lambda (&rest exps) '((lambda () .,exps))))\n"
"```"
msgstr ""

#: in/chapter23.md:1947
msgid ""
"With some work we could also eliminate quote.\n"
"Instead of `'x`, we could use `(string->symbol \"X\" )`, and instead of `'(1 "
"2)`, wecoulduse something like `(list 1 2)`.\n"
"The problem is in knowing when to reuse the same list.\n"
"Consider:"
msgstr ""

#: in/chapter23.md:1952
msgid ""
"```lisp\n"
"=> (define (one-two) '(1 2))\n"
"ONE-TWO\n"
"```"
msgstr ""

#: in/chapter23.md:1955
msgid ""
"`=> (eq?\n"
"(one-two) (one-two))`"
msgstr ""

#: in/chapter23.md:1959
msgid ""
"```lisp\n"
"T\n"
"```"
msgstr ""

#: in/chapter23.md:1962
msgid ""
"`=> (eq?\n"
"'(1 2) '(1 2))`"
msgstr ""

#: in/chapter23.md:1966
msgid ""
"```lisp\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter23.md:1969
msgid ""
"A clever memoized macro for quote could handle this, but it would be less "
"efficient than having `quote` as a special form.\n"
"In short, what's the point?"
msgstr ""

#: in/chapter23.md:1972
msgid ""
"It is also (nearly) possible to replace `if` with alternate code.\n"
"The idea is to replace:"
msgstr ""

#: in/chapter23.md:1974
msgid "`(if`*test then-part else-part*)"
msgstr ""

#: in/chapter23.md:1976
msgid "with"
msgstr ""

#: in/chapter23.md:1978
msgid "(*test*`(delay`*then-part*) `(delay`*else-part*))"
msgstr ""

#: in/chapter23.md:1980
msgid ""
"Now if we are assured that any *test* returns either `#t` or `#f`, then we "
"can make the following definitions:"
msgstr ""

#: in/chapter23.md:1985
msgid ""
"```lisp\n"
"(define #t (lambda (then-part else-part) (force then-part)))\n"
"(define #f (lambda (then-part else-part) (force else-part)))\n"
"```"
msgstr ""

#: in/chapter23.md:1987
msgid ""
"The only problem with this is that any value, not just `#t`, counts as true."
msgstr ""

#: in/chapter23.md:1992
msgid ""
"This seems to be a common phenomenon in Scheme compilers: translating "
"everything into a few very general constructs, and then recognizing special "
"cases of these constructs and compiling them specially.\n"
"This has the disadvantage (compared to explicit use of many special forms) "
"that compilation may be slower, because all macros have to be expanded "
"first, and then special cases have to be recognized.\n"
"It has the advantage that the optimizations will be applied even when the "
"user did not have a special construct in mind.\n"
"Common Lisp attempts to get the advantages of both by allowing "
"implementations to play loose with what they implement as macros and as "
"special forms."
msgstr ""

#: in/chapter23.md:1994
msgid ""
"**Answer 23.6** We define the predicate `always` and install it in two "
"places in `comp-if` :"
msgstr ""

#: in/chapter23.md:2009
msgid ""
"```lisp\n"
"(defun always (pred env)\n"
"      \"Does predicate always evaluate to true or false?\"\n"
"      (cond ((eq pred t) 'true)\n"
"                        ((eq pred nil) 'false)\n"
"                        ((symbolp pred) nil)\n"
"                        ((atom pred) 'true)\n"
"                        ((scheme-macro (first pred))\n"
"                          (always (scheme-macro-expand pred) env))\n"
"                        ((case (first pred)\n"
"                                (QUOTE (if (null (second pred)) 'false "
"'true))\n"
"                                (BEGIN (if (null (rest pred)) 'false\n"
"                                                                    (always "
"(last1 pred) env)))\n"
"```"
msgstr ""

#: in/chapter23.md:2012
msgid ""
"`                                (SET!\n"
"(always (third pred) env))`"
msgstr ""

#: in/chapter23.md:2025
msgid ""
"```lisp\n"
"        (IF (let ((test (always (second pred)) env)\n"
"            (then (always (third pred)) env)\n"
"            (else (always (fourth pred)) env))\n"
"                                (cond ((eq test 'true) then)\n"
"                                                                    ((eq "
"test 'false) else)\n"
"                                                                    ((eq "
"then else) then))))\n"
"        (LAMBDA 'true)\n"
"        (t (let ((prim (primitive-p (first pred) env\n"
"                                              (length (rest pred)))))\n"
"                      (if prim (prim-always prim))))))))\n"
"```"
msgstr ""

#: in/chapter23.md:2028
msgid ""
"`(defun comp-if (pred then else env val?\n"
"more?)`"
msgstr ""

#: in/chapter23.md:2033
msgid ""
"```lisp\n"
"      (case (always pred env)\n"
"          (true ; (if nil x y) = => y ; ***\n"
"```"
msgstr ""

#: in/chapter23.md:2036
msgid ""
"`              (comp then env val?\n"
"more?)) ; ***`"
msgstr ""

#: in/chapter23.md:2040
msgid ""
"```lisp\n"
"          (false ; (if t x y) = => x ; ***\n"
"```"
msgstr ""

#: in/chapter23.md:2043
msgid ""
"`              (comp else env val?\n"
"more?)) ; ***`"
msgstr ""

#: in/chapter23.md:2048
msgid ""
"```lisp\n"
"          (otherwise\n"
"              (let ((pcode (comp pred env t t))\n"
"```"
msgstr ""

#: in/chapter23.md:2051
msgid ""
"`                            (tcode (comp then env val?\n"
"more?))`"
msgstr ""

#: in/chapter23.md:2054
msgid ""
"`                            (ecode (comp else env val?\n"
"more?)))`"
msgstr ""

#: in/chapter23.md:2063
msgid ""
"```lisp\n"
"              (cond\n"
"                  ((and (listp pred) ; (if (not p) x y) ==> (if p y x)\n"
"                                    (length=1 (rest pred))\n"
"                                    (primitive-p (first pred) env 1)\n"
"                                    (eq (prim-opcode (primitive-p (first "
"pred) env 1))\n"
"                                                  'not))\n"
"```"
msgstr ""

#: in/chapter23.md:2066
msgid ""
"`                  (comp-if (second pred) else then env val?\n"
"more?))`"
msgstr ""

#: in/chapter23.md:2074
msgid ""
"```lisp\n"
"                ((equal tcode ecode) ; (if p x x) ==> (begin p x)\n"
"                  (seq (comp pred env nil t) ecode))\n"
"                ((null tcode) ; (if p nil y) ==> p (TJUMP L2) y L2:\n"
"                  (let ((L2 (gen-label)))\n"
"                          (seq pcode (gen 'TJUMP L2) ecode (list L2)\n"
"```"
msgstr ""

#: in/chapter23.md:2077
msgid ""
"`                  (unless more?\n"
"(gen 'RETURN)))))`"
msgstr ""

#: in/chapter23.md:2083
msgid ""
"```lisp\n"
"            ((null ecode) ; (if p x) ==> p (FJUMP L1) x L1:\n"
"            (let ((L1 (gen-label)))\n"
"                    (seq pcode (gen TJUMP L1) tcode (list L1)\n"
"```"
msgstr ""

#: in/chapter23.md:2086
msgid ""
"`                                  (unless more?\n"
"(gen 'RETURN)))))`"
msgstr ""

#: in/chapter23.md:2092
msgid ""
"```lisp\n"
"            (t                                                             ; "
"(if p x y) ==> p (FJUMP L1) x L1: y\n"
"                                                                              ; "
"or p (FJUMP L1) x (JUMP L2) L1: y L2:\n"
"            (let ((L1 (gen-label))\n"
"```"
msgstr ""

#: in/chapter23.md:2095
msgid ""
"`                          (L2 (if more?\n"
"(gen-label))))`"
msgstr ""

#: in/chapter23.md:2099
msgid ""
"```lisp\n"
"                (seq pcode (gen 'FJUMP L1) tcode\n"
"```"
msgstr ""

#: in/chapter23.md:2102
msgid ""
"`                              (if more?\n"
"(gen 'JUMP L2))`"
msgstr ""

#: in/chapter23.md:2105
msgid ""
"`                              (list L1) ecode (if more?\n"
"(list L2))))))))))`"
msgstr ""

#: in/chapter23.md:2111
msgid ""
"Development note: originally, I had coded `always` as a predicate that took "
"a Boolean value as input and returned true if the expression always had that "
"value.\n"
"Thus, you had to ask first if the predicate was always true, and then if it "
"was always false.\n"
"Then I realized this was duplicating much effort, and that the duplication "
"was exponential, not just linear: for a triply-nested conditional I would "
"have to do eight times the work, not twice the work.\n"
"Thus I switched to the above formulation, where `always` is a three-valued "
"function, returning `true`, `false`, or `nil` for none-of-the-above.\n"
"But to demonstrate that the right solution doesn't always appear the first "
"time, I give my original definition as well:"
msgstr ""

#: in/chapter23.md:2122
msgid ""
"```lisp\n"
"(defun always (boolean pred env)\n"
"      \"Does predicate always evaluate to boolean in env?\"\n"
"      (if (atom pred)\n"
"          (and (constantp pred) (equiv boolean pred))\n"
"          (case (first pred)\n"
"                (QUOTE (equiv boolean pred))\n"
"                (BEGIN (if (null (rest pred)) (equiv boolean nil)\n"
"                                                    (always boolean (last1 "
"pred) env)))\n"
"```"
msgstr ""

#: in/chapter23.md:2125
msgid ""
"`                (SET!\n"
"(always boolean (third pred) env))`"
msgstr ""

#: in/chapter23.md:2141
msgid ""
"```lisp\n"
"                (IF (or (and (always t (second pred) env)\n"
"                                                      (always boolean (third "
"pred) env))\n"
"                                          (and (always nil (second pred) "
"env)\n"
"                                                      (always boolean "
"(fourth pred) env))\n"
"                                          (and (always boolean (third pred) "
"env)\n"
"                                                      (always boolean "
"(fourth pred) env))))\n"
"                (LAMBDA (equiv boolean t))\n"
"                (t (let ((prim (primitive-p (first pred) env\n"
"                                                                                          (length "
"(rest pred)))))\n"
"                        (and prim\n"
"                                        (eq (prim-always prim)\n"
"                                                    (if boolean 'true "
"'false))))))))\n"
"(defun equiv (x y) \"Boolean equivalence\" (eq (not x) (not y)))\n"
"```"
msgstr ""

#: in/chapter23.md:2144
msgid ""
"**Answer 23.7** The original version requires *O*(*n*) stack space for "
"poorly chosen pivots.\n"
"Assuming a properly tail-recursive compiler, the modified version will never "
"require more than *O*(log *n*) space, because at each step at least half of "
"the vector is being sorted tail-recursively."
msgstr ""

#: in/chapter23.md:2149
msgid ""
"**Answer 23.10** (1) `(defun (funcall fn . args) (apply fn args))` (2) "
"Suppose you changed the piece of code `(+ . numbers)` to `(+ . (map sqrt "
"numbers))`.\n"
"The latter is the same expression as (+ `map sqrt numbers),` which is not "
"the intended resuit at all.\n"
"So there would be an arbitrary restriction: the last argument in an apply "
"form would have to be an atom.\n"
"This kind of restriction goes against the grain of Scheme."
msgstr ""

#: in/chapter23.md:2151
msgid "----------------------"
msgstr ""

#: in/chapter23.md:2154
msgid ""
"[1](#xfn0010) Strictly speaking, this is a read-compile-funcall-write loop.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter23.md:2159
msgid ""
"[2](#xfn0015) At the time, the MacLisp compiler dealt with something called "
"\"lisp assembly code\" or LAP.\n"
"The function to input LAP was called `lapin`.\n"
"Those who know French will get the pun.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
