#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter7.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-01-11 20:55+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter7.md:3
msgid ""
"# Chapter 7\n"
"## STUDENT: Solving Algebra Word Problems"
msgstr ""
"# Глава 7\n"
"## STUDENT: Решение Алгебраических Задач"

#: in/chapter7.md:5
msgid ""
"> *[This] is an example par excellence* of the power of using meaning to "
"solve linguistic problems"
msgstr ""
"> *[Это] превосходный пример* демонстрирующий силу использования "
"значений(meaning) для решения лингвистических проблем."

#: in/chapter7.md:7
msgid "> -[Marvin Minsky (1968)](B9780080571157500285.xhtml#bb0845)"
msgstr ""

#: in/chapter7.md:9
msgid "> MIT computer scientist"
msgstr ""

#: in/chapter7.md:14
msgid ""
"STUDENT was another early language understanding program, written by Daniel "
"Bobrow as his Ph.D.\n"
"research project in 1964.\n"
"It was designed to read and solve the kind of word problems found in high "
"school algebra books.\n"
"An example is:"
msgstr ""
"STUDENT еще одна ранняя программа понимания языка, написанная Дэниелом "
"Боброу в качестве исследовательского проекта на степень доктора философии "
"1964 г.\n"
"Она была разработана для чтения и решения задач со словами, которые можно "
"найти в школьных учебниках по алгебре.\n"
"Пример:"

#: in/chapter7.md:16
msgid ""
"> If the number of customers Tom gets is twice the square of 20% of the "
"number of advertisements he runs, and the number of advertisements is 45, "
"then what is the number of customers Tom gets?"
msgstr ""
"> If the number of customers Tom gets is twice the square of 20% of the "
"number of advertisements he runs, and the number of advertisements is 45, "
"then what is the number of customers Tom gets?\n"
"(Если количество клиентов, которых получает Том, вдвое больше квадрата 20% "
"от количества рекламных объявлений, которые он запускает, а количество "
"рекламных объявлений равно 45, то какое количество клиентов получает Том?)"

#: in/chapter7.md:22
msgid ""
"STUDENT could correctly reply that the number of customers is 162.\n"
"To do this, STUDENT must be far more sophisticated than ELIZA; it must "
"process and \"understand\" a great deal of the input, rather than just "
"concentrate on a few key words.\n"
"And it must compute a response, rather than just fill in blanks.\n"
"However, we shall see that the STUDENT program uses little more than the "
"pattern-matching techniques of ELIZA to translate the input into a set of "
"algebraic equations.\n"
"From there, it must know enough algebra to solve the equations, but that is "
"not very difficult."
msgstr ""
"STUDENT правильно ответит, что клиентов 162.\n"
"Для этого STUDENT должен быть гораздо более искушеннее, чем ELIZA; он должен "
"обрабатывать и \"понимать\" большую часть вводимой информации, а не просто "
"концентрироваться на нескольких ключевых словах.\n"
"И он должен вычислять ответ, а не просто заполнять пробелы.\n"
"Однако мы увидим, что программа STUDENT использует немногим больше, чем "
"методы сопоставления с образцом ELIZA для преобразования входных данных в "
"набор алгебраических уравнений.\n"
"Поэтому он должен знать достаточно алгебры, чтобы решать уравнения, но она "
"не очень сложная."

#: in/chapter7.md:25
msgid ""
"The version of STUDENT we develop here is nearly a full implementation of "
"the original.\n"
"However, remember that while the original was state-of-the-art as of 1964, "
"AI has made some progress in a quarter century, as subsequent chapters will "
"attempt to show."
msgstr ""
"Разрабатываемая нами версия STUDENT является почти полной реализацией "
"оригинала.\n"
"Однако помните, что хотя оригинал был последним по состоянию на 1964 год, ИИ "
"добился определенного прогресса за четверть века, как это будет показано в "
"последующих главах."

#: in/chapter7.md:27
msgid "## 7.1 Translating English into Equations"
msgstr "## 7.1 Преобразование Английского в Уравнения"

#: in/chapter7.md:29
msgid "The description of STUDENT is:"
msgstr "Описание STUDENT такое:"

#: in/chapter7.md:32
msgid ""
"1.  Break the input into phrases that will represent equations.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Разбейте ввод на фразы, которые будут представлять собой уравнения.\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:35
msgid ""
"2.  Break each phrase into a pair of phrases on either side of the  =  "
"sign.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Разбейте каждую фразу на пару фраз по обе стороны от знака =\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:39
msgid ""
"3.  Break these phrases down further into sums and products, and so on, "
"until finally we bottom out with numbers and variables.\n"
"(By \"variable\" here, I mean \"mathematical variable,\" which is distinct "
"from the idea of a \"pattern-matching variable\" as used in `pat-match` in "
"[chapter 6](B9780080571157500066.xhtml)).\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Далее разбейте эти фразы на суммы и произведения и так далее, пока, "
"наконец, мы не дойдем до конца с числами и переменными.\n"
"(Под \"переменной\" здесь я имею в виду \"математическую переменную\", "
"которая отличается от идеи \"переменной используемой при сопоставлении с "
"образцом\", используемой в `pat-match` в [главе 6](B9780080571157500066."
"xhtml)).\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:43
msgid ""
"4.  Translate each English phrase into a mathematical expression.\n"
"We use the idea of a rule-based translator as developed for ELIZA.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Преобразуйте каждую английскую фразу в математическое выражение.\n"
"Мы используем идею преобразователя на основе правил, разработанного для "
"ELIZA.\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:46
msgid ""
"5.  Solve the resulting mathematical equations, coming up with a value for "
"each unknown variable.\n"
"!!!(p) {:.numlist}"
msgstr ""
"5.  Решите полученные математические уравнения, найдя значение для каждой "
"неизвестной переменной.\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:49
msgid ""
"6.  Print the values of all the variables.\n"
"!!!(p) {:.numlist}"
msgstr ""
"6.  Выведите значения всех переменных.\n"
"!!!(p) {:.numlist}"

#: in/chapter7.md:56
msgid ""
"For example, we might have a pattern of the form (`If ?x then ?y`), with an "
"associated response that says that `?x` and `?y` will each be equations or "
"lists of equations.\n"
"Applying the pattern to the input above, `?y` would have the value (`what is "
"the number of customers Tomgets`).\n"
"Another pattern of the form (`?x is ?y`) could have a response corresponding "
"to an equation where `?x` and `?y` are the two sides of the equation.\n"
"We could then make up a mathematical variable for (`what`) and another for "
"(`the number of customers Tom gets`).\n"
"We would recognize this later phrase as a variable because there are no "
"patterns to break it down further.\n"
"In contrast, the phrase (`twice the square of 20 per cent of the number of "
"advertisements he runs`) could match a pattern of the form (`twice ?x`) and "
"transform to `(* 2 (the square of 20 per cent of the number of "
"advertisements he runs)),` and by further applying patterns of the form "
"(`the square of ?x`) and (`?x per cent of ?y`) we could arrive at a final "
"response of `(* 2 (expt (* (/ 20 100) n) 2))`, where `n` is the variable "
"generated by (`the number of advertisements he runs`)."
msgstr ""
"Например, у нас может быть образец формы (`If ?x then ?y`) с соответствующим "
"ответом, в котором говорится, что `?x` и `?y` будут уравнениями или списками "
"уравнений.\n"
"Применив сопоставление входных данных указанных выше с образцом, `?y` будет "
"иметь значение (`what is the number of customers Tomgets`/ сколько клиентов "
"Tomgets).\n"
"Другой образец формы (`?x is ?y`) мог бы иметь ответ, соответствующий "
"равенству, где  `?x` и `?y` - две стороны одного равенства.\n"
"Затем мы могли бы создать математическую переменную для (`what`) и другую "
"для (`the number of customers Tom gets`/количество клиентов, которых "
"получает Том).\n"
"Мы бы распознали эту более позднюю фразу как переменную, потому что нет "
"никаких образцов, которые позволили бы разбить её дальше.\n"
"Напротив, фраза (`twice the square of 20 per cent of the number of "
"advertisements he runs`/вдвое больше квадрата 20 процентов от количества "
"рекламных объявлений, которые он запускает) может соответствовать образцу "
"формы (`twice ?x`) и преобразовываться в `(* 2 (the square of 20 per cent of "
"the number of advertisements he runs))` и путем дальнейшего применения "
"образцов формы (`the square of ?x`) и (`?x per cent of ?y`) мы могли бы "
"прийти к окончательному ответу `(* 2 (expt (* (/ 20 100) n) 2))`, где `n` - "
"переменная, генерируемая (`the number of advertisements he runs`/количество "
"рекламных объявлений, которые он запускает)."

#: in/chapter7.md:65
msgid ""
"Thus, we need to represent variables, expressions, equations, and sets of "
"equations.\n"
"The easiest thing to do is to use something we know: represent them just as "
"Lisp itself does.\n"
"Variables will be symbols, expressions and equations will be nested lists "
"with prefix operators, and sets of equations will be lists of equations.\n"
"With that in mind, we can define a list of pattern-response rules "
"corresponding to the type of statements found in algebra word problems.\n"
"The structure definition for a rule is repeated here, and the structure "
"`exp`, an expression, is added.\n"
"`lhs` and `rhs` stand for left-and right-hand side, respectively.\n"
"Note that the constructor `mkexp` is defined as a constructor that builds "
"expressions without taking keyword arguments.\n"
"In general, the notation (`:constructor`*fn args*) creates a constructor "
"function with the given name and argument list.[1](#fn0015)"
msgstr ""
"Таким образом, нам нужно представить переменные, выражения, уравнения и "
"наборы уравнений.\n"
"Проще всего использовать то, что мы знаем: представить их так же, как это "
"делает сам Лисп.\n"
"Переменные будут символами, выражения и уравнения будут вложенными списками "
"с префиксными операторами, а наборы уравнений будут списками уравнений.\n"
"Имея это в виду, мы можем определить список правил `образец-ответ`, "
"соответствующих типам утверждений, встречающихся в описаниях задач алгебры.\n"
"Структура определений для правил повторется здесь, и добавляется структура  "
"выражений `exp`.\n"
"`lhs` и `rhs` обозначают левую и правую стороны, соответственно.\n"
"Обратите внимание, что конструктор `mkexp` определяется как конструктор, "
"который строит выражения без использования аргументов ключеввых слов.\n"
"Как правило, запись (`:constructor` *fn args*) создает функцию-конструктор с "
"заданным именем и списком аргументов. [1] (# fn0015)"

#: in/chapter7.md:68
msgid ""
"```lisp\n"
"(defstruct (rule (:type list)) pattern response)"
msgstr ""

#: in/chapter7.md:72
msgid ""
"(defstruct (exp (:type list)\n"
"                (:constructor mkexp (lhs op rhs)))\n"
"  op lhs rhs)"
msgstr ""

#: in/chapter7.md:76
msgid ""
"(defun exp-p (x) (consp x))\n"
"(defun exp-args (x) (rest x))\n"
"```"
msgstr ""

#: in/chapter7.md:80
msgid ""
"We ignored commas and periods in ELIZA, but they are crucial for STUDENT, so "
"we must make allowances for them.\n"
"The problem is that a `\",\"` in Lisp normally can be used only within a "
"backquote construction, and a `\".\"` normally can be used only as a decimal "
"point or in a dotted pair.\n"
"The special meaning of these characters to the Lisp reader can be escaped "
"either by preceding the character with a backslash (\\,) or by surrounding "
"the character by vertical bars (| , |)."
msgstr ""
"Мы проигнорировали запятые и точки в ELIZA, но они имеют решающее значение "
"для STUDENT, поэтому мы должны сделать поправку на них.\n"
"Проблема в том, что `\",\"` в Лиспе обычно можно использовать только в "
"конструкции обратных кавычек, а `\".\"` обычно можно использовать только как "
"десятичную точку или в точечной паре.\n"
"Специального значения этих символьных знаков для читателя(reader) Лиспа "
"можно избежать, поставив перед символьным знаком обратную косую черту (\\,) "
"или окружив знак вертикальными полосами (| , |)."

#: in/chapter7.md:84
msgid ""
"```lisp\n"
"(pat-match-abbrev '?x* '(?* ?x))\n"
"(pat-match-abbrev '?y* '(?* ?y))"
msgstr ""

#: in/chapter7.md:120
msgid ""
"(defparameter *student-rules* (mapcar #'expand-pat-match-abbrev\n"
"  '(((?x* |.|)                  ?x)\n"
"    ((?x* |.| ?y*)          (?x ?y))\n"
"    ((if ?x* |,| then ?y*)  (?x ?y))\n"
"    ((if ?x* then ?y*)      (?x ?y))\n"
"    ((if ?x* |,| ?y*)       (?x ?y))\n"
"    ((?x* |,| and ?y*)      (?x ?y))\n"
"    ((find ?x* and ?y*)     ((= to-find-1 ?x) (= to-find-2 ?y)))\n"
"    ((find ?x*)             (= to-find ?x))\n"
"    ((?x* equals ?y*)       (= ?x ?y))\n"
"    ((?x* same as ?y*)      (= ?x ?y))\n"
"    ((?x* = ?y*)            (= ?x ?y))\n"
"    ((?x* is equal to ?y*)  (= ?x ?y))\n"
"    ((?x* is ?y*)           (= ?x ?y))\n"
"    ((?x* - ?y*)            (- ?x ?y))\n"
"    ((?x* minus ?y*)        (- ?x ?y))\n"
"    ((difference between ?x* and ?y*)  (- ?y ?x))\n"
"    ((difference ?x* and ?y*)          (- ?y ?x))\n"
"    ((?x* + ?y*)            (+ ?x ?y))\n"
"    ((?x* plus ?y*)         (+ ?x ?y))\n"
"    ((sum ?x* and ?y*)      (+ ?x ?y))\n"
"    ((product ?x* and ?y*)  (* ?x ?y))\n"
"    ((?x* * ?y*)            (* ?x ?y))\n"
"    ((?x* times ?y*)        (* ?x ?y))\n"
"    ((?x* / ?y*)            (/ ?x ?y))\n"
"    ((?x* per ?y*)          (/ ?x ?y))\n"
"    ((?x* divided by ?y*)   (/ ?x ?y))\n"
"    ((half ?x*)             (/ ?x 2))\n"
"    ((one half ?x*)         (/ ?x 2))\n"
"    ((twice ?x*)            (* 2 ?x))\n"
"    ((square ?x*)           (* ?x ?x))\n"
"    ((?x* % less than ?y*)  (* ?y (/ (- 100 ?x) 100)))\n"
"    ((?x* % more than ?y*)  (* ?y (/ (+ 100 ?x) 100)))\n"
"    ((?x* % ?y*)            (* (/ ?x 100) ?y)))))\n"
"```"
msgstr ""

#: in/chapter7.md:125
msgid ""
"The main section of STUDENT will search through the list of rules for a "
"response, just as ELIZA did.\n"
"The first point of deviation is that before we substitute the values of the "
"`pat-match` variables into the response, we must first recursively translate "
"the value of each variable, using the same list of pattern-response rules.\n"
"The other difference is that once we're done, we don't just print the "
"response; instead we have to solve the set of equations and print the "
"answers.\n"
"The program is summarized in [figure 7.1](#f0010)."
msgstr ""
"Основной раздел STUDENTа будет искать по списку правил для ответа, как это "
"делала ELIZA.\n"
"Первое отклонение состоит в том, что перед тем, как мы подставим значения "
"переменных `pat-match` в ответ, мы должны сначала рекурсивно преобразовать "
"значение каждой переменной, используя тот же список правил образец-ответ.\n"
"Другое отличие состоит в том, что после того, как мы закончим, мы не просто "
"печатаем ответ; вместо этого мы должны решить систему уравнений и "
"распечатать ответы.\n"
"Краткое описание программы приведено на [рис. 7.1](#f0010)."

#: in/chapter7.md:130
msgid ""
"| []()                                         |\n"
"|----------------------------------------------|\n"
"| ![f07-01](images/chapter7/f07-01.jpg)        |\n"
"| Figure 7.1: Glossary for the STUDENT Program |"
msgstr ""
"| []()                                         |\n"
"|----------------------------------------------|\n"
"| ![f07-01](images/chapter7/f07-01.jpg)        |\n"
"| Figure 7.1: Словарь для программы STUDENT    |"

#: in/chapter7.md:132
msgid "(ed: this should be a markdown table)"
msgstr ""

#: in/chapter7.md:134
msgid ""
"Before looking carefully at the program, let's try a sample problem: \"If z "
"is 3, what is twice z?\" Applying the rules to the input gives the following "
"trace:"
msgstr ""
"Прежде чем внимательно взглянуть на программу, давайте попробуем рассмотреть "
"пример задачи: \"If z is 3, what is twice z?/Если z равно 3, сколько будет "
"дважды z?\" Применение правил к входу оставляет следующую трассу:"

#: in/chapter7.md:151
msgid ""
"```lisp\n"
"Input: (If z is 3, what is twice z)\n"
"Rule: ((if ?x |,| ?y)            (?x ?y))\n"
"Binding: ((?x . (z is 3)) (?y . (what is twice z)))\n"
"  Input: (z is 3)\n"
"  Rule: ((?x is ?y)                  (= ?x ?y))\n"
"  Result: (= z 3)\n"
"  Input: (what is twice z ?)\n"
"  Rule: ((?x is ?y)                  (= ?x ?y))\n"
"  Binding:((?x . what) (?y . (twice z)))\n"
"    Input: (twice z)\n"
"    Rule: ((twice ?x)                (* 2 ?x))\n"
"    Result: (* 2 z)\n"
"  Result: (= what (* 2 z))\n"
"Result: ((= z 3) (= what (* 2 z)))\n"
"```"
msgstr ""

#: in/chapter7.md:160
msgid ""
"There are two minor complications.\n"
"First, we agreed to implement sets of equations as lists of equations.\n"
"For this example, everything worked out, and the response was a list of two "
"equations.\n"
"But if nested patterns are used, the response could be something like `((= a "
"5) ((= b (+ a 1)) (= c (+ a b))))`, which is not a list of equations.\n"
"The function `create-list-of-equations` transforms a response like this into "
"a proper list of equations.\n"
"The other complication is choosing variable names.\n"
"Given a list of words like (`the number of customers Tom gets`), we want to "
"choose a symbol to represent it.\n"
"We will see below that the symbol `customers` is chosen, but that there are "
"other possibilities."
msgstr ""
"Есть две незначительных сложности.\n"
"Во-первых, мы договорились реализовать наборы уравнений в виде списков "
"уравнений.\n"
"В этом примере все сработало, и ответом был список из двух уравнений.\n"
"Но если используются вложенные образцы, ответ может быть чем-то вроде `((= a "
"5) ((= b (+ a 1)) (= c (+ a b))))`, который не является списком уравнений.\n"
"Функция `create-list-of-sizes` преобразует такой ответ в правильный список "
"уравнений.\n"
"Другая сложность - выбор имен переменных.\n"
"Имея список таких слов, как (`the number of customers Tom gets`/количество "
"клиентов, которых получает Том), мы хотим выбрать символ для их "
"представления.\n"
"Ниже мы увидим, что выбран символ `customers`/клиенты, но есть и другие "
"возможности."

#: in/chapter7.md:164
msgid ""
"Here is the main function for STUDENT.\n"
"It first removes words that have no content, then translates the input to "
"one big expression with `translate-to-expression`, and breaks that into "
"separate equations with `create-list-of-equations`.\n"
"Finally, the function `solve-equations` does the mathematics and prints the "
"solution."
msgstr ""
"Вот основная функция для STUDENT.\n"
"Сначала она удаляет слова, у которых нет содержимого, затем преобразует ввод "
"в одно большое выражение с помощью `translate-to-expression` и разбивает его "
"на отдельные уравнения с помощью `create-list-of-equations`.\n"
"Наконец, функция `solve-equations` выполняет математические вычисления и "
"выводит решение."

#: in/chapter7.md:171
msgid ""
"```lisp\n"
"(defun student (words)\n"
"  \"Solve certain Algebra Word Problems.\"\n"
"  (solve-equations\n"
"    (create-list-of-equations\n"
"      (translate-to-expression (remove-if #'noise-word-p words)))))"
msgstr ""

#: in/chapter7.md:173
msgid "```"
msgstr ""

#: in/chapter7.md:177
msgid ""
"The function `translate-to-expression` is a rule-based translator.\n"
"It either finds some rule in `*student-rules*` to transform the input, or it "
"assumes that the entire input represents a single variable.\n"
"The function `translate-pair` takes a variable/value binding pair and "
"translates the value by a recursive call to `translate-to-expression.`"
msgstr ""
"Функция `translate-to-expression` - это преобразователь на основе правил.\n"
"Он либо находит какое-то правило в `*student-rules*` для преобразования "
"ввода, либо предполагает, что весь ввод представляет собой единственную "
"переменную.\n"
"Функция `translate-pair` принимает пару привязки переменная/значение и "
"преобразует значение рекурсивным вызовом `translate-to-expression`."

#: in/chapter7.md:188
msgid ""
"```lisp\n"
"(defun translate-to-expression (words)\n"
"  \"Translate an English phrase into an equation or expression.\"\n"
"  (or (rule-based-translator\n"
"        words *student-rules*\n"
"        :rule-if #'rule-pattern :rule-then #'rule-response\n"
"        :action #'(lambda (bindings response)\n"
"                    (sublis (mapcar #'translate-pair bindings)\n"
"                              response)))\n"
"      (make-variable words)))"
msgstr ""

#: in/chapter7.md:194
msgid ""
"(defun translate-pair (pair)\n"
"  \"Translate the value part of the pair into an equation or expression.\"\n"
"  (cons (binding-var pair)\n"
"        (translate-to-expression (binding-val pair))))\n"
"```"
msgstr ""

#: in/chapter7.md:196
msgid ""
"The function `create-list-of-equations` takes a single expression containing "
"embedded equations and separates them into a list of equations:"
msgstr ""
"Функция `create-list-of-equations` принимает одно выражение, содержащее "
"встроенные уравнения(равенства), и разделяет их на список уравнений:"

#: in/chapter7.md:205
msgid ""
"```lisp\n"
"(defun create-list-of-equations (exp)\n"
"  \"Separate out equations embedded in nested parens.\"\n"
"  (cond ((null exp) nil)\n"
"        ((atom (first exp)) (list exp))\n"
"        (t (append (create-list-of-equations (first exp))\n"
"                   (create-list-of-equations (rest exp))))))\n"
"```"
msgstr ""

#: in/chapter7.md:213
msgid ""
"Finally, the function `make-variable` creates a variable to represent a list "
"of words.\n"
"We do that by first removing all \"noise words\" from the input, and then "
"taking the first symbol that remains.\n"
"So, for example, \"the distance John traveled\" and \"the distance traveled "
"by John\" will both be represented by the same variable, `distance,` which "
"is certainly the right thing to do.\n"
"However, \"the distance Mary traveled\" will also be represented by the same "
"variable, which is certainly a mistake.\n"
"For (`the number of customers Tom gets`), the variable will be `customers`, "
"since `the, of` and `number` are all noise words.\n"
"This will match (`the customers mentioned above`) and (`the number of "
"customers`), but not (`Tom's customers`).\n"
"For now, we will accept the first-non-noise-word solution, but note that "
"exercise 7.3 asks for a correction."
msgstr ""
"Наконец, функция `make-variable` создает переменную для представления списка "
"слов.\n"
"Мы делаем это, сначала удаляя все \"зашумляющие слова\" из ввода, а затем "
"беря первый оставшийся символ.\n"
"Так, например, \"the distance John traveled/расстояние, пройденное Джоном\" "
"и \"the distance traveled by John\", будут представлены одной и той же "
"переменной `distance`, что безусловно, является правильным решением.\n"
"Однако \"the distance Mary traveled\" также будет представлено той же "
"переменной, что, безусловно, является ошибкой.\n"
"Для ((`the number of customers Tom gets`/количество клиентов, которых "
"получает Том) переменной будет `customers`, так как `the`, `of` и `number` - "
"все это зашумляющие слова.\n"
"Она будет соответствовать (`the customers mentioned above`/клиенты, "
"упомянутые выше) и (`the number of customers`/количество клиентов`), но не "
"(`Tom's customers`/клиенты Тома).\n"
"На данный момент мы примем решение, первое не шумовое слово, но обратите "
"внимание, что в упражнении 7.3 требуется исправление."

#: in/chapter7.md:219
msgid ""
"```lisp\n"
"(defun make-variable (words)\n"
"  \"Create a variable name based on the given list of words\"\n"
"    ;; The list of words will already have noise words removed\n"
"  (first words))"
msgstr ""

#: in/chapter7.md:224
msgid ""
"(defun noise-word-p (word)\n"
"  \"Is this a low-content word which can be safely ignored?\"\n"
"  (member word '(a an the this number of $)))\n"
"```"
msgstr ""

#: in/chapter7.md:226
msgid "## 7.2 Solving Algebraic Equations"
msgstr "## 7.2 Решение Алгебраических Уравнений"

#: in/chapter7.md:229
msgid ""
"The next step is to write the equation-solving section of STUDENT.\n"
"This is more an exercise in elementary algebra than in AI, but it is a good "
"example of a symbol-manipulation task, and thus an interesting programming "
"problem."
msgstr ""
"Следующим шагом будет написание раздела решения уравнений для STUDENT.\n"
"Это больше упражнение по элементарной алгебре, чем по ИИ, но это хороший "
"пример задачи манипулирования символами и, следовательно, интересная "
"проблема программирования."

#: in/chapter7.md:232
msgid ""
"The STUDENT program mentioned the function `solve-equations`, passing it one "
"argument, a list of equations to be solved.\n"
"`solve-equations` prints the list of equations, attempts to solve them using "
"`solve`, and prints the result."
msgstr ""
"Программа STUDENT упоминала функцию `solve-equations` передав ей один "
"аргумент, список уравнений, которые необходимо решить.\n"
"`solve-equations` печатает список уравнений, пытаясь решить их с помощью "
"`solve` и печатает результат."

#: in/chapter7.md:239
msgid ""
"```lisp\n"
"(defun solve-equations (equations)\n"
"  \"Print the equations and their solution\"\n"
"  (print-equations \"The equations to be solved are:\" equations)\n"
"  (print-equations \"The solution is:\" (solve equations nil)))\n"
"```"
msgstr ""

#: in/chapter7.md:247
msgid ""
"The real work is done by solve, which has the following specification: (1) "
"Find an equation with exactly one occurrence of an unknown in it.\n"
"(2) Transform that equation so that the unknown is isolated on the left-hand "
"side.\n"
"This can be done if we limit the operators to  +, -, *,and /.\n"
"(3) Evaluate the arithmetic on the right-hand side, yielding a numeric value "
"for the unknown.\n"
"(4) Substitute the numeric value for the unknown in all the other equations, "
"and remember the known value.\n"
"Then try to solve the resulting set of equations.\n"
"(5) If step (1) fails-if there is no equation with exactly one unknown-then "
"just return the known values and don't try to solve anything else."
msgstr ""
"Настоящая работа выполняется методом solve, который имеет следующую "
"спецификацию: (1) Ищет уравнение, в котором ровно одно вхождение "
"неизвестного.\n"
"(2) Преобразует это уравнение так, чтобы неизвестное было изолировано в "
"левой части.\n"
"Это можно сделать, если мы ограничим возможные операторы +, -, * и /.\n"
"(3) Выполняет арифметические действия в правой части, получая числовое "
"значение для неизвестного.\n"
"(4) Подставляет числовое значение вместо неизвестного во все другие "
"уравнения и запоминает полученные значения.\n"
"Затем пробует решить получившуюся систему уравнений.\n"
"(5) Если шаг (1) завершился неудачно - если нет уравнения с точно одним "
"неизвестным - тогда просто возвращает известные значения и не пытайтется "
"решить что-либо еще.\n"

#: in/chapter7.md:255
msgid ""
"The function `solve` is passed a system of equations, along with a list of "
"known variable/value pairs.\n"
"Initially no variables are known, so this list will be empty.\n"
"`solve` goes through the list of equations searching for an equation with "
"exactly one unknown.\n"
"If it can find such an equation, it calls `isolate` to solve the equation in "
"terms of that one unknown.\n"
"`solve` then substitutes the value for the variable throughout the list of "
"equations and calls itself recursively on the resulting list.\n"
"Each time `solve` calls itself, it removes one equation from the list of "
"equations to be solved, and adds one to the list of known variable/value "
"pairs.\n"
"Since the list of equations is always growing shorter, `solve` must "
"eventually terminate."
msgstr ""
"В функцию `solve` передается система уравнений вместе со списком известных "
"пар переменная/значение.\n"
"Изначально переменные неизвестны, поэтому этот список будет пустым.\n"
"`solve` просматривает список уравнений в поисках уравнения с точно одним "
"неизвестным.\n"
"Если она может найти такое уравнение, она вызывает `isolate`, чтобы решить "
"уравнение в терминах этого неизвестного.\n"
"Затем `resolve` подставляет значение переменной по всему списку уравнений и "
"рекурсивно вызывает себя в результирующем списке.\n"
"Каждый раз, когда `resolve` вызывает себя, она удаляет одно уравнение из "
"списка уравнений, которые нужно решить, и добавляет одно в список известных "
"пар переменная/значение.\n"
"Поскольку список уравнений всегда становится короче, `solve` в конечном "
"итоге должно завершиться."

#: in/chapter7.md:272
msgid ""
"```lisp\n"
"(defun solve (equations known)\n"
"  \"Solve a system of equations by constraint propagation.\"\n"
"  ;; Try to solve for one equation, and substitute its value into\n"
"  ;; the others. If that doesn't work, return what is known.\n"
"  (or (some #'(lambda (equation)\n"
"                (let ((x (one-unknown equation)))\n"
"                  (when x\n"
"                    (let ((answer (solve-arithmetic\n"
"           (isolate equation x))))\n"
"                      (solve (subst (exp-rhs answer) (exp-lhs answer)\n"
"                                    (remove equation equations))\n"
"                             (cons answer known))))))\n"
"            equations)\n"
"      known))\n"
"```"
msgstr ""

#: in/chapter7.md:278
msgid ""
"`isolate` is passed an equation guaranteed to have one unknown.\n"
"It returns an equivalent equation with the unknown isolated on the left-hand "
"side.\n"
"There are five cases to consider: when the unknown is alone on the left, "
"we're done.\n"
"The second case is when the unknown is anywhere on the right-hand side.\n"
"Because '=' is commutative, we can reduce the problem to solving the "
"equivalent equation with left- and right-hand sides reversed."
msgstr ""
"`isolate` передается уравнение, которое гарантированно содержит одно "
"неизвестное.\n"
"Она возвращает эквивалентное уравнение с неизвестным, изолированным в левой "
"части.\n"
"Следует рассмотреть пять случаев: когда неизвестное остается только слева, "
"все готово.\n"
"Второй случай - когда неизвестное находится где-нибудь с правой стороны.\n"
"Поскольку '=' коммутативно, мы можем свести проблему к решению "
"эквивалентного уравнения переставленными левой и правой частями."

#: in/chapter7.md:282
msgid ""
"Next we have to deal with the case where the unknown is in a complex "
"expression on the left-hand side.\n"
"Because we are allowing four operators and the unknown can be either on the "
"right or the left, there are eight possibilities.\n"
"Letting X stand for an expression containing the unknown and A and B stand "
"for expressions with no unknowns, the possibilities and their solutions are "
"as follows:"
msgstr ""
"Далее мы должны иметь дело со случаем, когда неизвестное находится в сложном "
"выражении в левой части.\n"
"Поскольку мы допускаем четыре оператора, а неизвестное может быть справа или "
"слева, существует восемь возможностей.\n"
"Если X обозначает выражение, содержащее неизвестное, а A и B обозначают "
"выражения без неизвестных, то возможны их следующие решения:"

#: in/chapter7.md:289
msgid ""
"| []()                   |                        |\n"
"|------------------------|------------------------|\n"
"| (1) `X*A=B` => `X=B/A` | (5) `A*X=B` => `X=B/A` |\n"
"| (2) `X+A=B` => `X=B-A` | (6) `A+X=B` => `X=B-A` |\n"
"| (3) `X/A=B` => `X=B*A` | (7) `A/X=B` => `X=A/B` |\n"
"| (4) `X-A=B` => `X=B+A` | (8) `A-X=B` => `X=A-B` |"
msgstr ""

#: in/chapter7.md:294
msgid ""
"Possibilities (1) through (4) are handled by case III, (5) and (6) by case "
"IV, and (7) and (8) by case V.\n"
"In each case, the transformation does not give us the final answer, since X "
"need not be the unknown; it might be a complex expression involving the "
"unknown.\n"
"So we have to call isolate again on the resulting equation.\n"
"The reader should try to verify that transformations (1) to (8) are valid, "
"and that cases III to V implement them properly."
msgstr ""
"Возможности (1) - (4) обрабатываются случаем III, (5) и (6) случаем IV, и "
"(7) и (8) случаем V.\n"
"В каждом случае преобразование не дает нам окончательного ответа, поскольку "
"X не обязательно должно быть неизвестным; это могло быть сложное выражение, "
"связанное с неизвестным.\n"
"Итак, мы должны снова вызвать isolate c полученным уравнением.\n"
"Читатель должен попытаться проверить, что преобразования (1) - (8) "
"действительны, и что случаи с III по V реализуют их правильно."

#: in/chapter7.md:324
msgid ""
"```lisp\n"
"(defun isolate (e x)\n"
"  \"Isolate the lone x in e on the left hand side of e.\"\n"
"  ;; This assumes there is exactly one x in e,\n"
"  ;; and that e is an equation.\n"
"  (cond ((eq (exp-lhs e) x)\n"
"         ;; Case I: X = A -> X = n\n"
"         e)\n"
"        ((in-exp x (exp-rhs e))\n"
"         ;; Case II: A = f(X) -> f(X) = A\n"
"         (isolate (mkexp (exp-rhs e) '= (exp-lhs e)) x))\n"
"        ((in-exp x (exp-lhs (exp-lhs e)))\n"
"         ;; Case III: f(X)*A = B -> f(X) = B/A\n"
"         (isolate (mkexp (exp-lhs (exp-lhs e)) '=\n"
"                         (mkexp (exp-rhs e)\n"
"                                (inverse-op (exp-op (exp-lhs e)))\n"
"                                (exp-rhs (exp-lhs e)))) x))\n"
"        ((commutative-p (exp-op (exp-lhs e)))\n"
"         ;; Case IV: A*f(X) = B -> f(X) = B/A\n"
"         (isolate (mkexp (exp-rhs (exp-lhs e)) '=\n"
"                         (mkexp (exp-rhs e)\n"
"                                (inverse-op (exp-op (exp-lhs e)))\n"
"                                (exp-lhs (exp-lhs e)))) x))\n"
"        (t ;; Case V: A/f(X) = B -> f(X) = A/B\n"
"         (isolate (mkexp (exp-rhs (exp-lhs e)) '=\n"
"                         (mkexp (exp-lhs (exp-lhs e))\n"
"                                (exp-op (exp-lhs e))\n"
"                                (exp-rhs e))) x))))\n"
"```"
msgstr ""

#: in/chapter7.md:331
msgid ""
"Recall that to prove a function is correct, we have to prove both that it "
"gives the correct answer when it terminates and that it will eventually "
"terminate.\n"
"For a recursive function with several alternative cases, we must show that "
"each alternative is valid, and also that each alternative gets closer to the "
"end in some way (that any recursive calls involve 'simpler' arguments).\n"
"For `isolate`, elementary algebra will show that each step is valid-or at "
"least *nearly* valid.\n"
"Dividing both sides of an equation by 0 does not yield an equivalent "
"equation, and we never checked for that.\n"
"It's also possible that similar errors could sneak in during the call to "
"`eval`.\n"
"However, if we assume the equation does have a single valid solution, then "
"`isolate` performs only legal transformations."
msgstr ""
"Напомним, чтобы доказать правильность функции, мы должны доказать, что она "
"то что она в конечном итоге завершается и дает правильный ответ.\n"
"Для рекурсивной функции с несколькими альтернативными случаями мы должны "
"показать, что каждая альтернатива действительна, а также что, каждая "
"альтернатива каким-то образом приближается к концу (что любые рекурсивные "
"вызовы включают 'более простые' аргументы).\n"
"Для `isolate`, элементарная алгебра показывает, что каждый шаг верен, или по "
"крайней мере, почти верен.\n"
"Деление обоих частей уравнения на 0 не дает эквивалентного уравнения и мы "
"никогда не проверяли этого.\n"
"Также возможно, что подобные ошибки могут возникнуть во время вызова "
"`eval`.\n"
"Однако, мы предположим, что уравнение имеет единственное допустимое решение, "
"тогда `isolate` выполняет только законные преобразования."

#: in/chapter7.md:337
msgid ""
"The hard part is to prove that `isolate` terminates.\n"
"Case I clearly terminates, and the others all contribute towards isolating "
"the unknown on the left-hand side.\n"
"For any equation, the sequence will be first a possible use of case II, "
"followed by a number of recursive calls using cases III to V.\n"
"The number of calls is bounded by the number of subexpressions in the "
"equation, since each successive call effectively removes an expression from "
"the left and places it on the right.\n"
"Therefore, assuming the input is of finite size, we must eventually reach a "
"recursive call to `isolate` that will use case I and terminate."
msgstr ""
"Труднее всего доказать, что `isolate` завершается.\n"
"Случай I явно завершается, и все остальные вносят свой вклад в изоляцию "
"неизвестного расположенного с левой стороны.\n"
"Для любого уравнения, последовательность(sequence) будет первым из возможных "
"вариантов использования случая II, за которым последует ряд рекурсивных "
"вызовов использующих случаи от III до V.\n"
"Количество вызовов ограничено числом подвыражений в уравнении, поскольку "
"каждый последующий вызов эффективно удаляет выражение слева и помещает его "
"справа.\n"
"Следовательно, предполагая, что вход имеет конечный размер, мы должны в "
"конечном итоге достичь рекуривного вызова для `isolate`, который будет "
"использовать случай I и завершаться."

#: in/chapter7.md:345
msgid ""
"When `isolate` returns, the right-hand side must consist only of numbers and "
"operators.\n"
"We could easily write a function to evaluate such an expression.\n"
"However, we don't have to go to that effort, since the function already "
"exists.\n"
"The data structure exp was carefully selected to be the same structure "
"(lists with prefix functions) used by Lisp itself for its own expressions.\n"
"So Lisp will find the right-hand side to be an acceptable expression, one "
"that could be evaluated if typed in to the top level.\n"
"Lisp evaluates expressions by calling the function `eval`, so we can call "
"`eval` directly and have it return a number.\n"
"The function `solve-arithmetic` returns an equation of the form (=  *var "
"number*)."
msgstr ""
"Когда `isolate` возвращается, правая часть должна состоять только из чисел и "
"операторов.\n"
"Мы могли бы легко написать функцию для вычисления такого выражения.\n"
"Однако нам не нужно прилагать таких усилий, поскольку функция уже "
"существует.\n"
"Структура данных exp была тщательно выбрана, чтобы быть той же структурой "
"(списками с префиксными функциям), какую использует и сам Lisp для своих "
"собственных выражений.\n"
"Таким образом, Lisp обнаружит, что правая часть является приемлемым "
"выражением, которое может быть вычислено, если ввести его на верхнем "
"уровне.\n"
"Lisp вычисляет выражения, вызывая функцию `eval`, поэтому мы можем вызывать "
"`eval` напрямую и получить возвращаемое из неё число.\n"
"Функция `solve-arithmetic` возвращает уравнение вида (=  *var number*)."

#: in/chapter7.md:351
msgid ""
"Auxiliary functions for `solve` are shown below.\n"
"Most are straightforward, but I will remark on a few of them.\n"
"The function `prefix->infix` takes an expression in prefix notation and "
"converts it to a fully parenthesized infix expression.\n"
"Unlike `isolate`, it assumes the expressions will be implemented as lists.\n"
"`prefix->infix` is used by `print-equations` to produce more readable output."
msgstr ""
"Вспомогательные функции для `solve` показаны ниже.\n"
"Большинство из них просты, но я отмечу некоторые из них.\n"
"Функция `prefix->infix` принимает выражение в префиксной нотации и "
"преобразует его в инфиксное выражение, полностью заключенное в скобки.\n"
"В отличии от `isolate`, она предполагает, что выражения будут реализованы в "
"виде списков.\n"
"`prefix->infix` используется в `print-equations` для создания более "
"читабельного вывода."

#: in/chapter7.md:357
msgid ""
"```lisp\n"
"(defun print-equations (header equations)\n"
"  \"Print a list of equations.\"\n"
"  (format t \"~%~a~{~%  ~{ ~a~}~}~%\" header\n"
"          (mapcar #'prefix->infix equations)))"
msgstr ""

#: in/chapter7.md:360
msgid ""
"(defconstant operators-and-inverses\n"
"  '((+ -) (- +) (* /) (/ *) (= =)))"
msgstr ""

#: in/chapter7.md:363
msgid ""
"(defun inverse-op (op)\n"
"  (second (assoc op operators-and-inverses)))"
msgstr ""

#: in/chapter7.md:366
msgid ""
"(defun unknown-p (exp)\n"
"  (symbolp exp))"
msgstr ""

#: in/chapter7.md:372
msgid ""
"(defun in-exp (x exp)\n"
"  \"True if x appears anywhere in exp\"\n"
"  (or (eq x exp)\n"
"      (and (listp exp)\n"
"           (or (in-exp x (exp-lhs exp)) (in-exp x (exp-rhs exp))))))"
msgstr ""

#: in/chapter7.md:379
msgid ""
"(defun no-unknown (exp)\n"
"  \"Returns true if there are no unknowns in exp.\"\n"
"  (cond ((unknown-p exp) nil)\n"
"        ((atom exp) t)\n"
"        ((no-unknown (exp-lhs exp)) (no-unknown (exp-rhs exp)))\n"
"        (t nil)))"
msgstr ""

#: in/chapter7.md:387
msgid ""
"(defun one-unknown (exp)\n"
"  \"Returns the single unknown in exp, if there is exactly one.\"\n"
"  (cond ((unknown-p exp) exp)\n"
"        ((atom exp) nil)\n"
"        ((no-unknown (exp-lhs exp)) (one-unknown (exp-rhs exp)))\n"
"        ((no-unknown (exp-rhs exp)) (one-unknown (exp-lhs exp)))\n"
"        (t nil)))"
msgstr ""

#: in/chapter7.md:391
msgid ""
"(defun commutative-p (op)\n"
"  \"Is operator commutative?\"\n"
"  (member op '(+ * =)))"
msgstr ""

#: in/chapter7.md:396
msgid ""
"(defun solve-arithmetic (equation)\n"
"  \"Do the arithmetic for the right hand side.\"\n"
"  ;; This assumes that the right hand side is in the right form.\n"
"  (mkexp (exp-lhs equation) '= (eval (exp-rhs equation))))"
msgstr ""

#: in/chapter7.md:399
msgid ""
"(defun binary-exp-p (x)\n"
"  (and (exp-p x) (= (length (exp-args x)) 2)))"
msgstr ""

#: in/chapter7.md:408
msgid ""
"(defun prefix->infix (exp)\n"
"  \"Translate prefix to infix expressions.\"\n"
"  (if (atom exp) exp\n"
"      (mapcar #'prefix->infix\n"
"              (if (binary-exp-p exp)\n"
"                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))\n"
"                  exp))))\n"
"```"
msgstr ""

#: in/chapter7.md:411
msgid ""
"Here's an example of `solve-equations` in action, with a system of two "
"equations.\n"
"The reader should go through the trace, discovering which case was used at "
"each call to `isolate`, and verifying that each step is accurate."
msgstr ""
"Вот пример `solve-equations` в действии, с системой двух уравнений.\n"
"Читатель должен пройти тарссировку, обнаруживая какой случай использовался "
"при каждом вызове `isolate`, и проверяя правильность/точность каждого шага."

#: in/chapter7.md:446
msgid ""
"```lisp\n"
"> (trace isolate solve)\n"
"(isolate solve)\n"
"> (solve-equations '((= (+  3 4) (* (- 5 (+  2 x)) 7))\n"
"                            (= (+ (* 3 x) y) 12)))\n"
"The equations to be solved are:\n"
"      (3 + 4) = ((5 - (2 + X)) * 7)\n"
"      ((3 * X) + Y) = 12\n"
"(1 ENTER SOLVE: ((= (+  3 4) (* (- 5 (+  2 X)) 7))\n"
"                            (= (+ (* 3 X) Y) 12)) NIL)\n"
"    (1 ENTER ISOLATE: (= (+  3 4) (* (- 5 (+  2 X)) 7)) X)\n"
"        (2 ENTER ISOLATE: (= (* (- 5 (+  2 X)) 7) (+  3 4)) X)\n"
"            (3 ENTER ISOLATE: (= (- 5 (+  2 X)) (/ (+  3 4) 7)) X)\n"
"                (4 ENTER ISOLATE: (= (+  2 X) (- 5 (/ (+  3 4) 7))) X)\n"
"                    (5 ENTER ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)) X)\n"
"                    (5 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))\n"
"                (4 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))\n"
"            (3 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))\n"
"        (2 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))\n"
"    (1 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))\n"
"    (2 ENTER SOLVE: ((= (+ (* 3 2) Y) 12)) ((= X 2)))\n"
"        (1 ENTER ISOLATE: (= (+ (* 3 2) Y) 12) Y)\n"
"          (2 ENTER ISOLATE: (= Y (- 12 (* 3 2))) Y)\n"
"          (2 EXIT ISOLATE: (= Y (- 12 (* 3 2))))\n"
"        (1 EXIT ISOLATE: (= Y (- 12 (* 3 2))))\n"
"        (3 ENTER SOLVE: NIL ((= Y 6) (= X 2)))\n"
"        (3 EXIT SOLVE: ((= Y 6) (= X 2)))\n"
"    (2 EXIT SOLVE: ((= Y 6) (= X 2)))\n"
"(1 EXIT SOLVE: ((= Y 6) (= X 2)))\n"
"The solution is:\n"
"      Y = 6\n"
"      X = 2\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter7.md:454
msgid ""
"Now let's tackle the `format` string `\"~%~a~{~% ~{ ~  a  ~}~}~*%\"*` in "
"`print-equations.` This may look like random gibberish, but there is "
"actually sense behind it.\n"
"`format` processes the string by printing each character, except that `\"~"
"\"` indicates some special formatting action, depending on the following "
"character.\n"
"The combination `\"~%\"` prints a newline, and `\"~a\"` prints the next "
"argument to `format` that has not been used yet.\n"
"Thus the first four characters of the format string, `\"~%~a\"`, print a "
"newline followed by the argument `header`.\n"
"The combination `\"~{\"` treats the corresponding argument as a list, and "
"processes each element according to the specification between the `\"~{\"` "
"and the next `\"~}\"`.\n"
"In this case, `equations` is a list of equations, so each one gets printed "
"with a newline (`\"~%\"`) followed by two spaces, followed by the processing "
"of the equation itself as a list, where each element is printed in the `\"~a"
"\"` format and preceded by a blank.\n"
"The `t` given as the first argument to `format` means to print to the "
"standard output; another output stream may be specified there."
msgstr ""
"Теперь давайте займемся строкой форматирования `\"~%~a~{~% ~{ ~  a  ~}~}~*%"
"\"*` в `print-equations.` Она может показаться бессмысленной тарабарщиной, "
"но на самом деле в ней есть определенный смысл.\n"
"`format` обрабатывает строку, печатая каждый символьный знак, за исключением "
"`\"~\"` указывающим на некоторые специальный действия форматирования, "
"зависящие от следующего за ним знака.\n"
"Комбинация `\"~%\"` печатает знак новой строки, а `\"~a\"` печатает "
"следующий аргумент `format`, который еще не использовался.\n"
"Таким образом четыре знака строки форматирования: `\"~%~a\"`, выводят знак "
"новой строки, за которым следует аргумент `header`.\n"
"Комбинация `\"~{\"` обрабатывает соответствующий аргумент как список, и "
"обрабатывает каждый элемент списка в соответствии со спецификацией между `"
"\"~{\"` и следующими `\"~}\"`.\n"
"В данном случае, `equations` представлляет собой список уравнений, и каждое "
"уравнение печатается с новой строки (`\"~%\"`) за которой следует два "
"пробела, после чего следует обработка самого уравнения как списка, где "
"каждый элемент печатается в формате `\"~a\"` с пробелом перед ним.\n"
"Значение `t` указанное в качестве первого аргумента для `format` означает "
"вывод на стандартный поток вывода; так же может быть указан другой выходной "
"поток."

#: in/chapter7.md:457
msgid ""
"One of the annoying minor holes in Lisp is that there is no standard "
"convention on where to print newlines!\n"
"In C, for example, the very first line of code in the reference manual is"
msgstr ""
"Одно из неприятных мелких упущений в Lisp заключается в том, что нет "
"стандартного соглашения о том, где печатать знаки новой строки!\n"
"В Си, например, самая первая строка кода в справочном руководстве выглядит "
"так"

#: in/chapter7.md:461
msgid ""
"```lisp\n"
"printf(\"hello, world\\n\");\n"
"```"
msgstr ""

#: in/chapter7.md:471
msgid ""
"This makes it clear that newlines are printed *after* each line.\n"
"This convention is so ingrained in the UNIX world that some UNIX programs "
"will go into an infinite loop if the last line in a file is not terminated "
"by a newline.\n"
"In Lisp, however, the function `print` puts in a newline *before* the object "
"to be printed, and a space after.\n"
"Some Lisp programs carry the newline-before policy over to `format`, and "
"others use the newline-after policy.\n"
"This only becomes a problem when you want to combine two programs written "
"under different policies.\n"
"How did the two competing policies arise?\n"
"In UNIX there was only one reasonable policy, because all input to the UNIX "
"interpreter (the shell) is terminated by newlines, so there is no need for a "
"newline-before.\n"
"In some Lisp interpreters, however, input can be terminated by a matching "
"right parenthesis.\n"
"In that case, a newline-before is needed, lest the output appear on the same "
"line as the input."
msgstr ""
"Она ясно дает понять, что знак новой строки печатается *после* каждой "
"линии.\n"
"Это соглашение настолько укоренилось в мире UNIX, что некоторые UNIX "
"программы будут уходить в бесконечный цикл, если последняя строка в файле не "
"заканчивается знаком новой строки.\n"
"В Лиспе, однако, функция `print` ставит знак новой строки *перед* печатаемым "
"объектом и пробел после него.\n"
"Некоторые программы на Лиспе переносят политику перехода на новую строку "
"перед `format`, а другие используют политику перехода на новую строку "
"после.\n"
"Это становится проблемой только тогда, когда вы хотите объединить две "
"программы, написанные под разными политиками.\n"
"Как возникли две конкурирующие политики?\n"
"В UNIX была только одна разумная политика, потому что весь ввод в "
"интерпретатор UNIX (оболочку/shell) завершался знаками новой строки, поэтому "
"небыло необходимости в предшествующем знаке новой строки.\n"
"Однако в некоторых интерпетаторах Lisp ввод может быть завершен "
"соответствующей правой круглой скобкой.\n"
"В этом случае, требуется предшествующий знак новой строки, чтобы вывод не "
"отображался в той же строке, что и ввод."

#: in/chapter7.md:473
msgid ""
"**Exercise  7.1 [m]** Implement `print-equations` using only primitive "
"printing functions such as `terpri` and `princ`, along with explicit loops."
msgstr ""
"**Упражнение  7.1 [m]** Реализуйте `print-equations` используя только "
"примитивные функции печати, такие как `terpri` и `princ`, а также явные "
"циклы."

#: in/chapter7.md:475
msgid "## 7.3 Examples"
msgstr "## 7.3 Примеры"

#: in/chapter7.md:478
msgid ""
"Now we move on to examples, taken from Bobrow's thesis.\n"
"In the first example, it is necessary to insert a \"then\" before the word "
"\"what\" to get the right answer:"
msgstr ""
"Теперь перейдем к примерам, взятым из диссертации Bobrow's.\n"
"В первом примере, перед словом \"then/что\" необходимо вставить \"what/затем"
"\", чтобы получить правильный ответ:"

#: in/chapter7.md:495
msgid ""
"```lisp\n"
"> (student '(If the number of customers Tom gets is twice the square of\n"
"            20 % of the number of advertisements he runs |,|\n"
"            and the number of advertisements is 45 |,|\n"
"            then what is the number of customers Tom gets ?))\n"
"The equations to be solved are:\n"
"      CUSTOMERS = (2 * (((20 / 100) * ADVERTISEMENTS) *\n"
"                      ((20 / 100) * ADVERTISEMENTS)))\n"
"      ADVERTISEMENTS = 45\n"
"      WHAT = CUSTOMERS\n"
"The solution is:\n"
"      WHAT = 162\n"
"      CUSTOMERS = 162\n"
"      ADVERTISEMENTS = 45\n"
"NIL\n"
"```"
msgstr ""
"```lisp\n"
"> (student '(If the number of customers Tom gets is twice the square of\n"
"            20 % of the number of advertisements he runs |,|\n"
"            and the number of advertisements is 45 |,|\n"
"            then what is the number of customers Tom gets ?))\n"
"Решаемые уравнения:\n"
"      CUSTOMERS = (2 * (((20 / 100) * ADVERTISEMENTS) *\n"
"                      ((20 / 100) * ADVERTISEMENTS)))\n"
"      ADVERTISEMENTS = 45\n"
"      WHAT = CUSTOMERS\n"
"Решение:\n"
"      WHAT = 162\n"
"      CUSTOMERS = 162\n"
"      ADVERTISEMENTS = 45\n"
"NIL\n"
"```"

#: in/chapter7.md:499
msgid ""
"Notice that our program prints the values for all variables it can solve "
"for, while Bobrow's program only printed the values that were explicitly "
"asked for in the text.\n"
"This is an example of \"more is less\"-it may look impressive to print all "
"the answers, but it is actually easier to do so than to decide just what "
"answers should be printed.\n"
"The following example is not solved correctly:"
msgstr ""
"Обратите внимание, что наша программа печатает значения всех переменных, "
"которые она может найти, в то время как программа Bobrow's выводила только "
"те значения, которые явно были запрошены в тексте.\n"
"Это пример того, что \"больше значит меньше\", т.е. напечатать все ответы "
"может и впечатляюще, но на самом деле это легче сделать, чем решить, какие "
"именно ответы следует распечатать.\n"
"Следующий пример решен не правильно:"

#: in/chapter7.md:519
msgid ""
"```lisp\n"
"> (student '(The daily cost of living for a group is the overhead cost plus\n"
"            the running cost for each person times the number of people in\n"
"            the group |.| This cost for one group equals $ 100 |,|\n"
"            and the number of people in the group is 40 |.|\n"
"            If the overhead cost is 10 times the running cost |,|\n"
"            find the overhead and running cost for each person |.|))\n"
"The equations to be solved are:\n"
"      DAILY = (OVERHEAD + (RUNNING * PEOPLE))\n"
"      COST = 100\n"
"      PEOPLE = 40\n"
"      OVERHEAD = (10 * RUNNING)\n"
"      TO-FIND-1 = OVERHEAD\n"
"      TO-FIND-2 = RUNNING\n"
"The solution is:\n"
"      PEOPLE = 40\n"
"      COST = 100\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter7.md:526
msgid ""
"This example points out two important limitations of our version of student "
"as compared to Bobrow's.\n"
"The first problem is in naming of variables.\n"
"The phrases \"the daily cost of living for a group\" and \"this cost\" are "
"meant to refer to the same quantity, but our program gives them the names "
"`daily` and `cost` respectively.\n"
"Bobrow's program handled naming by first considering phrases to be the same "
"only if they matched perfectly.\n"
"If the resulting set of equations could not be solved, he would try again, "
"this time considering phrases with words in common to be identical.\n"
"(See the following exercises.)"
msgstr ""
"Этот пример указывает на два важных ограничения нашей версии student по "
"сравнению с программой Bobrow's.\n"
"Первая проблема заключается в именовании переменных.\n"
"Фразы \"the daily cost of living for a group(суточный прожиточный минимум "
"для группы)\" и \"this cost(эта стоимость)\" означают одно и тоже "
"количество, но наша программа дает им имена `daily(день)` и "
"`cost(стоимость)` соответственно.\n"
"Программа Bobrow's обрабатывала названия, сначала рассматривая фразы как "
"одинаковые, только если они идеально совпадали.\n"
"Если результирущую систему уравнений нельзя было решить, она пыталась снова, "
"на этот раз считая фразы с одинаковыми словами идентичными.\n"
"(См. следующие упражнения.)"

#: in/chapter7.md:529
msgid ""
"The other problem is in our `solve` function.\n"
"Assuming we got the variables equated properly, `solve` would be able to "
"boil the set of equations down to two:"
msgstr ""
"Другая проблема заключается в нашей функции `solve`.\n"
"Предполагая, что мы правильно присвоили переменные, `solve` может свести "
"набор уравнений к двум:"

#: in/chapter7.md:534
msgctxt "in/chapter7.md:534"
msgid ""
"```lisp\n"
"100 = (OVERHEAD + (RUNNING * 40))\n"
"OVERHEAD = (10 * RUNNING)\n"
"```"
msgstr ""

#: in/chapter7.md:538
msgid ""
"This is a set of two linear equations in two unknowns and has a unique "
"solution at `RUNNING = 2, OVERHEAD = 20`.\n"
"But our version of `solve` couldn't find this solution, since it looks for "
"equations with one unknown.\n"
"Here is another example that `student` handles well:"
msgstr ""
"Это набор двух линейных уравнений с двумя неизвестными и имеет единственное "
"решение при `RUNNING = 2, OVERHEAD = 20`.\n"
"Но наша версия `solve` не смогла найти это решение, поскольку ищет уравнения "
"с одним неизвестным.\n"
"Вот еще один пример, с которым  `student` хорошо справляется:"

#: in/chapter7.md:555
msgid ""
"```lisp\n"
"> (student '(Fran's age divided by Robin's height is one half Kelly's IQ "
"|.|\n"
"            Kelly's IQ minus 80 is Robin's height |.|\n"
"            If Robin is 4 feet tall |,| how old is Fran ?))\n"
"The equations to be solved are:\n"
"      (FRAN / ROBIN) = (KELLY / 2)\n"
"      (KELLY - 80) = ROBIN\n"
"      ROBIN = 4\n"
"      HOW = FRAN\n"
"The solution is:\n"
"      HOW = 168\n"
"      FRAN = 168\n"
"      KELLY = 84\n"
"      ROBIN = 4\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter7.md:557
msgid "But a slight variation leads to a problem:"
msgstr "Но небольшое изменение приводит к проблеме:"

#: in/chapter7.md:574
msgid ""
"```lisp\n"
"> (student '(Fran's age divided by Robin's height is one half Kelly's IQ "
"|.|\n"
"            Kelly's IQ minus 80 is Robin's height |.|\n"
"            If Robin is 0 feet tall |,| how old is Fran ?))\n"
"The equations to be solved are:\n"
"      (FRAN / ROBIN) = (KELLY / 2)\n"
"      (KELLY - 80) = ROBIN\n"
"      ROBIN = 0\n"
"      HOW = FRAN\n"
"The solution is:\n"
"      HOW = 0\n"
"      FRAN = 0\n"
"      KELLY = 80\n"
"      ROBIN = 0\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter7.md:577
msgid ""
"There is no valid solution to this problem, because it involves dividing by "
"zero (Robin's height).\n"
"But `student` is willing to transform the first equation into:"
msgstr ""
"У этой проблемы нет правильного решения, потому что она предполагает деление "
"на 0 (Robin's height).\n"
"Но `student` готов преобразовать первое уравенение в:"

#: in/chapter7.md:581
msgid ""
"```lisp\n"
"FRAN = ROBIN * (KELLY / 2)\n"
"```"
msgstr ""

#: in/chapter7.md:584
msgid ""
"and then substitutes to get `0` for `FRAN`.\n"
"Worse, dividing by zero could also come up inside `eval`:"
msgstr ""
"и затем подставить полученный `0` для `FRAN`.\n"
"Хуже того, деление на ноль, может появиться внутри `eval`:"

#: in/chapter7.md:596
msgid ""
"```lisp\n"
"> (student '(Fran's age times Robin's height is one half Kelly's IQ |.|\n"
"            Kelly's IQ minus 80 is Robin's height |.|\n"
"            If Robin is 0 feet tall |,| how old is Fran ?))\n"
"The equations to be solved are:\n"
"      (FRAN * ROBIN) = (KELLY / 2)\n"
"      (KELLY - 80) = ROBIN\n"
"      ROBIN = 0\n"
"      HOW = FRAN\n"
">>Error: There was an attempt to divide a number by zero\n"
"```"
msgstr ""

#: in/chapter7.md:598
msgid ""
"However, one could claim that nasty examples with division by zero don't "
"show up in algebra texts."
msgstr ""
"Однако можно утверждать, что неприятные примеры с делением на ноль не "
"встречаются в текстах по алгебре."

#: in/chapter7.md:605
msgid ""
"In summary, STUDENT behaves reasonably well, doing far more than the toy "
"program ELIZA.\n"
"STUDENT is also quite efficient; on my machine it takes less than one second "
"for each of the prior examples.\n"
"However, it could still be extended to have more powerful equation-solving "
"capabilities.\n"
"Its linguistic coverage is another matter.\n"
"While one could add new patterns, such patterns are really just tricks, and "
"don't capture the underlying structure of English sentences.\n"
"That is why the STUDENT approach was abandoned as a research topic."
msgstr ""
"Таким образом, STUDENT ведет себя достаточно хорошо, делая гораздо больше, "
"чем просто игрушечная программа ELIZA.\n"
"STUDENT так же довольно эффективен; на моей машине для каждого из предыдущих "
"примеров требуется меньше одной секунды.\n"
"Однако, его все еще можно расширить, чтобы иметь более мощные возможности "
"для решения уравнений.\n"
"Другое дело - его лингвистический охват.\n"
"Хотя можно добавлять новые шаблоны, она на самом деле являются лишь уловками "
"и не отражают основную структуру английских предложений.\n"
"Вот почему подход принятый в STUDENT был оставлен как тема для исследования."

#: in/chapter7.md:607
msgid "## 7.4 History and References"
msgstr "## 7.4 История и ссылки"

#: in/chapter7.md:617
msgid ""
"Bobrow's Ph.D.\n"
"thesis contains a complete description of STUDENT.\n"
"It is reprinted in [Minsky 1968](B9780080571157500285.xhtml#bb0845).\n"
"Since then, there have been several systems that address the same task, with "
"increased sophistication in both their mathematical and linguistic ability.\n"
"[Wong (1981)](B9780080571157500285.xhtml#bb1420) describes a system that "
"uses its understanding of the problem to get a better linguistic analysis.\n"
"[Sterling et al.\n"
"(1982)](B9780080571157500285.xhtml#bb1195) present a much more powerful "
"equation solver, but it does not accept natural language input.\n"
"Certainly Bobrow's language analysis techniques were not very sophisticated "
"by today's measures.\n"
"But that was largely the point: if you know that the language is describing "
"an algebraic problem of a certain type, then you don't need to know very "
"much linguistics to get the right answer most of the time."
msgstr ""

#: in/chapter7.md:619
msgid "## 7.5 Exercises"
msgstr "## 7.5 Упражнения"

#: in/chapter7.md:621
msgid ""
"**Exercise  7.2 [h]** We said earlier that our program was unable to solve "
"pairs of linear equations, such as:"
msgstr ""
"**Exercise  7.2 [h]** Ранее мы говорили, что наша программа не может решать "
"пары линейных уравнений, например:"

#: in/chapter7.md:626
msgctxt "in/chapter7.md:626"
msgid ""
"```lisp\n"
"100 = (OVERHEAD + (RUNNING * 40))\n"
"OVERHEAD = (10 * RUNNING)\n"
"```"
msgstr ""

#: in/chapter7.md:630
msgid ""
"The original STUDENT could solve these equations.\n"
"Write a routine to do so.\n"
"You may assume there will be only two equations in two unknowns if you wish, "
"or if you are more ambitious, you could solve a system of *n* linear "
"equations with *n* unknowns."
msgstr ""
"Первоначальная программа STUDENT могла решить эти уравнения.\n"
"Напишите Write a routine to do so.\n"
"You may assume there will be only two equations in two unknowns if you wish, "
"or if you are more ambitious, you could solve a system of *n* linear "
"equations with *n* unknowns."

#: in/chapter7.md:638
msgid ""
"**Exercise  7.3 [h]** Implement a version of Bobrow's variable-naming "
"algorithm.\n"
"Instead of taking the first word of each equation, create a unique symbol, "
"and associate with it the entire list of words.\n"
"In the first pass, each nonequal list of words will be considered a distinct "
"variable.\n"
"If no solution is reached, word lists that share words in common are "
"considered to be the same variable, and the solution is attempted again.\n"
"For example, an input that contains the phrases \"the rectangle's width\" "
"and \"the width of the rectangle\" might assign these two phrases the "
"variables `v1` and `v2`.\n"
"If an attempt to solve the problem yields no solutions, the program should "
"realize that `v1` and `v2` have the words \"rectangle\" and \"width\" in "
"common, and add the equation (`= v1 v2`) and try again.\n"
"Since the variables are arbitrary symbols, the printing routine should "
"probably print the phrases associated with each variable rather than the "
"variable itself."
msgstr ""
"**Exercise  7.3 [h]** Реализуйте версию алгоритма именования переменных "
"Боброу.\n"
"Вместо того, чтобы брать первое слово каждого уравнения, создайте уникальный "
"символ и свяжите с ним весь список слов.\n"
"На первом проходе каждый неравный список слов будет считаться отдельной "
"переменной.\n"
"Если решение не достигнуто, списки слов, которые имеют общие слова, считайте "
"одной и той же переменной, и попытка решения предпринимается снова.\n"
"Например, входные данные, содержащие фразы \"the rectangle's width\"(ширина "
"прямоугольника) и \"the width of the rectangle\"(ширина прямоугольника), "
"могут присвоить этим двум фразам переменные `v1` и` v2`.\n"
"Если попытка решить проблему не дает решения, программа должна понять, что "
"`v1` и `v2` имеют общие слова \"rectangle\"(прямоугольник) и \"width"
"\"(ширина), и добавить уравнение (`= v1 v2`) и повторить попытку.\n"
"Поскольку переменные являются произвольными символами, процедура печати, "
"вероятно, должна печатать фразы, связанные с каждой переменной, а не с саму "
"переменную."

#: in/chapter7.md:643
msgid ""
"**Exercise  7.4 [h]** The original STUDENT also had a set of \"common "
"knowledge\" equations that it could use when necessary.\n"
"These were mostly facts about conversion factors, such as (`1 inch = 2.54  "
"cm`).\n"
"Also included were equations like (`distance equal s rate times time`), "
"which could be used to solve problems like \"If the distance from Anabru to "
"Champaign is 10 miles and the time it takes Sandy to travel this distance is "
"2 hours, what is Sandy's rate of speed?\" Make changes to incorporate this "
"facility.\n"
"It probably only helps in conjunction with a solution to the previous "
"exercise."
msgstr ""
"**Exercise  7.4 [h]** Первоначальный STUDENT также имел набор "
"«общеизвестных» уравнений, которые он мог использовать при необходимости.\n"
"В основном это были факты о коэффициентах преобразования, например (`1 inch "
"= 2.54  cm`), т.е. 1 дюйм = 2,54 см».\n"
"Также были включены уравнения типа (`distance equal s rate times time`), т."
"е. расстояние равно  скорости умноженной на время, которые можно было "
"использовать для решения таких задач, как: If the distance from Anabru to "
"Champaign is 10 miles and the time it takes Sandy to travel this distance is "
"2 hours, what is Sandy's rate of speed?\"(Если расстояние от Анабру до "
"Шампейна составляет 10 миль, а время, необходимое Сэнди, чтобы преодолеть "
"это расстояние, составляет 2 часа, то какое скорость Сэнди?) Внесите "
"изменения, чтобы включить эту возможность.\n"
"Вероятно, это помогает только в сочетании с решением предыдущего упражнения."

#: in/chapter7.md:648
msgid ""
"**Exercise  7.5 [h]** Change `student` so that it prints values only for "
"those variables that are being asked for in the problem.\n"
"That is, given the problem \"X is 3.\n"
"Y is 4.\n"
"How much is X  +  Y ?\" it should not print values for X and Y."
msgstr ""
"**Exercise  7.5 [h]** Измените `student` так, чтобы он печатал значения "
"только тех переменных, которые запрашиваются в задаче.\n"
"То есть, если дана задача \"X равно 3.\n"
"Y равно 4.\n"
"Сколько X + Y?\" Он не должен печатать значения для X и Y."

#: in/chapter7.md:651
msgid ""
"**Exercise  7.6 [m]** Try STUDENT on the following examples.\n"
"Make sure you handle special characters properly:"
msgstr ""
"**Exercise  7.6 [m]** Попробуйте STUDENT по следующим примерам.\n"
"Убедитесь, что вы правильно обрабатываете специальные символы:"

#: in/chapter7.md:655
msgid ""
"(a)  The price of a radio is 69.70 dollars.\n"
"If this price is 15% less than the marked The number of soldiers the "
"Russians have is one half of the number of guns\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:660
msgid ""
"(b)  The number of soldiers the Russians have is one half of the number of "
"guns they have.\n"
"The number of guns they have is 7000.\n"
"What is the number of soldiers they have?\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:663
msgid ""
"(c)  If the number of customers Tom gets is twice the square of 20 % of the "
"number of advertisements he runs, and the number of advertisements is 45, "
"and the profit Tom receives is 10 times the number of customers he gets, "
"then what is the profit?\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:668
msgid ""
"(d)  The average score is 73.\n"
"The maximum score is 97.\n"
"What is the square of the difference between the average and the maximum?\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:672
msgid ""
"(e)  Tom is twice Mary's age, and Jane's age is half the difference between "
"Mary and Tom.\n"
"If Mary is 18 years old, how old is Jane?\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:675
msgid ""
"(f)  What is 4  +  5* 14/7?\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:681
msgid ""
"(g)  *x  x  b  =  c  +  d.\n"
"b  x  c  =  x.\n"
"x  =  b  +  b.\n"
"b  =  5.*\n"
"!!!(p) {:.numlist1}"
msgstr ""

#: in/chapter7.md:685
msgid ""
"**Exercise  7.7 [h]**`Student's` infix-to-prefix rules account for the "
"priority of operators properly, but they don't handle associativity in the "
"standard fashion.\n"
"For example, (`12 - 6 - 3`) translates to (`- 12 (- 6 3)`) or `9`, when the "
"usual convention is to interpret this as (`- (- 12 6) 3`) or `3`.\n"
"Fix student to handle this convention."
msgstr ""
"**Exercise  7.7 [h]** Инфиксно-префиксные правила `Student` правильно "
"учитывают приоритет операторов, но они не обрабатывают ассоциативность "
"стандартным образом.\n"
"Например, (`12 - 6 - 3`) переводится как (` - 12 (- 6 3)`) или `9`, когда "
"обычное соглашение интерпретирует это как (`- (- 12 6) 3`) или «3».\n"
"Исправьте ученика, чтобы он справился с этим соглашением."

#: in/chapter7.md:689
msgid ""
"**Exercise  7.8 [d]** Find a mathematically oriented domain that is "
"sufficiently limited so that STUDENT can solve problems in it.\n"
"The chemistry of solutions (calculating pH concentrations) might be an "
"example.\n"
"Write the necessary `*student-rules*`, and test the resulting program."
msgstr ""
"**Exercise  7.8 [d]** Найдите математически ориентированную область, "
"достаточно ограниченную, чтобы STUDENT мог решать в ней задачи.\n"
"Примером может служить химия растворов (расчет концентраций pH).\n"
"Напишите необходимые `*student-rules*` и протестируйте полученную программу."

#: in/chapter7.md:691
msgid ""
"**Exercise  7.9 [m]** Analyze the complexity of `one-unknown` and implement "
"a more efficient version."
msgstr ""
"**Exercise  7.9 [m]** Проанализируйте сложность `one-unknown` и внедрите "
"более эффективную версию."

#: in/chapter7.md:694
msgid ""
"**Exercise  7.10 [h]** Bobrow's paper on STUDENT (1968) includes an appendix "
"that abstractly characterizes all the problems that his system can solve.\n"
"Generate a similar characterization for this version of the program."
msgstr ""
"**Exercise  7.10 [h]** Статья Боброу о STUDENT (1968) включает приложение, в "
"котором абстрактно описываются все проблемы, которые может решить его "
"система.\n"
"Создайте аналогичную характеристику для этой версии программы."

#: in/chapter7.md:696
msgid "## 7.6 Answers"
msgstr "## 7.6 Ответы"

#: in/chapter7.md:698
msgid "**Answer 7.1**"
msgstr ""

#: in/chapter7.md:710
msgid ""
"```lisp\n"
"(defun print-equations (header equations)\n"
"    (terpri)\n"
"    (princ header)\n"
"    (dolist (equation equations)\n"
"        (terpri)\n"
"        (princ \" \")\n"
"        (dolist (x (prefix->infix equation))\n"
"            (princ \" \")\n"
"            (princ x))))\n"
"```"
msgstr ""

#: in/chapter7.md:713
msgid ""
"**Answer 7.9**`one-unknown` is very inefficient because it searches each "
"subcomponent of an expression twice.\n"
"For example, consider the equation:"
msgstr ""
"**Answer 7.9**`one-unknown` очень неэффективен, потому что он ищет каждый "
"подкомпонент выражения дважды.\n"
"Например, рассмотрим уравнение:"

#: in/chapter7.md:715
msgid "`(= (+ (+`  x  `2) (+  3 4)) (+ (+  5 6) (+  7 8)))`"
msgstr ""

#: in/chapter7.md:720
msgid ""
"To decide if this has one unknown, `one-unknown` will call `no-unknown` on "
"the left-hand side, and since it fails, call it again on the right-hand "
"side.\n"
"Although there are only eight atoms to consider, it ends up calling `no-"
"unknown 17` times and `one-unknown 4` times.\n"
"In general, for a tree of depth *n*, approximately 2*n* calls to `no-"
"unknown` are made.\n"
"This is clearly wasteful; there should be no need to look at each component "
"more than once."
msgstr ""
"Чтобы решить, есть ли у него одно неизвестное, `one-unknown` вызовет `no-"
"unknown` в левой части, и, поскольку он не работает, вызовет его снова в "
"правой части.\n"
"Хотя нужно рассмотреть только восемь атомов, в конечном итоге он вызывает "
"«`no-unknown 17` раз и `one-unknown 4` раза.\n"
"В общем, для дерева глубины *n* выполняется примерно *2n* вызовов `no-"
"unknown`.\n"
"Это явно расточительно; нет необходимости смотреть на каждый компонент более "
"одного раза."

#: in/chapter7.md:726
msgid ""
"The following version uses an auxiliary function, `find-one-unknown,` that "
"has an accumulator parameter, `unknown.` This parameter can take on three "
"possible values: nil, indicating that no unknown has been found; or the "
"single unknown that has been found so far; or the number 2 indicating that "
"two unknowns have been found and therefore the final result should be nil.\n"
"The function `find-one-unknown` has four cases: (1) If we have already found "
"two unknowns, then return 2 to indicate this.\n"
"(2) If the input expression is a nonatomic expression, then first look at "
"its left-hand side for unknowns, and pass the result found in that side as "
"the accumulator to a search of the right-hand side.\n"
"(3) If the expression is an unknown, and if it is the second one found, "
"return `2`; otherwise return the unknown itself.\n"
"(4) If the expression is an atom that is not an unknown, then just return "
"the accumulated result."
msgstr ""
"В следующей версии используется вспомогательная функция, `find-one-unknown`, "
"у которой есть аккумулирующий параметр ʻunknown`. Этот параметр может "
"принимать три возможных значения: nil, что указывает на то, что ничего "
"неизвестного не найдено; или единственное неизвестное, что было найдено до "
"сих пор; или число 2, указывающее, что были обнаружены два неизвестных, и "
"поэтому окончательный результат должен быть равен нулю.\n"
"Функция `find-one-unknown` имеет четыре случая: (1) Если мы уже нашли два "
"неизвестных, то верните 2, чтобы указать это.\n"
"(2) Если входное выражение является неатомарным выражением, то сначала "
"посмотрите на его левую часть на предмет неизвестных и передайте результат, "
"найденный на этой стороне, в качестве аккумулятора для поиска правой части.\n"
"(3) Если выражение неизвестно, и если это второе найденное выражение, "
"вернуть `2`; в противном случае верните само неизвестное.\n"
"(4) Если выражение представляет собой атом, который не является неизвестным, "
"просто верните накопленный результат."

#: in/chapter7.md:750
msgid ""
"```lisp\n"
"(defun one-unknown (exp)\n"
"    \"Returns the single unknown in exp, if there is exactly one.\"\n"
"    (let ((answer (find-one-unknown exp nil)))\n"
"        ;; If there were two unknowns, return nil;\n"
"        ;; otherwise return the unknown (if there was one)\n"
"        (if (eql answer 2)\n"
"              nil\n"
"              answer)))\n"
"(defun find-one-unknown (exp unknown)\n"
"    \"Assuming UNKNOWN is the unknown(s) found so far, decide\n"
"    if there is exactly one unknown in the entire expression.\"\n"
"    (cond ((eql unknown 2) 2)\n"
"                ((exp-p exp)\n"
"                    (find-one-unknown\n"
"                        (exp-rhs exp)\n"
"                        (find-one-unknown (exp-lhs exp) unknown)))\n"
"                ((unknown-p exp)\n"
"                    (if unknown\n"
"                            2\n"
"                            exp))\n"
"                (t unknown)))\n"
"```"
msgstr ""

#: in/chapter7.md:752
msgid "----------------------"
msgstr ""

#: in/chapter7.md:755
msgid ""
"[1](#xfn0015)[Page 316](B9780080571157500108.xhtml#p316) of *Common Lisp the "
"Language* says, \"Because a constructor of this type operates By Order of "
"Arguments, it is sometimes known as a BOA constructor.\"\n"
"!!!(p) {:.ftnote1}"
msgstr ""
