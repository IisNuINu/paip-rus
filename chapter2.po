#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter2.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-09-24 14:11+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter2.md:3
msgid ""
"# Chapter 2\n"
"## A Simple Lisp Program"
msgstr ""
"# Глава 2\n"
"## Простая Лисп Программа"

#: in/chapter2.md:5
msgid "> *Certum quod factum.*"
msgstr "> *Убедитесь, что это произошло.*"

#: in/chapter2.md:7
msgid "> (One is certain of only what one builds.)"
msgstr "> (Человек уверен только в том, что он создает.)"

#: in/chapter2.md:9
msgid "> -Giovanni Battista Vico (1668-1744)"
msgstr ""

#: in/chapter2.md:11
msgid "> Italian royal historiographer"
msgstr ""

#: in/chapter2.md:15
msgid ""
"You will never become proficient in a foreign language by studying "
"vocabulary lists.\n"
"Rather, you must hear and speak (or read and write) the language to gain "
"proficiency.\n"
"The same is true for learning computer languages."
msgstr ""
"Вы никогда не станете хорошо владеть иностранным языком, изучая словари.\n"
"Будет лучше, если вы будете слышать и говорить (или читать и писать) на "
"языке, чтобы получить навыки.\n"
"То же самое верно и для изучения компьютерных языков."

#: in/chapter2.md:18
msgid ""
"This chapter shows how to combine the basic functions and special forms of "
"Lisp into a complete program.\n"
"If you can learn how to do that, then acquiring the remaining vocabulary of "
"Lisp (as outlined in chapter 3) will be easy."
msgstr ""
"В этой главе показано, как объединить основные функции и специальные формы "
"Lisp в целостную программу.\n"
"Если вы научитесь этому, то освоить оставшийся словарный запас Lisp (как "
"описано в главе 3) будет легко."

#: in/chapter2.md:20
msgid "## 2.1 A Grammar for a Subset of English"
msgstr "## 2.1 Грамматика для подмножества английского языка"

#: in/chapter2.md:23
msgid ""
"The program we will develop in this chapter generates random English "
"sentences.\n"
"Here is a simple grammar for a tiny portion of English:"
msgstr ""
"Программа, которую мы разработаем в этой главе, генерирует случайные "
"английские предложения.\n"
"Вот простая грамматика для крошечной части английского языка:"

#: in/chapter2.md:30
msgid ""
"> *Sentence* => *Noun-Phrase + Verb-Phrase*  \n"
"> *Noun-Phrase* => *Article + Noun*  \n"
"> *Verb-Phrase* => *Verb + Noun-Phrase*  \n"
"> *Article* => *the, a,...*  \n"
"> *Noun* => *man, ball, woman, table...*  \n"
"> *Verb* => *hit, took, saw, liked...*"
msgstr ""
"> *Sentence* => *Noun-Phrase + Verb-Phrase*  \n"
"\n"
"> *Noun-Phrase* => *Article + Noun*  \n"
"\n"
"> *Verb-Phrase* => *Verb + Noun-Phrase*  \n"
"\n"
"> *Article* => *the, a,...*  \n"
"\n"
"> *Noun* => *man, ball, woman, table...*  \n"
"\n"
"> *Verb* => *hit, took, saw, liked...*\n"

#: in/chapter2.md:37
msgid ""
"To be technical, this description is called a *context-free phrase-structure "
"grammar*, and the underlying paradigm is called *generative syntax*.\n"
"The idea is that anywhere we want a sentence, we can generate a noun phrase "
"followed by a verb phrase.\n"
"Anywhere a noun phrase has been specified, we generate instead an article "
"followed by a noun.\n"
"Anywhere an article has been specified, we generate either \"the,\" \"a,\" "
"or some other article.\n"
"The formalism is \"context-free\" because the rules apply anywhere "
"regardless of the surrounding words, and the approach is \"generative\" "
"because the rules as a whole define the complete set of sentences in a "
"language (and by contrast the set of nonsentences as well).\n"
"In the following we show the derivation of a single sentence using the rules:"
msgstr ""
"Чтобы быть техническим, это описание называется \"контекстно-свободной "
"грамматикой структуры фразы\", а лежащая в ее основе парадигма называется "
"\"генеративным синтаксисом\".\n"
"Идея заключается в том, что в любом месте, где мы хотим предложение, мы "
"можем создать noun phrase (именная фраза), за которым следует verb "
"phrase(глагольная фраза).\n"
"Везде, где была указана noun phrase (именная фраза), мы генерируем вместо "
"нее article (артикль), за которым следует noun (существительное).\n"
"Где бы ни была указан article (артикль), мы генерируем либо \"the\", либо \"a"
"\", либо какой-то другой артикль.\n"
"Формализм является \"контекстно-свободным\", потому что правила применяются "
"везде, независимо от окружающих слов, а подход является \"генеративным\", "
"потому что правила в целом определяют полный набор предложений в языке (а "
"также, набор бессмысленностей).\n"
"Ниже мы покажем вывод одного предложения с помощью этих правил:"

#: in/chapter2.md:52
msgid ""
"* To get a *Sentence,* append a *Noun-Phrase* and a *Verb-Phrase*\n"
"  * To get a *Noun-Phrase*, append an *Article* and a *Noun*\n"
"    * Choose *\"the\"* for the *Article*\n"
"    * Choose *\"man\"* for the *Noun*\n"
"  * The resulting *Noun-Phrase* is *\"the man\"*\n"
"  * To get a *Verb-Phrase,* append a *Verb* and a *Noun-Phrase*\n"
"    * Choose *\"hit\"* for the *Verb*\n"
"    * To get a *Noun-Phrase*, append an *Article* and a *Noun*\n"
"      * Choose *\"the\"* for the *Article*\n"
"      * Choose *\"ball\"* for the *Noun*\n"
"    * The resulting *Noun-Phrase* is *\"the ball\"*\n"
"  * The resulting *Verb-Phrase* is *\"hit the ball\"*\n"
"* The resulting *Sentence* is *\"The man hit the ball\"*"
msgstr ""
"* Чтобы получить предложение - *Sentence*, добавьте *Noun-Phrase* и *Verb-"
"Phrase*\n"
"  * Чтобы получить именную фразу *Noun-Phrase*, добавьте артикль *Article* и "
"существительное *Noun*\n"
"    * Выбираем *\"the\"* для артикля *Article*\n"
"    * Выбираем *\"man\"* для существительного *Noun*\n"
"  * Результирующая именная фраза *Noun-Phrase* будет *\"the man\"*\n"
"  * Чтобы получить глагольную фразу *Verb-Phrase,* добавьте глагол *Verb* и "
"именную фразу *Noun-Phrase*\n"
"    * Выбираем *\"hit\"* для глагола *Verb*\n"
"    * Чтобы получить именную фразу *Noun-Phrase*, добвьте артикль *Article* "
"и существительное *Noun*\n"
"      * Выбираем *\"the\"* для артикля *Article*\n"
"      * Выбираем *\"ball\"* для существительного *Noun*\n"
"    * Результирующая именная фраза *Noun-Phrase* будет *\"the ball\"*\n"
"  * Результирующая глагольная фраза *Verb-Phrase* будет *\"hit the ball\"*\n"
"* Результирующее предложение *Sentence* будет *\"The man hit the ball\"*"

#: in/chapter2.md:54
msgid "## 2.2 A Straightforward Solution"
msgstr "## 2.2 Простое Решение"

#: in/chapter2.md:57
msgid ""
"We will develop a program that generates random sentences from a phrase-"
"structure grammar.\n"
"The most straightforward approach is to represent each grammar rule by a "
"separate Lisp function:"
msgstr ""
"Мы разработаем программу, которая генерирует случайные предложения из "
"грамматики структуры фразы.\n"
"Самый простой подход заключается в представлении каждого грамматического "
"правила отдельной функцией Lisp:"

#: in/chapter2.md:66
msgid ""
"```lisp\n"
"(defun sentence ()    (append (noun-phrase) (verb-phrase)))\n"
"(defun noun-phrase () (append (Article) (Noun)))\n"
"(defun verb-phrase () (append (Verb) (noun-phrase)))\n"
"(defun Article ()     (one-of '(the a)))\n"
"(defun Noun ()        (one-of '(man ball woman table)))\n"
"(defun Verb ()        (one-of '(hit took saw liked)))\n"
"```"
msgstr ""

#: in/chapter2.md:72
msgid ""
"Each of these function definitions has an empty parameter list, `()`.\n"
"That means the functions take no arguments.\n"
"This is unusual because, strictly speaking, a function with no arguments "
"would always return the same thing, so we would use a constant instead.\n"
"However, these functions make use of the `random` function (as we will see "
"shortly), and thus can return different results even with no arguments.\n"
"Thus, they are not functions in the mathematical sense, but they are still "
"called functions in Lisp, because they return a value."
msgstr ""
"Каждое из этих определений функций имеет пустой список параметров `()`.\n"
"Это означает, что функции не принимают аргументов.\n"
"Это необычно, потому что, строго говоря, функция без аргументов всегда будет "
"возвращать одно и то же, поэтому мы можем использовать константу вместо "
"неё.\n"
"Однако эти функции используют  функцию `random` (как мы вскоре увидим) и, "
"таким образом, могут возвращать различные результаты даже без аргументов.\n"
"Таким образом, они не являются функциями в математическом смысле, но они все "
"еще называются функциями в Lisp, потому что они возвращают значение."

#: in/chapter2.md:77
msgid ""
"All that remains now is to define the function `one-of`.\n"
"It takes a list of possible choices as an argument, chooses one of these at "
"random, and returns a one-element list of the element chosen.\n"
"This last part is so that all functions in the grammar will return a list of "
"words.\n"
"That way, we can freely apply `append` to any category."
msgstr ""
"Теперь остается только определить функцию \"один из\" - `one-of`.\n"
"Она принимает список возможных вариантов в качестве аргумента, выбирает один "
"из них наугад и возвращает одноэлементный список выбранного элемента.\n"
"Эта последняя часть предназначена для того, чтобы все функции в грамматике "
"возвращали список слов, пусть даже и одноэлементный.\n"
"Таким образом, мы можем свободно применять `append` к любой категории."

#: in/chapter2.md:82
msgid ""
"```lisp\n"
"(defun one-of (set)\n"
"  \"Pick one element of set, and make a list of it.\"\n"
"  (list (random-elt set)))"
msgstr ""
"```lisp\n"
"(defun one-of (set)\n"
"  \"Выбирает один элемент набора и составляет из него список.\"\n"
"  (list (random-elt set)))"

#: in/chapter2.md:87
msgid ""
"(defun random-elt (choices)\n"
"  \"Choose an element from a list at random.\"\n"
"  (elt choices (random (length choices))))\n"
"```"
msgstr ""
"(defun random-elt (choices)\n"
"  \"Выбирает элемент из списка наугад\"\n"
"  (elt choices (random (length choices))))\n"
"```"

#: in/chapter2.md:94
msgid ""
"There are two new functions here, `elt` and `random`.\n"
"`elt` picks an element out of a list.\n"
"The first argument is the list, and the second is the position in the list.\n"
"The confusing part is that the positions start at 0, so `(elt choices 0)` is "
"the first element of the list, and `(elt choices 1)` is the second.\n"
"Think of the position numbers as telling you how far away you are from the "
"front.\n"
"The expression `(random n)` returns an integer from 0 to n-1, so that "
"`(random 4)` would return either 0, 1, 2, or 3."
msgstr ""
"Здесь используются две новые функции: `elt` и `random`.\n"
"`elt` выбирает элемент из списка.\n"
"Первый аргумент - это список, а второй - позиция в списке.\n"
"Путаница заключается в том, что позиции начинаются с 0, поэтому `(elt "
"choices 0)` является первым элементом списка, а `(elt choices 1)` - вторым.\n"
"Считайте, что номера позиций говорят вам, как далеко вы находитесь от начала "
"списка.\n"
"Выражение `(random n)` возвращает целое число от 0 до n-1, так что `(random "
"4)` вернет либо 0, либо 1, либо 2, либо 3."

#: in/chapter2.md:96
msgid ""
"Now we can test the program by generating a few random sentences, along with "
"a noun phrase and a verb phrase:"
msgstr ""
"Теперь мы можем протестировать программу, создав несколько случайных "
"предложений, а также фразу существительного(noun) и глагола(verb):"

#: in/chapter2.md:99
msgid ""
"```lisp\n"
"> (sentence) => (THE WOMAN HIT THE BALL)"
msgstr ""

#: in/chapter2.md:101
msgid "> (sentence) => (THE WOMAN HIT THE MAN)"
msgstr ""

#: in/chapter2.md:103
msgid "> (sentence) =>(THE BALL SAW THE WOMAN)"
msgstr ""

#: in/chapter2.md:105
msgid "> (sentence) => (THE BALL SAW THE TABLE)"
msgstr ""

#: in/chapter2.md:107
msgid "> (noun-phrase) => (THE MAN)"
msgstr ""

#: in/chapter2.md:109
msgid "> (verb-phrase) => (LIKED THE WOMAN)"
msgstr ""

#: in/chapter2.md:112
msgid ""
"> (trace sentence noun-phrase verb-phrase article noun verb) =>\n"
"(SENTENCE NOUN-PHRASE VERB-PHRASE ARTICLE NOUN VERB)"
msgstr ""

#: in/chapter2.md:134
msgid ""
"> (sentence) =>\n"
"(1 ENTER SENTENCE)\n"
"  (1 ENTER NOUN-PHRASE)\n"
"    (1 ENTER ARTICLE)\n"
"    (1 EXIT ARTICLE: (THE))\n"
"    (1 ENTER NOUN)\n"
"    (1 EXIT NOUN: (MAN))\n"
"  (1 EXIT NOUN-PHRASE: (THE MAN))\n"
"  (1 ENTER VERB-PHRASE)\n"
"    (1 ENTER VERB)\n"
"    (1 EXIT VERB: (HIT))\n"
"    (1 ENTER NOUN-PHRASE)\n"
"      (1 ENTER ARTICLE)\n"
"      (1 EXIT ARTICLE: (THE))\n"
"      (1 ENTER NOUN)\n"
"      (1 EXIT NOUN: (BALL))\n"
"    (1 EXIT NOUN-PHRASE: (THE BALL))\n"
"  (1 EXIT VERB-PHRASE: (HIT THE BALL))\n"
"(1 EXIT SENTENCE: (THE MAN HIT THE BALL))\n"
"(THE MAN HIT THE BALL)\n"
"```"
msgstr ""

#: in/chapter2.md:139
msgid ""
"The program works fine, and the trace looks just like the sample derivation "
"above, but the Lisp definitions are a bit harder to read than the original "
"grammar rules.\n"
"This problem will be compounded as we consider more complex rules.\n"
"Suppose we wanted to allow noun phrases to be modified by an indefinite "
"number of adjectives and an indefinite number of prepositional phrases.\n"
"In grammatical notation, we might have the following rules:"
msgstr ""
"Программа работает нормально, и трассировка выглядит точно так же, как "
"пример деривации выше, но определения Lisp немного сложнее читать, чем "
"исходные грамматические правила.\n"
"Эта проблема будет усугубляться по мере рассмотрения более сложных правил.\n"
"Предположим, мы хотим, чтобы noun phrases(именые фразы) были изменены "
"неопределенным числом прилагательных(adjectives) и неопределенным числом "
"предложных фраз(prepositional phrases).\n"
"В грамматической нотации у нас могут быть следующие правила:"

#: in/chapter2.md:146
msgid ""
"> *Noun-Phrase => Article + Adj\\* + Noun + PP\\*  \n"
"> Adj\\* => 0&#x0338;, Adj + Adj\\*  \n"
"> PP\\* => 0&#x0338;, PP + PP\\*  \n"
"> PP => Prep + Noun-Phrase  \n"
"> Adj => big, little, blue, green, ...  \n"
"> Prep => to, in, by, with, ...*"
msgstr ""
"> *Noun-Phrase => Article + Adj\\* + Noun + PP\\*\n"
"\n"
"> Adj\\* => 0&#x0338;, Adj + Adj\\* \n"
"\n"
"> PP\\* => 0&#x0338;, PP + PP\\*\n"
"\n"
"> PP => Prep + Noun-Phrase  \n"
"\n"
"> Adj => big, little, blue, green, ...  \n"
"\n"
"> Prep => to, in, by, with, ...*\n"

#: in/chapter2.md:152
msgid ""
"In this notation, 0&#x0338; indicates a choice of nothing at all, a comma "
"indicates a choice of several alternatives, and the asterisk is nothing "
"special-as in Lisp, it's just part of the name of a symbol.\n"
"However, the convention used here is that names ending in an asterisk denote "
"zero or more repetitions of the underlying name.\n"
"That is, *PP\\** denotes zero or more repetitions of *PP*.\n"
"<a id=\"tfn02-1\"></a>\n"
"This is known as \"Kleene star\" notation (pronounced \"clean-E\") after the "
"mathematician Stephen Cole Kleene.[1](#fn02-1)"
msgstr ""
"В этой нотации 0&#x0338; указывает на выбор пустоты, запятая указывает на "
"выбор нескольких альтернатив, а звездочка не является чем-то особенным-как и "
"в Lisp, это просто часть имени символа.\n"
"Однако здесь используется соглашение, что имена, заканчивающиеся звездочкой, "
"обозначают ноль или более повторений основного имени.\n"
"То есть, *PP\\** означает ноль или более повторений *PP*.\n"
"<a id=\"tfn02-1\"></a>\n"
"Это обозначение известно как \"звезда Клина\" (произносится как \"clean-E\") "
"в честь математика Стивена Коула Клина.[1](#fn02-1)"

#: in/chapter2.md:155
msgid ""
"The problem is that the rules for *Adj\\** and *PP\\** contain choices that "
"we would have to represent as some kind of conditional in Lisp.\n"
"For example:"
msgstr ""
"Проблема в том, что правила для *Adj\\** и *PP\\**  содержат варианты "
"выбора, которые мы должны были бы представить как своего рода условия в "
"Lisp.\n"
"Например:"

#: in/chapter2.md:161
msgid ""
"```lisp\n"
"(defun Adj* ()\n"
"  (if (= (random 2) 0)\n"
"      nil\n"
"      (append (Adj) (Adj*))))"
msgstr ""

#: in/chapter2.md:166
msgid ""
"(defun PP* ()\n"
"  (if (random-elt '(t nil))\n"
"      (append (PP) (PP*))\n"
"      nil))"
msgstr ""

#: in/chapter2.md:172
msgid ""
"(defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))\n"
"(defun PP () (append (Prep) (noun-phrase)))\n"
"(defun Adj () (one-of '(big little blue green adiabatic)))\n"
"(defun Prep () (one-of '(to in by with on)))\n"
"```"
msgstr ""

#: in/chapter2.md:175
msgid ""
"I've chosen two different implementations for `Adj*` and `PP*`; either "
"approach would work in either function.\n"
"We have to be careful, though; here are two approaches that would not work:"
msgstr ""
"Я выбрал две различные реализации для `Adj*` и `PP*`; любой подход будет "
"работать в любой функции.\n"
"Однако мы должны быть осторожны; вот два подхода, которые не сработают:"

#: in/chapter2.md:184
msgid ""
"```lisp\n"
"(defun Adj* ()\n"
"  \"Warning - incorrect definition of Adjectives.\"\n"
"  (one-of '(nil (append (Adj) (Adj*)))))\n"
"(defun Adj* ()\n"
"  \"Warning - incorrect definition of Adjectives.\"\n"
"  (one-of (list nil (append (Adj) (Adj*)))))\n"
"```"
msgstr ""

#: in/chapter2.md:190
msgid ""
"The first definition is wrong because it could return the literal expression "
"`((append (Adj) (Adj*)))` rather than a list of words as expected.\n"
"The second definition would cause infinite recursion, because computing the "
"value of `(Adj*)` always involves a recursive call to `(Adj*)`.\n"
"The point is that what started out as simple functions are now becoming "
"quite complex.\n"
"To understand them, we need to know many Lisp conventions-`defun, (), case, "
"if`, `quote`, and the rules for order of evaluation-when ideally the "
"implementation of a grammar rule should use only *linguistic* conventions.\n"
"If we wanted to develop a larger grammar, the problem could get worse, "
"because the rule-writer might have to depend more and more on Lisp."
msgstr ""
"Первое определение неверно, потому что оно может возвращать буквальное "
"выражение `((append (Adj) (Adj*)))`, а не список слов, как ожидается.\n"
"Второе определение вызвало бы бесконечную рекурсию, потому что вычисление "
"значения `(Adj*)` всегда включает рекурсивный вызов `(Adj*)`.\n"
"Дело в том, что то, что начиналось как простые функции, теперь становится "
"довольно сложным.\n"
"Чтобы понять их, нам нужно знать многие соглашения Lisp - `defun, (), case, "
"if`, `quote` и правила порядка вычисления-когда в идеале реализация "
"грамматического правила должна использовать только *лингвистические* "
"соглашения.\n"
"Если бы мы хотели разработать более широкую грамматику, проблема могла бы "
"стать еще хуже, потому что автор правил мог бы все больше и больше зависеть "
"от Lisp."

#: in/chapter2.md:192
msgid "## 2.3 A Rule-Based Solution"
msgstr "## 2.3 Решение, Основанное На Правилах"

#: in/chapter2.md:195
msgid ""
"An alternative implementation of this program would concentrate on making it "
"easy to write grammar rules and would worry later about how they will be "
"processed.\n"
"Let's look again at the original grammar rules:"
msgstr ""
"Альтернативная реализация этой программы сосредоточилась бы на упрощении "
"написания грамматических правил и позже беспокоилась бы о том, как они будут "
"обработаны.\n"
"Давайте еще раз посмотрим на исходные грамматические правила:"

#: in/chapter2.md:202
msgid ""
"> *Sentence => Noun-Phrase + Verb-Phrase  \n"
"> Noun-Phrase => Article + Noun  \n"
"> Verb-Phrase => Verb + Noun-Phrase  \n"
"> Article => the, a, ...  \n"
"> Noun => man, ball, woman, table...  \n"
"> Verb => hit, took, saw, liked...*"
msgstr ""
"> *Sentence => Noun-Phrase + Verb-Phrase \n"
" \n"
"> Noun-Phrase => Article + Noun  \n"
"\n"
"> Verb-Phrase => Verb + Noun-Phrase  \n"
"\n"
"> Article => the, a, ...  \n"
"\n"
"> Noun => man, ball, woman, table...  \n"
"\n"
"> Verb => hit, took, saw, liked...*\n"

#: in/chapter2.md:207
msgid ""
"Each rule consists of an arrow with a symbol on the left-hand side and "
"something on the right-hand side.\n"
"The complication is that there can be two kinds of right-hand sides: a "
"concatenated list of symbols, as in \"*Noun-Phrase => Article+Noun*,\" or a "
"list of alternate words, as in \"*Noun => man, ball, ...*\"\n"
"We can account for these possibilities by deciding that every rule will have "
"a list of possibilities on the right-hand side, and that a concatenated "
"list, *for example \"Article+Noun,\"* will be represented as a Lisp list, "
"*for example* \"(`Article Noun`)\".\n"
"The list of rules can then be represented as follows:"
msgstr ""
"Каждое правило состоит из Стрелки с символом на левой стороне и еще чего-то "
"на правой стороне.\n"
"Сложность заключается в том, что правые стороны могут быть двух видов: "
"объединенный список символов, как в  \"Noun-Phrase => Article+Noun\", или "
"список альтернативных слов, как в \"Noun => man, ball, ...\"\n"
"Мы можем учесть эти возможности, решив, что каждое правило будет иметь "
"список возможностей в правой части, и что объединенный список, *например*  "
"\"Article+Noun\", будет представлен как список Lisp, *например*  \"(Article "
"Noun)\".\n"
"Затем список правил можно представить следующим образом:"

#: in/chapter2.md:217
msgid ""
"```lisp\n"
"(defparameter *simple-grammar*\n"
"  '((sentence -> (noun-phrase verb-phrase))\n"
"    (noun-phrase -> (Article Noun))\n"
"    (verb-phrase -> (Verb noun-phrase))\n"
"    (Article -> the a)\n"
"    (Noun -> man ball woman table)\n"
"    (Verb -> hit took saw liked))\n"
"  \"A grammar for a trivial subset of English.\")"
msgstr ""

#: in/chapter2.md:222
msgid ""
"(defvar *grammar* *simple-grammar*\n"
"  \"The grammar used by generate.  Initially, this is\n"
"  *simple-grammar*, but we can switch to other grammars.\")\n"
"```"
msgstr ""

#: in/chapter2.md:225
msgid ""
"Note that the Lisp version of the rules closely mimics the original "
"version.\n"
"In particular, I include the symbol \"->\", even though it serves no real "
"purpose; it is purely decorative."
msgstr ""
"Обратите внимание, что Лисп-версия правил близко имитирует исходную версию.\n"
"В частности, я включаю символ \"->\", хотя он не служит никакой реальной "
"цели; он чисто декоративный."

#: in/chapter2.md:229
msgid ""
"The special forms `defvar` and `defparameter` both introduce special "
"variables and assign a value to them; the difference is that a *variable*, "
"like `*grammar*,` is routinely changed during the course of running the "
"program.\n"
"A *parameter*, like `*simple-grammar*`, on the other hand, will normally "
"stay constant.\n"
"A change to a parameter is considered a change *to* the program, not a "
"change *by* the program."
msgstr ""
"Специальные формы `defvar` и `defparameter` вводят специальные переменные и "
"присваивают им значение; разница заключается в том, что *переменная* такая "
"как `*grammar*`, регулярно изменяется в ходе выполнения программы.\n"
"С другой стороны, *параметр*, такой как `*simple-grammar*`, обычно остается "
"постоянным.\n"
"Изменение параметра считается *изменением программы*, а не изменением "
"выполняемым *самой программой*."

#: in/chapter2.md:235
msgid ""
"Once the list of rules has been defined, it can be used to find the possible "
"rewrites of a given category symbol.\n"
"The function `assoc` is designed for just this sort of task.\n"
"It takes two arguments, a \"key\" and a list of lists, and returns the first "
"element of the list of lists that starts with the key.\n"
"If there is none, it returns `nil`.\n"
"Here is an example:"
msgstr ""
"После того, как список правил был определен, он может использоваться, чтобы "
"найти возможные перезаписи данного символа-category.\n"
"Функция `assoc` предназначена именно для такого рода задач.\n"
"Она принимает два аргумента, \"key\"(ключ) и список списков, и возвращает "
"первый элемент списка списков, который начинается с переданного ключа.\n"
"Если его нет, она возвращает `nil`.\n"
"Вот вам пример:"

#: in/chapter2.md:239
msgid ""
"```lisp\n"
"> (assoc 'noun *grammar*) => (NOUN -> MAN BALL WOMAN TABLE)\n"
"```"
msgstr ""

#: in/chapter2.md:242
msgid ""
"Although rules are quite simply implemented as lists, it is a good idea to "
"impose a layer of abstraction by defining functions to operate on the "
"rules.\n"
"We will need three functions: one to get the right-hand side of a rule, one "
"for the left-hand side, and one to look up all the possible rewrites (right-"
"hand sides) for a category."
msgstr ""
"Хотя правила довольно просто реализованы в виде списков, хорошей идеей "
"является наложение уровня абстракции путем определения функций для работы с "
"правилами.\n"
"Нам понадобятся три функции: одна для получения правой части правила, одна "
"для левой части и одна для поиска всех возможных переписываний (правых "
"частей) для категории(category)."

#: in/chapter2.md:247
msgid ""
"```lisp\n"
"(defun rule-lhs (rule)\n"
"  \"The left hand side of a rule.\"\n"
"  (first rule))"
msgstr ""

#: in/chapter2.md:251
msgid ""
"(defun rule-rhs (rule)\n"
"  \"The right hand side of a rule.\"\n"
"  (rest (rest rule)))"
msgstr ""

#: in/chapter2.md:256
msgid ""
"(defun rewrites (category)\n"
"  \"Return a list of the possible rewrites for this category.\"\n"
"  (rule-rhs (assoc category *grammar*)))\n"
"```"
msgstr ""
"(defun rewrites (category)\n"
"  \"Возвращает список возможных перезаписей для данной категории.\"\n"
"  (rule-rhs (assoc category *grammar*)))\n"
"```"

#: in/chapter2.md:258
msgid ""
"Defining these functions will make it easier to read the programs that use "
"them, and it also makes changing the representation of rules easier, should "
"we ever decide to do so."
msgstr ""
"Определение этих функций облегчит чтение программ, которые их используют, а "
"также облегчит изменение представления правил, если мы когда-либо решим это "
"сделать."

#: in/chapter2.md:270
msgid ""
"We are now ready to address the main problem: defining a function that will "
"generate sentences (or noun phrases, or any other category).\n"
"We will call this function `generate`.\n"
"It will have to contend with three cases:\n"
"(1) In the simplest case, `generate` is passed a symbol that has a set of "
"rewrite rules associated with it.\n"
"We choose one of those at random, and then generate from that.\n"
"(2) If the symbol has no possible rewrite rules, it must be a terminal "
"symbol-a word, rather than a grammatical category-and we want to leave it "
"alone.\n"
"Actually, we return the list of the input word, because, as in the previous "
"program, we want all results to be lists of words.\n"
"(3) In some cases, when the symbol has rewrites, we will pick one that is a "
"list of symbols, and try to generate from that.\n"
"Thus, `generate` must also accept a list as input, in which case it should "
"generate each element of the list, and then append them all together.\n"
"In the following, the first clause in `generate` handles this case, while "
"the second clause handles (1) and the third handles (2).\n"
"Note that we used the `mappend` function from section 1.7 (page 18)."
msgstr ""
"Теперь мы готовы рассмотреть главную проблему: определить функцию, которая "
"будет генерировать предложения (или именные фразы/noun phrases, или любую "
"другую категорию).\n"
"Мы будем называть эту функцию `generate`.\n"
"Ей придется разбираться с тремя случаями:\n"
"(1) в простейшем случае `generate` передается символ, с которым связан набор "
"правил перезаписи.\n"
"Мы выбираем одно из них наугад, а затем генерируем из него.(второе условие в "
"программе)\n"
"(2) Если символ не имеет возможных правил перезаписи, он должен быть "
"терминальным символом-словом, а не грамматической категорией,-и мы оставляем "
"его в покое.(третье условие в программе - по умолчанию)\n"
"На самом деле, мы возвращаем список с этим входным словом, потому что, как и "
"в предыдущей программе, мы хотим, чтобы все результаты были списками слов.\n"
"(3) в некоторых случаях, когда символ присутствует в rewrites(т.е. является "
"нетерминальным символом/категорией), мы выберем один из списка символов ему "
"соответствующих и попытаемся сгенерировать уже из этого символа.(второе "
"условие в программе)\n"
"Таким образом, `generate` также должна принимать список в качестве входных "
"данных, и в этом случае она должна выполнить генерацию для каждого элемента "
"списка (первое условие в программе), а затем соединить(append) их все "
"вместе.\n"
"Итак, первое предложение в `generate` обрабатывает этот случай, в то время "
"как второе предложение обрабатывает (1) и третье предложение - обрабатывает "
"(2).\n"
"Обратите внимание, что мы использовали функцию `mappend` из раздела 1.7 "
"(стр. 18)."

#: in/chapter2.md:280
msgid ""
"```lisp\n"
"(defun generate (phrase)\n"
"  \"Generate a random sentence or phrase\"\n"
"  (cond ((listp phrase)\n"
"         (mappend #'generate phrase))\n"
"        ((rewrites phrase)\n"
"         (generate (random-elt (rewrites phrase))))\n"
"        (t (list phrase))))\n"
"```"
msgstr ""

#: in/chapter2.md:282
msgid ""
"Like many of the programs in this book, this function is short, but dense "
"with information: the craft of programming includes knowing what *not* to "
"write, as well as what to write."
msgstr ""
"Как и многие программы в этой книге, эта функция коротка, но насыщена "
"информацией: Искусство программирования включает в себя знание того, что "
"писать, а также того, чего *не* писать."

#: in/chapter2.md:285
msgid ""
"This style of programming is called *data-driven* programming, because the "
"data (the list of rewrites associated with a category) drives what the "
"program does next.\n"
"It is a natural and easy-to-use style in Lisp, leading to concise and "
"extensible programs, because it is always possible to add a new piece of "
"data with a new association without having to modify the original program."
msgstr ""
"Этот стиль программирования называется программирование управляемое данными "
"(*data-driven* programming), потому что данные (список перезаписей, "
"связанных с категорией) управляют тем, что программа делает дальше.\n"
"Это естественный и простой в использовании стиль программирования в Lisp, "
"приводящий к сжатым и расширяемым программам, потому что всегда можно "
"добавить новый фрагмент данных с новой ассоциацией без необходимости "
"изменять исходную программу."

#: in/chapter2.md:287
msgid "Here are some examples of `generate` in use:"
msgstr "Вот несколько примеров использования функции `generate`:"

#: in/chapter2.md:290
msgid ""
"```lisp\n"
"> (generate 'sentence) => (THE TABLE SAW THE BALL)"
msgstr ""

#: in/chapter2.md:292
msgid "> (generate 'sentence) => (THE WOMAN HIT A TABLE)"
msgstr ""

#: in/chapter2.md:294
msgid "> (generate 'noun-phrase) => (THE MAN)"
msgstr ""

#: in/chapter2.md:297
msgid ""
"> (generate 'verb-phrase) (TOOK A TABLE)\n"
"```"
msgstr ""

#: in/chapter2.md:300
msgid ""
"There are many possible ways to write `generate`.\n"
"The following version uses `if` instead of `cond`:"
msgstr ""
"Существует множество возможных способов написать `generate`.\n"
"Следующая версия использует `if` вместо ``cond`:"

#: in/chapter2.md:311
msgid ""
"```lisp\n"
"(defun generate (phrase)\n"
"  \"Generate a random sentence or phrase\"\n"
"  (if (listp phrase)\n"
"      (mappend #'generate phrase)\n"
"      (let ((choices (rewrites phrase)))\n"
"        (if (null choices)\n"
"            (list phrase)\n"
"            (generate (random-elt choices))))))\n"
"```"
msgstr ""

#: in/chapter2.md:315
msgid ""
"This version uses the special form `let`, which introduces a new variable "
"(in this case, `choices`) and also binds the variable to a value.\n"
"In this case, introducing the variable saves us from calling the function "
"`rewrites` twice, as was done in the `cond` version of `generate`.\n"
"The general form of a `let` form is:"
msgstr ""
"В этой версии используется специальная форма `let`, которая вводит новую "
"переменную (в данном случае `choices`), а также связывает переменную со "
"значением.\n"
"В этом случае введение переменной избавляет нас от вызова функции `rewrites` "
"дважды, как это было сделано в версии `generate` с `cond`.\n"
"Общая форма формы `let` такова::"

#: in/chapter2.md:320
msgid ""
"```lisp\n"
"    `(let` ((*var value*)...)\n"
"        *body-containing-vars*)\n"
"```"
msgstr ""

#: in/chapter2.md:323
msgid ""
"`let` is the most common way of introducing variables that are not "
"parameters of functions.\n"
"One must resist the temptation to use a variable without introducing it:"
msgstr ""
"`let` - это наиболее распространенный способ введения переменных, которые не "
"являются параметрами функций.\n"
"Нужно сопротивляться искушению использовать переменную, не вводя ее:"

#: in/chapter2.md:332
msgid ""
"```lisp\n"
"(defun generate (phrase)\n"
"  (setf choices ...)         ;; wrong!\n"
"  ... choices ...)\n"
"```\n"
"This is wrong because the symbol `choices` now refers to a special or global "
"variable, one that may be shared or changed by other functions.\n"
"Thus, the function `generate` is not reliable, because there is no guarantee "
"that `choices` will retain the same value from the time it is set to the "
"time it is referenced again.\n"
"With `let` we introduce a brand new variable that nobody else can access; "
"therefore it is guaranteed to maintain the proper value."
msgstr ""
"```lisp\n"
"(defun generate (phrase)\n"
"  (setf choices ...)         ;; wrong!\n"
"  ... choices ...)\n"
"```\n"
"Это неверно, потому что символ `choices` теперь относится к специальной или "
"глобальной переменной, которая может быть разделяться или изменяться другими "
"функциями.\n"
"Таким образом, эта версия функции `generate` ненадежна, поскольку нет "
"никакой гарантии, что `choices` сохранит то же самое значение с момента его "
"установки(связывания/присваивания) до момента, когда на него снова "
"ссылаются(когда его будут использовать).\n"
"С помощью `let` мы вводим совершенно новую переменную, к которой никто "
"другой не может получить доступ; поэтому она гарантированно сохраняет "
"правильное значение."

#: in/chapter2.md:334
msgid ""
"&#9635; **Exercise  2.1 [m]** Write a version of `generate` that uses `cond` "
"but avoids calling `rewrites` twice."
msgstr ""
"&#9635; **Упражнение 2.1 [м]** написать версию `generate`, которая "
"использует `cond` но избегает вызова называть `rewrites` дважды."

#: in/chapter2.md:336
msgid ""
"&#9635; **Exercise  2.2 [m]** Write a version of `generate` that explicitly "
"differentiates between terminal symbols (those with no rewrite rules) and "
"nonterminal symbols."
msgstr ""
"&#9635; **Упражнение 2.2 [m]** напишите версию `generate`, которая явно "
"различает терминальные символы (те, которые не имеют правил перезаписи) и "
"нетерминальные символы."

#: in/chapter2.md:338
msgid "## 2.4 Two Paths to Follow"
msgstr "## 2.4 два пути следования"

#: in/chapter2.md:341
msgid ""
"The two versions of the preceding program represent two alternate approaches "
"that come up time and time again in developing programs: (1) Use the most "
"straightforward mapping of the problem description directly into Lisp code.\n"
"(2) Use the most natural notation available to solve the problem, and then "
"worry about writing an interpreter for that notation."
msgstr ""
"Две версии предыдущей программы представляют собой два альтернативных "
"подхода, которые возникают снова и снова при разработке программ: (1) "
"Использовать наиболее простое отображение описания проблемы непосредственно "
"в код Lisp.\n"
"(2) Использовать наиболее естественную нотацию, доступную для решения "
"проблемы, а затем позаботиться о написании интерпретатора для этой нотации."

#: in/chapter2.md:347
msgid ""
"Approach (2) involves an extra step, and thus is more work for small "
"problems.\n"
"However, programs that use this approach are often easier to modify and "
"expand.\n"
"This is especially true in a domain where there is a lot of data to account "
"for.\n"
"The grammar of natural language is one such domain-in fact, most AI problems "
"fit this description.\n"
"The idea behind approach (2) is to work with the problem as much as possible "
"in its own terms, and to minimize the part of the solution that is written "
"directly in Lisp."
msgstr ""
"Подход (2) предполагает дополнительный шаг и, таким образом, больше работы "
"для небольших проблем.\n"
"Однако программы, использующие этот подход, часто легче модифицировать и "
"расширять.\n"
"Это особенно верно в области, где есть много данных для учета.\n"
"Грамматика естественного языка является одной из таких областей-на самом "
"деле, большинство проблем ИИ соответствуют этому описанию.\n"
"Идея подхода (2) состоит в том, чтобы работать с проблемой как можно больше "
"в ее собственных терминах и минимизировать ту часть решения, которая "
"написана непосредственно на Лиспе."

#: in/chapter2.md:352
msgid ""
"Fortunately, it is very easy in Lisp to design new notations-in effect, new "
"programming languages.\n"
"Thus, Lisp encourages the construction of more robust programs.\n"
"Throughout this book, we will be aware of the two approaches.\n"
"The reader may notice that in most cases, we choose the second."
msgstr ""
"К счастью, в Lisp очень легко создавать новые нотации - фактически, новые "
"языки программирования.\n"
"Таким образом, Lisp стимулирует создание более надежных программ.\n"
"На протяжении всей этой книги мы будем помнить об этих двух подходах.\n"
"Читатель может заметить, что в большинстве случаев мы выбираем второй."

#: in/chapter2.md:354
msgid "## 2.5 Changing the Grammar without Changing the Program"
msgstr "## 2.5 изменение грамматики без изменения программы"

#: in/chapter2.md:357
msgid ""
"We show the utility of approach (2) by defining a new grammar that includes "
"adjectives, prepositional phrases, proper names, and pronouns.\n"
"We can then apply the `generate` function without modification to this new "
"grammar."
msgstr ""
"Мы покажем полезность подхода (2), определив новую грамматику, которая "
"включает прилагательные (adjectives), предложные фразы(prepositional "
"phrases), имена собственные (proper names)  и местоимения (pronouns).\n"
"Затем мы можем применить функцию `generate` без изменений к этой новой "
"грамматике."

#: in/chapter2.md:373
msgid ""
"```lisp\n"
"(defparameter *bigger-grammar*\n"
"  '((sentence -> (noun-phrase verb-phrase))\n"
"    (noun-phrase -> (Article Adj* Noun PP*) (Name) (Pronoun))\n"
"    (verb-phrase -> (Verb noun-phrase PP*))\n"
"    (PP* -> () (PP PP*))\n"
"    (Adj* -> () (Adj Adj*))\n"
"    (PP -> (Prep noun-phrase))\n"
"    (Prep -> to in by with on)\n"
"    (Adj -> big little blue green adiabatic)\n"
"    (Article -> the a)\n"
"    (Name -> Pat Kim Lee Terry Robin)\n"
"    (Noun -> man ball woman table)\n"
"    (Verb -> hit took saw liked)\n"
"    (Pronoun -> he she it these those that)))"
msgstr ""

#: in/chapter2.md:375
msgid "(setf *grammar* *bigger-grammar*)"
msgstr ""

#: in/chapter2.md:379
msgid ""
"> (generate 'sentence)\n"
"(A TABLE ON A TABLE IN THE BLUE ADIABATIC MAN SAW ROBIN\n"
" WITH A LITTLE WOMAN)"
msgstr ""

#: in/chapter2.md:384
msgid ""
"> (generate 'sentence)\n"
"(TERRY SAW A ADIABATIC TABLE ON THE GREEN BALL BY THAT WITH KIM\n"
" IN THESE BY A GREEN WOMAN BY A LITTLE ADIABATIC TABLE IN ROBIN\n"
" ON LEE)"
msgstr ""

#: in/chapter2.md:388
msgid ""
"> (generate 'sentence)\n"
"(THE GREEN TABLE HIT IT WITH HE)\n"
"```"
msgstr ""

#: in/chapter2.md:391
msgid ""
"Notice the problem with case agreement for pronouns: the program generated "
"\"with he,\" although \"with him\" is the proper grammatical form.\n"
"Also, it is clear that the program does not distinguish sensible from silly "
"output."
msgstr ""
"Обратите внимание на проблему с согласованием падежей для местоимений: "
"программа генерирует \"с ним/with he,\", хотя правильной грамматической "
"формой является \"with him\" .\n"
"Также ясно, что программа не отличает разумный вывод от глупого."

#: in/chapter2.md:393
msgid "## 2.6 Using the Same Data for Several Programs"
msgstr "## 2.6 использование одних и тех же данных для нескольких программ"

#: in/chapter2.md:397
msgid ""
"Another advantage of representing information in a declarative form-as rules "
"or facts rather than as Lisp functions-is that it can be easier to use the "
"information for multiple purposes.\n"
"Suppose we wanted a function that would generate not just the list of words "
"in a sentence but a representation of the complete syntax of a sentence.\n"
"For example, instead of the list `(a woman took a ball)`, we want to get the "
"nested list:"
msgstr ""
"Еще одно преимущество представления информации в декларативной форме - в "
"виде правил или фактов, а не в виде функций Lisp - заключается в том, что ее "
"легче использовать для различных целей.\n"
"Предположим, нам нужна функция, которая генерировала бы не только список "
"слов в предложении, но и представление полного синтаксиса предложения.\n"
"Например, вместо списка `(a woman took a ball)` мы хотим получить вложенный "
"список:"

#: in/chapter2.md:403
msgid ""
"```lisp\n"
"(SENTENCE (NOUN-PHRASE (ARTICLE A) (NOUN WOMAN))\n"
"          (VERB-PHRASE (VERB TOOK)\n"
"                       (NOUN-PHRASE (ARTICLE A) (NOUN BALL))))\n"
"```"
msgstr ""

#: in/chapter2.md:405
msgid "This corresponds to the tree that linguists draw as in figure 2.1."
msgstr ""
"Это соответствует дереву, которое лингвисты рисуют, как показано на рис. 2.1."

#: in/chapter2.md:408
msgid ""
"![Figure 2.1: Sentence Parse Tree](images/chapter2/f02-01.jpg)\n"
"**Figure 2.1: Sentence Parse Tree**"
msgstr ""
"![Figure 2.1: Sentence Parse Tree](images/chapter2/f02-01.jpg)\n"
"**Рис. 2.1: Дерево Синтаксического Анализа Предложений**"

#: in/chapter2.md:412
msgid ""
"Using the \"straightforward functions\" approach we would be stuck; we'd "
"have to rewrite every function to generate the additional structure.\n"
"With the \"new notation\" approach we could keep the grammar as it is and "
"just write one new function: a version of `generate` that produces nested "
"lists.\n"
"The two changes are to `cons` the category onto the front of each rewrite, "
"and then not to `append` together the results but rather just list them with "
"`mapcar`:"
msgstr ""
"Используя подход (1) \"простых функций\", мы застряли бы; нам пришлось бы "
"переписывать каждую функцию, чтобы создать дополнительную структуру.\n"
"С помощью подхода (2) \"новая нотация\" мы могли бы сохранить грамматику "
"такой, какая она есть, и просто написать одну новую функцию: версию "
"`generate`, которая создает вложенные списки.\n"
"Эти два изменения заключаются в том, чтобы `cons`(создать список) из "
"категории в передней части каждой перезаписи, а затем не выполнять `append` "
"для всех результатов, а просто перечислить их с помощью `mapcar`:"

#: in/chapter2.md:424
msgid ""
"```lisp\n"
"(defun generate-tree (phrase)\n"
"  \"Generate a random sentence or phrase,\n"
"  with a complete parse tree.\"\n"
"  (cond ((listp phrase)\n"
"         (mapcar #'generate-tree phrase))\n"
"        ((rewrites phrase)\n"
"         (cons phrase\n"
"               (generate-tree (random-elt (rewrites phrase)))))\n"
"        (t (list phrase))))\n"
"```"
msgstr ""

#: in/chapter2.md:426
msgid "Here are some examples:"
msgstr "Вот несколько примеров:"

#: in/chapter2.md:436
msgid ""
"```lisp\n"
"> (generate-tree 'Sentence)\n"
"(SENTENCE (NOUN-PHRASE (ARTICLE A)\n"
"                       (ADJ*)\n"
"                       (NOUN WOMAN)\n"
"                       (PP*))\n"
"      (VERB-PHRASE (VERB HIT)\n"
"                       (NOUN-PHRASE (PRONOUN HE))\n"
"                       (PP*)))"
msgstr ""

#: in/chapter2.md:443
msgid ""
"> (generate-tree 'Sentence)\n"
"(SENTENCE (NOUN-PHRASE (ARTICLE A)\n"
"                       (NOUN WOMAN))\n"
"          (VERB-PHRASE (VERB TOOK)\n"
"                       (NOUN-PHRASE (ARTICLE A) (NOUN BALL))))\n"
"```"
msgstr ""

#: in/chapter2.md:448
msgid ""
"As another example of the one-data/multiple-program approach, we can develop "
"a function to generate all possible rewrites of a phrase.\n"
"The function `generate-all` returns a list of phrases rather than just one, "
"and we define an auxiliary function, `combine-all`, to manage the "
"combination of results.\n"
"Also, there are four cases instead of three, because we have to check for "
"nil explicitly.\n"
"Still, the complete program is quite simple:"
msgstr ""
"В качестве еще одного примера подхода \"одини-данные/несколько-программы\" "
"мы можем разработать функцию для генерации всех возможных перезаписей "
"фразы.\n"
"Функция `generate-all` возвращает список фраз, а не только одну, и мы "
"определяем вспомогательную функцию `combine-all` для управления комбинацией "
"результатов.\n"
"Кроме того, есть четыре случая вместо трех, потому что мы должны явно "
"проверить на nil.\n"
"Тем не менее, полная программа довольно проста:"

#: in/chapter2.md:459
msgid ""
"```lisp\n"
"(defun generate-all (phrase)\n"
"  \"Generate a list of all possible expansions of this phrase.\"\n"
"  (cond ((null phrase) (list nil))\n"
"        ((listp phrase)\n"
"         (combine-all (generate-all (first phrase))\n"
"                      (generate-all (rest phrase))))\n"
"        ((rewrites phrase)\n"
"         (mappend #'generate-all (rewrites phrase)))\n"
"        (t (list (list phrase)))))"
msgstr ""

#: in/chapter2.md:468
msgid ""
"(defun combine-all (xlist ylist)\n"
"  \"Return a list of lists formed by appending a y to an x.\n"
"  E.g., (combine-all '((a) (b)) '((1) (2)))\n"
"  -> ((A 1) (B 1) (A 2) (B 2)).\"\n"
"  (mappend #'(lambda (y)\n"
"               (mapcar #'(lambda (x) (append x y)) xlist))\n"
"           ylist))\n"
"```"
msgstr ""

#: in/chapter2.md:472
msgid ""
"We can now use `generate-all` to test our original little grammar.\n"
"Note that a serious drawback of `generate-all` is that it can't deal with "
"recursive grammar rules like 'Adj\\* => Adj + Adj\\*' that appear in "
"`*bigger-grammar*,` since these lead to an infinite number of outputs.\n"
"But it works fine for finite languages, like the language generated by "
"`*simple-grammar*`:"
msgstr ""
"Теперь мы можем использовать `generate-all` для проверки нашей оригинальной "
"маленькой грамматики.\n"
"Обратите внимание, что серьезным недостатком `generate-all` является то, что "
"он не может иметь дело с рекурсивными грамматическими правилами, такими как "
"'Adj\\* => Adj + Adj\\*', которые появляются в `*bigger-grammar*`, поскольку "
"они приводят к бесконечному выводу.\n"
"Но она прекрасно работает для конечных языков, таких как язык, порожденный "
"`*simple-grammar*`:"

#: in/chapter2.md:475
msgid ""
"```lisp\n"
"> (generate-all 'Article)"
msgstr ""

#: in/chapter2.md:477
msgid "((THE) (A))"
msgstr ""

#: in/chapter2.md:479
msgid "> (generate-all 'Noun)"
msgstr ""

#: in/chapter2.md:481
msgid "((MAN) (BALL) (WOMAN) (TABLE))"
msgstr ""

#: in/chapter2.md:485
msgid ""
"> (generate-all 'noun-phrase)\n"
"((A MAN) (A BALL) (A WOMAN) (A TABLE)\n"
" (THE MAN) (THE BALL) (THE WOMAN) (THE TABLE))"
msgstr ""

#: in/chapter2.md:489
msgid ""
"> (length (generate-all 'sentence))\n"
"256\n"
"```"
msgstr ""

#: in/chapter2.md:491
msgid ""
"There are 256 sentences because every sentence in this language has the form "
"Article-Noun-Verb-Article-Noun, and there are two articles, four nouns and "
"four verbs (2 x 4 x 4 x 2 x 4 = 256)."
msgstr ""
"Есть 256 предложений, потому что каждое предложение в этом языке имеет форму "
"артикль-существительное-глагол-артикль-существительное(Article-Noun-Verb-"
"Article-Noun), и есть два артикля, четыре существительных и четыре глагола "
"(2 х 4 х 4 х 2 х 4 = 256)."

#: in/chapter2.md:493
msgid "## 2.7 Exercises"
msgstr "## 2.7 Упражнения"

#: in/chapter2.md:496
msgid ""
"&#9635; **Exercise  2.3 [h]** Write a trivial grammar for some other "
"language.\n"
"This can be a natural language other than English, or perhaps a subset of a "
"computer language."
msgstr ""
"&#9635; **Exercise  2.3 [h]** Напишите тривиальную грамматику для какого-"
"нибудь другого языка.\n"
"Это может быть естественный язык, отличный от английского, или, возможно, "
"подмножество компьютерного языка."

#: in/chapter2.md:499
msgid ""
"&#9635; **Exercise  2.4 [m]** One way of describing `combine-all` is that it "
"calculates the cross-product of the function `append` on the argument "
"lists.\n"
"Write the higher-order function `cross-product`, and define `combine-all` in "
"terms of it."
msgstr ""
"&#9635; **Exercise  2.4 [m]** Один из способов определения функции `combine-"
"all` заключается в том, что она вычисляет перекрестное произведение функции "
"`append` по списку аргументов.\n"
"Напишите функцию более высокого порядка `cross-product` и определите "
"`combine-all` в ее терминах."

#: in/chapter2.md:501
msgid ""
"The moral is to make your code as general as possible, because you never "
"know what you may want to do with it next."
msgstr ""
"Мораль заключается в том, чтобы сделать свой код как можно более общим, "
"потому что вы никогда не знаете, что вы можете сделать с ним дальше."

#: in/chapter2.md:503
msgid "## 2.8 Answers"
msgstr "## 2.8 Ответы"

#: in/chapter2.md:505
msgid "### Answer 2.1"
msgstr ""

#: in/chapter2.md:516
msgid ""
"```lisp\n"
"  (defun generate (phrase)\n"
"  \"Generate a random sentence or phrase\"\n"
"  (let ((choices nil))\n"
"    (cond ((listp phrase)\n"
"        (mappend #'generate phrase))\n"
"       ((setf choices (rewrites phrase))\n"
"        (generate (random-elt choices)))\n"
"       (t (list phrase)))))\n"
"```"
msgstr ""

#: in/chapter2.md:518
msgid "### Answer 2.2"
msgstr ""

#: in/chapter2.md:527
msgid ""
"```lisp\n"
"(defun generate (phrase)\n"
"  \"Generate a random sentence or phrase\"\n"
"  (cond ((listp phrase)\n"
"         (mappend #'generate phrase))\n"
"        ((non-terminal-p phrase)\n"
"         (generate (random-elt (rewrites phrase))))\n"
"        (t (list phrase))))"
msgstr ""

#: in/chapter2.md:532
msgid ""
"(defun non-terminal-p (category)\n"
"  \"True if this is a category in the grammar.\"\n"
"  (not (null (rewrites category))))\n"
"```"
msgstr ""

#: in/chapter2.md:534
msgid "### Answer 2.4"
msgstr ""

#: in/chapter2.md:542
msgid ""
"```lisp\n"
"(defun cross-product (fn xlist ylist)\n"
"  \"Return a list of all (fn x y) values.\"\n"
"  (mappend #'(lambda (y)\n"
"               (mapcar #'(lambda (x) (funcall fn x y))\n"
"                       xlist))\n"
"           ylist))"
msgstr ""

#: in/chapter2.md:547
msgid ""
"(defun combine-all (xlist ylist)\n"
"  \"Return a list of lists formed by appending a y to an x\"\n"
"  (cross-product #'append xlist ylist))\n"
"```"
msgstr ""

#: in/chapter2.md:549
msgid "Now we can use the `cross-product` in other ways as well:"
msgstr "Теперь мы можем использовать `cross-product` и другими способами:"

#: in/chapter2.md:555
msgid ""
"```\n"
"> (cross-product #'+ '(1 2 3) '(10 20 30))\n"
"(11 12 13\n"
" 21 22 23\n"
" 31 32 33)"
msgstr ""

#: in/chapter2.md:567
msgid ""
"> (cross-product #'list '(a b c d e f g h)\n"
"                        '(1 2 3 4 5 6 7 8))\n"
"((A 1) (B 1) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)\n"
" (A 2) (B 2) (C 2) (D 2) (E 2) (F 2) (G 2) (H 2)\n"
" (A 3) (B 3) (C 3) (D 3) (E 3) (F 3) (G 3) (H 3)\n"
" (A 4) (B 4) (C 4) (D 4) (E 4) (F 4) (G 4) (H 4)\n"
" (A 5) (B 5) (C 5) (D 5) (E 5) (F 5) (G 5) (H 5)\n"
" (A 6) (B 6) (C 6) (D 6) (E 6) (F 6) (G 6) (H 6)\n"
" (A 7) (B 7) (C 7) (D 7) (E 7) (F 7) (G 7) (H 7)\n"
" (A 8) (B 8) (C 8) (D 8) (E 8) (F 8) (G 8) (H 8))\n"
"```"
msgstr ""

#: in/chapter2.md:570
msgid ""
"----------------------\n"
"<a id=\"fn02-1\"></a>\n"
"[1](#tfn02-1) We will soon see \"Kleene plus\" notation, wherein *PP+* "
"denotes one or more repetition of *PP*."
msgstr ""
"----------------------\n"
"<a id=\"fn02-1\"></a>\n"
"[1](#tfn02-1) Вскоре мы увидим обозначение \"Kleene plus\", где *PP+* "
"обозначает одно или несколько повторений *PP*."
