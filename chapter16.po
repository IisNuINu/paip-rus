#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter16.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-16 21:36+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter16.md:3
msgid ""
"# Chapter 16\n"
"## Expert Systems"
msgstr ""
"# Глава 16\n"
"## Экспертные Системы"

#: in/chapter16.md:5
msgid "> An expert is one who knows more and more about less and less."
msgstr ""
"> Эксперт - это тот, кто знает все больше и больше о все меньшем и меньшем."

#: in/chapter16.md:7
msgid "> -Nicholas Murray Butler (1862-1947)"
msgstr ""

#: in/chapter16.md:12
msgid ""
"In the 1970s there was terrifie interest in the area of *knowledge-based "
"expert systems*.\n"
"An expert system or knowledge-based system is one that solves problems by "
"applying knowledge that has been garnered from one or more experts in a "
"field.\n"
"Since these experts will not in general be programmers, they will very "
"probably express their expertise in terms that cannot immediately be "
"translated into a program.\n"
"It is the goal of expert-system research to come up with a representation "
"that is flexible enough to handle expert knowledge, but still capable of "
"being manipulated by a computer program to come up with solutions."
msgstr ""
"В 1970-х годах был ужасный интерес к области *экспертных систем, основанных "
"на знаниях*.\n"
"Экспертная система или система, основанная на знаниях, - это система, "
"которая решает проблемы, применяя знания, полученные от одного или "
"нескольких экспертов в данной области.\n"
"Поскольку эти эксперты, как правило, не являются программистами, они, скорее "
"всего, выразят свои знания в терминах, которые нельзя сразу перевести в "
"программу.\n"
"Целью исследования экспертных систем является создание представления, "
"достаточно гибкого для обработки экспертных знаний, но все же пригодного для "
"манипулирования компьютерной программой для выработки решений."

#: in/chapter16.md:15
msgid ""
"A plausible candidate for this representation is as logical facts and rules, "
"as in Prolog.\n"
"However, there are three areas where Prolog provides poor support for a "
"general knowledge-based system:"
msgstr ""
"Правдоподобный кандидат на это представление - такие же логические факты и "
"правила, как в Прологе.\n"
"Однако есть три области, в которых Пролог плохо поддерживает системемы, "
"основанные на общих знаниях:"

#: in/chapter16.md:19
msgid ""
"*   Reasoning with uncertainty.\n"
"Prolog only deals with the black-and-white world of facts that are clearly "
"true or false (and it doesn't even handle false very well).\n"
"Often experts will express rules of thumb that are \"likely\" or \"90% "
"certain.\""
msgstr ""
"* Рассуждения с неуверенностью(Нечеткие рассуждения).\n"
"Пролог имеет дело только с черно-белым миром фактов, которые явно истинны "
"или ложны (и он даже не очень хорошо справляется с ложью).\n"
"Часто эксперты выражают эмпирические правила, которые \"вероятны(likely)\" "
"или \"уверены(certain) на 90%\"."

#: in/chapter16.md:23
msgid ""
"*   Explanation.\n"
"Prolog gives solutions to queries but no indication of how those solutions "
"were derived.\n"
"A system that can explain its solutions to the user in understandable terms "
"will be trusted more."
msgstr ""
"* Объяснение.\n"
"Prolog дает решения для запросов, но не указывает, как эти решения были "
"получены.\n"
"Система, которая может объяснить пользователю свои решения в понятной форме, "
"будет пользоваться большим доверием."

#: in/chapter16.md:29
msgid ""
"*   Flexible flow of control.\n"
"Prolog works by backward-chaining from the goal.\n"
"In some cases, we may need more varied control strategy.\n"
"For example, in medical diagnosis, there is a prescribed order for acquiring "
"certain information about the patient.\n"
"A medical system must follow this order, even if it doesn't fit in with the "
"backward-chaining strategy."
msgstr ""
"* Гибкий выбор типа потока управления.\n"
"Prolog работает путем обратной цепочки от цели.\n"
"В некоторых случаях нам может потребоваться более разнообразная стратегия "
"контроля/управления.\n"
"Например, в медицинской диагностике прописан порядок получения определенной "
"информации о пациенте.\n"
"Медицинская система должна следовать этому порядку, даже если он не "
"вписывается в стратегию обратной цепочки."

#: in/chapter16.md:33
msgid ""
"The early expert systems used a wide variety of techniques to attack these "
"problems.\n"
"Eventually, it became clear that certain techniques were being used "
"frequently, and they were captured in *expert-system shells*: specialized "
"programming environments that helped acquire knowledge from the expert and "
"use it to solve problems and provide explanations.\n"
"The idea was that these shells would provide a higher level of abstraction "
"than just Lisp or Prolog and would make it easy to write new expert systems."
msgstr ""
"Ранние экспертные системы использовали самые разные методы для решения этих "
"проблем.\n"
"В конце концов стало ясно, что определенные методы используются часто, и они "
"были зафиксированы в *оболочках экспертных систем*: специализированных "
"средах программирования, которые помогали получать знания от экспертов и "
"использовать их для решения проблем и предоставления объяснений.\n"
"Идея заключалась в том, что эти оболочки обеспечат более высокий уровень "
"абстракции, чем просто Lisp или Prolog, и упростят написание новых "
"экспертных систем."

#: in/chapter16.md:40
msgid ""
"The MYCIN expert system was one of the earliest and remains one of the best "
"known.\n"
"It was written by Dr.\n"
"Edward Shortliffe in 1974 as an experiment in medical diagnosis.\n"
"MYCIN was designed to prescribe antibiotic therapy for bacterial blood "
"infections, and when completed it was judged to perform this task as well as "
"experts in the field.\n"
"Its name comes from the common suffix in drugs it prescribes: erythromycin, "
"clindamycin, and so on.\n"
"The following is a slightly modified version of one of MYCIN's rules, along "
"with an English paraphrase generated by the system:"
msgstr ""
"Экспертная система MYCIN была одной из первых и остается одной из самых "
"известных.\n"
"Это было написано доктором Эдвардо Шортлиффом в 1974 году как эксперимент по "
"медицинской диагностике.\n"
"MYCIN был разработана для назначения антибактериальной терапии при "
"бактериальных инфекциях крови, и когда она была завершена, она была оценена "
"для выполнения этой задачи как эксперт в этой области\n"
"Её название происходит от общего суффикса лекарств, которые он назначает: "
"эритромицин, клиндамицин и так далее.\n"
"Ниже приводится слегка измененная версия одного из правил MYCIN, а также "
"перефразирование на английский язык, созданное системой:"

#: in/chapter16.md:44
msgctxt "in/chapter16.md:44"
msgid ""
"```lisp\n"
"(defrule 52\n"
"```"
msgstr ""

#: in/chapter16.md:46
msgctxt "in/chapter16.md:46"
msgid "  `if (site culture is blood)`"
msgstr ""

#: in/chapter16.md:48
msgid "    `(gram organism is neg)`"
msgstr ""

#: in/chapter16.md:50
msgid "    `(morphology organism is rod)`"
msgstr ""

#: in/chapter16.md:52
msgid "    `(burn patient is serious)`"
msgstr ""

#: in/chapter16.md:54
msgctxt "in/chapter16.md:54"
msgid "  `then .4`"
msgstr ""

#: in/chapter16.md:56
msgid "    `(identity organism is pseudomonas))`"
msgstr ""

#: in/chapter16.md:60
msgid ""
"```lisp\n"
"Rule 52:\n"
"```"
msgstr ""

#: in/chapter16.md:62
msgid "  `If`"
msgstr ""

#: in/chapter16.md:64
msgid "    `1) THE SITE OF THE CULTURE IS BLOOD`"
msgstr ""

#: in/chapter16.md:66
msgid "    `2) THE GRAM OF THE ORGANISM IS NEG`"
msgstr ""

#: in/chapter16.md:68
msgid "    `3) THE MORPHOLOGY OF THE ORGANISM IS ROD`"
msgstr ""

#: in/chapter16.md:70
msgid "    `4) THE BURN OF THE PATIENT IS SERIOUS`"
msgstr ""

#: in/chapter16.md:72
msgid "  `Then there is weakly suggestive evidence (0.4) that`"
msgstr ""

#: in/chapter16.md:74
msgid "    `1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS`"
msgstr ""

#: in/chapter16.md:78
msgid ""
"MYCIN lead to the development of the EMYCIN expert-system shell.\n"
"EMYCIN stands for \"essential MYCIN,\" although it is often mispresented as "
"\"empty MYCIN.\"\n"
"Either way, the name refers to the shell for acquiring knowledge, reasoning "
"with it, and explaining the results, without the specific medical knowledge."
msgstr ""
"MYCIN привел к разработке оболочки экспертной системы EMYCIN.\n"
"EMYCIN означает \"сущность(essential) MYCIN\", хотя его часто неправильно "
"представляют как \"пустой(empty) MYCIN\".\n"
"В любом случае, название относится к оболочке для получения знаний, "
"рассуждений с ее помощью и объяснения результатов без конкретных медицинских "
"знаний."

#: in/chapter16.md:87
msgid ""
"EMYCIN is a backward-chaining rule interpreter that has much in common with "
"Prolog.\n"
"However, there are four important differences.\n"
"First, and most importantly, EMYCIN deals with uncertainty.\n"
"Instead of insisting that all predications be true or false, EMYCIN "
"associates a *certainty factor* with each predication.\n"
"Second, EMYCIN caches the results of its computations so that they need not "
"be duplicated.\n"
"Third, EMYCIN provides an easy way for the system to ask the user for "
"information.\n"
"Fourth, it provides explanations of its behavior.\n"
"This can be summed up in the equation:"
msgstr ""
"EMYCIN - это интерпретатор правил с обратной цепочкой, который имеет много "
"общего с Prolog.\n"
"Однако есть четыре важных отличия.\n"
"Во-первых, и это наиболее важно, EMYCIN имеет дело с неопределенностью.\n"
"Вместо того чтобы настаивать на том, чтобы все предсказания были истинными "
"или ложными, EMYCIN связывает с каждым предсказанием *фактор "
"достоверности*.\n"
"Во-вторых, EMYCIN кэширует результаты своих вычислений, чтобы их не нужно "
"было дублировать.\n"
"В-третьих, EMYCIN предоставляет системе простой способ запросить информацию "
"у пользователя.\n"
"В-четвертых, он дает объяснения своего поведения.\n"
"Это можно выразить уравнением:"

#: in/chapter16.md:91
msgid ""
"```lisp\n"
"EMYCIN = Prolog + uncertainty + caching + questions + explanations\n"
"```"
msgstr ""

#: in/chapter16.md:96
msgid ""
"We will first cover the ways EMYCIN is different from Prolog.\n"
"After that we will return to the main core of EMYCIN, the backward-chaining "
"rule interpreter.\n"
"Finally, we will show how to add some medical knowledge to EMYCIN to "
"reconstruct MYCIN.\n"
"A glossary of the program is in [figure  16.1](#f0010)."
msgstr ""
"Сначала мы рассмотрим отличия EMYCIN от Prolog.\n"
"После этого мы вернемся к основному ядру EMYCIN, интерпретатору правил с "
"обратной цепочкой.\n"
"Наконец, мы покажем, как добавить некоторые медицинские знания к EMYCIN для "
"воссоздания MYCIN.\n"
"Глоссарий программы находится на [рисунок 16.1](#f0010)."

#: in/chapter16.md:101
msgid ""
"| []()                                         |\n"
"|----------------------------------------------|\n"
"| ![f16-01](images/chapter16/f16-01.jpg)       |\n"
"| Figure 16.1: Glossary for the EMYCIN Program |"
msgstr ""
"| []()                                         |\n"
"|----------------------------------------------|\n"
"| ![f16-01](images/chapter16/f16-01.jpg)       |\n"
"| Рисунок 16.1: Глоссарий программы EMYCIN |"

#: in/chapter16.md:103
msgid "*(ed: this could be a markdown table)*"
msgstr ""

#: in/chapter16.md:105
msgid "## 16.1 Dealing with Uncertainty"
msgstr "## 16.1 Работа с неопределенностью"

#: in/chapter16.md:109
msgid ""
"EMYCIN deals with uncertainty by replacing the two boolean values, true and "
"false, with a range of values called *certainty factors*.\n"
"These are numbers from -  1 (false) to +  1 (true), with 0 representing a "
"complete unknown.\n"
"In Lisp:"
msgstr ""
"EMYCIN имеет дело с неопределенностью, заменяя два логических значения, "
"истинное и ложное, на диапазон значений, называемых *факторами "
"достоверности*.\n"
"Это числа от -1 (ложь) до + 1 (истина), где 0 представляет собой полностью "
"неизвестное.\n"
"В Лиспе:"

#: in/chapter16.md:115
msgid ""
"```lisp\n"
"(defconstant true +  1.0)\n"
"(defconstant false -  1.0)\n"
"(defconstant unknown 0.0)\n"
"```"
msgstr ""

#: in/chapter16.md:126
msgid ""
"To define the logic of certainty factors, we need to define the logical "
"operations, such as `and, or`, and `not.` The first operation to consider is "
"the combination of two distinct pieces of evidence expressed as certainty "
"factors.\n"
"Suppose we are trying to determine the chances of a patient having disease "
"&Chi;.\n"
"Assume we have a population of prior patients that have been given two lab "
"tests.\n"
"One test says that 60% of the patients have the disease and the other says "
"that 40% have it.\n"
"How should we combine these two pieces of evidence into one?\n"
"Unfortunately, there is no way to answer that question correctly without "
"knowing more about the *dependence* of the two sources on each other.\n"
"Suppose the first test says that 60% of the patients (who all happen to be "
"male) have the disease, and the second says that 40% (who all happen to be "
"female) have it.\n"
"Then we should conclude that 100% have it, because the two tests cover the "
"entire population.\n"
"On the other hand, if the first test is positive only for patients that are "
"70 years old or older, and the second is positive only for patients that are "
"80 or older, then the second is just a subset of the first.\n"
"This adds no new information, so the correct answer is 60% in this case."
msgstr ""
"Чтобы определить логику факторов достоверности, нам необходимо определить "
"логические операции, такие как `and/и`, `or/или`, `not/не`. Первая операция, "
"которую следует рассмотреть, - это сочетание двух различных частей "
"доказательств, выраженных как факторы определенности.\n"
"Предположим, мы пытаемся определить вероятность того, что у пациента есть "
"заболевание &Chi;.\n"
"Предположим, что у нас есть группа предыдущих пациентов, которым были даны "
"два лабораторных теста.\n"
"Первый тест говорит, что у 60% пациентов есть заболевание, а второй говорит, "
"что  оно есть у 40%.\n"
"Как нам объединить эти два доказательства в одно?\n"
"К сожалению, невозможно правильно ответить на этот вопрос, не зная больше о "
"*зависимости* двух источников друг от друга.\n"
"Предположим, что первый тест показывает, что 60% пациентов (которые все "
"оказались мужчинами) имеют болезнь, а второй говорит, что 40% (которые все "
"оказались женщинами) болеют.\n"
"Тогда мы должны сделать вывод, что он есть у 100%, потому что два теста "
"охватывают все население.\n"
"С другой стороны, если первый тест положителен только для пациентов в "
"возрасте 70 лет и старше, а второй положителен только для пациентов в "
"возрасте 80 лет и старше, то второй является лишь частью первого.\n"
"Это не добавляет никакой новой информации, поэтому в данном случае "
"правильный ответ - 60%."

#: in/chapter16.md:130
msgid ""
"In [section 16.9](#s0050) we will consider ways to take this kind of "
"reasoning into account.\n"
"For now, we will present the combination method actually used in EMYCIN.\n"
"It is defined by the formula:"
msgstr ""
"В [section 16.9](#s0050) мы рассмотрим способы учета такого рода "
"рассуждений.\n"
"А пока мы представим метод комбинирования, фактически используемый в "
"EMYCIN.\n"
"Он определяется формулой:"

#: in/chapter16.md:132
msgid "combine (A, B) ="
msgstr ""

#: in/chapter16.md:134
msgid "A+B-AB;A,B>0A+B+AB;A,B<0A+B1-minAB;otherwise"
msgstr ""

#: in/chapter16.md:136
msgid "![si1_e](images/chapter16/si1_e.gif)"
msgstr ""

#: in/chapter16.md:139
msgid ""
"According to this formula, combine(.60,.40) = .76, which is a compromise "
"between the extremes of .60 and 1.00.\n"
"It is the same as the probability p(A or B), assuming that A and B are "
"independent."
msgstr ""
"Согласно этой формуле, combine(.60,.40) = .76, что является компромиссом "
"между крайними значениями 0,60 и 1,00.\n"
"Это то же самое, что вероятность p(A or B), если предположить, что A и B "
"независимы."

#: in/chapter16.md:143
msgid ""
"However, it should be clear that certainty factors are not the same thing as "
"probabilities.\n"
"Certainty factors attempt to deal with disbelief as well as belief, but they "
"do not deal with dependence and independence.\n"
"The EMYCIN combination function has a number of desirable properties:"
msgstr ""
"Однако должно быть ясно, что факторы уверенности - это не то же самое, что "
"вероятности.\n"
"Факторы уверенности пытаются справиться с недоверием так же, как с доверием, "
"но не с зависимостью и независимостью.\n"
"Функция комбинирования EMYCIN имеет ряд желаемых свойств:"

#: in/chapter16.md:145
msgid "*   It always computes a number between -  1 and +  1."
msgstr "* Он всегда вычисляет число от - 1 до +1."

#: in/chapter16.md:147
msgid "*   Combining unknown (zero) with anything leaves it unchanged."
msgstr "* Комбинирование неизвестного (нуля) с чем-либо ничего не меняет."

#: in/chapter16.md:149
msgid "*   Combining true with anything (except false) gives true."
msgstr "* Объединение истины с чем угодно (кроме ложи) дает истину."

#: in/chapter16.md:151
msgid "*   Combining true and false is an error."
msgstr "* Объединение истины и лжи является ошибкой."

#: in/chapter16.md:153
msgid "*   Combining two opposites gives unknown."
msgstr "* Комбинирование двух противоположностей дает неизвестное."

#: in/chapter16.md:155
msgid "*   Combining two positives (except true) gives a larger positive."
msgstr ""
"* Объединение/комбинирование двух положительных результатов (кроме "
"истинного) дает больший положительный результат."

#: in/chapter16.md:157
msgid "*   Combining a positive and a negative gives something in between."
msgstr "* Комбинирование положительного и отрицательного дает нечто среднее."

#: in/chapter16.md:160
msgid ""
"So far we have seen how to combine two separate pieces of evidence for the "
"same hypothesis.\n"
"In other words, if we have the two rules:"
msgstr ""
"До сих пор мы видели, как combine(комбинирование) двух отдельных "
"доказательств одной и той же гипотезы.\n"
"Другими словами, если у нас есть два правила:"

#: in/chapter16.md:162
msgid "A => C"
msgstr ""

#: in/chapter16.md:164
msgid "B => C"
msgstr ""

#: in/chapter16.md:167
msgid ""
"and we know A with certainty factor (cf) .6 and B with cf .4, then we can "
"conclude C with cf .76.\n"
"But consider a rule with a conjunction in the premise:"
msgstr ""
"и мы знаем A с коэффициентом достоверности (certainty factor - cf) .6 и B со "
"значением cf .4, тогда мы можем заключить C с cf  .76.\n"
"Но рассмотрим правило с коньюнкцией(объединением) в посылке:"

#: in/chapter16.md:169
msgid "A and B => C"
msgstr ""

#: in/chapter16.md:174
msgid ""
"Combining A and B in this case is quite different from combining them when "
"they are in separate rules.\n"
"EMYCIN chooses to combine conjunctions by taking the minimum of each "
"conjunct's certainty factor.\n"
"If certainty factors were probabilities, this would be equivalent to "
"assumming dependence between conjuncts in a rule.\n"
"(If the conjuncts were independent, then the product of the probabilities "
"would be the correct answer.) So EMYCIN is making the quite reasonable (but "
"sometimes incorrect) assumption that conditions that are tied together in a "
"single rule will be dependent on one another, while conditions in separate "
"rules are independent."
msgstr ""
"Комбинирование A и B в этом случае сильно отличается от их комбинирования, "
"когда они находятся в отдельных правилах.\n"
"EMYCIN выбирает комбинирование объединений, беря минимум фактора "
"уверенности(cf) каждого конъюнкта.\n"
"Если бы факторы уверенности были вероятностями, это было бы эквивалентно "
"предположению зависимости между конъюнктами в правиле.\n"
"(Если бы конъюнкты были независимыми, то правильным ответом было бы "
"произведение вероятностей.) Итак, EMYCIN делает вполне разумное (но иногда "
"неверное) предположение, что условия, связанные вместе в одном правиле, "
"будут зависеть друг от друга, в то время как условия в отдельных правилах "
"независимы."

#: in/chapter16.md:177
msgid ""
"The final complication is that rules themselves may be uncertain.\n"
"That is, MYCIN accommodates rules that look like:"
msgstr ""
"Последняя сложность заключается в том, что сами правила могут быть "
"неопределенными.\n"
"То есть MYCIN использует правила, которые выглядят так:"

#: in/chapter16.md:179
msgid "A and B => .9C"
msgstr ""

#: in/chapter16.md:186
msgid ""
"to say that A and B imply C with .9 certainty.\n"
"EMYCIN simply multiplies the rule's cf by the combined cf of the premise.\n"
"So if A has cf .6 and B has cf .4, then the premise as a whole has cf .4 "
"(the minimum of A and B), which is multiplied by .9 to get .36.\n"
"The .36 is then combined with any exisiting cf for C.\n"
"If C is previously unknown, then combining .36 with 0 will give .36.\n"
"If C had a prior cf of .76, then the new cf would be .36 + .76 - (.36 x .76) "
"= .8464."
msgstr ""
"говорят, что A и B подразумевают C с уверенностью(cf) .9.\n"
"EMYCIN просто умножает cf правила на комбинированный cf предпосылки.\n"
"Таким образом, если A имеет cf .6, а B имеет cf .4, то посылка в целом имеет "
"cf .4 (минимум A и B), который умножается на .9, чтобы получить .36.\n"
"Затем .36 комбинируется с любыми существующими cf для C.\n"
"Если C заранее неизвестен, то объединение .36 с 0 даст .36.\n"
"Если бы у C был предыдущий cf равный .76, то новый cf был бы .36 + .76 - "
"(.36 x .76) = .8464."

#: in/chapter16.md:188
msgid "Here are the EMYCIN certainty factor combination functions in Lisp:"
msgstr "Вот функции комбинации факторов достоверности EMYCIN в Lisp:"

#: in/chapter16.md:199
msgid ""
"```lisp\n"
"(defun cf-or (a b)\n"
"  \"Combine the certainty factors for the formula (A or B).\n"
"  This is used when two rules support the same conclusion.\"\n"
"  (cond ((and (> a 0) (> b 0))\n"
"         (+ a b (* -1 a b)))\n"
"        ((and (< a 0) (< b 0))\n"
"         (+ a b (* a b)))\n"
"        (t (/ (+ a b)\n"
"              (- 1 (min (abs a) (abs b)))))))"
msgstr ""

#: in/chapter16.md:204
msgid ""
"(defun cf-and (a b)\n"
"  \"Combine the certainty factors for the formula (A and B).\"\n"
"  (min a b))\n"
"```"
msgstr ""

#: in/chapter16.md:209
msgid ""
"Certainty factors can be seen as a generalization of truth values.\n"
"EMYCIN is a backward-chaining rule system that combines certainty factors "
"according to the functions laid out above.\n"
"But if we only used the certainty factors `true` and `false`, then EMYCIN "
"would behave exactly like Prolog, returning only answers that are definitely "
"true.\n"
"It is only when we provide fractional certainty factors that the additional "
"EMYCIN mechanism makes a difference."
msgstr ""
"Факторы уверенности можно рассматривать как обобщение истинностных "
"значений.\n"
"EMYCIN - это система правил с обратной связью, которая объединяет факторы "
"достоверности в соответствии с функциями, изложенными выше.\n"
"Но если бы мы использовали только факторы достоверности true и false, тогда "
"EMYCIN вел бы себя точно так же, как Prolog, возвращая только ответы, "
"которые определенно истинны.\n"
"Дополнительный механизм EMYCIN имеет значение только тогда, когда мы "
"предоставляем частичные факторы уверенности."

#: in/chapter16.md:215
msgid ""
"Truth values actually serve two purposes in Prolog.\n"
"They determine the final answer, yes, but they also determine when to eut "
"off search: if any one of the premises of a rule is false, then there is no "
"sense looking at the other premises.\n"
"If in EMYCIN we only eut off the search when one of the premises was "
"absolutely false, then we might have to search through a lot of rules, only "
"to yield answers with very low certainty factors.\n"
"Instead, EMYCIN arbitrarily cuts off the search and considers a premise "
"false when it has a certainty factor below .2.\n"
"The following functions support this arbitrary cutoff point:"
msgstr ""
"На самом деле значения истинности служат в Прологе двум целям.\n"
"Они определяют окончательный ответ, да, но они также определяют, когда "
"прекращать поиск: если какая-либо из посылок правила ложна, то нет смысла "
"смотреть на другие посылки.\n"
"Если в EMYCIN мы прекращаем поиск только тогда, когда одна из предпосылок "
"была абсолютно ложной, тогда нам, возможно, пришлось бы перебирать множество "
"правил, только чтобы получить ответы с очень низкими факторами уверенности.\n"
"Вместо этого EMYCIN произвольно прекращает поиск и считает предпосылку "
"ложной, если ее коэффициент достоверности(фактор уверенности) ниже .2.\n"
"Следующие функции поддерживают эту произвольную точку отсечения:"

#: in/chapter16.md:219
msgid ""
"```lisp\n"
"(defconstant cf-cut-off 0.2\n"
"  \"Below this certainty we cut off search.\")"
msgstr ""

#: in/chapter16.md:223
msgid ""
"(defun true-p (cf)\n"
"  \"Is this certainty factor considered true?\"\n"
"  (and (cf-p cf) (> cf cf-cut-off)))"
msgstr ""

#: in/chapter16.md:227
msgid ""
"(defun false-p (cf)\n"
"  \"Is this certainty factor considered false?\"\n"
"  (and (cf-p cf) (< cf (- cf-cut-off 1.0))))"
msgstr ""

#: in/chapter16.md:232
msgid ""
"(defun cf-p (x)\n"
"  \"Is X a valid numeric certainty factor?\"\n"
"  (and (numberp x) (<= false x true)))\n"
"```"
msgstr ""

#: in/chapter16.md:235
msgid ""
"**Exercise  16.1 [m]** Suppose you read the headline \"Elvis Alive in "
"Kalamazoo\" in a tabloid newspaper to which you attribute a certainty factor "
"of .01.\n"
"If you combine certainties using EMYCIN's combination rule, how many more "
"copies of the newspaper would you need to see before you were .95 certain "
"Elvis is alive?"
msgstr ""
"**Упражнение 16.1 [m]** Предположим, вы читаете заголовок \"Элвис жив в "
"Каламазу\" в бульварной газете, которой вы приписываете коэффициент "
"уверенности .01.\n"
"Если вы объедините достоверность, используя правило комбинирования EMYCIN, "
"сколько еще экземпляров газеты вам нужно будет увидеть, прежде чем вы "
"станете уверенным, что Элвис жив .95?"

#: in/chapter16.md:237
msgid "## 16.2 Caching Derived Facts"
msgstr "## 16.2 Кэширование производных фактов"

#: in/chapter16.md:241
msgid ""
"The second thing that makes EMYCIN different from Prolog is that EMYCIN "
"*caches* all the facts it derives in a data base.\n"
"When Prolog is asked to prove the same goal twice, it performs the same "
"computation twice, no matter how laborious.\n"
"EMYCIN performs the computation the first time and just fetches it the "
"second time."
msgstr ""
"Второе, что отличает EMYCIN от Prolog, - это то, что EMYCIN *кэширует* все "
"полученные данные в базе данных.\n"
"Когда Prolog просят дважды доказать одну и ту же цель, он дважды выполняет "
"одно и то же вычисление, независимо от того, насколько это трудоемко.\n"
"EMYCIN выполняет вычисление в первый раз и просто извлекает его во второй "
"раз."

#: in/chapter16.md:243
msgid ""
"We can implement a simple data base by providing three functions: `put-db` "
"to add an association between a key and a value, `get-db` to retrieve a "
"value, and `clear-db` to empty the data base and start over:"
msgstr ""
"Мы можем реализовать простую базу данных, предоставив три функции: `put-db` "
"для добавления связи между ключом и значением, `get-db` для получения "
"значения и `clear-db` для очистки базы данных, чтобы начать сначала:"

#: in/chapter16.md:250
msgid ""
"```lisp\n"
"(let ((db (make-hash-table :test #'equal)))\n"
"  (defun get-db (key) (gethash key db))\n"
"  (defun put-db (key val) (setf (gethash key db) val))\n"
"  (defun clear-db () (clrhash db)))\n"
"```"
msgstr ""

#: in/chapter16.md:263
msgid ""
"This data base is general enough to hold any association between key and "
"value.\n"
"However, most of the information we will want to store is more specific.\n"
"EMYCIN is designed to deal with objects (or *instances*) and attributes (or "
"*parameters*) of those objects.\n"
"For example, each patient has a name parameter.\n"
"Presumably, the value of this parameter will be known exactly.\n"
"On the other hand, each microscopic organism has an `identity` parameter "
"that is normally not known at the start of the consultation.\n"
"Applying the rules will lead to several possible values for this parameter, "
"each with its own certainty factor.\n"
"In general, then, the data base will have keys of the form (*parameter "
"instance*) with values of the form ((*val*1*cf*1) (*val*2*cf*2)...).\n"
"In the following code, `get-vals` returns the list of value/cf pairs for a "
"given parameter and instance, `get-cf` returns the certainty factor for a "
"parameter/instance/value triplet, and `update-cf` changes the certainty "
"factor by combining the old one with a new one.\n"
"Note that the first time `update-cf` is called on a given parameter/instance/"
"value triplet, `get-cf` will return un known (zero).\n"
"Combining that with the given `cf` yields `cf` itself.\n"
"Also note that the data base has to be an equal hash table, because the keys "
"may include freshly consed lists."
msgstr ""
"Эта база данных достаточно общая, чтобы удерживать любую связь между ключом "
"и значением.\n"
"Однако большая часть информации, которую мы хотим сохранить, носит более "
"конкретный характер.\n"
"EMYCIN предназначен для работы с объектами (или *экземплярами*) и атрибутами "
"(или *параметрами*) этих объектов.\n"
"Например, у каждого пациента(patient) есть параметр имя(name).\n"
"Предположительно, значение этого параметра будет известно точно.\n"
"С другой стороны, каждый микроскопический организм имеет параметр "
"`identity`(идентичности), который обычно не известен в начале консультации.\n"
"Применение правил приведет к нескольким возможным значениям этого параметра, "
"каждое со своим коэффициентом достоверности(фактором уверенности).\n"
"В общем, тогда в базе данных будут ключи вида (*экземпляр параметра*) со "
"значениями вида ((*val*1*cf*1) (*val*2*cf*2)...) .\n"
"В следующем коде `get-vals` возвращает список пар значение/cf для данного "
"параметра и экземпляра, `get-cf` возвращает фактор уверенности(коэффициент "
"достоверности/cf) для триплета параметр/экземпляр/значение, а `update-cf` "
"изменяет фактор уверенности за счет объединения старого с новым.\n"
"Обратите внимание, что при первом вызове `update-cf` для данного триплета "
"параметра/экземпляра/значения, `get-cf` вернет неизвестность(ноль).\n"
"Комбинируя это с данным `cf`, получаем сам `cf`.\n"
"Также обратите внимание, что база данных должна быть equal хэш-таблицей, "
"потому что ключи могут включать в себя только что созданные списки."

#: in/chapter16.md:268
msgid ""
"```lisp\n"
"(defun get-vals (parm inst)\n"
"  \"Return a list of (val cf) pairs for this (parm inst).\"\n"
"  (get-db (list parm inst)))"
msgstr ""

#: in/chapter16.md:273
msgid ""
"(defun get-cf (parm inst val)\n"
"  \"Look up the certainty factor or return unknown.\"\n"
"  (or (second (assoc val (get-vals parm inst)))\n"
"      unknown))"
msgstr ""

#: in/chapter16.md:283
msgid ""
"(defun update-cf (parm inst val cf)\n"
"  \"Change the certianty factor for (parm inst is val),\n"
"  by combining the given cf with the old.\"\n"
"  (let ((new-cf (cf-or cf (get-cf parm inst val))))\n"
"    (put-db (list parm inst)\n"
"            (cons (list val new-cf)\n"
"                  (remove val (get-db (list parm inst))\n"
"                          :key #'first)))))\n"
"```"
msgstr ""

#: in/chapter16.md:287
msgid ""
"The data base holds all information related to an instance of a problem.\n"
"For example, in the medical domain, the data base would hold all information "
"about the current patient.\n"
"When we want to consider a new patient, the data base is cleared."
msgstr ""
"База данных содержит всю информацию, относящуюся к конкретному случаю "
"проблемы.\n"
"Например, в области медицины база данных будет содержать всю информацию о "
"текущем пациенте.\n"
"Когда мы хотим рассмотреть нового пациента, база данных очищается."

#: in/chapter16.md:293
msgid ""
"There are three other sources of information that cannot be stored in this "
"data base, because they have to be maintained from one problem to the next.\n"
"First, the *rule base* holds all the rules defined by the expert.\n"
"Second, there is a structure to define each parameter; these are indexed "
"under the name of each parameter.\n"
"Third, we shall see that the flow of control is managed in part by a list of "
"*contexts* to consider.\n"
"These are structures that will be passed to the `MYCIN` function."
msgstr ""
"Есть еще три источника информации, которые нельзя сохранить в этой базе "
"данных, потому что их нужно поддерживать от одной проблемы к другой.\n"
"Во-первых, *база правил* содержит все правила, определенные экспертом.\n"
"Во-вторых, есть структура для определения каждого параметра; они "
"индексируются под именем каждого параметра.\n"
"В-третьих, мы увидим, что поток управления частично управляется списком "
"*контекстов*(*contexts*), которые необходимо учитывать.\n"
"Это структуры, которые будут переданы функции `MYCIN`."

#: in/chapter16.md:295
msgid "## 16.3 Asking Questions"
msgstr "## 16.3 Задавать вопросы"

#: in/chapter16.md:300
msgid ""
"The third way that EMYCIN differs from Prolog is in providing an automatic "
"means of asking the user questions when answers cannot be derived from the "
"rules.\n"
"This is not a fundamental difference; after all, it is not too hard to write "
"Prolog rules that print a query and read a reply.\n"
"EMYCIN lets the knowledge-base designer write a simple declaration instead "
"of a rule, and will even assume a default declaration if none is provided.\n"
"The system also makes sure that the same question is never asked twice."
msgstr ""
"Третий способ, которым EMYCIN отличается от Prolog, - это предоставление "
"автоматических средств для задания вопросов пользователю, когда ответы не "
"могут быть получены из правил.\n"
"Это не принципиальная разница; в конце концов, не так уж сложно написать "
"правила Пролога, которые выводят запрос и читают ответ.\n"
"EMYCIN позволяет разработчику базы знаний написать простое объявление вместо "
"правила и даже примет объявление по умолчанию, если оно не предусмотрено.\n"
"Система также гарантирует, что один и тот же вопрос никогда не будет задан "
"дважды."

#: in/chapter16.md:308
msgid ""
"The following function `ask-vals` prints a query that asks for the parameter "
"of an instance, and reads from the user the value or a list of values with "
"associated certainty factors.\n"
"The function first looks at the data base to make sure the question has not "
"been asked before.\n"
"It then checks each value and certainty factor to see if each is of the "
"correct type, and it also allows the user to ask certain questions.\n"
"A ? reply will show what type answer is expected.\n"
"`Rule` will show the current rule that the system is working on.\n"
"`Why` also shows the current rule, but it explains in more detail what the "
"system knows and is trying to find out.\n"
"Finally, `help` prints the following summary:"
msgstr ""
"Следующая функция `ask-vals` печатает запрос, который запрашивает параметр "
"экземпляра и считывает от пользователя значение или список значений с "
"соответствующими факторами достоверности.\n"
"Функция сначала просматривает базу данных, чтобы убедиться, что вопрос не "
"задавался ранее.\n"
"Затем она проверяет каждое значение и фактор уверенности, чтобы убедиться, "
"что каждое из них относится к правильному типу, а также позволяет "
"пользователю задавать определенные вопросы.\n"
"А ? ответ покажет, какой тип ответа ожидается.\n"
"`Rule`(Правило) покажет текущее правило, над которым работает система.\n"
"`Why`(Почему) также показывает текущее правило, но более подробно объясняет, "
"что система знает и что пытается выяснить.\n"
"Наконец, `help` выводит следующую сводку:"

#: in/chapter16.md:320
msgid ""
"```lisp\n"
"(defconstant help-string\n"
"  \"~&Type one of the following:\n"
" ?     - to see possible answers for this parameter\n"
" rule  - to show the current rule\n"
" why   - to see why this question is asked\n"
" help  - to see this list\n"
" xxx   - (for some specific xxx) if there is a definite answer\n"
" (xxx .5 yyy .4) - If there are several answers with\n"
"                   different certainty factors.\")\n"
"```"
msgstr ""

#: in/chapter16.md:324
msgid ""
"Here is `ask-vals`.\n"
"Note that the `why` and `rule` options assume that the current rule has been "
"stored in the data base.\n"
"The functions `print-why`, `parm-type`, and `check-reply` will be defined "
"shortly."
msgstr ""
"Вот и `ask-vals`.\n"
"Обратите внимание, что параметры `why` и `rule` предполагают, что текущее "
"правило было сохранено в базе данных.\n"
"Вскоре будут определены функции `print-why`, `parm-type` и `check-reply`."

#: in/chapter16.md:346
msgid ""
"```lisp\n"
"(defun ask-vals (parm inst)\n"
"  \"Ask the user for the value(s) of inst's parm parameter,\n"
"  unless this has already been asked.  Keep asking until the\n"
"  user types UNKNOWN (return nil) or a valid reply (return t).\"\n"
"  (unless (get-db `(asked ,parm ,inst))\n"
"    (put-db `(asked ,parm ,inst) t)\n"
"    (loop\n"
"      (let ((ans (prompt-and-read-vals parm inst)))\n"
"        (case ans\n"
"          (help (format t help-string))\n"
"          (why  (print-why (get-db 'current-rule) parm))\n"
"          (rule (princ (get-db 'current-rule)))\n"
"          ((unk unknown) (RETURN nil))\n"
"          (?    (format t \"~&A ~a must be of type ~a\"\n"
"                        parm (parm-type parm)) nil)\n"
"          (t    (if (check-reply ans parm inst)\n"
"                    (RETURN t)\n"
"                    (format t \"~&Illegal reply.  ~\n"
"                             Type ? to see legal ones.\"))))))))\n"
"```"
msgstr ""

#: in/chapter16.md:351
msgid ""
"The following is `prompt-and-read-vals,` the function that actually asks the "
"query and reads the reply.\n"
"It basically calls `format` to print a prompt and `read` to get the reply, "
"but there are a few subtleties.\n"
"First, it calls `finish-output.` Some Lisp implementations buffer output on "
"a line-by-line basis.\n"
"Since the prompt may not end in a newline, `finish-output` makes sure the "
"output is printed before the reply is read."
msgstr ""
"Далее следует `prompt-and-read-vals`, функция, которая фактически "
"запрашивает запрос и читает ответ.\n"
"По сути, он вызывает `format`, чтобы напечатать приглашение, и `read`, чтобы "
"получить ответ, но здесь есть несколько тонкостей.\n"
"Во-первых, она вызывает `finish-output`. Некоторые реализации Lisp "
"буферизуют вывод построчно.\n"
"Поскольку приглашение не может заканчиваться новой строкой, `finish-output` "
"гарантирует, что вывод будет напечатан до того, как будет прочитан ответ."

#: in/chapter16.md:356
msgid ""
"So far, all the code that refers to a `parm` is really referring to the name "
"of a parameter-a symbol.\n"
"The actual parameters themselves will be implemented as structures.\n"
"We use `get-parm` to look up the structure associated with a symbol, and the "
"selector functions `parm-prompt` to pick out the prompt for each parameter "
"and `parm-reader` to pick out the reader function.\n"
"Normally this will be the function `read`, but `read-line` is appropriate "
"for reading string-valued parameters."
msgstr ""
"До сих пор весь код, который ссылается на `parm`, действительно ссылается на "
"имя параметра-символа.\n"
"Сами фактические параметры будут реализованы в виде структур.\n"
"Мы используем `get-parm` для поиска структуры, связанной с символом, и "
"функции селектора `parm-prompt`, чтобы выбрать подсказку для каждого "
"параметра, и `parm-reader`, чтобы выбрать функцию чтения.\n"
"Обычно это будет функция `read`, но `read-line` подходит для чтения "
"параметров со строковыми значениями."

#: in/chapter16.md:358
msgid ""
"The macro `defparm` (shown here) provides a way to define prompts and "
"readers for parameters."
msgstr ""
"Макрос `defparm` (показанный здесь) обеспечивает способ определения "
"подсказок и считывателей для параметров."

#: in/chapter16.md:368
msgid ""
"```lisp\n"
"(defun prompt-and-read-vals (parm inst)\n"
"  \"Print the prompt for this parameter (or make one up) and\n"
"  read the reply.\"\n"
"  (fresh-line)\n"
"  (format t (parm-prompt (get-parm parm)) (inst-name inst) parm)\n"
"  (princ \" \")\n"
"  (finish-output)\n"
"  (funcall (parm-reader (get-parm parm))))"
msgstr ""

#: in/chapter16.md:375
msgid ""
"(defun inst-name (inst)\n"
"  \"The name of this instance.\"\n"
"  ;; The stored name is either like ((\"Jan Doe\" 1.0)) or nil\n"
"  (or (first (first (get-vals 'name inst)))\n"
"      inst))\n"
"```"
msgstr ""

#: in/chapter16.md:378
msgid ""
"The function `check-reply` uses `parse - reply` to convert the user's reply "
"into a canonical form, and then checks that each value is of the right type, "
"and that each certainty factor is valid.\n"
"If so, the data base is updated to reflect the new certainty factors."
msgstr ""
"Функция `check-reply` использует `parse-reply` для преобразования ответа "
"пользователя в каноническую форму, а затем проверяет, что каждое значение "
"имеет правильный тип и что каждый фактор уверенности действителен.\n"
"Если да, база данных обновляется, чтобы отразить новые факторы уверенности."

#: in/chapter16.md:393
msgid ""
"```lisp\n"
"(defun check-reply (reply parm inst)\n"
"  \"If reply is valid for this parm, update the DB.\n"
"  Reply should be a val or (val1 cf1 val2 cf2 ...).\n"
"  Each val must be of the right type for this parm.\"\n"
"  (let ((answers (parse-reply reply)))\n"
"    (when (every #'(lambda (pair)\n"
"                     (and (typep (first pair) (parm-type parm))\n"
"                          (cf-p (second pair))))\n"
"                 answers)\n"
"      ;; Add replies to the data base\n"
"      (dolist (pair answers)\n"
"        (update-cf parm inst (first pair) (second pair)))\n"
"      answers)))"
msgstr ""

#: in/chapter16.md:401
msgid ""
"(defun parse-reply (reply)\n"
"  \"Convert the reply into a list of (value cf) pairs.\"\n"
"  (cond ((null reply) nil)\n"
"        ((atom reply) `((,reply ,true)))\n"
"        (t (cons (list (first reply) (second reply))\n"
"                 (parse-reply (rest2 reply))))))\n"
"```"
msgstr ""

#: in/chapter16.md:403
msgid ""
"Parameters are implemented as structures with six slots: the name (a "
"symbol), the context the parameter is for, the prompt used to ask for the "
"parameter's value, a Boolean that tells if we should ask the user before or "
"after using rules, a type restriction describing the legal values, and "
"finally, the function used to read the value of the parameter."
msgstr ""
"Параметры реализованы в виде структур с шестью слотами: имя - name (символ), "
"context - контекст, для которого предназначен параметр, prompt - "
"приглашение, используемое для запроса значения параметра, логическое "
"значение, которое сообщает, следует ли спрашивать пользователя до или после "
"использования правил, ограничение типа, описывающее допустимые значения, и, "
"наконец, функция, используемая для чтения значения параметра."

#: in/chapter16.md:407
msgid ""
"Parameters are stored on the property list of their names under the pa rm "
"property, so getting the `parm-type` of a name requires first getting the "
"parm structure, and then selecting the type restriction field.\n"
"By default, a parameter is given type t, meaning that any value is valid for "
"that type.\n"
"We also define the type `yes/no`, which comes in handy for Boolean "
"parameters."
msgstr ""
"Параметры хранятся в списке свойств с их именами в свойстве parm, поэтому "
"для получения имени типа parm требуется сначала получить структуру parm, а "
"затем выбрать поле ограничения типа.\n"
"По умолчанию параметру присваивается тип t, что означает, что для этого типа "
"допустимо любое значение.\n"
"Мы также определяем тип `yes/no`- да/ нет, который пригодится для "
"логических(Boolean) параметров."

#: in/chapter16.md:412
msgid ""
"We want the default prompt to be \"What is the PARM of the INST?\" But most "
"user-defined prompts will want to print the inst, and not the parm.\n"
"To make it easy to write user-defined prompts, `prompt-and-read-vals` makes "
"the instance be the first argument to the format string, with the parm "
"second.\n"
"Therefore, in the default prompt we need to use the format directive `\"~*"
"\"` to skip the instance argument, and `\"~2:*\"` to back up two arguments "
"to get back to the instance.\n"
"(These directives are common in `cerror` calls, where one list of arguments "
"is passed to two format strings.)"
msgstr ""
"Мы хотим, чтобы запрос по умолчанию был \"What is the PARM of the INST?"
"\"(Что такое PARM INST?) Но в большинстве пользовательских подсказок "
"требуется напечатать inst, а не parm.\n"
"Чтобы упростить написание пользовательских подсказок, `prompt-and-read-vals` "
"делает экземпляр первым аргументом строки формата, а parm - вторым.\n"
"Следовательно, в приглашении по умолчанию нам нужно использовать директиву "
"формата `\"~*\"`, чтобы пропустить аргумент экземпляра, и `\"~2:*\"` для "
"возврата назад на два аргумента, чтобы вернуться к экземпляру.\n"
"(Эти директивы распространены в вызовах `cerror`, где один список аргументов "
"передается двум строкам формата.)"

#: in/chapter16.md:414
msgid ""
"`defparm` is a macro that calls `new-parm`, the constructor function defined "
"in the `parm` structure, and stores the resulting structure under the `parm` "
"property of the parameter's name."
msgstr ""
"`defparm` - это макрос, который вызывает `new-parm`, функцию - конструктор, "
"определенную в `parm` структуре, и сохраняет полученную структуру под именем "
"параметра в свойстве `parm` ."

#: in/chapter16.md:421
msgid ""
"```lisp\n"
"(defstruct (parm (:constructor\n"
"                  new-parm (name &optional context type-restriction\n"
"                            prompt ask-first reader)))\n"
"  name (context nil) (prompt \"~&What is the ~*~a of ~2:*~a?\")\n"
"  (ask-first nil) (type-restriction t) (reader 'read))"
msgstr ""

#: in/chapter16.md:425
msgid ""
"(defmacro defparm (parm &rest args)\n"
"  \"Define a parameter.\"\n"
"  `(setf (get ',parm 'parm) (apply #'new-parm ',parm ',args)))"
msgstr ""

#: in/chapter16.md:429
msgid ""
"(defun parm-type (parm-name)\n"
"  \"What type is expected for a value of this parameter?\"\n"
"  (parm-type-restriction (get-parm parm-name)))"
msgstr ""

#: in/chapter16.md:435
msgid ""
"(defun get-parm (parm-name)\n"
"  \"Look up the parameter structure with this name.\"\n"
"  ;; If there is none, make one\n"
"  (or (get parm-name 'parm)\n"
"      (setf (get parm-name 'parm) (new-parm parm-name))))"
msgstr ""

#: in/chapter16.md:438
msgid ""
"(deftype yes/no () '(member yes no))\n"
"```"
msgstr ""

#: in/chapter16.md:440
msgid "## 16.4 Contexts Instead of Variables"
msgstr "## 16.4 Контексты вместо переменных"

#: in/chapter16.md:445
msgid ""
"Earlier we gave an equation relating EMYCIN to Prolog.\n"
"That equation was not quite correct, because EMYCIN lacks one of Prolog's "
"most important features: the logic variable.\n"
"Instead, EMYCIN uses *contexts*.\n"
"So the complete equation is:"
msgstr ""
"Ранее мы приводили уравнение, связывающее EMYCIN с Prolog.\n"
"Это уравнение было не совсем правильным, потому что в EMYCIN отсутствует "
"одна из самых важных функций Prolog: логическая переменная.\n"
"Вместо этого EMYCIN использует *контексты* - *contexts*.\n"
"Итак, полное уравнение:"

#: in/chapter16.md:447
msgid ""
"EMYCIN = Prolog + uncertainty + caching + questions + explanations + "
"contexts - variables"
msgstr ""
"EMYCIN = Prolog + uncertainty + caching + questions + explanations + "
"contexts - variables\n"
"(EMYCIN = Пролог + неопределенность + кеширование + вопросы + объяснения + "
"контексты - переменные)"

#: in/chapter16.md:454
msgid ""
"A context is defined by the designers of MYCIN as a situation within which "
"the program reasons.\n"
"But it makes more sense to think of a context simply as a data type.\n"
"So the list of contexts supplied to the program will determine what types of "
"objects can be reasoned about.\n"
"The program keeps track of the most recent instance of each type, and the "
"rules can refer to those instances only, using the name of the type.\n"
"In our version of MYCIN, there are three types or contexts: patients, "
"cultures, and organisms.\n"
"Here is an example of a rule that references all three contexts:"
msgstr ""
"Контекст определяется разработчиками MYCIN как ситуация, в которой работает "
"программа.\n"
"Но имеет смысл рассматривать контекст просто как тип данных.\n"
"Таким образом, список контекстов, предоставленный программе, определит, о "
"каких типах объектов можно рассуждать.\n"
"Программа отслеживает самый последний экземпляр каждого типа, и правила "
"могут ссылаться только на эти экземпляры, используя имя типа.\n"
"В нашей версии MYCIN существует три типа или контекста: пациенты(patients), "
"культуры(cultures) и организмы(organisms).\n"
"Вот пример правила, которое ссылается на все три контекста:"

#: in/chapter16.md:458
msgctxt "in/chapter16.md:458"
msgid ""
"```lisp\n"
"(defrule 52\n"
"```"
msgstr ""

#: in/chapter16.md:460
msgctxt "in/chapter16.md:460"
msgid "  `if (site culture is blood)`"
msgstr ""

#: in/chapter16.md:462
msgid "      `(gram organism is neg)`"
msgstr ""

#: in/chapter16.md:464
msgid "      `(morphology organism is rod)`"
msgstr ""

#: in/chapter16.md:466
msgid "      `(burn patient is serious)`"
msgstr ""

#: in/chapter16.md:468
msgctxt "in/chapter16.md:468"
msgid "  `then .4`"
msgstr ""

#: in/chapter16.md:470
msgid "      `(identity organism is pseudomonas))`"
msgstr ""

#: in/chapter16.md:472
msgid ""
"Ignoring certainty factors for the moment, this MYCIN rule is equivalent to "
"a Prolog rule of the form:"
msgstr ""
"На данный момент игнорируя факторы уверенности, это правило MYCIN "
"эквивалентно правилу Пролога в форме:"

#: in/chapter16.md:476
msgid ""
"```lisp\n"
"(<- (identity ?o ?pseudomonas)\n"
"```"
msgstr ""

#: in/chapter16.md:478
msgid "  `(and (culture` ?c) `(site ?c blood)`"
msgstr ""

#: in/chapter16.md:480
msgid "    `(organism ?o) (gram ?o neg) (morphology ?o rod)`"
msgstr ""

#: in/chapter16.md:482
msgid "    `(patient ?p) (burn ?p serious)))`"
msgstr ""

#: in/chapter16.md:487
msgid ""
"The context mechanism provides sufficient flexibility to handle many of the "
"cases that would otherwise be handled by variables.\n"
"One important thing that cannot be done is to refer to more than one "
"instance of the same context.\n"
"Only the most recent instance can be referred to.\n"
"Contexts are implemented as structures with the following definition:"
msgstr ""
"Механизм контекста обеспечивает достаточную гибкость для обработки многих "
"случаев, которые в противном случае обрабатывались бы переменными.\n"
"Одна важная вещь, которую нельзя сделать, - это ссылаться на несколько "
"экземпляров одного и того же контекста.\n"
"Можно сослаться только на самый последний экземпляр.\n"
"Контексты реализованы как структуры со следующим определением:"

#: in/chapter16.md:492
msgid ""
"```lisp\n"
"(defstruct context\n"
"  \"A context is a sub-domain, a type.\"\n"
"  name (number 0) initial-data goals)"
msgstr ""

#: in/chapter16.md:498
msgid ""
"(defmacro defcontext (name &optional initial-data goals)\n"
"  \"Define a context.\"\n"
"  `(make-context :name ',name :initial-data ',initial-data\n"
"                 :goals ',goals))\n"
"```"
msgstr ""

#: in/chapter16.md:506
msgid ""
"The `name` field is something like `patient or organism.` Instances of "
"contexts are numbered; the `number` field holds the number of the most "
"recent instance.\n"
"Each context also has two lists of parameters.\n"
"The `initial-data` parameters are asked for when each instance is created.\n"
"Initial data parameters are normally known by the user.\n"
"For example, a doctor will normally know the patient's name, age, and sex, "
"and as a matter of training expects to be asked these questions first, even "
"if they don't factor into every case.\n"
"The goal parameters, on the other hand, are usually unknown to the user.\n"
"They are determined through the backward-chaining process."
msgstr ""
"Поле `name`(имя) похоже на `patient или organism.` Экземпляры контекстов "
"нумеруются; поле `number` содержит номер самого последнего экземпляра.\n"
"У каждого контекста также есть два списка параметров.\n"
"Параметры начальных данных запрашиваются при создании каждого экземпляра.\n"
"Параметры исходных данных обычно известны пользователю.\n"
"Например, врач обычно знает имя, возраст и пол пациента, и в целях обучения "
"ожидает, что ему сначала зададут эти вопросы, даже если они не учитываются в "
"каждом случае.\n"
"С другой стороны, параметры цели обычно неизвестны пользователю.\n"
"Они определяются в процессе поиска/прохождения обратной цепочки."

#: in/chapter16.md:513
msgid ""
"The following function creates a new instance of a context, writes a "
"message, and stores the instance in two places in the data base: under the "
"key `current-instance`, and also under the name of the context.\n"
"The contexts form a tree.\n"
"In our example, the `patient` context is the root of the tree, and the "
"current patient is stored in the data base under the key `patient.` The next "
"level of the tree is for cultures taken from the patient; the current "
"culture is stored under the `culture` key.\n"
"Finally, there is a level for organisms found in each culture.\n"
"The current organism is stored under both the `organism` and `current-"
"instance` keys.\n"
"The context tree is shown in [figure  16.2](#f0015)."
msgstr ""
"Следующая функция создает новый экземпляр контекста, записывает сообщение и "
"сохраняет этот экземпляр в двух местах в базе данных: под ключом `current-"
"instance`, а также под именем контекста.\n"
"Контексты образуют дерево.\n"
"В нашем примере контекст `patient`(пациент) является корнем дерева, а "
"текущий пациент хранится в базе данных под ключом `patient.` Следующий "
"уровень дерева предназначен для культур, взятых у пациента; текущая культура "
"хранится в ключе `culture`.\n"
"Наконец, есть уровень для организмов, обнаруженных в каждой культуре.\n"
"Текущий организм хранится под ключами `organism` и `current-instance`.\n"
"Контекстное дерево показано на [рисунке 16.2](#f0015)."

#: in/chapter16.md:518
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f16-02](images/chapter16/f16-02.jpg) |\n"
"| Figure 16.2: A Context Tree            |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f16-02](images/chapter16/f16-02.jpg) |\n"
"| Рисунок 16.2: Дерево контекста           |"

#: in/chapter16.md:529
msgid ""
"```lisp\n"
"(defun new-instance (context)\n"
"  \"Create a new instance of this context.\"\n"
"  (let ((instance (format nil \"~a-~d\"\n"
"                          (context-name context)\n"
"                          (incf (context-number context)))))\n"
"  (format t \"~&------ ~a ------~&\" instance)\n"
"    (put-db (context-name context) instance)\n"
"    (put-db 'current-instance instance)))\n"
"```"
msgstr ""

#: in/chapter16.md:531
msgid "## 16.5 Backward-Chaining Revisited"
msgstr "## 16.5 Возвращение к обратной цепочке"

#: in/chapter16.md:535
msgid ""
"Now that we have seen how EMYCIN is different from Prolog, we are ready to "
"tackle the way in which it is the same: the backward-chaining rule "
"interpreter.\n"
"Like Prolog, EMYCIN is given a goal and applies rules that are appropriate "
"to the goal.\n"
"Applying a rule means treating each premise of the rule as a goal and "
"recursively applying rules that are appropriate to each premise."
msgstr ""
"Теперь, когда мы увидели, чем EMYCIN отличается от Prolog, мы готовы "
"заняться тем же способом: интерпретатором правил с обратной цепочкой.\n"
"Как и Prolog, EMYCIN ставит перед собой цель и применяет правила, "
"соответствующие этой цели.\n"
"Применение правила означает рассмотрение каждой посылки правила как цели и "
"рекурсивное применение правил, соответствующих каждой посылке."

#: in/chapter16.md:542
msgid ""
"There are still some remaining differences.\n"
"In Prolog, a goal can be any expression, and appropriate rules are those "
"whose heads unify with the goal.\n"
"If any appropriate rule succeeds, then the goal is known to be true.\n"
"In EMYCIN, a rule might give a goal a certainty of .99, but we still have to "
"consider all the other rules that are appropriate to the goal, because they "
"might bring the certainty down below the cutoff threshold.\n"
"Thus, EMYCIN always gathers all evidence relating to a parameter/instance "
"pair first, and only evaluates the goal after all the evidence is in.\n"
"For example, if the goal was (`temp patient  > 98.6`), Emycin would first "
"evaluate all rules with conclusions about the current patient's temperature, "
"and only then compare the temperature to 98.6."
msgstr ""
"Остались еще некоторые отличия.\n"
"В Прологе целью может быть любое выражение, и подходящими правилами являются "
"те, чьи головы объединяются/унифицируются с целью.\n"
"Если какое-либо подходящее правило сработает, значит, цель истинна.\n"
"В EMYCIN правило может дать цели уверенность .99, но мы все равно должны "
"учитывать все другие правила, соответствующие цели, потому что они могут "
"снизить точность ниже порога отсечения.\n"
"Таким образом, EMYCIN всегда сначала собирает все свидетельства, относящиеся "
"к паре параметр/экземпляр, и оценивает/вычисляет цель только после того, как "
"все свидетельства получены.\n"
"Например, если цель была (`temp patient  > 98.6`), Emycin сначала вычислит "
"все правила с выводами(заключениями) о текущей температуре пациента, и "
"только затем сравнит температуру с 98.6."

#: in/chapter16.md:545
msgid ""
"Another way of looking at it is that Prolog has the luxury of searching "
"depth-first, because the semantics of Prolog rules is such that if any rule "
"says a goal is true, then it is true.\n"
"EMYCIN must search breadth-first, because a goal with certainty of .99 might "
"turn out to be false when more evidence is considered."
msgstr ""
"С другой стороны, в Прологе есть возможность искать в глубину, потому что "
"семантика правил Пролога такова, что если какое-либо правило утверждает, что "
"цель истинна, то это правда.\n"
"EMYCIN должен искать в ширину, потому что цель с уверенностью 0,99 может "
"оказаться ложной при рассмотрении большего количества доказательств."

#: in/chapter16.md:550
msgid ""
"We are now ready to sketch out the design of the EMYCIN rule interpreter: To "
"`find-out` a parameter of an instance: If the value is already stored in the "
"data base, use the known value.\n"
"Otherwise, the two choices are using the rules or asking the user.\n"
"Do these in the order specified for this parameter, and if the first one "
"succeeds, don't bother with the second.\n"
"Note that `ask-vals` (defined above) will not ask the same question twice."
msgstr ""
"Теперь мы готовы набросать схему интерпретатора правил EMYCIN. Для `find-"
"out` параметра экземпляра: Если значение уже хранится в базе данных, "
"используйте известное значение\n"
"В противном случае, два варианта: использование правил или спросить "
"пользователя.\n"
"Делайте это в порядке, указанном для этого параметра, и, если первый "
"успешен, не беспокойтесь о втором.\n"
"Обратите внимание, что `ask-vals` (определенную выше) не будет задавать один "
"и тот же вопрос дважды."

#: in/chapter16.md:553
msgid ""
"To `use-rules`, find all the rules that concern the given parameter and "
"evaluate them with `use-rule`.\n"
"After each rule has been tried, if any of them evaluate to true, then "
"succeed."
msgstr ""
"Чтобы использовать правила, найдите все правила, относящиеся к данному "
"параметру, и вычислите их с помощью `use-rule`.\n"
"После того, как каждое правило было проверено/опробавано, если какое-либо из "
"них вычисляется как истинное, то считается успешным."

#: in/chapter16.md:558
msgid ""
"To `use-rule` a rule, first check if any of the premises can be rejected "
"outright.\n"
"If we did not have this check, then the system could start asking the user "
"questions that were obviously irrelevant.\n"
"So we waste some of the program's time (checking each premise twice) to save "
"the more valuable user time.\n"
"(The function `eval-condition` takes an optional argument specifying if we "
"should recursively ask questions in trying to accept or reject a condition.)"
msgstr ""
"Чтобы использовать правило `use-rule`, сначала проверьте, можно ли полностью "
"отклонить какую-либо из посылок.\n"
"Если бы у нас не было этой проверки, то система могла бы начать задавать "
"пользователям явно не относящиеся к делу вопросы.\n"
"Таким образом, мы тратим часть времени программы (проверяя каждую "
"предпосылку дважды), чтобы сэкономить более ценное время пользователя.\n"
"(Функция `eval-condition` принимает необязательный аргумент, определяющий, "
"должны ли мы рекурсивно задавать вопросы, пытаясь принять или отклонить "
"условие.)"

#: in/chapter16.md:563
msgid ""
"If no premise can be rejected, then evaluate each premise in turn with "
"`evaluate-condition`, keeping track of the accumulated certainty factor with "
"`cf`-and (which is currently just `min`), and cutting off evaluation when "
"the certainty factor drops below threshold.\n"
"If the premises evaluate true, then add the conclusions to the data base.\n"
"The calling sequence looks like this.\n"
"Note that the recursive call to `find-out` is what enables chaining to occur:"
msgstr ""
"Если никакая посылка не может быть отклонена, то вычислите каждую посылку по "
"очереди с помощью `evaluate-condition`, отслеживая накопленный фактор "
"уверенности с помощью `cf-and` (который в настоящее время равен `min`), и "
"отключите вычисление, когда фактор уверенности падает ниже порогового "
"значения.\n"
"Если посылки вычислены в true то добавьте выводы в базу данных.\n"
"Последовательность вызовов выглядит так.\n"
"Обратите внимание, что рекурсивный вызов `find-out` - это то, что позволяет "
"выполнять цепочку:"

#: in/chapter16.md:565
msgid "`find-out`                 ;  To find out a parameter for an instance:"
msgstr "`find-out`                 ;  Чтобы узнать параметр для экземпляра:"

#: in/chapter16.md:567
msgid "`  get-db`                 ;    See if it is cached in the data base"
msgstr ""
"`  get-db`                 ;   Посмотрите, кэшируется ли он в базе данных"

#: in/chapter16.md:569
msgid "`  ask-vals`               ;    See if the user knows the answer"
msgstr "`  ask-vals`               ;   Посмотрите, знает ли пользователь ответ"

#: in/chapter16.md:571
msgid "`  use-rules`              ;    See if there is a rule for it:"
msgstr "`  use-rules`              ;   Посмотрите, есть ли для этого правило:"

#: in/chapter16.md:573
msgid "`      reject-premise`    ;      See if the rule is outright false"
msgstr ""
"`      reject-premise`    ;      Посмотрите, является ли это правило "
"откровенно ложным"

#: in/chapter16.md:575
msgid "`      satisfy-premises`  ;      Or see if each condition is true:"
msgstr ""
"`      satisfy-premises`  ;      Или посмотрите, верно ли каждое условие:"

#: in/chapter16.md:577
msgid "`          eval-condition` ;        Evaluate each condition"
msgstr "`          eval-condition` ;        Вычислите каждое условие"

#: in/chapter16.md:579
msgid ""
"`            find-out`      ;          By finding the parameter's values"
msgstr ""
"`            find-out`      ;          Путем нахождения значений параметра"

#: in/chapter16.md:581
msgid ""
"Before showing the interpreter, here is the structure definition for rules, "
"along with the functions to maintain a data base of rules:"
msgstr ""
"Перед показом интерпретатора приведем определение структуры правил вместе с "
"функциями для поддержки базы данных правил:"

#: in/chapter16.md:585
msgid ""
"```lisp\n"
"(defstruct (rule (:print-function print-rule))\n"
"  number premises conclusions cf)"
msgstr ""

#: in/chapter16.md:587
msgid "(let ((rules (make-hash-table)))"
msgstr ""

#: in/chapter16.md:594
msgid ""
"  (defun put-rule (rule)\n"
"    \"Put the rule in a table, indexed under each\n"
"    parm in the conclusion.\"\n"
"    (dolist (concl (rule-conclusions rule))\n"
"      (push rule (gethash (first concl) rules)))\n"
"    rule)"
msgstr ""

#: in/chapter16.md:598
msgid ""
"  (defun get-rules (parm)\n"
"    \"A list of rules that help determine this parameter.\"\n"
"    (gethash parm rules))"
msgstr ""

#: in/chapter16.md:601
msgid ""
"  (defun clear-rules () (clrhash rules)))\n"
"```"
msgstr ""

#: in/chapter16.md:608
msgid ""
"Here, then, is the interpreter, `find-out`.\n"
"It can find out the value(s) of a parameter three ways.\n"
"First, it looks to see if the value is already stored in the data base.\n"
"Next, it tries asking the user or using the rules.\n"
"The order in which these two options are tried depends on the `parm-ask-"
"first` property of the parameter.\n"
"Either way, if an answer is determined, it is stored in the data base."
msgstr ""
"Итак, вот интерпретатор `find-out`.\n"
"Он может узнать значение (значения) параметра тремя способами.\n"
"Во-первых, он проверяет, сохранено ли уже значение в базе данных.\n"
"Затем он пытается спросить пользователя или использовать правила.\n"
"Порядок, в котором проверяются эти две опции, зависит от свойства параметра "
"`parm-ask-first`.\n"
"В любом случае, если ответ определен, он сохраняется в базе данных."

#: in/chapter16.md:619
msgid ""
"```lisp\n"
"(defun find-out (parm &optional (inst (get-db 'current-instance)))\n"
"  \"Find the value(s) of this parameter for this instance,\n"
"  unless the values are already known.\n"
"  Some parameters we ask first; others we use rules first.\"\n"
"  (or (get-db `(known ,parm ,inst))\n"
"      (put-db `(known ,parm ,inst)\n"
"              (if (parm-ask-first (get-parm parm))\n"
"                  (or (ask-vals parm inst) (use-rules parm))\n"
"                  (or (use-rules parm) (ask-vals parm inst))))))"
msgstr ""

#: in/chapter16.md:624
msgid ""
"(defun use-rules (parm)\n"
"  \"Try every rule associated with this parameter.\n"
"  Return true if one of the rules returns true.\"\n"
"  (some #'true-p (mapcar #'use-rule (get-rules parm))))"
msgstr ""

#: in/chapter16.md:638
msgid ""
"(defun use-rule (rule)\n"
"  \"Apply a rule to the current situation.\"\n"
"  ;; Keep track of the rule for the explanation system:\n"
"  (put-db 'current-rule rule)\n"
"  ;; If any premise is known false, give up.\n"
"  ;; If every premise can be proved true,  then\n"
"  ;; draw conclusions (weighted with the certainty factor).\n"
"  (unless (some #'reject-premise (rule-premises rule))\n"
"    (let ((cf (satisfy-premises (rule-premises rule) true)))\n"
"      (when (true-p cf)\n"
"        (dolist (conclusion (rule-conclusions rule))\n"
"          (conclude conclusion (* cf (rule-cf rule))))\n"
"        cf))))"
msgstr ""

#: in/chapter16.md:650
msgid ""
"(defun satisfy-premises (premises cf-so-far)\n"
"  \"A list of premises is satisfied if they are all true.\n"
"  A combined cf is returned.\"\n"
"  ;; cf-so-far is an accumulator of certainty factors\n"
"  (cond ((null premises) cf-so-far)\n"
"        ((not (true-p cf-so-far)) false)\n"
"        (t (satisfy-premises\n"
"             (rest premises)\n"
"             (cf-and cf-so-far\n"
"                     (eval-condition (first premises)))))))\n"
"```"
msgstr ""

#: in/chapter16.md:657
msgid ""
"The function `eval-condition` evaluates a single condition, returning its "
"certainty factor.\n"
"If `find-out-p` is true, it first calls `find-out`, which may either query "
"the user or apply appropriate rules.\n"
"If `find-out-p` is false, it evaluates the condition using the current state "
"of the data base.\n"
"It does this by looking at each stored value for the parameter/instance pair "
"and evaluating the operator on it.\n"
"For example, if the condition is (`temp patient > 98.6`) and the values for "
"`temp` for the current patient are (`(98 .3) (99 .6) (100 .1)`), then `eval-"
"condition` will test each of the values 98, 99, and 100 against 98.6 using "
"the > operator.\n"
"This test will succeed twice, so the resulting certainty factor is .6 + .1 "
"= .7."
msgstr ""
"Функция `eval-condition` вычисляет одно условие, возвращая его коэффициент "
"достоверности(фактор уверенности).\n"
"Если `find-out-p` истинен, она сначала вызывает `find-out`, который может "
"либо запросить пользователя, либо применить соответствующие правила.\n"
"Если `find-out-p` ложен, она вычисляет условие, используя текущее состояние "
"базы данных.\n"
"Она делает это, просматривая каждое сохраненное значение для пары параметр/"
"экземпляр и вычисляя на нем оператор.\n"
"Например, если условие равно (`temp patient > 98.6`), а значения `temp` для "
"текущего пациента равны (`(98 .3) (99 .6) (100 .1)`), то `eval-condition` "
"проверит каждое из значений 98, 99 и 100 против 98,6 с помощью оператора >.\n"
"Этот тест будет успешным дважды, поэтому результирующий коэффициент "
"достоверности составит .6 + .1 = .7."

#: in/chapter16.md:660
msgid ""
"The function `reject-premise` is designed as a quick test to eliminate a "
"rule.\n"
"As such, it calls `eval-condition` with `find-out-p` nil, so it will reject "
"a premise only if it is clearly false without seeking additional information."
msgstr ""
"Функция `reject-premise` предназначена для быстрой проверки исключения "
"правила.\n"
"Таким образом, она вызывает `eval-condition` с `find-out-p` nil, поэтому она "
"отклонит предпосылку, только если она явно ложна, без поиска дополнительной "
"информации."

#: in/chapter16.md:663
msgid ""
"If a rule's premises are true, then the conclusions are added to the data "
"base by `conclude`.\n"
"Note that `is` is the only operator allowed in conclusions, `is` is just an "
"alias for equal."
msgstr ""
"Если посылки правила верны, то выводы добавляются в базу данных с помощью "
"`conclude`.\n"
"Обратите внимание, что `is` - единственный оператор, разрешенный в выводах, "
"`is` - просто псевдоним для equal(равенства)."

#: in/chapter16.md:676
msgid ""
"```lisp\n"
"(defun eval-condition (condition &optional (find-out-p t))\n"
"  \"See if this condition is true, optionally using FIND-OUT\n"
"  to determine unknown parameters.\"\n"
"  (multiple-value-bind (parm inst op val)\n"
"      (parse-condition condition)\n"
"    (when find-out-p\n"
"      (find-out parm inst))\n"
"    ;; Add up all the (val cf) pairs that satisfy the test\n"
"    (loop for pair in (get-vals parm inst)\n"
"          when (funcall op (first pair) val)\n"
"          sum (second pair))))"
msgstr ""

#: in/chapter16.md:681
msgid ""
"(defun reject-premise (premise)\n"
"  \"A premise is rejected if it is known false, without\n"
"  needing to call find-out recursively.\"\n"
"  (false-p (eval-condition premise nil)))"
msgstr ""

#: in/chapter16.md:687
msgid ""
"(defun conclude (conclusion cf)\n"
"  \"Add a conclusion (with specified certainty factor) to DB.\"\n"
"  (multiple-value-bind (parm inst op val)\n"
"      (parse-condition conclusion)\n"
"    (update-cf parm inst val cf)))"
msgstr ""

#: in/chapter16.md:690
msgid ""
"(defun is (a b) (equal a b))\n"
"```"
msgstr ""

#: in/chapter16.md:694
msgid ""
"All conditions are of the form: (*parameter instance operator value*).\n"
"For example: `(morphology organism is rod).` The function `parse-condition` "
"turns a list of this form into four values.\n"
"The trick is that it uses the data base to return the current instance of "
"the context, rather than the context name itself:"
msgstr ""
"Все условия имеют вид: (*parameter instance operator value*) - (*параметр "
"экземпляр оператор значение*).\n"
"Например: `(morphology organism is rod).` Функция `parse-condition` "
"превращает список этой формы в четыре значения.\n"
"Хитрость в том, что она использует базу данных для возврата текущего "
"экземпляра контекста, а не самого имени контекста:"

#: in/chapter16.md:705
msgid ""
"```lisp\n"
"(defun parse-condition (condition)\n"
"  \"A condition is of the form (parm inst op val).\n"
"  So for (age patient is 21), we would return 4 values:\n"
"  (age patient-1 is 21), where patient-1 is the current patient.\"\n"
"  (values (first condition)\n"
"          (get-db (second condition))\n"
"          (third condition)\n"
"          (fourth condition)))\n"
"```"
msgstr ""

#: in/chapter16.md:711
msgid ""
"At this point a call like (`find-out 'identity 'organism-1`) would do the "
"right thing only if we had somehow entered the proper information on the "
"current patient, culture, and organism.\n"
"The function `get-context-data` makes sure that each context is treated in "
"order.\n"
"First an instance is created, then `find-out` is used to determine both the "
"initial data parameters and the goals.\n"
"The findings for each goal are printed, and the program asks if there is "
"another instance of this context.\n"
"Finally, we also need a top-level function, `emycin`, which just clears the "
"data base before calling `get-context-data`."
msgstr ""
"На этом этапе такой вызов, как (`find-out 'identity 'organism-1`) будет "
"действовать правильно, только если мы каким-то образом ввели правильную "
"информацию о текущем пациенте, культуре и организме.\n"
"Функция `get-context-data` гарантирует, что каждый контекст обрабатывается "
"по порядку.\n"
"Сначала создается экземпляр, затем используется `find-out` для определения "
"как исходных параметров данных, так и целей.\n"
"Выводы для каждой цели печатаются, и программа спрашивает, есть ли еще один "
"экземпляр этого контекста.\n"
"Наконец, нам также нужна функция верхнего уровня `emycin`, которая просто "
"очищает базу данных перед вызовом `get-context-data`."

#: in/chapter16.md:718
msgid ""
"```lisp\n"
"(defun emycin (contexts)\n"
"  \"An Expert System Shell.  Accumulate data for instances of each\n"
"  context, and solve for goals.  Then report the findings.\"\n"
"  (clear-db)\n"
"  (get-context-data contexts))"
msgstr ""

#: in/chapter16.md:736
msgid ""
"(defun get-context-data (contexts)\n"
"  \"For each context, create an instance and try to find out\n"
"  required data.  Then go on to other contexts, depth first,\n"
"  and finally ask if there are other instances of this context.\"\n"
"  (unless (null contexts)\n"
"    (let* ((context (first contexts))\n"
"           (inst (new-instance context)))\n"
"      (put-db 'current-rule 'initial)\n"
"      (mapc #'find-out (context-initial-data context))\n"
"      (put-db 'current-rule 'goal)\n"
"      (mapc #'find-out (context-goals context))\n"
"      (report-findings context inst)\n"
"      (get-context-data (rest contexts))\n"
"      (when (y-or-n-p \"Is there another ~a?\"\n"
"                      (context-name context))\n"
"        (get-context-data contexts)))))\n"
"```"
msgstr ""

#: in/chapter16.md:738
msgid "## 16.6 Interacting with the Expert"
msgstr "## 16.6 Взаимодействие с экспертом"

#: in/chapter16.md:745
msgid ""
"At this point all the serious computational work is done: we have defined a "
"backward-chaining rule mechanism that deals with uncertainty, caching, "
"questions, and contexts.\n"
"But there is still quite a bit of work to do in terms of input/output "
"interaction.\n"
"A programming language needs only to interface with programmers, so it is "
"acceptable to make the programmer do all the work.\n"
"But an expert-system shell is supposed to alleviate (if not abolish) the "
"need for programmers.\n"
"Expert-system shells really have two classes of users: the experts use the "
"shell when they are developing the system, and the end users or clients use "
"the resulting expert system when it is completed.\n"
"Sometimes the expert can enter knowledge directly into the shell, but more "
"often it is assumed the expert will have the help of a *knowledge engineer*-"
"someone who is trained in the use of the shell and in eliciting knowledge, "
"but who need not be either an expert in the domain or an expert programmer."
msgstr ""
"На этом этапе вся серьезная вычислительная работа завершена: мы определили "
"механизм правил обратной цепочки, который имеет дело с неопределенностью, "
"кэшированием, запросами и контекстами.\n"
"Но с точки зрения взаимодействия ввода/вывода предстоит еще немало "
"поработать.\n"
"Язык программирования должен только взаимодействовать с программистами, "
"поэтому вполне допустимо, чтобы программист делал всю работу.\n"
"Но оболочка экспертной системы должна облегчить (если не отменить) "
"потребность в программистах.\n"
"Оболочки экспертной системы действительно имеют два класса пользователей: "
"эксперты используют оболочку при разработке системы, а конечные пользователи "
"или клиенты используют получившуюся экспертную систему, когда она "
"завершена.\n"
"Иногда эксперт может вводить знания непосредственно в оболочку, но чаще "
"предполагается, что эксперт будет пользоваться помощью *инженера знаний* - "
"кого-то, кто обучен использованию оболочки и извлечению знаний, но не "
"обязательно либо эксперт в своей области, либо опытный программист."

#: in/chapter16.md:749
msgid ""
"In our version of EMYCIN, we provide only the simplest tools for making the "
"expert's job easier.\n"
"The macros `defcontext` and `defparm`, defined above, are a little easier "
"than calling `make-context` and `make-parm` explicitly, but not much.\n"
"The macro `defrule` defines a rule and checks for some obvious errors:"
msgstr ""
"В нашей версии EMYCIN мы предоставляем только самые простые инструменты, "
"облегчающие работу эксперта.\n"
"Макросы `defcontext` и `defparm`, определенные выше, немного проще, чем "
"явный вызов `make-context` и `make-parm`, но не намного.\n"
"Макрос `defrule` определяет правило и проверяет наличие очевидных ошибок:"

#: in/chapter16.md:769
msgid ""
"```lisp\n"
"(defmacro defrule (number &body body)\n"
"  \"Define a rule with conditions, a certainty factor, and\n"
"  conclusions.  Example: (defrule R001 if ... then .9 ...)\"\n"
"  (assert (eq (first body) 'if))\n"
"  (let* ((then-part (member 'then body))\n"
"         (premises (ldiff (rest body) then-part))\n"
"         (conclusions (rest2 then-part))\n"
"         (cf (second then-part)))\n"
"    ;; Do some error checking:\n"
"    (check-conditions number premises 'premise)\n"
"    (check-conditions number conclusions 'conclusion)\n"
"    (when (not (cf-p cf))\n"
"      (warn \"Rule ~a: Illegal certainty factor: ~a\" number cf))\n"
"    ;; Now build the rule:\n"
"    `(put-rule\n"
"       (make-rule :number ',number :cf ,cf :premises ',premises\n"
"                  :conclusions ',conclusions))))\n"
"```"
msgstr ""

#: in/chapter16.md:772
msgid ""
"The function `check-conditions` makes sure that each rule has at least one "
"premise and conclusion, that each condition is of the right form, and that "
"the value of the condition is of the right type for the parameter.\n"
"It also checks that conclusions use only the operator `is`:"
msgstr ""
"Функция `check-conditions` проверяет, что каждое правило имеет по крайней "
"мере одну предпосылку и вывод, что каждое условие имеет правильную форму и "
"что значение условия имеет правильный тип для параметра.\n"
"Также проверяется, что в выводах используется только оператор `is`:"

#: in/chapter16.md:791
msgid ""
"```lisp\n"
"(defun check-conditions (rule-num conditions kind)\n"
"  \"Warn if any conditions are invalid.\"\n"
"  (when (null conditions)\n"
"    (warn \"Rule ~a: Missing ~a\" rule-num kind))\n"
"  (dolist (condition conditions)\n"
"    (when (not (consp condition))\n"
"      (warn \"Rule ~a: Illegal ~a: ~a\" rule-num kind condition))\n"
"    (multiple-value-bind (parm inst op val)\n"
"        (parse-condition condition)\n"
"      (declare (ignore inst))\n"
"      (when (and (eq kind 'conclusion) (not (eq op 'is)))\n"
"        (warn \"Rule ~a: Illegal operator (~a) in conclusion: ~a\"\n"
"              rule-num op condition))\n"
"      (when (not (typep val (parm-type parm)))\n"
"        (warn \"Rule ~a: Illegal value (~a) in ~a: ~a\"\n"
"              rule-num val kind condition)))))\n"
"```"
msgstr ""

#: in/chapter16.md:794
msgid ""
"The real EMYCIN had an interactive environment that prompted the expert for "
"each context, parameter, and rule.\n"
"Randall Davis ([1977](B9780080571157500285.xhtml#bb0290), [1979]"
"(B9780080571157500285.xhtml#bb0295), [Davis and Lenat 1982]"
"(B9780080571157500285.xhtml#bb0300)) describes the TEIRESIAS program, which "
"helped experts enter and debug rules."
msgstr ""
"Настоящий EMYCIN имел интерактивную среду, которая запрашивала у эксперта "
"каждый контекст, параметр и правило.\n"
"Рэндалл Дэвис ([1977](B9780080571157500285.xhtml#bb0290), [1979]"
"(B9780080571157500285.xhtml#bb0295), [Davis and Lenat 1982]"
"(B9780080571157500285.xhtml#bb0IRESIAS) описывает программу TEIRESIAS, "
"которая помогала вводить и отлаживать правила."

#: in/chapter16.md:796
msgid "## 16.7 Interacting with the Client"
msgstr "## 16.7 Взаимодействие с клиентом"

#: in/chapter16.md:801
msgid ""
"Once the knowledge is in, we need some way to get it out.\n"
"The client wants to run the system on his or her own problem and see two "
"things: a solution to the problem, and an explanation of why the solution is "
"reasonable.\n"
"EMYCIN provides primitive facilities for both of these.\n"
"The function `report-findings` prints information on all the goal parameters "
"for a given instance:"
msgstr ""
"Как только знание получено(введено), нам нужен какой-то способ "
"увидеть(вывести) его.\n"
"Клиент хочет запустить систему над своей собственной проблемой и увидеть две "
"вещи: решение проблемы и объяснение, почему решение является разумным.\n"
"EMYCIN предоставляет примитивные возможности для обоих из них.\n"
"Функция `report-findings` выводит информацию обо всех параметрах цели для "
"данного экземпляра:"

#: in/chapter16.md:816
msgid ""
"```lisp\n"
"(defun report-findings (context inst)\n"
"  \"Print findings on each goal for this instance.\"\n"
"  (when (context-goals context)\n"
"    (format t \"~&Findings for ~a:\" (inst-name inst))\n"
"    (dolist (goal (context-goals context))\n"
"      (let ((values (get-vals goal inst)))\n"
"        ;; If there are any values for this goal,\n"
"        ;; print them sorted by certainty factor.\n"
"        (if values\n"
"            (format t \"~& ~a:~{~{ ~a (~,3f)  ~}~}\" goal\n"
"                    (sort (copy-list values) #'> :key #'second))\n"
"            (format t \"~& ~a: unknown\" goal))))))\n"
"```"
msgstr ""

#: in/chapter16.md:820
msgid ""
"The only explanation facility our version of EMYCIN offers is a way to see "
"the current rule.\n"
"If the user types `rule` in response to a query, a pseudo-English "
"translation of the current rule is printed.\n"
"Here is a sample rule and its translation:"
msgstr ""
"Единственная возможность объяснения, которую предлагает наша версия EMYCIN, "
"- это способ увидеть текущее правило.\n"
"Если пользователь вводит `rule` в ответ на запрос, печатается "
"псевдоанглийский перевод текущего правила.\n"
"Вот пример правила и его перевод:"

#: in/chapter16.md:838
msgid ""
"```lisp\n"
"(defrule 52\n"
"  if (site culture is blood)\n"
"      (gram organism is neg)\n"
"      (morphology organism is rod)\n"
"      (burn patient is serious)\n"
"  then .4\n"
"      (identity organism is pseudomonas))\n"
"Rule 52:\n"
"  If\n"
"    1) THE SITE OF THE CULTURE IS BLOOD\n"
"    2) THE GRAM OF THE ORGANISM IS NEG\n"
"    3) THE MORPHOLOGY OF THE ORGANISM IS ROD\n"
"    4) THE BURN OF THE PATIENT IS SERIOUS\n"
"  Then there is weakly suggestive evidence (0.4) that\n"
"    1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS\n"
"```"
msgstr ""

#: in/chapter16.md:840
msgid "The function `print-rule` generates this translation:"
msgstr "Функция `print-rule` генерирует такой перевод:"

#: in/chapter16.md:849
msgid ""
"```lisp\n"
"(defun print-rule (rule &optional (stream t) depth)\n"
"  (declare (ignore depth))\n"
"  (format stream \"~&Rule ~a:~&  If\" (rule-number rule))\n"
"  (print-conditions (rule-premises rule) stream)\n"
"  (format stream \"~&  Then ~a (~a) that\"\n"
"          (cf->english (rule-cf rule)) (rule-cf rule))\n"
"  (print-conditions (rule-conclusions rule) stream))"
msgstr ""

#: in/chapter16.md:855
msgid ""
"(defun print-conditions (conditions &optional\n"
"                         (stream t) (num 1))\n"
"  \"Print a list of numbered conditions.\"\n"
"  (dolist (condition conditions)\n"
"    (print-condition condition stream num)))"
msgstr ""

#: in/chapter16.md:867
msgid ""
"(defun print-condition (condition stream number)\n"
"  \"Print a single condition in pseudo-English.\"\n"
"  (format stream \"~&    ~d)~{ ~a~}\" number\n"
"          (let ((parm (first condition))\n"
"                (inst (second condition))\n"
"                (op (third condition))\n"
"                (val (fourth condition)))\n"
"            (case val\n"
"              (YES `(the ,inst ,op ,parm))\n"
"              (NO  `(the ,inst ,op not ,parm))\n"
"              (T   `(the ,parm of the ,inst ,op ,val))))))"
msgstr ""

#: in/chapter16.md:878
msgid ""
"(defun cf->english (cf)\n"
"  \"Convert a certainy factor to an English phrase.\"\n"
"  (cond ((= cf  1.0) \"there is certain evidence\")\n"
"        ((> cf   .8) \"there is strongly suggestive evidence\")\n"
"        ((> cf   .5) \"there is suggestive evidence\")\n"
"        ((> cf  0.0) \"there is weakly suggestive evidence\")\n"
"        ((= cf  0.0) \"there is NO evidence either way\")\n"
"        ((< cf  0.0) (concatenate 'string (cf->english (- cf))\n"
"                                  \" AGAINST the conclusion\"))))\n"
"```"
msgstr ""

#: in/chapter16.md:885
msgid ""
"If the user types `why` in response to a query, a more detailed account of "
"the same rule is printed.\n"
"First, the premises that are already known are displayed, followed by the "
"remainder of the rule.\n"
"The parameter being asked for will always be the first premise in the "
"remainder of the rule.\n"
"The `current-rule` is stored in the data base by `use-rule` whenever a rule "
"is applied, but it is also set by `get-context-data` to the atom `initial` "
"or goal when the system is prompting for parameters.\n"
"`print-why` checks for this case as well.\n"
"Note the use of the `partition-if` function from page 256."
msgstr ""
"Если пользователь вводит `why` в ответ на запрос, печатается более подробное "
"описание того же правила.\n"
"Сначала отображаются уже известные предпосылки, а затем - оставшаяся часть "
"правила.\n"
"Запрашиваемый параметр всегда будет первой предпосылкой в оставшейся части "
"правила.\n"
"`current-rule` сохраняется в базе данных с помощью `use-rule` всякий раз, "
"когда применяется правило, но оно также устанавливается с помощью `get-"
"context-data` для атома `initial` или цели, когда система запрашивает для "
"параметров.\n"
"`print-why` также проверяет этот случай.\n"
"Обратите внимание на использование функции `partition-if` со страницы 256."

#: in/chapter16.md:906
msgid ""
"```lisp\n"
"(defun print-why (rule parm)\n"
"  \"Tell why this rule is being used.  Print what is known,\n"
"  what we are trying to find out, and what we can conclude.\"\n"
"  (format t \"~&[Why is the value of ~a being asked for?]\" parm)\n"
"  (if (member rule '(initial goal))\n"
"      (format t \"~&~a is one of the ~a parameters.\"\n"
"              parm rule)\n"
"      (multiple-value-bind (knowns unknowns)\n"
"          (partition-if #'(lambda (premise)\n"
"                            (true-p (eval-condition premise nil)))\n"
"                        (rule-premises rule))\n"
"        (when knowns\n"
"          (format t \"~&It is known that:\")\n"
"          (print-conditions knowns)\n"
"          (format t \"~&Therefore,\"))\n"
"        (let ((new-rule (copy-rule rule)))\n"
"          (setf (rule-premises new-rule) unknowns)\n"
"          (print new-rule)))))\n"
"```"
msgstr ""

#: in/chapter16.md:909
msgid ""
"That completes the definition of `emycin`.\n"
"We are now ready to apply the shell to a specific domain, yielding the "
"beginnings of an expert system."
msgstr ""
"Это завершает определение `emycin`.\n"
"Теперь мы готовы применить оболочку к конкретному домену, что положит начало "
"созданию экспертной системы."

#: in/chapter16.md:911
msgid "## 16.8 **MYCIN**, A Medical Expert System"
msgstr "## 16.8 **MYCIN**, Медицинская экспертная система"

#: in/chapter16.md:920
msgid ""
"This section applies `emycin` to Mycin's original domain: infectious blood "
"disease.\n"
"In our version of MYCIN, there are three contexts: first we consider a "
"patient, then any cultures that have been grown from samples taken from the "
"patient, and finally any infectious organisms in the cultures.\n"
"The goal is to determine the identity of each organism.\n"
"The real MYCIN was more complex, taking into account any drugs or operations "
"the patient may previously have had.\n"
"It also went on to decide the real question: what therapy to prescribe.\n"
"However, much of this was done by special-purpose procedures to compute "
"optimal dosages and the like, so it is not included here.\n"
"The original MYCIN also made a distinction between current versus prior "
"cultures, organisms, and drugs.\n"
"All together, it had ten contexts to consider, while our version only has "
"three:"
msgstr ""
"В этом разделе `emycin` применяется к исходной области Mycin: инфекционное "
"заболевание крови.\n"
"В нашей версии MYCIN существует три контекста: сначала мы рассматриваем "
"пациента, затем любые культуры, выращенные из образцов, взятых у пациента, "
"и, наконец, любые инфекционные организмы в культурах.\n"
"Цель состоит в том, чтобы определить идентичность каждого организма.\n"
"Настоящий MYCIN был более сложным с учетом любых лекарств или операций, "
"которые пациент мог перенести ранее.\n"
"Он также решал реальный вопрос: какую терапию назначить.\n"
"Однако большая часть этого была сделана с помощью специальных процедур для "
"расчета оптимальных дозировок и т.п., поэтому здесь они не рассматриваются.\n"
"Исходный MYCIN также проводил различие между существующими и предшествующими "
"культурами, организмами и лекарствами.\n"
"Всего нужно было рассмотреть десять контекстов, в то время как в нашей "
"версии их всего три:"

#: in/chapter16.md:929
msgid ""
"```lisp\n"
"(defun mycin ()\n"
"  \"Determine what organism is infecting a patient.\"\n"
"  (emycin\n"
"    (list (defcontext patient  (name sex age)  ())\n"
"          (defcontext culture  (site days-old) ())\n"
"          (defcontext organism ()              (identity)))))\n"
"```"
msgstr ""

#: in/chapter16.md:932
msgid ""
"These contexts declare that we will first ask each patient's name, sex, and "
"age, and each culture's site and the number of days ago it was isolated.\n"
"Organisms have no initial questions, but they do have a goal: to determine "
"the identity of the organism."
msgstr ""
"Эти контексты объявляют, что мы сначала спросим каждого пациента, имя, пол и "
"возраст, а также месторасположение каждой культуры и количество прошедших "
"дней, с момента её изоляции.\n"
"Для организмов нет первоначальных вопросов, но для них есть цель: определить "
"идентичность организма."

#: in/chapter16.md:935
msgid ""
"The next step is to declare parameters for the contexts.\n"
"Each parameter is given a type, and most are given prompts to improve the "
"naturalness of the dialogue:"
msgstr ""
"Следующим шагом является объявление параметров для контекстов.\n"
"Каждому параметру присваивается тип, и большинству из них даются "
"prompts(приглашения/подсказки), чтобы сделать диалог более естественным:"

#: in/chapter16.md:945
msgid ""
"```lisp\n"
";;; Parameters for patient:\n"
"(defparm name patient t \"Patient's name: \" t read-line)\n"
"(defparm sex patient (member male female) \"Sex:\" t)\n"
"(defparm age patient number \"Age:\" t)\n"
"(defparm burn patient (member no mild serious)\n"
"  \"Is ~a a burn patient?  If so, mild or serious?\" t)\n"
"(defparm compromised-host patient yes/no\n"
"  \"Is ~a a compromised host?\")"
msgstr ""

#: in/chapter16.md:951
msgid ""
";;; Parameters for culture:\n"
"(defparm site culture (member blood)\n"
"  \"From what site was the specimen for ~a taken?\" t)\n"
"(defparm days-old culture number\n"
"  \"How many days ago was this culture (~a) obtained?\" t)"
msgstr ""

#: in/chapter16.md:965
msgid ""
";;; Parameters for organism:\n"
"(defparm identity organism\n"
"  (member pseudomonas klebsiella enterobacteriaceae\n"
"          staphylococcus bacteroides streptococcus)\n"
"  \"Enter the identity (genus) of ~a:\" t)\n"
"(defparm gram organism (member acid-fast pos neg)\n"
"  \"The gram stain of ~a:\" t)\n"
"(defparm morphology organism (member rod coccus)\n"
"  \"Is ~a a rod or coccus (etc.):\")\n"
"(defparm aerobicity organism (member aerobic anaerobic))\n"
"(defparm growth-conformation organism\n"
"  (member chains pairs clumps))\n"
"```"
msgstr ""

#: in/chapter16.md:970
msgid ""
"Now we need some rules to help determine the identity of the organisms.\n"
"The following rules are taken from [Shortliffe 1976](B9780080571157500285."
"xhtml#bb1100).\n"
"The rule numbers refer to the pages on which they are listed.\n"
"The real MYCIN had about 400 rules, dealing with a much wider variety of "
"premises and conclusions."
msgstr ""
"Теперь нам нужны некоторые правила, которые помогут определить идентичность "
"организмов.\n"
"Следующие правила взяты из [Shortliffe 1976](B9780080571157500285."
"xhtml#bb1100).\n"
"Номера правил относятся к страницам, на которых они перечислены.\n"
"Настоящий MYCIN имел около 400 правил, касающихся гораздо более широкого "
"спектра предпосылок и выводов."

#: in/chapter16.md:973
msgid ""
"```lisp\n"
"(clear-rules)"
msgstr ""

#: in/chapter16.md:981
msgid ""
"(defrule 52\n"
"  if (site culture is blood)\n"
"     (gram organism is neg)\n"
"     (morphology organism is rod)\n"
"     (burn patient is serious)\n"
"  then .4\n"
"     (identity organism is pseudomonas))"
msgstr ""

#: in/chapter16.md:988
msgid ""
"(defrule 71\n"
"  if (gram organism is pos)\n"
"     (morphology organism is coccus)\n"
"     (growth-conformation organism is clumps)\n"
"  then .7\n"
"     (identity organism is staphylococcus))"
msgstr ""

#: in/chapter16.md:996
msgid ""
"(defrule 73\n"
"  if (site culture is blood)\n"
"     (gram organism is neg)\n"
"     (morphology organism is rod)\n"
"     (aerobicity organism is anaerobic)\n"
"  then .9\n"
"     (identity organism is bacteroides))"
msgstr ""

#: in/chapter16.md:1003
msgid ""
"(defrule 75\n"
"  if (gram organism is neg)\n"
"     (morphology organism is rod)\n"
"     (compromised-host patient is yes)\n"
"  then .6\n"
"     (identity organism is pseudomonas))"
msgstr ""

#: in/chapter16.md:1010
msgid ""
"(defrule 107\n"
"  if (gram organism is neg)\n"
"     (morphology organism is rod)\n"
"     (aerobicity organism is aerobic)\n"
"  then .8\n"
"     (identity organism is enterobacteriaceae))"
msgstr ""

#: in/chapter16.md:1018
msgid ""
"(defrule 165\n"
"  if (gram organism is pos)\n"
"     (morphology organism is coccus)\n"
"     (growth-conformation organism is chains)\n"
"  then .7\n"
"     (identity organism is streptococcus))\n"
"```"
msgstr ""

#: in/chapter16.md:1020
msgid "Here is an example of the program in use:"
msgstr "Вот пример использования программы:"

#: in/chapter16.md:1029
msgid ""
"```lisp\n"
"> (mycin)\n"
"------ PATIENT-1 ------\n"
"Patient's name: Sylvia Fischer\n"
"Sex: female\n"
"Age: 27\n"
"------ CULTURE-1 ------\n"
"```"
msgstr ""

#: in/chapter16.md:1032
msgid ""
"`From what site was the specimen for CULTURE-1 taken?\n"
"blood`"
msgstr ""

#: in/chapter16.md:1035
msgid ""
"`How many days ago was this culture (CULTURE-1) obtained?\n"
"3`"
msgstr ""

#: in/chapter16.md:1043
msgid ""
"```lisp\n"
"------ ORGANISM-1 ------\n"
"Enter the identity (genus) of ORGANISM-1: unknown\n"
"The gram stain of ORGANISM-1: ?\n"
"A GRAM must be of type (MEMBER ACID-FAST POS NEG)\n"
"The gram stain of ORGANISM-1: neg\n"
"```"
msgstr ""

#: in/chapter16.md:1046
msgid ""
"The user typed ? to see the list of valid responses.\n"
"The dialog continues:"
msgstr ""
"Пользователь набрал ? чтобы увидеть список действительных ответов.\n"
"Диалог продолжается:"

#: in/chapter16.md:1050
msgid ""
"```lisp\n"
"Is ORGANISM-1 a rod or coccus (etc.): rod\n"
"```"
msgstr ""

#: in/chapter16.md:1053
msgid ""
"`What is the AEROBICITY of ORGANISM-1?\n"
"Why`"
msgstr ""

#: in/chapter16.md:1066
msgid ""
"```lisp\n"
"[Why is the value of AEROBICITY being asked for?]\n"
"It is known that:\n"
"      1) THE GRAM OF THE ORGANISM IS NEG\n"
"      2) THE MORPHOLOGY OF THE ORGANISM IS ROD\n"
"Therefore,\n"
"Rule 107:\n"
"  If\n"
"      1) THE AEROBICITY OF THE ORGANISM IS AEROBIC\n"
"  Then there is suggestive evidence (0.8) that\n"
"      1) THE IDENTITY OF THE ORGANISM IS ENTEROBACTERIACEAE\n"
"```"
msgstr ""

#: in/chapter16.md:1070
msgid ""
"The user wants to know why the system is asking about the organism's "
"aerobicity.\n"
"The reply shows the current rule, what is already known about the rule, and "
"the fact that if the organism is aerobic, then we can conclude something "
"about its identity.\n"
"In this hypothetical case, the organism is in fact aerobic:"
msgstr ""
"Пользователь хочет знать, почему система спрашивает об аэробности "
"организма.\n"
"Ответ показывает текущее правило, то, что уже известно о правиле, и тот "
"факт, что если организм аэробный, то мы можем сделать некоторые выводы о его "
"идентичности.\n"
"В этом гипотетическом случае организм фактически аэробен:"

#: in/chapter16.md:1073
msgid ""
"`What is the AEROBICITY of ORGANISM-1?\n"
"aerobic`"
msgstr ""

#: in/chapter16.md:1076
msgid ""
"`Is Sylvia Fischer a compromised host?\n"
"yes`"
msgstr ""

#: in/chapter16.md:1081
msgid ""
"`Is Sylvia Fischer a burn patient?\n"
"If so.\n"
"mild or serious?\n"
"why`"
msgstr ""

#: in/chapter16.md:1095
msgid ""
"```lisp\n"
"[Why is the value of BURN being asked for?]\n"
"It is known that:\n"
"      1) THE SITE OF THE CULTURE IS BLOOD\n"
"      2) THE GRAM OF THE ORGANISM IS NEG\n"
"      3) THE MORPHOLOGY OF THE ORGANISM IS ROD\n"
"Therefore,\n"
"Rule 52:\n"
"  If\n"
"      1) THE BURN OF THE PATIENT IS SERIOUS\n"
"  Then there is weakly suggestive evidence (0.4) that\n"
"      1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS\n"
"```"
msgstr ""

#: in/chapter16.md:1099
msgid ""
"`Is Sylvia Fischer a burn patient?\n"
"If so, mild or serious?\n"
"serious`"
msgstr ""

#: in/chapter16.md:1104
msgid ""
"```lisp\n"
"Findings for ORGANISM-1:\n"
"  IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)\n"
"```"
msgstr ""

#: in/chapter16.md:1110
msgid ""
"The system used rule 107 to conclude the identity might be "
"enterobacteriaceae.\n"
"The certainty is .8, the certainty for the rule itself, because all the "
"conditions were known to be true with certainty.\n"
"Rules 52 and 75 both support the hypothesis of pseudomonas.\n"
"The certainty factors of the two rules, .6 and .4, are combined by the "
"formula .6 + .4 - (.6 x .4) = .76.\n"
"After printing the findings for the first organism, the system asks if "
"another organism was obtained from this culture:"
msgstr ""
"Система использовала правило 107, чтобы сделать вывод, что это могут быть "
"энтеробактерии.\n"
"Уверенность равна .8, достоверность самого правила, потому что все условия "
"были достоверно известны.\n"
"Правила 52 и 75 поддерживают гипотезу псевдомонад.\n"
"Коэффициенты достоверности двух правил, .6 и .4, объединяются по формуле .6 "
"+ .4 - (.6 x .4) = .76.\n"
"После распечатки результатов для первого организма система спрашивает, был "
"ли другой организм получен из этой культуры:"

#: in/chapter16.md:1113
msgid ""
"`Is there another ORGANISM?\n"
"(Y or N) Y`"
msgstr ""

#: in/chapter16.md:1120
msgid ""
"```lisp\n"
"------ ORGANISM-2 ------\n"
"Enter the identity (genus) of ORGANISM-2: unknown\n"
"The gram stain of ORGANISM-2: (neg .8 pos .2)\n"
"Is ORGANISM-2 a rod or coccus (etc.): rod\n"
"```"
msgstr ""

#: in/chapter16.md:1123
msgid ""
"`What is the AEROBICITY of ORGANISM-2?\n"
"anaerobic`"
msgstr ""

#: in/chapter16.md:1129
msgid ""
"For the second organism, the lab test was inconclusive, so the user entered "
"a qualified answer indicating that it is probably gram-negative, but perhaps "
"gram-positive.\n"
"This organism was also a rod but was anaerobic.\n"
"Note that the system does not repeat questions that it already knows the "
"answers to.\n"
"In considering rules 75 and 52 it already knows that the culture came from "
"the blood, and that the patient is a compromised host and a serious burn "
"patient.\n"
"In the end, rule 73 contributes to the bacteroides conclusion, and rules 75 "
"and 52 again combine to suggest pseudomonas, although with a lower certainty "
"factor, because the neg finding had a lower certainty factor:"
msgstr ""
"Для второго организма лабораторный тест не дал результатов, поэтому "
"пользователь ввел квалифицированный ответ, указывающий, что он, вероятно, "
"является грамотрицательным, но, возможно, грамположительным.\n"
"Этот организм тоже был rod, но был анаэробным.\n"
"Обратите внимание, что система не повторяет вопросы, ответы на которые ей "
"уже известны.\n"
"При рассмотрении правил 75 и 52 она уже знает, что посев произошел из крови, "
"и что пациент является скомпрометированным хозяином и серьезным ожоговым "
"пациентом.\n"
"В конце концов, правило 73 способствует выводу о бактероидах, а правила 75 и "
"52 снова объединяются, чтобы предложить pseudomonas, хотя и с более низким "
"фактором уверенности, потому что  обнаружение neg имело более низкий фактор "
"уверенности:"

#: in/chapter16.md:1134
msgid ""
"```lisp\n"
"Findings for ORGANISM-2:\n"
"  IDENTITY: BACTEROIDES (0.720) PSEUDOMONAS (0.646)\n"
"```"
msgstr ""

#: in/chapter16.md:1136
msgid ""
"Finally, the program gives the user the opportunity to extend the context "
"tree with new organisms, cultures, or patients:"
msgstr ""
"Наконец, программа дает пользователю возможность расширить контекстное "
"дерево новыми организмами, культурами или пациентами:"

#: in/chapter16.md:1139
msgid ""
"`Is there another ORGANISM?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1142
msgid ""
"`Is there another CULTURE?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1145
msgctxt "in/chapter16.md:1145"
msgid ""
"`Is there another PATIENT?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1147
msgid ""
"The set of rules listed above do not demonstrate two important features of "
"the system: the ability to backward-chain, and the ability to use operators "
"other than i s in premises."
msgstr ""
"Набор правил, перечисленных выше, не демонстрирует двух важных характеристик "
"системы: возможность обратной цепочки и возможность использовать операторы, "
"отличные от тех, которые находятся в помещении. "

#: in/chapter16.md:1150
msgid ""
"If we add the following three rules and repeat the case shown above, then "
"evaluating rule 75 will back-chain to rule 1, 2, and finally 3 trying to "
"determine if the patient is a compromised host.\n"
"Note that the question asked will be \"What is Sylvia Fischer's white blood "
"cell count?\" and not \"Is the white blood cell count of Sylvia Fischer < "
"2.5?\" The latter question would suffice for the premise at hand, but it "
"would not be as useful for other rules that might refer to the WBC."
msgstr ""
"Если мы добавим следующие три правила и повторим случай, показанный выше, то "
"вычисление правила 75 вернется к правилу 1, 2 и, наконец, 3, пытаясь "
"определить, является ли пациент скомпрометированным хозяином.\n"
"Обратите внимание, что задается вопрос: \"What is Sylvia Fischer's white "
"blood cell count?\"(Какое количество лейкоцитов у Сильвии Фишер?), а не \"Is "
"the white blood cell count of Sylvia Fischer < 2.5?\"(Является ли количество "
"лейкоцитов Сильвии Фишер < 2.5?) Последний вопрос будет достаточным для "
"рассматриваемой предпосылки, но не будет столь же полезным для других "
"правил, которые могут относиться к WBC."

#: in/chapter16.md:1164
msgid ""
"```lisp\n"
"(defparm wbc patient number\n"
"  \"What is ~a's white blood cell count?\")\n"
"(defrule 1\n"
"  if (immunosuppressed patient is yes)\n"
"  then 1.0 (compromised-host patient is yes))\n"
"(defrule 2\n"
"  if (leukopenia patient is yes)\n"
"  then 1.0 (immunosuppressed patient is yes))\n"
"(defrule 3\n"
"  if (wbc patient <  2.5)\n"
"  then .9 (leukopenia patient is yes))\n"
"```"
msgstr ""

#: in/chapter16.md:1166
msgid "## 16.9 Alternatives to Certainty Factors"
msgstr "## 16.9 Альтернативы факторам уверенности"

#: in/chapter16.md:1170
msgid ""
"Certainty factors are a compromise.\n"
"The good news is that a system based on rules with certainty factors "
"requires the expert to come up with only a small set of numbers (one for "
"each rule) and will allow fast computation of answers.\n"
"The bad news is that the answer computed may lead to irrational decisions."
msgstr ""
"Факторы уверенности - это компромисс.\n"
"Хорошая новость заключается в том, что система, основанная на правилах с "
"факторами уверенности, требует, чтобы эксперт придумал только небольшой "
"набор чисел (по одному для каждого правила), и позволит быстро вычислять "
"ответы.\n"
"Плохая новость в том, что вычисленный ответ может привести к иррациональным "
"решениям."

#: in/chapter16.md:1174
msgid ""
"Certainty factors have been justified by their performance (MYCIN performed "
"as well or better than expert doctors) and by intuitive appeal (they satisfy "
"the criteria listed on page 534).\n"
"However, they are subject to paradoxes where they compute bizarre results "
"(as in Exercise 16.1, page 536).\n"
"If the rules that make up the knowledge base are designed in a modular "
"fashion, then problems usually do not arise, but it is certainly worrisome "
"that the answers may be untrustworthy."
msgstr ""
"Факторы уверенности были подтверждены их эффективностью (MYCIN работает так "
"же или лучше, чем опытные врачи) и интуитивным обращением (они удовлетворяют "
"критериям, перечисленным на странице 534).\n"
"Однако они подвержены парадоксам, когда вычисляют странные результаты (как в "
"упражнении 16.1, стр. 536).\n"
"Если правила, составляющие базу знаний, построены по модульному принципу, то "
"проблем обычно не возникает, но, безусловно, вызывает беспокойство то, что "
"ответы могут быть недостоверными."

#: in/chapter16.md:1188
msgid ""
"Before MYCIN, most reasoning with uncertainty was done using probability "
"theory.\n"
"The laws of probability-in particular, Bayes's law-provide a well-founded "
"mathematical formalism that is not subject to the inconsistencies of "
"certainty factors.\n"
"Indeed, probability theory can be shown to be the only formalism that leads "
"to rational behavior, in the sense that if you have to make a series of bets "
"on some uncertain events, combining information with probability theory will "
"give you the highest expected value for your bets.\n"
"Despite this, probability theory was largely set aside in the mid-1970s.\n"
"The argument made by [Shortliffe and Buchanan (1975)](B9780080571157500285."
"xhtml#bb1105) was that probability theory required too many conditional "
"probabilities, and that people were not good at estimating these.\n"
"They argued that certainty factors were intuitively easier to deal with.\n"
"Other researchers of the time shared this view.\n"
"Shafer, with later refinements by Dempster, created a theory of belief "
"functions that, like certainty factors, represented a combination of the "
"belief for and against an event.\n"
"Instead of representing an event by a single probability or certainty, "
"Dempster-Shafer theory maintains two numbers, which are analagous to the "
"lower and upper bound on the probability.\n"
"Instead of a single number like .5, Dempster-Shafer theory would have an "
"interval like [.4,.6] to represent a range of probabilities.\n"
"A complete lack of knowledge would be represented by the range [0,1].\n"
"A great deal of effort in the late 1970s and early 1980s was invested in "
"these and other nonprobabilistic theories.\n"
"Another example is Zadeh's fuzzy set theory, which is also based on "
"intervais."
msgstr ""
"До MYCIN большинство рассуждений о неопределенности делалось с помощью "
"теории вероятностей.\n"
"Законы вероятности - в частности, закон Байеса - представляют собой хорошо "
"обоснованный математический формализм, который не зависит от несоответствий "
"факторов уверенности.\n"
"Действительно, можно показать, что теория вероятностей является единственным "
"формализмом, ведущим к рациональному поведению, в том смысле, что если вам "
"нужно сделать серию ставок на некоторые неопределенные события, объединение "
"информации с теорией вероятности даст вам наивысшую ожидаемую ценность для "
"вашего Пари.\n"
"Несмотря на это, в середине 1970-х от теории вероятностей отказались.\n"
"Аргумент, сделанный [Шортлиффом и Бьюкененом (1975)](B9780080571157500285."
"xhtml#bb1105), заключался в том, что теория вероятностей требует слишком "
"большого количества условных вероятностей и что люди не умеют их оценивать.\n"
"Они утверждали, что с факторами уверенности интуитивно легче справиться.\n"
"Эту точку зрения разделяли и другие исследователи того времени.\n"
"Шафер с последующими уточнениями Демпстера создал теорию функций убеждений, "
"которая, как и факторы уверенности, представляет собой комбинацию убеждений "
"за и против события.\n"
"Вместо того, чтобы представлять событие единственной вероятностью или "
"определенностью, теория Демпстера-Шафера поддерживает два числа, которые "
"аналогичны нижней и верхней границе вероятности.\n"
"Вместо одного числа, такого как .5, теория Демпстера-Шейфера будет иметь "
"интервал вроде [.4, .6], представляющий диапазон вероятностей.\n"
"Полное отсутствие знаний будет представлено диапазоном [0,1].\n"
"В конце 1970-х - начале 1980-х годов было вложено много усилий в эти и "
"другие невероятностные теории.\n"
"Другой пример - теория нечетких множеств Заде, которая также основана на "
"интервалах."

#: in/chapter16.md:1193
msgid ""
"There is ample evidence that people have difficulty with problems involving "
"probability.\n"
"In a very entertaining and thought-provoking series of articles, Tversky and "
"Kahneman ([1974](B9780080571157500285.xhtml#bb1245), [1983]"
"(B9780080571157500285.xhtml#bb1250), [1986](B9780080571157500285."
"xhtml#bb1255)) show how people make irrational choices when faced with "
"problems that are quite simple from a mathematical viewpoint.\n"
"They liken these errors in choice to errors in visual perception caused by "
"optical illusions.\n"
"Even trained doctors and statisticians are subject to these errors."
msgstr ""
"Существует множество свидетельств того, что людям трудно решать проблемы, "
"связанные с вероятностью.\n"
"В серии очень занимательных и наводящих на размышления статей Тверски и "
"Канеман ([1974](B9780080571157500285.xhtml#bb1245), [1983]"
"(B9780080571157500285.xhtml#bb1250), [1986](B9780080571157500285."
"xhtml#bb1255)) как люди делают иррациональный выбор, когда сталкиваются с "
"проблемами, довольно простыми с математической точки зрения.\n"
"Они сравнивают эти ошибки в выборе с ошибками визуального восприятия, "
"вызванными оптическими иллюзиями.\n"
"Этим ошибкам подвержены даже обученные врачи и статистики."

#: in/chapter16.md:1206
msgid ""
"As an example, consider the following scenario.\n"
"Adrian and Dominique are to be married.\n"
"Adrian goes for a routine blood test and is told that the results are "
"positive for a rare genetic disorder, one that strikes only 1 in 10,000 "
"people.\n"
"The doctor says that the test is 99% accurate-it gives a false positive "
"reading in only 1 in 100 cases.\n"
"Adrian is despondent, being convinced that the probability of actually "
"having the disease is 99%.\n"
"Fortunately, Dominique happens to be a Bayesian, and quickly reassures "
"Adrian that the chance is more like 1 %.\n"
"The reasoning is as follows: Take 10,001 people at random.\n"
"Of these, only 1 is expected to have the disease.\n"
"That person could certainly expect to test positive for the disease.\n"
"But if the other 10,000 people all took the blood test, then 1 % of them, or "
"100 people would also test positive.\n"
"Thus, the chance of actually having the disease given that one tests "
"positive is 1/101.\n"
"Doctors are trained in this kind of analysis, but unfortunately many of them "
"continue to reason more like Adrian than Dominique."
msgstr ""
"В качестве примера рассмотрим следующий сценарий.\n"
"Адриан и Доминика собираются пожениться.\n"
"Адриан идет на обычный анализ крови, и ему говорят, что результаты "
"положительны для редкого генетического заболевания, которым страдает только "
"1 человек из 10 000.\n"
"Врач говорит, что тест на 99% точен - он дает ложноположительные результаты "
"только в 1 из 100 случаев.\n"
"Адриан подавлен, будучи убежденным, что вероятность того, что действительно "
"заболеть, составляет 99%.\n"
"К счастью, Доминика оказалась знакомой с байесовской теорией и быстро "
"успокоила Адриана, что вероятность около 1%.\n"
"Рассуждения таковы: возьмите 10 001 человека наугад.\n"
"Предполагается, что из них только 1 болен.\n"
"Этот человек определенно мог ожидать положительный результат теста на "
"болезнь.\n"
"Но если все остальные 10 000 человек сдадут анализ крови, то 1% из них или "
"100 человек также будут иметь положительный результат.\n"
"Таким образом, вероятность того, что действительно заболеть, при "
"положительном результате теста составляет 1/101.\n"
"Докторов обучили такому анализу, но, к сожалению, многие из них продолжают "
"рассуждать больше как Адриан, чем Доминика."

#: in/chapter16.md:1213
msgid ""
"In the late 1980s, the tide started to turn back to subjective Bayesian "
"probability theory.\n"
"[Cheeseman (1985)](B9780080571157500285.xhtml#bb0185) showed that, while "
"Dempster-Shafer theory looks like it can, in fact it cannot help you make "
"better decisions than probability theory.\n"
"[Heckerman (1986)](B9780080571157500285.xhtml#bb0525) re-examined MYCIN's "
"certainty factors, showing how they could be interpreted as probabilities.\n"
"Judea [Pearl's 1988](B9780080571157500285.xhtml#bb0935) book is an eloquent "
"defense of probability theory.\n"
"He shows that there are efficient algorithms for combining and propagating "
"probabilities, as long as the network of interdependencies does not contain "
"loops.\n"
"It seems likely that uncertain reasoning in the 1990s will be based "
"increasingly on Bayesian probability theory."
msgstr ""
"В конце 1980-х годов волна субъективной байесовской теории вероятностей "
"начала возвращаться.\n"
"[Cheeseman (1985)](B9780080571157500285.xhtml#bb0185) показал, что, хотя "
"теория Демпстера-Шафера выглядит способной, на самом деле она не может "
"помочь вам принимать лучшие решения, чем теория вероятностей.\n"
"[Хекерман (1986)] (B9780080571157500285.xhtml#bb0525) повторно исследовал "
"факторы достоверности MYCIN, показывая, как их можно интерпретировать как "
"вероятности.\n"
"Книга Иудеи [Перл, 1988](B9780080571157500285.xhtml#bb0935) является "
"красноречивой защитой теории вероятностей.\n"
"Он показывает, что существуют эффективные алгоритмы для объединения и "
"распространения вероятностей, пока сеть взаимозависимостей не содержит "
"петель.\n"
"Кажется вероятным, что неопределенные рассуждения в 1990-х годах все больше "
"будут основываться на байесовской теории вероятностей."

#: in/chapter16.md:1215
msgid "## 16.10 History and References"
msgstr "## 16.10 История и Ссылки"

#: in/chapter16.md:1219
msgid ""
"The MYCIN project is well documented in [Buchanan and Shortliffe 1984]"
"(B9780080571157500285.xhtml#bb0145).\n"
"An earlier book, [Shortliffe 1976](B9780080571157500285.xhtml#bb1100), is "
"interesting mainly for historical purposes.\n"
"Good introductions to expert systems in general include [Weiss and "
"Kulikowski 1984](B9780080571157500285.xhtml#bb1365), [Waterman 1986]"
"(B9780080571157500285.xhtml#bb1345), [Luger and Stubblefield 1989]"
"(B9780080571157500285.xhtml#bb0760), and [Jackson 1990](B9780080571157500285."
"xhtml#bb0580)."
msgstr ""

#: in/chapter16.md:1222
msgid ""
"Dempster-Shafer evidence theory is presented enthusiastically in [Gordon and "
"Shortliffe 1984](B9780080571157500285.xhtml#bb0485) and in a critical light "
"in [Pearl 1989](B9780080571157500285.xhtml#bb0940)/1978.\n"
"Fuzzy set theory is presented in Zadeh 1979 and [Dubois and Prade 1988]"
"(B9780080571157500285.xhtml#bb0350)."
msgstr ""

#: in/chapter16.md:1225
msgid ""
"[Pearl (1988)](B9780080571157500285.xhtml#bb0935) captures most of the "
"important points that lead to the renaissance of probability theory.\n"
"[Shafer and Pearl 1990](B9780080571157500285.xhtml#bb1090) is a balanced "
"collection of papers on all kinds of uncertain reasoning."
msgstr ""

#: in/chapter16.md:1227
msgid "## 16.11 Exercises"
msgstr "## 16.11 Упражнения"

#: in/chapter16.md:1230
msgid ""
"**Exercise  16.2 [s]** Suppose the rule writer wanted to be able to use "
"symbolic certainty factors instead of numbers.\n"
"What would you need to change to support rules like this:"
msgstr ""

#: in/chapter16.md:1235
msgid ""
"```lisp\n"
"(defrule 100 if ... then true ...)\n"
"(defrule 101 if ... then probably ...)\n"
"```"
msgstr ""

#: in/chapter16.md:1237
msgid ""
"**Exercise  16.3 [m]** Change `prompt-and-read-vals` so that it gives a "
"better prompt for parameters of type `yes/no`."
msgstr ""

#: in/chapter16.md:1242
msgid ""
"**Exercise  16.4 [m]** Currently, the rule writer can introduce a new "
"parameter without defining it first.\n"
"That is handy for rapid testing, but it means that the user of the system "
"won't be able to see a nice English prompt, nor ask for the type of the "
"parameter.\n"
"In addition, if the rule writer simply misspells a parameter, it will be "
"treated as a new one.\n"
"Make a simple change to fix these problems."
msgstr ""

#: in/chapter16.md:1246
msgid ""
"**Exercise  16.5 [d]** Write rules in a domain you are an expert in, or find "
"and interview an expert in some domain, and write down rules coaxed from the "
"expert.\n"
"Evaluate your resulting system.\n"
"Was it easier to develop your system with EMYCIN than it would have been "
"without it?"
msgstr ""

#: in/chapter16.md:1249
msgid ""
"**Exercise  16.6 [s]** It is said that an early version of MYCIN asked if "
"the patient was pregnant, even though the patient was male.\n"
"Write a rule that would fix this problem."
msgstr ""

#: in/chapter16.md:1251
msgid ""
"**Exercise  16.7 [m]** To a yes/no question, what is the difference between "
"yes and `(no-1)` ? What does this suggest?"
msgstr ""

#: in/chapter16.md:1255
msgid ""
"**Exercise  16.8 [m]** What happens if the user types `why` to the prompt "
"about the patient's name?\n"
"What happens if the expert wants to have more than one context with a name "
"parameter?\n"
"If there is a problem, fix it."
msgstr ""

#: in/chapter16.md:1259
msgid ""
"The remaining exercises discuss extensions that were in the original EMYCIN, "
"but were not implemented in our version.\n"
"Implementing all the extensions will result in a system that is very close "
"to the full power of EMYCIN.\n"
"These extensions are discussed in [chapter 3](B9780080571157500030.xhtml) of "
"[Buchanan and Shortliffe 1984](B9780080571157500285.xhtml#bb0145)."
msgstr ""

#: in/chapter16.md:1264
msgid ""
"**Exercise  16.9 [h]** Add a spelling corrector to `ask-vals`.\n"
"If the user enters an invalid reply, and the parameter type is a `member` "
"expression, check if the reply is \"close\" in spelling to one of the valid "
"values, and if so, use that value.\n"
"That way, the user can type just `entero` instead of `enterobacteriaceae`.\n"
"You may experiment with the definition of \"close,\" but you should "
"certainly allow for prefixes and at least one instance of a changed, "
"missing, inserted, or transposed letter."
msgstr ""

#: in/chapter16.md:1267
msgid ""
"**Exercise  16.10 [m]** Indent the output for each new branch in the context "
"tree.\n"
"In other words, have the prompts and findings printed like this:"
msgstr ""

#: in/chapter16.md:1275
msgid ""
"```lisp\n"
"------ PATIENT-1 ------\n"
"Patient's name: Sylvia Fischer\n"
"Sex: female\n"
"Age: 27\n"
"      ------ CULTURE-1 ------\n"
"```"
msgstr ""

#: in/chapter16.md:1278
msgid ""
"`      From what site was the specimen for CULTURE-1 taken?\n"
"blood`"
msgstr ""

#: in/chapter16.md:1281
msgid ""
"`      How many days ago was this culture (CULTURE-1) obtained?\n"
"3`"
msgstr ""

#: in/chapter16.md:1290
msgid ""
"```lisp\n"
"          ------ ORGANISM-1 ------\n"
"          Enter the identity (genus) of ORGANISM-1: unknown\n"
"          The gram stain of ORGANISM-1: neg\n"
"          ...\n"
"          Findings for ORGANISM-1:\n"
"            IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)\n"
"```"
msgstr ""

#: in/chapter16.md:1293
msgid ""
"`          Is there another ORGANISM?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1296
msgid ""
"`      Is there another CULTURE?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1299
msgctxt "in/chapter16.md:1299"
msgid ""
"`Is there another PATIENT?\n"
"(Y or N) N`"
msgstr ""

#: in/chapter16.md:1305
msgid ""
"**Exercise  16.11 [h]** We said that our `emycin` looks at all possible "
"rules for each parameter, because there is no telling how a later rule may "
"affect the certainty factor.\n"
"Actually, that is not quite true.\n"
"If there is a rule that leads to a conclusion with certainty 1, then no "
"other rules need be considered.\n"
"This was called a *unity path*.\n"
"Modify the program to look for unity paths first."
msgstr ""

#: in/chapter16.md:1313
msgid ""
"**Exercise  16.12 [m]** Depending on whether a parameter is in `initial-"
"data` or not, all the relevant rules are run either before or after asking "
"the user for the value of the parameter.\n"
"But there are some cases when not all initial data parameters should be "
"asked for.\n"
"As an example, suppose that `identity` and `gram` were initial data "
"parameters of `organism`.\n"
"If the user gave a positive answer for `identity`, then it would be wasteful "
"to ask for the `gram` parameter, since it could be determined directly from "
"rules.\n"
"After receiving complaints about this problem, a system of *antecedent "
"rules* was developed.\n"
"These rules were always run first, before asking questions.\n"
"Implement antecedent rules."
msgstr ""

#: in/chapter16.md:1316
msgid ""
"**Exercise  16.13 [h]** It is useful to be able to write *default rules* "
"that fill in a value after all other rules have failed to determine one.\n"
"A default rule looks like this:"
msgstr ""

#: in/chapter16.md:1320
msgid ""
"```lisp\n"
"(defrule n if (parm inst unknown) then (parm inst is default))\n"
"```"
msgstr ""

#: in/chapter16.md:1323
msgid ""
"It may also have other conjuncts in the premise.\n"
"Beside details like writing the `unknown` operator, the difficult part is in "
"making sure that these rules get run at the right time (after other rules "
"have had a chance to fill in the parameter), and that infinite loops are "
"avoided."
msgstr ""

#: in/chapter16.md:1326
msgid ""
"**Exercise  16.14 [h]** The context tree proved to be a limitation.\n"
"Eventually, the need arose for a rule that said, \"If any of the organisms "
"in a culture has property X, then the culture has property Y.\" Implement a "
"means of checking for `some` or `every` instance of a context."
msgstr ""

#: in/chapter16.md:1329
msgid ""
"**Exercise  16.15 [m]** As the rule base grew, it became increasingly hard "
"to remember the justification for previous rules.\n"
"Implement a mechanism that keeps track of the author and date of creation of "
"each rule, and allows the author to add documentation explaining the "
"rationale for the rule."
msgstr ""

#: in/chapter16.md:1333
msgid ""
"**Exercise  16.16 [m]** It is difficult to come up with the perfect prompt "
"for each parameter.\n"
"One solution is not to insist that one promptfits all users, but rather to "
"allow the expert to supply three different prompts: a normal prompt, a "
"verbose prompt (or reprompt) for when the user replies with a ?, and a terse "
"prompt for the experienced user.\n"
"Modify `defparm` to accommodate this concept, add a command for the user to "
"ask for the terse prompts, and change `ask-vals` to use the proper prompt."
msgstr ""

#: in/chapter16.md:1335
msgid ""
"The remaining exercises cover three additional replies the user can make: "
"`how`, `stop`, and `change`."
msgstr ""

#: in/chapter16.md:1340
msgid ""
"**Exercise  16.17 [d]** In addition to `why` replies, EMYCIN also allowed "
"for `how` questions.\n"
"The user can ask how the value of a particular parameter/instance pair was "
"determined, and the system will reply with a list of rules and the evidence "
"they supplied for or against each value.\n"
"Implement this mechanism.\n"
"It will require storing additional information in the data base."
msgstr ""

#: in/chapter16.md:1343
msgid ""
"**Exercise  16.18 [m]** There was also a stop command that immediately "
"halted the session.\n"
"Implement it."
msgstr ""

#: in/chapter16.md:1350
msgid ""
"**Exercise  16.19 [d]** The original EMYCIN also had a change command to "
"allow the user to change the answer to certain questions without starting "
"all over.\n"
"Each question was assigned a number, which was printed before the prompt.\n"
"The command change, followed by a list of numbers, causes the system to look "
"up the questions associated with each number and delete the answer to these "
"questions.\n"
"The system also throws away the entire context tree and all derived "
"parameter values.\n"
"At that point the entire consultation is restarted, using only the data "
"obtained from the unchanged questions.\n"
"Although it may seem wasteful to start over from the beginning, it will not "
"be wasteful of the user's time, since correct answers will not be asked "
"again."
msgstr ""

#: in/chapter16.md:1352
msgid ""
"Identify what needs to be altered to implement change and make the "
"alterations."
msgstr ""

#: in/chapter16.md:1355
msgid ""
"**Exercise  16.20 [h]** Change the definition of `cf`-and and `cf-or` to use "
"fuzzy set theory instead of certainty factors.\n"
"Do the same for Dempster-Shafer theory."
msgstr ""

#: in/chapter16.md:1357
msgid "## 16.12 Answers"
msgstr "## 16.12 Ответы"

#: in/chapter16.md:1361
msgid ""
"**Answer 16.1** Because EMYCIN assumes independence, each reading of the "
"same headline would increase the certainty factor.\n"
"The following computation shows that 298 more copies would be needed to "
"reach .95 certainty.\n"
"A more sophisticated reasoner would realize that multiple copies of a "
"newspaper are completely dependent on one another, and would not change the "
"certainty with each new copy."
msgstr ""

#: in/chapter16.md:1368
msgid ""
"```lisp\n"
"> (loop for cf = .01 then (cf-or .01 cf)\n"
"      until (> cf .95)\n"
"      count t)\n"
"298\n"
"```"
msgstr ""

#: in/chapter16.md:1371
msgid ""
"**Answer 16.2** The `defrule` expandsto (`make-rule :number '101 :cf true ..."
"`); that is, the certainty factor is unquoted, so it is already legal to use "
"true as a certainty factor!\n"
"To support `probably` and other hedges, just define new constants."
msgstr ""

#: in/chapter16.md:1374
msgid ""
"**Answer 16.4** Just make the default parameter type be `nil` (by changing "
"`t` to `nil` in `parm-type`).\n"
"Then any rule that uses an undefined parameter will automatically generate a "
"warning."
msgstr ""

#: in/chapter16.md:1376
msgid "**Answer 16.6**"
msgstr ""

#: in/chapter16.md:1382
msgid ""
"```lisp\n"
"(defrule 4\n"
"  if (sex patient is male)\n"
"  then -  1 (pregnant patient is yes))\n"
"```"
msgstr ""

#: in/chapter16.md:1388
msgid ""
"**Answer 16.7** Logically, there should be no difference, but to EMYCIN "
"there is a big difference.\n"
"EMYCIN would not complain if you answered `(yes 1 no 1)`.\n"
"This suggests that the system should have some way of dealing with mutually "
"exclusive answers.\n"
"One way would be to accept only yes responses for Boolean parameters, but "
"have the input routine translate no to `(yes -1)` and `(no *cf*)` to `(yes 1-"
"*cf*)`.\n"
"Another possibility would be to have `update-cf check` to see if any "
"certainty factor on a mutually exclusive value is 1, and if so, change the "
"other values to -1."
msgstr ""

#: in/chapter16.md:1390
msgid ""
"**Answer 16.18** Add the clause `(stop (throw 'stop nil))` to the case "
"statement inask-valsandwrapa `(catch 'stop ...)` around the code in `emycin`."
msgstr ""
