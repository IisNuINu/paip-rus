#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter1.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-09-24 09:50+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter1.md:3
msgid ""
"# Chapter 1\n"
"## Introduction to Lisp"
msgstr ""
"# Глава 1\n"
"## Введение в Лисп"

#: in/chapter1.md:5
msgid ""
"> You think you know when you learn, are more sure when you can write, even "
"more when you can teach, but certain when you can program."
msgstr ""
"> Вы думаете, что знаете, когда вы учитесь, более уверены, когда вы можете "
"писать, еще более уверены, когда вы можете учить, но по настоящему вы "
"уверены, когда можете программировать."

#: in/chapter1.md:8
msgid ""
"> -Alan Perlis  \n"
"> Yale University computer scientist"
msgstr ""
"> -Alan Perlis  \n"
"> Yale University computer scientist"

#: in/chapter1.md:13
msgid ""
"This chapter is for people with little or no experience in Lisp.\n"
"Readers who feel confident in their Lisp programming ability can quickly "
"skim the chapter or skip it entirely.\n"
"This chapter necessarily moves quickly, so those with little programming "
"experience, or any reader who finds this chapter tough going, should seek "
"out a supplementary introductory text.\n"
"My recommendations are in the preface."
msgstr ""
"Эта глава предназначена для людей с небольшим или полным отсутствием опыта "
"работы на Лиспе.\n"
"Читатели, уверенные в своих способностях к программированию на Лиспе, могут "
"быстро просмотреть эту главу или пропустить ее полностью.\n"
"Эта глава пробегает по верхам, поэтому те, у кого мало опыта "
"программирования, или любой читатель, который находит эту главу трудной, "
"должны искать дополнительный ознакомительный текст.\n"
"Мои рекомендации приведены в предисловии."

#: in/chapter1.md:17
msgid ""
"Computers allow one to carry out computations.\n"
"A word processing program deals with words while a calculator deals with "
"numbers, but the principles are the same.\n"
"In both cases, you provide the input (words or numbers) and specify the "
"operations (such as deleting a word or adding two numbers) to yield a result "
"(a completed document or calculation)."
msgstr ""
"Компьютеры позволяют производить вычисления.\n"
"Программа обработки текстов имеет дело со словами, а калькулятор - с "
"числами, но принципы те же.\n"
"В обоих случаях вы вводите входные данные (слова или числа) и указываете "
"операции (например, удаление слова или сложение двух чисел) для получения "
"результата (завершенного документа или вычисления)."

#: in/chapter1.md:21
msgid ""
"We will refer to anything that can be represented in the memory of a "
"computer as a *computational object,* or just an *object.*\n"
"So, words, paragraphs, and numbers can be objects.\n"
"And because the operations (deleting and adding) must be represented "
"somewhere in the computer's memory, they are objects, too."
msgstr ""
"Мы будем называть все, что может быть представлено в памяти компьютера как "
"*вычислительный объект* или просто *объект*.\n"
"Таким образом, слова, абзацы и числа могут быть объектами.\n"
"И поскольку операции (удаление и добавление) должны быть представлены где-то "
"в памяти компьютера, они также являются объектами."

#: in/chapter1.md:29
msgid ""
"Normally, the distinction between a computer \"user\" and a computer "
"\"programmer\" is that the user provides new input, or data (words or "
"numbers), while the programmer defines new *operations*, or programs, as "
"well as new *types* of data.\n"
"Every new object, be it datum or operation, must be defined in terms of "
"previously defined objects.\n"
"The bad news is that it can be quite tedious to get these definitions "
"right.\n"
"The good news is that each new object can in turn be used in the definition "
"of future objects.\n"
"Thus, even complex programs can be built out of smaller, simpler objects.\n"
"This book covers a number of typical AI problems, showing how each problem "
"can be broken down into manageable pieces, and also how each piece can be "
"described in the programming language Common Lisp.\n"
"Ideally, readers will learn enough through studying these examples to attack "
"new AI problems with style, grace, and success."
msgstr ""
"Обычно различие между компьютерным \"пользователем\" и компьютерным "
"\"программистом\" состоит в том, что пользователь предоставляет новые "
"входные данные или данные (слова или числа), в то время как программист "
"определяет новые операции(*operations*) или программы, а также новые "
"типы(*types*) данных.\n"
"Каждый новый объект, будь то данные(datum) или операция, должен быть "
"определен в терминах ранее определенных объектов.\n"
"Плохая новость заключается в том, что это может быть довольно утомительно, "
"чтобы получить эти определения правильно.\n"
"Хорошая новость заключается в том, что каждый новый объект, в свою очередь, "
"может быть использован в определении будущих объектов.\n"
"Таким образом, даже сложные программы могут быть построены из более мелких и "
"простых объектов.\n"
"Эта книга охватывает ряд типичных проблем искусственного интеллекта, "
"показывая, как каждая проблема может быть разбита на управляемые части, а "
"также как каждая часть может быть описана на языке программирования Common "
"Lisp.\n"
"В идеале, читатели узнают достаточно, изучая эти примеры, чтобы атаковать "
"новые проблемы ИИ со стилем, изяществом и успехом."

#: in/chapter1.md:35
msgid ""
"Let's consider a simple example of a computation: finding the sum of two "
"numbers, let's say 2 and 2.\n"
"If we had a calculator handy, we would type \"2 + 2 =\" and see the answer "
"displayed.\n"
"On a calculator using reverse Polish notation, we would have to type \"2 2 +"
"\" to see the same answer.\n"
"In Lisp, as with the calculator, the user carries out an interactive dialog "
"with the computer by typing in an expression and seeing the computer print "
"the value of that expression.\n"
"This interactive mode is different from many other programming languages "
"that only offer a batch mode, wherein an entire program is compiled and run "
"before any output can be seen."
msgstr ""
"Рассмотрим простой пример вычисления: найти сумму двух чисел, скажем 2 и 2.\n"
"Если бы у нас был под рукой калькулятор, мы набрали бы \"2 + 2 =\" и увидели "
"бы отображаемый ответ.\n"
"На калькуляторе, использующем обратную польскую нотацию, мы должны были бы "
"ввести \"2 2 +\", чтобы увидеть тот же ответ.\n"
"В Lisp, как и в калькуляторе, пользователь выполняет интерактивный диалог с "
"компьютером, вводя выражение и смотря, как компьютер печатает значение этого "
"выражения.\n"
"Этот интерактивный режим отличается от многих других языков "
"программирования, которые предлагают только пакетный режим, в котором вся "
"программа компилируется и запускается до того, как можно увидеть какой-либо "
"вывод."

#: in/chapter1.md:41
msgid ""
"We start up a pocket calculator by flipping the on/off switch.\n"
"The Lisp program must also be started, but the details vary from one "
"computer to another, so I can't explain how your Lisp will work.\n"
"Assuming we have managed to start up Lisp, we are likely to see a *prompt* "
"of some kind.\n"
"On my computer, Lisp types \"`>`\" to indicate it is ready to accept the "
"next computation.\n"
"So we are faced with a screen that looks like this:"
msgstr ""
"Мы запускаем карманный калькулятор, щелкая выключателем включения/"
"выключения.\n"
"Программа Lisp также должна быть запущена, но детали варьируются от одного "
"компьютера к другому, поэтому я не могу объяснить, как будет работать ваш "
"Lisp.\n"
"Предполагая, что нам удалось запустить Lisp, мы, вероятно, увидим какую-то "
"подсказку.\n"
"На моем компьютере Lisp печатает \"'>'\", чтобы указать, что он готов "
"принять следующее вычисление.\n"
"Итак, перед нами экран, который выглядит следующим образом:"

#: in/chapter1.md:45
msgid ""
"```lisp\n"
">\n"
"```"
msgstr ""

#: in/chapter1.md:49
msgid ""
"We may now type in our computation and see the result displayed.\n"
"It turns out that the Lisp convention for arithmetic expressions is slightly "
"different: a computation consists of a parenthesized list with the operation "
"name first, followed by any number of operands, or arguments.\n"
"This is called *prefix notation.*"
msgstr ""
"Теперь мы можем ввести наши вычисления и увидеть результат.\n"
"Оказывается, что соглашение Lisp для арифметических выражений немного "
"отличается: вычисление состоит из заключенного в скобки списка с первым "
"именем операции, за которым следует любое количество операндов или "
"аргументов.\n"
"Это называется *префиксная нотация.*"

#: in/chapter1.md:55
msgid ""
"```lisp\n"
"> (+  2 2)\n"
"4\n"
">\n"
"```"
msgstr ""

#: in/chapter1.md:61
msgid ""
"We see that Lisp has printed the answer, 4, and then another prompt, >, to "
"indicate it is ready for the next computation.\n"
"Throughout this book, all Lisp expressions will be displayed in `typewriter` "
"font.\n"
"Text on the same line as the \">\" prompt is input typed by the user, and "
"text following it is output printed by the computer.\n"
"Usually, input that is typed by the programmer will be in `lowercase` "
"letters, while output that is printed back by the computer will be in "
"`UPPERCASE` letters.\n"
"Of course, with symbols like + and 4 there is no difference."
msgstr ""
"Мы видим, что Lisp напечатал ответ, 4, а затем еще одно приглашение, >, "
"чтобы указать, что он готов к следующему вычислению.\n"
"На протяжении всей этой книги все выражения Lisp будут отображаться шрифтом "
"`typewriter`.\n"
"Текст в той же строке, что и приглашение \">\", вводится пользователем, а "
"следующий за ним текст выводится компьютером.\n"
"Обычно ввод, введенный программистом, будет состоять из букв \"нижнего "
"регистра\"(`lowercase`), а вывод, напечатанный компьютером, - из букв "
"\"верхнего регистра\"(`UPPERCASE`).\n"
"Конечно, для таких символьных знаков как + и 4, нет никакой разницы."

#: in/chapter1.md:63
msgid ""
"To save space on the page, the output will sometimes be shown on the same "
"line as the input, separated by an arrow (=>), which can be read as "
"\"evaluates to,\" and can also be thought of as standing for the return or "
"enter key that the user presses to complete the input:"
msgstr ""
"Чтобы сэкономить место на странице, выходные данные иногда отображаются в "
"той же строке, что и входные данные, разделенные стрелкой ( = > ), которая "
"может быть прочитана как \"вычисляется\", а также может рассматриваться как "
"значение клавиши return или enter, которую пользователь нажимает для "
"завершения ввода:"

#: in/chapter1.md:67
msgid ""
"```lisp\n"
"> (+  2 2) => 4\n"
"```"
msgstr ""

#: in/chapter1.md:70
msgid ""
"One advantage of parenthesized prefix notation is that the parentheses "
"clearly mark the beginning and end of an expression.\n"
"If we want, we can give + more than two arguments, and it will still add "
"them all:"
msgstr ""
"Одним из преимуществ скобочной префиксной нотации является то, что скобки "
"четко обозначают начало и конец выражения.\n"
"Если мы хотим, мы можем передать + больше двух аргументов, и он все равно "
"сложит их все:"

#: in/chapter1.md:74
msgid ""
"```lisp\n"
"> (+ 1 2 3 4 5 6 7 8 9 10) => 55\n"
"```"
msgstr ""

#: in/chapter1.md:76
msgid "This time we try (9000 + 900 + 90  + 9) - (5000 + 500 + 50 + 5):"
msgstr ""
"На этот раз мы попытаемся вычислить (9000 + 900 + 90  + 9) - (5000 + 500 + "
"50 + 5):"

#: in/chapter1.md:80
msgid ""
"```lisp\n"
"> (- (+ 9000 900 90 9) (+ 5000 500 50 5)) => 4444\n"
"```"
msgstr ""

#: in/chapter1.md:87
msgid ""
"This example shows that expressions can be nested.\n"
"The arguments to the - function are parenthesized lists, while the arguments "
"to each `+` are atoms.\n"
"The Lisp notation may look unusual compared to standard mathematical "
"notation, but there are advantages to this notation; since Lisp expressions "
"can consist of a function followed by any number of arguments, we don't have "
"to keep repeating the `\"+.\"` More important than the notation is the rule "
"for evaluation.\n"
"In Lisp, lists are evaluated by first evaluating all the arguments, then "
"applying the function to the arguments, thereby computing the result.\n"
"This rule is much simpler than the rule for evaluating normal mathematical "
"expressions, where there are many conventions to remember, such as doing "
"multiplications and divisions before sums and differences.\n"
"We will see below that the actual Lisp evaluation rule is a little more "
"complicated, but not much."
msgstr ""
"Этот пример показывает, что выражения могут быть вложенными.\n"
"Аргументы функции \"-\" это заключенные в скобки списки, а аргументы каждой "
"функции \"+\" - атомы.\n"
"Лисп-нотация может показаться необычной по сравнению со стандартной "
"математической нотацией, но у этой нотации есть свои преимущества; поскольку "
"Лисп-выражения могут состоять из функции, за которой следует любое "
"количество аргументов, нам не нужно постоянно повторять `\"+.\"` Более "
"важным, чем нотация, является правило вычисления.\n"
"В Lisp списки вычисляются путем предварительного вычисления всех аргументов, "
"а затем применения функции к аргументам, тем самым вычисляя результат.\n"
"Это правило намного проще, чем правило для вычисления обычных математических "
"выражений, где есть много условностей, которые нужно запомнить, например, "
"делать умножения и деления перед сложением и вычитанием.\n"
"Ниже мы увидим, что фактическое правило вычисления в Lisp немного сложнее, "
"но не намного."

#: in/chapter1.md:95
msgid ""
"Sometimes programmers who are familiar with other languages have "
"preconceptions that make it difficult for them to learn Lisp.\n"
"For them, three points are worth stressing here.\n"
"First, many other languages make a distinction between statements and "
"expressions.\n"
"An expression, like `2 + 2`, has a value, but a statement, like `x  = 2 + "
"2`, does not.\n"
"Statements have effects, but they do not return values.\n"
"In Lisp, there is no such distinction: every expression returns a value.\n"
"It is true that some expressions have effects, but even those expressions "
"also return values."
msgstr ""
"Иногда программисты, знакомые с другими языками, имеют предубеждения, "
"которые затрудняют им изучение Лиспа.\n"
"Для них здесь стоит подчеркнуть три момента.\n"
"Во-первых, многие другие языки проводят различие между утверждениями и "
"выражениями.\n"
"Выражение, такое как `2 + 2`, имеет значение, но утверждение, такое как `x  "
"= 2 + 2`, не имеет значения.\n"
"Утверждения имеют эффекты, но они не возвращают значения.\n"
"В Lisp такого различия нет: каждое выражение возвращает значение.\n"
"Это правда, что некоторые выражения имеют эффекты, но даже эти выражения "
"также возвращают значения."

#: in/chapter1.md:101
msgid ""
"Second, the lexical rules for Lisp are much simpler than the rules for other "
"languages.\n"
"In particular, there are fewer punctuation characters: only parentheses, "
"quote marks (single, double, and backward), spaces, and the comma serve to "
"separate symbols from each other.\n"
"Thus, while the statement `y=a*x+3` is analyzed as seven separate tokens in "
"other languages, in Lisp it would be treated as a single symbol.\n"
"<a id=\"tfn01-1\"></a>\n"
"To get a list of tokens, we would have to insert spaces: `(y = a * x + 3)`."
"[1](#fn01-1)"
msgstr ""
"Во-вторых, лексические правила для Lisp намного проще, чем правила для "
"других языков.\n"
"В частности, меньше знаков препинания: только круглые скобки, кавычки "
"(одинарные, двойные и обратные), пробелы и запятая служат для отделения "
"символов друг от друга.\n"
"Таким образом, в то время как утверждение `y=a*x+3` анализируется как семь "
"отдельных лексем в других языках, в Lisp оно будет рассматриваться как один "
"символ.\n"
"<a id=\"tfn01-1\"></a>\n"
"Чтобы получить список токенов, мы должны были бы вставить пробелы: `(y = a * "
"x + 3)`.[1](#fn01-1)"

#: in/chapter1.md:104
msgid ""
"Third, while many languages use semicolons to delimit statements, Lisp has "
"no need of semicolons, since expressions are delimited by parentheses.\n"
"Lisp chooses to use semicolons for another purpose-to mark the beginning of "
"a comment, which lasts until the end of the line:"
msgstr ""
"В-третьих, хотя многие языки используют точки с запятой для разграничения "
"операторов, Lisp не нуждается в точках с запятой, поскольку выражения "
"разделяются скобками.\n"
"Lisp выбирает использовать точки с запятой для другой цели-для обозначения "
"начала комментария, который длится до конца строки"

#: in/chapter1.md:109
msgid ""
"```lisp\n"
"> (+ 2 2) ; this is a comment\n"
"4\n"
"```"
msgstr ""

#: in/chapter1.md:111
msgid "## 1.1 Symbolic Computation"
msgstr "## 1.1 Символьные вычисления"

#: in/chapter1.md:116
msgid ""
"All we've done so far is manipulate numbers in the same way a simple pocket "
"calculator would.\n"
"Lisp is more useful than a calculator for two main reasons.\n"
"First, it allows us to manipulate objects other than numbers, and second, it "
"allows us to define new objects that might be useful in subsequent "
"computations.\n"
"We will examine these two important properties in turn."
msgstr ""
"Все, что мы делали до сих пор, - это манипулировали числами так же, как "
"простой карманный калькулятор.\n"
"Lisp является более полезным, чем калькулятор по двум основным причинам.\n"
"Во-первых, он позволяет нам манипулировать объектами, отличными от чисел, а "
"во-вторых, он позволяет нам определять новые объекты, которые могут быть "
"полезны в последующих вычислениях.\n"
"Мы рассмотрим эти два важных свойства по очереди."

#: in/chapter1.md:120
msgid ""
"Besides numbers, Lisp can represent characters (letters), strings of "
"characters, and arbitrary symbols, where we are free to interpret these "
"symbols as referring to things outside the world of mathematics.\n"
"Lisp can also build nonatomic objects by combining several objects into a "
"list.\n"
"This capability is fundamental and well supported in the language; in fact, "
"the name Lisp is short for LISt Processing."
msgstr ""
"Помимо чисел, Lisp может представлять знаки(символьные знаки, буквы), строки "
"знаков и произвольные символы, где мы вольны интерпретировать эти символы "
"как относящиеся к вещам вне мира математики.\n"
"Lisp также может создавать неатомные объекты, объединяя несколько объектов в "
"список.\n"
"Эта возможность является фундаментальной и хорошо поддерживается в языке; на "
"самом деле, имя Lisp является сокращением для обработки списков."

#: in/chapter1.md:122
msgid "Here's an example of a computation on lists:"
msgstr "Вот пример вычисления со списками:"

#: in/chapter1.md:126
msgid ""
"```lisp\n"
"> (append '(Pat Kim) '(Robin Sandy)) => (PAT KIM ROBIN SANDY)\n"
"```"
msgstr ""

#: in/chapter1.md:129
msgid ""
"This expression appends together two lists of names.\n"
"The rule for evaluating this expression is the same as the rule for numeric "
"calculations: apply the function (in this case append) to the value of the "
"arguments."
msgstr ""
"Это выражение соединяет два списка имен.\n"
"Правило для вычисления этого выражения такое же, как правило для числовых "
"вычислений: примените функцию (в данном случае append) к значению аргументов."

#: in/chapter1.md:134
msgid ""
"The unusual part is the quote mark `(')`, which serves to block the "
"evaluation of the following expression, returning it literally.\n"
"If we just had the expression `(Pat Kim),` it would be evaluated by "
"considering `Pat` as a function and applying it to the value of the "
"expression `Kim`.\n"
"This is not what we had in mind.\n"
"The quote mark instructs Lisp to treat the list as a piece of data rather "
"than as a function call:"
msgstr ""
"Необычной частью является кавычка `(')`, которая служит для блокирования "
"вычисления следующего выражения, возвращая его буквально.\n"
"Если бы у нас было только выражение  `(Pat Kim),` оно было бы вычислено "
"путем рассмотрения `Pat` как функции и применения его к значению выражения "
"`Kim`.\n"
"Это не то, что  мы хотели сделать.\n"
"Кавычка указывает Lisp рассматривать список как часть данных, а не как вызов "
"функции:"

#: in/chapter1.md:138
msgid ""
"```lisp\n"
"> '(Pat Kim) (PAT KIM)\n"
"```"
msgstr ""

#: in/chapter1.md:144
msgid ""
"In other computer languages (and in English), quotes usually come in pairs: "
"one to mark the beginning, and one to mark the end.\n"
"In Lisp, a single quote is used to mark the beginning of an expression.\n"
"Since we always know how long a single expression is-either to the end of an "
"atom or to the matching parenthesis of a list-we don't need an explicit "
"punctuation mark to tell us where the expression ends.\n"
"Quotes can be used on lists, as in `'(Pat Kim)`, on symbols as in `'Robin`, "
"and in fact on anything else.\n"
"Here are some examples:"
msgstr ""
"На других компьютерных языках (и на английском) кавычки обычно идут парами: "
"одна для обозначения начала и одна для обозначения конца.\n"
"В Лиспе одинарная кавычка используется для обозначения начала выражения.\n"
"Поскольку мы всегда знаем, какой длины одиночное выражение - либо до конца "
"атома, либо до соответствующей круглой скобки списка - нам не нужен явный "
"знак пунктуации, чтобы сообщить нам, где заканчивается выражение.\n"
"Кавычки могут использоваться в списках, как в `'(Pat Kim)`, в символах, как "
"в `'Robin`, и фактически в любом другом месте.\n"
"Вот некоторые примеры:"

#: in/chapter1.md:147
msgid ""
"```lisp\n"
"> 'John => JOHN"
msgstr ""

#: in/chapter1.md:149
msgid "> '(John Q Public) => (JOHN Q PUBLIC)"
msgstr ""

#: in/chapter1.md:151
msgid "> '2 => 2"
msgstr ""

#: in/chapter1.md:153
msgid "> 2 => 2"
msgstr ""

#: in/chapter1.md:155
msgid "> '(+  2 2) => (+  2 2)"
msgstr ""

#: in/chapter1.md:157
msgid "> (+  2 2) 4"
msgstr ""

#: in/chapter1.md:159
msgid "> John => *Error: JOHN is not a bound variable*"
msgstr ""

#: in/chapter1.md:162
msgid ""
"> (John Q Public) => *Error: JOHN is not a function*\n"
"```"
msgstr ""

#: in/chapter1.md:166
msgid ""
"Note that `'2` evaluates to `2` because it is a quoted expression, and `2` "
"evaluates to `2` because numbers evaluate to themselves.\n"
"Same result, different reason.\n"
"In contrast, '`John` evaluates to `John` because it is a quoted expression, "
"but evaluating `John` leads to an error, because evaluating a symbol means "
"getting the value of the symbol, and no value has been assigned to `John.`"
msgstr ""
"Обратите внимание, что `'2` вычисляется как `2`, потому что это выражение в "
"кавычках, а `2` вычисляется как `2`, потому что числа вычисляются сами в "
"себя.\n"
"Тот же результат, другая причина.\n"
"Напротив, '`John` вычисляется как `John`, потому что это выражение в "
"кавычках, но вычисление `John` приводит к ошибке, потому что вычисление "
"символа означает получение значения символа, а значение `John` присвоено не "
"было."

#: in/chapter1.md:170
msgid ""
"Symbolic computations can be nested and even mixed with numeric "
"computations.\n"
"The following expression builds a list of names in a slightly different way "
"than we saw before, using the built-in function `list`.\n"
"We then see how to find the number of elements in the list, using the built-"
"in function `length:`"
msgstr ""
"Символьные вычисления могут быть вложенными и даже смешиваться с числовыми "
"вычислениями.\n"
"Следующее выражение создает список имен немного другим способом, чем мы "
"видели ранее, используя встроенную функцию `list`.\n"
"Затем мы увидим, как найти количество элементов в списке, используя "
"встроенную функцию `length:`"

#: in/chapter1.md:174
msgid ""
"```lisp\n"
"> (append '(Pat Kim) (list '(John Q Public) 'Sandy))\n"
"(PAT KIM (JOHN Q PUBLIC) SANDY)"
msgstr ""

#: in/chapter1.md:178
msgid ""
"> (length (append '(Pat Kim) (list '(John Q Public) 'Sandy)))\n"
"4\n"
"```"
msgstr ""

#: in/chapter1.md:180
msgid "There are four important points to make about symbols:"
msgstr "Есть четыре важных момента, которые нужно отметить о символах:"

#: in/chapter1.md:185
msgid ""
"*   First, it is important to remember that Lisp does not attach any "
"external significance to the objects it manipulates.\n"
"For example, we naturally think of (`Robin Sandy`) as a list of two first "
"names, and (`John Q Public`) as a list of one person's first name, middle "
"initial, and last name.\n"
"Lisp has no such preconceptions.\n"
"To Lisp, both `Robin` and `xyzzy` are perfectly good symbols."
msgstr ""
"*   Во-первых, важно помнить, что Lisp не придает никакого внешнего значения "
"объектам, которыми он манипулирует.\n"
"Например, мы, естественно, думаем о (`Robin Sandy`) как о списке двух имен, "
"а (`John Q Public`) как о списке состоящем из имени, среднего инициала и "
"фамилии одного человека.\n"
"У Лиспа нет таких предубеждений.\n"
"Для Лиспа, как `Robin`, так и `xyzzy`, оба очень хорошие символы."

#: in/chapter1.md:190
msgid ""
"*   Second, to do the computations above, we had to know that `append, "
"length`, and + are defined functions in Common Lisp.\n"
"Learning a language involves remembering vocabulary items (or knowing where "
"to look them up) as well as learning the basic rules for forming expressions "
"and determining what they mean.\n"
"Common Lisp provides over 700 built-in functions.\n"
"At some point the reader should flip through a reference text to see what's "
"there, but most of the important functions are presented in part I of this "
"book."
msgstr ""
"*   Во-вторых, чтобы выполнить приведенные выше вычисления, мы должны были "
"знать, что `append, length` и + являются определенными функциями в Common "
"Lisp.\n"
"Изучение языка включает в себя запоминание словарных единиц (или знание "
"того, где их искать), а также изучение основных правил формирования "
"выражений и определения того, что они означают.\n"
"Common Lisp предоставляет более 700 встроенных функций.\n"
"В какой-то момент читатель должен пролистать справочный текст, чтобы "
"увидеть, что там есть, но большинство важных функций представлены в части I "
"этой книги."

#: in/chapter1.md:194
msgid ""
"*   Third, note that symbols in Common Lisp are not case sensitive.\n"
"<a id=\"tfn01-2\"></a>\n"
"By that I mean that the inputs `John, john,` and `jOhN` all refer to the "
"same symbol, which is normally printed as `JOHN.`[2](#fn01-2)"
msgstr ""
"*   В-третьих, обратите внимание, что символы в Common Lisp не чувствительны "
"к регистру символьных знаков.\n"
"<a id=\"tfn01-2\"></a>\n"
"Под этим я подразумеваю, что входные данные `John, john,` и `jOhN` относятся "
"к одному и тому же символу, который обычно печатается как `JOHN.`[2](#fn01-2)"

#: in/chapter1.md:200
msgid ""
"*   Fourth, note that a wide variety of characters are allowed in symbols: "
"numbers, letters, and other punctuation marks like `'+'` or `'!'`\n"
"The exact rules for what constitutes a symbol are a little complicated, but "
"the normal convention is to use symbols consisting mostly of letters, with "
"words separated by a dash `(-)`, and perhaps with a number at the end.\n"
"Some programmers are more liberal in naming variables, and include "
"characters like `'?!$/<=>'`.\n"
"For example, a function to convert dollars to yen might be named with the "
"symbol `$-to-yen` or `$->yen` in Lisp, while one would use something like "
"`DollarsToYen, dollars_to_yen` or `dol2yen` in Pascal or C.\n"
"There are a few exceptions to these naming conventions, which will be dealt "
"with as they come up."
msgstr ""
"*   В-четвертых, обратите внимание, что в символах допускается большое "
"разнообразие символьных знаков: цифры, буквы и другие знаки препинания, "
"такие как `'+'`  или  `'!'`\n"
"Точные правила для того, что представляет собой символ, немного сложны, но "
"нормальное соглашение заключается в использовании символов, состоящих в "
"основном из букв, со словами, разделенными тире   `(-)`, и, возможно, с "
"числом в конце.\n"
"Некоторые программисты более либеральны в именовании переменных и включают "
"такие символы, как   `'?!$/<=>'`.\n"
"Например, функция конвертации долларов в иены может иметь имя, начинающееся "
"с символа   `$-to-yen`   или   `$->yen`    в Лиспе, хотя можно было бы "
"использовать что-то вроде   `DollarsToYen, dollars_to_yen`   или   "
"`dol2yen`   в Pascal или C.\n"
"Есть несколько исключений из этих соглашений об именовании, которые будут "
"рассмотрены по мере их появления."

#: in/chapter1.md:202
msgid "## 1.2 Variables"
msgstr "## 1.2 Переменные"

#: in/chapter1.md:208
msgid ""
"We have seen some of the basics of symbolic computation.\n"
"Now we move on to perhaps the most important characteristic of a programming "
"language: the ability to define new objects in terms of others, and to name "
"these objects for future use.\n"
"Here symbols again play an important role-they are used to name variables.\n"
"A variable can take on a value, which can be any Lisp object.\n"
"One way to give a value to a variable is with `setf`:"
msgstr ""
"Мы познакомились с некоторыми основами символических вычислений.\n"
"Теперь мы перейдем к, пожалуй, самой важной характеристике языка "
"программирования: способности определять новые объекты в терминах других и "
"давать им имена для дальнейшего использования.\n"
"Здесь символы снова играют важную роль - они используются для именования "
"переменных.\n"
"Переменная может принимать значение, которое может быть любым объектом "
"Lisp.\n"
"Один из способов дать значение переменной использовать `setf`:"

#: in/chapter1.md:216
msgid ""
"```lisp\n"
"> (setf p '(John Q Public)) => (JOHN Q PUBLIC)\n"
"> p => (JOHN Q PUBLIC)\n"
"> (setf x 10) => 10\n"
"> (+ x x) => 20\n"
"> (+ x (length p)) => 13\n"
"```"
msgstr ""

#: in/chapter1.md:219
msgid ""
"After assigning the value (`John Q Public`) to the variable named `p`, we "
"can refer to the value with the name `p`.\n"
"Similarly, after assigning a value to the variable named `x`, we can refer "
"to both `x` and `p`."
msgstr ""
"После присвоения значения (`John Q Public`) переменной с именем `p`, мы "
"можем обратиться к значению с именем `p`.\n"
"Аналогично, после присвоения значения переменной с именем `x`, мы можем "
"ссылаться как на `x`, так и на `p`."

#: in/chapter1.md:223
msgid ""
"Symbols are also used to name functions in Common Lisp.\n"
"Every symbol can be used as the name of a variable or a function, or both, "
"although it is rare (and potentially confusing) to have symbols name both.\n"
"For example, `append` and `length` are symbols that name functions but have "
"no values as variables, and `pi` does not name a function but is a variable "
"whose value is 3.1415926535897936 (or thereabout)."
msgstr ""
"Символы также используются для именования функций в Common Lisp.\n"
"Каждый символ может быть использован в качестве имени переменной или "
"функции, или и того, и другого, хотя редко (и потенциально запутанно), чтобы "
"символы становились именами обоих.\n"
"Например, `append` и `length`  -  это символы, которые именуют функции, но "
"не имеют значений в качестве переменных, а `pi` - это не имя функции, а "
"переменная, значение которой равно 3.1415926535897936 (или около того)."

#: in/chapter1.md:225
msgid "## 1.3 Special Forms"
msgstr "## 1.3 Специальные Формы"

#: in/chapter1.md:238
msgid ""
"The careful reader will note that `setf` violates the evaluation rule.\n"
"We said earlier that functions like `+`, - and `append` work by first "
"evaluating all their arguments and then applying the function to the "
"result.\n"
"But `setf` doesn't follow that rule, because `setf` is not a function at "
"all.\n"
"Rather, it is part of the basic syntax of Lisp.\n"
"Besides the syntax of atoms and function calls, Lisp has a small number of "
"syntactic expressions.\n"
"They are known as *special forms.*\n"
"They serve the same purpose as statements in other programming languages, "
"and indeed have some of the same syntactic markers, such as `if` and "
"`loop`.\n"
"There are two main differences between Lisp's syntax and other languages.\n"
"First, Lisp's syntactic forms are always lists in which the first element is "
"one of a small number of privileged symbols.\n"
"`setf` is one of these symbols, so (`setf x 10`) is a special form.\n"
"Second, special forms are expressions that return a value.\n"
"This is in contrast to statements in most languages, which have an effect "
"but do not return a value."
msgstr ""
"Внимательный читатель заметит, что `setf` нарушает правило вычисления "
"выражений.\n"
"Ранее мы говорили, что такие функции, как `+`, -  и  `append` работают, "
"сначала вычисляя все свои аргументы, а затем применяя функцию к результату.\n"
"Но `setf` не следует этому правилу, потому что `setf` - это вообще не "
"функция.\n"
"Скорее, это часть базового синтаксиса Lisp.\n"
"Помимо синтаксиса атомов и вызова функций, Lisp имеет небольшое количество "
"синтаксических выражений.\n"
"Они известны как *специальные формы.*\n"
"Они служат той же цели, что и операторы в других языках программирования, и "
"действительно имеют некоторые из тех же синтаксических маркеров, таких как "
"`if` и `loop`.\n"
"Существует два основных различия между синтаксисом Lisp и другими языками.\n"
"Во-первых, синтаксические формы Lisp-это всегда списки, в которых первый "
"элемент является одним из небольшого числа привилегированных символов.\n"
"`setf` - один из этих символов, поэтому (`setf x 10`) - это специальная "
"форма.\n"
"Во-вторых, специальные формы-это выражения, возвращающие значение.\n"
"В этом отличие их от операторов большинства других языков, которые имеют "
"эффект, но не возвращают значение."

#: in/chapter1.md:243
msgid ""
"In evaluating an to expression *(ed note: ???)* like `(setf x (+  1 2)`), we "
"set the variable named by the symbol `x` to the value of `(+  1 2)`, which "
"is `3`.\n"
"If `setf` were a normal function, we would evaluate both the symbol `x` and "
"the expression `(+  1 2)` and do something with these two values, which is "
"not what we want at all.\n"
"`setf` is called a special form because it does something special: if it did "
"not exist, it would be impossible to write a function that assigns a value "
"to a variable.\n"
"The philosophy of Lisp is to provide a small number of special forms to do "
"the things that could not otherwise be done, and then to expect the user to "
"write everything else as functions."
msgstr ""
"При вычислении выражения подобного `(setf x (+1 2)`), мы устанавливаем "
"переменную, обозначаемую символом `x`, значением  `(+1 2)`, которое равно "
"`3`.\n"
"Если бы `setf` была нормальной функцией, мы бы вычислили и символ `x` и "
"выражение `(+  1 2)` и сделали что-то с этими двумя значениями, что совсем "
"не то, что мы хотим.\n"
"`setf` называется специальной формой, потому что она делает нечто особенное: "
"если бы её не существовало, было бы невозможно написать функцию, которая "
"присваивает значение переменной.\n"
"Философия Lisp состоит в том, чтобы предоставить небольшое количество "
"специальных форм для выполнения вещей, которые иначе не могли бы быть "
"выполнены, а затем ожидать, что пользователь напишет все остальное, например "
"функции."

#: in/chapter1.md:251
msgid ""
"The term *special form* is used confusingly to refer both to symbols like "
"`setf` and expressions that start with them, like `(setf x 3)`.\n"
"In the book *Common LISPcraft,* Wilensky resolves the ambiguity by calling "
"`setf` a *special function,* and reserving the term *special form* for "
"(`setf x 3`).\n"
"This terminology implies that `setf` is just another function, but a special "
"one in that its first argument is not evaluated.\n"
"Such a view made sense in the days when Lisp was primarily an interpreted "
"language.\n"
"The modern view is that `setf` should not be considered some kind of "
"abnormal function but rather a marker of special syntax that will be handled "
"specially by the compiler.\n"
"Thus, the special form `(setf x (+  2 1))` should be considered the "
"equivalent of `x = 2 + 1` in `C`.\n"
"When there is risk of confusion, we will call `setf` a *special form "
"operator* and `(setf x 3)` a *special form expression.*"
msgstr ""
"Термин \"специальная форма\" используется путано для обозначения как "
"символов типа `setf`, так и выражений, которые начинаются с них, например "
"`(setf x 3)`.\n"
"В книге *Common LISPcraft,* Wilensky устраняет неоднозначность называя "
"`setf` С *специальной функцией* и резервируя термин *специальная форма* для "
"(`setf x 3`).\n"
"Эта терминология подразумевает, что `setf` - это просто еще одна функция, но "
"особая в том смысле, что ее первый аргумент не вычисляется.\n"
"Такая точка зрения имела смысл в те дни, когда Лисп был главным образом "
"интерпретируемым языком.\n"
"Современная точка зрения состоит в том, что `setf` не следует рассматривать "
"как какую-то ненормальную функцию, а скорее как маркер особого синтаксиса, "
"который будет специально обработан компилятором.\n"
"Таким образом, специальная форма `(setf x (+  2 1))` должна рассматриваться "
"как эквивалент `x = 2 + 1` в `C`.\n"
"Когда есть риск путаницы, мы будем называть `setf` *оператором специальной "
"формы* и `(setf x 3)` *выражением специальной формы.*"

#: in/chapter1.md:255
msgid ""
"It turns out that the quote mark is just an abbreviation for another special "
"form.\n"
"The expression '*x* is equivalent to `(quote *x*)`, a special form "
"expression that evaluates to *x.*\n"
"The special form operators used in this chapter are:"
msgstr ""
"Оказывается, что кавычка - это просто аббревиатура для другой специальной "
"формы.\n"
"Выражение '*x* является эквивалентом `(quote x)`, выражения особой формы , "
"которое вычисляется в *x.*\n"
"Специальные операторы форм, используемые в этой главе:"

#: in/chapter1.md:266
msgid ""
"| []()            |                                              |\n"
"|-----------------|----------------------------------------------|\n"
"| `defun`         | define function                              |\n"
"| `defparameter`  | define special variable                      |\n"
"| `setf`          | set variable or field to new value           |\n"
"| `let`           | bind local variable(s)                       |\n"
"| `case`          | choose one of several alternatives           |\n"
"| `if`            | do one thing or another, depending on a test |\n"
"| `function (#')` | refer to a function                          |\n"
"| `quote (')`     | introduce constant data                      |"
msgstr ""
"| Спец.форма      | Действие                                     |\n"
"|-----------------|----------------------------------------------|\n"
"| `defun`         | определяет функцию                           |\n"
"| `defparameter`  | определяет специальную переменную            |\n"
"| `setf`          | устанавливает переменную или поле новым значением\n"
"| `let`           | связывает локальную(ные) переменную(ные)     |\n"
"| `case`          | выбор из нескольких альтернатив              |\n"
"| `if`            | выполняет одно или другое выражение, в зависимости от "
"теста\n"
"| `function (#')` | ссылка на функцию                            |\n"
"| `quote (')`     | ввести постоянные данные                     |"

#: in/chapter1.md:268
msgid "## 1.4 Lists"
msgstr "## 1.4 Списки"

#: in/chapter1.md:270
msgid ""
"So far we have seen two functions that operate on lists: `append` and "
"`length.` Since lists are important, let's look at some more list processing "
"functions:"
msgstr ""
"До сих пор мы видели две функции, которые работают со списками: `append` and "
"`length.` Поскольку списки важны, давайте рассмотрим еще несколько функций "
"обработки списков:"

#: in/chapter1.md:273
msgctxt "in/chapter1.md:273"
msgid ""
"```lisp\n"
"> p => (JOHN Q PUBLIC)"
msgstr ""

#: in/chapter1.md:275
msgid "> (first p) JOHN"
msgstr ""

#: in/chapter1.md:277
msgid "> (rest p) => (Q PUBLIC)"
msgstr ""

#: in/chapter1.md:279
msgid "> (second p) => Q"
msgstr ""

#: in/chapter1.md:281
msgid "> (third p) => PUBLIC"
msgstr ""

#: in/chapter1.md:283
msgid "> (fourth p) => NIL"
msgstr ""

#: in/chapter1.md:286
msgid ""
"> (length p) => 3\n"
"```"
msgstr ""

#: in/chapter1.md:292
msgid ""
"The functions `first, second, third,` and `fourth` are aptly named: `first` "
"returns the first element of a list, `second` gives you the second element, "
"and so on.\n"
"The function `rest` is not as obvious; its name stands for \"the rest of the "
"list after the first element.\" The symbol `nil` and the form `()` are "
"completely synonymous; they are both representations of the empty list.\n"
"`nil` is also used to denote the \"false\" value in Lisp.\n"
"Thus, `(fourth p)` is `nil` because there is no fourth element of `p`.\n"
"Note that lists need not be composed only of atoms, but can contain sublists "
"as elements:"
msgstr ""
"Функции `first, second, third` и `fourth` называются точно: `first` "
"возвращает первый элемент списка, `second` дает вам второй элемент и так "
"далее.\n"
"Функция `rest` не столь очевидна; ее название означает \"остальная часть "
"списка после первого элемента\". Символ `nil` и форма `()` полностью "
"синонимичны; они оба являются представлениями пустого списка.\n"
"`nil` также используется для обозначения значения \"false\" в Lisp.\n"
"Таким образом, `(fourth p)` это `nil`, потому что нет четвертого элемента "
"`p`.\n"
"Обратите внимание, что списки не обязательно должны состоять только из "
"атомов, но могут содержать подсписки в виде элементов:"

#: in/chapter1.md:296
msgid ""
"```lisp\n"
"> (setf x '((1st element) 2 (element 3) ((4)) 5))\n"
"((1ST ELEMENT) 2 (ELEMENT 3) ((4)) 5)"
msgstr ""

#: in/chapter1.md:298
msgid "> (length x) => 5"
msgstr ""

#: in/chapter1.md:300
msgctxt "in/chapter1.md:300"
msgid "> (first x) => (1ST ELEMENT)"
msgstr ""

#: in/chapter1.md:302
msgid "> (second x) => 2"
msgstr ""

#: in/chapter1.md:304
msgid "> (third x) => (ELEMENT 3)"
msgstr ""

#: in/chapter1.md:306
msgid "> (fourth x) => ((4))"
msgstr ""

#: in/chapter1.md:308
msgid "> (first (fourth x)) => (4)"
msgstr ""

#: in/chapter1.md:310
msgid "> (first (first (fourth x))) => 4"
msgstr ""

#: in/chapter1.md:312
msgid "> (fifth x) => 5"
msgstr ""

#: in/chapter1.md:314
msgctxt "in/chapter1.md:314"
msgid "> (first x) => (1ST ELEMENT)"
msgstr ""

#: in/chapter1.md:317
msgid ""
"> (second (first x)) => ELEMENT\n"
"```"
msgstr ""

#: in/chapter1.md:320
msgid ""
"So far we have seen how to access parts of lists.\n"
"It is also possible to build up new lists, as these examples show:"
msgstr ""
"До сих пор мы видели, как получить доступ к частям списков.\n"
"Кроме того, можно создавать новые списки, как показывают эти примеры:"

#: in/chapter1.md:323
msgctxt "in/chapter1.md:323"
msgid ""
"```lisp\n"
"> p => (JOHN Q PUBLIC)"
msgstr ""

#: in/chapter1.md:325
msgid "> (cons 'Mr p) => (MR JOHN Q PUBLIC)"
msgstr ""

#: in/chapter1.md:327
msgid "> (cons (first p) (rest p)) => (JOHN Q PUBLIC)"
msgstr ""

#: in/chapter1.md:329
msgid "> (setf town (list 'Anytown 'USA)) => (ANYTOWN USA)"
msgstr ""

#: in/chapter1.md:332
msgid ""
"> (list p 'of town 'may 'have 'already 'won!) =>\n"
"((JOHN Q PUBLIC) OF (ANYTOWN USA) MAY HAVE ALREADY WON!)"
msgstr ""

#: in/chapter1.md:335
msgid ""
"> (append p '(of) town '(may have already won!)) =>\n"
"(JOHN Q PUBLIC OF ANYTOWN USA MAY HAVE ALREADY WON!)"
msgstr ""

#: in/chapter1.md:338
msgid ""
"> p => (JOHN Q PUBLIC)\n"
"```"
msgstr ""

#: in/chapter1.md:348
msgid ""
"The function cons stands for \"construct.\"\n"
"<a id=\"tfn01-3\"></a>\n"
"It takes as arguments an element and a list,[3](#fn01-3) and constructs a "
"new list whose first is the element and whose rest is the original list.\n"
"`list` takes any number of elements as arguments and returns a new list "
"containing those elements in order.\n"
"We've already seen `append`, which is similar to `list`; it takes as "
"arguments any number of lists and appends them all together, forming one big "
"list.\n"
"Thus, the arguments to `append` must be lists, while the arguments to `list` "
"may be lists or atoms.\n"
"It is important to note that these functions create new lists; they don't "
"modify old ones.\n"
"When we say `(append p q)`, the effect is to create a brand new list that "
"starts with the same elements that were in `p.\n"
"p` itself remains unchanged."
msgstr ""
"Функция cons расшифровывается как \" построить(construct).\"\n"
"<a id=\"tfn01-3\"></a>\n"
"Она принимает в качестве аргументов элемент и список, [3](#fn01-3) и строит "
"новый список, первым элементом в котором является переданный элемент, а "
"rest(остальные) - исходным списком.\n"
"`list` принимает любое количество элементов в качестве аргументов и "
"возвращает новый список, содержащий эти элементы по порядку.\n"
"Мы уже видели `append`, который похож на `list`; он принимает в качестве "
"аргументов любое количество списков и соединяет их все вместе, образуя один "
"большой список.\n"
"Таким образом, аргументы для `append` должны быть списками, в то время как "
"аргументы для `list` могут быть списками или атомами.\n"
"Важно отметить, что эти функции создают новые списки, а не изменяют старые.\n"
"Когда мы говорим `(append p q)`, результатом является создание совершенно "
"нового списка, который начинается с тех же элементов, которые были в `p`.\n"
"Сам `p`  остается неизменным."

#: in/chapter1.md:353
msgid ""
"Now let's move away from abstract functions on lists, and consider a simple "
"problem: given a person's name in the form of a list, how might we extract "
"the family name?\n"
"For `(JOHN Q PUBLIC)` we could just use the function `third`, but that "
"wouldn't work for someone with no middle name.\n"
"There is a function called `last` in Common Lisp; perhaps that would work.\n"
"We can experiment:"
msgstr ""
"Теперь давайте отойдем от абстрактных функций над списками и рассмотрим "
"простую проблему: если имя человека представлено в виде списка, как мы можем "
"извлечь его фамилию?\n"
"Для `(JOHN Q PUBLIC)` мы могли бы просто использовать функцию `third`, но "
"это не сработало бы для кого-то без второго имени.\n"
"В Common Lisp есть функция под названием `last`; возможно, это сработает.\n"
"Мы можем поэкспериментировать:"

#: in/chapter1.md:356
msgid ""
"```lisp\n"
"> (last p) => (PUBLIC)"
msgstr ""

#: in/chapter1.md:359
msgid ""
"> (first (last p)) => PUBLIC\n"
"```"
msgstr ""

#: in/chapter1.md:367
msgid ""
"<a id=\"tfn01-4\"></a>\n"
"It turns out that `last` perversely returns a list of the last element, "
"rather than the last element itself.[4](#fn01-4)\n"
"Thus we need to combine `first` and `last` to pick out the actual last "
"element.\n"
"We would like to be able to save the work we've done, and give it a proper "
"description, like `last-name`.\n"
"We could use `setf` to save the last name of `p`, but that wouldn't help "
"determine any other last name.\n"
"Instead we want to define a new function that computes the last name of "
"*any* name that is represented as a list.\n"
"The next section does just that."
msgstr ""
"<a id=\"tfn01-4\"></a>\n"
"Оказывается, что `last` порочно возвращает список последнего элемента, а не "
"сам последний элемент.[4](#fn01-4)\n"
"Таким образом, нам нужно объединить `first` и `last`, чтобы выбрать "
"фактический последний элемент.\n"
"Мы хотели бы сохранить проделанную работу и дать ей правильное описание, "
"например фамилия - `last-name`.\n"
"Мы могли бы использовать `setf`, чтобы сохранить фамилию в `p`, но это не "
"помогло бы определить любую другую фамилию.\n"
"Вместо этого мы хотим определить новую функцию, которая вычисляет последнее "
"имя *любого* имени, представленного в виде списка.\n"
"Следующий раздел делает именно это."

#: in/chapter1.md:369
msgid "## 1.5 Defining New Functions"
msgstr "## 1.5 Определение Новых Функций"

#: in/chapter1.md:372
msgid ""
"The special form `defun` stands for \"define function.\"\n"
"It is used here to define a new function called `last-name`:"
msgstr ""
"Специальная форма \"defun\" расшифровывается как \"define function/"
"определить функцию\".\"\n"
"Она используется здесь для определения новой функции, называемой фамилия/"
"`last-name`:"

#: in/chapter1.md:378
msgid ""
"```lisp\n"
"(defun last-name (name)\n"
"  \"Select the last name from a name represented as a list.\"\n"
"  (first (last name)))\n"
"```"
msgstr ""

#: in/chapter1.md:385
msgid ""
"We give our new function the name `last-name.` It has a *parameter list* "
"consisting of a single parameter: (`name`).\n"
"This means that the function takes one argument, which we will refer to as "
"`name`.\n"
"It also has a *documentation string* that states what the function does.\n"
"This is not used in any computation, but documentation strings are crucial "
"tools for debugging and understanding large systems.\n"
"The body of the definition is `(first (last name))`, which is what we used "
"before to pick out the last name of `p`.\n"
"The difference is that here we want to pick out the last name of any `name,` "
"not just of the particular name `p`."
msgstr ""
"Мы даем нашей новой функции имя `last-name.` Она имеет  *список параметров*, "
"состоящий из одного параметра: (`name`).\n"
"Это означает, что функция принимает один аргумент, который мы будем называть "
"`name`.\n"
"В ней также есть строка документации(*documentation string*), в которой "
"указано, что делает функция.\n"
"Она не используется ни в каких вычислениях, но строки документации являются "
"важными инструментами для отладки и понимания больших систем.\n"
"Тело определения - это `(first (last name))`, которое мы использовали "
"раньше, чтобы выбрать фамилию из `p`.\n"
"Разница в том, что здесь мы хотим выбрать фамилию из любого `name,` а не "
"только конкретного имени `p`."

#: in/chapter1.md:387
msgid ""
"In general, a function definition takes the following form (where the "
"documentation string is optional, and all other parts are required):"
msgstr ""
"В общем случае определение функции принимает следующий вид (где строка "
"документации необязательна, а все остальные части обязательны):"

#: in/chapter1.md:393
msgid ""
"```lisp\n"
"(defun *function-name* (*parameter...*)\n"
"      \"*documentation string*\"\n"
"      *function-body...*)\n"
"```"
msgstr ""

#: in/chapter1.md:396
msgid ""
"The function name must be a symbol, the parameters are usually symbols (with "
"some complications to be explained later), and the function body consists of "
"one or more expressions that are evaluated when the function is called.\n"
"The last expression is returned as the value of the function call."
msgstr ""
"Имя функции должно быть символом, параметры обычно являются символами (с "
"некоторыми осложнениями, которые будут объяснены позже), а тело функции "
"состоит из одного или нескольких выражений, которые вычисляются при вызове "
"функции.\n"
"Значение последнего выражения возвращается как значение вызова функции."

#: in/chapter1.md:398
msgid ""
"Once we have defined `last-name,` we can use it just like any other Lisp "
"function:"
msgstr ""
"Как только мы определили `last-name,` мы можем использовать ее так же, как и "
"любую другую функцию Lisp:"

#: in/chapter1.md:401
msgid ""
"```lisp\n"
"> (last-name p) => PUBLIC"
msgstr ""

#: in/chapter1.md:403
msgid "> (last-name '(Rear Admiral Grace Murray Hopper)) => HOPPER"
msgstr ""

#: in/chapter1.md:405
msgid "> (last-name '(Rex Morgan MD)) => MD"
msgstr ""

#: in/chapter1.md:407
msgid "> (last-name '(Spot)) => SPOT"
msgstr ""

#: in/chapter1.md:410
msgid ""
"> (last-name '(Aristotle)) => ARISTOTLE\n"
"```"
msgstr ""

#: in/chapter1.md:415
msgid ""
"The last three examples point out an inherent limitation of the programming "
"enterprise.\n"
"When we say `(defun last-name...)` we are not really defining what it means "
"for a person to have a last name; we are just defining an operation on a "
"representation of names in terms of lists.\n"
"Our intuitions-that MD is a title, Spot is the first name of a dog, and "
"Aristotle lived before the concept of last name was invented-are not "
"represented in this operation.\n"
"However, we could always change the definition of `last-name` to incorporate "
"these problematic cases."
msgstr ""
"Последние три примера указывают на неотъемлемое ограничение занятия "
"программированием.\n"
"Когда мы говорим `(defun last-name...)` мы на самом деле не определяем, что "
"означает для человека иметь фамилию; мы просто определяем операцию над "
"представлением имен в терминах списков.\n"
"Наши интуитивные представления о том, что MD - это титул, Spot - это имя "
"собаки, а Aristotle(Аристотель) жил до того, как было изобретено понятие "
"фамилии, не представлены в этой операции.\n"
"Однако мы всегда можем изменить определение `last-name`, чтобы включить в "
"него эти проблемные случаи."

#: in/chapter1.md:422
msgid ""
"We can also define the function `first-name`.\n"
"Even though the definition is trivial (it is the same as the function "
"`first`), it is still good practice to define `first-name` explicitly.\n"
"Then we can use the function `first-name` when we are dealing with names, "
"and `first` when we are dealing with arbitrary lists.\n"
"The computer will perform the same operation in each case, but we as "
"programmers (and readers of programs) will be less confused.\n"
"Another advantage of defining specific functions like `first-name` is that "
"if we decide to change the representation of names we will only have to "
"change the definition of `first-name`.\n"
"This is a much easier task than hunting through a large program and changing "
"the uses of `first` that refer to names, while leaving other uses alone."
msgstr ""
"Мы также можем определить функцию имя - `first-name`.\n"
"Даже если это определение тривиально (оно совпадает с функцией `first`), все "
"равно хорошей практикой является явное определение `first-name`.\n"
"Затем мы можем использовать функцию `first-name`, когда мы имеем дело с "
"именами, и `first`, когда мы имеем дело с произвольными списками.\n"
"Компьютер будет выполнять одну и ту же операцию в каждом конкретном случае, "
"но мы как программисты (и читатели программ) будем меньше путаться.\n"
"Еще одно преимущество определения конкретных функций, таких как `first-"
"name`, заключается в том, что если мы решим изменить представление имен, нам "
"придется изменить только определение `first-name`.\n"
"Это гораздо более простая задача, чем поиск по большой программе и изменение "
"использования `first`, которые ссылаются на имена, оставляя другие виды "
"использования в покое."

#: in/chapter1.md:427
msgid ""
"```lisp \n"
"(defun first-name (name)\n"
"  \"Select the first name from a name represented as a list.\"\n"
"  (first name))"
msgstr ""
"```lisp\n"
"(defun first-name (name)\n"
"  \"Select the first name from a name represented as a list.\"\n"
"  (first name))"

#: in/chapter1.md:429
msgid "> p => (JOHN Q PUBLIC)`"
msgstr ""

#: in/chapter1.md:431
msgid "> (first-name p) => JOHN`"
msgstr ""

#: in/chapter1.md:433
msgid "> (first-name '(Wilma Flintstone)) => WILMA`"
msgstr ""

#: in/chapter1.md:438
msgid ""
"> (setf names '((John Q Public) (Malcolm X)\n"
"              (Admiral Grace Murray Hopper) (Spot) \n"
"              (Aristotle) (A A Milne) (Z Z Top)\n"
"              (Sir Larry Olivier) (Miss Scarlet))) => "
msgstr ""

#: in/chapter1.md:442
msgid ""
"((JOHN Q PUBLIC) (MALCOLM X) (ADMIRAL GRACE MURRAY HOPPER)\n"
" (SPOT) (ARISTOTLE) (A A MILNE) (Z Z TOP) (SIR LARRY OLIVIER)\n"
" (MISS SCARLET))"
msgstr ""

#: in/chapter1.md:445
msgid ""
"> (first-name (first names)) => JOHN\n"
"```"
msgstr ""
"> (first-name (first names)) => JOHN\n"
"```"

#: in/chapter1.md:448
msgid ""
"In the last expression we used the function `first` to pick out the first "
"element in a list of names, and then the function `first-name` to pick out "
"the first name of that element.\n"
"We could also have said `(first (first names))` or even `(first (first-name "
"names))` and still have gotten `JOHN,` but we would not be accurately "
"representing what is being considered a name and what is being considered a "
"list of names."
msgstr ""
"В последнем выражении мы использовали функцию `first`, чтобы выбрать первый "
"элемент в списке имен, а затем функцию `first-name`, чтобы выбрать первое "
"имя этого элемента.\n"
"Мы могли бы также сказать `(first (first names))` или даже `(first (first-"
"name names))` и все так же получить `JOHN,` но мы не будем точно "
"представлять, что считается именем и что считается списком имен."

#: in/chapter1.md:450
msgid "## 1.6 Using Functions"
msgstr "## 1.6 Использование Функций"

#: in/chapter1.md:453
msgid ""
"One good thing about defining a list of names, as we did above, is that it "
"makes it easier to test our functions.\n"
"Consider the following expression, which can be used to test the `last-name` "
"function:"
msgstr ""
"Одна хорошая вещь в определении списка имен, как мы сделали выше, "
"заключается в том, что он облегчает тестирование наших функций.\n"
"Рассмотрим следующее выражение, которое можно использовать для проверки "
"функции `last-name` :"

#: in/chapter1.md:458
msgid ""
"```lisp\n"
"> (mapcar #'last-name names)\n"
"(PUBLIC X HOPPER SPOT ARISTOTLE MILNE TOP OLIVIER SCARLET)\n"
"```"
msgstr ""

#: in/chapter1.md:464
msgid ""
"The funny `#'` notation maps from the name of a function to the function "
"itself.\n"
"This is analogous to `'x` notation.\n"
"The built-in function `mapcar` is passed two arguments, a function and a "
"list.\n"
"It returns a list built by calling the function on every element of the "
"input list.\n"
"In other words, the `mapcar` call above is equivalent to:"
msgstr ""
"Странная нотация `#'` ссылается по имени функции к самой функции.\n"
"Она аналогична обозначению `'x`.\n"
"Встроенной функции `mapcar` передается два аргумента, функция и список.\n"
"Она возвращает список, построенный путем вызова функции для каждого элемента "
"входного списка.\n"
"Другими словами, приведенный выше вызов `mapcar` эквивалентен:"

#: in/chapter1.md:470
msgid ""
"```lisp\n"
"(list (last-name (first names))\n"
"      (last-name (second names))\n"
"      (last-name (third names))\n"
"```"
msgstr ""

#: in/chapter1.md:478
msgid ""
"`mapcar`'s name comes from the fact that it \"maps\" the function across "
"each of the arguments.\n"
"The `car` part of the name refers to the Lisp function `car`, an old name "
"for `first`.\n"
"`cdr` is the old name for `rest`.\n"
"The names stand for \"contents of the address register\" and \"contents of "
"the decrement register,\" the instructions that were used in the first "
"implementation of Lisp on the IBM 704.\n"
"I'm sure you'll agree that `first` and `rest` are much better names, and "
"they will be used instead of `car` and `cdr` whenever we are talking about "
"lists.\n"
"However, we will continue to use `car` and `cdr` on occasion when we are "
"considering a pair of values that are not considered as a list.\n"
"Beware that some programmers still use `car` and `cdr` for lists as well."
msgstr ""
"название `mapcar` происходит от того, что она \"maps/отображает\" функцию "
"для каждого из аргументов.\n"
"Часть названия `car`  относится к Лисп функция `car`, старое название для "
"`first`.\n"
"`cdr` - это старое название для `rest`(\"остаток\").\n"
"Эти имена означали абривиатуру \"contents of the address register\" и "
"\"contents of the decrement register,\" - инструкций, которые использовались "
"в первой реализации Lisp на IBM 704.\n"
"Я уверен, вы согласитесь, что `first` и `rest` - гораздо лучшие имена, и они "
"будут использоваться вместо `car` и `cdr` всякий раз, когда мы говорим о "
"списках.\n"
"Однако мы будем продолжать использовать `car` и `cdr` в некоторых случаях, "
"когда мы рассматриваем пару значений, которые не рассматриваются как "
"список.\n"
"Имейте в виду, что некоторые программисты все еще используют `car` и `cdr` "
"для списков."

#: in/chapter1.md:480
msgid "Here are some more examples of `mapcar`:"
msgstr "Вот еще несколько примеров `mapcar`:"

#: in/chapter1.md:483
msgid ""
"```lisp\n"
"> (mapcar #'- '(1 2 3 4)) => (-1 -2 -3 -4)"
msgstr ""

#: in/chapter1.md:486
msgid ""
"> (mapcar #'+ '(1 2 3 4) '(10 20 30 40)) => (11 22 33 44)\n"
"```"
msgstr ""

#: in/chapter1.md:492
msgid ""
"This last example shows that `mapcar` can be passed three arguments, in "
"which case the first argument should be a binary function, which will be "
"applied to corresponding elements of the other two lists.\n"
"In general, `mapcar` expects an *n*-ary function as its first argument, "
"followed by *n* lists.\n"
"It first applies the function to the argument list obtained by collecting "
"the first element of each list.\n"
"Then it applies the function to the second element of each list, and so on, "
"until one of the lists is exhausted.\n"
"It returns a list of all the function values it has computed."
msgstr ""
"Этот последний пример показывает, что `mapcar` может быть передано три "
"аргумента, и в этом случае первый аргумент должен быть функцией двух "
"аргументов, которая будет применена к соответствующим элементам двух других "
"списков.\n"
"В общем случае `mapcar` ожидает в качестве своего первого аргумента функцию "
"*n* - арности, за которой следуют *n* списков.\n"
"Сначала она применяет функцию к списку аргументов, полученному путем сбора "
"первого элемента из каждого списка.\n"
"Затем она применяет функцию ко второму элементу каждого списка и так далее, "
"пока один из списков не будет исчерпан.\n"
"Она возвращает список всех вычисленных значений функции."

#: in/chapter1.md:494
msgid ""
"Now that we understand `mapcar`, let's use it to test the `first-name` "
"function:"
msgstr ""
"Теперь, когда мы понимаем `mapcar`, давайте использовать её для тестирования "
"функции `first-name` :"

#: in/chapter1.md:499
msgid ""
"```lisp\n"
"> (mapcar #'first-name names)\n"
"(JOHN MALCOLM ADMIRAL SPOT ARISTOTLE A Z SIR MISS)\n"
"```"
msgstr ""

#: in/chapter1.md:503
msgid ""
"We might be disappointed with these results.\n"
"Suppose we wanted a version of `first-name` which ignored titles like "
"Admiral and Miss, and got to the \"real\" first name.\n"
"We could proceed as follows:"
msgstr ""
"Мы можем быть разочарованы этими результатами.\n"
"Предположим, нам нужна версия `first-name`, которая игнорировала бы такие "
"титулы, как Admiral и Miss, и добралась бы до \"настоящего\" имени.\n"
"Мы могли бы действовать следующим образом:"

#: in/chapter1.md:509
msgid ""
"```lisp\n"
"(defparameter *titles*\n"
"  '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)\n"
"  \"A list of titles that can appear at the start of a name.\")\n"
"```"
msgstr ""

#: in/chapter1.md:515
msgid ""
"We've introduced another new special form, `defparameter`, which defines a "
"parameter-a variable that does not change over the course of a computation, "
"but that might change when we think of new things to add (like the French "
"Mme or the military Lt.).\n"
"The `defparameter` form both gives a value to the variable and makes it "
"possible to use the variable in subsequent function definitions.\n"
"In this example we have exercised the option of providing a documentation "
"string that describes the variable.\n"
"It is a widely used convention among Lisp programmers to mark special "
"variables by spelling their names with asterisks on either end.\n"
"This is just a convention; in Lisp, the asterisk is just another character "
"that has no particular meaning."
msgstr ""
"Мы ввели еще одну новую специальную форму, `defparameter`, которая "
"определяет параметр - переменную, которая не меняется в ходе вычислений, но "
"может измениться, когда мы думаем о новых вещах, которые нужно добавить "
"(например, французский Mme или военное Lt.).\n"
"Форма `defparameter` одновременно дает значение переменной и позволяет "
"использовать переменную в последующих определениях функций.\n"
"В этом примере мы воспользовались возможностью предоставления строки "
"документации, описывающей переменную.\n"
"Это широко используемое соглашение среди программистов Lisp, чтобы отметить "
"специальные переменные, их имена пишут со звездочками на обоих концах.\n"
"Это просто условность; в Lisp звездочка - это просто еще один знак, который "
"не имеет особого значения."

#: in/chapter1.md:521
msgid ""
"<a id=\"tfn01-5\"></a>\n"
"We next give a new definition for `first-name`, which supersedes the "
"previous definition.[5](#fn01-5)\n"
"This definition says that if the first word of the name is a member of the "
"list of titles, then we want to ignore that word and return the `first-name` "
"of the rest of the words in the name.\n"
"Otherwise, we use the first word, just as before.\n"
"Another built-in function, `member`, tests to see if its first argument is "
"an element of the list passed as the second argument."
msgstr ""
"<a id=\"tfn01-5\"></a>\n"
"Затем мы дадим новое определение `first-name`, которое заменяет предыдущее "
"определение.[5](#fn01-5)\n"
"Это определение гласит, что если первое слово имени является членом списка "
"титулов(titles), то нам надо проигнорировать это слово и вернуть `first-"
"name` от остатка слов в имени.\n"
"В противном случае мы используем первое слово, как и раньше.\n"
"Другая встроенная функция, `member`, проверяет, является ли ее первый "
"аргумент элементом списка, переданного в качестве второго аргумента."

#: in/chapter1.md:532
msgid ""
"The special form `if` has the form `(if *test then-part else-part*)`.\n"
"There are many special forms for performing conditional tests in Lisp; `if` "
"is the most appropriate for this example.\n"
"An `if` form is evaluated by first evaluating the *test* expression.\n"
"If it is true, the *then-part* is evaluated and returned as the value of the "
"`if` form; otherwise the *else-part* is evaluated and returned.\n"
"While some languages insist that the value of a conditional test must be "
"either `true` or `false`, Lisp is much more forgiving.\n"
"The test may legally evaluate to any value at all.\n"
"Only the value `nil` is considered false; all other values are considered "
"true.\n"
"*(ed. note: is `false` considered `true`?)*\n"
"In the definition of `first-name` below, the function `member` will return a "
"non-nil (hence true) value if the first element of the name is in the list "
"of titles, and will return `nil` (hence false) if it is not.\n"
"Although all non-nil values are considered true, by convention the constant "
"`t` is usually used to represent truth."
msgstr ""
"Специальная форма `if`(если) имеет форму `(if *test then-part else-part*)`.\n"
"Существует много специальных форм для выполнения условных проверок в Lisp; "
"`if` является наиболее подходящим для этого примера.\n"
"Форма `if` вычисляется путем вычисления первого выражения* test*.\n"
"Если оно верно, то вычисляется *then-part* и возвращается как значение формы "
"`if`; в противном случае вычисляется *else-part* и возвращается.\n"
"В то время как некоторые языки настаивают на том, что значение условного "
"теста должно быть либо `true` или `false`, Lisp гораздо более "
"снисходителен.\n"
"Тест может законно вычислять любое значение вообще.\n"
"Только значение `nil` считается ложным; все остальные значения считаются "
"истинными.\n"
"*(ред. Примечание: считается ли значение `false` истинным?)*\n"
"В приведенном ниже определении `first-name` функция `member` возвращает не "
"nil (следовательно, истинное) значение, если первый элемент имени находится "
"в списке титулов, и возвращает `nil` (следовательно, false), если его нет.\n"
"Хотя все не-nil значения считаются истинными, по соглашению константа `t` "
"обычно используется для представления истины."

#: in/chapter1.md:540
msgid ""
"```lisp\n"
"(defun first-name (name)\n"
"  \"Select the first name from a name represented as a list.\"\n"
"  (if (member (first name) *titles*)\n"
"      (first-name (rest name))\n"
"      (first name)))\n"
"```"
msgstr ""

#: in/chapter1.md:543
msgid ""
"When we map the new `first-name` over the list of names, the results are "
"more encouraging.\n"
"In addition, the function gets the \"right\" result for `'(Madam Major "
"General Paula Jones)` by dropping off titles one at a time."
msgstr ""
"Когда мы сопоставляем новое `first-name` со списком имен, результаты "
"становятся более обнадеживающими.\n"
"Кроме того, функция получает \"правильный\" результат для `'(Madam Major "
"General Paula Jones)`, отбрасывая титулы по одному за раз."

#: in/chapter1.md:547
msgid ""
"```lisp\n"
"> (mapcar #'first-name names)\n"
"(JOHN MALCOLM GRACE SPOT ARISTOTLE A Z LARRY SCARLET)"
msgstr ""

#: in/chapter1.md:551
msgid ""
"> (first-name '(Madam Major General Paula Jones))\n"
"PAULA\n"
"```"
msgstr ""

#: in/chapter1.md:554
msgid ""
"We can see how this works by *tracing* the execution of `first-name`, and "
"seeing the values passed to and returned from the function.\n"
"The special forms `trace` and `untrace` are used for this purpose."
msgstr ""
"Мы можем видеть, как это работает , *трассируя* выполнение `first-name` и "
"видя значения, передаваемые в функцию и возвращаемые из нее.\n"
"Для этого используются специальные формы `trace` и `untrace`."

#: in/chapter1.md:558
msgid ""
"```lisp\n"
"> (trace first-name)\n"
"(FIRST-NAME)"
msgstr ""

#: in/chapter1.md:564
msgid ""
"> (first-name '(John Q Public))\n"
"(1 ENTER FIRST-NAME: (JOHN Q PUBLIC))\n"
"(1 EXIT FIRST-NAME: JOHN)\n"
"JOHN\n"
"```"
msgstr ""

#: in/chapter1.md:568
msgid ""
"When `first-name` is called, the definition is entered with the single "
"argument, `name,` taking on the value `(JOHN Q PUBLIC)`.\n"
"The value returned is `JOHN`.\n"
"Trace prints two lines indicating entry and exit from the function, and then "
"Lisp, as usual, prints the final result, `JOHN`."
msgstr ""
"Когда вызывается `first-name`, определение вводится с единственным "
"аргументом `name,` принимающим значение `(JOHN Q PUBLIC)`.\n"
"Возвращаемое значение - `JOHN`.\n"
"Трассировка выводит две строки, указывающие на вход и выход из функции, а "
"затем Lisp, как обычно, выводит конечный результат `JOHN`."

#: in/chapter1.md:576
msgid ""
"The next example is more complicated.\n"
"The function `first-name` is used four times.\n"
"First, it is entered with `name` bound to `(Madam Major General Paula Jones)."
"`\n"
"The first element of this list is `Madam,` and since this is a member of the "
"list of titles, the result is computed by calling `first-name` again on the "
"rest of the name-`(Major General Paula Jones).`\n"
"This process repeats two more times, and we finally enter `first-name` with "
"name bound to (`Paula Jones`).\n"
"Since `Paula` is not a title, it becomes the result of this call to `first-"
"name,` and thus the result of all four calls, as trace shows.\n"
"Once we are happy with the workings of `first-name,` the special form "
"`untrace` turns off tracing."
msgstr ""
"Следующий пример более сложен.\n"
"Функция `first-name` используется четыре раза.\n"
"Во-первых, она вводится с `name` связанным со списком `(Madam Major General "
"Paula Jones).`\n"
"Первый элемент этого списка - `Madam,` и поскольку это член списка титулов, "
"результат вычисляется путем вызова  `first-name` снова для оставшейся части "
"имени- `(Major General Paula Jones).`\n"
"Этот процесс повторяется еще два раза, и мы, наконец, вводим `first-name` с "
"привязкой к имени (`Paula Jones`)\n"
"Поскольку `Paula` -это не титул, он становится результатом этого вызова "
"`first-name,` и, таким образом, результатом всех четырех вызовов, как "
"показывает трассировка.\n"
"Как только мы довольны работой `first-name,` специальная форма `untrace` "
"отключает трассировку."

#: in/chapter1.md:588
msgid ""
"```lisp\n"
"> (first-name '(Madam Major General Paula Jones)) =>\n"
"(1 ENTER FIRST-NAME: (MADAM MAJOR GENERAL PAULA JONES))\n"
"  (2 ENTER FIRST-NAME: (MAJOR GENERAL PAULA JONES))\n"
"    (3 ENTER FIRST-NAME: (GENERAL PAULA JONES))\n"
"      (4 ENTER FIRST-NAME: (PAULA JONES))\n"
"      (4 EXIT FIRST-NAME: PAULA)\n"
"    (3 EXIT FIRST-NAME: PAULA)\n"
"  (2 EXIT FIRST-NAME: PAULA)\n"
"(1 EXIT FIRST-NAME: PAULA)\n"
"PAULA"
msgstr ""

#: in/chapter1.md:590
msgid "> (untrace first-name) => (FIRST-NAME)"
msgstr ""

#: in/chapter1.md:593
msgid ""
"> (first-name '(Mr Blue Jeans)) => BLUE\n"
"```"
msgstr ""

#: in/chapter1.md:600
msgid ""
"The function `first-name` is said to be *recursive* because its definition "
"includes a call to itself.\n"
"Programmers who are new to the concept of recursion sometimes find it "
"mysterious.\n"
"But recursive functions are really no different from nonrecursive ones.\n"
"Any function is required to return the correct value for the given "
"input(s).\n"
"Another way to look at this requirement is to break it into two parts: a "
"function must return a value, and it must not return any incorrect values.\n"
"This two-part requirement is equivalent to the first one, but it makes it "
"easier to think about and design function definitions."
msgstr ""
"Функция `first-name` называется рекурсивной, потому что ее определение "
"включает вызов самой себя.\n"
"Программисты, которые не знакомы с концепцией рекурсии, иногда находят ее "
"загадочной.\n"
"Но рекурсивные функции на самом деле ничем не отличаются от нерекурсивных.\n"
"Любая функция должна возвращать правильное значение для данного входна(ов).\n"
"Другой способ взглянуть на это требование-разбить его на две части: функция "
"должна возвращать значение, и она не должна возвращать никаких неправильных "
"значений.\n"
"Это требование из двух частей эквивалентно первому, но оно облегчает "
"обдумывание и разработку определений функций."

#: in/chapter1.md:602
msgid ""
"Next I show an abstract description of the `first-name` problem, to "
"emphasize the design of the function and the fact that recursive solutions "
"are not tied to Lisp in any way:"
msgstr ""
"Далее я показываю абстрактное описание проблемы \"`first-name`, чтобы "
"подчеркнуть дизайн функции и тот факт, что рекурсивные решения никоим "
"образом не связаны с Lisp:"

#: in/chapter1.md:609
msgid ""
"```lisp\n"
"function first-name(name):\n"
"  if *the first element of name is a title*\n"
"    then *do something complicated to get the first-name*\n"
"    else *return the first element of the name*\n"
"```"
msgstr ""

#: in/chapter1.md:615
msgid ""
"This breaks up the problem into two cases.\n"
"In the second case, we return an answer, and it is in fact the correct "
"answer.\n"
"We have not yet specified what to do in the first case.\n"
"But we do know that it has something to do with the rest of the name after "
"the first element, and that what we want is to extract the first name out of "
"those elements.\n"
"The leap of faith is to go ahead and use `first-name`, even though it has "
"not been fully defined yet:"
msgstr ""
"Это разбивает проблему на два случая.\n"
"Во втором случае мы возвращаем ответ, и это на самом деле правильный ответ.\n"
"Мы еще не определили, что делать в первом случае.\n"
"Но мы знаем, что это имеет какое-то отношение к остальной части имени после "
"первого элемента, и что мы хотим извлечь первое имя из этих элементов.\n"
"Прыжок веры заключается в том, чтобы идти вперед и использовать `first-"
"name`, даже если оно еще не полностью определено:"

#: in/chapter1.md:622
msgid ""
"```lisp\n"
"function first-name(name):\n"
"  if *the first element of name is a title*\n"
"    then *return the* first-name *of the rest of the name*\n"
"    else *return the first element of the name*\n"
"```"
msgstr ""

#: in/chapter1.md:630
msgid ""
"Now the first case in `first-name` is recursive, and the second case remains "
"unchanged.\n"
"We already agreed that the second case returns the correct answer, and the "
"first case only returns what `first-name` returns.\n"
"So `first-name` as a whole can only return correct answers.\n"
"Thus, we're halfway to showing that the function is correct; the other half "
"is to show that it eventually returns some answer.\n"
"But every recursive call chops off the first element and looks at the rest, "
"so for an *n*-element list there can be at most *n* recursive calls.\n"
"This completes the demonstration that the function is correct.\n"
"Programmers who learn to think this way find recursion to be a valuable tool "
"rather than a confusing mystery."
msgstr ""
"Теперь первый случай в `first-name` является рекурсивным, а второй случай "
"остается неизменным.\n"
"Мы уже договорились, что второй случай возвращает правильный ответ, а первый "
"случай возвращает только то, что возвращает `first-name`.\n"
"Таким образом, `first-name` в целом может возвращать только правильные "
"ответы.\n"
"Таким образом, мы находимся на полпути к тому, чтобы показать, что функция "
"верна; другая половина-показать, что она в конечном итоге возвращает "
"некоторый ответ.\n"
"Но каждый рекурсивный вызов отсекает первый элемент и смотрит на остаток, "
"так что для списка *n*-элементов может быть не более *n* рекурсивных "
"вызовов.\n"
"Это завершает демонстрацию того, что функция верна.\n"
"Программисты, которые учатся думать таким образом, находят рекурсию ценным "
"инструментом, а не запутанной тайной."

#: in/chapter1.md:632
msgid "## 1.7 Higher-Order Functions"
msgstr "## 1.7 Функции Высшего Порядка"

#: in/chapter1.md:639
msgid ""
"Functions in Lisp can not only be \"called,\" or applied to arguments, they "
"can also be manipulated just like any other kind of object.\n"
"A function that takes another function as an argument is called a *higher-"
"order function.*\n"
"`mapcar` is an example.\n"
"To demonstrate the higher-order-function style of programming, we will "
"define a new function called `mappend.` It takes two arguments, a function "
"and a list.\n"
"`mappend` maps the function over each element of the list and appends "
"together all the results.\n"
"The first definition follows immediately from the description and the fact "
"that the function `apply` can be used to apply a function to a list of "
"arguments."
msgstr ""
"Функции в Lisp можно не только \"вызывать\" или применять к аргументам, но и "
"манипулировать ими, как и любыми другими объектами.\n"
"Функция, принимающая в качестве аргумента другую функцию, называется *higher-"
"order function/функцией высшего порядка.*\n"
"`mapcar` - это пример.\n"
"Чтобы продемонстрировать стиль программирования функций высшего порядка, мы "
"определим новую функцию под названием `mappend`(map append). Для неё нужны "
"два аргумента: функция и список.\n"
"`mappend` отображает функцию для каждого элемента списка и складывает вместе "
"все результаты.\n"
"Первое определение следует непосредственно из описания и того факта, что "
"функция `apply` может быть использована для применения функции к списку "
"аргументов."

#: in/chapter1.md:645
msgid ""
"```lisp\n"
"(defun mappend (fn the-list)\n"
"  \"Apply fn to each element of list and append the results.\"\n"
"  (apply #'append (mapcar fn the-list)))\n"
"```"
msgstr ""

#: in/chapter1.md:648
msgid ""
"Now we experiment a little to see how `apply` and `mappend` work.\n"
"The first example applies the addition function to a list of four numbers."
msgstr ""
"Теперь мы немного поэкспериментируем, чтобы увидеть, как работают `apply` и "
"`mappend`.\n"
"В первом примере функция сложения применяется к списку из четырех чисел."

#: in/chapter1.md:652
msgid ""
"```lisp\n"
"> (apply #'+ '(1 2 3 4)) => 10\n"
"```"
msgstr ""

#: in/chapter1.md:655
msgid ""
"The next example applies append to a list of two arguments, where each "
"argument is a list.\n"
"If the arguments were not lists, it would be an error."
msgstr ""
"В следующем примере append применяется к списку из двух аргументов, где "
"каждый аргумент является списком.\n"
"Если бы аргументы не были списками, это было бы ошибкой."

#: in/chapter1.md:659
msgid ""
"```lisp\n"
"> (apply #'append '((1 2 3) (a b c))) => (1 2 3 A B C)\n"
"```"
msgstr ""

#: in/chapter1.md:661
msgid ""
"Now we define a new function, `self-and-double`, and apply it to a variety "
"of arguments."
msgstr ""
"Теперь мы определяем новую функцию `self-and-double` и применяем ее к "
"различным аргументам."

#: in/chapter1.md:664
msgid ""
"```lisp\n"
"> (defun self-and-double (x) (list x (+ x x)))"
msgstr ""

#: in/chapter1.md:666
msgid "> (self-and-double 3) => (3 6)"
msgstr ""

#: in/chapter1.md:669
msgid ""
"> (apply #'self-and-double '(3)) => (3 6)\n"
"```"
msgstr ""

#: in/chapter1.md:672
msgid ""
"If we had tried to apply `self-and-double` to a list of more than one "
"argument, or to a list that did not contain a number, it would be an error, "
"just as it would be an error to evaluate (`self-and-double 3 4`) or (`self-"
"and-double 'Kim`).\n"
"Now let's return to the mapping functions:"
msgstr ""
"Если бы мы попытались применить(apply) `self-and-double` к списку из более "
"чем одного аргумента или к списку, который не содержит числа, это было бы "
"ошибкой, точно так же, как это было бы ошибкой вычислять (`self-and-double 3 "
"4`) или (`self-and-double 'Kim`)\n"
"Теперь вернемся к функциям отображения:"

#: in/chapter1.md:675
msgid ""
"```lisp\n"
"> (mapcar #'self-and-double '(1 10 300)) => ((1 2) (10 20) (300 600))"
msgstr ""

#: in/chapter1.md:678
msgid ""
"> (mappend #'self-and-double '(1 10 300)) => (1 2 10 20 300 600)\n"
"```"
msgstr ""

#: in/chapter1.md:683
msgid ""
"When `mapcar` is passed a function and a list of three arguments, it always "
"returns a list of three values.\n"
"Each value is the result of calling the function on the respective "
"argument.\n"
"In contrast, when `mappend` is called, it returns one big list, which is "
"equal to all the values that `mapcar` would generate appended together.\n"
"It would be an error to call `mappend` with a function that didn't return "
"lists, because `append` expects to see lists as its arguments."
msgstr ""
"Когда `mapcar` передается функция и список из трех аргументов, она всегда "
"возвращает список из трех значений.\n"
"Каждое значение является результатом вызова функции с соответствующим "
"аргументом.\n"
"Напротив, когда вызывается `mappend`, она возвращает один большой список, "
"который равен всем значениям, которые `mapcar` будет генерировать.\n"
"Было бы ошибкой вызывать `mappend` с функцией, которая не возвращает списки, "
"потому что `append` ожидает увидеть списки в качестве своих аргументов."

#: in/chapter1.md:687
msgid ""
"Now consider the following problem: given a list of elements, return a list "
"consisting of all the numbers in the original list and the negation of those "
"numbers.\n"
"For example, given the list (`testing 1 2 3 test`), return (`1 -1 2 -2 3 "
"-3`).\n"
"This problem can be solved very easily using `mappend` as a component:"
msgstr ""
"Теперь рассмотрим следующую задачу: задан список элементов, вернуть список, "
"состоящий из всех чисел из исходного списка и отрицания этих чисел.\n"
"Например, задан список (`testing 1 2 3 test`), вернуть (`1 -1 2 -2 3 -3`)\n"
"Эта проблема может быть решена очень легко с помощью `mappend` в качестве "
"компонента:"

#: in/chapter1.md:692
msgid ""
"```lisp\n"
"(defun numbers-and-negations (input)\n"
"  \"Given a list, return only the numbers and their negations.\"\n"
"  (mappend #'number-and-negation input))"
msgstr ""

#: in/chapter1.md:698
msgid ""
"(defun number-and-negation (x)\n"
"  \"If x is a number, return a list of x and -x.\"\n"
"  (if (numberp x)\n"
"      (list x (- x))\n"
"      nil))"
msgstr ""

#: in/chapter1.md:701
msgid ""
"> (numbers-and-negations '(testing 1 2 3 test)) => (1 -1 2 -2 3 -3)\n"
"```"
msgstr ""

#: in/chapter1.md:703
msgid ""
"The alternate definition of `mappend` shown in the following doesn't make "
"use of `mapcar;` instead it builds up the list one element at a time:"
msgstr ""
"Альтернативное определение `mappend`, показанное ниже, не использует "
"`mapcar`; вместо этого он строит список по одному элементу за раз:"

#: in/chapter1.md:712
msgid ""
"```lisp\n"
"(defun mappend (fn the-list)\n"
"  \"Apply fn to each element of list and append the results.\"\n"
"  (if (null the-list)\n"
"      nil\n"
"      (append (funcall fn (first the-list))\n"
"              (mappend fn (rest the-list)))))\n"
"```"
msgstr ""

#: in/chapter1.md:714
msgid ""
"`funcall` is similar to `apply;` it too takes a function as its first "
"argument and applies the function to a list of arguments, but in the case of "
"`funcall`, the arguments are listed separately:"
msgstr ""
"`funcall` аналогичен `apply`; он также принимает функцию в качестве своего "
"первого аргумента и применяет её к списку аргументов, но в случае `funcall` "
"аргументы перечислены отдельно:"

#: in/chapter1.md:717
msgid ""
"```lisp\n"
"> (funcall #'+ 2 3) => 5"
msgstr ""

#: in/chapter1.md:719
msgid "> (apply #' + '(2 3)) => 5"
msgstr ""

#: in/chapter1.md:722
msgid ""
"> (funcall #' + '(2 3)) => *Error: (2 3) is not a number.*\n"
"```"
msgstr ""

#: in/chapter1.md:724
msgid ""
"These are equivalent to `(+  2 3), (+ 2 3)`,and`(+ '(2 3))`, respectively."
msgstr "Они эквивалентны `(+  2 3), (+ 2 3)` и `(+ '(2 3))`, соответственно."

#: in/chapter1.md:727
msgid ""
"So far, every function we have used has been either predefined in Common "
"Lisp or introduced with a `defun`, which pairs a function with a name.\n"
"It is also possible to introduce a function without giving it a name, using "
"the special syntax `lambda`."
msgstr ""
"До сих пор каждая функция, которую мы использовали, была либо предопределена "
"в Common Lisp, либо введена с помощью `defun`, которая связывает функцию с "
"именем.\n"
"Кроме того, можно ввести функцию, не давая ей имени, используя специальный "
"синтаксис `lambda`."

#: in/chapter1.md:732
msgid ""
"The name *lambda* comes from the mathematician Alonzo Church's notation for "
"functions (Church 1941).\n"
"Lisp usually prefers expressive names over terse Greek letters, but lambda "
"is an exception.\n"
"A better name would be `make-function`.\n"
"Lambda derives from the notation in Russell and Whitehead's *Principia "
"Mathematica,* which used a caret over bound variables: *x&#x302;*(*x + x*)."
msgstr ""
"Название *lambda* происходит от обозначения функций математиком Алонсо "
"Черчем (Church 1941).\n"
"Лисп обычно предпочитает выразительные имена кратким греческим буквам, но "
"лямбда-исключение.\n"
"Лучшим названием будет `make-function`.\n"
"Лямбда происходит от обозначения в Расселле и Уайтхеде *Principia "
"Mathematica*, которое использовало \"крышку\" над связанными переменными: "
"*x&#x302;*(*x + x*)."

#: in/chapter1.md:739
msgid ""
"Church wanted a one-dimensional string, so he moved the caret in front: "
"*^x*(*x + x*).\n"
"The caret looked funny with nothing below it, so Church switched to the "
"closest thing, an uppercase lambda, *&Lambda;x*(*x + x*).\n"
"The &Lambda; was easily confused with other symbols, so eventually the "
"lowercase lambda was substituted: *&lambda;x*(*x + x*).\n"
"John McCarthy was a student of Church's at Princeton, so when McCarthy "
"invented Lisp in 1958, he adopted the lambda notation.\n"
"There were no Greek letters on the keypunches of that era, so McCarthy used "
"(`lambda (x) (+ x x)`), and it has survived to this day.\n"
"In general, the form of a lambda expression is"
msgstr ""
"Черчу нужна была одномерная строка, поэтому он передвинул крышку вперед: "
"*^x*(*x + x*).\n"
"Крышка выглядела забавно, когда под ней ничего не было, поэтому Черч "
"переключился на похожую вещь, заглавную лямбду, *&Lambda;x*(*x + x*).\n"
"&Lambda; легко было перепутать с другими символами, поэтому в конце концов "
"строчная лямбда была заменена: *&lambda;x*(*x + x*).\n"
"Джон Маккарти был студентом Черча в Принстоне, поэтому, когда Маккарти "
"изобрел Lisp в 1958 году, он принял лямбда-нотацию.\n"
"В ту эпоху на клавиатурах не было греческих букв, поэтому Маккарти "
"использовал (`lambda (x) (+ x x)`), и он сохранился до наших дней.\n"
"В общем случае форма лямбда-выражения такова:"

#: in/chapter1.md:743
msgid ""
"```lisp\n"
"(lambda (*parameters...*) *body...*)\n"
"```"
msgstr ""

#: in/chapter1.md:747
msgid ""
"A lambda expression is just a nonatomic *name* for a function, just as "
"`append` is an atomic name for a built-in function.\n"
"As such, it is appropriate for use in the first position of a function call, "
"but if we want to get at the actual function, rather than its name, we still "
"have to use the `#'` notation.\n"
"For example:"
msgstr ""
"Лямбда-выражение-это просто неатомарное *имя* для функции, так же как "
"`append` -атомарное имя для встроенной функции.\n"
"Таким образом, оно подходит для использования в первой позиции вызова "
"функции, но если мы хотим получить фактическую функцию, а не ее имя, мы все "
"равно должны использовать обозначение `#'`.\n"
"Например:"

#: in/chapter1.md:750
msgid ""
"```lisp\n"
"> ((lambda (x) (+ x 2)) 4) => 6"
msgstr ""

#: in/chapter1.md:753
msgid ""
"> (funcall #'(lambda (x) (+ x 2)) 4) => 6\n"
"```"
msgstr ""

#: in/chapter1.md:767
msgid ""
"To understand the distinction we have to be clear on how expressions are "
"evaluated in Lisp.\n"
"The normal rule for evaluation states that symbols are evaluated by looking "
"up the value of the variable that the symbol refers to.\n"
"So the `x` in `(+ x 2)` is evaluated by looking up the value of the variable "
"named `x`.\n"
"A list is evaluated in one of two ways.\n"
"If the first element of the list is a special form operator, then the list "
"is evaluated according to the syntax rule for that special form.\n"
"Otherwise, the list represents a function call.\n"
"The first element is evaluated in a unique way, as a function.\n"
"This means it can either be a symbol or a lambda expression.\n"
"In either case, the function named by the first element is applied to the "
"values of the remaining elements in the list.\n"
"These values are determined by the normal evaluation rules.\n"
"If we want to refer to a function in a position other than the first element "
"of a function call, we have to use the `#'` notation.\n"
"Otherwise, the expressions will be evaluated by the normal evaluation rule, "
"and will not be treated as functions.\n"
"For example:"
msgstr ""
"Чтобы понять это различие, мы должны быть понимать то, как выражения "
"вычисляются в Lisp.\n"
"Нормальное правило вычисления гласит, что символы вычисляются путем поиска "
"значения переменной, на которую ссылается символ.\n"
"Поэтому `x` в `(+ x 2)` при вычислении ищется значение переменной с именем "
"`x`.\n"
"Список вычисляется одним из двух способов.\n"
"Если первый элемент списка является оператором специальной формы, то список "
"вычисляется в соответствии с синтаксическим правилом для этой специальной "
"формы.\n"
"В противном случае список представляет собой вызов функции.\n"
"Первый элемент вычисляется уникальным образом, как функция.\n"
"Это означает, что он может быть либо символом, либо лямбда-выражением.\n"
"В любом случае функция, именуемая первым элементом, применяется к значениям "
"остальных элементов в списке.\n"
"Эти значения определяются нормальными правилами вычисления.\n"
"Если мы хотим сослаться на функцию в позиции, отличной от первого элемента "
"вызова функции, мы должны использовать обозначение `#'`.\n"
"В противном случае выражения будут вычисляться по нормальному правилу "
"вычисления и не будут рассматриваться как функции.\n"
"Например:"

#: in/chapter1.md:770
msgid ""
"```lisp\n"
"> append => *Error: APPEND is not a bound variable*"
msgstr ""

#: in/chapter1.md:773
msgid ""
"> (lambda (x) (+ x 2)) => *Error: LAMBDA is not a function*\n"
"```"
msgstr ""

#: in/chapter1.md:775
msgid "Here are some more examples of the correct use of functions:"
msgstr "Вот еще несколько примеров правильного использования функций:"

#: in/chapter1.md:780
msgid ""
"```lisp\n"
">(mapcar #'(lambda (x) (+ x x))\n"
"         '(1 2 3 4 5)) =>\n"
"(2 4 6 8 10)"
msgstr ""

#: in/chapter1.md:785
msgid ""
"> (mappend #'(lambda (l) (list l (reverse l)))\n"
"           ((1 2 3) (a b c))) =>\n"
"((1 2 3) (3 2 1) (A B C) (C B A))\n"
"```"
msgstr ""

#: in/chapter1.md:788
msgid ""
"Programmers who are used to other languages sometimes fail to see the point "
"of lambda expressions.\n"
"There are two reasons why lambda expressions are very useful."
msgstr ""
"Программисты, привыкшие к другим языкам, иногда не видят смысла в лямбда-"
"выражениях.\n"
"Есть две причины, по которым лямбда-выражения очень полезны."

#: in/chapter1.md:791
msgid ""
"First, it can be messy to clutter up a program with superfluous names.\n"
"Just as it is clearer to write `(a+b)*(c+d)` rather than to invent variable "
"names like `temp1` and `temp2` to hold `a+b` and `c+d`, so it can be clearer "
"to define a function as a lambda expression rather than inventing a name for "
"it."
msgstr ""
"Во-первых, загромождение программы лишними именами приводит к бардаку и "
"хаосу.\n"
"Точно так же, как понятнее написать `(a+b)*(c+d)`, а не изобретать имена "
"переменных, такие как `temp1` и `temp2`, чтобы хранить `a+b` и `c+d`, так же "
"может быть яснее определить функцию как лямбда-выражение, а не изобретать "
"для нее имя."

#: in/chapter1.md:795
msgid ""
"Second, and more importantly, lambda expressions make it possible to create "
"new functions at run time.\n"
"This is a powerful technique that is not possible in most programming "
"languages.\n"
"These run-time functions, known as *closures,* will be covered in section "
"3.16."
msgstr ""
"Во-вторых, что еще более важно, лямбда-выражения позволяют создавать новые "
"функции во время выполнения.\n"
"Это мощный метод, который невозможен в большинстве языков программирования.\n"
"Эти функции времени выполнения, известные как замыкания - *closures*, будут "
"рассмотрены в разделе 3.16."

#: in/chapter1.md:797
msgid "## 1.8 Other Data Types"
msgstr "## 1.8 Другие Типы Данных"

#: in/chapter1.md:804
msgid ""
"So far we have seen just four kinds of Lisp objects: numbers, symbols, "
"lists, and functions.\n"
"Lisp actually defines about 25 different types of objects: vectors, arrays, "
"structures, characters, streams, hash tables, and others.\n"
"At this point we will introduce one more, the string.\n"
"As you can see in the following, strings, like numbers, evaluate to "
"themselves.\n"
"Strings are used mainly for printing out messages, while symbols are used "
"for their relationships to other objects, and to name variables.\n"
"The printed representation of a string has a double quote mark `(\")` at "
"each end."
msgstr ""
"До сих пор мы видели только четыре вида объектов Lisp: числа, символы, "
"списки и функции.\n"
"Lisp фактически определяет около 25 различных типов объектов: векторы, "
"массивы, структуры, символьные знаки, потоки, хэш-таблицы и другие.\n"
"На этом этапе мы введем еще один, строки.\n"
"Как вы можете видеть далее, строки, как и числа, вычисляют себя сами.\n"
"Строки используются главным образом для печати сообщений, в то время как "
"символы используются для установки отношений/связей с другими объектами и "
"для именования переменных.\n"
"Печатное представление строки имеет двойную кавычку `(\")` на каждом конце."

#: in/chapter1.md:807
msgid ""
"```lisp\n"
"> \"a string\" => \"a string\""
msgstr ""

#: in/chapter1.md:809
msgid "> (length \"a string\") => 8"
msgstr ""

#: in/chapter1.md:812
msgid ""
"> (length \"\") => 0\n"
"```"
msgstr ""

#: in/chapter1.md:814
msgid "## 1.9 Summary: The Lisp Evaluation Rule"
msgstr "## 1.9 Резюме: Правило Вычисления(Оценки) в Lisp"

#: in/chapter1.md:816
msgid "We can now summarize the evaluation rule for Lisp."
msgstr "Теперь мы можем обобщить правило вычисления для Lisp."

#: in/chapter1.md:818
msgid "*   Every expression is either a *list* or an *atom.*"
msgstr "*   Каждое выражение - это либо список(*list*), либо атом(*atom*)."

#: in/chapter1.md:820
msgid ""
"*   Every list to be evaluated is either a *special form expression* or a "
"*function application*."
msgstr ""
"*   Каждый список, подлежащий вычислению/оценке, является либо *выражением "
"специальной формы*, либо *применением функции*."

#: in/chapter1.md:828
msgid ""
"*   A *special form expression* is defined to be a list whose first element "
"is a special form operator.\n"
"The expression is evaluated according to the operator's idiosyncratic "
"evaluation rule.\n"
"For example, the evaluation rule for `setf` is to evaluate the second "
"argument according to the normal evaluation rule, set the first argument to "
"that value, and return the value as the result.\n"
"The rule for `defun` is to define a new function, and return the name of the "
"function.\n"
"The rule for quote is to return the first argument unevaluated.\n"
"The notation `'x` is actually an abbreviation for the special form "
"expression `(quote x)`.\n"
"Similarly, the notation `#'f` is an abbreviation for the special form "
"expression `(function f)`."
msgstr ""
"*   *Выражение специальной формы* определяется как список, первым элементом "
"которого является оператор специальной формы.\n"
"Выражение вычисляется в соответствии с правилом "
"идиосинкразической(своеобразного) вычисления оператора.\n"
"Например, правило вычисления для `setf` состоит в том, чтобы вычислить "
"второй аргумент в соответствии с обычным правилом вычисления, установить "
"первый аргумент в это значение и вернуть значение в качестве результата.\n"
"Правило для `defun` состоит в том, чтобы определить новую функцию и вернуть "
"ее имя.\n"
"Правило для `quote`(цитаты) состоит в том, чтобы вернуть первый аргумент не "
"вычисленным.\n"
"Обозначение `'x` на самом деле является аббревиатурой выражения специальной "
"формы `(quote x)`.\n"
"Аналогично, обозначение `#'f` является аббревиатурой для выражения "
"специальной формы `(function f)`."

#: in/chapter1.md:831
msgid ""
"```lisp\n"
"'John = (quote John) => JOHN"
msgstr ""

#: in/chapter1.md:833
msgid "(setf p 'John) => JOHN"
msgstr ""

#: in/chapter1.md:835
msgid "defun twice (x) (+ x x)) => TWICE"
msgstr "(defun twice (x) (+ x x)) => TWICE"

#: in/chapter1.md:838
msgid ""
"(if (=  2 3) (error) (+  5 6)) => 11\n"
"```"
msgstr ""

#: in/chapter1.md:840
msgid ""
"*   A *function application* is evaluated by first evaluating the arguments "
"(the rest of the list) and then finding the function named by the first "
"element of the list and applying it to the list of evaluated arguments."
msgstr ""
"*   *Применение функции* вычисляется путем вычисления, в первую очередь, "
"аргументов (остальная часть списка), а затем нахождения функции, именуемой "
"первым элементом списка, и применения её к списку вычисляемых аргументов."

#: in/chapter1.md:845
msgid ""
"```lisp\n"
"(+  2 3) => 5\n"
"(- (+  90 9) (+  50 5 (length '(Pat Kim)))) => 42\n"
"```"
msgstr ""

#: in/chapter1.md:847
msgid ""
"Note that if `'(Pat Kim)` did not have the quote, it would betreated as a "
"function application of the function `pat` to the value of the variable `kim."
"`"
msgstr ""
"Обратите внимание, что если бы у `'(Pat Kim)` не было кавычки, то она была "
"бы интерпретирована как применение функции   `pat` к значению переменной   "
"`kim`."

#: in/chapter1.md:849
msgid "*   Every atom is either a *symbol* or a *nonsymbol.*"
msgstr "*   Каждый атом является либо *символом*, либо *несимволом*."

#: in/chapter1.md:854
msgid ""
"*   A *symbol* evaluates to the most recent value that has been assigned to "
"the variable named by that symbol.\n"
"Symbols are composed of letters, and possibly digits and, rarely, "
"punctuation characters.\n"
"<a id=\"tfn01-6\"></a>\n"
"To avoid confusion, we will use symbols composed mostly of the letters `a-z` "
"and the `'-'` character, with a few exceptions.[6](#fn01-6)"
msgstr ""
"*   *Символ* вычисляет самое последнее значение, которое было присвоено "
"переменной, именуемой этим символом.\n"
"Символы состоят из букв, и возможно, цифр и, реже, знаков препинания.\n"
"<a id=\"tfn01-6\"></a>\n"
"Чтобы избежать путаницы, мы будем использовать символы, состоящие в основном "
"из букв `a-z` и знака `'-'`, за некоторыми исключениями.[6](#fn01-6)"

#: in/chapter1.md:860
msgid ""
"```lisp\n"
"names\n"
"p\n"
"*print-pretty*\n"
"```"
msgstr ""

#: in/chapter1.md:866
msgid ""
"*   A *nonsymbol atom* evaluates to itself.\n"
"For now, numbers and strings are the only such non-symbol atoms we know of.\n"
"Numbers are composed of digits, and possibly a decimal point and sign.\n"
"There are also provisions for scientific notation, rational and complex "
"numbers, and numbers with different bases, but we won't describe the details "
"here.\n"
"Strings are delimited by double quote marks on both sides."
msgstr ""
"*   *Несимвольный атом* вычисляет себя.\n"
"На данный момент числа и строки-единственные известные нам атомы не "
"являющиеся символами.\n"
"Числа состоят из цифр и, возможно, десятичной точки и знака.\n"
"Существуют также положения о научной нотации, рациональных и комплексных "
"числел, а также числах с различными основаниями, но мы не будем описывать "
"здесь детали.\n"
"Строки выделяются двойными кавычками с обеих сторон."

#: in/chapter1.md:872
msgid ""
"```lisp\n"
"42 => 42\n"
"-273.15 => -273.15\n"
"\"a string\" => \"a string\"\n"
"```"
msgstr ""

#: in/chapter1.md:874
msgid ""
"There are some minor details of Common Lisp that complicate the evaluation "
"rules, but this definition will suffice for now."
msgstr ""
"Есть некоторые незначительные детали Common Lisp, которые усложняют правила "
"вычисления, но пока этого определения будет достаточно."

#: in/chapter1.md:877
msgid ""
"One complication that causes confusion for beginning Lispers is the "
"difference between *reading* and *evaluating* an expression.\n"
"Beginners often imagine that when they type an expression, such as"
msgstr ""
"Одно из осложнений, которое вызывает путаницу у начинающих Лисперов, - это "
"разница между \"чтением\" и \"вычислением/оценкой\" выражения.\n"
"Новички часто представляют себе, что когда они вводят выражение, например"

#: in/chapter1.md:881
msgid ""
"```lisp\n"
"> (+ (* 3 4) (* 5 6))\n"
"```"
msgstr ""

#: in/chapter1.md:886
msgid ""
"the Lisp system first reads the (`+`, then fetches the addition function, "
"then reads `(* 3 4)` and computes `12`, then reads `(* 5 6)` and computes "
"30, and finally computes 42.\n"
"In fact, what actually happens is that the system first reads the entire "
"expression, the list `(+ (* 3 4) (* 5 6))`.\n"
"Only after it has been read does the system begin to evaluate it.\n"
"This evaluation can be done by an interpreter that looks at the list "
"directly, or it can be done by a compiler that translates the list into "
"machine language instructions and then executes those instructions."
msgstr ""
"система Lisp сначала считывает (`+` , затем извлекает функцию сложения, "
"затем считывает `(* 3 4)` и вычисляет `12`, затем читает `(* 5 6)` и "
"вычисляет 30, и, наконец, вычисляет 42.\n"
"На самом деле, происходит то, что система сначала считывает все выражение, "
"список `(+ (* 3 4) (* 5 6))`.\n"
"Только после того, как оно было прочитано, система начинает его вычилять.\n"
"Это вычиление может быть выполнено интерпретатором, который непосредственно "
"смотрит на список, или компилятором, который переводит список в инструкции "
"машинного языка и затем выполняет эти инструкции."

#: in/chapter1.md:890
msgid ""
"We can see now that it was a little imprecise to say, \"Numbers are composed "
"of digits, and possibly a decimal point and sign.\" It would be more precise "
"to say that the printed representation of a number, as expected by the "
"function read and as produced by the function print, is composed of digits, "
"and possibly a decimal point and sign.\n"
"The internal representation of a number varies from one computer to another, "
"but you can be sure that it will be a bit pattern in a particular memory "
"location, and it will no longer contain the original characters used to "
"represent the number in decimal notation.\n"
"Similarly, it is the printed representation of a string that is surrounded "
"by double quote marks; the internal representation is a memory location "
"marking the beginning of a vector of characters."
msgstr ""
"Теперь мы видим, что было бы несколько неточно сказать: \"числа состоят из "
"цифр и, возможно, десятичной точки и знака.\" Было бы более точным сказать, "
"что печатное представление числа, ожидаемое функцией read и производимое "
"функцией print, состоит из цифр и, возможно, десятичной точки и знака.\n"
"Внутреннее представление числа варьируется от одного компьютера к другому, "
"но вы можете быть уверены, что это будет битовый шаблон в определенной "
"ячейке памяти, и он больше не будет содержать исходные знаки, используемые "
"для представления числа в десятичной системе счисления.\n"
"Аналогично, это печатное представление строки, которая окружена двойными "
"кавычками; внутреннее представление-это ячейка памяти, отмечающая начало "
"вектора знаков."

#: in/chapter1.md:895
msgid ""
"Beginners who fail to grasp the distinction between reading and evaluating "
"may have a good model of what expressions evaluate to, but they usually have "
"a terrible model of the efficiency of evaluating expressions.\n"
"One student used only one-letter variable names, because he felt that it "
"would be faster for the computer to look up a one-letter name than a "
"multiletter name.\n"
"While it may be true that shorter names can save a microsecond at read time, "
"this makes no difference at all at evaluation time.\n"
"Every variable, regardless of its name, is just a memory location, and the "
"time to access the location does not depend on the name of the variable."
msgstr ""
"Новички, которые не понимают разницы между чтением и вычислением, могут "
"иметь хорошую модель того, что выражения вычисляют, но у них обычно есть "
"ужасная модель эффективности вычисления выражений.\n"
"Один студент использовал только однобуквенные имена переменных, потому что "
"он чувствовал, что для компьютера было бы быстрее найти однобуквенное имя, "
"чем многобуквенное имя.\n"
"Хотя это может быть правдой, что более короткие имена могут сэкономить "
"микросекунду во время чтения, это не имеет никакого значения во время "
"вычисления.\n"
"Каждая переменная, независимо от ее имени, является просто ячейкой памяти, и "
"время доступа к ней не зависит от имени переменной."

#: in/chapter1.md:897
msgid "## 1.10 What Makes Lisp Different?"
msgstr "## 1.10 Что Делает Лисп - Особенным?"

#: in/chapter1.md:901
msgid ""
"What is it that sets Lisp apart from other languages?\n"
"Why is it a good language for AI applications?\n"
"There are at least eight important factors:"
msgstr ""
"Что же отличает Lisp от других языков?\n"
"Почему это хороший язык для приложений искусственного интеллекта?\n"
"Существует по меньшей мере восемь важных факторов:"

#: in/chapter1.md:910
msgid ""
"*   Built-in Support for Lists\n"
"*   Automatic Storage Management\n"
"*   Dynamic Typing\n"
"*   First-Class Functions\n"
"*   Uniform Syntax\n"
"*   Interactive Environment\n"
"*   Extensibility\n"
"*   History"
msgstr ""
"* Встроенная поддержка списков\n"
"* Автоматическое Управление Хранилищем\n"
"* Динамическая типизация\n"
"* Функции Первого Класса\n"
"* Единообразный Синтаксис\n"
"* Интерактивная Среда\n"
"* Расширяемость\n"
"* История"

#: in/chapter1.md:914
msgid ""
"In sum, these factors allow a programmer to delay making decisions.\n"
"In the example dealing with names, we were able to use the built-in list "
"functions to construct and manipulate names without making a lot of explicit "
"decisions about their representation.\n"
"If we decided to change the representation, it would be easy to go back and "
"alter parts of the program, leaving other parts unchanged."
msgstr ""
"В сумме, эти факторы позволяют программисту откладывать принятие решений.\n"
"В Примере, связанном с именами, мы смогли использовать встроенные функции "
"списка для построения и манипулирования именами, не принимая много явных "
"решений об их представлении.\n"
"Если бы мы решили изменить представление, было бы легко вернуться назад и "
"изменить части программы, оставив другие части неизменными."

#: in/chapter1.md:921
msgid ""
"This ability to delay decisions-or more accurately, to make temporary, "
"nonbinding decisions-is usually a good thing, because it means that "
"irrelevant details can be ignored.\n"
"There are also some negative points of delaying decisions.\n"
"First, the less we tell the compiler, the greater the chance that it may "
"have to produce inefficient code.\n"
"Second, the less we tell the compiler, the less chance it has of noticing "
"inconsistencies and warning us.\n"
"Errors may not be detected until the program is run.\n"
"Let's consider each factor in more depth, weighing the advantages and "
"disadvantages:"
msgstr ""
"Эта способность откладывать принятие решений или, точнее, принимать "
"временные, не обязывающие решения-обычно является хорошей вещью, потому что "
"это означает, что несущественные детали могут быть проигнорированы.\n"
"Есть и некоторые негативные моменты затягивания принятия решений.\n"
"Во-первых, чем меньше мы сообщаем компилятору, тем больше вероятность того, "
"что он будет выдавать неэффективный код.\n"
"Во-вторых, чем меньше мы сообщаем компилятору, тем меньше у него шансов "
"заметить несоответствия и предупредить нас.\n"
"Ошибки могут быть обнаружены только после запуска программы.\n"
"Рассмотрим каждый фактор более подробно, взвешивая достоинства и недостатки:"

#: in/chapter1.md:927
msgid ""
"*   *Built-in Support for Lists.*\n"
"The list is a very versatile data structure, and while lists can be "
"implemented in any language, Lisp makes it easy to use them.\n"
"Many AI applications involve lists of constantly changing size, making fixed-"
"length data structures like vectors harder to use.\n"
"Early versions of Lisp used lists as their only aggregate data structure.\n"
"Common Lisp provides other types as well, because lists are not always the "
"most efficient choice."
msgstr ""
"*   *Встроенная поддержка списков.*\n"
"Список - это очень универсальная структура данных, и хотя списки могут быть "
"реализованы на любом языке, Lisp упрощает их использование.\n"
"Многие приложения искусственного интеллекта включают в себя списки постоянно "
"меняющегося размера, что затрудняет использование структур данных "
"фиксированной длины, таких как векторы.\n"
"Ранние версии Lisp использовали списки как единственную структуру "
"агрегированных данных.\n"
"Common Lisp предоставляет и другие типы, поскольку списки не всегда являются "
"наиболее эффективным выбором."

#: in/chapter1.md:936
msgid ""
"*   *Automatic Storage Management.*\n"
"The Lisp programmer needn't keep track of memory allocation; it is all done "
"automatically.\n"
"This frees the programmer of a lot of effort, and makes it easy to use the "
"functional style of programming.\n"
"Other languages present programmers with a choice.\n"
"Variables can be allocated on the stack, meaning that they are created when "
"a procedure is entered, and disappear when the procedure is done.\n"
"This is an efficient use of storage, but it rules out functions that return "
"complex values.\n"
"The other choice is for the programmer to explicitly allocate and free "
"storage.\n"
"This makes the functional style possible but can lead to errors."
msgstr ""
"*   *Автоматическое Управление Хранилищем.*\n"
"Программисту Lisp не нужно следить за распределением памяти; все это "
"делается автоматически.\n"
"Это освобождает программиста от больших усилий и облегчает использование "
"функционального стиля программирования.\n"
"Другие языки предоставляют программистам возможность выбора.\n"
"Переменные могут быть выделены в стеке, что означает, что они создаются при "
"вводе процедуры и исчезают, когда процедура завершена.\n"
"Это эффективное использование хранилища, но оно исключает функции, "
"возвращающие сложные значения.\n"
"Другой выбор заключается в том, чтобы программист явно выделял и освобождал "
"хранилище.\n"
"Это делает функциональный стиль возможным, но может привести к ошибкам."

#: in/chapter1.md:939
msgid ""
"For example, consider the trivial problem of computing the expression *a* x "
"(b + c), where *a*, *b*, and *c* are numbers.\n"
"The code is trivial in any language; here it is in Pascal and in Lisp:"
msgstr ""
"Например, рассмотрим тривиальную задачу вычисления выражения *a* x (b + c), "
"где *a*, *b* и *c* - числа.\n"
"Код тривиален на любом языке; здесь он приводиться на Pascal и Lisp:"

#: in/chapter1.md:944
msgid ""
"| []()           |                 |\n"
"|----------------|-----------------|\n"
"| `/* Pascal */` | `;;; Lisp`      |\n"
"| `a * (b + c)`  | `(* a (+ b c))` |"
msgstr ""

#: in/chapter1.md:951
msgid ""
"The only difference is that Pascal uses infix notation and Lisp uses "
"prefix.\n"
"Now consider computing *a* x (b + c) when *a*, *b*, and *c* are matrices.\n"
"Assume we have procedures for matrix multiplication and addition.\n"
"In Lisp the form is exactly the same; only the names of the functions are "
"changed.\n"
"In Pascal we have the choice of approaches mentioned before.\n"
"We could declare temporary variables to hold intermediate results on the "
"stack, and replace the functional expression with a series of procedure "
"calls:"
msgstr ""
"Единственная разница заключается в том, что Pascal использует инфиксную "
"нотацию, а Lisp-префиксную.\n"
"Теперь рассмотрим вычисление *a* x (b + c), когда *a*, *b* и *c* являются "
"матрицами.\n"
"Предположим, что у нас есть процедуры умножения и сложения матриц.\n"
"В Lisp форма точно такая же, меняются только названия функций.\n"
"В Паскале мы имеем выбор подходов, упомянутых выше.\n"
"Мы могли бы объявить временные переменные для хранения промежуточных "
"результатов в стеке и заменить функциональное выражение серией вызовов "
"процедур:"

#: in/chapter1.md:959
msgid ""
"| []()                        |                      |\n"
"|-----------------------------|----------------------|\n"
"| `/* Pascal */`              | `;;; Lisp`           |\n"
"| `var temp, result: matrix;` |                      |\n"
"| `add(b,c,temp);`            | `(mult a (add b c))` |\n"
"| `mult(a,temp,result);`      |                      |\n"
"| `return(result);`           |                      |"
msgstr ""

#: in/chapter1.md:963
msgid ""
"The other choice is to write Pascal functions that allocate new matrices on "
"the heap.\n"
"Then one can write nice functional expressions like `mult(a,add(b,c))` even "
"in Pascal.\n"
"However, in practice it rarely works this nicely, because of the need to "
"manage storage explicitly:"
msgstr ""
"Другой вариант-написать функции Pascal, которые выделяют новые матрицы в "
"куче.\n"
"Тогда можно написать хорошие функциональные выражения типа `mult(a,add(b,"
"c))` даже на языке Паскаля.\n"
"Однако на практике это редко работает так хорошо из-за необходимости явно "
"управлять хранилищем:"

#: in/chapter1.md:972
msgid ""
"| []()                     |                      |\n"
"|--------------------------|----------------------|\n"
"| `/* Pascal */`           | `;;; Lisp`           |\n"
"| `var a,b,c,x,y: matrix;` |                      |\n"
"| `x := add(b.c);`         | `(mult a (add b c))` |\n"
"| `y := mult(a,x);`        |                      |\n"
"| `free(x);`               |                      |\n"
"| `return(y);`             |                      |"
msgstr ""

#: in/chapter1.md:977
msgid ""
"In general, deciding which structures to free is a difficult task for the "
"Pascal programmer.\n"
"If the programmer misses some, then the program may run out of memory.\n"
"Worse, if the programmer frees a structure that is still being used, then "
"strange errors can occur when that piece of memory is reallocated.\n"
"Lisp automatically allocates and frees structures, so these two types of "
"errors can *never* occur."
msgstr ""
"В общем, решить, какие структуры освободить, - сложная задача для "
"программиста Pascal.\n"
"Если программист что-то пропустит, то у программы может закончиться память.\n"
"Хуже того, если программист освобождает структуру, которая все еще "
"используется, то при перераспределении этого фрагмента памяти могут "
"возникнуть странные ошибки.\n"
"Lisp автоматически выделяет и освобождает структуры, поэтому эти два типа "
"ошибок могут *никогда* не возникать."

#: in/chapter1.md:993
msgid ""
"*   *Dynamic Typing.*\n"
"Lisp programmers don't have to provide type declarations, because the "
"language keeps track of the type of each object at run time, rather than "
"figuring out all types at compile time.\n"
"This makes Lisp programs shorter and hence faster to develop, and it also "
"means that functions can often be extended to work for objects to which they "
"were not originally intended to apply.\n"
"In Pascal, we can write a procedure to sort an array of 100 integers, but we "
"can't use that same procedure to sort 200 integers, or 100 strings.\n"
"In Lisp, one `sort` fits all.\n"
"One way to appreciate this kind of flexibility is to see how hard it is to "
"achieve in other languages.\n"
"It is impossible in Pascal; in fact, the language Modula was invented "
"primarily to fix this problem in Pascal.\n"
"The language Ada was designed to allow flexible generic functions, and a "
"book by Musser and Stepanov (1989) describes an Ada package that gives some "
"of the functionality of Common Lisp's sequence functions.\n"
"But the Ada solution is less than ideal: it takes a 264-page book to "
"duplicate only part of the functionality of the 20-page chapter 14 from "
"Steele (1990), and Musser and Stepanov went through five Ada compilers "
"before they found one that would correctly compile their package.\n"
"Also, their package is considerably less powerful, since it does not handle "
"vectors or optional keyword parameters.\n"
"In Common Lisp, all this functionality comes for free, and it is easy to add "
"more.\n"
"On the other hand, dynamic typing means that some errors will go undetected "
"until run time.\n"
"The great advantage of strongly typed languages is that they are able to "
"give error messages at compile time.\n"
"The great frustration with strongly typed languages is that they are only "
"able to warn about a small class of errors.\n"
"They can tell you that you are mistakenly passing a string to a function "
"that expects an integer, but they can't tell you that you are passing an odd "
"number to a function that expects an even number."
msgstr ""
"*   *динамическая типизация.*\n"
"Программистам Lisp не нужно предоставлять объявления типов, потому что язык "
"отслеживает тип каждого объекта во время выполнения, а не вычисляет все типы "
"во время компиляции.\n"
"Это делает Лисп-программы короче и, следовательно, они быстрее "
"разрабатываются, а также означает, что функции часто могут быть расширены "
"для работы с объектами, к которым они изначально не предназначались.\n"
"В Pascal мы можем написать процедуру сортировки массива из 100 целых чисел, "
"но мы не можем использовать ту же самую процедуру для сортировки 200 целых "
"чисел или 100 строк.\n"
"В Лиспе один `sort` подходит всем.\n"
"Один из способов оценить такую гибкость заключается в том, чтобы увидеть, "
"насколько трудно достичь ее на других языках.\n"
"Это невозможно в Паскале; на самом деле, язык Modula был изобретен в первую "
"очередь для решения этой проблемы в Паскале.\n"
"Язык Ada был разработан для обеспечения гибких универсальных функций, и в "
"книге Муссера и Степанова (1989) описан пакет Ada, который дает некоторые "
"функциональные возможности функций роботы с последовательностями Common "
"Lisp.\n"
"Но решение Ada далеко не идеально: требуется 264-страничная книга, чтобы "
"дублировать только часть функциональности 20-страничной главы 14 из Steele "
"(1990), и Мюссер и Степанов прошли через пять компиляторов Ada, прежде чем "
"нашли тот, который правильно скомпилировал бы их пакет.\n"
"Кроме того, их пакет значительно менее мощный, так как он не обрабатывает "
"векторы или необязательные параметры ключевых слов.\n"
"В Common Lisp вся эта функциональность поставляется бесплатно,и ее легко "
"добавить.\n"
"С другой стороны, динамическая типизация означает, что некоторые ошибки "
"останутся незамеченными до времени выполнения.\n"
"Большим преимуществом строго типизированных языков является то, что они "
"способны выдавать сообщения об ошибках во время компиляции.\n"
"Большое разочарование в строго типизированных языках заключается в том, что "
"они способны предупреждать только о небольшом классе ошибок.\n"
"Они могут сказать вам, что вы ошибочно передаете строку функции, которая "
"ожидает целое число, но они не могут сказать вам, что вы передаете нечетное "
"число функции, которая ожидает четное число."

#: in/chapter1.md:999
msgid ""
"*   *First-Class Functions.*\n"
"A *first-class* object is one that can be used anywhere and can be "
"manipulated in the same ways as any other kind of object.\n"
"In Pascal or C, for example, functions can be passed as arguments to other "
"functions, but they are not first-class, because it is not possible to "
"create new functions while the program is running, nor is it possible to "
"create an anonymous function without giving it a name.\n"
"In Lisp we can do both those things using `lambda`.\n"
"This is explained in section 3.16, page 92."
msgstr ""
"*   *Функции Первого Класса*\n"
"Объект первого класса - это объект, который можно использовать где угодно и "
"которым можно манипулировать так же, как и любым другим типом объекта.\n"
"В Pascal или C, например, функции могут передаваться в качестве аргументов "
"другим функциям, но они не являются первоклассными, поскольку невозможно "
"создать новые функции во время работы программы, а также невозможно создать "
"анонимную функцию, не дав ей имени.\n"
"В Lisp мы можем делать обе эти вещи, используя `lambda`.\n"
"Это объясняется в разделе 3.16, стр. 92."

#: in/chapter1.md:1026
msgid ""
"*   *Uniform Syntax.*\n"
"The syntax of Lisp programs is simple.\n"
"This makes the language easy to learn, and very little time is wasted "
"correcting typos.\n"
"In addition, it is easy to write programs that manipulate other programs or "
"define whole new languages-a very powerful technique.\n"
"The simple syntax also makes it easy for text editing programs to parse "
"Lisp.\n"
"Your editor program should be able to indent expressions automatically and "
"to show matching parentheses.\n"
"This is harder to do for languages with complex syntax.\n"
"On the other hand, some people object to all the parentheses.\n"
"There are two answers to this objection.\n"
"First, consider the alternative: in a language with \"conventional\" syntax, "
"Lisp's parentheses pairs would be replaced either by an implicit operator "
"precedence rule (in the case of arithmetic and logical expressions) or by a "
"`begin/end` pair (in the case of control structures).\n"
"But neither of these is necessarily an advantage.\n"
"Implicit precedence is notoriously error-prone, and `begin/end` pairs "
"clutter up the page without adding any content.\n"
"Many languages are moving away from `begin/end: C` uses { and }, which are "
"equivalent to parentheses, and several modern functional languages (such as "
"Haskell) use horizontal blank space, with no explicit grouping at all.\n"
"Second, many Lisp programmers *have* considered the alternative.\n"
"There have been a number of preprocessors that translate from \"conventional"
"\" syntax into Lisp.\n"
"None of these has caught on.\n"
"It is not that Lisp programmers find it *tolerable* to use all those "
"parentheses, rather, they find it *advantageous.*\n"
"With a little experience, you may too.\n"
"It is also important that the syntax of Lisp data is the same as the syntax "
"of programs.\n"
"Obviously, this makes it easy to convert data to program.\n"
"Less obvious is the time saved by having universal functions to handle input "
"and output.\n"
"The Lisp functions `read` and `print` will automatically handle any list, "
"structure, string, or number.\n"
"This makes it trivial to test individual functions while developing your "
"program.\n"
"In a traditional language like C or Pascal, you would have to write special-"
"purpose functions to read and print each data type you wanted to debug, as "
"well as a special-purpose driver to call the routines.\n"
"Because this is time-consuming and error-prone, the temptation is to avoid "
"testing altogether.\n"
"Thus, Lisp encourages better-tested programs, and makes it easier to develop "
"them faster."
msgstr ""
"*   *Единый Синтаксис.*\n"
"Синтаксис Лисп-программ прост.\n"
"Это облегчает изучение языка, и очень мало времени тратится на исправление "
"опечаток.\n"
"Кроме того, легко писать программы, которые управляют другими программами "
"или определяют целые новые языки-очень мощная техника.\n"
"Простой синтаксис также позволяет программам редактирования текста легко "
"анализировать Lisp.\n"
"Ваша программа-редактор должна иметь возможность автоматически делать "
"отступы в выражениях и показывать соответствующие скобки.\n"
"Это труднее сделать для языков со сложным синтаксисом.\n"
"С другой стороны, некоторые люди возражают против всех скобок.\n"
"На это возражение есть два ответа.\n"
"Во-первых, рассмотрим альтернативу: в языке с \"обычным\" синтаксисом пары "
"скобок Lisp будут заменены либо неявным правилом приоритета операторов (в "
"случае арифметических и логических выражений), либо парой `begin/end` (в "
"случае управляющих структур).\n"
"Но ни то, ни другое не обязательно является преимуществом.\n"
"Неявный приоритет, как известно, подвержен ошибкам, и пары `begin/end` "
"загромождают страницу без добавления какого-либо информационного "
"содержания.\n"
"Многие языки отходят от `begin/end: C` использует { и }, которые "
"эквивалентны скобкам, а некоторые современные функциональные языки (такие "
"как Haskell) используют горизонтальное пустое пространство, вообще не имея "
"явной группировки.\n"
"Во-вторых, многие Лисп-программисты рассматривали альтернативу.\n"
"Существует ряд препроцессоров, которые переводят с \"обычного\" синтаксиса "
"на Лисп.\n"
"Ни одна из них не прижилась.\n"
"Дело не в том, что Лисп-программисты находят это *терпимым*, чтобы "
"использовать все эти скобки, скорее, они находят это *выгодным.*\n"
"Имея небольшой опыт, вы тоже сможете.\n"
"Также важно, чтобы синтаксис данных Lisp был таким же, как и синтаксис "
"программ.\n"
"Очевидно, что это позволяет легко конвертировать данные в программу.\n"
"Менее очевидным является экономия времени за счет наличия универсальных "
"функций для обработки ввода и вывода.\n"
"Функции Lisp `read` и `print` автоматически обрабатывают любой список, "
"структуру, строку или число.\n"
"Это делает тривиальным тестирование отдельных функций при разработке вашей "
"программы.\n"
"В традиционном языке, таком как C или Pascal, вам придется написать "
"специальные функции для чтения и печати каждого типа данных, который вы "
"хотите отладить, а также специальный драйвер для вызова подпрограмм.\n"
"Поскольку это отнимает много времени и подвержено ошибкам, возникает соблазн "
"вообще избежать тестирования.\n"
"Таким образом, Lisp поощряет более проверенные программы и облегчает их "
"быструю разработку."

#: in/chapter1.md:1049
msgid ""
"*   *Interactive Environment.*\n"
"Traditionally, a programmer would write a complete program, compile it, "
"correct any errors detected by the compiler, and then run and debug it.\n"
"This is known as the *batch* mode of interaction.\n"
"For long programs, waiting for the compiler occupied a large portion of the "
"debugging time.\n"
"In Lisp one normally writes a few small functions at a time, getting "
"feedback from the Lisp system after evaluating each one.\n"
"This is known as an *interactive* environment.\n"
"When it comes time to make a change, only the changed functions need to be "
"recompiled, so the wait is much shorter.\n"
"In addition, the Lisp programmer can debug by typing in arbitrary "
"expressions at any time.\n"
"This is a big improvement over editing the program to introduce print "
"statements and recompiling.\n"
"Notice that the distinction between *interactive* and a *batch* languages is "
"separate from the distinction between *interpreted* and *compiled* "
"languages.\n"
"It has often been stated, incorrectly, that Lisp has an advantage by virtue "
"of being an interpreted language.\n"
"Actually, experienced Common Lisp programmers tend to use the compiler "
"almost exclusively.\n"
"The important point is interaction, not interpretation.\n"
"The idea of an interactive environment is such a good one that even "
"traditional languages like C and Pascal are starting to offer interactive "
"versions, so this is not an exclusive advantage of Lisp.\n"
"However, Lisp still provides much better access to the interactive "
"features.\n"
"A C interpreter may allow the programmer to type in an expression and have "
"it evaluated immediately, but it will not allow the programmer to write a "
"program that, say, goes through the symbol table and finds all the user-"
"defined functions and prints information on them.\n"
"In C-even interpreted C-the symbol table is just a Cheshire-cat-like "
"invention of the interpreter's imagination that disappears when the program "
"is run.\n"
"<a id=\"tfn01-7\"></a>\n"
"In Lisp, the symbol table is a first-class object[7](#fn01-7) that can be "
"accessed and modified with functions like `read, intern` and `do-symbols`.\n"
"Common Lisp offers an unusually rich set of useful tools, including over 700 "
"built-in functions (ANSI Common Lisp has over 900).\n"
"Thus, writing a new program involves more gathering of existing pieces of "
"code and less writing of new code from scratch.\n"
"In addition to the standard functions, Common Lisp implementations usually "
"provide extensions for interacting with the editor, debugger, and window "
"system."
msgstr ""
"*   *интерактивная среда.*\n"
"Обычно программист пишет полную программу, компилирует ее, исправляет все "
"ошибки, обнаруженные компилятором, а затем запускает и отлаживает ее.\n"
"Это называется *пакетный* режим взаимодействия.\n"
"Для длинных программ ожидание компилятора занимало большую часть времени "
"отладки.\n"
"В Lisp обычно пишется несколько небольших функций одновременно, получая "
"обратную связь от системы Lisp после оценки каждой из них.\n"
"Это называется *интерактивная* среда.\n"
"Когда приходит время вносить изменения, только измененные функции должны "
"быть перекомпилированы, поэтому ожидание намного короче.\n"
"Кроме того, программист Lisp может выполнять отладку, вводя произвольные "
"выражения в любое время.\n"
"Это большое улучшение по сравнению с редактированием программы для введения "
"инструкций печати и перекомпиляции.\n"
"Обратите внимание, что различие между *интерактивными* и *пакетными* языками "
"отличается от различия между *интерпретируемыми* и *компилируемыми* "
"языками.\n"
"Часто неверно утверждается, что Lisp имеет преимущество в силу того, что он "
"является интерпретируемым языком.\n"
"На самом деле, опытные программисты Common Lisp, как правило, используют "
"почти исключительно компилятор.\n"
"Важным моментом является взаимодействие, а не интерпретация.\n"
"Идея интерактивной среды настолько хороша, что даже традиционные языки, "
"такие как C и Pascal, начинают предлагать интерактивные версии, так что это "
"не является исключительным преимуществом Lisp.\n"
"Однако Lisp по-прежнему обеспечивает гораздо лучший доступ к интерактивным "
"функциям.\n"
"Интерпретатор языка Си может позволить программисту ввести выражение и "
"немедленно вычислить его, но он не позволит программисту написать программу, "
"которая, скажем, проходит через таблицу символов и находит все "
"пользовательские функции и печатает информацию о них.\n"
"В C-даже интерпретируемом C-символьная таблица-это просто Чеширский кот-"
"изобретение воображения интерпретатора, которое исчезает при запуске "
"программы.\n"
"<a id=\"tfn01-7\"></a>\n"
"В Lisp таблица символов является первоклассным объектом[7](#fn01-7), доступ "
"к которому можно получить и изменить с помощью таких функций, как `read, "
"intern` и `do-symbols`.\n"
"Common Lisp предлагает необычайно богатый набор полезных инструментов, "
"включая более 700 встроенных функций (ANSI Common Lisp имеет более 900).\n"
"Таким образом, написание новой программы предполагает больше сбора "
"существующих фрагментов кода и меньше написания нового кода с нуля.\n"
"Помимо стандартных функций, реализации Common Lisp обычно предоставляют "
"расширения для взаимодействия с редактором, отладчиком и оконной системой."

#: in/chapter1.md:1062
msgid ""
"*   *Extensibility*.\n"
"When Lisp was invented in 1958, nobody could have foreseen the advances in "
"programming theory and language design that have taken place in the last "
"thirty years.\n"
"Other early languages have been discarded, replaced by ones based on newer "
"ideas.\n"
"However, Lisp has been able to survive, because it has been able to adapt.\n"
"Because Lisp is extensible, it has been changed to incorporate the newest "
"features as they become popular.\n"
"The easiest way to extend the language is with macros.\n"
"When so-called structured programming constructs such as *case* and *if-then-"
"else* arose, they were incorporated into Lisp as macros.\n"
"But the flexibility of Lisp goes beyond adding individual constructs.\n"
"Brand new styles of programming can easily be implemented.\n"
"Many AI applications are based on the idea of *rule-based* programming.\n"
"<a id=\"tfn01-8\"></a>\n"
"Another new style is *object-oriented* programming, which has been "
"incorporated with the Common Lisp Object System (CLOS),[8](#fn01-8) a set of "
"macros, functions, and data types that have been integrated into ANSI Common "
"Lisp."
msgstr ""
"*   *Расширяемость*.\n"
"Когда Lisp был изобретен в 1958 году, никто не мог предвидеть те успехи в "
"теории программирования и разработке языков, которые произошли за последние "
"тридцать лет.\n"
"Другие ранние языки были отброшены, заменены теми, которые основаны на более "
"новых идеях.\n"
"Тем не менее, Лисп смог выжить, потому что он смог адаптироваться.\n"
"Поскольку Lisp является расширяемым, он был изменен, чтобы включить новейшие "
"функции по мере того, как они становятся популярными.\n"
"Самый простой способ расширить язык-это использовать макросы.\n"
"Когда возникли так называемые конструкции структурированного "
"программирования, такие как *case* и *if-then-else*, они были включены в "
"Lisp как макросы.\n"
"Но гибкость Lisp выходит за рамки добавления отдельных конструкций.\n"
"Совершенно новые стили программирования могут быть легко реализованы.\n"
"Многие приложения искусственного интеллекта основаны на идее "
"программирования, основанного на правилах.\n"
"<a id=\"tfn01-8\"></a>\n"
"Еще одним новым стилем является объектно-ориентированное программирование, "
"которое было включено в объектную систему Common Lisp (CLOS) [8](#fn01-8) - "
"набор макросов, функций и типов данных, интегрированных в ANSI Common Lisp."

#: in/chapter1.md:1064
msgid ""
"To show how far Lisp has come, here's the only sample program given in the "
"*Lisp/MTS Programmer's Guide* (Hafner and Wilcox 1974):"
msgstr ""
"Чтобы показать, как далеко продвинулся Lisp, вот единственный пример "
"программы, приведенный в *Руководстве программиста Lisp/MTS* (Hafner и "
"Wilcox 1974):"

#: in/chapter1.md:1083
msgid ""
"```lisp\n"
"(PROG (LIST DEPTH TEMP RESTLIST)\n"
"(SETQ RESTLIST (LIST (CONS (READ) O)))\n"
"A (COND\n"
"((NOT RESTLIST) (RETURN 'DONE))\n"
"(T (SETQ LIST (UNCONS (UNCONS RESTLIST\n"
"     RESTLIST) DEPTH))\n"
"(COND ((ATOM LIST)\n"
"(MAPC 'PRIN1 (LIST '\"ATOM:\" LIST '\",\" 'DEPTH DEPTH))\n"
"(TERPRI))\n"
"(T (SETQ TEMP (UNCONS LIST LIST))\n"
"(COND (LIST\n"
"(SETQ RESTLIST (CONS(CONS LIST DEPTH) RESTLIST))))\n"
"(SETQ RESTLIST (CONS (CONS TEMP\n"
"     (ADD1 DEPTH)) RESTLIST))\n"
"))))\n"
"))))(GO A))\n"
"```"
msgstr ""

#: in/chapter1.md:1086
msgid ""
"Note the use of the now-deprecated goto `(GO)` statement, and the lack of "
"consistent indentation conventions.\n"
"The manual also gives a recursive version of the same program:"
msgstr ""
"Обратите внимание на использование теперь устаревшего оператора goto `(GO)` "
"и отсутствие последовательных соглашений об отступах.\n"
"В руководстве также приводится рекурсивная версия той же программы:"

#: in/chapter1.md:1103
msgid ""
"```lisp\n"
"(PROG NIL (\n"
"(LABEL ATOMPRINT (LAMBDA (RESTLIST)\n"
"(COND ((NOT RESTLIST) (RETURN 'DONE))\n"
"((ATOM (CAAR RESTLIST)) (MAPC 'PRIN1\n"
"     (LIST '\"ATOM:\" (CAAR RESTLIST)\n"
"          '\",\" 'DEPTH (CDAR RESTLIST)))\n"
"(TERPRI)\n"
"(ATOMPRINT (CDR RESTLIST)))\n"
"( T (ATOMPRINT (GRAFT\n"
"(LIST (CONS (CAAAR RESTLIST) (ADD1 (CDAR RESTLIST))))\n"
"(AND (CDAAR RESTLIST) (LIST (CONS (CDAAR RESTLIST)\n"
"     (CDAR RESTLIST))))\n"
"           (CDR RESTLIST)))))))\n"
"(LIST (CONS (READ) 0))))\n"
"```"
msgstr ""

#: in/chapter1.md:1106
msgid ""
"Both versions are very difficult to read.\n"
"With our modern insight (and text editors that automatically indent), a much "
"simpler program is possible:"
msgstr ""
"Обе версии очень трудно читать.\n"
"С нашим современным пониманием (и текстовыми редакторами, которые "
"автоматически делают отступ), возможна гораздо более простая программа:"

#: in/chapter1.md:1115
msgid ""
"```lisp\n"
"(defun atomprint (exp &optional (depth 0))\n"
"  \"Print each atom in exp, along with its depth of nesting.\"\n"
"  (if (atom exp)\n"
"      (format t \"~&ATOM: ~a, DEPTH ~d\" exp depth)\n"
"      (dolist (element exp)\n"
"        (atomprint element (+ depth 1)))))\n"
"```"
msgstr ""

#: in/chapter1.md:1117
msgid "## 1.11 Exercises"
msgstr "## 1.11 упражнения"

#: in/chapter1.md:1119
msgid ""
"&#9635; **Exercise  1.1 [m]** Define a version of `last-name` that handles "
"\"Rex Morgan MD,\" \"Morton Downey, Jr.,\" and whatever other cases you can "
"think of."
msgstr ""
"&#9635; **Exercise  1.1 [m]** Определите версию `last-name`, которая "
"обрабатывает \"Rex Morgan MD,\" \"Morton Downey, Jr.,\" и любые другие "
"случаи, которые вы можете придумать."

#: in/chapter1.md:1122
msgid ""
"&#9635; **Exercise  1.2 [m]** Write a function to exponentiate, or raise a "
"number to an integer power.\n"
"For example: `(power 3 2)` = 3<sup>2</sup> = 9."
msgstr ""
"&#9635; **Exercise  1.2 [m]** Напишите функцию для возведения в степень или "
"возведения числа в целочисленную степень.\n"
"Например: `(power 3 2)` = 3<sup>2</sup> = 9."

#: in/chapter1.md:1126
msgid ""
"&#9635; **Exercise  1.3 [m]** Write a function that counts the number of "
"atoms in an expression.\n"
"For example: `(count-atoms '(a (b) c)) = 3`.\n"
"Notice that there is something of an ambiguity in this: should (`a nil c`) "
"count as three atoms, or as two, because it is equivalent to (`a () c`)?"
msgstr ""
"&#9635; **Exercise  1.3 [m]** Напишите функцию, которая подсчитывает "
"количество атомов в выражении.\n"
"Например: `(count-atoms '(a (b) c)) = 3`.\n"
"Заметьте, что в этом есть некоторая двусмысленность: следует ли (`a nil c`) "
"считать тремя атомами или двумя, потому что это эквивалентно (`a () c`)?"

#: in/chapter1.md:1129
msgid ""
"&#9635; **Exercise  1.4 [m]** Write a function that counts the number of "
"times an expression occurs anywhere within another expression.\n"
"Example: `(count-anywhere 'a '(a ((a) b) a)) => 3.`"
msgstr ""
"&#9635; **Exercise  1.4 [m]** Напишите функцию, которая подсчитывает "
"количество раз, когда выражение встречается в любом месте другого "
"выражения.\n"
"Пример: `(count-anywhere 'a '(a ((a) b) a)) => 3.`"

#: in/chapter1.md:1133
msgid ""
"&#9635; **Exercise  1.5 [m]** Write a function to compute the dot product of "
"two sequences of numbers, represented as lists.\n"
"The dot product is computed by multiplying corresponding elements and then "
"adding up the resulting products.\n"
"Example:"
msgstr ""
"&#9635; **Exercise  1.5 [m]** Напишите функцию для вычисления точечного "
"произведения двух последовательностей чисел, представленных в виде списков.\n"
"Точечное произведение вычисляется путем умножения соответствующих элементов "
"и последующего сложения полученных произведений.\n"
"Пример:"

#: in/chapter1.md:1137
msgid ""
"```lisp\n"
"(dot-product '(10 20) '(3 4)) = 10 x 3 + 20 x 4 = 110\n"
"```"
msgstr ""

#: in/chapter1.md:1139
msgid "## 1.12 Answers"
msgstr "## 1.12 ответы"

#: in/chapter1.md:1149
msgid ""
"### Answer 1.2\n"
"```lisp\n"
"(defun power (x n)\n"
"  \"Power raises x to the nth power.  N must be an integer >= 0.\n"
"   This executes in log n time, because of the check for even n.\"\n"
"  (cond ((= n 0) 1)\n"
"        ((evenp n) (expt (power x (/ n 2)) 2))\n"
"        (t (* x (power x (- n 1))))))\n"
"```"
msgstr ""

#: in/chapter1.md:1151
msgid "### Answer 1.3"
msgstr ""

#: in/chapter1.md:1159
msgid ""
"```lisp\n"
"(defun count-atoms (exp)\n"
"  \"Return the total number of non-nil atoms in the expression.\"\n"
"  (cond ((null exp) 0)\n"
"        ((atom exp) 1)\n"
"        (t (+ (count-atoms (first exp))\n"
"              (count-atoms (rest exp))))))"
msgstr ""

#: in/chapter1.md:1168
msgid ""
"(defun count-all-atoms (exp &optional (if-null 1))\n"
"  \"Return the total number of atoms in the expression,\n"
"  counting nil as an atom only in non-tail position.\"\n"
"  (cond ((null exp) if-null)\n"
"        ((atom exp) 1)\n"
"        (t (+ (count-all-atoms (first exp) 1)\n"
"              (count-all-atoms (rest exp) 0)))))\n"
"```"
msgstr ""

#: in/chapter1.md:1170
msgid "### Answer 1.4"
msgstr ""

#: in/chapter1.md:1179
msgid ""
"```lisp\n"
"(defun count-anywhere (item tree)\n"
"  \"Count the times item appears anywhere within tree.\"\n"
"  (cond ((eql item tree) 1)\n"
"        ((atom tree) 0)\n"
"        (t (+ (count-anywhere item (first tree))\n"
"              (count-anywhere item (rest tree))))))\n"
"```"
msgstr ""

#: in/chapter1.md:1182
msgid ""
"### Answer 1.5\n"
"Here are three versions:"
msgstr ""

#: in/chapter1.md:1191
msgid ""
"```lisp\n"
"(defun dot-product (a b)\n"
"  \"Compute the mathematical dot product of two vectors.\"\n"
"  (if (or (null a) (null b))\n"
"      0\n"
"      (+ (* (first a) (first b))\n"
"         (dot-product (rest a) (rest b)))))"
msgstr ""

#: in/chapter1.md:1198
msgid ""
"(defun dot-product (a b)\n"
"  \"Compute the mathematical dot product of two vectors.\"\n"
"  (let ((sum 0))\n"
"    (dotimes (i (length a))\n"
"      (incf sum (* (elt a i) (elt b i))))\n"
"    sum))"
msgstr ""

#: in/chapter1.md:1203
msgid ""
"(defun dot-product (a b)\n"
"  \"Compute the mathematical dot product of two vectors.\"\n"
"  (apply #'+ (mapcar #'* a b)))\n"
"```"
msgstr ""

#: in/chapter1.md:1205
msgid "----------------------"
msgstr ""

#: in/chapter1.md:1208
msgid ""
"<a id=\"fn01-1\"></a>\n"
"[1](#tfn01-1) This list of symbols is not a legal Lisp assignment statement, "
"but it is a Lisp data object."
msgstr ""
"<a id=\"fn01-1\"></a>\n"
"[1](#tfn01-1) Этот список символов не является законным оператором "
"присвоения Lisp, но это объект данных Lisp."

#: in/chapter1.md:1212
msgid ""
"<a id=\"fn01-2\"></a>\n"
"[2](#tfn01-2) The variable `*print-case*` controls how symbols will be "
"printed.\n"
"By default, the value of this variable is :`upcase`, but it can be changed "
"to :`downcase` or `:capitalize`."
msgstr ""
"<a id=\"fn01-2\"></a>\n"
"[2](#tfn01-2) Переменная `*print-case*` управляет тем, как будут печататься "
"символы.\n"
"По умолчанию значение этой переменной равно: `upcase`, но его можно изменить "
"на:`downcase` или `:capitalize`."

#: in/chapter1.md:1215
msgid ""
"<a id=\"fn01-3\"></a>\n"
"[3](#tfn01-3) Later we will see what happens when the second argument is not "
"a list."
msgstr ""
"<a id=\"fn01-3\"></a>\n"
"[3](#tfn01-3) Позже мы увидим, что происходит, когда второй аргумент не "
"является списком."

#: in/chapter1.md:1220
msgid ""
"<a id=\"fn01-4\"></a>\n"
"[4](#tfn01-4) In ANSI Common Lisp, `last` is defined to return a list of the "
"last *n* elements, where n defaults to 1.\n"
"Thus `(last p) = (last p 1) = (PUBLIC)`,and `(last p 2) = (Q PUBLIC)`.\n"
"This may make the definition of `last` seem less perverse."
msgstr ""
"<a id=\"fn01-4\"></a>\n"
"[4](#tfn01-4) В ANSI Common Lisp `last` определяется как возвращающий список "
"последних *n* элементов, где n по умолчанию равно 1.\n"
"Таким образом, `(last p) = (last p 1) = (PUBLIC)`,и `(last p 2) = (Q "
"PUBLIC)`..\n"
"Это может сделать определение `last` менее извращенным."

#: in/chapter1.md:1224
msgid ""
"<a id=\"fn01-5\"></a>\n"
"[5](#tfn01-5) Just as we can change the value of a variable, we can also "
"change the value of a function in Lisp.\n"
"It is not necessary to recompile everything when a change is made, as it "
"would be in other languages."
msgstr ""
"<a id=\"fn01-5\"></a>\n"
"[5](#tfn01-5) Точно так же, как мы можем изменить значение переменной, мы "
"можем также изменить значение функции в Lisp.\n"
"Нет необходимости перекомпилировать все, когда вносятся изменения, как это "
"было бы в других языках."

#: in/chapter1.md:1228
msgid ""
"<a id=\"fn01-6\"></a>\n"
"[6](#tfn01-6) For example, symbols that denote so-called *special* variables "
"usually begin and end in asterisks.\n"
"Also, note that I did not hesitate to use the symbol `won!` on page 11."
msgstr ""
"<a id=\"fn01-6\"></a>\n"
"[6](#tfn01-6) Например, символы, обозначающие так называемые "
"специальные(*special*) переменные, обычно начинаются и заканчиваются "
"звездочками.\n"
"Кроме того, обратите внимание, что я не колеблясь использовал символ `won!`- "
"на странице 11."

#: in/chapter1.md:1232
msgid ""
"<a id=\"fn01-7\"></a>\n"
"[7](#tfn01-7) Actually, there can be several symbol tables.\n"
"They are known as *packages* in Common Lisp."
msgstr ""
"<a id=\"fn01-7\"></a>\n"
"[7](#tfn01-7) На самом деле, может быть несколько таблиц символов.\n"
"Они известны как пакеты - *packages* в Common Lisp."

#: in/chapter1.md:1234
msgid ""
"<a id=\"fn01-8\"></a>\n"
"[8](#tfn01-8) Pronounced \"see-loss.\" An alternate pronunciation, \"klaus,"
"\" seems to be losing favor."
msgstr ""
"<a id=\"fn01-8\"></a>\n"
"[8](#tfn01-8) Произносится \"вижу-потерю/see-loss\".- Альтернативное "
"произношение, \"klaus,\" - кажется, теряет свою популярность."
