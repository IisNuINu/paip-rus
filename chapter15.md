# Глава 15
## Символическая математика с каноническими формами

> Меня всегда интересует все простое.

> -David Hockney

[Глава 8](B978008057115750008X.xhtml) началась с больших надежд: взять существующий сопоставитель с образцом, скопировать некоторые математические тождества из справочника и придумать пригодную для использования систему символьной алгебры.
Получившаяся система *была* применима для некоторых целей, и она показала, что техника преобразования на основе правил является мощной.
Однако проблемы [раздел 8.5](B978008057115750008X.xhtml#s0030) показывают, что не все можно сделать легко и эффективно в рамках инструментария сопоставления с образцом на основе правил.

Существуют важные математические преобразования, которые трудно выразить с помощью подхода, основанного на правилах.
Например, деление двух многочленов для получения частного и остатка - это задача, которую легче выразить в виде алгоритма или программы, чем правила или набора правил.

Кроме того, есть проблема с эффективностью.
Части входных выражений снова и снова упрощаются, и много времени уходит на интерпретацию неприменимых правил.
[Раздел 9.6](B9780080571157500091.xhtml#s0035) показал некоторые методы ускорения программы в 100 раз при вводе примерно дюжины символов, но для выражений с примерно сотней символов такого ускорения недостаточно.
Мы можем добиться большего, если спроектируем специализированное представление с нуля.

Программы серьезных алгебраических манипуляций обычно применяют понятие *канонического упрощения*. То есть выражения преобразуются в канонический внутренний формат, который может быть далек от формы ввода.
Затем ими манипулируют и переводят обратно во внешнюю форму для вывода.
Конечно, упрощатель, который у нас уже есть, в некоторой степени выполняет такой перевод.
Он внутренне переводит `(3 + x + -3 + y)` в `(+ x y)`, а затем выводит его как `(x + y)`.
Но *каноническое* представление должно обладать тем свойством, что любые два равных выражения имеют идентичные канонические формы.
В нашей системе выражение `(5 + y + x + -5)` преобразуется во внутреннюю форму `(+ y x)`, которая не идентична `(+ x y)`, даже если эти два выражения равны.
Таким образом, наша система не является канонической.
Большинство проблем предыдущего раздела проистекают из отсутствия канонической формы.

Соблюдение канонической формы накладывает серьезные ограничения на представление.
Например, *x2*- 1 и (*x* - 1) (*x* + 1) равны, поэтому они должны быть представлены одинаково.
Один из способов гарантировать это - перемножить все факторы и собрать аналогичные термины.
Итак, (*x*- 1)(*x* + 1) равно *x2* - *x* + *x* - 1, что упрощается до *x2* - 1 в любой канонической внутренней форме.
Этот подход отлично работает для *x2* - 1, но для такого выражения, как (*x* - 1) 1000, умножение всех факторов потребует много времени (и места).
Трудно найти каноническую форму, идеально подходящую для всех задач.
Лучшее, что мы можем сделать, это выбрать ту, которая хорошо подходит для проблем, с которыми мы, скорее всего, столкнемся.

## 15.1 Каноническая форма для многочленов(полиномов)

В этом разделе мы сконцентрируемся на канонической форме для *многочленов* С математической точки зрения, многочлен - это функция (от одной или нескольких переменных), которую можно вычислить, используя только сложение и умножение.
Мы будем говорить о *основной переменной многочлена(полинома), коэффициентах* и *степени*. В полиноме:

5xx3+bxx2+cxx+1

![si1_e](images/chapter15/si1_e.gif)

основная переменная *x*, степень равна 3 (наивысшая степень *x*), а коэффициенты равны 5, *b, c* и 1.
Мы можем определить входной формат для полиномов следующим образом:

1.  Любое число Лиспа является многочленом.
!!!(p) {:.numlist}

2.  Любой символ Лиспа является многочленом.
!!!(p) {:.numlist}

3.  Если *p* и *q* - многочлены, то (*p + q*) и (*p * q*) - тоже.
!!!(p) {:.numlist}

4.  Если *p* - многочлен, а *n* - положительное целое число, то (*p* ^ *n*) - многочлен.
!!!(p) {:.numlist}

Однако формат ввода нельзя использовать в качестве канонической формы, потому что он допускает как `(x + y)`, так и `(y + x)`, а также `4` и `(2 + 2)`.

Прежде чем рассматривать каноническую форму для многочленов, давайте посмотрим, почему многочлены были выбраны в качестве целевой области.
Во-первых, существенно возрастает объем программирования, необходимый для поддержки канонических форм для более широкого класса выражений.
Чтобы упростить задачу, мы устранили такие сложности, как функции log(логарифмические) и trig(тригонометрические).
Многочлены - хороший выбор, потому что они замкнуты относительно сложения и умножения: сумма или произведение любых двух многочленов является многочленом.
Если бы мы разрешили деление, результат не был бы замкнут, потому что частное двух многочленов не обязательно должно быть многочленом.
В качестве бонуса многочлены также замыкаются при дифференцировании и интегрировании, поэтому мы также можем включить эти операторы.

Во-вторых, для достаточно больших классов выражений становится не просто сложно, но и невозможно определить каноническую форму.
Это может показаться удивительным, и у нас нет места, чтобы объяснить, почему это так, но вот аргумент: подумайте, что бы произошло, если бы мы добавили достаточно функциональности, чтобы дублировать весь Лисп.
Тогда "преобразование в каноническую форму" будет таким же, как "запуск программы". Но элементарным результатом теории вычислимости является то, что в общем случае невозможно определить результат выполнения произвольной программы (это известно как проблема остановки).
Таким образом, неудивительно, что невозможно канонизировать сложные выражения.

Наша задача - преобразовать ранее определенный многочлен в некоторую каноническую форму. [1](#fn0015) Большая часть кода и некоторые комментарии к этому формату и процедурам для управления им были написаны Ричардом Фейтманом с некоторыми усовершенствованиями. пользователя Peter Klier.

Первое дизайнерское решение - предположить, что мы будем иметь дело в основном с *плотными* многочленами, а не с *разреженными*.
То есть мы ожидаем, что большинство многочленов будут похожи на *ax * 3 * + bx * 2 * + cx * + * d,* не на *ax * 100 * + bx * 50 + * c.* Для плотных многочленов мы можем сэкономить место, представив основную переменную (*x* в этих примерах) и отдельные коэффициенты (*a*, *b*, *c* и *d* в этих примерах) явно, но представляя экспоненты только неявно , по позиции.
Вместо списков будут использоваться векторы, чтобы сэкономить место и обеспечить быстрый доступ к любому элементу.
Таким образом, представление 5 * x * 3 + 10 * x * 2 + 20 * x + * 30 будет вектором:

```lisp
#(x 30 20 10 5)
```

Основная переменная *x* находится в 0-м элементе вектора, а коэффициент при *i* -й степени *x* находится в элементе *i* + 1 вектора.
Одиночная переменная представлена как вектор, первый коэффициент которого равен 1, а число представлено как само себя:

| []()              |                                        |
|-------------------|----------------------------------------|
| `#(x 30 20 10 5)` | represents 5*x*3 + 10*x*2 + 20*x* + 30 |
| `#(x 0 1)`        | represents *x*                         |
| `5`               | represents 5                           |

Тот факт, что число представлено самим собой, может вызвать путаницу.
Число 5, например, является многочленом согласно нашему математическому определению многочленов.
Но он представлен как 5, а не как вектор, поэтому `(typep 5 'polynomial)` будет ложным.
Слово "многочлен" используется неоднозначно для обозначения как математической концепции, так и типа Лисп, но из контекста должно быть ясно, что имеется в виду.

Глоссарий программы канонического упрощения приведен на [рисунок 15.1](#f0010).

| []()                                                        |
|-------------------------------------------------------------|
| ![f15-01](images/chapter15/f15-01.jpg)                      |
| Рисунок 15.1: Глоссарий программы символьной манипуляции |

*(ed: should be a markdown table)*

Функции, определяющие тип `polynomial`-полинома, следуют ниже.
Поскольку нас интересует эффективность, мы объявляем, что некоторые короткие функции компилируются inline-встроенно, используем конкретную функцию `svref` (simple-vector reference/ссылка на простой вектор), а не более общую aref, и предоставляем объявления для многочленов с использованием специальной формы the.
Более подробная информация по вопросам эффективности приведена в [Глава 9](B9780080571157500091.xhtml).

```lisp
(proclaim '(inline main-var degree coef
```

              `var= var> poly make-poly))`

```lisp
(deftype polynomial () 'simple-vector)
(defun main-var (p) (svref (the polynomial p) 0))
(defun coef (p i)  (svref (the polynomial p) (+ i 1)))
(defun degree (p)  (-(length (the polynomial p)) 2))
```

Нам пришлось принять еще одно дизайнерское решение при определении `coef`, функции для извлечения коэффициента из полинома.
Как указано выше, *i* -ый коэффициент многочлена находится в элементе вектора *i* + 1.
Если мы потребуем, чтобы вызывающий `coef` передал *i* + 1, чтобы получить *i*, мы могли бы сэкономить несколько операций сложения.
Дизайнерское решение заключалось в том, что это будет слишком запутанным и подверженным ошибкам.
Таким образом, coef ожидает передачи *i* и выполняет сложение самостоятельно.

В нашем формате мы будем настаивать на том, чтобы основные переменные были символами, а коэффициенты могли быть числами или другими многочленами.
"Производственная" версия программы может учитывать основные переменные, такие как `(sin x)`, а также другие сложности, такие как + и * с более чем двумя аргументами и нецелочисленными степенями.

Теперь мы можем извлекать информацию из многочлена, но нам также необходимо создавать и изменять многочлены.
Функция `poly` принимает переменную и некоторые коэффициенты и строит вектор, представляющий многочлен.
`make-poly` принимает переменную и степень и производит/создает многочлен со всеми нулевыми коэффициентами.

```lisp
(defun poly (x &rest coefs)
  "Make a polynomial with main variable x
  and coefficients in increasing order."
  (apply #'vector x coefs))

(defun make-poly (x degree)
  "Make the polynomial 0 + 0*x + 0*x^2 + ... 0*x^degree"
  (let ((p (make-array (+ degree 2) :initial-element 0)))
    (setf (main-var p) x)
    p))
```

Многочлен можно изменить, установив его основную переменную или любой из его коэффициентов, используя следующие формы `defsetf`.

```lisp
(defsetf main-var (p) (val)
  `(setf (svref (the polynomial ,p) 0) ,val))

(defsetf coef (p i) (val)
  `(setf (svref (the polynomial ,p) (+ ,i 1)) ,val))
```

Функция `poly` конструирует многочлены аналогично `list` или `vector`: с явным списком содержимого, `make-poly`, с другой стороны, похожа на `make-array`: она создает многочлен заданного размера.

Мы предоставляем методы `setf` для изменения основной переменной и коэффициентов.
Поскольку это первое использование `defsetf`, оно заслуживает некоторых пояснений.
Форма `defsetf` принимает имя функции (или макроса), список аргументов и второй список аргументов, который должен состоять из одного аргумента, значения, которое должно быть присвоено.
Тело формы - это выражение, в котором значение хранится в нужном месте.
Таким образом, `defsetf` для `main-var` говорит, что `(setf (main-varp) val)` эквивалентно `(setf (svref (the polynomial p) 0) val)`.
`defsetf` очень похож на `defmacro`, но на писателя `defsetf` ложится немного меньше бремени.
Вместо передачи `p` и `val` непосредственно методу `setf`, Common Lisp связывает локальные переменные с этими выражениями и передает эти переменные методу `setf`.
Таким образом, писателю не нужно беспокоиться об вычислении выражений в неправильном порядке или неправильном количестве раз.
Также возможно получить более точный контроль над всем процессом с помощью `define-setf-method`, как описано на [стр. 884](B978008057115750025X.xhtml#p884).

Функции `poly+poly, poly*poly и poly^n` выполняют сложение, умножение и возведение в степень многочленов соответственно.
Они определены с несколькими вспомогательными функциями.
`k*poly` умножает многочлен на константу,`k`, которая может быть числом или другим многочленом, не содержащим главной переменной многочлена `p`.
`poly*same` используется для умножения двух многочленов на одну и ту же главную переменную.
Кроме того, аналогичным целям служат функции `k+poly` и `poly+same`.
Имея это в виду, вот функция для преобразования префикса в каноническую форму:

```lisp
(defun prefix->canon (x)
  "Convert a prefix Lisp expression to canonical form.
  Exs: (+ (^ x 2) (* 3 x)) => #(x 0 3 1)
       (- (* (- x 1) (+ x 1)) (- (^ x 2) 1)) => 0"
  (cond ((numberp x) x)
        ((symbolp x) (poly x 0 1))
        ((and (exp-p x) (get (exp-op x) 'prefix->canon))
         (apply (get (exp-op x) 'prefix->canon)
                (mapcar #'prefix->canon (exp-args x))))
        (t (error "Not a polynomial: ~a" x))))
```

Она управляется данными и основана на свойстве `prefix->canon` каждого оператора.
Далее мы устанавливаем соответствующие функции.
Существующие функции `poly*poly` и `poly^n` можно использовать напрямую.
Но другим операторам нужны интерфейсные функции.
Операторам + и - нужны интерфейсные функции, которые обрабатывают как унарные, так и бинарные(двойные) данные.

```lisp
(dolist (item '((+ poly+) (- poly-) (* poly*poly)
                (^ poly^n) (D deriv-poly)))
  (setf (get (first item) 'prefix->canon) (second item)))

(defun poly+ (&rest args)
  "Unary or binary polynomial addition."
  (ecase (length args)
    (1 (first args))
    (2 (poly+poly (first args) (second args)))))

(defun poly- (&rest args)
  "Unary or binary polynomial subtraction."
  (ecase (length args)
    (0 0)
    (1 (poly*poly -1 (first args)))
    (2 (poly+poly (first args) (poly*poly -1 (second args))))))
```

Функция `prefix->canon` принимает входные данные, которые не были частью нашего определения многочленов: унарные операторы положительного и отрицательного значений, а также бинарные операторы вычитания и дифференцирования.
Это допустимо, потому что все они могут быть сведены к элементарным операциям + и *.

Помните, что наши проблемы с канонической формой начались с неспособности решить, что проще: `(+ x y)` или `(+ y x)`.
В этой системе мы определяем каноническую форму, налагая порядок на переменные (мы используем алфавитный порядок, как определено `string>`).
Правило состоит в том, что полином `p` может иметь коэффициенты, которые являются полиномами от переменной, расположенной позже в алфавите, чем основная переменная `p`, но не коэффициенты, которые являются полиномами от переменных, предшествующих основной переменной `p`.
Вот как сравнивать переменные:

```lisp
(defun var= (x y) (eq x y))
(defun var> (x y) (string> x y))
```

Каноническая форма переменной `x` будет `#(x 0 1)`, что равно 0 x *x*0 + 1 x *x*1.
Каноническая форма `(+ x y)` это `#(x #(y 0 1) 1)`.
Она не может быть `#(y #(x 0 1) 1)`, потому что тогда полученный многочлен будет иметь коэффициент с меньшей основной переменной.
Политика упорядочивания переменных обеспечивает каноничность за счет правильного группирования одинаковых переменных вместе и наложения определенного порядка на выражения, которые в противном случае были бы коммутативными.

Итак, вот код для сложения двух многочленов:

```lisp
(defun poly+poly (p q)
  "Add two polynomials."
  (normalize-poly
    (cond
      ((numberp p)                      (k+poly p q))
      ((numberp q)                      (k+poly q p))
      ((var= (main-var p) (main-var q)) (poly+same p q))
      ((var> (main-var q) (main-var p)) (k+poly q p))
      (t                                (k+poly p q)))))

(defun k+poly (k p)
  "Add a constant k to a polynomial p."
  (cond ((eql k 0) p)                 ;; 0 + p = p
        ((and (numberp k) (numberp p))
         (+ k p))                     ;; Add numbers
        (t (let ((r (copy-poly p)))   ;; Add k to x^0 term of p
             (setf (coef r 0) (poly+poly (coef r 0) k))
             r))))

(defun poly+same (p q)
  "Add two polynomials with the same main variable."
  ;; First assure that q is the higher degree polynomial
  (if (> (degree p) (degree q))
      (poly+same q p)
      ;; Add each element of p into r (which is a copy of q).
      (let ((r (copy-poly q)))
        (loop for i from 0 to (degree p) do
              (setf (coef r i) (poly+poly (coef r i) (coef p i))))
        r)))

(defun copy-poly (p)
  "Make a copy a polynomial."
  (copy-seq p))
```

и код для умножения многочленов:

```lisp
(defun poly*poly (p q)
  "Multiply two polynomials."
  (normalize-poly
    (cond
      ((numberp p)                      (k*poly p q))
      ((numberp q)                      (k*poly q p))
      ((var= (main-var p) (main-var q)) (poly*same p q))
      ((var> (main-var q) (main-var p)) (k*poly q p))
      (t                                (k*poly p q)))))

(defun k*poly (k p)
  "Multiply a polynomial p by a constant factor k."
  (cond
    ((eql k 0)         0)       ;; 0 * p = 0
    ((eql k 1)         p)       ;; 1 * p = p
    ((and (numberp k)
          (numberp p)) (* k p)) ;; Multiply numbers
    (t ;; Multiply each coefficient
     (let ((r (make-poly (main-var p) (degree p))))
       ;; Accumulate result in r;  r[i] = k*p[i]
       (loop for i from 0 to (degree p) do
             (setf (coef r i) (poly*poly k (coef p i))))
       r))))
```

Сложная часть - это умножение двух многочленов на одну и ту же главную переменную.
Это делается путем создания нового полинома, `r`, степень которого является суммой двух входных полиномов `p` и `q`.
Первоначально все коэффициенты `r` равны нулю.
Дважды вложенный цикл умножает каждый коэффициент `p` и `q` и добавляет результат к соответствующему коэффициенту `r`.

```lisp
(defun poly*same (p q)
  "Multiply two polynomials with the same variable."
  ;; r[i] = p[0]*q[i] + p[1]*q[i-1] + ...
  (let* ((r-degree (+ (degree p) (degree q)))
         (r (make-poly (main-var p) r-degree)))
    (loop for i from 0 to (degree p) do
          (unless (eql (coef p i) 0)
            (loop for j from 0 to (degree q) do
                  (setf (coef r (+ i j))
                        (poly+poly (coef r (+ i j))
                                   (poly*poly (coef p i)
                                              (coef q j)))))))
    r))
```

И `poly+poly`, и `poly*poly` используют функцию `normalize-poly` для "нормализации" результата.
Идея состоит в том, что `(- (^ 5) (^ x 5))` должен возвращать 0, а не `#(x 0 0 0 0 0 0)`.
Обратите внимание, что `normalize-poly` - это деструктивная операция: она вызывает `delete`, что может фактически изменить ее аргумент.
Обычно это опасно, но поскольку `normalize-poly` заменяет что-то его концептуальным эквивалентом, никакого вреда не происходит.

```lisp
(defun normalize-poly (p)
  "Alter a polynomial by dropping trailing zeros."
  (if (numberp p)
      p
      (let ((p-degree (- (position 0 p :test (complement #'eql)
                                       :from-end t)
                         1)))
        (cond ((<= p-degree 0) (normalize-poly (coef p 0)))
              ((< p-degree (degree p))
               (delete 0 p :start p-degree))
              (t p)))))
```

Есть несколько незакрепленных концов, которые нужно исправить.
Во-первых, функция возведения в степень:

```lisp
(defun poly^n (p n)
```

  `"Raise polynomial p to the nth power, n>=0."`

  `(check-type n (integer 0 *))`

  `(cond ((= n 0) (assert (not (eql p 0))) 1)`

      `((integerp p) (expt p n))`

      `(t (poly*poly p (poly^n p (- n 1))))))`

## 15.2 Дифференцирование Многочленов

Процедура дифференцирования проста, в основном потому, что нужно иметь дело только с двумя операторами (+ и \ *):

```lisp
(defun deriv-poly (p x)
  "Return the derivative, dp/dx, of the polynomial p."
  ;; If p is a number or a polynomial with main-var > x,
  ;; then p is free of x, and the derivative is zero;
  ;; otherwise do real work.
  ;; But first, make sure X is a simple variable,
  ;; of the form #(X 0 1).
  (assert (and (typep x 'polynomial) (= (degree x) 1)
         (eql (coef x 0) 0) (eql (coef x 1) 1)))
  (cond
    ((numberp p) 0)
    ((var> (main-var p) (main-var x)) 0)
    ((var= (main-var p) (main-var x))
     ;; d(a + bx + cx^2 + dx^3)/dx = b + 2cx + 3dx^2
     ;; So, shift the sequence p over by 1, then
     ;; put x back in, and multiply by the exponents
     (let ((r (subseq p 1)))
       (setf (main-var r) (main-var x))
       (loop for i from 1 to (degree r) do
             (setf (coef r i) (poly*poly (+ i 1) (coef r i))))
       (normalize-poly r)))
    (t ;; Otherwise some coefficient may contain x.  Ex:
     ;; d(z + 3x + 3zx^2 + z^2x^3)/dz
     ;; = 1 +  0 +  3x^2 +  2zx^3
     ;; So copy p, and differentiate the coefficients.
     (let ((r (copy-poly p)))
       (loop for i from 0 to (degree p) do
             (setf (coef r i) (deriv-poly (coef r i) x)))
       (normalize-poly r)))))
```

**Упражнение 15.1 [h]** Интегрировать многочлены не намного сложнее, чем их дифференцировать.
Например:

&int;ax2+bxdx=ax33+bx22+c.

![si2_e](images/chapter15/si2_e.gif)

Напишите функцию для интеграции многочленов и установите ее в `prefix->canon`.

**Упражнение 15.2 [m]** Добавьте поддержку *определенных* интегралов, таких как &int;abydx !!!(span) {:.hiddenClass} ![si3_e](images/chapter15/si3_e.gif).
Вам нужно будет составить подходящую нотацию и правильно установить ее как в `infix->prefix`, так и в `prefix->canon`.
Полная реализация этой функции должна рассматривать бесконечность как границу, а также проблему интегрирования по сингулярностям.
Вам не нужно заниматься этими проблемами.

## 15.3 Преобразование между инфиксом и префиксом

Остается только преобразовать каноническую форму обратно в префиксную, а оттуда обратно в инфиксную.
Это хороший момент для расширения формы префикса, чтобы можно было использовать выражения с более чем двумя аргументами.
Сначала мы показываем обновленную версию `prefix->infix`, которая обрабатывает несколько аргументов:

```lisp
(defun prefix->infix (exp)
  "Translate prefix to infix expressions.
  Handles operators with any number of args."
  (if (atom exp)
      exp
      (intersperse
        (exp-op exp)
        (mapcar #'prefix->infix (exp-args exp)))))

(defun intersperse (op args)
  "Place op between each element of args.
  Ex: (intersperse '+ '(a b c)) => '(a + b + c)"
  (if (length=1 args)
      (first args)
      (rest (loop for arg in args
               collect op
               collect arg))))
```

Теперь нам нужно только преобразовать из канонической формы в префикс:

```lisp
(defun canon->prefix (p)
  "Convert a canonical polynomial to a lisp expression."
  (if (numberp p)
      p
      (args->prefix
        '+ 0
        (loop for i from (degree p) downto 0
              collect (args->prefix
                        '* 1
                        (list (canon->prefix (coef p i))
                              (exponent->prefix
                                (main-var p) i)))))))

(defun exponent->prefix (base exponent)
  "Convert canonical base^exponent to prefix form."
  (case exponent
    (0 1)
    (1 base)
    (t `(^ ,base ,exponent))))

(defun args->prefix (op identity args)
  "Convert arg1 op arg2 op ... to prefix form."
  (let ((useful-args (remove identity args)))
    (cond ((null useful-args) identity)
          ((and (eq op '*) (member 0 args)) 0)
          ((length=1 args) (first useful-args))
          (t (cons op (mappend
                        #'(lambda (exp)
                            (if (starts-with exp op)
                                (exp-args exp)
                                (list exp)))
                        useful-args))))))
```

Наконец, вот верхний уровень, чтобы все это использовать:

```lisp
(defun canon (infix-exp)
  "Canonicalize argument and convert it back to infix"
  (prefix->infix (canon->prefix (prefix->canon (infix->prefix infix-exp)))))

(defun canon-simplifier ()
  "Read an expression, canonicalize it, and print the result."
  (loop
    (print 'canon>)
    (print (canon (read)))))
```

и пример его использования:

```lisp
> (canon-simplifier)
CANON> (3 + x + 4 - x)
7
CANON> (x + y + y + x)
((2 * X) + (2 * Y))
CANON> (3 * x + 4 * x)
(7 * X)
CANON> (3 * x + y + x + 4 * x)
((8 * X) + Y)
CANON> (3 * x + y + z + x + 4 * x)
((8 * X) + (Y + Z))
CANON> ((x + 1) ^ 10)
((X ^ 10) + (10 * (X ^ 9)) + (45 * (X ^ 8)) + (120 * (X ^ 7))
```

  `+ (210 * (X ^ 6)) + (252 * (X ^ 5)) + (210 * (X ^ 4))`

  `+ (120 * (X ^ 3)) + (45 * (X ^ 2)) + (10 * X) + 1)`

```lisp
CANON> ((x + 1) ^ 10 + (x - 1) ^ 10)
((2 * (X ^ 10)) + (90 * (X ^ 8)) + (420 * (X ^ 6))
```

  `+ (420 * (X ^ 4)) + (90 * (X ^ 2)) + 2)`

```lisp
CANON> ((x + 1) ^ 10 - (x - 1) ^ 10)
((20 * (X ^ 8)) + (240 * (X ^ 7)) + (504 * (X ^ 5))
```

  `+ (240 * (X ^ 3)) + (20 * X))`

```lisp
CANON> (3 * x ^ 3 + 4 * x * y * (x - 1) + x ^ 2 * (x + y))
((4 * (X ^ 3)) + ((5 * Y) * (X ^ 2)) + ((-4 * Y) * X))
CANON> (3 * x ^ 3 + 4 * x * w * (x - 1) + x ^ 2 * (x + w))
((((5 * (X ^ 2)) + (-4 * X)) * W) + (4 * (X ^ 3)))
CANON> (d (3 * x ^ 2 + 2 * x + 1) / d x)
((6 * X) + 2)
CANON> (d(z + 3 * x + 3 * z * x ^ 2 + z ^ 2 * x ^ 3) / d z)
(((2 * Z) * (X ^ 3)) + (3 * (X ^ 2)) + 1)
CANON> [Abort]
```

## 15.4 Сравнительный анализ упрощения многочленов/полиномов

В отличие от программы, основанной на правилах, эта версия дает правильные ответы на все вопросы.
Программа не только правильная (по крайней мере, в этих примерах), она еще и быстрая.
Мы можем сравнить его с каноническим упрощением, первоначально написанным для MACSYMA Уильямом Мартином (около 1968 г.) и модифицированным Ричардом Фейтманом.
Модифицированная версия была использована Ричардом Габриэлем в его наборе тестов Common Lisp (1985).
Программа тестирования называется `frpoly`, потому что она имеет дело с полиномами и изначально была написана на диалекте Franz Lisp.
Тест `frpoly` кодирует многочлены в виде списков, а не векторов, и делает все возможное, чтобы быть эффективной.
В остальном она похожа на используемые здесь алгоритмы (хотя сам код совершенно другой, в нем используются progs и gos и другие функциональности, которые пришли в немилость за прошедшие десятилетия).
Конкретный тест, который мы будем использовать здесь, возводит 1 ***+** x + y + z* в 15-ю степень:

```lisp
(defun r15-test ()
```

  `(let ((r (prefix->canon'(+ 1 (+ x (+ y z))))))`

    `(time (poly^n r 15))`

    `nil))`

В нашей системе это занимает 0,97 секунды.
Эквивалентный тест с исходным кодом `frpoly` занимает примерно такое же время: 0,98 секунды.
Таким образом, наша программа работает так же быстро, как и код производственного качества.
Что касается места для хранения, векторы используют примерно половину памяти, чем списки, потому что половина каждой cons-ячейки является указателем, а все векторы - это полезные данные. [2](#fn0020)

Насколько быстрее код на основе полиномов, чем версия на основе правил?
К сожалению, мы не можем ответить на этот вопрос напрямую.
Мы можем время `(simp ' ( (1 + x + y + z) ^ 15)))`.
Это занимает всего десятую долю секунды, но это потому, что он не выполняет никакой работы - ответ такой же, как и ввод!
В качестве альтернативы, мы можем взять выражение, вычисленное с помощью `(poly^n r 15)`, преобразовать его в префикс и передать это `для упрощения.
Упрощение занимает 27,8 секунды, поэтому версия на основе правил работает намного медленнее.
[Раздел 9.6](B9780080571157500091.xhtml#s0035) описывает способы ускорения программы, основанной на правилах, а сравнение данных времени появляется на [страница 525](#p525).

Когда дело доходит до измерения временных данных, всегда есть сюрпризы.
Например, читатель предупреждений мог заметить, что версия `poly^n`, определенная выше, требует умножений на *n*.
Обычно возведение в степень выполняется возведением в квадрат значения, когда показатель степени четный.
Такой алгоритм использует только log *n* умножений вместо *n.* Мы можем добавить строку к определению `poly^n`, чтобы получить алгоритм *O*(log *n*):

```lisp
(defun poly^n (p n)
```

  `"Raise polynomial p to the nth power, n>=0."`

  `(check-type n (integer 0 *))`

  `(cond ((= n 0) (assert (not (eql p 0))) 1)`

      `((integerp p) (expt p n))`

      `((evenp n) (poly^2 (poly^n p (/ n 2)))) ;***`

      `(t (poly*poly p (poly^n p (- n 1))))))`

```lisp
(defun poly^2 (p) (poly*poly p p))
```

Сюрприз в том, что возведение `*r*` в 15-ю степень занимает *больше* времени.
Несмотря на то, что он выполняет меньше операций `poly*poly`, он выполняет их с более сложными аргументами, и в целом работы требуется больше.
Если мы используем эту версию `poly^n`, то `r15-test` занимает 1,6 секунды вместо 0,98 секунды. 

Кстати, это прекрасный пример концептуальной мощи рекурсивных функций.
Мы взяли существующую функцию poly^n, добавили одно предложение cond и изменили алгоритм с *O*(*n*) на *O*(log *n*).
(Это оказалось плохой идеей, но это не относится к делу.
Было бы неплохо возводить целые числа в степени.) Рассуждения, позволяющие сделать это изменение, просты: во-первых, * pn * определенно равно (*p**n*/2)2, когда *n* четно, поэтому изменение не может привести к неправильным ответам.
Во-вторых, изменение продолжает политику уменьшения *n* при каждом рекурсивном вызове, поэтому функция должна в конечном итоге завершиться (когда *n =* 0).
Если она не дает неправильных ответов и завершается, значит, она должна дать правильный ответ.

Напротив, внести изменения в итерационный алгоритм более сложно.
Первоначальный алгоритм прост:

```lisp
(defun poly^n (p n)
```

  `(let ((result 1))`

    `(loop repeat n do (setf result (poly*poly p result)))`

    `result))`

Но чтобы изменить его, мы должны изменить цикл повторения на цикл `while`, явно указать декремент *n* и вставить тест для четного случая: 

```lisp
(defun poly^n (p n)
```

  `(let ((result 1))`

    `(loop while (> n 0)`

      `do (if (evenp n)`

          `(setf p (poly^2 p)`

              `n (/ n 2))`

          `(setf result (poly*poly p result)`

              `n (- n 1))))`

    `result))`

Для этой проблемы ясно, что рекурсивное мышление приводит к более простой функции, которую легче изменить. 

Оказывается, это не последнее слово.
Возведение в степень многочленов может быть выполнено еще быстрее, с немного большей математической сложностью.
[Ричард Фейтман, 1974](B9780080571157500285.xhtml#bb0380) статья о полиномиальном умножении анализирует сложность множества алгоритмов возведения в степень.
Вместо обычного асимптотического анализа (например,
*O*(*n*) or *O*(*n*2)), он использует детальный анализ, который вычисляет постоянные коэффициенты (например,
1000 x *n* or 2 x *n*2).
Такой анализ важен для малых значений *n*.
Оказывается, что для множества многочленов лучше всего подходит алгоритм возведения в степень, основанный на биномиальной теореме.
Биномиальная теорема утверждает, что

a+bn=&Sigma;i=0nn!i!n-i!aibn-i

![si4_e](images/chapter15/si4_e.gif)

например,

a+b3=b3+3ab2+3a2b+a3

![si5_e](images/chapter15/si5_e.gif)

Мы можем использовать эту теорему, чтобы вычислить степень многочлена сразу, вместо того, чтобы вычислять ее многократным умножением или возведением в квадрат.
Конечно, многочлен, как правило, представляет собой сумму более чем двух компонентов, поэтому мы должны решить, как разбить его на части *a* и *b*.
Есть два очевидных способа: либо разделить многочлен пополам, чтобы *a* и *b* были одинакового размера, либо разделить по одному компоненту за раз.
Фейтман показывает, что последний метод в большинстве случаев более эффективен.
Другими словами, полином k1xn+k2xn-1+k3xn-2+... !!!(span) {:.hiddenClass} ![si6_e](images/chapter15/si6_e.gif) будет рассматриваться как сумма   *a*=  *k*1*xn* и *b* - остальная часть многочлена.

Ниже приведен код для биномиального возведения в степень.
Он несколько беспорядочен, потому что упор делается на эффективность.
Это означает повторное использование некоторых данных и использование `p-add-into!` Вместо более общего `poly+poly`.

```lisp
(defun poly^n (p n)
  "Raise polynomial p to the nth power, n>=0."
  ;; Uses the binomial theorem
  (check-type n (integer 0 *))
  (cond
    ((= n 0) 1)
    ((integerp p) (expt p n))
    (t ;; First: split the polynomial p = a + b, where
     ;; a = k*x^d and b is the rest of p
     (let ((a (make-poly (main-var p) (degree p)))
           (b (normalize-poly (subseq p 0 (- (length p) 1))))
           ;; Allocate arrays of powers of a and b:
           (a^n (make-array (+ n 1)))
           (b^n (make-array (+ n 1)))
           ;; Initialize the result:
           (result (make-poly (main-var p) (* (degree p) n))))
       (setf (coef a (degree p)) (coef p (degree p)))
       ;; Second: Compute powers of a^i and b^i for i up to n
       (setf (aref a^n 0) 1)
       (setf (aref b^n 0) 1)
       (loop for i from 1 to n do
             (setf (aref a^n i) (poly*poly a (aref a^n (- i 1))))
             (setf (aref b^n i) (poly*poly b (aref b^n (- i 1)))))
       ;; Third: add the products into the result,
       ;; so that result[i] = (n choose i) * a^i * b^(n-i)
       (let ((c 1)) ;; c helps compute (n choose i) incrementally
         (loop for i from 0 to n do
               (p-add-into! result c
                            (poly*poly (aref a^n i)
                                 (aref b^n (- n i))))
               (setf c (/ (* c (- n i)) (+ i 1)))))
       (normalize-poly result)))))

(defun p-add-into! (result c p)
  "Destructively add c*p into result."
  (if (or (numberp p)
          (not (var= (main-var p) (main-var result))))
      (setf (coef result 0)
            (poly+poly (coef result 0) (poly*poly c p)))
      (loop for i from 0 to (degree p) do
            (setf (coef result i)
                  (poly+poly (coef result i) (poly*poly c (coef p i))))))
  result)
```

Использование этой версии `poly^n, r15-test` занимает всего 0,23 секунды, что в четыре раза быстрее, чем в предыдущей версии.
В следующей таблице сравнивается время для `r15-test` с тремя версиями `poly^n`, а также время для применения `simply` к полиному `r15` для различных версий `simplify`:

|      | program                 | secs | speed-up |
|------|-------------------------|------|----------|
|      | **rule-based versions** |      |          |
| 1    | original                | 27.8 | -        |
| 2    | memoization             | 7.7  | 4        |
| 3    | memo+index              | 4.0  | 7        |
| 4    | compilation only        | 2.5  | 11       |
| 5    | memo+compilation        | 1.9  | 15       |
|      | **canonical versions**  |      |          |
| 6    | squaring `poly^n`       | 1.6  | 17       |
| 7    | iterative `poly^n`      | .98  | 28       |
| 8    | binomial `poly^n`       | .23  | 120      |

Как мы уже отмечали ранее, общие методы (memoization)запоминания, индексации и компиляции значительно ускоряют работу.
Однако в конечном итоге они не приводят к самой быстрой программе.
Вместо этого самая быстрая версия была достигнута за счет отказа от исходной программы, основанной на правилах, замены ее программой, основанной на канонической форме, и тонкой настройки алгоритмов в этой программе с использованием математического анализа.

Теперь, когда мы создали достаточно быструю систему, в следующих двух разделах мы сосредоточимся на том, чтобы сделать ее более мощной.

## 15.5 Каноническая форма рациональных выражений

*Рациональное* число определяется как дробь: частное двух целых чисел.
*Рациональное выражение* определяется как отношение двух многочленов.
В этом разделе представлена каноническая форма рациональных выражений.

Во-первых, число или многочлен будет по-прежнему представляться, как и раньше.
Частное двух многочленов(полиномов) будет представлено как cons-ячейки пар - числитель и знаменатель.
Однако так же, как Lisp автоматически приводит рациональные числа к простейшей форме (6/8 представлено как 3/4), мы должны сокращать рациональные выражения.
Так, например, (*x*2- 1)/(*x*- 1) нужно сократить до *x* + 1, а не оставить как частное двух многочленов.

Следующие функции создают рациональные выражения и обращаются к ним, но не сводятся к простейшей форме, за исключением случая, когда знаменателем является число.
Создание остальной функциональности для полноценного рационального выражения остается за серией упражнений:

```lisp
(defun make-rat (numerator denominator)
  "Build a rational: a quotient of two polynomials."
  (if (numberp denominator)
      (k*poly (/ 1 denominator) numerator)
      (cons numerator denominator)))

(defun rat-numerator (rat)
  "The numerator of a rational expression."
  (typecase rat
    (cons (car rat))
    (number (numerator rat))
    (t rat)))

(defun rat-denominator (rat)
  "The denominator of a rational expression."
  (typecase rat
    (cons (cdr rat))
    (number (denominator rat))
    (t 1)))
```

**Упражнение 15.3 [s ** Измените `prefix-> canon`, чтобы принимать входные данные в форме `x / y` и возвращать рациональные выражения вместо многочленов.
Также разрешите ввод формы `x ^ - n`.

**Exercise 15.4 [m]** Добавьте арифметические процедуры для умножения, сложения и деления рациональных выражений.
Назовите их `rat*rat, rat+rat`, и `rat/rat` соответственно.
Они будут вызывать `poly*poly.
poly+poly` и новую функцию `poly/poly`, которая определена в следующем упражнении.

**Упражнение 15.5 [h]** Определите `poly-gcd`, которая вычисляет наибольший общий делитель двух многочленов.

**Упражнение 15.6 [h]** Используя `poly-gcd`, определите функцию `poly/poly`, которая будет реализовывать деление для многочленов.
Многочлены замкныты для сложения и умножения, поэтому обе возвращают многочлены `poly+poly` и `poly*poly`.
Многочлены не замкнуты для деления, поэтому `poly/poly` вернет рациональное выражение.

## 15.6 Расширение рациональных выражений

Теперь, когда мы можем делить многочлены, последний шаг - восстановить логарифмическую, экспоненциальную и тригонометрическую функции.
Проблема в том, что если мы разрешим все эти функции, мы снова столкнемся с проблемами канонической формы.
Например, следующие три выражения эквивалентны:

sinxcosx-&pi;2eix-e-ix2i

![si7_e](images/chapter15/si7_e.gif)

Если нас интересует каноническая форма, безопаснее всего разрешить только *e**x*** и log(*x*).
Все остальные функции могут быть определены в терминах этих двух.
С помощью этого расширения набор выражений, которые мы можем формировать замыкание при дифференцировании, и можно канонизировать выражения.
`result` - это математически обоснованная конструкция, известная как *дифференцируемое поле.* Это именно та конструкция, которую предполагает алгоритм интегрирования Риша ([Risch 1969](B9780080571157500285.xhtml#bb0985), [1979](B9780080571157500285.xhtml)#bb0990)).

Недостатком этого минимального расширения является то, что ответы могут быть выражены незнакомыми терминами.
Пользователь спрашивает *d* sin(*x2*)*/dx,* ожидая простого ответа в терминах cos, и с удивлением видит сложный ответ, включающий *eix*.
Из-за этой проблемы большинство систем компьютерной алгебры сделали более радикальные расширения, допустив sin, cos и другие функции.
Эти системы ступают по тонкому математическому льду.
Алгоритмы, которые гарантированно работают с простым дифференцируемым полем, могут дать сбой при таком расширении области.
В общем, результатом будет не неправильный ответ, а скорее невозможность найти ответ вообще.

## 15.7 История и ссылки

A brief history of symbolic algebra systems is given in [chapter 8](B978008057115750008X.xhtml).
[Fateman (1979)](B9780080571157500285.xhtml#bb0385), [Martin and Fateman (1971)](B9780080571157500285.xhtml#bb0775), and [Davenport et al.
(1988)](B9780080571157500285.xhtml#bb0270) give more details on the MACSYMA system, on which this chapter is loosely based.
[Fateman (1991)](B9780080571157500285.xhtml#bb0390) discusses the `frpoly` benchmark and introduces the vector implementation used in this chapter.

## 15.8 Exercises

**Exercise 15.7 [h]** Implement an extension of the rationals to include logarithmic, exponential, and trigonometrie functions.

**Exercise 15.8 [m]** Modify `deriv` to handle the extended rational expressions.

**Exercise 15.9 [d]** Adapt the integration routine from [section 8.6](B9780080571157500078.xhtml#s0035) ([page 252](B978008057115750008X.xhtml#p252)) to the rational expression representation.
[Davenport et al.
1988](B9780080571157500285.xhtml#bb0270) may be useful.

**Exercise 15.10 [s]** Give several reasons why constant polynomials, like 3, are represented as integers rather than as vectors.

## 15.9 Ответы

**Answer 15.4**

```lisp
(defun rat*rat (x y)
  "Multiply rationals: a/b * c/d = a*c/b*d"
  (poly/poly (poly*poly (rat-numerator x)
                        (rat-numerator y))
             (poly*poly (rat-denominator x)
                        (rat-denominator y))))

(defun rat+rat (x y)
  "Add rationals: a/b + c/d = (a*d + c*b)/b*d"
  ;; Bug fix by dst 4/6/92; b and c were switched
  (let ((a (rat-numerator x))
        (b (rat-denominator x))
        (c (rat-numerator y))
        (d (rat-denominator y)))
    (poly/poly (poly+poly (poly*poly a d) (poly*poly c b))
               (poly*poly b d))))

(defun rat/rat (x y)
  "Divide rationals: a/b / c/d = a*d/b*c"
  (rat*rat x (make-rat (rat-denominator y) (rat-numerator y))))
```

**Answer 15.6**

```lisp
(defun poly/poly (p q)
```

  `"Divide p by q: if d is the greatest common divisor of p and q`

  `then p/q = (p/d) / (q/d).
Note if q-1.
then p/q = p."`

  `(if (eql q 1)`

      `p`

      `(let ((d (poly-gcd p q)))`

        `(make-rat (poly/poly p d)`

                `(poly/poly q d)))))`

**Answer 15.10** (1) An integer takes less time and space to process.
(2) Representing numbers as a polynomial would cause an infinit`e` regress, because the coefficients would be numbers.
(3) Unless a policy was decided upon, the representation would not be canonical, since `#(x 3)` and `#(y 3)` both represent 3.

----------------------

[1](#xfn0015) In fact, the algebraic properties of polynomial arithmetic and its generalizations fit so well with ideas in data abstraction that an extended example (in Scheme) on this topic is provided in *Structure and Interpretation of Computer Programs* by Abelson and Sussman (see section 2.4.3, [pages 153](B9780080571157500054.xhtml#p153)-[166](B9780080571157500054.xhtml#p166)).
We'll pursue a slightly different approach here.
!!!(p) {:.ftnote1}

[2](#xfn0020) Note: systems that use `"`cdr-coding`"` take about the same space for lists that are allocated all at once as for vectors.
But cdr-coding is losing favor as RISC chips replace microcoded processors.
!!!(p) {:.ftnote1}