#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter25.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-03-18 11:23+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter25.md:3
msgid ""
"# Chapter 25\n"
"## Troubleshooting"
msgstr ""
"# Глава 25\n"
"## Решение Проблем"

#: in/chapter25.md:5
msgid ""
"> Perhaps if we wrote programs from childhood on, as adults we'd be able to "
"read them."
msgstr ""
"> Возможно, если бы мы писали программы с детства, врослыми бы, смогли их "
"читать."

#: in/chapter25.md:7
msgid "> -Alan Perlis"
msgstr ""

#: in/chapter25.md:9
msgid ""
"When you buy a new appliance such as a television, it comes with an "
"instruction booklet that lists troubleshooting hints in the following form:"
msgstr ""
"Когда вы покупаете новое устройство, такое как телевизор, к нему прилагается "
"буклет с инструкциями, в котором перечислены советы по устранению неполадок "
"в следующей форме:"

#: in/chapter25.md:11
msgid "**PROBLEM**: Nothing works."
msgstr "**Проблема**: ничего не работает."

#: in/chapter25.md:13
msgid "**Diagnosis**: Power is off."
msgstr "**Диагностика**: Питание отключено."

#: in/chapter25.md:15
msgid "**Remedy:** Plug in outlet and turn on power switch."
msgstr "**Устранение:** Подключите розетку и включите питание."

#: in/chapter25.md:18
msgid ""
"If your Lisp compiler came without such a handy instruction booklet, this "
"chapter may be of some help.\n"
"It lists some of the most common difficulties that Lisp programmers "
"encounter."
msgstr ""
"Если в вашем компиляторе Lisp не было такого удобного буклета с "
"инструкциями, эта глава может быть вам полезна.\n"
"В ней перечислены некоторые из наиболее распространенных трудностей, с "
"которыми сталкиваются программисты на Lisp."

#: in/chapter25.md:20
msgid "## 25.1 Nothing Happens"
msgstr "## 25.1 Ничего не происходит"

#: in/chapter25.md:22
msgid ""
"**PROBLEM:** You type an expression to Lisp's read-eval-print loop and get "
"no response-no result, no prompt."
msgstr ""
"**ПРОБЛЕМА:** Вы вводите выражение в цикл Lisp read-eval-print(REPL) и не "
"получаете ответа, ни результата, ни приглашения."

#: in/chapter25.md:25
msgid ""
"**Diagnosis:** There are two likely reasons why output wasn't printed: "
"either Lisp is still doing read or it is still doing `eval`.\n"
"These possibilities can be broken down further into four cases:"
msgstr ""
"**Diagnosis:** Есть две вероятные причины по которым вывод не был напечатан: "
"либо Lisp все еще выполняет read(чтение), либо он все еще выполняет `eval`.\n"
"Эти возможности можно разделить на четыре случая:"

#: in/chapter25.md:32
msgid ""
"**Diagnosis:** If the expression you type is incomplete, Lisp will wait for "
"more input to complete it.\n"
"An expression can be incomplete because you have left off a right "
"parenthesis (or inserted an extra left parenthesis).\n"
"Or you may have started a string, atom, or comment without finishing it.\n"
"This is particularly hard to spot when the error spans multiple lines.\n"
"A string begins and ends with double-quotes: `\"string\"`; an atom "
"containing unusual characters can be delimited by vertical bars: `| AN ATOM |"
"` ; and a comment can be of the form `# | a comment | #`.\n"
"Here are four incomplete expressions:"
msgstr ""
"**Диагностика:** Если вы ввели не полное выражение, Lisp будет ждать "
"дополнительных данных, чтобы завершить его.\n"
"Выражение может быть не полным, потому что вы непоставили правую скобку(или "
"вставили лишнюю левую скобку). Или вы могли начать строку, атом или "
"комментарий, не закончив их.\n"
"Это особенно сложно обнаружить когда, ошибка охватывает несколько строк.\n"
"Строка начинается и заканчивается двойными кавычками: `\"string\"`; atom "
"содержащий не обычные символьные знаки, может быть ограничен вертикльными "
"чертами: `| AN ATOM |` ; и  комментарий может иметь форму `# | a comment | "
"#`.\n"
"Вот четыре не полных выражения:"

#: in/chapter25.md:36
msgid ""
"```lisp\n"
"(+ (* 3 (sqrt 5) 1)\n"
"```"
msgstr ""

#: in/chapter25.md:39
msgid ""
"`(format t \"~&X=~a, Y=~a.\n"
"x y)`"
msgstr ""

#: in/chapter25.md:46
msgid ""
"```lisp\n"
"(get '|strange-atom 'prop)\n"
"(if (= x 0) #1 test if x is zero\n"
"        y\n"
"        x)\n"
"```"
msgstr ""

#: in/chapter25.md:49
msgid ""
"**Remedy:** Add a ), \", `|`, and `| #`, respectively.\n"
"Or hit the interrupt key and type the input again."
msgstr ""
"**Способ устранения:** Добавьте соответственно ), \", `|`, и `| #`.\n"
"Или нажмите клавишу прерывания и введите ввод еще раз."

#: in/chapter25.md:51
msgid "**Diagnosis:** Your program may be waiting for input."
msgstr "**Диагностика:** Возможно, ваша программа ожидает ввода."

#: in/chapter25.md:57
msgid ""
"**Remedy:** Never do a `(read)` without first printing a prompt of some "
"kind.\n"
"If the prompt does not end with a newline, a call to `finish-output` is also "
"in order.\n"
"In fact, it is a good idea to call a function that is at a higher level than "
"`read`.\n"
"Several systems define the function `prompt-and-read`.\n"
"Here is one version:"
msgstr ""
"**Устранение:** Никогда не выполняйте `(read)` без вывода какого-либо "
"приглашения.\n"
"Если приглашение не заканчивается новой строкой, вызов `finish-output` также "
"в порядке.\n"
"На самом деле, это хорошая идея вызвать функцию более высокого уровня, чем "
"`read`.\n"
"Несколько систем определяют функцию `prompt-and-read`.\n"
"Вот одна из версий:"

#: in/chapter25.md:65
msgid ""
"```lisp\n"
"(defun prompt-and-read (ctl-string &rest args)\n"
"  \"Print a prompt and read a reply.\"\n"
"  (apply #'format t ctl-string args)\n"
"  (finish-output)\n"
"  (read))\n"
"```"
msgstr ""

#: in/chapter25.md:67
msgid ""
"**Diagnosis:** The program may be caught in an infinite loop, either in an "
"explicit `loop` or in a recursive function."
msgstr ""
"**Диагностика:** программа может попасть в бесконечный цикл, либо в явном "
"цикле, либо в рекурсивной функции."

#: in/chapter25.md:70
msgid ""
"**Remedy:** Interrupt the computation, get a back trace, and see what "
"functions are active.\n"
"Check the base case and loop variant on active functions and loops."
msgstr ""
"**Устранение:** прервите вычисление, получив обратную трассировку и "
"посмотрите, какие функции активны. Проверьте базовый вариант и вариант цикла "
"для активных функций и циклов."

#: in/chapter25.md:72
msgid ""
"**Diagnosis:** Even a simple expression like (`mapc #'sqrt list`) or "
"(`length list`) will cause an infinite loop if `list` is an infinite list-"
"that is, a list that has some tail that points back to itself."
msgstr ""
"**Диагностика:** даже простое выражение вроде (`mapc #'sqrt list`) или "
"(`length list`) могут вызвать бесконечный цикл если список `list` являются "
"бесконенчым списком, то есть списком, имеющим хвост, указывающий на себя."

#: in/chapter25.md:74
msgid ""
"**Remedy:** Be very careful any time you modify a structure with `nconc`, "
"`delete`, `setf`, and so forth."
msgstr ""
"**Устранение:** будьте осторожны при изменении структуры с помощью `nconc`, "
"`delete`, `setf` и так далее."

#: in/chapter25.md:76
msgid ""
"**PROBLEM:** You get a new prompt from the read-eval-print loop, but no "
"output was printed."
msgstr ""
"**Проблема:** вы получили новое приглашение из цикла read-eval-print(REPL), "
"но вывод не был напечатан."

#: in/chapter25.md:78
msgid ""
"**Diagnosis:** The expression you evaluated must have returned no values at "
"all, that is, the result `(values)`."
msgstr ""
"**Диагноз:** вычисленное вами выражение не должно возвращать значения, то "
"есть результат  `(values)`."

#: in/chapter25.md:80
msgid "## 25.2 Change to Variable Has No Effect"
msgstr "## 25.2 Изменение переменной не имеет никакого эффекта"

#: in/chapter25.md:82
msgid "**PROBLEM:** You redefined a variable, but the new value was ignored."
msgstr ""
"**Проблема:** Вы переопределили переменную, но новое значение было "
"проигнорировано."

#: in/chapter25.md:84
msgid ""
"**Diagnosis:** Altering a variable by editing and re-evaluating a `defvar` "
"form will not change the variable's value, `defvar` only assigns an initial "
"value when the variable is unbound."
msgstr ""
"**Диагноз:** изменение переменной путем изменения и перевычисления формы "
"`defvar` не изменит значения переменной, `defvar` присваивает значение "
"только тогда, когда переменная не связана."

#: in/chapter25.md:86
msgid ""
"**Remedy:** Use setf to update the variable, or change the `defvar` to a "
"`defparameter`."
msgstr ""
"**Устранение:** Используйте setf для обновления переменной или измените "
"`defvar` на `defparameter`."

#: in/chapter25.md:89
msgid ""
"**Diagnosis:** Updating a locally bound variable will not affect a like-"
"named variable outside that binding.\n"
"For example, consider:"
msgstr ""
"**Диагноз:** обновление локально связанной переменной не влияет на "
"переменную с тем же именем вне этой привязки.\n"
"Наример, рассмотрим:"

#: in/chapter25.md:96
msgid ""
"```lisp\n"
"(defun check-ops (*ops*)\n"
"  (if (null *ops*)\n"
"          (setf *ops* *default-ops*))\n"
"  (mapcar #'check-op *ops*))\n"
"```"
msgstr ""

#: in/chapter25.md:98
msgid ""
"If `check - ops` is called with a null argument, the `*ops*` that is a "
"parameter of `check - ops` will be updated, but the global `*ops*` will not "
"be, even if it is declared special."
msgstr ""
"Если `check-ops` вызывается с нулевым(nil) аргументом, `*ops*` который "
"является параметром `check-ops` будет изменен, но глобальный `*ops*` изменен "
"не будет, даже если он объявлен специальным."

#: in/chapter25.md:105
msgid ""
"**Remedy:** Don't shadow variables you want to update.\n"
"Use a different name for the local variable.\n"
"It is important to distinguish special and local variables.\n"
"Stick to the naming convention for special variables: they should begin and "
"end with asterisks.\n"
"Don't forget to introduce a binding for all local variables.\n"
"The following excerpt from a recent textbook is an example of this error:"
msgstr ""
"**Устранение:** на затеняйте переменны, которые вы хотите обновлять.\n"
"Используйте другое имя для локальной переменной.\n"
"Важно различать специальные и локальные переменные.\n"
"Придерживайтесь соглашения об именах для специальных переменных: они должны "
"начинаться и заканчиваться звездочками.\n"
"Не забудьте ввести привязку для всех локальных переменных.\n"
"следующий отрывок из недавнего учебника является примером этой ошибки:"

#: in/chapter25.md:111
msgid ""
"```lisp\n"
"(defun test ()\n"
"  (setq x 'test-data)      :*Warning!*\n"
"  (solve-problem x))        :*Don't do this.*\n"
"```"
msgstr ""

#: in/chapter25.md:113
msgid "This function should have been written:"
msgstr "Эту функцию следовало написать так:"

#: in/chapter25.md:119
msgid ""
"```lisp\n"
"(defun test ()\n"
"  (let ((x 'test-data))      :*Do this instead.*\n"
"      (solve-problem x)))\n"
"```"
msgstr ""

#: in/chapter25.md:121
msgid "## 25.3 Change to Function Has No Effect"
msgstr "## 25.3 Изменение функции не имеет никакого эффекта"

#: in/chapter25.md:123
msgid "**PROBLEM:** You redefined a function, but the change was ignored."
msgstr ""
"**Проблема:** Вы переопределили функцию, но это изменение было "
"проигнорировано."

#: in/chapter25.md:126
msgid ""
"**Diagnosis:** When you change a macro, or a function that has been declared "
"inline, the change will not necessarily be seen by users of the changed "
"function.\n"
"(It depends on the implementation.)"
msgstr ""
"**Диагноз:** Когда вы меняете макрос или функцию, которая была объявлена "
"встроеной, это изменение не обязательно будет видно пользователям измененной "
"функции.\n"
"(Это зависит от реализации.)"

#: in/chapter25.md:130
msgid ""
"**Remedy:** Recompile after changing a macro.\n"
"Don't use inline functions until everything is debugged.\n"
"(`Use (declare (notinline f)`) to cancel an inline declaration)."
msgstr ""
"**Устранение:** перекомпилируйте после изменения макроса.\n"
"Не используйте встроенные функции, пока все не будет отлажено.\n"
"(`Используйте (declare (notinline f)`) чтобы отменить объявление "
"встраивания(inline))."

#: in/chapter25.md:133
msgid ""
"**Diagnosis:** If you change a normal (non-inline) function, that change "
"*will* be seen by code that refers to the function by *name*, but not by "
"code that refers to the old value of the function itself.\n"
"Consider:"
msgstr ""
"**Диагностика:** Если вы измените обычную(не встроенную) функцию, это "
"изменение будет видно кодом, который ссылается на функцию по  *имени*, но не "
"коду, который ссылается на старое значение функции.\n"
"Рассмотрим:"

#: in/chapter25.md:142
msgid ""
"```lisp\n"
"(defparameter *scorer* #'score-fn)\n"
"(defparameter *printer* 'print-fn)\n"
"(defun show (values)\n"
"  (funcall *printer*\n"
"      (funcall *scorer* values)\n"
"      (reduce #'better values)))\n"
"```"
msgstr ""

#: in/chapter25.md:150
msgid ""
"Now suppose that the definitions of `score - fn, print - fn`, and `better` "
"are all changed.\n"
"Does any of the prior code have to be recompiled?\n"
"The variable *`printer`* can stay as is.\n"
"When it is funcalled, the symbol `print-fn` will be consulted for the "
"current functional value.\n"
"Within show, the expression # ' `better` is compiled into code that will get "
"the current version of `better`, so it too is safe.\n"
"However, the variable *`scorer`* must be changed.\n"
"Its value is the old definition of `score-fn`."
msgstr ""
"Теперь предположим, что определения `score-fn, print-fn` и `better` были "
"изменены.\n"
"Нужно ли прекомпилировать како-либо предыдущий код?\n"
"Переменная *`printer`* может оставаться как есть.\n"
"При её вызове, будет использоваться символ `print-fn` для определения "
"текущего функционального значения.\n"
"Внутри show, выражение ``#'better`` компилируется в код, который получит "
"текущую версию `better`, так что это тоже безопасно.\n"
"Однако, небходимо изменить переменную *`scorer`*.\n"
"Её значение - это старое определение `score-fn`."

#: in/chapter25.md:156
msgid ""
"**Remedy:** Re-evaluate the definition of *`scorer`*.\n"
"It is unfortunate, but this problem encourages many programmers to use "
"symbols where they really mean functions.\n"
"Symbols will be coerced to the global function they name when passed to "
"`funcall`or `apply`, but this can be the source of another error.\n"
"In the following example, the symbol `local - fn` will not refer to the "
"locally bound function.\n"
"One needs to use `#'local - fn` to refer to it."
msgstr ""
"**Устранение:** Вычислить заново определение *`scorer`*.\n"
"К сожалению, эта проблема побуждает многих программистов использовать "
"символы там, где они на самом деле означают функции.\n"
"Символы будут принуждены к глобальной функции, которую они именуют, при "
"передаче в `funcall` или `apply`, но это может быть источником другой "
"ошибки.\n"
"В следующем примере, символ `local-fn` не будет ссылаться на локально "
"связанную функцию.\n"
"Для ссылки на неё нужно использовать `#'local-fn`."

#: in/chapter25.md:161
msgid ""
"```lisp\n"
"(flet ((local-fn (x) ...))\n"
"  (mapcar 'local-fn list))\n"
"```"
msgstr ""

#: in/chapter25.md:164
msgid ""
"**Diagnosis:** If you changed the name of a function, did you change the "
"name every-where?\n"
"For example, if you decide to change the name of `print-fn` to `print-"
"function` but forget to change the value of *`printer`*, then the old "
"function will be called."
msgstr ""
"**Диагностика:** Если вы меняли название функции, вы изменили название "
"везде?\n"
"Например, если вы решили изменить имя `print-fn` на `print-function`, но "
"забыли изменить значение *`printer`*, то будет вызвана старая функция."

#: in/chapter25.md:168
msgid ""
"**Remedy:** Use your editor's global replace command.\n"
"To be even safer, redefine obsolete functions to call `error`.\n"
"The following function is handy for this purpose:"
msgstr ""
"**Устранение:** Используйте команду глобальной замены в вашем редакторе.\n"
"Чтобы быть еще безопаснее, переопределите устаревшие функции на вызов "
"`error`.\n"
"Для этого пригодиться следующая функция:"

#: in/chapter25.md:177
msgid ""
"```lisp\n"
"(defun make-obsolete (fn-name)\n"
"  \"Print an error if an obsolete function is called.\"\n"
"  (setf (symbol-function fn-name)\n"
"        #'(lambda (&rest args)\n"
"              (declare (ignore args))\n"
"              (error \"Obsolete function.\"))))\n"
"```"
msgstr ""

#: in/chapter25.md:180
msgid ""
"**Diagnosis:** Are you using `labels` and `flet` properly?\n"
"Consider again the function `replace-?-vars`, which was defined in [section "
"11.3](B978008057115750011X.xhtml#s0025) to replace an anonymous logic "
"variable with a unique new variable."
msgstr ""
"**Диагностика:** Правильно ли вы используете `labels` и `flet`?\n"
"Снова рассмотрим функцию `replace-?-vars`, которая была определена в "
"[разделе 11.3](B978008057115750011X.xhtml#s0025) для замены анонимной "
"логической переменной на\n"
"уникальную новую переменную."

#: in/chapter25.md:189
msgid ""
"```lisp\n"
"(defun replace-?-vars (exp)\n"
"  \"Replace any ? within exp with a var of the form ?123.\"\n"
"  (cond ((eq exp '?) (gensym \"?\"))\n"
"      ((atom exp) exp)\n"
"      (t (cons (replace-?-vars (first exp))\n"
"          (replace-?-vars (rest exp))))))\n"
"```"
msgstr ""

#: in/chapter25.md:194
msgid ""
"It might occur to the reader that gensyming a different variable each time "
"is wasteful.\n"
"The variables must be unique in each clause, but they can be shared across "
"clauses.\n"
"So we could generate variables in the sequence `?1, ?2, ...`, intern them, "
"and thus reuse these variables in the next clause (provided we warn the user "
"never to use such variable names).\n"
"One way to do that is to introduce a local variable to hold the variable "
"number, and then a local function to do the computation:"
msgstr ""
"Читателю может прийти в голову, что каждый раз создавать новую переменную "
"расточительно.\n"
"Переменные должны быть уникальными в каждом предложении, но они могут "
"использоваться в разных предложениях.\n"
"Таким образом, мы могли бы генерироват последовательности `?1, ?2, ...`, "
"интернировать(intern) их и, таким образом, повторнго использовать эти "
"переменные в следующем предложении(при условии, что мы предупреждаем "
"пользователя никогда не использовать такие имена переменных).\n"
"Один из способов сделать это- ввести локальную переменную для хранения "
"номера переменной, а затем локальную функцию для выполнения вычислений:"

#: in/chapter25.md:203
msgid ""
"```lisp\n"
"(defun replace-?-vars (exp)\n"
"  \"Replace any ? within exp with a var of the form ?123.\"\n"
"  ;;*** Buggy Version ***\n"
"  (let ((n 0))\n"
"      (flet\n"
"        ((replace-?-vars (exp)\n"
"```"
msgstr ""

#: in/chapter25.md:206
msgctxt "in/chapter25.md:206"
msgid ""
"`          (cond ((eq exp '?) (symbol '?\n"
"(incf n)))`"
msgstr ""

#: in/chapter25.md:213
msgid ""
"```lisp\n"
"          ((atom exp) exp)\n"
"          (t (cons (replace-?-vars (first exp))\n"
"                  (replace-?-vars (rest exp)))))))\n"
"      (replace-?-vars exp))))\n"
"```"
msgstr ""

#: in/chapter25.md:218
msgid ""
"This version doesn't work.\n"
"The problem is that `flet`, like `let`, defines a new function within the "
"body of the `flet` but not within the new function's definition.\n"
"So two lessons are learned here: use `labels` instead of `flet` to define "
"recursive functions, and don't shadow a function definition with a local "
"definition of the same name (this second lesson holds for variables as "
"well).\n"
"Let's fix the problem by changing `labels` to `flet` and naming the local "
"function `recurse`:"
msgstr ""
"Эта версия не работает.\n"
"Проблема в том, что `flet`, как и `let`, определяют новую функцию в теле "
"`flet` но не в определении новой функции.\n"
"Итак, из этого можно извлечь два урока: испоьзуйте `labels` вместо `flet` "
"для определения рекурсивных функций, и не затеняйте определение функции "
"локальным определением с тем же именем (это второй урок относящийся к "
"переменным).\n"
"Давайте исправим проблему, изменив `labels` на `flet` и назвав новую функцию "
"`recurse`:"

#: in/chapter25.md:227
msgid ""
"```lisp\n"
"(defun replace-?-vars (exp)\n"
"  \"Replace any ? within exp with a var of the form ?123.\"\n"
"  ;;*** Buggy Version ***\n"
"  (let ((n 0))\n"
"      (labels\n"
"        ((recurse (exp)\n"
"```"
msgstr ""

#: in/chapter25.md:230
msgctxt "in/chapter25.md:230"
msgid ""
"`          (cond ((eq exp '?) (symbol '?\n"
"(incf n)))`"
msgstr ""

#: in/chapter25.md:237
msgid ""
"```lisp\n"
"          ((atom exp) exp)\n"
"          (t (cons (replace-?-vars (first exp))\n"
"            (replace-?-vars (rest exp)))))))\n"
"        (recurse exp))))\n"
"```"
msgstr ""

#: in/chapter25.md:240
msgid ""
"Annoyingly, this version still doesn't work!\n"
"This time, the problem is carelessness; we changed the `replace- ? - vars to "
"recurse` in two places, but not in the two calls in the body of `recurse`."
msgstr ""
"К сожалению, эта версия все еще не работает!\n"
"На этот раз проблема в невнимательности; мы изменили `replace-?-vars` на "
"`recurse` в двух местах, но не в двух вызовах в теле `recurse`."

#: in/chapter25.md:244
msgid ""
"**Remedy:** In general, the lesson is to make sure you call the right "
"function.\n"
"If there are two functions with similar effects and you call the wrong one, "
"it can be hard to see.\n"
"This is especially true if they have similar names."
msgstr ""
"**Устранение:** В общем, урок состоит в том, чтобы убедиться, что вы "
"вызываете правильную функцию.\n"
"Если есть две разные функции с похожими эффектами, и вы вызываете "
"неправильную, это может быть трудно заметить.\n"
"Это особенно актуально, если у них похожие названия."

#: in/chapter25.md:246
msgid "**PROBLEM:** Your closures don't seem to be working."
msgstr "**Проблема:** похоже, ваши замыкания не работают."

#: in/chapter25.md:249
msgid ""
"**Diagnosis:** You may be erroneously creating a lambda expression by "
"consing up code.\n"
"Here's an example from a recent textbook:"
msgstr ""
"**Диагностика:** возможно, вы ошибочно создаете лямбда-выражение, используя "
"код создаваемый консингом(конструированием списков).\n"
"Вот пример из недавнего учебника:"

#: in/chapter25.md:260
msgid ""
"```lisp\n"
"(defun make-specialization (c)\n"
"  (let (pred newc)\n"
"    ...\n"
"  (setf (get newc 'predicate)\n"
"    '(lambda (obj)    :Warning\n"
"      (and ,(cons pred '(obj))    :Don't do this.\n"
"      (apply '.(get c 'predicate) (list obj)))))\n"
"    ...))\n"
"```"
msgstr ""

#: in/chapter25.md:265
msgid ""
"Strictly speaking, this is legal according to *Common Lisp the Language*, "
"although in ANSI Common Lisp it will *not* be legal to use a list beginning "
"with `lambda` as a function.\n"
"But in either version, it is a bad idea to do so.\n"
"A list beginning with `lambda` is just that: a list, not a closure.\n"
"Therefore, it cannot capture lexical variables the way a closure does."
msgstr ""
"Строго говоря, это законно в соответствии с *Common Lisp the Language*, хотя "
"в ANSI Common Lisp незаконно использовать a list начинающийся с `lambda` как "
"функцию.\n"
"Но в любом случае это плохая идея.\n"
"Список начанающийся с `lambda` это просто список, а не замыкание.\n"
"Следовательно, он не может захватывать лексические переменные, как это "
"делает замыкание."

#: in/chapter25.md:270
msgid ""
"**Remedy:** The correct way to create a closure is to evaluate a call to the "
"special form `function`, or its abbreviation, # '.\n"
"Here is a replacement for the code beginning with '(`lambda ....` Note that "
"it is a closure, closed over `pred` and `c`.\n"
"Also note that it gets the `predicate` each time it is called; thus, it is "
"safe to use even when predicates are being changed dynamically.\n"
"The previous version would not work when a predicate is changed."
msgstr ""
"**Устранение:** Правильный способ создать замыкание - вычислить специальную "
"форму `function`, или ее сокращенную запись ``#'``.\n"
"Это замена для кода начинающегося с '(`lambda ....` Обратите внимание, что "
"это замыкание, замкунтое над `pred` и `c`.\n"
"Также обратите внимание, что оно получает предикат каждый раз, когда оно "
"вызывается; таким образом, безопасно использовать даже если предикаты "
"изменяются динамически. Предыдущая версия не работала бы при изменении "
"предиката."

#: in/chapter25.md:276
msgid ""
"```lisp\n"
"#'(lambda (obj)            ; *Do this instead.*\n"
"      (and (funcall pred obj)\n"
"          (funcall (get c 'predicate) obj)))\n"
"```"
msgstr ""

#: in/chapter25.md:279
msgid ""
"It is important to remember that `function` (and thus # ') is a special "
"form, and thus only returns the right value when it is evaluated.\n"
"A common error is to use # ' notation in positions that are not evaluated:"
msgstr ""
"Важно помнить, что функция(`function`) (и следовательно # ') это особая "
"специальная форма, и поэтому она возвращает правильное значение только при "
"ее вычислении.\n"
"Распространенной ошибкой является использование обозначения ``#'`` в "
"позициях, которые не вычисляются:"

#: in/chapter25.md:283
msgid ""
"```lisp\n"
"(defvar *obscure-fns* '(#'cis #'cosh #'ash #'bit-orc2)) ; *wrong*\n"
"```"
msgstr ""

#: in/chapter25.md:289
msgid ""
"This does not create a list of four functions.\n"
"Rather, it creates a list of four sublists; the first sublist is (`function "
"cis`).\n"
"It is an error to funcall or apply such an object.\n"
"The two correct ways to create a list of functions are shown below.\n"
"The first assures that each function special form is evaluated, and the "
"second uses function names instead of functions, thus relying on `funcall` "
"or `apply` to coerce the names to the actual functions."
msgstr ""
"Здесь не создается список из четырех функций.\n"
"Скорее,  он создает список из четырех подсписков (`function cis`).\n"
"Будет ошибкой выполнить funcall или apply для такого объекта.\n"
"Ниже показаны два правильных способа создания списка функций.\n"
"Первый гарантирует, что каждая спциальная форма function вычисляется, и "
"вторая использует имена функций вместо функций, таким образом полагаясь на "
"`funcall` или `apply` для удержвания имен актуальных функциям."

#: in/chapter25.md:294
msgid ""
"```lisp\n"
"(defvar *obscure-fns* (list #'cis #'cosh #'ash #'bit-orc2))\n"
"(defvar *obscure-fns* '(cis cosh ash bit-orc2))\n"
"```"
msgstr ""

#: in/chapter25.md:298
msgid ""
"Another common `error` is to expect # ' `if` or # ' `or` to return a "
"function.\n"
"This is an error because special forms are just syntactic markers.\n"
"There is no function named `if` or `or`; they should be thought of as "
"directives that tell the compiler what to do with a piece of code."
msgstr ""
"Другой распространенной `ошибкой` является ожидание ``#'if`` или ``#'or`` "
"возврата функции.\n"
"Это ошибка, потому что специальные формы это просто синтаксические маркеры.\n"
"Нет функции с именем `if` или `or`; и их следует рассматривать как "
"директивы, которые сообщают компилятору, что делать с фрагментом кода."

#: in/chapter25.md:301
msgid ""
"By the way, the function `make` - `specialization` above is bad not only for "
"its lack of `function` but also for its use of backquote.\n"
"The following is a better use of backquote:"
msgstr ""
"Кстати, указанная выше функция `make` - `specialization` плоха не  только из-"
"за отсутствия `function`, но и из-за использования обратной кавычки.\n"
"Следующий код показывает лучшее использование обратной кавычки:"

#: in/chapter25.md:307
msgid ""
"```lisp\n"
"'(lambda (obj)\n"
"    (and (,pred obj)\n"
"        (,(get c 'predicate) obj)))\n"
"```"
msgstr ""

#: in/chapter25.md:309
msgid "## 25.4 Values Change \"by Themselves\""
msgstr "## 25.4 Значения меняются \"сами по себе\""

#: in/chapter25.md:312
msgid ""
"**PROBLEM:** You deleted/removed something, but it didn't take effect.\n"
"For example:"
msgstr ""
"**Проблема:** Вы что-то удалили, но это не сработало.\n"
"Например:"

#: in/chapter25.md:314
msgid "`> (setf numbers '(1 2 3 4 5))`=> `(1 2 3 4 5)`"
msgstr ""

#: in/chapter25.md:316
msgid "`> (remove 4 numbers)`=> `(1 2 3 5)`"
msgstr ""

#: in/chapter25.md:318
msgctxt "in/chapter25.md:318"
msgid "`> numbers`=> `(1 2 3 4 5)`"
msgstr ""

#: in/chapter25.md:320
msgid "`> (delete 1 numbers)`=> `(2 3 4 5)`"
msgstr ""

#: in/chapter25.md:322
msgctxt "in/chapter25.md:322"
msgid "`> numbers`=> `(1 2 3 4 5)`"
msgstr ""

#: in/chapter25.md:327
msgid ""
"**Remedy:** Use (`setf numbers` (`delete 1 numbers`)).\n"
"Note that `remove` is a non-destructive function, so it will never alter its "
"arguments, `delete` is destructive, but when asked to delete the first "
"element of a list, it returns the rest of the list, and thus does not alter "
"the list itself.\n"
"That is why `setf` is necessary.\n"
"Similar remarks hold for `nconc`, `sort`, and other destructive operations."
msgstr ""
"**Устранение:** Используйте (`setf numbers` (`delete 1 numbers`)).\n"
"Обратите внимание, что `remove` это не разрушающая функция, поэтому она "
"никогда не меняет свои аргументы, `delete` является разрушающей, но при "
"запросе на удаление первого элемента списка возвращает оставшуюся часть "
"списка, и, таим образом, не изменяет сам список.\n"
"Вот почему `setf` необходим.\n"
"Аналогичные замечания справедливы для `nconc`, `sort` и других разрушающих "
"операций."

#: in/chapter25.md:330
msgid ""
"**PROBLEM:** You created a hundred different structures and changed a field "
"in one of them.\n"
"Suddenly, all the other ones magically changed!"
msgstr ""
"**PROBLEM:** Вы создали сотню различных структур и изменили поле одной из "
"них. Внезапно все остальные волшебным образом изменились!"

#: in/chapter25.md:333
msgid ""
"**Diagnosis:** Different structures may share identical subfields.\n"
"For example, suppose you had:"
msgstr ""
"**Диагностика:** Различные структуры могут иметь одинаковые подполя. \n"
"Например, предположим у вас есть:"

#: in/chapter25.md:343
msgid ""
"```lisp\n"
"(defstruct block\n"
"  (possible-colors '(red green blue))\n"
"  ...)\n"
"  (setf bl (make-block))\n"
"  (setf b2 (make-block))\n"
"  ...\n"
"  (delete 'green (block-possible-colors bl))\n"
"```"
msgstr ""

#: in/chapter25.md:346
msgid ""
"Both `b1` and `b2` share the initial list of possible colors.\n"
"The `delete` function modifies this shared list, so `green` is deleted from "
"`b2`'s possible colors list just as surely as it is deleted from `b1`'s."
msgstr ""
"И `b1`, и `b2` разделяют исходный список возможных цветов.\n"
"Функция `delete` изменяет этот общий(разделяемый) список, поэтому `green` "
"удаляется из списка возможных цветов `b2`, также надежно, как он удаляется "
"из списка `b1`."

#: in/chapter25.md:349
msgid ""
"**Remedy:** Don't share pieces of data that you want to alter individually.\n"
"In this case, either use `remove` instead of `delete`, or allocate a "
"different copy of the list to each instance:"
msgstr ""
"**Устранение:** не делитесь частями данных, которые вы хотите изменять "
"индивидуально.\n"
"В этом случае либо используйте `remove` вместо `delete`, либо "
"создайте(выделите) отдельную копию списка для каждого экземпляра:"

#: in/chapter25.md:355
msgid ""
"```lisp\n"
"(defstruct block\n"
"  (possible-colors (list 'red 'green 'blue))\n"
"  ...)\n"
"```"
msgstr ""

#: in/chapter25.md:358
msgid ""
"Remember that the initial value field of a defstruct is an expression that "
"is evaluated anew each time `make-block` is called.\n"
"It is incorrect to think that the initial form is evaluated once when the "
"`defstruct` is defined."
msgstr ""
"Помните, что инициализирующее значение поля  defstruct - это выражение, "
"которое вычисляется заново каждый раз при вызове `make-block`.\n"
"Неправильно думать, что исходная форма вычисляется один раз при определении "
"`defstruct`."

#: in/chapter25.md:360
msgid "## 25.5 Built-In Functions Don't Find Elements"
msgstr "## 25.5 Встроенные Функции не находят элементов"

#: in/chapter25.md:362
msgid ""
"**PROBLEM:** You tried (`find item list`), and you know it is there, but it "
"wasn't found."
msgstr ""
"**Проблем:** Вы пробуете (`find item list`), и вы знаете что он там есть, но "
"он не находиться."

#: in/chapter25.md:365
msgid ""
"**Diagnosis:** By default, many built-in functions use `eql` as an equality "
"test, `find` is one of them.\n"
"If `item` is, say, a list that is `equal` but not `eql` to one of the "
"elements of `list`, it will not be found."
msgstr ""
"**Диагностика:** по умолчанию многие встроенные функции используют `eql` в "
"качестве проверки на равенство, `find` одна из них.\n"
"Если `item` это, скажем список, который  `equal` но не  `eql` ни одному "
"элементу `list`, он не будет найден."

#: in/chapter25.md:367
msgid "**Remedy:** Use (`find item list :test #'equal`)"
msgstr "**Устранение:** Используйте (`find item list :test #'equal`)"

#: in/chapter25.md:369
msgid ""
"**Diagnosis:** If the `item` is nil, then nil will be returned whether it is "
"found or not."
msgstr ""
"**Диагностика:** если `item` это nil, то будет возвращено nil не зависимо от "
"того, найден элемент или нет."

#: in/chapter25.md:371
msgid ""
"**Remedy:** Use `member` or `position` instead of `find` whenever the item "
"can be nil."
msgstr ""
"**Устранение:** используйте `member` или `position` вместо `find` когда item "
"может быть nil."

#: in/chapter25.md:373
msgid "## 25.6 Multiple Values Are Lost"
msgstr "## 25.6 Теряются множественные значения"

#: in/chapter25.md:375
msgid ""
"**PROBLEM:** You only get one of the multiple values you were expecting."
msgstr "**ПРОБЛЕМА:** Вы получаете только одно из ожидаемых значений."

#: in/chapter25.md:378
msgid ""
"**Diagnosis:** In certain contexts where a value must be tested by Lisp, "
"multiple values are discarded.\n"
"For example, consider:"
msgstr ""
"**Диагностика:** В определенных контекстах, где значение должно быть "
"проверено Lisp, множественные значения отбрасываются.\n"
"Например, рассмотрим:"

#: in/chapter25.md:385
msgid ""
"```lisp\n"
"(or (mv-1 x) (mv-2 x))\n"
"(and (mv-1 x) (mv-2 x))\n"
"(cond ((mv-1 x))\n"
"  (t (mv-2 x)))\n"
"```"
msgstr ""

#: in/chapter25.md:390
msgid ""
"In each case, if `mv-2` returns multiple values, they will all be passed "
"on.\n"
"But if `mv-1` returns multiple values, only the first value will be passed "
"on.\n"
"This is true even in the last clause of a cond.\n"
"So, while the final clause (`t (mv-2 x)`) passes on multiple values, the "
"final clause (`(mv-2 x )`) would not."
msgstr ""
"В каждом случае, если `mv-2` возвращает несколько значений, все они будут "
"переданы.\n"
"Но если `mv-1` возвращает несколько значений, будет передано только первое "
"значение.\n"
"Это верно даже в последнем предложении cond.\n"
"Итак, в то время как последнее предложение (`t (mv-2 x)`) передает несколько "
"значений, последнее предложение (`(mv-2 x)`) не передает."

#: in/chapter25.md:393
msgid ""
"**Diagnosis:** Multiple values can be inadvertently lost in debugging as "
"well.\n"
"Suppose I had:"
msgstr ""
"**Диагностика:** Множественные значения также могут быть случайно потеряны "
"при отладке.\n"
"Предположим, у меня было:"

#: in/chapter25.md:399
msgid ""
"```lisp\n"
"(multiple-value-bind (a b c)\n"
"  (mv-1 x)\n"
"    ...)\n"
"```"
msgstr ""

#: in/chapter25.md:401
msgid ""
"Now, if I become curious as to what `mv -1` returns, I might change this "
"code to:"
msgstr ""
"Теперь, если мне станет любопытно, что возвращает `mv -1`, я могу изменить "
"этот код на:"

#: in/chapter25.md:407
msgid ""
"```lisp\n"
"(multiple-value-bind (a b c)\n"
"  (print (mv-1 x)) ;*** debugging output\n"
"  ...)\n"
"```"
msgstr ""

#: in/chapter25.md:410
msgid ""
"Unfortunately, `print` will see only the first value returned by `mv-1`, and "
"will return only that one value to be bound to the variable a.\n"
"The other values will be discarded, and `b` and `c` will be bound to `nil`."
msgstr ""
"К сожалению, print увидит только первое значение, возвращаемое mv-1, и "
"вернет только то одно значение, которое будет привязано к переменной a.\n"
"Остальные значения будут отброшены, а `b` и `c` будут привязаны к `nil`."

#: in/chapter25.md:412
msgid "## 25.7 Declarations Are Ignored"
msgstr "## 25.7 Объявления(декларации) игнорируются"

#: in/chapter25.md:417
msgid ""
"**PROBLEM:** Your program uses 1024 x 1024 arrays of floating-point "
"numbers.\n"
"But you find that it takes 15 seconds just to initialize such an array to "
"zeros!\n"
"Imagine how inefficient it is to actually do any computation!\n"
"Here is your function that zeroes an array:"
msgstr ""
"**ПРОБЛЕМА:** Ваша программа использует массивы 1024 x 1024 чисел с "
"плавающей запятой.\n"
"Но вы обнаружите, что для инициализации такого массива нулями требуется 15 "
"секунд!\n"
"Представьте себе, насколько неэффективно выполнять какие-либо вычисления!\n"
"Вот ваша функция, которая обнуляет массив:"

#: in/chapter25.md:426
msgid ""
"```lisp\n"
"(defun zero-array (arr)\n"
"  \"Set the 1024x1024 array to all zeros.\"\n"
"  (declare (type (array float) arr))\n"
"  (dotimes (i 1024)\n"
"    (dotimes (j 1024)\n"
"      (setf (aref arr i j) 0.0))))\n"
"```"
msgstr ""

#: in/chapter25.md:431
msgid ""
"**Diagnosis:** The main problem here is an ineffective declaration.\n"
"The type (`array float`) does not help the compiler, because the array could "
"be displaced to an array of another type, and because `float` encompasses "
"both single- and double-precision floating-point numbers.\n"
"Thus, the compiler is forced to allocate storage for a new copy of the "
"number 0.0 for each of the million elements of the array.\n"
"The function is slow mainly because it generates so much garbage."
msgstr ""
"**Диагностика:** Основная проблема здесь - неэффективное декларирование.\n"
"Тип (array float) не помогает компилятору, потому что массив может быть "
"перемещен в массив другого типа, и потому что float охватывает числа с "
"плавающей запятой как одинарной, так и двойной точности.\n"
"Таким образом, компилятор вынужден выделять хранилище для новую копию числа "
"0,0 для каждого из миллиона элементов массива.\n"
"Функция работает медленно, главным образом потому, что генерирует много "
"мусора."

#: in/chapter25.md:435
msgid ""
"**Remedy:** The following version uses a much more effective type "
"declaration: a simple array of single-precision numbers.\n"
"It also declares the size of the array and turns safety checks off.\n"
"It runs in under a second on a SPARCstation, which is slower than optimized "
"C, but faster than unoptimized C."
msgstr ""
"**Устранение:** В следующей версии используется гораздо более эффективное "
"объявление типа: простой массив чисел с одинарной точностью.\n"
"Оно также объявляет размер массива и отключает проверки безопасности.\n"
"Оно работает менее чем за секунду на SPARCstation, что медленнее, чем "
"оптимизированный C, но быстрее, чем неоптимизированный C."

#: in/chapter25.md:445
msgid ""
"```lisp\n"
"(defun zero-array (arr)\n"
"  \"Set the array to all zeros.\"\n"
"  (declare (type (simple-array single-float (1024 1024)) arr)\n"
"          (optimize (speed 3) (safety 0)))\n"
"  (dotimes (i 1024)\n"
"    (dotimes (j 1024)\n"
"      (setf (aref arr i j) 0.0))))\n"
"```"
msgstr ""

#: in/chapter25.md:449
msgid ""
"Another common error is to use something like (`simple-vector fixnum`) "
"asatype specifier.\n"
"It is a quirk of Common Lisp that the `simple-vector` type specifier only "
"accepts a size, not a type, while the `array, vector` and `simple-array` "
"specifiers all accept an optional type followed by an optional size or list "
"of sizes.\n"
"To specify a simple vector of fixnums, use (`simple-array fixnum (*)`)."
msgstr ""
"Другой распространенной ошибкой является использование чего-то вроде "
"(`simple-vector fixnum`) в качестве спецификатора типа.\n"
"Особенность Common Lisp заключается в том, что спецификатор типа `simple-"
"vector` принимает только размер, а не тип, в то время как спецификаторы "
"`array`, `vector` и `simple-array` принимают необязательный тип, за которым "
"следует необязательный размер или список размеров.\n"
"Чтобы указать простой вектор(simple vector) фиксированных чисел, используйте "
"(`simple-array fixnum (*)`)."

#: in/chapter25.md:455
msgid ""
"To be precise, `simple-vector` means (`simple-array t (*)`).\n"
"This means that `simple-vector` cannot be used in conjunction with any other "
"type specifier.\n"
"A common mistake is to think that the type (`and simple-vector (vector "
"fixnum)`) is equivalent to (`simple-array fixnum (*)`), a simple, one-"
"dimensional vector of fixnums.\n"
"Actually, it is equivalent to (`simple-array t (*)`), a simple one-"
"dimensional array of any type elements.\n"
"To eliminate this problem, avoid `simple- vector` altogether."
msgstr ""
"Если быть точным, `simple-vector` означает (`simple-array t (*)`).\n"
"Это означает, что `simple-vector` не может использоваться вместе с любым "
"другим спецификатором типа.\n"
"Распространенная ошибка - думать, что тип (`and simple-vector (vector "
"fixnum)`) эквивалентен (`simple-array fixnum (*)`), простому, одномерному "
"вектору фиксированных чисел.\n"
"Фактически, он эквивалентен (`simple-array t (*)`), простому одномерному "
"массиву элементов любого типа.\n"
"Чтобы устранить эту проблему, вообще избегайте `simple-vector`."

#: in/chapter25.md:457
msgid "## 25.8 My Lisp Does the Wrong Thing"
msgstr "## 25.8 Мой Лисп делает не то"

#: in/chapter25.md:461
msgid ""
"When all else fails, it is tempting to shift the blame for an error away "
"from your own code and onto the Common Lisp implementation.\n"
"It is certainly true that errors are found in existing implementations.\n"
"But it is also true that most of the time, Common Lisp is merely doing "
"something the user did not expect rather than something that is in error."
msgstr ""
"Когда все остальное терпит неудачу, возникает соблазн переложить вину за "
"ошибку с вашего собственного кода на реализацию Common Lisp.\n"
"Безусловно, ошибки обнаруживаются в существующих реализациях.\n"
"Но также верно и то, что большую часть времени Common Lisp просто делает то, "
"чего пользователь не ожидал, а не что-то ошибочное."

#: in/chapter25.md:464
msgid ""
"For example, a common \"bug report\" is to complain about read - `from- "
"string`.\n"
"A user might write:"
msgstr ""
"Например, распространенный \"bug report\"(отчет об ошибке) - это жалоба на "
"чтение - `from-string`(из строки).\n"
"Пользователь может написать:"

#: in/chapter25.md:468
msgid ""
"```lisp\n"
"(read-from-string \"a b c\" :start 2)\n"
"```"
msgstr ""

#: in/chapter25.md:472
msgid ""
"expecting the expression to start reading at position `2` and thus return "
"`b`.\n"
"In fact, this expression returns a.\n"
"The angry user thinks the implementation has erroneously ignored the :"
"`start` argument and files a bug report,[1](#fn0010) only to get back the "
"following explanation:"
msgstr ""
"ожидая, что выражение начнет чтение с позиции `2` и, таким образом, вернет "
"`b`.\n"
"Фактически, это выражение возвращает a.\n"
"Рассерженный пользователь думает, что реализация ошибочно проигнорировала "
"аргумент: `start` и отправляет отчет об ошибке [1](#fn0010) только для того, "
"чтобы получить следующее объяснение:"

#: in/chapter25.md:476
msgid ""
"The function `read-from-string` takes two optional arguments, `eof-errorp` "
"and `eof-value`, in addition to the keyword arguments.\n"
"Thus, in the expression above, : `start` is taken as the value of `eof-"
"errorp`, with `2` as the value of `eof-value`.\n"
"The correct answer is in fact to read from the start of the string and "
"return the very first form, a."
msgstr ""
"Функция `read-from-string` принимает два необязательных аргумента, `eof-"
"errorp` и `eof-value`, в дополнении к аргументам ключевым словам.\n"
"Таким образом, в приведенном выше выражении: `start` принимается как "
"значение `eof-errorp`, а `2` - как значение `eof-value`.\n"
"На самом деле правильный ответ - читать с начала строки и возвращать самую "
"первую форму, a."

#: in/chapter25.md:480
msgid ""
"The functions `read-from-string` and `parse-namestring` are the only built-"
"in functions that have this problem, because they are the only ones that "
"have both optional and keyword arguments, with an even number of optional "
"arguments.\n"
"The functions `write-line` and `write-string` have keyword arguments and a "
"single optional argument (the stream), so if the stream is accidently "
"omitted, an error will be signaled.\n"
"(If you type (`write-line str :start 4`), the system will complain either "
"that : `start` is not a stream or that 4 is not a keyword.)"
msgstr ""
"Функции `read-from-string` и `parse-namestring` - единственные встроенные "
"функции, у которых есть эта проблема, потому что они единственные, у которых "
"есть как необязательные аргументы, так и аргументы ключевые слова с четным "
"числом необязательных аргументов.\n"
"Функции `write-line` и `write-string` имеют аргументы ключевые слова и "
"единственный необязательный аргумент (поток), поэтому, если поток случайно "
"пропущен, будет выдана ошибка.\n"
"(Если вы наберете (`write-line str: start 4`), система будет жаловаться либо "
"на то, что: `start` не является потоком, либо что 4 не является ключевым "
"словом.)"

#: in/chapter25.md:483
msgid ""
"The moral is this: functions that have both optional and keyword arguments "
"are confusing.\n"
"Take care when using existing functions that have this problem, and abstain "
"from using both in your own functions."
msgstr ""
"Мораль такова: функции, которые имеют как необязательные, так и ключевые "
"аргументы, сбивают с толку.\n"
"Будьте осторожны при использовании существующих функций, у которых есть эта "
"проблема, и воздержитесь от использования обеих в своих собственных функциях."

#: in/chapter25.md:485
msgid "## 25.9 How to Find the Function You Want"
msgstr "## 25.9 Как найти нужную функцию"

#: in/chapter25.md:487
msgid ""
"Veteran Common Lisp programmers often experience a kind of software "
"*d&eacute;j&agrave; vu:* they believe that the code they are writing could "
"be done by a built-in Common Lisp function, but they can't remember the name "
"of the function."
msgstr ""
"Опытные программисты Common Lisp часто сталкиваются с чем-то вроде "
"программного обеспечения *d&eacute;j&agrave; vu:*(дежа-вю) они считают, что "
"код, который они пишут, может быть выполнен встроенной функцией Common Lisp, "
"но они не могут вспомнить имя функции."

#: in/chapter25.md:495
msgid ""
"Here's an example: while coding up a problem I realized I needed a function "
"that, given the lists (`a b c d`) and (`c d`), would return (`a b`), that "
"is, the part of the first list without the second list.\n"
"I thought that this was the kind of function that might be in the standard, "
"but I didn't know what it would be called.\n"
"The desired function is similar to `set-difference`, so I looked that up in "
"the index of *Common Lisp the Language* and was directed to page 429.\n"
"I browsed through the section on \"using lists as sets\" but found nothing "
"appropriate.\n"
"However, I was reminded of the function `butlast`, which is also similar to "
"the desired function.\n"
"The index directed me to page 422 for `butlast`, and on the same page I "
"found `ldiff`, which was exactly the desired function.\n"
"It might have been easier to find (and remember) if it were called `list-"
"difference`, but the methodology of browsing near similar functions paid off."
msgstr ""
"Вот пример: при написании кода я понял, что мне нужна функция, которая, "
"учитывая списки (`a b c d`) и (` c d`), возвращала бы (`a b`), то есть часть "
"первого списка без второго списока.\n"
"Я думал, что это та функция, которая может быть в стандарте, но я не знал, "
"как она будет называться.\n"
"Требуемая функция похожа на `set-difference`, поэтому я нашел ее в указателе "
"*Common Lisp the Language* и был перенаправлен на страницу 429.\n"
"Я просмотрел раздел \"Использование списков как наборов\", но не нашел "
"ничего подходящего.\n"
"Однако мне напомнили о функции `butlast`, которая тоже похожа на искомую "
"функцию.\n"
"Индекс направил меня на страницу 422 для `butlast`, и на той же странице я "
"нашел `ldiff`, что было именно той функцией, которую нужно было.\n"
"Было бы легче найти (и запомнить), если бы это называлось `list-difference`, "
"но методология осмотра рядом с похожими функциями окупилась."

#: in/chapter25.md:500
msgid ""
"If you think you know part of the name of the desired function, then you can "
"use apropos to find it.\n"
"For example, suppose I thought there was a function to push a new element "
"onto the front of an array.\n"
"Looking under `array, push-array`, and `array - push` in the index yields "
"nothing.\n"
"But I can turn to Lisp itself and ask:"
msgstr ""
"Если вы думаете, что знаете часть имени нужной функции, вы можете "
"использовать apropos, чтобы найти ее.\n"
"Например, предположим, что я думал, что есть функция, которая помещает новый "
"элемент в начало массива.\n"
"Поиск в индексах `array, push-array` и `array-push` ничего не даст.\n"
"Но я могу обратиться к самому Лиспу и спросить:"

#: in/chapter25.md:508
msgid ""
"```lisp\n"
"> (apropos \"push\")\n"
"PUSH                              Macro          (VALUE PLACE), plist\n"
"PUSHNEW                        Macro          (VALUE PLACE &KEY ...), plist\n"
"VECTOR-PUSH                function    (NEW-ELEMENT VECTOR), plist\n"
"VECTOR-PUSH-EXTEND  function    (DATA VECTOR &OPTIONAL ...), plist\n"
"```"
msgstr ""

#: in/chapter25.md:511
msgid ""
"This should be enough to remind me that `vector-push` is the answer.\n"
"If not, I can get more information from the manual or from the online "
"functions `documentation` or `describe`:"
msgstr ""
"Этого должно быть достаточно, чтобы напомнить мне, что ответ - `vector-"
"push`.\n"
"Если нет, я могу получить дополнительную информацию из руководства или из "
"онлайн-функций `documentation` или `describe`:"

#: in/chapter25.md:517
msgid ""
"```lisp\n"
"> (documentation 'vector-push 'function)\n"
"\"Add NEW-ELEMENT as an element at the end of VECTOR.\n"
"The fill pointer (leader element 0) is the index of the next\n"
"```"
msgstr ""

#: in/chapter25.md:520
msgid ""
"`element to be added.\n"
"If the array is full, VECTOR-PUSH returns`"
msgstr ""

#: in/chapter25.md:525
msgid ""
"```lisp\n"
"NIL and the array is unaffected; use VECTOR-PUSH-EXTEND instead\n"
"if you want the array to grow automatically.\"\n"
"```"
msgstr ""

#: in/chapter25.md:528
msgid ""
"Another possibility is to browse through existing code that performs a "
"similar purpose.\n"
"That way, you may find the exact function you want, and you may get "
"additional ideas on how to do things differently."
msgstr ""
"Другая возможность - просмотреть существующий код, который выполняет "
"аналогичную цель.\n"
"Таким образом, вы можете найти именно ту функцию, которую хотите, и получить "
"дополнительные идеи о том, как действовать по-другому."

#: in/chapter25.md:530
msgid "## 25.10 Syntax of LOOP"
msgstr "## 25.10 Синтаксис LOOP"

#: in/chapter25.md:535
msgid ""
"`loop` by itself is a powerful programming language, one with a syntax quite "
"different from the rest of Lisp.\n"
"It is therefore important to exercise restraint in using `loop`, lest the "
"reader of your program become lost.\n"
"One simple rule for limiting the complexity of `loops` is to avoid the "
"`with` and and keywords.\n"
"This eliminates most problems dealing with binding and scope."
msgstr ""
"`loop` сам по себе является мощным языком программирования, синтаксис "
"которого сильно отличается от остального Lisp.\n"
"Поэтому важно проявлять сдержанность при использовании `loop`, чтобы "
"читатель вашей программы не потерялся.\n"
"Одно простое правило для ограничения сложности циклов - избегать "
"использования ключевых слов `with` и `and`.\n"
"Это устраняет большинство проблем, связанных с привязкой и областью действия."

#: in/chapter25.md:538
msgid ""
"When in doubt, macro-expand the loop to see what it actually does.\n"
"But if you need to macro-expand, then perhaps it would be clearer to rewrite "
"the loop with more primitive constructs."
msgstr ""
"Если сомневаетесь, разверните loop macro-expand, чтобы увидеть, что он на "
"самом деле делает.\n"
"Но если вам нужно макрорасширение, то, возможно, будет понятнее переписать "
"цикл с более примитивными конструкциями."

#: in/chapter25.md:540
msgid "## 25.11 Syntax of COND"
msgstr "## 25.11 Синтаксис COND"

#: in/chapter25.md:544
msgid ""
"For many programmers, the special form cond is responsible for more syntax "
"errors than any other, with the possible exception of `loop`.\n"
"Because most cond-clause start with two left parentheses, beginners often "
"come to the conclusion that every clause must.\n"
"This leads to errors like the following:"
msgstr ""
"Для многих программистов специальная форма cond вызывает больше "
"синтаксических ошибок, чем любая другая, за возможным исключением `loop`.\n"
"Поскольку большинство условных предложений начинается с двух левых круглых "
"скобок, новички часто приходят к выводу, что каждое предложение должно быть "
"обязательным.\n"
"Это приводит к следующим ошибкам:"

#: in/chapter25.md:550
msgid ""
"```lisp\n"
"(let ((entry (assoc item list)))\n"
"  (cond ((entry (process entry)))\n"
"          ...))\n"
"```"
msgstr ""

#: in/chapter25.md:552
msgid ""
"Here entry is a variable, but the urge to put in an extra parenthesis means "
"that the cond-clause attempts to call entry as a function rather than "
"testing its value as a variable."
msgstr ""
"Здесь запись - это переменная, но желание заключить дополнительные скобки "
"означает, что условие cond попытается вызвать запись как функцию, а не "
"проверить ее значение как переменную."

#: in/chapter25.md:554
msgid ""
"The opposite problem, leaving out a parenthesis, is also a source of error:"
msgstr ""
"Противоположная проблема, отсутствие скобок, также является источником "
"ошибки:"

#: in/chapter25.md:559
msgid ""
"```lisp\n"
"(cond (lookup item list)\n"
"  (t nil))\n"
"```"
msgstr ""

#: in/chapter25.md:562
msgid ""
"In this case, `lookup` is accessed as a variable, when the intent was to "
"call it as a function.\n"
"In Common Lisp this will usually lead to an unbound variable error, but in "
"Scheme this bug can be very difficult to pin down: the value of `lookup` is "
"the function itself, and since this is not null, the test will succeed, and "
"the expression will return `list` without complaining."
msgstr ""
"В этом случае к `lookup` обращаются как к переменной, когда намеревались "
"вызвать ее как функцию.\n"
"В Common Lisp это обычно приводит к ошибке несвязанной переменной, но в "
"Scheme эту ошибку может быть очень сложно определить: значение `lookup` - "
"это сама функция, и, поскольку она не равна нулю, тест будет успешным, и "
"выражение вернет `list` без выдачи ошибки."

#: in/chapter25.md:565
msgid ""
"The moral is to be careful with cond, especially when using Scheme.\n"
"Note that `if` is much less error prone and looks just as nice when there "
"are no more than two branches."
msgstr ""
"Мораль - быть осторожным с cond, особенно при использовании Scheme.\n"
"Обратите внимание, что `if` гораздо менее подвержен ошибкам и выглядит так "
"же хорошо, когда существует не более двух ветвей."

#: in/chapter25.md:567
msgid "## 25.12 Syntax of CASE"
msgstr "## 25.12 Синтаксис CASE"

#: in/chapter25.md:571
msgid ""
"In a `case` special form, each clause consists of a key or list of keys, "
"followed by the value of that case.\n"
"The thing to watch out for is when the key is `t`, `otherwise`, or `nil`.\n"
"For example:"
msgstr ""
"В специальной форме `case` каждое предложение состоит из ключа или списка "
"ключей, за которым следует значение этого case.\n"
"На что следует обратить внимание, это когда ключ имеет значение `t`, "
"`otherwise`(иначе) или `nil`.\n"
"Например:"

#: in/chapter25.md:578
msgid ""
"```lisp\n"
"(case letter\n"
"  (s ...)\n"
"  (t ...)\n"
"  (u ...))\n"
"```"
msgstr ""

#: in/chapter25.md:583
msgid ""
"Here the t is taken as the default clause; it will always succeed, and all "
"subsequent clauses will be ignored.\n"
"Similarly, using a () `ornil` as a key will not have the desired effect: it "
"will be interpreted as an empty key list.\n"
"If you want to be completely safe, you can use a list of keys for every "
"clause.[2](#fn0015) This is a particularly good idea when you write a macro "
"that expands into a `case`.\n"
"The following code correctly tests for `t` and `nil` keys:"
msgstr ""
"Здесь t используется по умолчанию; он всегда будет успешным, и все "
"последующие предложения будут проигнорированы.\n"
"Точно ,использование () или `nil` в качестве ключа не даст желаемого "
"эффекта: оно будет интерпретировано как пустой список ключей.\n"
"Если вы хотите быть в полной безопасности, вы можете использовать список "
"ключей для каждого предложения. [2](# fn0015) Это особенно хорошая идея, "
"когда вы пишете макрос, который раскрывается в `case`.\n"
"Следующий код правильно проверяет ключи `t` и `nil`:"

#: in/chapter25.md:591
msgid ""
"```lisp\n"
"(case letter\n"
"  ((s) ...)\n"
"  ((t) ...)\n"
"  ((u) ...)\n"
"  ((nil) ...))\n"
"```"
msgstr ""

#: in/chapter25.md:593
msgid "## 25.13 Syntax of LET and LET*"
msgstr "## 25.13 Синтаксис LET и LET*"

#: in/chapter25.md:597
msgid ""
"A common error is leaving off a layer of parentheses in `let`, just like in "
"cond.\n"
"Another error is to refer to a variable that has not yet been bound in a "
"`let`.\n"
"To avoid this problem, use `let*` whenever a variable's initial binding "
"refers to a previous variable."
msgstr ""
"Распространенная ошибка - это пропуск круглых скобок в `let`, как и в "
"`cond`.\n"
"Другая ошибка - ссылка на переменную, которая еще не была привязана в "
"`let`.\n"
"Чтобы избежать этой проблемы, используйте `let*` всякий раз, когда начальная "
"привязка переменной ссылается на предыдущую переменную."

#: in/chapter25.md:599
msgid "## 25.14 Problems with Macros"
msgstr "## 25.14 Проблемы с Макросом"

#: in/chapter25.md:601
msgid ""
"In [section 3.2](B9780080571157500030.xhtml#s0015) we described a four-part "
"approach to the design of macros:"
msgstr ""
"В [разделе 3.2](B9780080571157500030.xhtml#s0015) мы описали четырехэтапный "
"подход к созданию макросов:"

#: in/chapter25.md:603
msgctxt "in/chapter25.md:603"
msgid "*   Decide if the macro is really necessary."
msgstr "*   Решите, действительно ли нужен макрос."

#: in/chapter25.md:605
msgctxt "in/chapter25.md:605"
msgid "*   Write down the syntax of the macro."
msgstr "*   Запишите синтаксис макроса."

#: in/chapter25.md:607
msgctxt "in/chapter25.md:607"
msgid "*   Figure out what the macro should expand into."
msgstr "*   Выясните, во что должен расширяться макрос."

#: in/chapter25.md:610
msgid ""
"*   Use `defmacro` to implement the syntax/expansion correspondence.\n"
"This section shows the problems that can arise in each part, starting with "
"the first:"
msgstr ""
"*   Используйте `defmacro`, чтобы реализовать соответствие синтаксиса и "
"расширения.\n"
"В этом разделе показаны проблемы, которые могут возникнуть в каждой части, "
"начиная с первой:"

#: in/chapter25.md:612
msgctxt "in/chapter25.md:612"
msgid "*   Decide if the macro is really necessary."
msgstr "*   Решите, действительно ли нужен макрос."

#: in/chapter25.md:617
msgid ""
"Macros extend the rules for evaluating an expression, while function calls "
"obey the rules.\n"
"Therefore, it can be a mistake to define too many macros, since they can "
"make it more difficult to understand a program.\n"
"A common mistake is to define macros that *do not* violate the usual "
"evaluation rules.\n"
"One recent book on AI programming suggests the following:"
msgstr ""
"Макросы расширяют правила вычисления выражения, тогда как вызовы функций "
"подчиняются правилам.\n"
"Следовательно, определение слишком большого количества макросов может быть "
"ошибкой, поскольку они могут затруднить понимание программы.\n"
"Распространенной ошибкой является определение макросов, которые *не* "
"нарушают обычные правила вычисления.\n"
"Одна недавняя книга по программированию ИИ предлагает следующее:"

#: in/chapter25.md:622
msgid ""
"```lisp\n"
"(defmacro binding-of (binding)    ; *Warning!*\n"
"    '(cadr .binding))                          ; *Don't do this.*\n"
"```"
msgstr ""
"```lisp\n"
"(defmacro binding-of (binding)    ; *Warning!*\n"
"    '(cadr .binding))                          ; *Don't do this.*\n"
"```"

#: in/chapter25.md:626
msgid ""
"The only possible reason for this macro is an unfounded desire for "
"efficiency.\n"
"Always use an `inline` function instead of a macro for such cases.\n"
"That way you get the efficiency gain, you have not introduced a spurious "
"macro, and you gain the ability to `apply` or `map` the function # ' "
"`binding - of`, something you could not do with a macro:"
msgstr ""
"Единственная возможная причина написания этого макроса - необоснованное "
"стремление к эффективности.\n"
"В таких случаях всегда используйте `inline` функцию вместо макроса.\n"
"Таким образом, вы получаете повышение эффективности, вы не вводите ложный "
"макрос и получаете возможность `apply` или `map` функции  # ' `binding - "
"of`, чего вы не могли сделать с помощью макроса:"

#: in/chapter25.md:632
msgid ""
"```lisp\n"
"(proclaim '(inline binding-of))\n"
"(defun binding-of (binding)    ; *Do this instead.*\n"
"  (second binding))\n"
"```"
msgstr ""

#: in/chapter25.md:634
msgctxt "in/chapter25.md:634"
msgid "*   Write down the syntax of the macro."
msgstr "*   Запишите синтаксис макроса."

#: in/chapter25.md:638
msgid ""
"Try to make your macro follow conventions laid down by similar macros.\n"
"For example, if your macro defines something, it should obey the conventions "
"of `defvar, defstruct, defmacro,` and the rest: start with the letters "
"`def`, take the name of the thing to be defined as the first argument, then "
"a lambda-list if appropriate, then a value or body.\n"
"It would be nice to allow for optional declarations and documentation "
"strings."
msgstr ""
"Постарайтесь, чтобы ваш макрос соответствовал соглашениям, установленным "
"аналогичными макросами.\n"
"Например, если ваш макрос что-то определяет, он должен подчиняться "
"соглашениям `defvar, defstruct, defmacro` и остальным: начните с букв `def`, "
"возьмите имя объекта, который будет определен как первый аргумент, затем "
"если необходимо, лямбда-список, затем значение или тело.\n"
"Было бы неплохо разрешить необязательные объявления и строки документации."

#: in/chapter25.md:642
msgid ""
"If your macro binds some variables or variablelike objects, use the "
"conventions laid down by `let, let*,` and `labels`: allow for a list of "
"variable or ( *variable init-val)* pairs.\n"
"If you are iterating over some kind of sequence, follow `dotimes` and "
"`dolist`.\n"
"For example, here is the syntax of a macro to iterate over the leaves of a "
"tree of conses:"
msgstr ""
"Если ваш макрос связывает некоторые переменные или объекты, подобные "
"переменным, используйте соглашения, совпадающие с `let, let*` и `labels`: "
"принимающих список переменных или пар *(variable init-val)*.\n"
"Если вы повторяете какую-то последовательность, следуйте `dotimes` и "
"`dolist`.\n"
"Например, вот синтаксис макроса для перебора листьев дерева из пар(conses):"

#: in/chapter25.md:647
msgid ""
"```lisp\n"
"(defmacro dotree ((var tree &optional result) &body body)\n"
"  \"Perform body with var bound to every leaf of tree,\n"
"```"
msgstr ""

#: in/chapter25.md:650
msgctxt "in/chapter25.md:650"
msgid ""
"`  then return result.\n"
"Return and Go can be used in body.\"`"
msgstr ""

#: in/chapter25.md:654
msgid ""
"```lisp\n"
"  ...)\n"
"```"
msgstr ""

#: in/chapter25.md:656
msgctxt "in/chapter25.md:656"
msgid "*   Figure out what the macro should expand into."
msgstr "*   Выясните, во что должен расширяться макрос."

#: in/chapter25.md:658
msgid "*   Use defmacro to implement the syntax/expansion correspondence."
msgstr ""
"*   Используйте defmacro, чтобы реализовать соответствие синтаксиса/"
"расширению."

#: in/chapter25.md:663
msgid ""
"There are a number of things to watch out for in figuring out how to expand "
"a macro.\n"
"First, make sure you don't shadow local variables.\n"
"Consider the following definition for `pop - end`, a function to pop off and "
"return the last element of a list, while updating the list to no longer "
"contain the last element.\n"
"The definition uses `last1`, which was defined on page 305 to return the "
"last element of a list, and the built-in function `nbutlast` returns all but "
"the last element of a list, destructively altering the list."
msgstr ""
"Есть несколько вещей, на которые следует обратить внимание при выяснении "
"того, как раскрыть макрос.\n"
"Во-первых, убедитесь, что вы не затеняете локальные переменные.\n"
"Рассмотрим следующее определение для `pop-end`, функции для извлечения и "
"возврата последнего элемента списка, при обновлении списка, чтобы он больше "
"не содержал последний элемент.\n"
"В определении используется `last1`, который был определен на стр. 305 для "
"возврата последнего элемента списка, а встроенная функция `nbutlast` "
"возвращает все, кроме последнего элемента списка, деструктивно изменяя "
"список."

#: in/chapter25.md:671
msgid ""
"```lisp\n"
"(defmacro pop-end (place)    ; *Warning!Buggy!*\n"
"  \"Pop and return last element of the list in PLACE.\"\n"
"  '(let ((result (lastl .place)))\n"
"      (setf .place (nbutlast .place))\n"
"      result))\n"
"```"
msgstr ""

#: in/chapter25.md:674
msgid ""
"This will do the wrong thing for (`pop-end result`), or for other "
"expressions that mention the variable `result`.\n"
"The solution is to use a brand new local variable that could not possibly be "
"used elsewhere:"
msgstr ""
"Оно будет неверно для (`pop-end result`) или для других выражений, которые "
"упоминают переменную `result`.\n"
"Решение состоит в том, чтобы использовать новую локальную переменную, "
"которую нельзя использовать где-либо еще:"

#: in/chapter25.md:683
msgid ""
"```lisp\n"
"(defmacro pop-end (place)    ; *Less buggy*\n"
"  \"Pop and return last element of the list in PLACE.\"\n"
"  (let ((result (gensym)))\n"
"  '(let ((,result (lastl ,place)))\n"
"    (setf ,place (nbutlast ,place))\n"
"      ,result)))\n"
"```"
msgstr ""

#: in/chapter25.md:685
msgid ""
"There is still the problem of shadowing local *functions.* For example, a "
"user who writes:"
msgstr ""
"По-прежнему существует проблема затенения локальных *функций.* Например, "
"пользователь, который пишет:"

#: in/chapter25.md:691
msgid ""
"```lisp\n"
"(flet ((lastl (x) (sqrt x)))\n"
"  (pop-end list)\n"
"  ...)\n"
"```"
msgstr ""

#: in/chapter25.md:695
msgid ""
"will be in for a surprise, pop-end will expand into code that calls `lastl`, "
"but since `lastl` has been locally defined to be something else, the code "
"won't work.\n"
"Thus, the expansion of the macro violates referential transparency.\n"
"To be perfectly safe, we could try:"
msgstr ""
"будет сюрпризом, pop-end превратится в код, который вызывает `lastl`, но "
"поскольку `lastl` локально определен как что-то еще, этот код не будет "
"работать.\n"
"Таким образом, расширение макроса нарушает ссылочную прозрачность.\n"
"Чтобы быть в полной безопасности, мы могли бы попробовать:"

#: in/chapter25.md:704
msgid ""
"```lisp\n"
"(defmacro pop-end (place)    ; *Less buggy*\n"
"  \"Pop and return last element of the list in PLACE.\"\n"
"  (let ((result (gensym)))\n"
"    '(let ((.result (funcall .#'lastl .place)))\n"
"      (setf .place (funcall .#'nbutlast .place))\n"
"        ,result)))\n"
"```"
msgstr ""

#: in/chapter25.md:708
msgid ""
"This approach is sometimes used by Scheme programmers, but Common Lisp "
"programmers usually do not bother, since it is rarer to define local "
"functions in Common Lisp.\n"
"Indeed, in *Common Lisp the Language*, 2d edition, it was explicitly stated "
"(page 260) that a user function cannot redefine or even bind any built-in "
"function, variable, or macro.\n"
"Even if it is not prohibited in your implementation, redefining or binding a "
"built-in function is confusing and should be avoided."
msgstr ""
"Этот подход иногда используется программистами на Scheme, но программисты "
"Common Lisp обычно не используют его, поскольку локальные функции в Common "
"Lisp определяются реже.\n"
"Действительно, в *Common Lisp the Language*, 2d edition, было явно указано "
"(стр. 260), что пользовательская функция не может переопределить или даже "
"связать какую-либо встроенную функцию, переменную или макрос.\n"
"Даже если это не запрещено в вашей реализации, переопределение или привязка "
"встроенной функции сбивает с толку, и этого следует избегать."

#: in/chapter25.md:712
msgid ""
"Common Lisp programmers expect that arguments will be evaluated in left-to-"
"right order, and that no argument is evaluated more than once.\n"
"Our definition of `pop-end` violates the second of these expectations.\n"
"Consider:"
msgstr ""
"Программисты Common Lisp ожидают, что аргументы будут вычисляться в порядке "
"слева направо и что ни один аргумент не вычисляется более одного раза.\n"
"Наше определение `pop-end` противоречит второму из этих ожиданий.\n"
"Рассмотрим:"

#: in/chapter25.md:719
msgid ""
"```lisp\n"
"(pop-end (aref lists (incf i))) =\n"
"(LET ((#:G3096 (LAST1 (AREF LISTS (INCF I)))))\n"
"  (SETF (AREF LISTS (INCF I)) (NBUTLAST (AREF LISTS (INCF I))))\n"
"  #:G3096)\n"
"```"
msgstr ""

#: in/chapter25.md:722
msgid ""
"This increments `i` three times, when it should increment it only once.\n"
"We could fix this by introducing more local variables into the expansion:"
msgstr ""
"Этот код увеличивает `i` три раза, тогда как оно должно увеличивать его "
"только один раз.\n"
"Мы могли бы исправить это, добавив в расширение больше локальных переменных:"

#: in/chapter25.md:730
msgid ""
"```lisp\n"
"(let* ((templ (incf i))\n"
"      (temp2 (AREF LISTS temp1))\n"
"      (temp3 (LAST1 temp2)))\n"
"  (setf (aref lists templ) (nbutlast temp2))\n"
"  temp3)\n"
"```"
msgstr ""

#: in/chapter25.md:734
msgid ""
"This kind of left-to-right argument processing via local variables is done "
"automatically by the Common Lisp setf mechanism.\n"
"Fortunately, the mechanism is easy to use.\n"
"We can redefine `pop-end` to call `pop` directly:"
msgstr ""
"Этот вид обработки аргументов слева направо через локальные переменные "
"выполняется автоматически механизмом setf Common Lisp.\n"
"К счастью, механизм прост в использовании.\n"
"Мы можем переопределить `pop-end` для прямого вызова `pop`:"

#: in/chapter25.md:740
msgid ""
"```lisp\n"
"(defmacro pop-end (place)\n"
"  \"Pop and return last element of the list in PLACE.\"\n"
"  '(pop (last ,place)))\n"
"```"
msgstr ""

#: in/chapter25.md:745
msgid ""
"Now all we need to do is define the `setf` method for `last`.\n"
"Here is a simple definition.\n"
"It makes use of the function `last2`, which returns the last two elements of "
"a list.\n"
"In ANSI Common Lisp we could use (`last list 2`), but with a pre-ANSI "
"compiler we need to define `last2`:"
msgstr ""
"Теперь все, что нам нужно сделать, это определить метод `setf` для `last`.\n"
"Вот простое определение.\n"
"Оно использует функцию `last2`, которая возвращает два последних элемента "
"списка.\n"
"В ANSI Common Lisp мы могли бы использовать (`last list 2`), но с "
"компилятором pre-ANSI нам нужно определить `last2`:"

#: in/chapter25.md:755
msgid ""
"```lisp\n"
"(defsetf last (place) (value)\n"
"  '(setf (cdr (last2 .place)) .value))\n"
"(defun last2 (list)\n"
"  \"Return the last two elements of a list.\"\n"
"  (if (null (rest2 list))\n"
"      list\n"
"      (last2 (rest list))))\n"
"```"
msgstr ""

#: in/chapter25.md:758
msgid ""
"Here are some macro-expansions of calls to `pop-end` and to the `setf` "
"method for `last`.\n"
"Different compilers will produce different code, but they will always "
"respect the left-to-right, one-evaluation-only semantics:"
msgstr ""
"Вот некоторые макрорасширения вызовов метода `pop-end` и метода `setf` для "
"`last`.\n"
"Разные компиляторы будут создавать разный код, но они всегда будут уважать "
"семантику с написанием слева направо, только с одним вычислением:"

#: in/chapter25.md:768
msgid ""
"```lisp\n"
"> (pop-end (aref (foo lists) (incf i))) =\n"
"(LET ((G0128 (AREF (FOO LISTS) (SETQ I (+ I 1)))))\n"
"  (PROG1\n"
"  (CAR (LAST G0128))\n"
"  (SYS:SETCDR (LAST2 G0128) (CDR (LAST G0128)))))\n"
"> (setf (last (append x y)) 'end) =\n"
"(SYS:SETCDR (LAST2 (APPEND X Y)) 'END)\n"
"```"
msgstr ""

#: in/chapter25.md:773
msgid ""
"Unfortunately, there is an error in the `setf` method for `last`.\n"
"It assumes that the list will have at least two elements.\n"
"If the list is empty, it is probably an error, but if a list has exactly one "
"element, then (`setf` (`last`*list) val)* should have the same effect as "
"(`setf`*list val).* But there is no way to do that with `defsetf`, because "
"the `setf` method defined by `defsetf` never sees *list* itself.\n"
"Instead, it sees a local variable that is automatically bound to the value "
"of *list.* In other words, `defsetf` evaluates the *list* and *val* for you, "
"so that you needn't worry about evaluating the arguments out of order, or "
"more than once."
msgstr ""
"К сожалению, в методе `setf` для `last` есть ошибка.\n"
"Предполагается, что в списке будет как минимум два элемента.\n"
"Если список пуст, вероятно, это ошибка, но если в списке ровно один элемент, "
"то (`setf` (`last`*list) val)* должно иметь тот же эффект, что и (`setf` "
"*list val).* Но нет способа сделать это с помощью `defsetf`, потому что "
"метод `setf`, определенный в `defsetf`, никогда не видит *list* сам.\n"
"Вместо этого он видит локальную переменную, которая автоматически "
"связывается со значением *list.* \n"
"Другими словами, `defsetf` вычисляет *list* и *val* за вас, так что вам не "
"нужно беспокоиться о порядке вычисления аргументов или вычислении более "
"одного раза."

#: in/chapter25.md:779
msgid ""
"To solve the problem we need to go beyond the simple `defsetf` macro and "
"delve into the complexities of `define-setf-method`, one of the trickiest "
"macros in all of Common Lisp.\n"
"`define-setf-method` defines a setf method not by writing code directly but "
"by specifying five values that will be used by Common Lisp to write the code "
"for a call to `setf`.\n"
"The five values give more control over the exact order in which expressions "
"are evaluated, variables are bound, and results are returned.\n"
"The five values are: (1) a list of temporary, local variables used in the "
"code; (2) a list of values these variables should be bound to; (3) a list of "
"one variable to hold the value specified in the call to `setf`; (4) code "
"that will store the value in the proper place; (5) code that will access the "
"value of the place.\n"
"This is necessary for variations of `setf` like `inef` and `pop`, which need "
"to both access and store."
msgstr ""
"Чтобы решить эту проблему, нам нужно выйти за рамки простого макроса "
"`defsetf` и углубиться в сложности `define-setf-method`, одного из самых "
"сложных макросов во всем Common Lisp.\n"
"`define-setf-method` определяет метод setf не путем написания кода напрямую, "
"а путем указания пяти значений, которые будут использоваться Common Lisp для "
"написания кода для вызова `setf`.\n"
"Пять значений дают больший контроль над точным порядком, в котором "
"вычисляются выражения, связываются переменные и возвращаются результаты.\n"
"Пятью значениями являются: (1) список временных локальных переменных, "
"используемых в коде; (2) список значений, с которыми должны быть связаны эти "
"переменные; (3) список из одной переменной для хранения значения, указанного "
"в вызове `setf`; (4) код, который сохранит значение в нужном месте; (5) код, "
"который будет иметь доступ к значению места.\n"
"Это необходимо для таких вариантов `setf`, как `inef` и `pop`, которые "
"требуют и доступа, и сохранения."

#: in/chapter25.md:785
msgid ""
"In the following `setf` method for `last`, then, we are defining the meaning "
"of (`setf` (`last place`) `value`).\n"
"We keep track of all the variables and values needed to evaluate `place`, "
"and add to that three more local variables: `last2`-var will hold the last "
"two elements of the list, `last2`-p will be true only if there are two or "
"more elements in the list, and `last-var` will hold the form to access the "
"last element of the list.\n"
"We also make up a new variable, `result`, to hold the `value`.\n"
"The code to store the value either modifies the cdr of `last2-var`, if the "
"list is long enough, or it stores directly into `place`.\n"
"The code to access the value just retrieves `last - var`."
msgstr ""
"В следующем методе `setf` для `last` мы определяем значение (`setf` (`last "
"place`) `value`).\n"
"Мы отслеживаем все переменные и значения, необходимые для вычисления "
"`place`, и добавляем к ним еще три локальные переменные: `last2-var` будет "
"содержать два последних элемента списка, `last2-p` будет истинным, только "
"если в списке два или более элемента, а `last-var` будет содержать форму для "
"доступа к последнему элементу списка.\n"
"Мы также создаем новую переменную `result` для хранения значения `value`.\n"
"Код для сохранения значения либо изменяет cdr для `last2-var`, если список "
"достаточно длинный, либо сохраняет непосредственно в `place`(место).\n"
"Код для доступа к значению просто извлекает `last-var`."

#: in/chapter25.md:807
msgid ""
"```lisp\n"
"(define-setf-method last (place)\n"
"  (multiple-value-bind (temps vais stores store-form access-form)\n"
"        (get-setf-method place)\n"
"    (let ((result (gensym))\n"
"          (last2-var (gensym))\n"
"          (last2-p (gensym))\n"
"          (last-var (gensym)))\n"
"        ;; Return 5 vais: temps vais stores store-form access-form\n"
"        (values\n"
"          '(.@temps .last2-var .last2-p .last-var)\n"
"          '(.@vais (last2 .access-form)\n"
"            (= (length .last2-var) 2)\n"
"            (if .last2-p (rest .last2-var) .access-form))\n"
"          (list result)\n"
"          '(if .last2-p\n"
"            (setf (cdr .last2-var) .result)\n"
"            (let ((.(first stores) .result))\n"
"              .store-form))\n"
"          last-var))))\n"
"```"
msgstr ""

#: in/chapter25.md:815
msgid ""
"It should be mentioned that `setf` methods are very useful and powerful "
"things.\n"
"It is often better to provide a `setf` method for an arbitrary function, "
"`f`, than to define a special setting function, say, `set-f`.\n"
"The advantage of the `setf` method is that it can be used in idioms like "
"`incf` and `pop`, in addition to `setf` itself.\n"
"Also, in ANSI Common Lisp, it is permissible to name a function with # "
"' (`setf f`), so you can also use map or apply the `setf` method.\n"
"Most `setf` methods are for functions that just access data, but it is "
"permissible to define `setf` methods for functions that do any computation "
"whatsoever.\n"
"As a rather fanciful example, here is a `setf` method for the square-root "
"function.\n"
"It makes (`setf (sqrt x) 5`) be almost equivalent to (`setf x (* 5 5)`) ; "
"the difference is that the first returns 5 while the second returns 25."
msgstr ""
"Следует отметить, что методы `setf` - очень полезные и мощные вещи.\n"
"Часто лучше предоставить метод `setf` для произвольной функции `f`, чем "
"определять специальную функцию настройки, скажем, `set-f`.\n"
"Преимущество метода `setf` в том, что он может использоваться в идиомах, "
"таких как `incf` и `pop`, в дополнение к самому `setf`.\n"
"Кроме того, в ANSI Common Lisp разрешено называть функцию #'(`setf f`), "
"поэтому вы также можете использовать map или apply с методом `setf`.\n"
"Большинство методов `setf` предназначены для функций, которые просто "
"обращаются к данным, но допустимо определять методы setf для функций, "
"которые выполняют какие-либо вычисления.\n"
"В качестве довольно причудливого примера приведем метод setf для функции "
"извлечения квадратного корня.\n"
"Она делает (`setf (sqrt x) 5`) почти эквивалентным (`setf x (* 5 5)`); "
"разница в том, что первый возвращает 5, а второй - 25."

#: in/chapter25.md:829
msgid ""
"```lisp\n"
"(define-setf-method sqrt (num)\n"
"  (multiple-value-bind (temps vals stores store-form access-form)\n"
"        (get-setf-method num)\n"
"    (let ((store (gensym)))\n"
"        (values temps\n"
"                    vals\n"
"                    (list store)\n"
"                    '(let ((,(first stores) (* .store .store)))\n"
"                        ,store-form\n"
"                        ,store)\n"
"                    '(sqrt .access-form)))))\n"
"```"
msgstr ""

#: in/chapter25.md:833
msgid ""
"Turning from `setf` methods back to macros, another hard part about writing "
"portable macros is anticipating what compilers might warn about.\n"
"Let's go back to the `dotree` macro.\n"
"Its definition might look in part like this:"
msgstr ""
"Возвращаясь от методов `setf` к макросам, еще одна сложная часть написания "
"переносимых макросов - это предвидеть, о чем могут предупреждать "
"компиляторы.\n"
"Вернемся к макросу `dotree`.\n"
"Частично его определение может выглядеть так:"

#: in/chapter25.md:838
msgid ""
"```lisp\n"
"(defmacro dotree ((var tree &optional result) &body body)\n"
"  \"Perform body with var bound to every leaf of tree.\n"
"```"
msgstr ""

#: in/chapter25.md:841
msgctxt "in/chapter25.md:841"
msgid ""
"`  then return result.\n"
"Return and Go can be used in body.\"`"
msgstr ""

#: in/chapter25.md:847
msgid ""
"```lisp\n"
"  '(let ((.var))\n"
"      ...\n"
"      ,@body))\n"
"```"
msgstr ""

#: in/chapter25.md:849
msgid "Now suppose a user decides to count the leaves of a tree with:"
msgstr ""
"Теперь предположим, что пользователь решает подсчитать листья дерева с "
"помощью:"

#: in/chapter25.md:855
msgid ""
"```lisp\n"
"(let ((count 0))\n"
"    (dotree (leaf tree count)\n"
"        (incf count)))\n"
"```"
msgstr ""

#: in/chapter25.md:858
msgid ""
"The problem is that the variable `leaf` is not used in the body of the "
"macro, and a compiler may well issue a warning to that effect.\n"
"To make matters worse, a conscientious user might write:"
msgstr ""
"Проблема в том, что переменная `leaf` не используется в теле макроса, и "
"компилятор вполне может выдать предупреждение об этом.\n"
"Что еще хуже, добросовестный пользователь может написать:"

#: in/chapter25.md:865
msgid ""
"```lisp\n"
"(let ((count 0))\n"
"  (dotree (leaf tree count)\n"
"    (declare (ignore leaf))\n"
"      (incf count)))\n"
"```"
msgstr ""

#: in/chapter25.md:867
msgid ""
"The designer of a new macro must decide if declarations are allowed and must "
"make sure that compiler warnings will not be generated unless they are "
"warranted."
msgstr ""
"Разработчик нового макроса должен решить, разрешены ли объявления, и должен "
"убедиться, что предупреждения компилятора не будут генерироваться, если они "
"не требуются"

#: in/chapter25.md:870
msgid ""
"Macros have the full power of Lisp at their disposal, but the macro designer "
"must remember the purpose of a macro is to translate macro code into "
"primitive code, and not to do any computations.\n"
"Consider the following macro, which assumes that `translate - rule-body` is "
"defined elsewhere:"
msgstr ""
"Макросы имеют в своем распоряжении всю мощь Лиспа, но разработчик макросов "
"должен помнить, что цель макроса - преобразовать код макроса в "
"примитивный(обычный) код, а не выполнять какие-либо вычисления.\n"
"Рассмотрим следующий макрос, который предполагает, что `translate-rule-body` "
"определено где-то еще:"

#: in/chapter25.md:873
msgid ""
"`(defmacro defrule (name &body body)    ; Warning!\n"
"buggy!`"
msgstr ""

#: in/chapter25.md:879
msgid ""
"```lisp\n"
"  \"Define a new rule with the given name.\"\n"
"  (setf (get name 'rule)\n"
"        '#'(lambda O ,(translate-rule-body body))))\n"
"```"
msgstr ""

#: in/chapter25.md:883
msgid ""
"The idea is to store a function under the `rule` property of the rule's "
"name.\n"
"But this definition is incorrect because the function is stored as a side "
"effect of expanding the macro, rather than as an effect of executing the "
"expanded macro code.\n"
"The correct definition is:"
msgstr ""
"Идея состоит в том, чтобы сохранить функцию под свойством `rule` имени "
"правила.\n"
"Но это определение неверно, потому что функция сохраняется как побочный "
"эффект расширения макроса, а не как результат выполнения расширенного кода "
"макроса.\n"
"Правильное определение:"

#: in/chapter25.md:890
msgid ""
"```lisp\n"
"(defmacro defrule (name &body body)\n"
"  \"Define a new rule with the given name.\"\n"
"  '(setf (get '.name 'rule)\n"
"  #'(lambda () .(translate-rule-body body))))\n"
"```"
msgstr ""

#: in/chapter25.md:893
msgid ""
"Beginners sometimes fail to see the difference between these two approaches, "
"because they both have the same result when interpreting a file that makes "
"use of `defrule`.\n"
"But when the file is compiled and later loaded into a different Lisp image, "
"the difference becomes clear: the first definition erroneously stores the "
"function in the compiler's image, while the second produces code that "
"correctly stores the function when the code is loaded."
msgstr ""
"Новички иногда не видят разницы между этими двумя подходами, потому что оба "
"они дают одинаковый результат при интерпретации файла, который использует "
"`defrule`.\n"
"Но когда файл компилируется и позже загружается в другой образ Лиспа, "
"разница становится очевидной: первое определение ошибочно сохраняет функцию "
"в скомпилированном образе, а второе создает код, который правильно сохраняет "
"функцию при загрузке кода."

#: in/chapter25.md:896
msgid ""
"Beginning macro users have asked, \"How can I have a macro that expands into "
"code that does more than one thing?\n"
"Can I splice in the results of a macro?\""
msgstr ""
"Начинающие пользователи макросов спрашивают: \"Как я могу получить макрос, "
"который расширяется в код, который выполняет более одного действия?\n"
"Могу ли я соединить результаты макроса? \""

#: in/chapter25.md:900
msgid ""
"If by this the beginner wants a macro that just *does* two things, the "
"answer is simply to use a progn.\n"
"There will be no efficiency problem, even if the progn forms are nested.\n"
"That is, if macro-expansion results in code like:"
msgstr ""
"Если по этому поводу новичку нужен макрос, который просто *делает* две вещи, "
"ответ - просто использовать progn.\n"
"Не будет проблем с эффективностью, даже если формы  progn вложены.\n"
"То есть, если расширение макроса приводит к такому коду:"

#: in/chapter25.md:904
msgid ""
"```lisp\n"
"(progn (progn (progn *a b*) c) (progn *d e))*\n"
"```"
msgstr ""

#: in/chapter25.md:906
msgid "the compiler will treat it the same as `(progn *abc de).*`"
msgstr "компилятор будет относиться к нему так же, как `(progn *abc de).*`"

#: in/chapter25.md:913
msgid ""
"On the other hand, if the beginner wants a macro that *returns* two values, "
"the proper form is val ues, but it must be understood that the calling "
"function needs to arrange specially to see both values.\n"
"There is no way around this limitation.\n"
"That is, there is no way to write a macro-or a function for that matter-that "
"will \"splice in\" its results to an arbitrary call.\n"
"For example, the function `floor` returns two values (the quotient and "
"remainder), as does i ntern (the symbol and whether or not the symbol "
"already existed).\n"
"But we need a special form to capture these values.\n"
"For example, compare:"
msgstr ""
"С другой стороны, если новичок хочет макрос, который *возвращает* два "
"значения, правильная форма - это значения, но следует понимать, что "
"вызывающая функция должна быть организована специально, чтобы видеть оба "
"значения.\n"
"Это ограничение невозможно обойти.\n"
"То есть, нет способа написать макрос - или функцию в этом отношении, - "
"который будет \"вставлять\" свои результаты в произвольный вызов.\n"
"Например, функция `floor` возвращает два значения (частное и остаток), как и "
"`intern` (символ и факт существования символа).\n"
"Но нам нужна специальная форма для перехвата этих значений.\n"
"Например, сравните:"

#: in/chapter25.md:919
msgid ""
"```lisp\n"
"> (list (floor 11 5) (intern 'x))=M2 X)\n"
"> (multiple-value-call #'list\n"
"  (floor 11 5) (intern 'x))=>(2 1 X :INTERNAL)\n"
"```"
msgstr ""

#: in/chapter25.md:921
msgid "## 25.15 A Style Guide to Lisp"
msgstr "## 25.15 Руководство по Стилю Lisp"

#: in/chapter25.md:924
msgid ""
"In a sense, this whole book is a style guide to writing quality Lisp "
"programs.\n"
"But this section attempts to distill some of the lessons into a set of "
"guidelines."
msgstr ""
"В некотором смысле, вся эта книга представляет собой руководство по стилю "
"написания качественных программ на Лиспе.\n"
"Но в этом разделе делается попытка обобщить некоторые уроки в виде набора "
"рекомендаций."

#: in/chapter25.md:926
msgid "### When to Define a Function"
msgstr "### Когда определять Функцию"

#: in/chapter25.md:929
msgid ""
"Lisp programs tend to consist of many short functions, in contrast to some "
"languages that prefer a style using fewer, longer functions.\n"
"New functions should be introduced for any of the following reasons:"
msgstr ""
"Программы на Lisp, как правило, состоят из множества коротких функций, в "
"отличии от некоторых языков, которые предпочитают стиль с меньшим "
"количеством более длинных функций. \n"
"Новые функции следует вводить по любой из следующих причин:"

#: in/chapter25.md:932
msgid ""
"1.  For a specific, easily stated purpose.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Для конкретной, легко формулируемой цели.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:935
msgid ""
"2.  To break up a function that is too long.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Разбить слишком длинную функцию.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:938
msgctxt "in/chapter25.md:938"
msgid ""
"3.  When the name would be useful documentation.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Когда имя пригодиться при документировании.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:941
msgid ""
"4.  When it is used in several places.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Когда этот код надо использовать в нескольких местах.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:948
msgid ""
"In (2), it is interesting to consider what \"too long\" means.\n"
"[Charniak et al.\n"
"(1987)](B9780080571157500285.xhtml#bb0180) suggested that 20 lines is the "
"limit.\n"
"But now that large bit-map displays have replaced 24-line terminals, "
"function definitions have become longer.\n"
"So perhaps one screenful is a better limit than 20 lines.\n"
"The addition of `flet` and `labels` also contributes to longer function "
"definitions."
msgstr ""
"В (2), интересно рассмотреть, что означает \"слишком длинная\".\n"
"[Charniak et al. (1987)](B9780080571157500285.xhtml#bb0180) предложил, что "
"20 строк это предел.\n"
"Но теперь когда большие растровые изображения заменили 24-строчные "
"терминалы, определения функций стали длиннее.\n"
"Так что, возможно, один экран - лучшее ограничение, чем 20 строк.\n"
"Добавление `flet` и `labels` также способствуют более длинному определению "
"функций."

#: in/chapter25.md:950
msgid "### When to Define a Special Variable"
msgstr "### Когда определять Специальные Переменные(Special Variable)"

#: in/chapter25.md:954
msgid ""
"In general, it is a good idea to minimize the use of special variables.\n"
"Lexical variables are easier to understand, precisely because their scope is "
"limited.\n"
"Try to limit special variables to one of the following uses:"
msgstr ""
"В общем, рекомендуется минимизировать использование специальных переменных.\n"
"Лексические переменные легче понять именно потому, что их область действия "
"ограничена.\n"
"Попробуйте ограничить использование специальных переменных одним из "
"следующих использований:"

#: in/chapter25.md:957
msgid ""
"1.  For parameters that are used in many functions spread throughout a "
"program.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Для параметров, которые используются во многих функциях, распределенных "
"по программе.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:960
msgid ""
"2.  For global, persistant, mutable data, such as a data base of facts.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Для глобальных, постоянных, неизменяемых данных, таких как база данных "
"фактов.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:963
msgid ""
"3.  For infrequent but deeply nested use.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Для нечастого, но глубоко вложенного использования.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:966
msgid ""
"An example of (3) might be a variable like `*standard-output*`, which is "
"used by low-level priniting functions.\n"
"It would be confusing to have to pass this variable around among all your "
"high-level functions just to make it available to `print`."
msgstr ""
"Примером (3) может быть такая переменная, как `*standard-output*`, которая "
"используется низкоуровневыми функциями печати.\n"
"Было бы непросто передавать эту переменную среди всех ваших высокоуровневых "
"функций только для того, чтобы сделать ее доступной для `print`"

#: in/chapter25.md:968
msgid "### When to Bind a Lexical Variable"
msgstr "### Когда связывать лексическую переменную"

#: in/chapter25.md:971
msgid ""
"In contrast to special variables, lexical variables are encouraged.\n"
"You should feel free to introduce a lexical variable (with `a let, lambda` "
"or `defun`) for any of the following reasons:"
msgstr ""
"В отличие от специальных переменных, использование лексических переменных "
"приветствуется.\n"
"Вы можете свободно вводить лексическую переменную (с `let`, `lambda` или "
"`defun`) по любой из следующих причин:"

#: in/chapter25.md:974
msgid ""
"1.  To avoid typing in the same expression twice.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Чтобы не вводить одно и то же выражение дважды.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:977
msgid ""
"2.  To avoid computing the same expression twice.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Чтобы не вычислять одно и то же выражение дважды.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:980
msgctxt "in/chapter25.md:980"
msgid ""
"3.  When the name would be useful documentation.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Когда название пригодится для документации.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:983
msgid ""
"4.  To keep the indentation manageable.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Чтобы отступы оставались управляемыми.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:985
msgid "### How to Choose a Name"
msgstr "### Как выбрать имя"

#: in/chapter25.md:988
msgid ""
"Your choice of names for functions, variables, and other objects should be "
"clear, meaningful, and consistent.\n"
"Some of the conventions are listed here:"
msgstr ""
"Выбранные вами имена для функций, переменных и других объектов должны быть "
"ясными, значимыми и последовательными.\n"
"Некоторые из соглашений перечислены здесь:"

#: in/chapter25.md:991
msgid ""
"1.  Use mostly letters and hyphens, and use full words: `delete-file`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1. Используйте в основном буквы и дефисы и используйте полные слова: `delete-"
"file`..\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:995
msgid ""
"2.  You can introduce an abbreviation if you are consistent: `get-dtree`, "
"`dtree-fetch`.\n"
"For example, this book uses `fn` consistently as the abbreviation for "
"\"function.\"\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Вы можете ввести аббревиатуру, если будете последовательны: `get-dtree`,"
"` dtree-fetch`.\n"
"Например, в этой книге `fn` постоянно используется как сокращение от слова "
"\"function.\".\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:998
msgid ""
"3.  Predicates end in - `p` (or ? in Scheme), unless the name is already a "
"predicate: `variable-p`, `occurs-in`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Предикаты оканчиваются на - `p` (или ? В Scheme), если имя уже не "
"является предикатом: `variable-p`, `plays-in`.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1001
msgid ""
"4.  Destructive functions start with n (or end in ! in Scheme): nreverse.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Разарушающие функции начинаются с n (или заканчиваются ! в Scheme): "
"nreverse.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1005
msgid ""
"5.  Generalized variable-setting macros end in `f`: `setf`, `incf`.\n"
"(`Push` is an exception.)\n"
"!!!(p) {:.numlist}"
msgstr ""
"5.  Обобщенные макросы установки переменных заканчиваются на  `f`: `setf`, "
"`incf`.\n"
"(`Push` это исключение.)\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1008
msgid ""
"6.  Slot selectors created by `defstruct` are of the form *type-slot.* Use "
"this for `non-defstruct` selectors as well: `char-bits`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"6.  Селекторы слотов, созданные `defstruct`, имеют вид *type-slot.* "
"Используйте это также для селекторов `non-defstruct`: `char-bits`.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1011
msgid ""
"7.  Many functions have the form *action-object:*`copy-list, delete-file`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"7.  Многие функции имеют вид *объект-действие:* `copy-list, delete-file`.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1016
msgid ""
"8.  Other functions have the form *object-modifier:*`list-length, char-"
"lessp`.\n"
"Be consistent in your choice between these two forms.\n"
"Don't have `print-edge` and `vertex-print` in the same system.\n"
"!!!(p) {:.numlist}"
msgstr ""
"8.  Другие функции имеют вид *объекта-модификатор:* `list-length, char-"
"lessp`.\n"
"Будьте последовательны в выборе между этими двумя формами.\n"
"Не используйте `print-edge` и `vertex-print` в одной системе.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1020
msgid ""
"9.  A function of the form *modulename-functionname* is an indication that "
"packages are needed.\n"
"Use parser: `print-tree` instead of `parser-print-tree`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"9.  Функция в форме *имя модуля-имя функции* указывает на то, что необходимо "
"использовать пакеты.\n"
"Используйте пакет parser:`print-tree` вместо `parser-print-tree`.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1023
msgid ""
"10.  Special variables have asterisks: `*db*, *print-length*`.\n"
"!!!(p) {:.numlista}"
msgstr ""
"10.  Специальные переменные отмечены звездочками: `*db*, *print-length*`.\n"
"!!!(p) {:.numlista}"

#: in/chapter25.md:1026
msgid ""
"11.  Constants do not have asterisks: `pi, most-positive-fixnum`.\n"
"!!!(p) {:.numlista}"
msgstr ""
"11.  Константы не имеют звездочек: `pi, most-positive-fixnum`.\n"
"!!!(p) {:.numlista}"

#: in/chapter25.md:1029
msgid ""
"12.  Parameters are named by type: (`defun length (sequence) ...)` or by "
"purpose: (`defun subsetp(subset superset) ...`) or both: (`defun / (number "
"&rest denominator-numbers) ...`)\n"
"!!!(p) {:.numlista}"
msgstr ""
"12. Параметры именуются по типу: (`defun length (sequence) ...)` или по "
"назначению: (`defun subsetp(subset superset) ...`) или обоим: (`defun / "
"(number &rest denominator-numbers) ...`)\n"
"!!!(p) {:.numlista}"

#: in/chapter25.md:1033
msgid ""
"13.  Avoid ambiguity.\n"
"A variable named `last-node` could have two meanings; use `previous` -`node` "
"or `final` - `node` instead.\n"
"!!!(p) {:.numlista}"
msgstr ""
"13.  Избегайте двусмысленности.\n"
"Переменная с именем `last-node` может иметь два значения; используйте вместо "
"них `previous`-`node` или `final`-`node`. \n"
"!!!(p) {:.numlista}"

#: in/chapter25.md:1037
msgid ""
"14.  A name like `propagate-constraints-to-neighboring-vertexes` is too "
"long, while `prp-con` is too short.\n"
"In deciding on length, consider how the name will be used: `propagate-"
"constraints` is just right, because a typical call will be `(propagate-const "
"rai nts vertex)`, so it will be obvious what the constraints are propagating "
"to.\n"
"!!!(p) {:.numlista}"
msgstr ""
"14.  Имя типа `propagate-constraints-to-neighboring-vertexes` слишком "
"длинное, а `prp-con` - слишком короткое.\n"
"Принимая решение о длине, подумайте о том, как будет использоваться имя: "
"`spread-constraints` в самый раз, потому что типичным вызовом будет `(spread-"
"const rai nts vertex)`, поэтому будет очевидно, на что распространяются "
"ограничения .\n"
"!!!(p) {:.numlista}"

#: in/chapter25.md:1039
msgid "### Deciding on the Order of Parameters"
msgstr "### Определение порядка параметров"

#: in/chapter25.md:1042
msgid ""
"Once you have decided to define a function, you must decide what parameters "
"it will take, and in what order.\n"
"In general,"
msgstr ""
"После того, как вы решили определить функцию, вы должны решить, какие "
"параметры она будет принимать и в каком порядке.\n"
"В общем,"

#: in/chapter25.md:1045
msgid ""
"1.  Put important parameters first (and optional ones last).\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Поместите важные параметры первыми (а необязательные - последними).\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1048
msgid ""
"2.  Make it read like prose if possible: (`push element stack`).\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  По возможности сделайте его читаемым как прозу: (`push element stack`).\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1051
msgid ""
"3.  Group similar parameters together.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3. Сгруппируйте похожие параметры вместе.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1056
msgid ""
"Interestingly, the choice of a parameter list for top-level functions (those "
"that the user is expected to call) depends on the environment in which the "
"user will function.\n"
"In many systems the user can type a keystroke to get back the previous input "
"to the top level, and can then edit that input and re-execute it.\n"
"In these systems it is preferable to have the parameters that are likely to "
"change be at the end of the parameter list, so that they can be easily "
"edited.\n"
"On systems that do not offer this kind of editing, it is better to either "
"use keyword parameters or make the highly variable parameters first in the "
"list (with the others optional), so that the user will not have to type as "
"much."
msgstr ""
"Интересно, что выбор списка параметров для функций верхнего уровня (тех, "
"которые, как ожидается, будет вызывать пользователь) зависит от среды, в "
"которой будет работать пользователь.\n"
"Во многих системах пользователь может нажать клавишу, чтобы вернуть "
"предыдущий ввод на верхний уровень, а затем может отредактировать этот ввод "
"и повторно выполнить его.\n"
"В этих системах предпочтительно, чтобы параметры, которые могут измениться, "
"были в конце списка параметров, чтобы их можно было легко редактировать.\n"
"В системах, которые не предлагают такой вид редактирования, лучше либо "
"использовать параметры ключевые слова, либо сделать параметры с высокой "
"степенью вариабельности первыми в списке (с другими необязательными), чтобы "
"пользователю не приходилось печатать так много."

#: in/chapter25.md:1060
msgid ""
"Many users want to have *required* keyword parameters.\n"
"It turns out that all keyword parameters are optional, but the following "
"trick is equivalent to a required keyword parameter.\n"
"First we define the function `required` to signal an error, and then we use "
"a call to `required` as the default value for any keyword that we want to "
"make required:"
msgstr ""
"Многие пользователи хотят иметь *обязательные* параметры ключевые слова.\n"
"Оказывается, что все параметры ключевого слова необязательны, но следующий "
"трюк эквивалентен обязательному параметру ключевого слова.\n"
"Сначала мы определяем функцию `required`, чтобы сигнализировать об ошибке, а "
"затем мы используем вызов `required` в качестве значения по умолчанию для "
"любого ключевого слова, которое мы хотим сделать обязательным:"

#: in/chapter25.md:1067
msgid ""
"```lisp\n"
"(defun required ()\n"
"  (error \"A required keyword argument was not supplied.\"))\n"
"(defun fn (x &key (y (required)))\n"
"  ...)\n"
"```"
msgstr ""

#: in/chapter25.md:1069
msgid "## 25.16 Dealing with Files, Packages, and Systems"
msgstr "## 25.16 Работа с файлами, пакетами и системами"

#: in/chapter25.md:1072
msgid ""
"While this book has covered topics that are more advanced than any other "
"Lisp text available, it is still concerned only with programming in the "
"small: a single project at a time, capable of being implemented by a single "
"programmer.\n"
"More challenging is the problem of programming in the large: building "
"multiproject, multiprogrammer systems that interact well."
msgstr ""
"Хотя эта книга охватывает темы, которые являются более сложными, чем любой "
"другой доступный текст на Лиспе, она по-прежнему касается только "
"программирования в малых масштабах: по одному проекту за раз, который может "
"быть реализован одним программистом.\n"
"Более сложная проблема программирования в целом: построение многопроектных, "
"многопрограммных систем, которые хорошо взаимодействуют друг с другом."

#: in/chapter25.md:1074
msgid ""
"This section briefly outlines an approach to organizing a larger project "
"into man-ageable components, and how to place those components in files."
msgstr ""
"В этом разделе кратко описывается подход к организации более крупного "
"проекта в управляемые компоненты, а также способы размещения этих "
"компонентов в файлах."

#: in/chapter25.md:1077
msgid ""
"Every system should have a separate file that defines the other files that "
"comprise the system.\n"
"I recommend defining any packages in that file, although others put package "
"definitions in separate files."
msgstr ""
"Каждая система должна иметь отдельный файл, определяющий другие файлы, "
"составляющие систему.\n"
"Я рекомендую определять любые пакеты в этом файле, хотя другие помещают "
"определения пакетов в отдельные файлы."

#: in/chapter25.md:1080
msgid ""
"The following is a sample file for the mythical system Project-X.\n"
"Each entry in the file is discussed in turn."
msgstr ""
"Ниже представлен образец файла мифической системы Project-X.\n"
"Каждая запись в файле обсуждается по очереди."

#: in/chapter25.md:1085
msgid ""
"1.  The first line is a comment known as the *mode line.* The text editor "
"emacs will parse the characters between -*- delimiters to discover that the "
"file contains Lisp code, and thus the Lisp editing commands should be made "
"available.\n"
"The dialect of Lisp and the package are also specified.\n"
"This notation is becoming widespread as other text editors emulate emacs's "
"conventions.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Первая строка - это комментарий, известный как *строка режима*(*mode "
"line*).  \n"
"Текстовый редактор emacs проанализирует символы между разделителями -*-, "
"чтобы обнаружить, что файл содержит код Лиспа, и поэтому команды "
"редактирования Лиспа должны быть доступны.\n"
"Также указывается диалект Lisp и пакет.\n"
"Эта нотация становится широко распространенной, поскольку другие текстовые "
"редакторы подражают соглашениям emacs.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1088
msgid ""
"2.  Each file should have a description of its contents, along with "
"information on the authors and what revisions have taken place.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Каждый файл должен иметь описание его содержимого, а также информацию об "
"авторах и внесенных изменениях.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1092
msgid ""
"3.  Comments with four semicolons (`;;;;`) denote header lines.\n"
"Many text editors supply a command to print all such lines, thus achieving "
"an outline of the major parts of a file.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Комментарии с четырьмя точками с запятой (`;;;;`) обозначают строки "
"заголовка.\n"
"Многие текстовые редакторы предоставляют команду для печати всех таких "
"строк, таким образом достигая контура основных частей файла.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1097
msgid ""
"4.  The first executable form in every file should be an `in-package`.\n"
"Here we use the user package.\n"
"We will soon create the `project-x package`, and it will be used in all "
"subsequent files.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Первая исполняемая форма в каждом файле должна быть `in-package`.\n"
"Здесь мы используем пользовательский пакет.\n"
"Вскоре мы создадим пакет `project-x`, и он будет использоваться во всех "
"последующих файлах.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1101
msgid ""
"5.  We want to define the Project-X system as a collection of files.\n"
"Unfortunately, Common Lisp provides no way to do that, so we have to load "
"our own system-definition functions explicitly with a call to `load`.\n"
"!!!(p) {:.numlist}"
msgstr ""
"5.  Мы хотим определить систему Project-X как набор файлов.\n"
"К сожалению, Common Lisp не предоставляет возможности сделать это, поэтому "
"мы должны явно загружать наши собственные функции определения системы с "
"помощью вызова `load`.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1107
msgid ""
"6.  The call to `define - system` specifies the files that make up Project-"
"X.\n"
"We provide a name for the system, a directory for the source and object "
"files, and a list of *modules* that make up the system.\n"
"Each module is a list consisting of the module name (a symbol) followed by a "
"one or more files (strings or pathnames).\n"
"We have used keywords as the module names to eliminate any possible name "
"conflicts, but any symbol could be used.\n"
"!!!(p) {:.numlist}"
msgstr ""
"6.  Вызов функции `define-system` указывает файлы, из которых состоит "
"Project-X.\n"
"Мы предоставляем имя для системы, каталог для исходных и объектных файлов, а "
"также список *модулей*, составляющих систему.\n"
"Каждый модуль представляет собой список, состоящий из имени модуля "
"(символа), за которым следует один или несколько файлов (строки или пути).\n"
"Мы использовали ключевые слова в качестве имен модулей, чтобы исключить "
"любые возможные конфликты имен, но можно использовать любой символ.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1111
msgid ""
"7.  The call to `defpackage` defines the package `project-x`.\n"
"For more on packages, see section 24.1.\n"
"!!!(p) {:.numlist}"
msgstr ""
"7.  Вызов `defpackage` определяет пакет `project-x`.\n"
"Подробнее о пакетах см. Раздел 24.1.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1114
msgid ""
"8.  The final form prints instructions on how to load and run the system.\n"
"!!!(p) {:.numlist}"
msgstr ""
"8.  В окончательной форме печатаются инструкции о том, как загрузить и "
"запустить систему.\n"
"!!!(p) {:.numlist}"

#: in/chapter25.md:1138
msgid ""
"```lisp\n"
";;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: User -*-\n"
";;; (Brief description of system here.)\n"
";;;; Define the Project-X system.\n"
"(in-package \"USER\")\n"
"(load \"/usr/norvig/defsys.lisp\") ; load define-system\n"
"(define-system ;; Define the system Project-X\n"
"  :name :project-x\n"
"  :source-dir \"/usr/norvig/project-x/*.lisp\"\n"
"  :object-dir \"/usr/norvig/project-x/*.bin\"\n"
"  :modules '((:macros \"header\" \"macros\")\n"
"    (:main \"parser\" \"transformer\" \"optimizer\"\n"
"        \"commands\" \"database\" \"output\")\n"
"    (:windows \"xwindows\" \"clx\" \"client\")))\n"
"(defpackage :project-x ;; Define the package Project-X\n"
"  (:export \"DEFINE-X\" \"DO-X\" \"RUN-X\")\n"
"  (:nicknames \"PX\")\n"
"  (:use common-lisp))\n"
"(format *debug-io* To load the Project-X system, type\n"
"  (make-system marne :project-x)\n"
"To run the system, type\n"
"  (project-x:run-x)\")\n"
"```"
msgstr ""

#: in/chapter25.md:1140
msgid "Each of the files that make up the system will start like this:"
msgstr ""
"Каждый из файлов, составляющих систему, будет запускаться следующим образом:"

#: in/chapter25.md:1145
msgid ""
"```lisp\n"
";;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: Project-X -*-\n"
"(in-package \"PROJECT-X\")\n"
"```"
msgstr ""

#: in/chapter25.md:1152
msgid ""
"Now we need to provide the system-definition functions, `define-system` and "
"`make-system`.\n"
"The idea is that `define-system` is used to define the files that make up a "
"system, the modules that the system is comprised of, and the files that make "
"up each module.\n"
"It is necessary to group files into modules because some files may depend on "
"others.\n"
"For example, all macros, special variables, constants, and inline functions "
"need to be both compiled and loaded before any other files that reference "
"them are compiled.\n"
"In Project-X, all `defvar, defparameter, defconstant,` and `defstruct`[3]"
"(#fn0020) forms are put in the file header, and all defmacro forms are put "
"in the file macros.\n"
"Together these two files form the first module, named : macros, which will "
"be loaded before the other two modules (: `main` and :`windows`) are "
"compiled and loaded."
msgstr ""
"Теперь нам нужно предоставить функции определения системы, `define-system` и "
"`make-system`.\n"
"Идея состоит в том, что `define-system` используется для определения файлов, "
"составляющих систему, модулей, из которых система состоит, и файлов, "
"составляющих каждый модуль.\n"
"Необходимо сгруппировать файлы в модули, потому что одни файлы могут "
"зависеть от других.\n"
"Например, все макросы, специальные переменные, константы и встроенные "
"функции должны быть скомпилированы и загружены до компиляции любых других "
"файлов, которые на них ссылаются.\n"
"В Project-X все формы `defvar`, `defparameter`, `defconstant` и `defstruct` "
"[3](# fn0020) помещаются в заголовок файла, а все формы `defmacro` "
"помещаются в файл macros.\n"
"Вместе эти два файла образуют первый модуль с именем : macros, который будет "
"загружен до компиляции и загрузки двух других модулей (:`main` и :`windows`)."

#: in/chapter25.md:1155
msgid ""
"define-system also provides a place to specify a directory where the source "
"and object files will reside.\n"
"For larger systems spread across multiple directories, `define - system` "
"will not be adequate."
msgstr ""
"define-system также предоставляет место для указания каталога, в котором "
"будут находиться исходный и объектный файлы.\n"
"Для больших систем, разбросанных по нескольким каталогам, `define-system` не "
"подходит."

#: in/chapter25.md:1157
msgid ""
"Here is the first part of the file `defsys.lisp`, showing the definition of "
"`define-system` and the structure sys."
msgstr ""
"Вот первая часть файла `defsys.lisp`, в которой показано определение `define-"
"system` и структура sys."

#: in/chapter25.md:1169
msgid ""
"```lisp\n"
";;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: User -*-\n"
"; ; ; ; A Facility for Defining Systems and their Components\n"
"(in-package \"USER\")\n"
"(defvar *systems* nil \"List of all systems defined.\")\n"
"(defstruct sys\n"
"  \"A system containing a number of source and object files.\"\n"
"  name source-dir object-dir modules)\n"
"(defun define-system (&key name source-dir object-dir modules)\n"
"  \"Define a new system.\"\n"
"```"
msgstr ""

#: in/chapter25.md:1172
msgid ""
"`  ;; Delete any old system of this name.\n"
"and add the new one.`"
msgstr ""
"`  ;; Delete any old system of this name.\n"
"и добавить новый.`"

#: in/chapter25.md:1184
msgid ""
"```lisp\n"
"  (setf *systems* (delete name *systems* :test #'string-equal\n"
"      :key #'sys-name))\n"
"  (push (make-sys\n"
"      :name (string name)\n"
"      :source-dir (pathname source-dir)\n"
"      :object-dir (pathname object-dir)\n"
"      :modules '((:all ..(mapcar #'first modules)) ..modules))\n"
"    *systems*)\n"
"name)\n"
"```"
msgstr ""

#: in/chapter25.md:1190
msgid ""
"The function `make` - `systemis` used to compile and/or load a previously "
"defined system.\n"
"The name supplied is used to look up the definition of a system, and one of "
"three actions is taken on the system.\n"
"The keyword : `cload` means to compile and then load files.\n"
": `load` means to load files; if there is an object (compiled) file and it "
"is newer than the source file, then it will be loaded, otherwise the source "
"file will be loaded.\n"
"Finally, : `update` means to compile just those source files that have been "
"changed since their corresponding source files were last altered, and to "
"load the new compiled version."
msgstr ""
"Функция `make-systemis` используется для компиляции и/или загрузки ранее "
"определенной системы.\n"
"Указанное имя используется для поиска определения системы, и в системе "
"выполняется одно из трех действий.\n"
"Ключевое слово: `cload` означает компилировать, а затем загружать файлы.\n"
": `load` означает загружать файлы; если есть объектный (скомпилированный) "
"файл и он новее, чем исходный файл, то он будет загружен, иначе будет "
"загружен исходный файл.\n"
"Наконец,: `update` означает компилировать только те исходные файлы, которые "
"были изменены с момента последнего изменения соответствующих исходных "
"файлов, и загружать новую скомпилированную версию."

#: in/chapter25.md:1203
msgid ""
"```lisp\n"
"(defun make-system (&key (module : al 1 ) (action :cload)\n"
"                  (name (sys-name (first *systems*))))\n"
"    \"Compile and/or load a system or one of its modules.\"\n"
"    (let ((system (find name *systems* :key #'sys-name\n"
"            :test #'string-equal)))\n"
"      (check-type system (not null))\n"
"      (check-type action (member : cload : update :load))\n"
"      (with-compilation-unit O (sys-action module system action))\n"
"  (defun sys-action (x system action)\n"
"    \"Perform the specified action to x in this system.\n"
"```"
msgstr ""

#: in/chapter25.md:1206
msgid ""
"`    X can be a module name (symbol).\n"
"file name (string)`"
msgstr ""

#: in/chapter25.md:1232
msgid ""
"```lisp\n"
"    or a list.\"\n"
"    (typecase x\n"
"      (symbol (let ((files (rest (assoc x (sys-modules system)))))\n"
"            (if (null files)\n"
"              (warn \"No files for module ~  a\" x)\n"
"              (sys-action files system action))))\n"
"      (list (dolist (file x)\n"
"          (sys-action file system action)))\n"
"      ((string pathname)\n"
"          (let ((source (merge-pathnames\n"
"                x (sys-source-dir system)))\n"
"            (object (merge-pathnames\n"
"                x (sys-object-dir system))))\n"
"          (case action\n"
"  (:cload (compile-file source) (load object))\n"
"  (:update (unless (newer-file-p object source)\n"
"      (compile-file source))\n"
"    (load object))\n"
"  (:load (if (newer-file-p object source)\n"
"      (load object)\n"
"      (load source))))))\n"
"(t (warn \"Don't know how to ~  a \"~a in system ~  a\"\n"
"    action x system))))\n"
"```"
msgstr ""

#: in/chapter25.md:1235
msgid ""
"To support this, we need to be able to compare the write dates on files.\n"
"This is not hard to do, since Common Lisp provides the function `file-write-"
"date`."
msgstr ""
"Чтобы поддержать это, нам нужно иметь возможность сравнивать даты записи в "
"файлы.\n"
"Это несложно сделать, поскольку Common Lisp предоставляет функцию `file-"
"write-date`."

#: in/chapter25.md:1243
msgid ""
"```lisp\n"
"(defun newer-file-p (file1 file2)\n"
"  \"Is file1 newer than (written later than) file2?\"\n"
"  (>-num (if (probe-file filel) (file-write-date filel))\n"
"  (if (probe-file file2) (file-write-date file2))))\n"
"(defun >-num (x y)\n"
"```"
msgstr ""

#: in/chapter25.md:1246
msgid ""
"`  \"True if x and y are numbers.\n"
"and x > y.\"`"
msgstr ""

#: in/chapter25.md:1250
msgid ""
"```lisp\n"
"  (and (numberp x) (numberp y) (> x y)))\n"
"```"
msgstr ""

#: in/chapter25.md:1252
msgid "## 25.17 Portability Problems"
msgstr "## 25.17 Проблемы Переносимости"

#: in/chapter25.md:1258
msgid ""
"Programming is difficult.\n"
"All programmers know the frustration of trying to get a program to work "
"according to the specification.\n"
"But one thing that really defines the professional programmer is the ability "
"to write portable programs that will work on a variety of systems.\n"
"A portable program not only must work on the computer it was tested on but "
"also must anticipate the difference between your computer and other ones.\n"
"To do this, you must understand the Common Lisp specification in the "
"abstract, not just how it is implemented on your particular machine."
msgstr ""
"Программирование сложно.\n"
"Все программисты испытывают разочарование от попыток заставить программу "
"работать в соответствии со спецификацией.\n"
"Но одна вещь, которая действительно определяет профессионального "
"программиста, - это способность писать переносимые программы, которые будут "
"работать в самых разных системах.\n"
"Переносимая программа не только должна работать на компьютере, на котором "
"она была протестирована, но также должна учитывать разницу между вашим "
"компьютером и другими.\n"
"Для этого вы должны понимать спецификацию Common Lisp абстрактно, а не "
"только то, как она реализована на вашей конкретной машине."

#: in/chapter25.md:1260
msgid ""
"There are three ways in which Common Lisp systems can vary: in the treatment "
"of \"is an error\" situations, in the treatment of unspecified results, and "
"in extensions to the language."
msgstr ""
"Системы Common Lisp могут различаться тремя способами: при обработке "
"ситуаций \"является ошибкой\", при обработке неопределенных результатов и "
"при использовании расширений языка."

#: in/chapter25.md:1266
msgid ""
"*Common Lisp the Language* specifies that it \"is an error\" to pass a non-"
"number to an arithmetic function.\n"
"For example, it is an error to evaluate (`+ nil 1`).\n"
"However, it is not specified what should be done in this situation.\n"
"Some implementations may signal an error, but others may not.\n"
"An implementation would be within its right to return 1, or any other number "
"or non-number as the result."
msgstr ""
"*Common Lisp the Language * указывает, что передача нечисловой функции "
"арифметической функции является \"ошибкой\".\n"
"Например, вычисление (`+ nil 1`) является ошибкой.\n"
"Однако не уточняется, что делать в этой ситуации.\n"
"Некоторые реализации могут сигнализировать об ошибке, а другие нет.\n"
"Реализация будет иметь право вернуть 1 или любое другое число или нечисловое "
"значение в качестве результата."

#: in/chapter25.md:1272
msgid ""
"An unsuspecting programmer may code an expression that is an error but still "
"computes reasonable results in his or her implementation.\n"
"A common example is applying get to a non-symbol.\n"
"This is an error, but many implementations will just return nil, so the "
"programmer may write (`get x ' prop`) when `(if ( symbol p x) (get x 'prop) "
"nil`) is actually needed for portable code.\n"
"Another common problem is with subseq and the sequence functions that take : "
"end keywords.\n"
"It is an error if the : end parameter is not an integer less than the length "
"of the sequence, but many implementations will not complain if : end is nil "
"or is an integer greater than the length of the sequence."
msgstr ""
"Ничего не подозревающий программист может закодировать выражение, которое "
"является ошибкой, но все же вычислит разумные результаты в своей "
"реализации.\n"
"Типичный пример - применение get к несимволу.\n"
"Это ошибка, но многие реализации просто возвращают nil, поэтому программист "
"может написать (`get x 'prop`), когда `(if (symbol p x) (get x 'prop) nil`) "
"действительно необходимо для переносимого кода.\n"
"Еще одна распространенная проблема связана с subseq и функциями "
"последовательности(sequence), которые принимают ключевые слова :end.\n"
"Будет ошибкой, если параметр :end не является целым числом меньше длины "
"последовательности, но многие реализации не будут жаловаться, если :end "
"равен нулю или является целым числом больше длины последовательности."

#: in/chapter25.md:1275
msgid ""
"The Common Lisp specification often places constraints on the result that a "
"function must compute, without fully specifying the result.\n"
"For example, both of the following are valid results:"
msgstr ""
"Спецификация Common Lisp часто накладывает ограничения на результат, который "
"должна вычислить функция, без полного определения результата.\n"
"Например, оба следующих результата являются допустимыми:"

#: in/chapter25.md:1277
msgid "`> (union '(a b c) '(b c d))`=>`(A B C D)`"
msgstr ""

#: in/chapter25.md:1279
msgid "`> (union '(a b c) '(b c d))`=>`(D A B C)`"
msgstr ""

#: in/chapter25.md:1284
msgid ""
"A program that relies on one order or the other will not be portable.\n"
"The same warning applies to `intersection` and `set-difference`.\n"
"Many functions do not specify how much the result shares with the input.\n"
"The following computation has only one possible printed result:"
msgstr ""
"Программа, которая полагается на тот или иной порядок, не будет "
"переносимой.\n"
"То же самое предупреждение относится к `intersection` и `set-difference`.\n"
"Многие функции не указывают, насколько результат разделяется с вводом.\n"
"Следующее вычисление имеет только один возможный результат печати:"

#: in/chapter25.md:1288
msgid ""
"```lisp\n"
"> (remove 'x'(a b c d)) (A B C D)\n"
"```"
msgstr ""

#: in/chapter25.md:1290
msgid ""
"However, it is not specified whether the output is `eq` or only `equal` to "
"the second input."
msgstr ""
"Однако не указывается, является ли вывод `eq` или только `equal` второму "
"вводу."

#: in/chapter25.md:1293
msgid ""
"Input/output is particularly prone to variation, as different operating "
"systems can have very different conceptions of how I/O and the file system "
"works.\n"
"Things to watch out for are whether `read-char` echoes its input or not, the "
"need to include `finish-output`, and variationin where newlines are needed, "
"particularly with respect to the top level."
msgstr ""
"Ввод/вывод особенно подвержен вариациям, поскольку разные операционные "
"системы могут иметь очень разные представления о том, как работает ввод/"
"вывод и файловая система.\n"
"На что следует обратить внимание, это то, повторяет(отображает в виде эха на "
"терминал) ли `read-char` свой ввод или нет, необходимость включения `finish-"
"output` и варианты, где необходимы новые строки, особенно в отношении "
"верхнего уровня."

#: in/chapter25.md:1296
msgid ""
"Finally, many implementations provide extensions to Common Lisp, either by "
"adding entirely new functions or by modifying existing functions.\n"
"The programmer must be careful not to use such extensions in portable code."
msgstr ""
"Наконец, многие реализации предоставляют расширения Common Lisp либо путем "
"добавления полностью новых функций, либо путем изменения существующих "
"функций.\n"
"Программист должен быть осторожен, чтобы не использовать такие расширения в "
"переносимом коде."

#: in/chapter25.md:1298
msgid "## 25.18 Exercises"
msgstr "## 25.18 Упражнения"

#: in/chapter25.md:1303
msgid ""
"**Exercise  251 [h]** On your next programming project, keep a log of each "
"bug you detect and its eventual cause and remedy.\n"
"Classify each one according to the taxon-omy given in this chapter.\n"
"What kind of mistakes do you make most often?\n"
"How could you correct that?"
msgstr ""

#: in/chapter25.md:1307
msgid ""
"**Exercise  25.2 [s-d]** Take a Common Lisp program and get it to work with "
"a different compiler on a different computer.\n"
"Make sure you use conditional compilation read macros (#+ and #-) so that "
"the program will work on both systems.\n"
"What did you have to change?"
msgstr ""

#: in/chapter25.md:1309
msgid ""
"**Exercise  25.3 [m]** Write a `setf` method for `if` that works like this:"
msgstr ""

#: in/chapter25.md:1317
msgid ""
"```lisp\n"
"(setf (if test (first x) y) (+  2 3))=\n"
"(let ((temp (+  2 3)))\n"
"  (if test\n"
"    (setf (first x) temp)\n"
"    (setf y temp)))\n"
"```"
msgstr ""

#: in/chapter25.md:1320
msgid ""
"You will need to use `define-setf-method`, not `defsetf`.\n"
"(Why?) Make sure you handle the case where there is no else part to the `if`."
msgstr ""

#: in/chapter25.md:1322
msgid ""
"**Exercise  25.4 [h]** Write a `setf` method for `lookup`, a function to get "
"the value for a key in an association list."
msgstr ""

#: in/chapter25.md:1328
msgid ""
"```lisp\n"
"(defun lookup (key alist)\n"
"  \"Get the cdr of key's entry in the association list.\"\n"
"  (cdr (assoc key alist)))\n"
"```"
msgstr ""

#: in/chapter25.md:1330
msgid "## 25.19 Answers"
msgstr "## 25.19 Ответы"

#: in/chapter25.md:1333
msgid ""
"**Answer 25.4** Here is the setf method for `lookup`.\n"
"It looks for the key in the a-list, and if the key is there, it modifies the "
"cdr of the pair containing the key; otherwise it adds a new key/value pair "
"to the front of the a-list."
msgstr ""

#: in/chapter25.md:1353
msgid ""
"```lisp\n"
"(define-setf-method lookup (key alist-place)\n"
"  (multiple-value-bind (temps vais stores store-form access-form)\n"
"      (get-setf-method alist-place)\n"
"  (let ((key-var (gensym))\n"
"          (pair-var (gensym))\n"
"          (result (gensym)))\n"
"      (values\n"
"        '(.key-var .@temps .pair-var)\n"
"        '(.key .@vais (assoc .key-var ,access-form))\n"
"        '(.result)\n"
"        '(if .pair-var\n"
"            (setf (cdr .pair-var) .result)\n"
"            (let ((.(first stores)\n"
"                (acons ,key-var .result .access-form)))\n"
"              .store-form\n"
"              ,result))\n"
"        '(cdr .pair-var)))))\n"
"```"
msgstr ""

#: in/chapter25.md:1355
msgid "----------------------"
msgstr ""

#: in/chapter25.md:1358
msgid ""
"[1](#xfn0010) This misunderstanding has shown up even in published articles, "
"such as [Baker 1991](B9780080571157500285.xhtml#bb0060).\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter25.md:1362
msgid ""
"[2](#xfn0015) Scheme requires a list of keys in each clause.\n"
"Now you know why.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter25.md:1365
msgid ""
"[3](#xfn0020) def struct forms are put here because they may create inline "
"functions.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
