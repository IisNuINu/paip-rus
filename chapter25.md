# Глава 25
## Решение Проблем

> Возможно, если бы мы писали программы с детства, врослыми бы, смогли их читать.

> -Alan Perlis

Когда вы покупаете новое устройство, такое как телевизор, к нему прилагается буклет с инструкциями, в котором перечислены советы по устранению неполадок в следующей форме:

**Проблема**: ничего не работает.

**Диагностика**: Питание отключено.

**Устранение:** Подключите розетку и включите питание.

Если в вашем компиляторе Lisp не было такого удобного буклета с инструкциями, эта глава может быть вам полезна.
В ней перечислены некоторые из наиболее распространенных трудностей, с которыми сталкиваются программисты на Lisp.

## 25.1 Ничего не происходит

**ПРОБЛЕМА:** Вы вводите выражение в цикл Lisp read-eval-print(REPL) и не получаете ответа, ни результата, ни приглашения.

**Diagnosis:** Есть две вероятные причины по которым вывод не был напечатан: либо Lisp все еще выполняет read(чтение), либо он все еще выполняет `eval`.
Эти возможности можно разделить на четыре случая:

**Диагностика:** Если вы ввели не полное выражение, Lisp будет ждать дополнительных данных, чтобы завершить его.
Выражение может быть не полным, потому что вы непоставили правую скобку(или вставили лишнюю левую скобку). Или вы могли начать строку, атом или комментарий, не закончив их.
Это особенно сложно обнаружить когда, ошибка охватывает несколько строк.
Строка начинается и заканчивается двойными кавычками: `"string"`; atom содержащий не обычные символьные знаки, может быть ограничен вертикльными чертами: `| AN ATOM |` ; и  комментарий может иметь форму `# | a comment | #`.
Вот четыре не полных выражения:

```lisp
(+ (* 3 (sqrt 5) 1)
```

`(format t "~&X=~a, Y=~a.
x y)`

```lisp
(get '|strange-atom 'prop)
(if (= x 0) #1 test if x is zero
        y
        x)
```

**Способ устранения:** Добавьте соответственно ), ", `|`, и `| #`.
Или нажмите клавишу прерывания и введите ввод еще раз.

**Диагностика:** Возможно, ваша программа ожидает ввода.

**Устранение:** Никогда не выполняйте `(read)` без вывода какого-либо приглашения.
Если приглашение не заканчивается новой строкой, вызов `finish-output` также в порядке.
На самом деле, это хорошая идея вызвать функцию более высокого уровня, чем `read`.
Несколько систем определяют функцию `prompt-and-read`.
Вот одна из версий:

```lisp
(defun prompt-and-read (ctl-string &rest args)
  "Print a prompt and read a reply."
  (apply #'format t ctl-string args)
  (finish-output)
  (read))
```

**Диагностика:** программа может попасть в бесконечный цикл, либо в явном цикле, либо в рекурсивной функции.

**Устранение:** прервите вычисление, получив обратную трассировку и посмотрите, какие функции активны. Проверьте базовый вариант и вариант цикла для активных функций и циклов.

**Диагностика:** даже простое выражение вроде (`mapc #'sqrt list`) или (`length list`) могут вызвать бесконечный цикл если список `list` являются бесконенчым списком, то есть списком, имеющим хвост, указывающий на себя.

**Устранение:** будьте осторожны при изменении структуры с помощью `nconc`, `delete`, `setf` и так далее.

**Проблема:** вы получили новое приглашение из цикла read-eval-print(REPL), но вывод не был напечатан.

**Диагноз:** вычисленное вами выражение не должно возвращать значения, то есть результат  `(values)`.

## 25.2 Изменение переменной не имеет никакого эффекта

**Проблема:** Вы переопределили переменную, но новое значение было проигнорировано.

**Диагноз:** изменение переменной путем изменения и перевычисления формы `defvar` не изменит значения переменной, `defvar` присваивает значение только тогда, когда переменная не связана.

**Устранение:** Используйте setf для обновления переменной или измените `defvar` на `defparameter`.

**Диагноз:** обновление локально связанной переменной не влияет на переменную с тем же именем вне этой привязки.
Наример, рассмотрим:

```lisp
(defun check-ops (*ops*)
  (if (null *ops*)
          (setf *ops* *default-ops*))
  (mapcar #'check-op *ops*))
```

Если `check-ops` вызывается с нулевым(nil) аргументом, `*ops*` который является параметром `check-ops` будет изменен, но глобальный `*ops*` изменен не будет, даже если он объявлен специальным.

**Устранение:** на затеняйте переменны, которые вы хотите обновлять.
Используйте другое имя для локальной переменной.
Важно различать специальные и локальные переменные.
Придерживайтесь соглашения об именах для специальных переменных: они должны начинаться и заканчиваться звездочками.
Не забудьте ввести привязку для всех локальных переменных.
следующий отрывок из недавнего учебника является примером этой ошибки:

```lisp
(defun test ()
  (setq x 'test-data)      :*Warning!*
  (solve-problem x))        :*Don't do this.*
```

Эту функцию следовало написать так:

```lisp
(defun test ()
  (let ((x 'test-data))      :*Do this instead.*
      (solve-problem x)))
```

## 25.3 Изменение функции не имеет никакого эффекта

**Проблема:** Вы переопределили функцию, но это изменение было проигнорировано.

**Диагноз:** Когда вы меняете макрос или функцию, которая была объявлена встроеной, это изменение не обязательно будет видно пользователям измененной функции.
(Это зависит от реализации.)

**Устранение:** перекомпилируйте после изменения макроса.
Не используйте встроенные функции, пока все не будет отлажено.
(`Используйте (declare (notinline f)`) чтобы отменить объявление встраивания(inline)).

**Диагностика:** Если вы измените обычную(не встроенную) функцию, это изменение будет видно кодом, который ссылается на функцию по  *имени*, но не коду, который ссылается на старое значение функции.
Рассмотрим:

```lisp
(defparameter *scorer* #'score-fn)
(defparameter *printer* 'print-fn)
(defun show (values)
  (funcall *printer*
      (funcall *scorer* values)
      (reduce #'better values)))
```

Теперь предположим, что определения `score-fn, print-fn` и `better` были изменены.
Нужно ли прекомпилировать како-либо предыдущий код?
Переменная *`printer`* может оставаться как есть.
При её вызове, будет использоваться символ `print-fn` для определения текущего функционального значения.
Внутри show, выражение ``#'better`` компилируется в код, который получит текущую версию `better`, так что это тоже безопасно.
Однако, небходимо изменить переменную *`scorer`*.
Её значение - это старое определение `score-fn`.

**Устранение:** Вычислить заново определение *`scorer`*.
К сожалению, эта проблема побуждает многих программистов использовать символы там, где они на самом деле означают функции.
Символы будут принуждены к глобальной функции, которую они именуют, при передаче в `funcall` или `apply`, но это может быть источником другой ошибки.
В следующем примере, символ `local-fn` не будет ссылаться на локально связанную функцию.
Для ссылки на неё нужно использовать `#'local-fn`.

```lisp
(flet ((local-fn (x) ...))
  (mapcar 'local-fn list))
```

**Диагностика:** Если вы меняли название функции, вы изменили название везде?
Например, если вы решили изменить имя `print-fn` на `print-function`, но забыли изменить значение *`printer`*, то будет вызвана старая функция.

**Устранение:** Используйте команду глобальной замены в вашем редакторе.
Чтобы быть еще безопаснее, переопределите устаревшие функции на вызов `error`.
Для этого пригодиться следующая функция:

```lisp
(defun make-obsolete (fn-name)
  "Print an error if an obsolete function is called."
  (setf (symbol-function fn-name)
        #'(lambda (&rest args)
              (declare (ignore args))
              (error "Obsolete function."))))
```

**Диагностика:** Правильно ли вы используете `labels` и `flet`?
Снова рассмотрим функцию `replace-?-vars`, которая была определена в [разделе 11.3](B978008057115750011X.xhtml#s0025) для замены анонимной логической переменной на
уникальную новую переменную.

```lisp
(defun replace-?-vars (exp)
  "Replace any ? within exp with a var of the form ?123."
  (cond ((eq exp '?) (gensym "?"))
      ((atom exp) exp)
      (t (cons (replace-?-vars (first exp))
          (replace-?-vars (rest exp))))))
```

Читателю может прийти в голову, что каждый раз создавать новую переменную расточительно.
Переменные должны быть уникальными в каждом предложении, но они могут использоваться в разных предложениях.
Таким образом, мы могли бы генерироват последовательности `?1, ?2, ...`, интернировать(intern) их и, таким образом, повторнго использовать эти переменные в следующем предложении(при условии, что мы предупреждаем пользователя никогда не использовать такие имена переменных).
Один из способов сделать это- ввести локальную переменную для хранения номера переменной, а затем локальную функцию для выполнения вычислений:

```lisp
(defun replace-?-vars (exp)
  "Replace any ? within exp with a var of the form ?123."
  ;;*** Buggy Version ***
  (let ((n 0))
      (flet
        ((replace-?-vars (exp)
```

`          (cond ((eq exp '?) (symbol '?
(incf n)))`

```lisp
          ((atom exp) exp)
          (t (cons (replace-?-vars (first exp))
                  (replace-?-vars (rest exp)))))))
      (replace-?-vars exp))))
```

Эта версия не работает.
Проблема в том, что `flet`, как и `let`, определяют новую функцию в теле `flet` но не в определении новой функции.
Итак, из этого можно извлечь два урока: испоьзуйте `labels` вместо `flet` для определения рекурсивных функций, и не затеняйте определение функции локальным определением с тем же именем (это второй урок относящийся к переменным).
Давайте исправим проблему, изменив `labels` на `flet` и назвав новую функцию `recurse`:

```lisp
(defun replace-?-vars (exp)
  "Replace any ? within exp with a var of the form ?123."
  ;;*** Buggy Version ***
  (let ((n 0))
      (labels
        ((recurse (exp)
```

`          (cond ((eq exp '?) (symbol '?
(incf n)))`

```lisp
          ((atom exp) exp)
          (t (cons (replace-?-vars (first exp))
            (replace-?-vars (rest exp)))))))
        (recurse exp))))
```

К сожалению, эта версия все еще не работает!
На этот раз проблема в невнимательности; мы изменили `replace-?-vars` на `recurse` в двух местах, но не в двух вызовах в теле `recurse`.

**Устранение:** В общем, урок состоит в том, чтобы убедиться, что вы вызываете правильную функцию.
Если есть две разные функции с похожими эффектами, и вы вызываете неправильную, это может быть трудно заметить.
Это особенно актуально, если у них похожие названия.

**Проблема:** похоже, ваши замыкания не работают.

**Диагностика:** возможно, вы ошибочно создаете лямбда-выражение, используя код создаваемый консингом(конструированием списков).
Вот пример из недавнего учебника:

```lisp
(defun make-specialization (c)
  (let (pred newc)
    ...
  (setf (get newc 'predicate)
    '(lambda (obj)    :Warning
      (and ,(cons pred '(obj))    :Don't do this.
      (apply '.(get c 'predicate) (list obj)))))
    ...))
```

Строго говоря, это законно в соответствии с *Common Lisp the Language*, хотя в ANSI Common Lisp незаконно использовать a list начинающийся с `lambda` как функцию.
Но в любом случае это плохая идея.
Список начанающийся с `lambda` это просто список, а не замыкание.
Следовательно, он не может захватывать лексические переменные, как это делает замыкание.

**Устранение:** Правильный способ создать замыкание - вычислить специальную форму `function`, или ее сокращенную запись ``#'``.
Это замена для кода начинающегося с '(`lambda ....` Обратите внимание, что это замыкание, замкунтое над `pred` и `c`.
Также обратите внимание, что оно получает предикат каждый раз, когда оно вызывается; таким образом, безопасно использовать даже если предикаты изменяются динамически. Предыдущая версия не работала бы при изменении предиката.

```lisp
#'(lambda (obj)            ; *Do this instead.*
      (and (funcall pred obj)
          (funcall (get c 'predicate) obj)))
```

Важно помнить, что функция(`function`) (и следовательно # ') это особая специальная форма, и поэтому она возвращает правильное значение только при ее вычислении.
Распространенной ошибкой является использование обозначения ``#'`` в позициях, которые не вычисляются:

```lisp
(defvar *obscure-fns* '(#'cis #'cosh #'ash #'bit-orc2)) ; *wrong*
```

Здесь не создается список из четырех функций.
Скорее,  он создает список из четырех подсписков (`function cis`).
Будет ошибкой выполнить funcall или apply для такого объекта.
Ниже показаны два правильных способа создания списка функций.
Первый гарантирует, что каждая спциальная форма function вычисляется, и вторая использует имена функций вместо функций, таким образом полагаясь на `funcall` или `apply` для удержвания имен актуальных функциям.

```lisp
(defvar *obscure-fns* (list #'cis #'cosh #'ash #'bit-orc2))
(defvar *obscure-fns* '(cis cosh ash bit-orc2))
```

Другой распространенной `ошибкой` является ожидание ``#'if`` или ``#'or`` возврата функции.
Это ошибка, потому что специальные формы это просто синтаксические маркеры.
Нет функции с именем `if` или `or`; и их следует рассматривать как директивы, которые сообщают компилятору, что делать с фрагментом кода.

Кстати, указанная выше функция `make` - `specialization` плоха не  только из-за отсутствия `function`, но и из-за использования обратной кавычки.
Следующий код показывает лучшее использование обратной кавычки:

```lisp
'(lambda (obj)
    (and (,pred obj)
        (,(get c 'predicate) obj)))
```

## 25.4 Значения меняются "сами по себе"

**Проблема:** Вы что-то удалили, но это не сработало.
Например:

`> (setf numbers '(1 2 3 4 5))`=> `(1 2 3 4 5)`

`> (remove 4 numbers)`=> `(1 2 3 5)`

`> numbers`=> `(1 2 3 4 5)`

`> (delete 1 numbers)`=> `(2 3 4 5)`

`> numbers`=> `(1 2 3 4 5)`

**Устранение:** Используйте (`setf numbers` (`delete 1 numbers`)).
Обратите внимание, что `remove` это не разрушающая функция, поэтому она никогда не меняет свои аргументы, `delete` является разрушающей, но при запросе на удаление первого элемента списка возвращает оставшуюся часть списка, и, таим образом, не изменяет сам список.
Вот почему `setf` необходим.
Аналогичные замечания справедливы для `nconc`, `sort` и других разрушающих операций.

**PROBLEM:** Вы создали сотню различных структур и изменили поле одной из них. Внезапно все остальные волшебным образом изменились!

**Диагностика:** Различные структуры могут иметь одинаковые подполя. 
Например, предположим у вас есть:

```lisp
(defstruct block
  (possible-colors '(red green blue))
  ...)
  (setf bl (make-block))
  (setf b2 (make-block))
  ...
  (delete 'green (block-possible-colors bl))
```

И `b1`, и `b2` разделяют исходный список возможных цветов.
Функция `delete` изменяет этот общий(разделяемый) список, поэтому `green` удаляется из списка возможных цветов `b2`, также надежно, как он удаляется из списка `b1`.

**Устранение:** не делитесь частями данных, которые вы хотите изменять индивидуально.
В этом случае либо используйте `remove` вместо `delete`, либо создайте(выделите) отдельную копию списка для каждого экземпляра:

```lisp
(defstruct block
  (possible-colors (list 'red 'green 'blue))
  ...)
```

Помните, что инициализирующее значение поля  defstruct - это выражение, которое вычисляется заново каждый раз при вызове `make-block`.
Неправильно думать, что исходная форма вычисляется один раз при определении `defstruct`.

## 25.5 Встроенные Функции не находят элементов

**Проблем:** Вы пробуете (`find item list`), и вы знаете что он там есть, но он не находиться.

**Диагностика:** по умолчанию многие встроенные функции используют `eql` в качестве проверки на равенство, `find` одна из них.
Если `item` это, скажем список, который  `equal` но не  `eql` ни одному элементу `list`, он не будет найден.

**Устранение:** Используйте (`find item list :test #'equal`)

**Диагностика:** если `item` это nil, то будет возвращено nil не зависимо от того, найден элемент или нет.

**Устранение:** используйте `member` или `position` вместо `find` когда item может быть nil.

## 25.6 Теряются множественные значения

**ПРОБЛЕМА:** Вы получаете только одно из ожидаемых значений.

**Диагностика:** В определенных контекстах, где значение должно быть проверено Lisp, множественные значения отбрасываются.
Например, рассмотрим:

```lisp
(or (mv-1 x) (mv-2 x))
(and (mv-1 x) (mv-2 x))
(cond ((mv-1 x))
  (t (mv-2 x)))
```

В каждом случае, если `mv-2` возвращает несколько значений, все они будут переданы.
Но если `mv-1` возвращает несколько значений, будет передано только первое значение.
Это верно даже в последнем предложении cond.
Итак, в то время как последнее предложение (`t (mv-2 x)`) передает несколько значений, последнее предложение (`(mv-2 x)`) не передает.

**Диагностика:** Множественные значения также могут быть случайно потеряны при отладке.
Предположим, у меня было:

```lisp
(multiple-value-bind (a b c)
  (mv-1 x)
    ...)
```

Теперь, если мне станет любопытно, что возвращает `mv -1`, я могу изменить этот код на:

```lisp
(multiple-value-bind (a b c)
  (print (mv-1 x)) ;*** debugging output
  ...)
```

К сожалению, print увидит только первое значение, возвращаемое mv-1, и вернет только то одно значение, которое будет привязано к переменной a.
Остальные значения будут отброшены, а `b` и `c` будут привязаны к `nil`.

## 25.7 Объявления(декларации) игнорируются

**ПРОБЛЕМА:** Ваша программа использует массивы 1024 x 1024 чисел с плавающей запятой.
Но вы обнаружите, что для инициализации такого массива нулями требуется 15 секунд!
Представьте себе, насколько неэффективно выполнять какие-либо вычисления!
Вот ваша функция, которая обнуляет массив:

```lisp
(defun zero-array (arr)
  "Set the 1024x1024 array to all zeros."
  (declare (type (array float) arr))
  (dotimes (i 1024)
    (dotimes (j 1024)
      (setf (aref arr i j) 0.0))))
```

**Диагностика:** Основная проблема здесь - неэффективное декларирование.
Тип (array float) не помогает компилятору, потому что массив может быть перемещен в массив другого типа, и потому что float охватывает числа с плавающей запятой как одинарной, так и двойной точности.
Таким образом, компилятор вынужден выделять хранилище для новую копию числа 0,0 для каждого из миллиона элементов массива.
Функция работает медленно, главным образом потому, что генерирует много мусора.

**Устранение:** В следующей версии используется гораздо более эффективное объявление типа: простой массив чисел с одинарной точностью.
Оно также объявляет размер массива и отключает проверки безопасности.
Оно работает менее чем за секунду на SPARCstation, что медленнее, чем оптимизированный C, но быстрее, чем неоптимизированный C.

```lisp
(defun zero-array (arr)
  "Set the array to all zeros."
  (declare (type (simple-array single-float (1024 1024)) arr)
          (optimize (speed 3) (safety 0)))
  (dotimes (i 1024)
    (dotimes (j 1024)
      (setf (aref arr i j) 0.0))))
```

Другой распространенной ошибкой является использование чего-то вроде (`simple-vector fixnum`) в качестве спецификатора типа.
Особенность Common Lisp заключается в том, что спецификатор типа `simple-vector` принимает только размер, а не тип, в то время как спецификаторы `array`, `vector` и `simple-array` принимают необязательный тип, за которым следует необязательный размер или список размеров.
Чтобы указать простой вектор(simple vector) фиксированных чисел, используйте (`simple-array fixnum (*)`).

Если быть точным, `simple-vector` означает (`simple-array t (*)`).
Это означает, что `simple-vector` не может использоваться вместе с любым другим спецификатором типа.
Распространенная ошибка - думать, что тип (`and simple-vector (vector fixnum)`) эквивалентен (`simple-array fixnum (*)`), простому, одномерному вектору фиксированных чисел.
Фактически, он эквивалентен (`simple-array t (*)`), простому одномерному массиву элементов любого типа.
Чтобы устранить эту проблему, вообще избегайте `simple-vector`.

## 25.8 Мой Лисп делает не то

Когда все остальное терпит неудачу, возникает соблазн переложить вину за ошибку с вашего собственного кода на реализацию Common Lisp.
Безусловно, ошибки обнаруживаются в существующих реализациях.
Но также верно и то, что большую часть времени Common Lisp просто делает то, чего пользователь не ожидал, а не что-то ошибочное.

Например, распространенный "bug report"(отчет об ошибке) - это жалоба на чтение - `from-string`(из строки).
Пользователь может написать:

```lisp
(read-from-string "a b c" :start 2)
```

ожидая, что выражение начнет чтение с позиции `2` и, таким образом, вернет `b`.
Фактически, это выражение возвращает a.
Рассерженный пользователь думает, что реализация ошибочно проигнорировала аргумент: `start` и отправляет отчет об ошибке [1](#fn0010) только для того, чтобы получить следующее объяснение:

Функция `read-from-string` принимает два необязательных аргумента, `eof-errorp` и `eof-value`, в дополнении к аргументам ключевым словам.
Таким образом, в приведенном выше выражении: `start` принимается как значение `eof-errorp`, а `2` - как значение `eof-value`.
На самом деле правильный ответ - читать с начала строки и возвращать самую первую форму, a.

Функции `read-from-string` и `parse-namestring` - единственные встроенные функции, у которых есть эта проблема, потому что они единственные, у которых есть как необязательные аргументы, так и аргументы ключевые слова с четным числом необязательных аргументов.
Функции `write-line` и `write-string` имеют аргументы ключевые слова и единственный необязательный аргумент (поток), поэтому, если поток случайно пропущен, будет выдана ошибка.
(Если вы наберете (`write-line str: start 4`), система будет жаловаться либо на то, что: `start` не является потоком, либо что 4 не является ключевым словом.)

Мораль такова: функции, которые имеют как необязательные, так и ключевые аргументы, сбивают с толку.
Будьте осторожны при использовании существующих функций, у которых есть эта проблема, и воздержитесь от использования обеих в своих собственных функциях.

## 25.9 Как найти нужную функцию

Опытные программисты Common Lisp часто сталкиваются с чем-то вроде программного обеспечения *d&eacute;j&agrave; vu:*(дежа-вю) они считают, что код, который они пишут, может быть выполнен встроенной функцией Common Lisp, но они не могут вспомнить имя функции.

Вот пример: при написании кода я понял, что мне нужна функция, которая, учитывая списки (`a b c d`) и (` c d`), возвращала бы (`a b`), то есть часть первого списка без второго списока.
Я думал, что это та функция, которая может быть в стандарте, но я не знал, как она будет называться.
Требуемая функция похожа на `set-difference`, поэтому я нашел ее в указателе *Common Lisp the Language* и был перенаправлен на страницу 429.
Я просмотрел раздел "Использование списков как наборов", но не нашел ничего подходящего.
Однако мне напомнили о функции `butlast`, которая тоже похожа на искомую функцию.
Индекс направил меня на страницу 422 для `butlast`, и на той же странице я нашел `ldiff`, что было именно той функцией, которую нужно было.
Было бы легче найти (и запомнить), если бы это называлось `list-difference`, но методология осмотра рядом с похожими функциями окупилась.

Если вы думаете, что знаете часть имени нужной функции, вы можете использовать apropos, чтобы найти ее.
Например, предположим, что я думал, что есть функция, которая помещает новый элемент в начало массива.
Поиск в индексах `array, push-array` и `array-push` ничего не даст.
Но я могу обратиться к самому Лиспу и спросить:

```lisp
> (apropos "push")
PUSH                              Macro          (VALUE PLACE), plist
PUSHNEW                        Macro          (VALUE PLACE &KEY ...), plist
VECTOR-PUSH                function    (NEW-ELEMENT VECTOR), plist
VECTOR-PUSH-EXTEND  function    (DATA VECTOR &OPTIONAL ...), plist
```

Этого должно быть достаточно, чтобы напомнить мне, что ответ - `vector-push`.
Если нет, я могу получить дополнительную информацию из руководства или из онлайн-функций `documentation` или `describe`:

```lisp
> (documentation 'vector-push 'function)
"Add NEW-ELEMENT as an element at the end of VECTOR.
The fill pointer (leader element 0) is the index of the next
```

`element to be added.
If the array is full, VECTOR-PUSH returns`

```lisp
NIL and the array is unaffected; use VECTOR-PUSH-EXTEND instead
if you want the array to grow automatically."
```

Другая возможность - просмотреть существующий код, который выполняет аналогичную цель.
Таким образом, вы можете найти именно ту функцию, которую хотите, и получить дополнительные идеи о том, как действовать по-другому.

## 25.10 Синтаксис LOOP

`loop` сам по себе является мощным языком программирования, синтаксис которого сильно отличается от остального Lisp.
Поэтому важно проявлять сдержанность при использовании `loop`, чтобы читатель вашей программы не потерялся.
Одно простое правило для ограничения сложности циклов - избегать использования ключевых слов `with` и `and`.
Это устраняет большинство проблем, связанных с привязкой и областью действия.

Если сомневаетесь, разверните loop macro-expand, чтобы увидеть, что он на самом деле делает.
Но если вам нужно макрорасширение, то, возможно, будет понятнее переписать цикл с более примитивными конструкциями.

## 25.11 Синтаксис COND

Для многих программистов специальная форма cond вызывает больше синтаксических ошибок, чем любая другая, за возможным исключением `loop`.
Поскольку большинство условных предложений начинается с двух левых круглых скобок, новички часто приходят к выводу, что каждое предложение должно быть обязательным.
Это приводит к следующим ошибкам:

```lisp
(let ((entry (assoc item list)))
  (cond ((entry (process entry)))
          ...))
```

Здесь запись - это переменная, но желание заключить дополнительные скобки означает, что условие cond попытается вызвать запись как функцию, а не проверить ее значение как переменную.

Противоположная проблема, отсутствие скобок, также является источником ошибки:

```lisp
(cond (lookup item list)
  (t nil))
```

В этом случае к `lookup` обращаются как к переменной, когда намеревались вызвать ее как функцию.
В Common Lisp это обычно приводит к ошибке несвязанной переменной, но в Scheme эту ошибку может быть очень сложно определить: значение `lookup` - это сама функция, и, поскольку она не равна нулю, тест будет успешным, и выражение вернет `list` без выдачи ошибки.

Мораль - быть осторожным с cond, особенно при использовании Scheme.
Обратите внимание, что `if` гораздо менее подвержен ошибкам и выглядит так же хорошо, когда существует не более двух ветвей.

## 25.12 Синтаксис CASE

В специальной форме `case` каждое предложение состоит из ключа или списка ключей, за которым следует значение этого case.
На что следует обратить внимание, это когда ключ имеет значение `t`, `otherwise`(иначе) или `nil`.
Например:

```lisp
(case letter
  (s ...)
  (t ...)
  (u ...))
```

Здесь t используется по умолчанию; он всегда будет успешным, и все последующие предложения будут проигнорированы.
Точно ,использование () или `nil` в качестве ключа не даст желаемого эффекта: оно будет интерпретировано как пустой список ключей.
Если вы хотите быть в полной безопасности, вы можете использовать список ключей для каждого предложения. [2](# fn0015) Это особенно хорошая идея, когда вы пишете макрос, который раскрывается в `case`.
Следующий код правильно проверяет ключи `t` и `nil`:

```lisp
(case letter
  ((s) ...)
  ((t) ...)
  ((u) ...)
  ((nil) ...))
```

## 25.13 Синтаксис LET и LET*

Распространенная ошибка - это пропуск круглых скобок в `let`, как и в `cond`.
Другая ошибка - ссылка на переменную, которая еще не была привязана в `let`.
Чтобы избежать этой проблемы, используйте `let*` всякий раз, когда начальная привязка переменной ссылается на предыдущую переменную.

## 25.14 Проблемы с Макросом

В [разделе 3.2](B9780080571157500030.xhtml#s0015) мы описали четырехэтапный подход к созданию макросов:

*   Решите, действительно ли нужен макрос.

*   Запишите синтаксис макроса.

*   Выясните, во что должен расширяться макрос.

*   Используйте `defmacro`, чтобы реализовать соответствие синтаксиса и расширения.
В этом разделе показаны проблемы, которые могут возникнуть в каждой части, начиная с первой:

*   Решите, действительно ли нужен макрос.

Макросы расширяют правила вычисления выражения, тогда как вызовы функций подчиняются правилам.
Следовательно, определение слишком большого количества макросов может быть ошибкой, поскольку они могут затруднить понимание программы.
Распространенной ошибкой является определение макросов, которые *не* нарушают обычные правила вычисления.
Одна недавняя книга по программированию ИИ предлагает следующее:

```lisp
(defmacro binding-of (binding)    ; *Warning!*
    '(cadr .binding))                          ; *Don't do this.*
```

Единственная возможная причина написания этого макроса - необоснованное стремление к эффективности.
В таких случаях всегда используйте `inline` функцию вместо макроса.
Таким образом, вы получаете повышение эффективности, вы не вводите ложный макрос и получаете возможность `apply` или `map` функции  # ' `binding - of`, чего вы не могли сделать с помощью макроса:

```lisp
(proclaim '(inline binding-of))
(defun binding-of (binding)    ; *Do this instead.*
  (second binding))
```

*   Запишите синтаксис макроса.

Постарайтесь, чтобы ваш макрос соответствовал соглашениям, установленным аналогичными макросами.
Например, если ваш макрос что-то определяет, он должен подчиняться соглашениям `defvar, defstruct, defmacro` и остальным: начните с букв `def`, возьмите имя объекта, который будет определен как первый аргумент, затем если необходимо, лямбда-список, затем значение или тело.
Было бы неплохо разрешить необязательные объявления и строки документации.

Если ваш макрос связывает некоторые переменные или объекты, подобные переменным, используйте соглашения, совпадающие с `let, let*` и `labels`: принимающих список переменных или пар *(variable init-val)*.
Если вы повторяете какую-то последовательность, следуйте `dotimes` и `dolist`.
Например, вот синтаксис макроса для перебора листьев дерева из пар(conses):

```lisp
(defmacro dotree ((var tree &optional result) &body body)
  "Perform body with var bound to every leaf of tree,
```

`  then return result.
Return and Go can be used in body."`

```lisp
  ...)
```

*   Выясните, во что должен расширяться макрос.

*   Используйте defmacro, чтобы реализовать соответствие синтаксиса/расширению.

Есть несколько вещей, на которые следует обратить внимание при выяснении того, как раскрыть макрос.
Во-первых, убедитесь, что вы не затеняете локальные переменные.
Рассмотрим следующее определение для `pop-end`, функции для извлечения и возврата последнего элемента списка, при обновлении списка, чтобы он больше не содержал последний элемент.
В определении используется `last1`, который был определен на стр. 305 для возврата последнего элемента списка, а встроенная функция `nbutlast` возвращает все, кроме последнего элемента списка, деструктивно изменяя список.

```lisp
(defmacro pop-end (place)    ; *Warning!Buggy!*
  "Pop and return last element of the list in PLACE."
  '(let ((result (lastl .place)))
      (setf .place (nbutlast .place))
      result))
```

Оно будет неверно для (`pop-end result`) или для других выражений, которые упоминают переменную `result`.
Решение состоит в том, чтобы использовать новую локальную переменную, которую нельзя использовать где-либо еще:

```lisp
(defmacro pop-end (place)    ; *Less buggy*
  "Pop and return last element of the list in PLACE."
  (let ((result (gensym)))
  '(let ((,result (lastl ,place)))
    (setf ,place (nbutlast ,place))
      ,result)))
```

По-прежнему существует проблема затенения локальных *функций.* Например, пользователь, который пишет:

```lisp
(flet ((lastl (x) (sqrt x)))
  (pop-end list)
  ...)
```

будет сюрпризом, pop-end превратится в код, который вызывает `lastl`, но поскольку `lastl` локально определен как что-то еще, этот код не будет работать.
Таким образом, расширение макроса нарушает ссылочную прозрачность.
Чтобы быть в полной безопасности, мы могли бы попробовать:

```lisp
(defmacro pop-end (place)    ; *Less buggy*
  "Pop and return last element of the list in PLACE."
  (let ((result (gensym)))
    '(let ((.result (funcall .#'lastl .place)))
      (setf .place (funcall .#'nbutlast .place))
        ,result)))
```

Этот подход иногда используется программистами на Scheme, но программисты Common Lisp обычно не используют его, поскольку локальные функции в Common Lisp определяются реже.
Действительно, в *Common Lisp the Language*, 2d edition, было явно указано (стр. 260), что пользовательская функция не может переопределить или даже связать какую-либо встроенную функцию, переменную или макрос.
Даже если это не запрещено в вашей реализации, переопределение или привязка встроенной функции сбивает с толку, и этого следует избегать.

Программисты Common Lisp ожидают, что аргументы будут вычисляться в порядке слева направо и что ни один аргумент не вычисляется более одного раза.
Наше определение `pop-end` противоречит второму из этих ожиданий.
Рассмотрим:

```lisp
(pop-end (aref lists (incf i))) =
(LET ((#:G3096 (LAST1 (AREF LISTS (INCF I)))))
  (SETF (AREF LISTS (INCF I)) (NBUTLAST (AREF LISTS (INCF I))))
  #:G3096)
```

Этот код увеличивает `i` три раза, тогда как оно должно увеличивать его только один раз.
Мы могли бы исправить это, добавив в расширение больше локальных переменных:

```lisp
(let* ((templ (incf i))
      (temp2 (AREF LISTS temp1))
      (temp3 (LAST1 temp2)))
  (setf (aref lists templ) (nbutlast temp2))
  temp3)
```

Этот вид обработки аргументов слева направо через локальные переменные выполняется автоматически механизмом setf Common Lisp.
К счастью, механизм прост в использовании.
Мы можем переопределить `pop-end` для прямого вызова `pop`:

```lisp
(defmacro pop-end (place)
  "Pop and return last element of the list in PLACE."
  '(pop (last ,place)))
```

Теперь все, что нам нужно сделать, это определить метод `setf` для `last`.
Вот простое определение.
Оно использует функцию `last2`, которая возвращает два последних элемента списка.
В ANSI Common Lisp мы могли бы использовать (`last list 2`), но с компилятором pre-ANSI нам нужно определить `last2`:

```lisp
(defsetf last (place) (value)
  '(setf (cdr (last2 .place)) .value))
(defun last2 (list)
  "Return the last two elements of a list."
  (if (null (rest2 list))
      list
      (last2 (rest list))))
```

Вот некоторые макрорасширения вызовов метода `pop-end` и метода `setf` для `last`.
Разные компиляторы будут создавать разный код, но они всегда будут уважать семантику с написанием слева направо, только с одним вычислением:

```lisp
> (pop-end (aref (foo lists) (incf i))) =
(LET ((G0128 (AREF (FOO LISTS) (SETQ I (+ I 1)))))
  (PROG1
  (CAR (LAST G0128))
  (SYS:SETCDR (LAST2 G0128) (CDR (LAST G0128)))))
> (setf (last (append x y)) 'end) =
(SYS:SETCDR (LAST2 (APPEND X Y)) 'END)
```

К сожалению, в методе `setf` для `last` есть ошибка.
Предполагается, что в списке будет как минимум два элемента.
Если список пуст, вероятно, это ошибка, но если в списке ровно один элемент, то (`setf` (`last`*list) val)* должно иметь тот же эффект, что и (`setf` *list val).* Но нет способа сделать это с помощью `defsetf`, потому что метод `setf`, определенный в `defsetf`, никогда не видит *list* сам.
Вместо этого он видит локальную переменную, которая автоматически связывается со значением *list.* 
Другими словами, `defsetf` вычисляет *list* и *val* за вас, так что вам не нужно беспокоиться о порядке вычисления аргументов или вычислении более одного раза.

Чтобы решить эту проблему, нам нужно выйти за рамки простого макроса `defsetf` и углубиться в сложности `define-setf-method`, одного из самых сложных макросов во всем Common Lisp.
`define-setf-method` определяет метод setf не путем написания кода напрямую, а путем указания пяти значений, которые будут использоваться Common Lisp для написания кода для вызова `setf`.
Пять значений дают больший контроль над точным порядком, в котором вычисляются выражения, связываются переменные и возвращаются результаты.
Пятью значениями являются: (1) список временных локальных переменных, используемых в коде; (2) список значений, с которыми должны быть связаны эти переменные; (3) список из одной переменной для хранения значения, указанного в вызове `setf`; (4) код, который сохранит значение в нужном месте; (5) код, который будет иметь доступ к значению места.
Это необходимо для таких вариантов `setf`, как `inef` и `pop`, которые требуют и доступа, и сохранения.

В следующем методе `setf` для `last` мы определяем значение (`setf` (`last place`) `value`).
Мы отслеживаем все переменные и значения, необходимые для вычисления `place`, и добавляем к ним еще три локальные переменные: `last2-var` будет содержать два последних элемента списка, `last2-p` будет истинным, только если в списке два или более элемента, а `last-var` будет содержать форму для доступа к последнему элементу списка.
Мы также создаем новую переменную `result` для хранения значения `value`.
Код для сохранения значения либо изменяет cdr для `last2-var`, если список достаточно длинный, либо сохраняет непосредственно в `place`(место).
Код для доступа к значению просто извлекает `last-var`.

```lisp
(define-setf-method last (place)
  (multiple-value-bind (temps vais stores store-form access-form)
        (get-setf-method place)
    (let ((result (gensym))
          (last2-var (gensym))
          (last2-p (gensym))
          (last-var (gensym)))
        ;; Return 5 vais: temps vais stores store-form access-form
        (values
          '(.@temps .last2-var .last2-p .last-var)
          '(.@vais (last2 .access-form)
            (= (length .last2-var) 2)
            (if .last2-p (rest .last2-var) .access-form))
          (list result)
          '(if .last2-p
            (setf (cdr .last2-var) .result)
            (let ((.(first stores) .result))
              .store-form))
          last-var))))
```

Следует отметить, что методы `setf` - очень полезные и мощные вещи.
Часто лучше предоставить метод `setf` для произвольной функции `f`, чем определять специальную функцию настройки, скажем, `set-f`.
Преимущество метода `setf` в том, что он может использоваться в идиомах, таких как `incf` и `pop`, в дополнение к самому `setf`.
Кроме того, в ANSI Common Lisp разрешено называть функцию #'(`setf f`), поэтому вы также можете использовать map или apply с методом `setf`.
Большинство методов `setf` предназначены для функций, которые просто обращаются к данным, но допустимо определять методы setf для функций, которые выполняют какие-либо вычисления.
В качестве довольно причудливого примера приведем метод setf для функции извлечения квадратного корня.
Она делает (`setf (sqrt x) 5`) почти эквивалентным (`setf x (* 5 5)`); разница в том, что первый возвращает 5, а второй - 25.

```lisp
(define-setf-method sqrt (num)
  (multiple-value-bind (temps vals stores store-form access-form)
        (get-setf-method num)
    (let ((store (gensym)))
        (values temps
                    vals
                    (list store)
                    '(let ((,(first stores) (* .store .store)))
                        ,store-form
                        ,store)
                    '(sqrt .access-form)))))
```

Возвращаясь от методов `setf` к макросам, еще одна сложная часть написания переносимых макросов - это предвидеть, о чем могут предупреждать компиляторы.
Вернемся к макросу `dotree`.
Частично его определение может выглядеть так:

```lisp
(defmacro dotree ((var tree &optional result) &body body)
  "Perform body with var bound to every leaf of tree.
```

`  then return result.
Return and Go can be used in body."`

```lisp
  '(let ((.var))
      ...
      ,@body))
```

Теперь предположим, что пользователь решает подсчитать листья дерева с помощью:

```lisp
(let ((count 0))
    (dotree (leaf tree count)
        (incf count)))
```

Проблема в том, что переменная `leaf` не используется в теле макроса, и компилятор вполне может выдать предупреждение об этом.
Что еще хуже, добросовестный пользователь может написать:

```lisp
(let ((count 0))
  (dotree (leaf tree count)
    (declare (ignore leaf))
      (incf count)))
```

Разработчик нового макроса должен решить, разрешены ли объявления, и должен убедиться, что предупреждения компилятора не будут генерироваться, если они не требуются

Макросы имеют в своем распоряжении всю мощь Лиспа, но разработчик макросов должен помнить, что цель макроса - преобразовать код макроса в примитивный(обычный) код, а не выполнять какие-либо вычисления.
Рассмотрим следующий макрос, который предполагает, что `translate-rule-body` определено где-то еще:

`(defmacro defrule (name &body body)    ; Warning!
buggy!`

```lisp
  "Define a new rule with the given name."
  (setf (get name 'rule)
        '#'(lambda O ,(translate-rule-body body))))
```

Идея состоит в том, чтобы сохранить функцию под свойством `rule` имени правила.
Но это определение неверно, потому что функция сохраняется как побочный эффект расширения макроса, а не как результат выполнения расширенного кода макроса.
Правильное определение:

```lisp
(defmacro defrule (name &body body)
  "Define a new rule with the given name."
  '(setf (get '.name 'rule)
  #'(lambda () .(translate-rule-body body))))
```

Новички иногда не видят разницы между этими двумя подходами, потому что оба они дают одинаковый результат при интерпретации файла, который использует `defrule`.
Но когда файл компилируется и позже загружается в другой образ Лиспа, разница становится очевидной: первое определение ошибочно сохраняет функцию в скомпилированном образе, а второе создает код, который правильно сохраняет функцию при загрузке кода.

Начинающие пользователи макросов спрашивают: "Как я могу получить макрос, который расширяется в код, который выполняет более одного действия?
Могу ли я соединить результаты макроса? "

Если по этому поводу новичку нужен макрос, который просто *делает* две вещи, ответ - просто использовать progn.
Не будет проблем с эффективностью, даже если формы  progn вложены.
То есть, если расширение макроса приводит к такому коду:

```lisp
(progn (progn (progn *a b*) c) (progn *d e))*
```

компилятор будет относиться к нему так же, как `(progn *abc de).*`

С другой стороны, если новичок хочет макрос, который *возвращает* два значения, правильная форма - это значения, но следует понимать, что вызывающая функция должна быть организована специально, чтобы видеть оба значения.
Это ограничение невозможно обойти.
То есть, нет способа написать макрос - или функцию в этом отношении, - который будет "вставлять" свои результаты в произвольный вызов.
Например, функция `floor` возвращает два значения (частное и остаток), как и `intern` (символ и факт существования символа).
Но нам нужна специальная форма для перехвата этих значений.
Например, сравните:

```lisp
> (list (floor 11 5) (intern 'x))=M2 X)
> (multiple-value-call #'list
  (floor 11 5) (intern 'x))=>(2 1 X :INTERNAL)
```

## 25.15 Руководство по Стилю Lisp

В некотором смысле, вся эта книга представляет собой руководство по стилю написания качественных программ на Лиспе.
Но в этом разделе делается попытка обобщить некоторые уроки в виде набора рекомендаций.

### Когда определять Функцию

Программы на Lisp, как правило, состоят из множества коротких функций, в отличии от некоторых языков, которые предпочитают стиль с меньшим количеством более длинных функций. 
Новые функции следует вводить по любой из следующих причин:

1.  Для конкретной, легко формулируемой цели.
!!!(p) {:.numlist}

2.  Разбить слишком длинную функцию.
!!!(p) {:.numlist}

3.  Когда имя пригодиться при документировании.
!!!(p) {:.numlist}

4.  Когда этот код надо использовать в нескольких местах.
!!!(p) {:.numlist}

В (2), интересно рассмотреть, что означает "слишком длинная".
[Charniak et al. (1987)](B9780080571157500285.xhtml#bb0180) предложил, что 20 строк это предел.
Но теперь когда большие растровые изображения заменили 24-строчные терминалы, определения функций стали длиннее.
Так что, возможно, один экран - лучшее ограничение, чем 20 строк.
Добавление `flet` и `labels` также способствуют более длинному определению функций.

### Когда определять Специальные Переменные(Special Variable)

В общем, рекомендуется минимизировать использование специальных переменных.
Лексические переменные легче понять именно потому, что их область действия ограничена.
Попробуйте ограничить использование специальных переменных одним из следующих использований:

1.  Для параметров, которые используются во многих функциях, распределенных по программе.
!!!(p) {:.numlist}

2.  Для глобальных, постоянных, неизменяемых данных, таких как база данных фактов.
!!!(p) {:.numlist}

3.  Для нечастого, но глубоко вложенного использования.
!!!(p) {:.numlist}

Примером (3) может быть такая переменная, как `*standard-output*`, которая используется низкоуровневыми функциями печати.
Было бы непросто передавать эту переменную среди всех ваших высокоуровневых функций только для того, чтобы сделать ее доступной для `print`

### Когда связывать лексическую переменную

В отличие от специальных переменных, использование лексических переменных приветствуется.
Вы можете свободно вводить лексическую переменную (с `let`, `lambda` или `defun`) по любой из следующих причин:

1.  Чтобы не вводить одно и то же выражение дважды.
!!!(p) {:.numlist}

2.  Чтобы не вычислять одно и то же выражение дважды.
!!!(p) {:.numlist}

3.  Когда название пригодится для документации.
!!!(p) {:.numlist}

4.  Чтобы отступы оставались управляемыми.
!!!(p) {:.numlist}

### Как выбрать имя

Выбранные вами имена для функций, переменных и других объектов должны быть ясными, значимыми и последовательными.
Некоторые из соглашений перечислены здесь:

1. Используйте в основном буквы и дефисы и используйте полные слова: `delete-file`..
!!!(p) {:.numlist}

2.  Вы можете ввести аббревиатуру, если будете последовательны: `get-dtree`,` dtree-fetch`.
Например, в этой книге `fn` постоянно используется как сокращение от слова "function.".
!!!(p) {:.numlist}

3.  Предикаты оканчиваются на - `p` (или ? В Scheme), если имя уже не является предикатом: `variable-p`, `plays-in`.
!!!(p) {:.numlist}

4.  Разарушающие функции начинаются с n (или заканчиваются ! в Scheme): nreverse.
!!!(p) {:.numlist}

5.  Обобщенные макросы установки переменных заканчиваются на  `f`: `setf`, `incf`.
(`Push` это исключение.)
!!!(p) {:.numlist}

6.  Селекторы слотов, созданные `defstruct`, имеют вид *type-slot.* Используйте это также для селекторов `non-defstruct`: `char-bits`.
!!!(p) {:.numlist}

7.  Многие функции имеют вид *объект-действие:* `copy-list, delete-file`.
!!!(p) {:.numlist}

8.  Другие функции имеют вид *объекта-модификатор:* `list-length, char-lessp`.
Будьте последовательны в выборе между этими двумя формами.
Не используйте `print-edge` и `vertex-print` в одной системе.
!!!(p) {:.numlist}

9.  Функция в форме *имя модуля-имя функции* указывает на то, что необходимо использовать пакеты.
Используйте пакет parser:`print-tree` вместо `parser-print-tree`.
!!!(p) {:.numlist}

10.  Специальные переменные отмечены звездочками: `*db*, *print-length*`.
!!!(p) {:.numlista}

11.  Константы не имеют звездочек: `pi, most-positive-fixnum`.
!!!(p) {:.numlista}

12. Параметры именуются по типу: (`defun length (sequence) ...)` или по назначению: (`defun subsetp(subset superset) ...`) или обоим: (`defun / (number &rest denominator-numbers) ...`)
!!!(p) {:.numlista}

13.  Избегайте двусмысленности.
Переменная с именем `last-node` может иметь два значения; используйте вместо них `previous`-`node` или `final`-`node`. 
!!!(p) {:.numlista}

14.  Имя типа `propagate-constraints-to-neighboring-vertexes` слишком длинное, а `prp-con` - слишком короткое.
Принимая решение о длине, подумайте о том, как будет использоваться имя: `spread-constraints` в самый раз, потому что типичным вызовом будет `(spread-const rai nts vertex)`, поэтому будет очевидно, на что распространяются ограничения .
!!!(p) {:.numlista}

### Определение порядка параметров

После того, как вы решили определить функцию, вы должны решить, какие параметры она будет принимать и в каком порядке.
В общем,

1.  Поместите важные параметры первыми (а необязательные - последними).
!!!(p) {:.numlist}

2.  По возможности сделайте его читаемым как прозу: (`push element stack`).
!!!(p) {:.numlist}

3. Сгруппируйте похожие параметры вместе.
!!!(p) {:.numlist}

Интересно, что выбор списка параметров для функций верхнего уровня (тех, которые, как ожидается, будет вызывать пользователь) зависит от среды, в которой будет работать пользователь.
Во многих системах пользователь может нажать клавишу, чтобы вернуть предыдущий ввод на верхний уровень, а затем может отредактировать этот ввод и повторно выполнить его.
В этих системах предпочтительно, чтобы параметры, которые могут измениться, были в конце списка параметров, чтобы их можно было легко редактировать.
В системах, которые не предлагают такой вид редактирования, лучше либо использовать параметры ключевые слова, либо сделать параметры с высокой степенью вариабельности первыми в списке (с другими необязательными), чтобы пользователю не приходилось печатать так много.

Многие пользователи хотят иметь *обязательные* параметры ключевые слова.
Оказывается, что все параметры ключевого слова необязательны, но следующий трюк эквивалентен обязательному параметру ключевого слова.
Сначала мы определяем функцию `required`, чтобы сигнализировать об ошибке, а затем мы используем вызов `required` в качестве значения по умолчанию для любого ключевого слова, которое мы хотим сделать обязательным:

```lisp
(defun required ()
  (error "A required keyword argument was not supplied."))
(defun fn (x &key (y (required)))
  ...)
```

## 25.16 Работа с файлами, пакетами и системами

Хотя эта книга охватывает темы, которые являются более сложными, чем любой другой доступный текст на Лиспе, она по-прежнему касается только программирования в малых масштабах: по одному проекту за раз, который может быть реализован одним программистом.
Более сложная проблема программирования в целом: построение многопроектных, многопрограммных систем, которые хорошо взаимодействуют друг с другом.

В этом разделе кратко описывается подход к организации более крупного проекта в управляемые компоненты, а также способы размещения этих компонентов в файлах.

Каждая система должна иметь отдельный файл, определяющий другие файлы, составляющие систему.
Я рекомендую определять любые пакеты в этом файле, хотя другие помещают определения пакетов в отдельные файлы.

Ниже представлен образец файла мифической системы Project-X.
Каждая запись в файле обсуждается по очереди.

1.  Первая строка - это комментарий, известный как *строка режима*(*mode line*).  
Текстовый редактор emacs проанализирует символы между разделителями -*-, чтобы обнаружить, что файл содержит код Лиспа, и поэтому команды редактирования Лиспа должны быть доступны.
Также указывается диалект Lisp и пакет.
Эта нотация становится широко распространенной, поскольку другие текстовые редакторы подражают соглашениям emacs.
!!!(p) {:.numlist}

2.  Каждый файл должен иметь описание его содержимого, а также информацию об авторах и внесенных изменениях.
!!!(p) {:.numlist}

3.  Комментарии с четырьмя точками с запятой (`;;;;`) обозначают строки заголовка.
Многие текстовые редакторы предоставляют команду для печати всех таких строк, таким образом достигая контура основных частей файла.
!!!(p) {:.numlist}

4.  Первая исполняемая форма в каждом файле должна быть `in-package`.
Здесь мы используем пользовательский пакет.
Вскоре мы создадим пакет `project-x`, и он будет использоваться во всех последующих файлах.
!!!(p) {:.numlist}

5.  Мы хотим определить систему Project-X как набор файлов.
К сожалению, Common Lisp не предоставляет возможности сделать это, поэтому мы должны явно загружать наши собственные функции определения системы с помощью вызова `load`.
!!!(p) {:.numlist}

6.  Вызов функции `define-system` указывает файлы, из которых состоит Project-X.
Мы предоставляем имя для системы, каталог для исходных и объектных файлов, а также список *модулей*, составляющих систему.
Каждый модуль представляет собой список, состоящий из имени модуля (символа), за которым следует один или несколько файлов (строки или пути).
Мы использовали ключевые слова в качестве имен модулей, чтобы исключить любые возможные конфликты имен, но можно использовать любой символ.
!!!(p) {:.numlist}

7.  Вызов `defpackage` определяет пакет `project-x`.
Подробнее о пакетах см. Раздел 24.1.
!!!(p) {:.numlist}

8.  В окончательной форме печатаются инструкции о том, как загрузить и запустить систему.
!!!(p) {:.numlist}

```lisp
;;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: User -*-
;;; (Brief description of system here.)
;;;; Define the Project-X system.
(in-package "USER")
(load "/usr/norvig/defsys.lisp") ; load define-system
(define-system ;; Define the system Project-X
  :name :project-x
  :source-dir "/usr/norvig/project-x/*.lisp"
  :object-dir "/usr/norvig/project-x/*.bin"
  :modules '((:macros "header" "macros")
    (:main "parser" "transformer" "optimizer"
        "commands" "database" "output")
    (:windows "xwindows" "clx" "client")))
(defpackage :project-x ;; Define the package Project-X
  (:export "DEFINE-X" "DO-X" "RUN-X")
  (:nicknames "PX")
  (:use common-lisp))
(format *debug-io* To load the Project-X system, type
  (make-system marne :project-x)
To run the system, type
  (project-x:run-x)")
```

Каждый из файлов, составляющих систему, будет запускаться следующим образом:

```lisp
;;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: Project-X -*-
(in-package "PROJECT-X")
```

Теперь нам нужно предоставить функции определения системы, `define-system` и `make-system`.
Идея состоит в том, что `define-system` используется для определения файлов, составляющих систему, модулей, из которых система состоит, и файлов, составляющих каждый модуль.
Необходимо сгруппировать файлы в модули, потому что одни файлы могут зависеть от других.
Например, все макросы, специальные переменные, константы и встроенные функции должны быть скомпилированы и загружены до компиляции любых других файлов, которые на них ссылаются.
В Project-X все формы `defvar`, `defparameter`, `defconstant` и `defstruct` [3](# fn0020) помещаются в заголовок файла, а все формы `defmacro` помещаются в файл macros.
Вместе эти два файла образуют первый модуль с именем : macros, который будет загружен до компиляции и загрузки двух других модулей (:`main` и :`windows`).

define-system также предоставляет место для указания каталога, в котором будут находиться исходный и объектный файлы.
Для больших систем, разбросанных по нескольким каталогам, `define-system` не подходит.

Вот первая часть файла `defsys.lisp`, в которой показано определение `define-system` и структура sys.

```lisp
;;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: User -*-
; ; ; ; A Facility for Defining Systems and their Components
(in-package "USER")
(defvar *systems* nil "List of all systems defined.")
(defstruct sys
  "A system containing a number of source and object files."
  name source-dir object-dir modules)
(defun define-system (&key name source-dir object-dir modules)
  "Define a new system."
```

`  ;; Delete any old system of this name.
и добавить новый.`

```lisp
  (setf *systems* (delete name *systems* :test #'string-equal
      :key #'sys-name))
  (push (make-sys
      :name (string name)
      :source-dir (pathname source-dir)
      :object-dir (pathname object-dir)
      :modules '((:all ..(mapcar #'first modules)) ..modules))
    *systems*)
name)
```

Функция `make-systemis` используется для компиляции и/или загрузки ранее определенной системы.
Указанное имя используется для поиска определения системы, и в системе выполняется одно из трех действий.
Ключевое слово: `cload` означает компилировать, а затем загружать файлы.
: `load` означает загружать файлы; если есть объектный (скомпилированный) файл и он новее, чем исходный файл, то он будет загружен, иначе будет загружен исходный файл.
Наконец,: `update` означает компилировать только те исходные файлы, которые были изменены с момента последнего изменения соответствующих исходных файлов, и загружать новую скомпилированную версию.

```lisp
(defun make-system (&key (module : al 1 ) (action :cload)
                  (name (sys-name (first *systems*))))
    "Compile and/or load a system or one of its modules."
    (let ((system (find name *systems* :key #'sys-name
            :test #'string-equal)))
      (check-type system (not null))
      (check-type action (member : cload : update :load))
      (with-compilation-unit O (sys-action module system action))
  (defun sys-action (x system action)
    "Perform the specified action to x in this system.
```

`    X can be a module name (symbol).
file name (string)`

```lisp
    or a list."
    (typecase x
      (symbol (let ((files (rest (assoc x (sys-modules system)))))
            (if (null files)
              (warn "No files for module ~  a" x)
              (sys-action files system action))))
      (list (dolist (file x)
          (sys-action file system action)))
      ((string pathname)
          (let ((source (merge-pathnames
                x (sys-source-dir system)))
            (object (merge-pathnames
                x (sys-object-dir system))))
          (case action
  (:cload (compile-file source) (load object))
  (:update (unless (newer-file-p object source)
      (compile-file source))
    (load object))
  (:load (if (newer-file-p object source)
      (load object)
      (load source))))))
(t (warn "Don't know how to ~  a "~a in system ~  a"
    action x system))))
```

Чтобы поддержать это, нам нужно иметь возможность сравнивать даты записи в файлы.
Это несложно сделать, поскольку Common Lisp предоставляет функцию `file-write-date`.

```lisp
(defun newer-file-p (file1 file2)
  "Is file1 newer than (written later than) file2?"
  (>-num (if (probe-file filel) (file-write-date filel))
  (if (probe-file file2) (file-write-date file2))))
(defun >-num (x y)
```

`  "True if x and y are numbers.
and x > y."`

```lisp
  (and (numberp x) (numberp y) (> x y)))
```

## 25.17 Проблемы Переносимости

Программирование сложно.
Все программисты испытывают разочарование от попыток заставить программу работать в соответствии со спецификацией.
Но одна вещь, которая действительно определяет профессионального программиста, - это способность писать переносимые программы, которые будут работать в самых разных системах.
Переносимая программа не только должна работать на компьютере, на котором она была протестирована, но также должна учитывать разницу между вашим компьютером и другими.
Для этого вы должны понимать спецификацию Common Lisp абстрактно, а не только то, как она реализована на вашей конкретной машине.

Системы Common Lisp могут различаться тремя способами: при обработке ситуаций "является ошибкой", при обработке неопределенных результатов и при использовании расширений языка.

*Common Lisp the Language * указывает, что передача нечисловой функции арифметической функции является "ошибкой".
Например, вычисление (`+ nil 1`) является ошибкой.
Однако не уточняется, что делать в этой ситуации.
Некоторые реализации могут сигнализировать об ошибке, а другие нет.
Реализация будет иметь право вернуть 1 или любое другое число или нечисловое значение в качестве результата.

Ничего не подозревающий программист может закодировать выражение, которое является ошибкой, но все же вычислит разумные результаты в своей реализации.
Типичный пример - применение get к несимволу.
Это ошибка, но многие реализации просто возвращают nil, поэтому программист может написать (`get x 'prop`), когда `(if (symbol p x) (get x 'prop) nil`) действительно необходимо для переносимого кода.
Еще одна распространенная проблема связана с subseq и функциями последовательности(sequence), которые принимают ключевые слова :end.
Будет ошибкой, если параметр :end не является целым числом меньше длины последовательности, но многие реализации не будут жаловаться, если :end равен нулю или является целым числом больше длины последовательности.

Спецификация Common Lisp часто накладывает ограничения на результат, который должна вычислить функция, без полного определения результата.
Например, оба следующих результата являются допустимыми:

`> (union '(a b c) '(b c d))`=>`(A B C D)`

`> (union '(a b c) '(b c d))`=>`(D A B C)`

Программа, которая полагается на тот или иной порядок, не будет переносимой.
То же самое предупреждение относится к `intersection` и `set-difference`.
Многие функции не указывают, насколько результат разделяется с вводом.
Следующее вычисление имеет только один возможный результат печати:

```lisp
> (remove 'x'(a b c d)) (A B C D)
```

Однако не указывается, является ли вывод `eq` или только `equal` второму вводу.

Ввод/вывод особенно подвержен вариациям, поскольку разные операционные системы могут иметь очень разные представления о том, как работает ввод/вывод и файловая система.
На что следует обратить внимание, это то, повторяет(отображает в виде эха на терминал) ли `read-char` свой ввод или нет, необходимость включения `finish-output` и варианты, где необходимы новые строки, особенно в отношении верхнего уровня.

Наконец, многие реализации предоставляют расширения Common Lisp либо путем добавления полностью новых функций, либо путем изменения существующих функций.
Программист должен быть осторожен, чтобы не использовать такие расширения в переносимом коде.

## 25.18 Упражнения

**Exercise  251 [h]** On your next programming project, keep a log of each bug you detect and its eventual cause and remedy.
Classify each one according to the taxon-omy given in this chapter.
What kind of mistakes do you make most often?
How could you correct that?

**Exercise  25.2 [s-d]** Take a Common Lisp program and get it to work with a different compiler on a different computer.
Make sure you use conditional compilation read macros (#+ and #-) so that the program will work on both systems.
What did you have to change?

**Exercise  25.3 [m]** Write a `setf` method for `if` that works like this:

```lisp
(setf (if test (first x) y) (+  2 3))=
(let ((temp (+  2 3)))
  (if test
    (setf (first x) temp)
    (setf y temp)))
```

You will need to use `define-setf-method`, not `defsetf`.
(Why?) Make sure you handle the case where there is no else part to the `if`.

**Exercise  25.4 [h]** Write a `setf` method for `lookup`, a function to get the value for a key in an association list.

```lisp
(defun lookup (key alist)
  "Get the cdr of key's entry in the association list."
  (cdr (assoc key alist)))
```

## 25.19 Ответы

**Answer 25.4** Here is the setf method for `lookup`.
It looks for the key in the a-list, and if the key is there, it modifies the cdr of the pair containing the key; otherwise it adds a new key/value pair to the front of the a-list.

```lisp
(define-setf-method lookup (key alist-place)
  (multiple-value-bind (temps vais stores store-form access-form)
      (get-setf-method alist-place)
  (let ((key-var (gensym))
          (pair-var (gensym))
          (result (gensym)))
      (values
        '(.key-var .@temps .pair-var)
        '(.key .@vais (assoc .key-var ,access-form))
        '(.result)
        '(if .pair-var
            (setf (cdr .pair-var) .result)
            (let ((.(first stores)
                (acons ,key-var .result .access-form)))
              .store-form
              ,result))
        '(cdr .pair-var)))))
```

----------------------

[1](#xfn0010) This misunderstanding has shown up even in published articles, such as [Baker 1991](B9780080571157500285.xhtml#bb0060).
!!!(p) {:.ftnote1}

[2](#xfn0015) Scheme requires a list of keys in each clause.
Now you know why.
!!!(p) {:.ftnote1}

[3](#xfn0020) def struct forms are put here because they may create inline functions.
!!!(p) {:.ftnote1}