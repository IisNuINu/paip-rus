# Глава 8
## Символьная Математика: Программа Упрощения

> *Наша жизнь испорчена деталями....*

> *Упрощай, упрощай.*

> -Henry David Thoreau, *Walden* (1854)

"Символьная математика" относится к числовой математике так же, как алгебра к арифметике: она имеет дело с переменными и выражениями, а не только с числами.
Первоначально компьютеры были разработаны в первую очередь для решения арифметических задач: для суммирования длинных числовых столбцов, для умножения многозначных чисел, для решения систем линейных уравнений и для расчета траекторий баллистики.
Ободренные успехом в этих областях, люди надеялись, что компьютеры можно будет использовать и для решения более сложных задач; дифференцировать или интегрировать математическое выражение и получить другое выражение в качестве ответа, а не просто число.
Несколько программ были разработаны в этом направлении в 1960-х и 1970-х годах.
Они использовались в основном профессиональными математиками и физиками, имеющими доступ к большим мэйнфреймам.
Недавно такие программы, как MATHLAB, DERIVE и MATHEMATICA, предоставили эти возможности среднему пользователю персонального компьютера.

Интересно взглянуть на историю символической алгебры, которая началась в 1963 году с SAINT, программы Джеймса Слэгла по символьному интегрированию.
Первоначально SAINT был провозглашен триумфом AI.
Он использовал общие методы решения проблем, аналогичные GPS, для поиска решений сложных проблем.
Программа преодолела проблему интеграции, выбрав один из известных ей методов и выполняла откат назад, когда какой-либо подход не удавался.
Поведение SAINT при решении таких задач изначально было подобно (а в конечном итоге намного лучше) результативности студентов-математиков.

Со временем ИИ-компонент символьной интеграции начал исчезать.
Джоиль Мозес реализовал преемника SAINT назвав его SIN.
Он использовал многие из тех же самых методов, но вместо того, чтобы полагаться на поиск, чтобы найти правильную комбинацию методов, он имел дополнительные математические знания, которые заставляли программу выбирать правильную технику на каждом шаге, без какого-либо обеспечения возвратов назад и альтернативных попыток.
SIN решал больше проблем и был гораздо быстрее SAINT, хотя и не был совершенным: он все еще иногда делал неправильный выбор и мог не решить проблему, которую ему задали.

К 1970 году математик Р.Риш и другие разработали алгоритмы неопределенного интегрирования любого выражения, включающего алгебраические, логарифмические или экспоненциальные расширения рациональных функций.
Другими словами, для "нормальной" функции алгоритм Риша вернет либо неопределенный интеграл функции, либо указание на то, что интеграл в замкнутой форме невозможен в терминах элементарных функций.
Эта работа положила конец эпохе рассмотрения интегрирования как проблемы поиска.

SIN был дополнительно доработан, объединен с частями алгоритма Риша и включен в развивающуюся программу MACSYMA [1] (#fn0010).
По большей части усовершенствование MACSYMA состояло из включения новых алгоритмов.
Лишь немногие эвристики выживают.
Сегодня MACSYMA больше не считается программой ИИ.
Её ежедневно используют ученые и математики, в то время как ELIZA и STUDENT теперь являются лишь историческими сносками.

С помощью ELIZA и STUDENT мы смогли разработать миниатюрные программы, которые дублировали большинство функций оригинала.
Мы даже не будем пытаться разработать программу, достойную названия MACSYMA; вместо этого мы довольствуемся скромной программой для символического упрощения, которую мы будем называть (просто) `simplifier`.
Затем мы расширим `simplifier`, чтобы выполнять дифференцирование и некоторые задачи интегрирования.
Идея состоит в том, что при таком выражении, как (2-1)*x* + 0, мы хотим, чтобы программа вычисляла упрощенную форму *x*.

Согласно *Математическому словарю* (Джеймс и Джеймс, 1949), слово "упрощенный" - это "вероятно, самый неопределенный термин, серьезно используемый в математике". Проблема в том, что "упрощение" относится к тому, что вы хотите использовать для следующего выражения.
Что проще: *x* 2 + 3 *x* + 2 или (*x* + 1) (*x* + 2)?
Первое упрощает интегрирование или дифференцирование, второе - поиск корней.
Мы ограничимся "очевидными" упрощениями.
Например, *x* почти всегда предпочтительнее 1 *x* + 0.

## 8.1 Преобразование инфиксной в префиксную нотацию

Мы представим упрощения в виде списка правил, очень похожих на правила для STUDENT и ELIZA.
Но поскольку каждое правило упрощения представляет собой алгебраическое уравнение, мы будем хранить каждое из них как exp, а не как `rule`.
Чтобы сделать вещи более понятными, мы будем писать каждое выражение в инфиксной форме, но хранить их в префиксной форме, ожидаемой `exp`.
Для этого требуется функция `infix->prefix` для преобразования инфиксных выражений в префиксную нотацию.
У нас есть выбор, насколько общими мы хотим, чтобы наша инфиксная нотация была.
Рассмотрим:

```lisp
(((a * (x ^ 2)) + (b * x)) + c)
(a * x ^ 2 + b * x + c)
(a x ^ 2 + b x + c)
a x^2 + b*x+c
```

Первый инфиксный, заключенный в круглые скобки, второй использует приоритет операторов (умножение связывает сильнее, чем сложение, и поэтому выполняется первым), а третий использует неявное умножение, а также приоритет операторов.
Четвертый требует наличия лексического анализатора, чтобы разбивать символы Лиспа на части.

Предположим, мы хотим обработать только случай, при котором выражение полностью заключено в круглые скобки.
Чтобы написать `infix->prefix`, можно сначала взглянуть на `prefix->infix` (на [стр. 228] (B9780080571157500078.xhtml#p228)), попытавшись приспособить его к нашим новым целям.
При этом внимательный читатель может обнаружить сюрприз: `infix->prefix` и `prefix->infix` на самом деле являются одной и той же функцией!
Обе оставляют атомы без изменений, и обе преобразуют трехэлементные списки, меняя местами `exp-op` и `exp-lhs`.
Обе применяются рекурсивно к (возможно, измененному) входному списку.
Как только мы обнаружим этот факт, возникнет соблазн не писать `infix->prefix`, а вместо этого просто вызвать `prefix->infix`.
Избегайте этого искушения любой ценой.
Вместо этого определите `infix->prefix`, как показано ниже.
Предназначение вашего кода будет более ясным:

```lisp
(defun infix->prefix (infix-exp)
  "Convert fully parenthesized infix-exp to a prefix expression"
  ;; Don't use this version for non-fully parenthesized exps!
```

  `(prefix->infix infix-exp))`

Как мы видели выше, полностью заключенная в круглые скобки инфиксная запись может быть довольно уродливой, со всеми этими дополнительными круглыми скобками, поэтому вместо этого мы будем использовать приоритет операторов.
Есть несколько способов сделать это, но самый простой способ продолжить - использовать наш ранее определенный инструмент `rule-based-translator` и его подинструмент `pat-match`. Обратите внимание, что третье предложение `infix->prefix`, то, которое вызывает `rule-based-translator`, необычно тем, что состоит из одного выражения.
Большинство условных предложений имеют два выражения: тест и результат, но такие, как это, означают: "Вычислить тест и, если результат не равен nil, вернуть вычисленное значение.
В противном случае переходите к следующему предложению".

```lisp
(defun infix->prefix (exp)
  "Translate an infix expression into prefix notation."
  ;; Note we cannot do implicit multiplication in this system
  (cond ((atom exp) exp)
        ((= (length exp) 1) (infix->prefix (first exp)))
        ((rule-based-translator exp *infix->prefix-rules*
           :rule-if #'rule-pattern :rule-then #'rule-response
           :action
           #'(lambda (bindings response)
               (sublis (mapcar
                         #'(lambda (pair)
                             (cons (first pair)
                                   (infix->prefix (rest pair))))
                         bindings)
                       response))))
        ((symbolp (first exp))
         (list (first exp) (infix->prefix (rest exp))))
        (t (error "Illegal exp"))))
```

Поскольку в этой главе мы занимаемся математикой, мы принимаем математическое соглашение об использовании некоторых однобуквенных переменных и переопределим `variable-p` так, чтобы переменные представляли собой только символы от `m` до `z`.

```lisp
(defun variable-p (exp)
  "Variables are the symbols M through Z."
  ;; put x,y,z first to find them a little faster
  (member exp '(x y z m n o p q r s t u v w)))

;; Define x+ and y+ as a sequence:
(pat-match-abbrev 'x+ '(?+ x))
(pat-match-abbrev 'y+ '(?+ y))

(defun rule-pattern (rule) (first rule))
(defun rule-response (rule) (second rule))

(defparameter *infix->prefix-rules*
  (mapcar #'expand-pat-match-abbrev
    '(((x+ = y+) (= x y))
      ((- x+)    (- x))
      ((+ x+)    (+ x))
      ((x+ + y+) (+ x y))
      ((x+ - y+) (- x y))
      ((x+ * y+) (* x y))
      ((x+ / y+) (/ x y))
      ((x+ ^ y+) (^ x y)))))
  "A list of rules, ordered by precedence.")
```

## 8.2 Правила Упрощения

Теперь мы готовы определить правила упрощения.
Мы используем определение типа данных rule и exp ([стр. 221](B9780080571157500078.xhtml#p221)) и `prefix->infix` ([page 228](B9780080571157500078.xhtml#p228)) из STUDENT.
Они повторяются здесь:

```lisp
(defstruct (rule (:type list)) pattern response)
(defstruct (exp (:type list)
                (:constructor mkexp (lhs op rhs)))
  op lhs rhs)

(defun exp-p (x) (consp x))
(defun exp-args (x) (rest x))

(defun prefix->infix (exp)
  "Translate prefix to infix expressions."
  (if (atom exp) exp
      (mapcar #'prefix->infix
              (if (binary-exp-p exp)
                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))
                  exp))))

(defun binary-exp-p (x)
  (and (exp-p x) (= (length (exp-args x)) 2)))
```

Мы также снова используем `rule-based-translator` ([page 188](B9780080571157500066.xhtml#p188)), на этот раз со списком правил упрощения.
Разумный список правил упрощения показан ниже.
Этот список охватывает четыре арифметических оператора: сложение, вычитание, умножение и деление, а также возведение в степень(exp), обозначаемый символом "^"

Опять же, важно отметить, что правила упорядочены, и что более поздние правила будут применяться только тогда, когда более ранние правила не совпадают.
Так, например, 0/0 упрощается до `undefined`, а не до 1 или 0, потому что правило для 0 / 0 предшествует другим правилам.
См. [Упражнение 8.8](#st0045) для более полной обработки этого.

```lisp
(setf *simplification-rules* (mapcar #'simp-rule '(
  (x + 0  = x)
  (0 + x  = x)
  (x + x  = 2 * x)
  (x - 0  = x)
  (0 - x  = - x)
  (x - x  = 0)
  (- - x  = x)
  (x * 1  = x)
  (1 * x  = x)
  (x * 0  = 0)
  (0 * x  = 0)
  (x * x  = x ^ 2)
  (x / 0  = undefined)
  (0 / x  = 0)
  (x / 1  = x)
  (x / x  = 1)
  (0 ^ 0  = undefined)
  (x ^ 0  = 1)
  (0 ^ x  = 0)
  (1 ^ x  = 1)
  (x ^ 1  = x)
  (x ^ -1 = 1 / x)
  (x * (y / x) = y)
  ((y / x) * x = y)
  ((y * x) / x = y)
  ((x * y) / x = y)
  (x + - x = 0)
  ((- x) + x = 0)
  (x + y - x = y)
  )))

(defun ^ (x y) "Exponentiation" (expt x y))
```

Теперь мы готовы приступить к написанию упростителя.
Основная функция, `simpleifier`, будет многократно печатать приглашение-подсказку, читать ввод и печатать его в упрощенной форме.
Ввод и вывод находятся в инфиксном виде, а вычисления - в префиксном, поэтому нам нужно их соответственно преобразовать; функция simp делает это, а функция `simpleify` заботится о единственном префиксном выражении.
Это кратко показано на [рис. 8.1](#f0010).

| []()                                    |
|-----------------------------------------|
| ![f08-01](images/chapter8/f08-01.jpg)   |
| Figure 8.1: Словарь для Simplifier |

(ed: this should be a markdown table)

Вот программа:

```lisp
(defun simplifier ()
  "Read a mathematical expression, simplify it, and print the result."
  (loop
    (print 'simplifier>)
    (print (simp (read)))))

(defun simp (inf) (prefix->infix (simplify (infix->prefix inf))))

(defun simplify (exp)
  "Simplify an expression by first simplifying its components."
  (if (atom exp) exp
      (simplify-exp (mapcar #'simplify exp))))

;;; simplify-exp is redefined below
(defun simplify-exp (exp)
  "Simplify using a rule, or by doing arithmetic."
  (cond ((rule-based-translator exp *simplification-rules*
           :rule-if #'exp-lhs :rule-then #'exp-rhs
           :action #'(lambda (bindings response)
                       (simplify (sublis bindings response)))))
        ((evaluable exp) (eval exp))
        (t exp)))

(defun evaluable (exp)
  "Is this an arithmetic expression that can be evaluated?"
  (and (every #'numberp (exp-args exp))
       (or (member (exp-op exp) '(+ - * /))
           (and (eq (exp-op exp) '^)
                (integerp (second (exp-args exp)))))))
```

Функция `simpleify` гарантирует, что любое составное выражение будет упрощено, если сначала упростить аргументы, а затем вызвать `simpleify-exp`. Эта последняя функция выполняет поиск по правилам упрощения, подобно `use-eliza-rules` и `translate-to-expression`.
Когда она находит совпадение, `simpleify-exp` заменяет правильные значения переменных и вызывает `simplify` для результата, `simplify-exp` также имеет возможность вызвать `eval`, чтобы упростить арифметическое выражение до числа.
Как и в STUDENT, именно ради этого eval мы и требуем, чтобы выражения были представлены в виде списков в префиксной нотации.
Числовое вычисление выполняется *после* проверки правил, чтобы правила могли перехватывать выражения вроде (/ 1 0) и упрощать их до ʻundefined`.
Если бы мы сначала выполнили числовое вычисление, эти выражения выдали бы ошибку при передаче в eval.
Поскольку Common Lisp поддерживает рациональные числа (дроби) произвольной точности, мы гарантируем, что не будет ошибки округления, если только входные данные явно не включают неточные (с плавающей запятой) числа.
Обратите внимание, что мы разрешаем вычисления с участием четырех арифметических операторов, но возведение в степень разрешено только в том случае, если показатель степени является целым числом.
Это потому, что выражения типа (^ 4 1/2) не гарантируют возврата 2 (точный квадратный корень из 4); ответ может быть 2.0 (неточное число).
Другая проблема заключается в том, что - 2 также является квадратным корнем из 4, и в некоторых случаях это правильный вариант.

На следующей трассировке показаны некоторые примеры работы упрощателя.
Сначала мы покажем, что его можно использовать как калькулятор; затем мы показываем более сложные задачи.

```lisp
>(simplifier)
SIMPLIFIER  > (2 + 2)
4
SIMPLIFIER  > (5 * 20 + 30 + 7)
137
SIMPLIFIER  > (5 * x - (4 + 1) * x)
0
SIMPLIFIER  > (y / z * (5 * x - (4 + 1) * x))
0
SIMPLIFIER  > ((4-3) * x + (y / y - 1) * z)
X
SIMPLIFIER  > (1 * f(x) + 0)
(F X)
SIMPLIFIER  > (3 * 2 * X)
(3 * (2 * X))
SIMPLIFIER  > [Abort]
>
```

Здесь мы завершили цикл нажатием клавиши прерывания на терминале.
(Детали этого механизма варьируются от одной реализации Common Lisp к другой). Simplifier, похоже, работает довольно хорошо, хотя в последнем примере он ошибся: `(3 * (2 * X))`, а должно упроститься до `(6 * X)`.
В следующем разделе мы исправим эту проблему.

## 8.3 Ассоциативность и коммутативность

Мы могли бы легко добавить правило, чтобы переписать `(3 * (2 * X))` как `((3 * 2) * X)` и затем `(6 * X)`.
Проблема в том, что это правило также перепишет `(X * (2 * 3))` как `((X * 2) * 3)`, если только у нас не будет способа ограничить применение правила только тогда, когда оно будет группировать числа вместе.
К счастью, `pat-match` действительно предоставляет именно такую возможность, использованием  образца `?is`.
Мы могли бы написать это правило:

```lisp
(((?is n numberp) * ((?is m numberp) * x)) = ((n * m) * x))
```

Оно преобразует `(3 * (2 * x))` в `((3 * 2) * x)` и следовательно, в `(6 * x)`.
К сожалению, проблема не так проста.
Мы также хотим упростить `((2 * x) * (y * 3))` до `(6 * (x * y))`.
Мы можем сделать улучшить работу по группировке чисел вместе, приняв три соглашения.
Во-первых, первыми ставить числа в продукциях: измените `x * 3` на `3 * x`.
Во-вторых, совмещать числа во внешнем выражении с числом во внутреннем выражении: измените `3 *(5 * x)` на `(3 * 5)* x`.
В-третьих, по возможности уберать числа из внутренних выражений: измените `(3 * x) *y` на `3 * (x * y)`.
Мы принимаем аналогичные соглашения для сложения, за исключением того, что мы предпочитаем ставить числа последними: `x + 1` вместо `1 + x`.

```lisp
;; Define n and m as numbers; s as a non-number:
(pat-match-abbrev 'n '(?is n numberp))
(pat-match-abbrev 'm '(?is m numberp))
(pat-match-abbrev 's '(?is s not-numberp))

(defun not-numberp (x) (not (numberp x)))

(defun simp-rule (rule)
  "Transform a rule into proper format."
  (let ((exp (infix->prefix rule)))
    (mkexp (expand-pat-match-abbrev (exp-lhs exp))
     (exp-op exp) (exp-rhs exp))))

(setf *simplification-rules*
 (append *simplification-rules* (mapcar #'simp-rule
  '((s * n = n * s)
    (n * (m * x) = (n * m) * x)
    (x * (n * y) = n * (x * y))
    ((n * x) * y = n * (x * y))
    (n + s = s + n)
    ((x + m) + n = x + n + m)
    (x + (y + n) = (x + y) + n)
    ((x + n) + y = (x + y) + n)))))
```

С новыми правилами мы готовы попробовать еще раз.
На некоторые вопросы мы получаем только правильные ответы:

```lisp
> (simplifier)
SIMPLIFIER  > (3 * 2 * x)
(6 * X)
SIMPLIFIER  > (2 * x * x * 3)
(6 * (X ^ 2))
SIMPLIFIER  > (2 * x * 3 * y * 4 * z * 5 * 6)
(720 * (X * (Y * Z)))
SIMPLIFIER  > (3 + x + 4 + x)
((2 * X) + 7)
SIMPLIFIER  > (2 * x * 3 * x * 4 * (l / x) * 5 * 6)
(720 * X)
```

К сожалению, есть и другие проблемы, которые не упрощаются должным образом:

```lisp
SIMPLIFIER  > (3 + x + 4 - x)
((X + (4 - X)) + 3)
SIMPLIFIER  > (x + y + y + x)
(X + (Y + (Y + X)))
SIMPLIFIER  > (3 * x + 4 * x)
((3 * X) + (4 * X))
```

Мы вернемся к этим проблемам в [разделе 8.5](#s0030).

**Exercise  8.1** Убедитесь, что набор правил, только что введенный, действительно реализует желаемые соглашения, и что соглашения имеют надлежащий эффект и всегда заканчиваются.
В качестве примера потенциальной проблемы, что произойдет, если мы используем правило `(x * n = n * x)` вместо правила `(s * n = n * s)?`

## 8.4 Логарифмы, Тригонометические функции и Дифференцирование.

В предыдущем разделе мы ограничились простыми арифметическими функциями, чтобы не пугать тех, кто немного недоверчив к сложной математике.
В этом разделе мы немного добавим к математической сложности, не изменяя саму программу ни на йоту.
Таким образом, математически застенчивые могут спокойно перейти к следующему разделу, не чувствуя, что они упускают что-то интересное.

Мы начнем с представления некоторых элементарных свойств логарифмических и тригонометрических функций.
Новые правила аналогичны правилам "нулей и единиц", которые нам нужны для арифметических операторов, за исключением того, что здесь важны константы `e` и `pi` (*e* = 2.71828... и *&pi;* = 3.14159...), в дополнение к 0 и 1.
Мы также вводим некоторые правила, относящиеся к логарифмам и экспонентам, а также к суммам и разностям логорифмов.
Правила предполагают, что комплексные числа не допускаются.
Если бы это было так, log *ex* (и даже *xy*) имел бы несколько значений, и было бы неправильно произвольно выбирать одно из этих значений.

```lisp
(setf *simplification-rules*
 (append *simplification-rules* (mapcar #'simp-rule '(
  (log 1         = 0)
  (log 0         = undefined)
  (log e         = 1)
  (sin 0         = 0)
  (sin pi        = 0)
  (cos 0         = 1)
  (cos pi        = -1)
  (sin(pi / 2)   = 1)
  (cos(pi / 2)   = 0)
  (log (e ^ x)   = x)
  (e ^ (log x)   = x)
  ((x ^ y) * (x ^ z) = x ^ (y + z))
  ((x ^ y) / (x ^ z) = x ^ (y - z))
  (log x + log y = log(x * y))
  (log x - log y = log(x / y))
  ((sin x) ^ 2 + (cos x) ^ 2 = 1)
  ))))
```

Теперь мы хотели бы пойти еще дальше и расширить систему, чтобы справиться с дифференцированием.
Это любимая проблема, и она имеет историческое значение: летом 1958 года Джон Маккарти решил исследовать дифференцирование как интересную проблему символических вычислений, которую было трудно выразить на примитивных языках программирования того времени.
Это исследование привело его к пониманию важности функциональных аргументов и рекурсивных функций в области символьных вычислений.
Например, Маккарти изобрел то, что мы теперь называем `mapcar`, чтобы выразить идею о том, что производная суммы является суммой производной функции, примененной к каждому аргументу.
Дальнейшая работа привела Маккарти к публикации в октябре 1958 года Записки MIT AI Lab No.
1: "Алгебраический язык для манипулирования символическими выражениями", который определил предшественника Lisp.

В работе Маккарти и во многих последующих текстах вы можете увидеть программы символического дифференцирования с процедурой упрощения, выполняемой в конце, чтобы сделать вывод более читаемым.
Здесь мы используем противоположный подход: процедура упрощения является центральной, а дифференцирование рассматривается как просто еще один оператор со своим собственным набором правил упрощения.
Нам потребуется новое правило преобразования infix-to-prefix(инфикса в префикс).
В то же время мы добавим правило для неопределенного интегрирования, хотя мы еще не будем писать правил упрощения для интегрирования.
Вот новые обозначения:

| []()        |             |             |
|-------------|-------------|-------------|
| math        | infix       | prefix      |
| *dy*/*dx*   | `d y / d x` | `(d y x)`   |
| *&int; ydx* | `Int y d x` | `(int y x)` |

А вот и необходимые правила перехода infix-to-prefix(от инфикса к префиксу):

```lisp
(defparameter *infix->prefix-rules*
      (mapcar #'expand-pat-match-abbrev
          '(((x+ = y+) (= x y))
          ((- x+) (- x))
          ((+ x+) (+ x))
          ((x+ + y+) (+ x y))
          ((x+ - y+) (- x y))
          ((d y+ / d x) (d y x))        ;*** New rule
          ((Int y+ d x) (int y x))    ;*** New rule
          ((x+ * y+) (* x y))
          ((x+ / y+) (/ x y))
          ((x+ ^ y+) (^ x y)))))
```

Поскольку новое правило для дифференцирования стоит раньше правила для деления, не будет никакой путаницы с дифференциалом, интерпретируемым как частное.
С другой стороны, существует потенциальная проблема с интегралами, которые содержат `d` в качестве переменной.
Пользователь всегда может избежать этой проблемы, используя (`d`) вместо `d` внутри интеграла.

Теперь мы дополняем правила упрощения, копируя таблицу дифференцирования из справочника:

```lisp
(setf *simplification-rules*
 (append *simplification-rules* (mapcar #'simp-rule '(
  (d x / d x       = 1)
  (d (u + v) / d x = (d u / d x) + (d v / d x))
  (d (u - v) / d x = (d u / d x) - (d v / d x))
  (d (- u) / d x   = - (d u / d x))
  (d (u * v) / d x = u * (d v / d x) + v * (d u / d x))
  (d (u / v) / d x = (v * (d u / d x) - u * (d v / d x))
                     / v ^ 2) ; [This corrects an error in the first printing]
  (d (u ^ n) / d x = n * u ^ (n - 1) * (d u / d x))
  (d (u ^ v) / d x = v * u ^ (v - 1) * (d u / d x)
                   + u ^ v * (log u) * (d v / d x))
  (d (log u) / d x = (d u / d x) / u)
  (d (sin u) / d x = (cos u) * (d u / d x))
  (d (cos u) / d x = - (sin u) * (d u / d x))
  (d (e ^ u) / d x = (e ^ u) * (d u / d x))
  (d u / d x       = 0)))))
```

Мы добавили правило по умолчанию `(d u / d x = 0)`; оно должно применяться только тогда, когда выражение `u` свободно от переменной `x` (то есть когда u не является функцией `x`).
Мы могли бы использовать `?if`, чтобы проверить это, но вместо этого мы полагаемся на то, что дифференцирование ограничено списком операторов, описанных здесь - так что, до тех пор, пока мы не введем никаких новых операторов, ответ всегда будет правильным.
Обратите внимание, что есть два правила для возведения в степень, одно для случая, когда показатель степени является числом, и одно, когда это не так.
В этом не было строгой необходимости, поскольку второе правило охватывает оба случая, но именно так правила были записаны в таблице дифференциалов, с которой я консультировался, поэтому я оставил оба правила.

```lisp
SIMPLIFIER  > (d (x + x) / d x)
2
SIMPLIFIER  > (d (a * x ^ 2 + b * x + c) / d x)
((2 * (A * X)) + B)
SIMPLIFIER  > (d ((a * x ^ 2 + b * x + c) / x) / d x)
((((A * (X ^ 2)) + ((B * X) + C)) - (X * ((2 * (A * X)) + B)))
/ (X ^ 2))
SIMPLIFIER  > (log ((d (x + x) / d x) / 2))
0
SIMPLIFIER  > (log(x + x) - log x)
(LOG 2)
SIMPLIFIER  > (x ^ cos pi)
(1 / X)
SIMPLIFIER  > (d (3 * x + (cos x) / x) / d x)
((((COS X) - (X * (- (SIN X)))) / (X ^ 2)) + 3)
SIMPLIFIER  > (d ((cos x) / x) / d x)
(((COS X) - (X * (- (SIN X)))) / (X ^ 2))
SIMPLIFIER  > (d (3 * x ^ 2 + 2 * x + 1) / d x)
((6 * X) + 2)
SIMPLIFIER  > (sin(x + x) ^ 2 + cos(d x ^ 2 / d x) ^ 2)
1
SIMPLIFIER  > (sin(x + x) * sin(d x ^ 2 / d x) +
      cos(2 * x) * cos(x * d 2 * y / d y))
1
```

Программа хорошо справляется с проблемами дифференцирования и, по-видимому, умна в использовании тождества sin^2*x* + cos^2*x* = 1.

## 8.5 Пределы применения подходов основанных на правилах

В этом разделе мы вернемся к некоторым примерам, которые создают проблемы для упрощателя.
Вот простой пример

`SIMPLIFIER  > (x + y + y + x)`=> `(X + (Y + (Y + X)))`

Мы бы предпочли `2 * (x + y)`.
Проблема в том, что, хотя мы приложили много усилий, чтобы сгруппировать числа вместе, не было никаких усилий, чтобы сгруппировать не-числа.
Мы могли бы написать правила вида:

```lisp
(y + (y + x) = (2 * y) + x)
(y + (x + y) = (2 * y) + x)
```

Они будут работать для рассматриваемого примера, но они не будут работать для `(x + y + z + y + x)'.
Для этого нам понадобится больше правил:

```lisp
(y + (z + (y + x)) = (2 * y) + x + z)
(y + (z + (x + y)) = (2 * y) + x + z)
(y + ((y + x) + z) = (2 * y) + x + z)
(y + ((x + y) + z) = (2 * y) + x + z)
```

Чтобы справиться со всеми случаями, нам понадобится бесконечное число правил.
Язык сопоставления с образцом недостаточно силен, чтобы выразить это кратко.
Могло бы помочь, если бы вложенные суммы (и произведения) были невложенными; то есть, если бы мы позволили + принять произвольное число аргументов вместо только одного.
Как только аргументы сгруппированы вместе, мы можем отсортировать их так, чтобы, скажем, все `ys` появлялись перед `z` и после `x`.
Тогда подобные термины можно было бы сгруппировать вместе.
Но мы должны быть осторожны.
Рассмотрим следующие примеры:

```lisp
SIMPLIFIER  > (3 * x + 4 * x)
((3 * X) + (4 * X))
SIMPLIFIER  > (3 * x + y + x + 4 * x)
((3 * X) + (Y + (X + (4 * X))))
```

Мы бы хотели, чтобы `(3 * x)` сортировался в то же место, что и `x` и `(4 * x)`, чтобы все они могли быть объединены в `(8 * x)`.
В [главе 15](B9780080571157500157.xhtml) мы разрабатываем новую версию программы, которая решает эту проблему.

## 8.6 Интегрирование

До сих пор алгебраические манипуляции были простыми.
Существует прямой алгоритм вычисления производной каждого выражения.
Когда мы рассматриваем интегралы или первообразные [2](# fn0015), картина намного сложнее.
Как вы, возможно, помните из исчисления для первокурсников, вычисление интегралов - это настоящее искусство.
В этом разделе мы пытаемся увидеть, как далеко мы можем зайти, кодируя лишь некоторые из множества приемов, доступных изучающему математику.

Первый шаг - признать, что записей в таблице упрощения будет недостаточно.
Вместо этого нам понадобится алгоритм для вычисления или "упрощения" интегралов.
Мы добавим новый случай в `simpleify-exp`, чтобы проверить каждый оператор, чтобы увидеть, связана ли с ним функция упрощения.
Эти функции упрощения будут связаны с операторами через функции `set-simp-fn` и `simp-fn`.
Если у оператора есть функция упрощения, то эта функция будет вызываться вместо обращения к правилам упрощения.
Функция упрощения может решить не обрабатывать выражение в конце концов, возвращая nil, и в этом случае мы продолжим использовать другие методы упрощения.

```lisp
(defun simp-fn (op) (get op 'simp-fn))
(defun set-simp-fn (op fn) (setf (get op 'simp-fn) fn))

(defun simplify-exp (exp)
  "Simplify using a rule, or by doing arithmetic,
  or by using the simp function supplied for this operator."
  (cond ((simplify-by-fn exp))                             ;***
        ((rule-based-translator exp *simplification-rules*
           :rule-if #'exp-lhs :rule-then #'exp-rhs
           :action #'(lambda (bindings response)
                       (simplify (sublis bindings response)))))
        ((evaluable exp) (eval exp))
        (t exp)))

(defun simplify-by-fn (exp)
  "If there is a simplification fn for this exp,
  and if applying it gives a non-null result,
  then simplify the result and return that."
  (let* ((fn (simp-fn (exp-op exp)))
         (result (if fn (funcall fn exp))))
    (if (null result)
        nil
        (simplify result))))
```

На уроках математического анализа первокурсникам преподаются различные методы интегрирования.
К счастью, одина техника - метод разделения переменных - может быть использован для решения большинства проблем, которые возникают на уровне математики первокурсников, возможно, 90% задач, заданных при проверке.
Основное правило:

&int;fxdx=&int;fududxdx.

![si1_e](images/chapter8/si1_e.gif)

В качестве примера рассмотрим *&int; x* sin(*x*2) *dx*.
Используя подстановку *u* = *x*2, мы можем дифференцировать, чтобы получить *du*/*dx* = 2*x*.
Затем, применяя основное правило, мы получаем:

&int;xsinx2dx=12&int;sinududxdx=12&int;sinudu.

![si2_e](images/chapter8/si2_e.gif)

Предположим, что у нас есть таблица интегралов, включающая правило *&int;* sin(*x*) *dx* = - cos(*x*).
Тогда мы сможем получить окончательный ответ:

-12cosx2.

![si3_e](images/chapter8/si3_e.gif)

Если абстрагироваться от этого примера, общий алгоритм интегрирования выражения *y* относительно *x* следующий:

1.  Выберите коэффициент *y*, называя его *f*(*u*).
!!!(p) {:.numlist}

2.  Вычислить производную *du*/*dx*.
!!!(p) {:.numlist}

3.  Разделите *y* на *f*(*u*) x *du*/*dx*, получив коэффициэнт *k*.
!!!(p) {:.numlist}

4.  Если *k* является константой (по отношению к *x*), то результат будет *k &int; f*(*u*)*du*.
!!!(p) {:.numlist}

Этот алгоритм недетерминирован, так как может быть много факторов *y*.
В нашем примере *f*(*u*) = sin(*x*2), *u* = *x*2, and *du*/*dx* = 2*x*.
Итак, k=12 !!!(span) {:.hiddenClass} ![si4_e](images/chapter8/si4_e.gif), и ответ будет -12cosx2 !!!(span) {:.hiddenClass} ![si5_e](images/chapter8/si5_e.gif).

Первый шаг в реализации этой техники - убедиться, что разделение выполнено правильно.
Нам нужно иметь возможность выбирать множители *y*, разделять выражения, а затем определять, свободны ли частные(коэффициэнты) от *x*.
Это делает функция `factorize`.
Она хранит список факторов и текущее произведение постоянных факторов и дополняет их с каждым вызовом локальной функции `fac`.

```lisp
(defun factorize (exp)
  "Return a list of the factors of exp^n,
  where each factor is of the form (^ y n)."
  (let ((factors nil)
        (constant 1))
    (labels
      ((fac (x n)
         (cond
           ((numberp x)
            (setf constant (* constant (expt x n))))
           ((starts-with x '*)
            (fac (exp-lhs x) n)
            (fac (exp-rhs x) n))
           ((starts-with x '/)
            (fac (exp-lhs x) n)
            (fac (exp-rhs x) (- n)))
           ((and (starts-with x '-) (length=1 (exp-args x)))
            (setf constant (- constant))
            (fac (exp-lhs x) n))
           ((and (starts-with x '^) (numberp (exp-rhs x)))
            (fac (exp-lhs x) (* n (exp-rhs x))))
           (t (let ((factor (find x factors :key #'exp-lhs
                                  :test #'equal)))
                (if factor
                    (incf (exp-rhs factor) n)
                    (push `(^ ,x ,n) factors)))))))
      ;; Body of factorize:
      (fac exp 1)
      (case constant
        (0 '((^ 0 1)))
        (1 factors)
        (t `((^ ,constant 1) .,factors))))))
```

`factorize`  отображает выражение в список факторов, но нам также нужно `unfactorize`, чтобы превратить список обратно в выражение:

```lisp
(defun unfactorize (factors)
  "Convert a list of factors back into prefix form."
  (cond ((null factors) 1)
        ((length=1 factors) (first factors))
        (t `(* ,(first factors) ,(unfactorize (rest factors))))))
```

Метод разделения на производные(метод разделения переменных) требует разделения двух выражений.
Мы делаем это путем факторизации каждого выражения, а затем отмены деления на коэффициенты(факторы).
Могут быть случаи, когда, например, два множителя в числителе можно перемножить, чтобы отменить множитель в знаменателе, но такая возможность не рассматривается.
Оказывается, что большинство задач по математике первокурсников не требуют такой сложности.

```lisp
(defun divide-factors (numer denom)
  "Divide a list of factors by another, producing a third."
  (let ((result (mapcar #'copy-list numer)))
    (dolist (d denom)
      (let ((factor (find (exp-lhs d) result :key #'exp-lhs
                          :test #'equal)))
        (if factor
            (decf (exp-rhs factor) (exp-rhs d))
            (push `(^ ,(exp-lhs d) ,(- (exp-rhs d))) result))))
    (delete 0 result :key #'exp-rhs)))
```

Наконец, предикат `free-of` возвращает истину, если в выражении нет вхождений определенной переменной.

```lisp
(defun free-of (exp var)
  "True if expression has no occurrence of var."
  (not (find-anywhere var exp)))

(defun find-anywhere (item tree)
  "Does item occur anywhere in tree?  If so, return it."
  (cond ((eql item tree) tree)
        ((atom tree) nil)
        ((find-anywhere item (first tree)))
        ((find-anywhere item (rest tree)))))
```

В `factorize` мы использовали вспомогательную функцию `length=1`. Вызов функции `(length=l x)` быстрее, чем `(= (length x) 1)`, потому что последняя должна вычислять длину всего списока, в то время как первая просто должна смотреть, есть ли в списке элемент `rest` или нет.

```lisp
(defun length=l (x)
  "Is X a list of length 1?"
  (and (consp x) (null (rest x))))
```

Учитывая эти предварительные сведения, функция `integrate` довольно проста.
Начнем с нескольких простых случаев интегрирования сумм и постоянных выражений.
Затем мы факторизируем выражение и разбиваем список факторов на два: список постоянных факторов и список факторов, содержащий *x*.
(Это делается с помощью `partition-if`, комбинации `remove-if` и `remove-if-not`.) Наконец, мы вызываем `deriv-divides`, давая ему шанс с каждым из факторов.
Если ни один из них не сработает, мы возвращаем выражение, указывающее, что интеграл неизвестен.

```lisp
(defun integrate (exp x)
  ;; First try some trivial cases
  (cond
    ((free-of exp x) `(* ,exp x))          ; Int c dx = c*x
    ((starts-with exp '+)                  ; Int f + g  =
     `(+ ,(integrate (exp-lhs exp) x)      ;   Int f + Int g
         ,(integrate (exp-rhs exp) x)))
    ((starts-with exp '-)
     (ecase (length (exp-args exp))
       (1 (integrate (exp-lhs exp) x))     ; Int - f = - Int f
       (2 `(- ,(integrate (exp-lhs exp) x) ; Int f - g  =
              ,(integrate (exp-rhs exp) x)))))  ; Int f - Int g
    ;; Now move the constant factors to the left of the integral
    ((multiple-value-bind (const-factors x-factors)
         (partition-if #'(lambda (factor) (free-of factor x))
                       (factorize exp))
       (identity ;simplify
         `(* ,(unfactorize const-factors)
             ;; And try to integrate:
             ,(cond ((null x-factors) x)
                    ((some #'(lambda (factor)
                               (deriv-divides factor x-factors x))
                           x-factors))
                    ;; <other methods here>
                    (t `(int? ,(unfactorize x-factors) ,x)))))))))
```

```lisp
(defun partition-if (pred list)
  "Return 2 values: elements of list that satisfy pred,
  and elements that don't."
  (let ((yes-list nil)
        (no-list nil))
    (dolist (item list)
      (if (funcall pred item)
          (push item yes-list)
          (push item no-list)))
    (values (nreverse yes-list) (nreverse no-list))))
```

Обратите внимание, в integrate отмечено место, где можно было бы добавить другие методы.
Мы будем реализовывать только метод разделения переменных(derivative-divides).
Оказывается, эта функция немного сложнее, чем простой четырехэтапный алгоритм, описанный ранее:

```lisp
(defun deriv-divides (factor factors x)
  (assert (starts-with factor '^))
  (let* ((u (exp-lhs factor))              ; factor = u^n
         (n (exp-rhs factor))
         (k (divide-factors
              factors (factorize `(* ,factor ,(deriv u x))))))
    (cond ((free-of k x)
           ;; Int k*u^n*du/dx dx = k*Int u^n du
           ;;                    = k*u^(n+1)/(n+1) for n/=1
           ;;                    = k*log(u) for n=1
           (if (= n -1)
               `(* ,(unfactorize k) (log ,u))
               `(/ (* ,(unfactorize k) (^ ,u ,(+ n 1)))
                   ,(+ n 1))))
          ((and (= n 1) (in-integral-table? u))
           ;; Int y'*f(y) dx = Int f(y) dy
           (let ((k2 (divide-factors
                       factors
                       (factorize `(* ,u ,(deriv (exp-lhs u) x))))))
             (if (free-of k2 x)
                 `(* ,(integrate-from-table (exp-op u) (exp-lhs u))
                     ,(unfactorize k2))))))))
```

Есть три случая.
В любом случае, все множители имеют вид `(^ u n)`, поэтому мы разделяем множитель на основание `u` и показатель степени `n`.
Если *u* или *un* равномерно делит исходное выражение (здесь представлено как множители), то у нас есть ответ.
Но нам нужно проверить экспоненту, потому что *&int; undu* равен *u**n*+1/(*n* + 1) для *n*&ne; - 1, но это log(*u*) для *n* = - 1.
Но следует рассмотреть третий случай.
Фактор может быть чем-то вроде `(^ (sin (^ x 2)) 1)`, и в этом случае мы должны учитывать *f*(*u*) = sin(*x*2).
Этот случай обрабатывается с помощью таблицы интегрирования.
Нам не нужна таблица производных, потому что мы можем просто использовать для этого simplifier.

```lisp
(defun deriv (y x) (simplify `(d ,y ,x)))

(defun integration-table (rules)
  (dolist (i-rule rules)
    ;; changed infix->prefix to simp-rule - norvig Jun 11 1996
    (let ((rule (simp-rule i-rule)))
      (setf (get (exp-op (exp-lhs (exp-lhs rule))) 'int)
            rule))))

(defun in-integral-table? (exp)
  (and (exp-p exp) (get (exp-op exp) 'int)))

(defun integrate-from-table (op arg)
  (let ((rule (get op 'int)))
    (subst arg (exp-lhs (exp-lhs (exp-lhs rule))) (exp-rhs rule))))

(integration-table
  '((Int log(x) d x = x * log(x) - x)
    (Int exp(x) d x = exp(x))
    (Int sin(x) d x = - cos(x))
    (Int cos(x) d x = sin(x))
    (Int tan(x) d x = - log(cos(x)))
    (Int sinh(x) d x = cosh(x))
    (Int cosh(x) d x = sinh(x))
    (Int tanh(x) d x = log(cosh(x)))
    ))
```

Последний шаг - установить integrate как функцию упрощения для оператора Int.
Очевидный способ сделать это:

```lisp
(set-simp-fn 'Int 'integrate)
```

К сожалению, это не совсем так.
Проблема в том, что integrate ожидает два аргумента, соответствующих двум аргументам *`y`* и *`x`* в (Int *y x*)`.
Но соглашение для функций упрощения заключается в передаче им одного аргумента, состоящего из всего выражения `(Int *y x*)`.
Мы могли бы вернуться и отредактировать `simpleify-exp`, чтобы изменить соглашение, но вместо этого я предпочёл сделать преобразование следующим образом:

```lisp
(set-simp-fn 'Int #'(lambda (exp)
          (integrate (exp-lhs exp) (exp-rhs exp))))
```

Вот несколько примеров, взятых из [глав 8](#c0040) и [9](B9780080571157500091.xhtml) из *Calculus* ([Loomis 1974](B9780080571157500285.xhtml#bb0750)):

```lisp
SIMPLIFIER  > (Int x * sin(x ^ 2) d x)
(1/2 * (- (COS (X ^ 2))))
SIMPLIFIER  > (Int ((3 * x ^ 3) - 1 / (3 * x ^ 3)) d x)
((3 * ((X ^ 4) / 4)) - (1/3 * ((X ^ -2) / -2)))
SIMPLIFIER  > (Int (3 * x + 2) ^ -2/3 d x)
(((3 * X) + 2) ^ 1/3)
SIMPLIFIER  > (Int sin(x) ^ 2 * cos(x) d x)
(((SIN X) ^ 3) / 3)
SIMPLIFIER  > (Int sin(x) / (1 + cos(x)) d x)
(-1 * (LOG ((COS X) + 1)))
SIMPLIFIER  > (Int (2 * x + 1) / (x ^ 2 + x - 1) d x)
(LOG ((X ^ 2) + (X - 1)))
SIMPLIFIER  > (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)
(8 * ((1/3 * (((X ^ 3) + 2) ^ -2)) / -2))
```

Все ответы верны, хотя последний можно было бы сделать проще.
Один из быстрых способов упростить такое выражение - это разложить на множители(факторизовать) и дефакторизовать, а затем снова упростить:

```lisp
(set-simp-fn 'Int
    #'(lambda (exp)
      (unfactorize
        (factorize
          (integrate (exp-lhs exp) (exp-rhs exp))))))
```

С этим изменением мы получаем:

```lisp
SIMPLIFIER  > (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)
(-4/3 * (((X ^ 3) + 2) ^ -2))
```

## 8.7 История и ссылки

A brief history is given in the introduction to this chapter.
An interesting point is that the history of Lisp and of symbolic algebraic manipulation are deeply intertwined.
It is not too gross an exaggeration to say that Lisp was invented by John McCarthy to express the symbolic differentiation algorithm.
And the development of the first high-quality Lisp system, MacLisp, was driven largely by the needs of MACSYMA, one of the first large Lisp systems.
See [McCarthy 1958](B9780080571157500285.xhtml#bb0790) for early Lisp history and the differentiation algorithm, and [Martin and Fateman 1971](B9780080571157500285.xhtml#bb0775) and [Moses (1975)](B9780080571157500285.xhtml#bb0875) for more details on MACSYMA.
A comprehensive book on computer algebra systems is [Davenport 1988](B9780080571157500285.xhtml#bb0270).
It covers the MACSYMA and REDUCE systems as well as the algorithms behind those systems.

Because symbolic differentiation is historically important, it is presented in a number of text books, from the original Lisp 1.5 Primer ([Weissman 1967](B9780080571157500285.xhtml#bb1370)) and Allen's influential [*Anatomy of Lisp* (1978)](B9780080571157500285.xhtml#bb0040) to recent texts like [Brooks 1985](B9780080571157500285.xhtml#bb0135), [Hennessey 1989](B9780080571157500285.xhtml#bb0530), and [Tanimoto 1990](B9780080571157500285.xhtml#bb1220).
Many of these books use rules or data-driven programming, but each treats differentiation as the main task, with simplification as a separate problem.
None of them use the approach taken here, where differentiation is just another kind of simplification.

The symbolic integration programs SAINT and SIN are covered in [Slagle 1963](B9780080571157500285.xhtml#bb1115) and [Moses 1967](B9780080571157500285.xhtml#bb0870), respectively.
The mathematical solution to the problem of integration in closed term is addressed in [Risch 1969](B9780080571157500285.xhtml#bb0985), but be warned; this paper is not for the mathematically naive, and it has no hints on programming the algorithm.
A better reference is [Davenport et al.
1988](B9780080571157500285.xhtml#bb0270).

In this book, techniques for improving the efficiency of algebraic manipulation are covered in [sections 9.6](B9780080571157500091.xhtml#s0035) and [10.4](B9780080571157500108.xhtml#s0025).
[Chapter 15](B9780080571157500157.xhtml) presents a reimplementation that does not use pattern-matching, and is closer to the techniques used in MACSYMA.

## 8.8 Exercises

**Exercise  8.2 [s]** Some notations use the operator ** instead of ^ to indicate exponentiation.
`Fix infix->prefix` so that either notation is allowed.

**Exercise  8.3 [m]** Can the system as is deal with imaginary numbers?
What are some of the difficulties?

**Exercise  8.4 [h]** There are some simple expressions involving sums that are not handled by the `integrate` function.
The function can integrate *a*x *x*2 + *b*x *x* + *c* but not 5 x (*a*x *x*2 + *b*x *x* + *c*).
Similarly, it can integrate *x*4 + 2 x *x*3 + *x*2 but not (*x*2 + *x*)2, and it can do *x*3 + *x*2 + *x* + 1 but not (*x*2 + 1) x (*x* + 1).
Modify `integrate` so that it expands out products (or small exponents) of sums.
You will probably want to try the usual techniques first, and do the expansion only when that fails.

**Exercise  8.5 [d]** Another very general integration technique is called integration by parts.
It is based on the rule:

&int;udv=uv-&int;vdu

![si6_e](images/chapter8/si6_e.gif)

So, for example, given

&int;xcosxdx

![si7_e](images/chapter8/si7_e.gif)

we can take *u* = *x*, *dv* = cos *xdx*.
Then we can determine *v* = sin *x* by integration, and come up with the solution:

&int;xcosxdx=xsinx-&int;sinxx1dx=xsinx+cosx

![si8_e](images/chapter8/si8_e.gif)

It is easy to program an integration by parts routine.
The hard part is to program the control component.
Integration by parts involves a recursive call to `integrate`, and of all the possible ways of breaking up the original expression into a *u* and a *dv*, few, if any, will lead to a successful integration.
One simple control rule is to allow integration by parts only at the top level, not at the recursive level.
Implement this approach.

**Exercise  8.6 [d]** A more complicated approach is to try to decide which ways of breaking up the original expression are promising and which are not.
Derive some heuristics for making this division, and reimplement `integrate` to include a search component, using the search tools of [chapter 6](B9780080571157500066.xhtml).

Look in a calculus textbook to see how *&int;* sin2*xdx* is evaluated by two integrations by parts and a division.
Implement this technique as well.

**Exercise  8.7 [m]** Write simplification rules for predicate calculus expressions.
For example,

```lisp
(true and x = x)
(false and x = false)
(true or x = true)
(false or x = false)
```

**Exercise  8.8 [m]** The simplification rule `(x / 0 = undefined)` is necessary to avoid problems with division by zero, but the treatment of `undefined` is inadequate.
For example, the expression `((0 / 0) - (0 / 0))` will simplify to zero, when it should simplify to `undefined`.
Add rules to propagate `undefined` values and prevent them from being simplified away.

**Exercise  8.9 [d]** Extend the method used to handle `undefined` to handle `+  infinity` and `-infinity` as well.

----------------------

[1](#xfn0010)MACSYMA is the Project MAC SYMbolic MAthematics program.
Project MAC is the MIT research organization that was the precursor of MIT's Laboratory for Computer Science.
MAC stood either for Machine-Aided Cognition or Multiple-Access Computer, according to one of their annual reports.
The cynical have claimed that MAC really stood for Man Against Computer.
!!!(p) {:.ftnote1}

[2](#xfn0015) The term antiderivative is more correct, because of branch point problems.
!!!(p) {:.ftnote1}

Part III
Tools and Techniques
!!!(p) {:.parttitle}