#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter6.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-11-03 13:04+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter6.md:3
msgid ""
"# Chapter 6\n"
"## Building Software Tools"
msgstr ""
"# Chapter 6\n"
"## Построение Программных Средств"

#: in/chapter6.md:5
msgid ""
"> *Man is a tool-using animal...Without tools he is nothing with tools he is "
"all.*"
msgstr ""
"> *Человек - животное, использующее инструменты ... Без инструментов он - "
"ничто, с инструментами он все.*"

#: in/chapter6.md:7
msgid "> -Thomas Carlyle (1795-1881)"
msgstr ""

#: in/chapter6.md:10
msgid ""
"In [chapters 4](B9780080571157500042.xhtml) and [5](B9780080571157500054."
"xhtml) we were concerned with building two particular programs, GPS and "
"ELIZA. In this chapter, we will reexamine those two programs to discover "
"some common patterns.\n"
"Those patterns will be abstracted out to form reusable software tools that "
"will prove helpful in subsequent chapters."
msgstr ""
"В [главах 4](B9780080571157500042.xhtml) и [5](B9780080571157500054.xhtml) "
"мы были заинтересованы в создании двух конкретных программ, GPS и ELIZA. В "
"этой главе мы еще раз рассмотрим эти две программы, чтобы выявить некоторые "
"общие закономерности(шаблоны).\n"
"Эти закономерности(шаблоны) будут абстрагированы, чтобы сформировать "
"программные инструменты для многократного использования, которые окажутся "
"полезными в следующих главах."

#: in/chapter6.md:12
msgid "## 6.1 An Interactive Interpreter Tool"
msgstr "## 6.1 Интерактивный Инструмент Интерпретатора"

#: in/chapter6.md:15
msgid ""
"The structure of the function `eliza` is a common one.\n"
"It is repeated below:"
msgstr ""
"Структура функции `eliza` обычная.\n"
"Она повторяется ниже:"

#: in/chapter6.md:23
msgid ""
"```lisp\n"
"(defun eliza ()\n"
"  \"Respond to user input using pattern matching rules.\"\n"
"  (loop\n"
"    (print 'eliza>)\n"
"    (print (flatten (use-eliza-rules (read))))))\n"
"```"
msgstr ""

#: in/chapter6.md:26
msgid ""
"Many other applications use this pattern, including Lisp itself.\n"
"The top level of Lisp could be defined as:"
msgstr ""
"Многие другие приложения используют этот шаблон, включая сам Лисп.\n"
"Верхний уровень Lisp можно определить как:"

#: in/chapter6.md:33
msgid ""
"```lisp\n"
"(defun lisp ()\n"
"  (loop\n"
"    (print '>)\n"
"    (print (eval (read)))))\n"
"```"
msgstr ""

#: in/chapter6.md:36
msgid ""
"The top level of a Lisp system has historically been called the \"read-eval-"
"print loop.\" Most modern Lisps print a prompt before reading input, so it "
"should really be called the \"prompt-read-eval-print loop,\" but there was "
"no prompt in some early systems like MacLisp, so the shorter name stuck.\n"
"If we left out the prompt, we could write a complete Lisp interpreter using "
"just four symbols:"
msgstr ""
"Верхний уровень системы Lisp исторически назывался \"read-eval-print loop/"
"циклом чтения-вычисления-печати(REPL)\". Большинство современных Лиспов "
"выводят приглашение перед чтением ввода, поэтому его на самом деле следует "
"называть \"цикл подсказка-чтение-вычисление-печать\", но в некоторых ранних "
"системах, таких как MacLisp, приглашения не было, поэтому более короткое имя "
"прижилось.\n"
"Если бы мы не указали приглашение, мы могли бы написать полный интерпретатор "
"Лиспа, используя всего четыре символа:"

#: in/chapter6.md:40
msgid ""
"```lisp\n"
"(loop (print (eval (read))))\n"
"```"
msgstr ""

#: in/chapter6.md:50
msgid ""
"It may seem facetious to say those four symbols and eight parentheses "
"constitute a Lisp interpreter.\n"
"When we write that line, have we really accomplished anything?\n"
"One answer to that question is to consider what we would have to do to write "
"a Lisp (or Pascal) interpreter in Pascal.\n"
"We would need a lexical analyzer and a symbol table manager.\n"
"This is a considerable amount of work, but it is all handled by `read`.\n"
"We would need a syntactic parser to assemble the lexical tokens into "
"statements.\n"
"`read` also handles this, but only because Lisp statements have trivial "
"syntax: the syntax of lists and atoms.\n"
"Thus `read` serves fine as a syntactic parser for Lisp, but would fail for "
"Pascal.\n"
"Next, we need the evaluation or interpretation part of the interpreter; "
"`eval` does this nicely, and could handle Pascal just as well if we parsed "
"Pascal syntax into Lisp expressions, `print` does much less work than `read` "
"or `eval`, but is still quite handy."
msgstr ""
"Может показаться шуткой утверждение, что эти четыре символа и восемь круглых "
"скобок составляют интерпретатор Лиспа.\n"
"Когда мы напишем эту строку, действительно ли мы чего-нибудь достигнем?\n"
"Один из ответов на этот вопрос - подумать о том, что нам нужно сделать, "
"чтобы написать интерпретатор Лиспа (или Паскаля) на Паскале.\n"
"Нам понадобится лексический анализатор и менеджер таблиц символов.\n"
"Это значительный объем работы, но все это выполняется с помощью `read`.\n"
"Нам понадобится синтаксический анализатор для сборки лексических токенов в "
"операторы.\n"
"`read` также обрабатывает это, но только потому, что операторы Lisp имеют "
"тривиальный синтаксис: синтаксис списков и атомов.\n"
"Таким образом, `read` отлично работает как синтаксический анализатор для "
"Лиспа, но не работает для Паскаля.\n"
"Затем нам понадобится часть интерпретатора, которая занимается оценкой(eval)/"
"вычислением или интерпретацией; `eval` делает это прекрасно, и с таким же "
"успехом может обрабатывать выражения Паскаля, если мы разберем синтаксис "
"Паскаля в выражениях Лиспа, `print` выполняет гораздо меньше работы, чем "
"`read` или `eval`, но все же довольно удобна."

#: in/chapter6.md:54
msgid ""
"The important point is not whether one line of code can be considered an "
"implementation of Lisp; it is to recognize common patterns of computation.\n"
"Both `eliza` and `lisp` can be seen as interactive interpreters that read "
"some input, transform or evaluate the input in some way, print the result, "
"and then go back for more input.\n"
"We can extract the following common pattern:"
msgstr ""
"Важный момент не в том, можно ли считать одну строчку кода реализацией "
"Лиспа, а в выявлении общих схем вычислений.\n"
"И `eliza`, и `lisp` можно рассматривать как интерактивные интерпретаторы, "
"которые читают некоторый ввод, преобразуют или вычисляют ввод каким-либо "
"образом, распечатывают результат и затем возвращаются за дополнительным "
"вводом.\n"
"Мы можем выделить следующий общий шаблон:"

#: in/chapter6.md:61
msgid ""
"```lisp\n"
"(defun *program* ()\n"
"  (loop\n"
"    (print *prompt*)\n"
"    (print (*transform* (read)))))\n"
"```"
msgstr ""

#: in/chapter6.md:66
msgid ""
"There are two ways to make use of recurring patterns like this: formally and "
"informally.\n"
"The informal alternative is to treat the pattern as a cliche or idiom that "
"will occur frequently in our writing of programs but will vary from use to "
"use.\n"
"When we want to write a new program, we remember writing or reading a "
"similar one, go back and look at the first program, copy the relevant "
"sections, and then modify them for the new program.\n"
"If the borrowing is extensive, it would be good practice to insert a comment "
"in the new program citing the original, but there would be no \"official\" "
"connection between the original and the derived program."
msgstr ""
"Есть два способа использовать повторяющиеся шаблоны, подобные этому: "
"формально и неформально.\n"
"Неформальная альтернатива - рассматривать шаблон как клише или идиому, "
"которые будут часто встречаться при написании программ, но будут "
"варьироваться от одного использования к другому.\n"
"Когда мы захотим написать новую программу, мы вспоминаем, как писали или "
"читали похожую, возвращаемся назад и смотрим на первую программу, копируем "
"соответствующие разделы, а затем изменяем их для новой программы.\n"
"Если заимствование обширное, было бы хорошей практикой вставить комментарий "
"в новую программу со ссылкой на оригинал, но тогда бы небыло никакой "
"\"официальной\" связи между исходной и производной программой."

#: in/chapter6.md:69
msgid ""
"The formal alternative is to create an abstraction, in the form of functions "
"and perhaps data structures, and refer explicitly to that abstraction in "
"each new application-in other words, to capture the abstraction in the form "
"of a useable software tool.\n"
"The interpreter pattern could be abstracted into a function as follows:"
msgstr ""
"Формальной альтернативой является создание абстракции в форме функций и, "
"возможно, структур данных, и явной ссылки на эту абстракцию в каждом новом "
"приложении - другими словами, для фиксации абстракции в форме пригодного для "
"повторного использования программного инструмента.\n"
"Шаблон интерпретатора можно абстрагировать в функцию следующим образом:\n"

#: in/chapter6.md:77
msgid ""
"```lisp\n"
"(defun interactive-interpreter (prompt transformer)\n"
"  \"Read an expression, transform it, and print the result.\"\n"
"  (loop\n"
"    (print prompt)\n"
"    (print (funcall transformer (read)))))\n"
"```"
msgstr ""

#: in/chapter6.md:79
msgid "This function could then be used in writing each new interpreter:"
msgstr ""
"Затем эту функцию можно было бы использовать при написании каждого нового "
"интерпретатора:"

#: in/chapter6.md:83
msgid ""
"```lisp\n"
"(defun lisp ()\n"
"  (interactive-interpreter '> #'eval))"
msgstr ""

#: in/chapter6.md:88
msgid ""
"(defun eliza ()\n"
"  (interactive-interpreter 'eliza>\n"
"    #'(lambda (x) (flatten (use-eliza-rules x)))))\n"
"```"
msgstr ""

#: in/chapter6.md:90
msgid "Or, with the help of the higher-order function compose:"
msgstr "Или с помощью функции высшего порядка compose:"

#: in/chapter6.md:95
msgid ""
"```lisp\n"
"(defun compose (f g)\n"
"  \"Return the function that computes (f (g x)).\"\n"
"  #'(lambda (x) (funcall f (funcall g x))))"
msgstr ""

#: in/chapter6.md:100
msgid ""
"(defun eliza ()\n"
"  (interactive-interpreter 'eliza>\n"
"    (compose #'flatten #'use-eliza-rules)))\n"
"```"
msgstr ""

#: in/chapter6.md:104
msgid ""
"There are two differences between the formal and informal approaches.\n"
"First, they look different.\n"
"If the abstraction is a simple one, as this one is, then it is probably "
"easier to read an expression that has the loop explicitly written out than "
"to read one that calls `interactive-interpreter`, since that requires "
"finding the definition of `interactive-interpreter` and understanding it as "
"well."
msgstr ""
"Есть два различия между формальным и неформальным подходами.\n"
"Во-первых, они выглядят поразному.\n"
"Если абстракция простая, как эта, то, вероятно, легче прочитать выражение, в "
"котором цикл явно выписан, чем прочитать выражение, вызывающее `interactive-"
"interpreter`(интерактивный интерпретатор), поскольку для этого требуется "
"найти определение `interactive-interpreter` и понять его.\n"

#: in/chapter6.md:113
msgid ""
"The other difference shows up in what's called *maintenance*.\n"
"Suppose we find a missing feature in the definition of the interactive "
"interpreter.\n"
"One such omission is that the `loop` has no exit.\n"
"I have been assuming that the user can terminate the loop by hitting some "
"interrupt (or break, or abort) key.\n"
"A cleaner implementation would allow the user to give the interpreter an "
"explicit termination command.\n"
"Another useful feature would be to handle errors within the interpreter.\n"
"If we use the informal approach, then adding such a feature to one program "
"would have no effect on the others.\n"
"But if we use the formal approach, then improving `interactive-interpreter` "
"would automatically bring the new features to all the programs that use it."
msgstr ""
"Другое отличие проявляется в так называемом *обслуживании/сопровождение*.\n"
"Предположим, мы обнаружили недостаточную функциональность в определении "
"интерактивного интерпретатора.\n"
"Одно из таких упущений состоит в том, что `loop` не имеет выхода.\n"
"Я предполагал, что пользователь может завершить цикл, нажав какую-либо "
"клавишу прерывания (или break, или abort).\n"
"Более понятная реализация позволила бы пользователю дать интерпретатору "
"явную команду завершения.\n"
"Еще одна полезная функция - обработка ошибок в интерпретаторе.\n"
"Если мы будем использовать неформальный подход, то добавление такой "
"возможности в одну программу не повлияет на другие.\n"
"Но если мы воспользуемся формальным подходом, то улучшение `interactive-"
"interpreter`(интерактивного интерпретатора) автоматически внесет новую "
"функциональность во все программы, которые её используют."

#: in/chapter6.md:119
msgid ""
"The following version of `interactive-interpreter` adds two new features.\n"
"First, it uses the macro `handler-case`[1](#fn0015) to handle errors.\n"
"This macro evaluates its first argument, and normally just returns that "
"value.\n"
"However, if an error occurs, the subsequent arguments are checked for an "
"error condition that matches the error that occurred.\n"
"In this use, the case `error` matches all errors, and the action taken is to "
"prints the error condition and continue."
msgstr ""
"Следующая версия `interactive-interpreter` добавляет две новых возможности.\n"
"Во-первых, она использует макрос `handler-case` [1](# fn0015) для обработки "
"ошибок.\n"
"Этот макрос вычисляет свой первый аргумент и обычно просто возвращает это "
"значение.\n"
"Однако при возникновении ошибки последующие аргументы проверяются на наличие "
"условия ошибки, которое соответствует возникшей ошибке.\n"
"При таком использовании, в случае `error` соответствует всем ошибкам, и "
"предпринимаемое действие - распечатать состояние ошибки и продолжить."

#: in/chapter6.md:122
msgid ""
"This version also allows the prompt to be either a string or a function of "
"no arguments that will be called to print the prompt.\n"
"The function `prompt-generator`, for example, returns a function that will "
"print prompts of the form [1], [2], and so forth."
msgstr ""
"Эта версия также позволяет приглашению быть либо строкой, либо функцией без "
"аргументов, которая будет вызываться для печати приглашения.\n"
"Например, функция `prompt-generator` возвращает функцию, которая будет "
"печатать подсказки вида [1], [2] и так далее."

#: in/chapter6.md:137
msgid ""
"```lisp\n"
"(defun interactive-interpreter (prompt transformer)\n"
"   \"Read an expression, transform it, and print the result.\"\n"
"   (loop\n"
"      (handler-case\n"
"\t  (progn\n"
"\t    (if (stringp prompt)\n"
"\t\t(print prompt)\n"
"\t\t(funcall prompt))\n"
"\t    (print (funcall transformer (read))))\n"
"\t;; In case of error, do this:\n"
"\t(error (condition)\n"
"\t  (format t \"~&;; Error ~a ignored, back to top level.\"\n"
"\t\t  condition)))))"
msgstr ""

#: in/chapter6.md:142
msgid ""
"(defun prompt-generator (&optional (num 0) (ctl-string \"[~d] \"))\n"
"  \"Return a function that prints prompts like [l], [2], etc.\"\n"
"  #'(lambda () (format t ctl-string (incf num))))\n"
"```"
msgstr ""

#: in/chapter6.md:144
msgid "## 6.2 A Pattern-Matching Tool"
msgstr "## 6.2 Инструмент Сопоставления с образцом"

#: in/chapter6.md:147
msgid ""
"The `pat-match` function was a pattern matcher defined specifically for the "
"ELIZA program.\n"
"Subsequent programs will need pattern matchers too, and rather than write "
"specialized matchers for each new program, it is easier to define one "
"general pattern matcher that can serve most needs, and is extensible in case "
"novel needs come up."
msgstr ""
"Функция `pat-match` была средством сопоставления с образцом, определенным "
"специально для программы ELIZA.\n"
"Последующим программам также потребуются сопоставители с образцами, и вместо "
"того, чтобы писать специализированные сопоставители для каждой новой "
"программы, легче определить один общий сопоставитель с образцом, который "
"может удовлетворить большинство потребностей и может быть расширен в случае "
"возникновения новых потребностей."

#: in/chapter6.md:150
msgid ""
"The problem in designing a \"general\" tool is deciding what features to "
"provide.\n"
"We can try to define features that might be useful, but it is also a good "
"idea to make the list of features open-ended, so that new ones can be easily "
"added when needed."
msgstr ""
"Проблема при разработке \"общего\" инструмента - решить, какие функции "
"предоставить.\n"
"Мы можем попытаться определить функции, которые могут быть полезны, но также "
"неплохо сделать список функций открытым, чтобы при необходимости можно было "
"легко добавлять новые."

#: in/chapter6.md:156
msgid ""
"Features can be added by generalizing or specializing existing ones.\n"
"For example, we provide segment variables that match zero or more input "
"elements.\n"
"We can specialize this by providing for a kind of segment variable that "
"matches one or more elements, or for an optional variable that matches zero "
"or one element.\n"
"Another possibility is to generalize segment variables to specify a match of "
"*m* to *n* elements, for any specified *m* and *n*.\n"
"These ideas come from experience with notations for writing regular "
"expressions, as well as from very general heuristics for generalization, "
"such as \"consider important special cases\" and \"zero and one are likely "
"to be important special cases.\""
msgstr ""
"Функции могут быть добавлены путем обобщения или специализации уже "
"существующих.\n"
"Например, мы предоставляем сегментные переменные, которые соответствуют нулю "
"или нескольким входным элементам.\n"
"Мы можем специализировать эту функциональность, предоставляя своего рода "
"сегментную переменную, которая соответствует одному или нескольким "
"элементам, или необязательную переменную, которая соответствует нулю или "
"одному элементу.\n"
"Другая возможность состоит в том, чтобы обобщить сегментные переменные, "
"чтобы указать соответствие *m* к *n* элементов, для любого заданного *m* и "
"*n*.\n"
"Эти идеи приходят из опыта работы с нотациями для написания регулярных "
"выражений, а также из очень общих эвристик для обобщения, таких как "
"\"рассмотрения важных частных случаев\" и \"ноль и один, вероятно, будут "
"важными частными случаями\"."

#: in/chapter6.md:160
msgid ""
"Another useful feature is to allow the user to specify an arbitrary "
"predicate that a match must satisfy.\n"
"The notation `(?is ?n numberp)` could be used to match any expression that "
"is a number and bind it to the variable `?n`.\n"
"This would look like:"
msgstr ""
"Еще одна полезная функциональность заключается в том, чтобы позволить "
"пользователю указать произвольный предикат, которому должно соответствовать "
"сопоставление.\n"
"Обозначение `(?is ?n numberp)` может быть использовано для сопоставления "
"любого выражения, которое является числом, и привязки его к переменной `?"
"n`.\n"
"Это будет выглядеть как-то так:"

#: in/chapter6.md:165
msgid ""
"```lisp\n"
"> (pat-match '(x = (?is ?n numberp)) '(x = 34)) => ((?n . 34))\n"
"> (pat-match '(x = (?is ?n numberp)) '(x = x)) => NIL\n"
"```"
msgstr ""

#: in/chapter6.md:169
msgid ""
"Since patterns are like boolean expressions, it makes sense to allow boolean "
"operators on them.\n"
"Following the question-mark convention, we will use `?and`, `?or` and `?not` "
"for the operators.[2](#fn0020) Here is a pattern to match a relational "
"expression with one of three relations.\n"
"It succeeds because the < matches one of the three possibilities specified "
"by `(?or < = >).`"
msgstr ""
"Поскольку образцы подобны булевым(логическим) выражениям, имеет смысл "
"разрешить булевы операторы над ними.\n"
"Следуя соглашению о вопросительном знаке в именах переменных, мы будем "
"использовать `?and`, `?or` и `?not` для операторов.[2](#fn0020) Вот образец "
"для сопоставления реляционного выражения с одним из трех отношений.\n"
"Оно удачно, потому что < соответствует одной из трех возможностей, указанных "
"как `(?or < = >).`"

#: in/chapter6.md:173
msgid ""
"```lisp\n"
"> (pat-match '(?x (?or < = >) ?y) '(3 < 4)) => ((?Y . 4) (?X . 3))\n"
"```"
msgstr ""

#: in/chapter6.md:175
msgid ""
"Here is an example of an `?and` pattern that checks if an expression is both "
"a number and odd:"
msgstr ""
"Вот пример образца с `?and`, который проверяет является ли выражение "
"одновременно числом и при этом еще нечетным:"

#: in/chapter6.md:179
msgid ""
"```lisp\n"
"> (pat-match '(x = (?and (?is ?n numberp) (?is ?n oddp))) '(x = 3)) => ((?"
"N . 3))\n"
"```"
msgstr ""

#: in/chapter6.md:181
msgid "The next pattern uses `?not` to insure that two parts are not equal:"
msgstr ""
"В следующем образце использование `?not` гарантирует, что две части не равны:"

#: in/chapter6.md:185
msgid ""
"```lisp\n"
"> (pat-match '(?x /= (?not ?x)) '(3 /= 4)) => ((?X . 3))\n"
"```"
msgstr ""

#: in/chapter6.md:190
msgid ""
"The segment matching notation we have seen before.\n"
"It is augmented to allow for three possibilities: zero or more expressions; "
"one or more expressions; and zero or one expressions.\n"
"Finally, the notation `(?if *exp*)` can be used to test a relationship "
"between several variables.\n"
"It has to be listed as a segment pattern rather than a single pattern "
"because it does not consume any of the input at all:"
msgstr ""
"Обозначение сегментных совпадений мы видели ранее.\n"
"Оно расширено, чтобы учесть три возможности: ноль или более выражений; одно "
"или более выражений; и ноль или одно выражения.\n"
"Наконц, обозначение `(?if *exp*)` может использоваться для проверки связи "
"между несколькими переменными. Оно должно быть указано как сегментный "
"образец, а не как отдельный образец, потому что оно вообще не использует "
"вход:"

#: in/chapter6.md:195
msgid ""
"```lisp\n"
"> (pat-match '(?x > ?y (?if (> ?x ?y))) '(4 > 3)) =>\n"
"((?Y . 3) (?X . 4))\n"
"```"
msgstr ""

#: in/chapter6.md:198
msgid ""
"When the description of a problem gets this complicated, it is a good idea "
"to attempt a more formal specification.\n"
"The following table describes a grammar of patterns, using the same grammar "
"rule format described in [chapter 2](B9780080571157500029.xhtml)."
msgstr ""
"Когда описание проблемы становиться таким сложным, рекомендуется попытаться "
"сформулировать более формальную спецификацию.\n"
"В следующей таблице описана граматика образцов с испольованием того же "
"формата правил грамматики, который описан в [chapter 2](B9780080571157500029."
"xhtml)."

#: in/chapter6.md:216
msgid ""
"| []()              |                        "
"|                                                   |\n"
"|-------------------|------------------------|---------------------------------------------------|\n"
"| *pat*=>           | *var*                  | match any one "
"expression                          |\n"
"|                   | *Constant*             | match just this "
"atom                              |\n"
"|                   | *segment*-*pat*        | match something against a "
"sequence                |\n"
"|                   | *single*-*pat*         | match something against one "
"expression            |\n"
"|                   | (*pat* . *pat*)         | match the first and the "
"rest                      |\n"
"| *single*-*pat*=>  | (?is *var predicate*) | test predicate on one "
"expression                  |\n"
"|                   | (?or *pat*...)        | match any pattern on one "
"expression               |\n"
"|                   | (?and *pat*...)       | match every pattern on one "
"expression             |\n"
"|                   | (?not *pat*...)       | succeed if pattern(s) do not "
"match                |\n"
"| *segment*-*pat*=> | ( (?* *var*)...)       | match zero or more "
"expressions                    |\n"
"|                   | ( (?+ *var*) ... )     | match one or more "
"expressions                     |\n"
"|                   | ( ( ?? *var*) ... )    | match zero or one "
"expression                      |\n"
"|                   | ( ( ?if *exp* )...)   | test if exp (which may contain "
"variables) is true |\n"
"| *Var* =>          | ?*chars*               | a symbol starting "
"with ?                          |\n"
"| *constant* =>     | *atom*                 | any nonvariable "
"atom                              |"
msgstr ""
"| входн.символ      | выходной символ или значение |     "
"расшифровка                               |\n"
"|-------------------|------------------------|---------------------------------------------------|\n"
"| *pat* =>          | *var*                  | соответствие  одному "
"произвольному выражению      |\n"
"|                   | *Constant*             | соответствие  только этому "
"атому                  |\n"
"|                   | *segment-pat*          | соответствие какой то "
"последовательности          |\n"
"|                   | *single-pat*           | соответствие чего-либо с "
"одним выражением         |\n"
"|                   | (*pat* . *pat*)        | соответствие первого и "
"остатка                    |\n"
"| *single-pat* =>   | (?is *var predicate*)  | тестовый предикат для одного "
"выражения            |\n"
"|                   | (?or *pat*...)         | соответствие любому образцу в "
"одном выражении     |\n"
"|                   | (?and *pat*...)        | соответствие всем образцам в "
"одном выражении      |\n"
"|                   | (?not *pat*...)        | соответствует, если образец "
"не совпадает          |\n"
"| *segment-pat* =>  | ( (?* *var*)...)       | соответствие нулю или более "
"выражений            |\n"
"|                   | ( (?+ *var*) ... )     | соответствие одному или "
"нескольким выражениям    |\n"
"|                   | ( ( ?? *var*) ... )    | соответствие нулю или одному "
"выражинию           |\n"
"|                   | ( ( ?if *exp* )...)    | тест если exp ( может иметь "
"перем.) истинно      |\n"
"| *Var* =>          | ?chars                 | некоторый символ начинающийся "
"с  ?               |\n"
"| *constant* =>     | *atom*                 | любой неизменяемый "
"атом                          |"

#: in/chapter6.md:220
msgid ""
"Despite the added complexity, all patterns can still be classified into five "
"cases.\n"
"The pattern must be either a variable, constant, a (generalized) segment "
"pattern, a (generalized) single-element pattern, or a cons of two patterns.\n"
"The following definition of `pat-match` reflects the five cases (along with "
"two checks for failure):"
msgstr ""
"Не смотря на дополнительную сложность, все образцы можно разделить на пять "
"случаев.\n"
"Образец должен быть либо переменнной, либо константой, либо (обобщенным) "
"сегментынм образцом, либо (обобщенным) одноэлементным образцом, либо "
"конструкцией(точечной парой) из двух образцов.\n"
"Следующее определение `pat-match` отражает пять случаев (вместе с двумя "
"проверками на неудачу):"

#: in/chapter6.md:238
msgid ""
"```lisp\n"
"(defun pat-match (pattern input &optional (bindings no-bindings))\n"
"  \"Match pattern against input in the context of the bindings\"\n"
"  (cond ((eq bindings fail) fail)\n"
"    ((variable-p pattern)\n"
"      (match-variable pattern input bindings))\n"
"    ((eql pattern input) bindings)\n"
"    ((segment-pattern-p pattern)\n"
"      (segment-matcher pattern input bindings))\n"
"    ((single-pattern-p pattern) ; ***\n"
"      (single-matcher pattern input bindings)) ; ***\n"
"    ((and (consp pattern) (consp input))\n"
"      (pat-match (rest pattern) (rest input)\n"
"            (pat-match (first pattern) (first input)\n"
"                bindings)))\n"
"    (t fail)))\n"
"```"
msgstr ""

#: in/chapter6.md:240
msgid ""
"For completeness, we repeat here the necessary constants and low-level "
"functions from ELIZA:"
msgstr ""
"Для полноты картины, повтрим необходимые константы и низкоуровневые функции "
"из ELIZA:"

#: in/chapter6.md:243
msgid ""
"```lisp\n"
"(defconstant fail nil \"Indicates pat-match failure\")"
msgstr ""

#: in/chapter6.md:246
msgid ""
"(defconstant no-bindings '((t . t))\n"
"  \"Indicates pat-match success, with no variables.\")"
msgstr ""

#: in/chapter6.md:250
msgid ""
"(defun variable-p (x)\n"
"  \"Is x a variable (a symbol beginning with '?')?\"\n"
"  (and (symbolp x) (equal (elt (symbol-name x) 0) #\\?)))"
msgstr ""

#: in/chapter6.md:254
msgid ""
"(defun get-binding (var bindings)\n"
"  \"Find a (variable . value) pair in a binding list.\"\n"
"  (assoc var bindings))"
msgstr ""

#: in/chapter6.md:258
msgid ""
"(defun binding-var (binding)\n"
"  \"Get the variable part of a single binding.\"\n"
"  (car binding))"
msgstr ""

#: in/chapter6.md:262
msgid ""
"(defun binding-val (binding)\n"
"  \"Get the value part of a single binding.\"\n"
"  (cdr binding))"
msgstr ""

#: in/chapter6.md:264
msgid "(defun make-binding (var val) (cons var val))"
msgstr ""

#: in/chapter6.md:268
msgid ""
"(defun lookup (var bindings)\n"
"  \"Get the value part (for var) from a binding list.\"\n"
"  (binding-val (get-binding var bindings)))"
msgstr ""

#: in/chapter6.md:277
msgid ""
"(defun extend-bindings (var val bindings)\n"
"  \"Add a (var . value) pair to a binding list.\"\n"
"  (cons (make-binding var val)\n"
"    ;; Once we add a \"real\" binding,\n"
"    ;; we can get rid of the dummy no-bindings\n"
"    (if (eq bindings no-bindings)\n"
"      nil\n"
"      bindings)))"
msgstr ""

#: in/chapter6.md:285
msgid ""
"(defun match-variable (var input bindings)\n"
"  \"Does VAR match input? Uses (or updates) and returns bindings.\"\n"
"  (let ((binding (get-binding var bindings)))\n"
"    (cond ((not binding) (extend-bindings var input bindings))\n"
"      ((equal input (binding-val binding)) bindings)\n"
"      (t fail))))\n"
"```"
msgstr ""

#: in/chapter6.md:293
msgid ""
"The next step is to define the predicates that recognize generalized segment "
"and single-element patterns, and the matching functions that operate on "
"them.\n"
"We could implement `segment-matcher` and `single-matcher` with case "
"statements that consider all possible cases.\n"
"However, that would make it difficult to extend the matcher.\n"
"A programmer who wanted to add a new kind of segment pattern would have to "
"edit the definitions of both `segment-pattern-p` and `segment-matcher` to "
"install the new feature.\n"
"This by itself may not be too bad, but consider what happens when two "
"programmers each add independent features.\n"
"If you want to use both, then neither version of `segment-matcher` (or "
"`segment-pattern-p`) will do.\n"
"You'll have to edit the functions again, just to merge the two extensions."
msgstr ""
"Следующим шагом является определение предикатов, распознающих обобщенные "
"сегментные и одноэлементные образцы, а также функции сопоставления, которые "
"работают с ними.\n"
"Мы могли бы реализовать `segment-matcher` и `single-matcher` с операторами "
"case, которые учитывают все возможные случаи.\n"
"Однако это затруднило бы расширение сопоставителя.\n"
"Программист, который захотел бы добавить новый тип сегментного образца, "
"должен был бы отредактировать определения как `segment-pattern-p`, так и "
"`segment-matcher`, чтобы добавить новую функциональность.\n"
"Само по себе это может быть неплохо, но подумайте, что произойдет, когда два "
"программиста добавляют независимую функциональность одновременно.\n"
"Если вы захотите использовать и ту и другую, то ни одна из версий `segment-"
"matcher` (или `segment-pattern-p`) не подойдет.\n"
"Вам придется снова отредактировать функции, чтобы просто объединить эти два "
"расширения."

#: in/chapter6.md:297
msgid ""
"The solution to this dilemma is to write one version of `segment-pattern-p` "
"and `segment-matcher`, once and for all, but to have these functions refer "
"to a table of pattern/action pairs.\n"
"The table would say \"if you see `?*` in the pattern, then use the function "
"`segment-match`,\" and so on.\n"
"Then programmers who want to extend the matcher just add entries to the "
"table, and it is trivial to merge different extensions (unless of course two "
"programmers have chosen the same symbol to mark different actions)."
msgstr ""
"Решение этой дилеммы состоит в том, чтобы раз и навсегда написать одну "
"версию `segment-pattern-p` и `segment-matcher`, но чтобы эти функции "
"ссылались на таблицу пар образец/действие(pattern/action).\n"
"В таблице будет сказано \"если вы видите `?*` в образце, тогда используйте "
"функцию `segment-match`\" и так далее.\n"
"Затем программисты, которые хотят расширить сопоставитель, просто добавляют "
"записи в таблицу, и тогда тривиально объединить разные расширения (если, "
"конечно, два программиста не выбрали один и тот же символ для обозначения "
"различных действий)."

#: in/chapter6.md:300
msgid ""
"This style of programming, where pattern/action pairs are stored in a table, "
"is called *data*-*driven programming*.\n"
"It is a very flexible style that is appropriate for writing extensible "
"systems."
msgstr ""
"Такой стиль программирования, при котором пары образец/действие хранятся в "
"таблице, называется программированием, управляемым данными, т.е.: *data-"
"driven* *programming*.\n"
"Это очень гибкий стиль, подходящий для написания расширяемых систем."

#: in/chapter6.md:307
msgid ""
"There are many ways to implement tables in Common Lisp, as discussed in "
"[section 3.6](B9780080571157500030.xhtml#s0080), [page 73]"
"(B9780080571157500030.xhtml#p73).\n"
"In this case, the keys to the table will be symbols  (like `?*`), and it is "
"fine if the representation of the table is distributed across memory.\n"
"Thus, property lists are an appropriate choice.\n"
"We will have two tables, represented by the `segment-match` property and the "
"`single-match` property of symbols like `?*`.\n"
"The value of each property will be the name of a function that implements "
"the match.\n"
"Here are the table entries to implement the grammar listed previously:"
msgstr ""
"Есть много способов реализовать таблицы в  Common Lisp, как обсуждалось в "
"[section 3.6](B9780080571157500030.xhtml#s0080), [page 73]"
"(B9780080571157500030.xhtml#p73).\n"
"В этом случае ключи к таблице будут символами  (подобно `?*`), и нормально, "
"если представление таблицы распределено в памяти.\n"
"Таким образом, списки свойств являются подходящим выбором.\n"
"У нас будет две таблицы, представляющих свойства `segment-match` и свойства "
"`single-match` для символов подобных `?*`.\n"
"Значение каждого свойства будет именем функции, которая реализует "
"сопоставление.\n"
"Вот записи таблицы для реализации описанной ранее грамматики:"

#: in/chapter6.md:318
msgid ""
"```lisp\n"
"(setf (get '?is 'single-match) 'match-is)\n"
"(setf (get '?or 'single-match) 'match-or)\n"
"(setf (get '?and 'single-match) 'match-and)\n"
"(setf (get '?not 'single-match) 'match-not)\n"
"(setf (get '?* 'segment-match) 'segment-match)\n"
"(setf (get '?+ 'segment-match) 'segment-match+)\n"
"(setf (get '?? 'segment-match) 'segment-match?)\n"
"(setf (get '?if 'segment-match) 'match-if)\n"
"```"
msgstr ""

#: in/chapter6.md:322
msgid ""
"With the table defined, we need to do two things.\n"
"First, define the \"glue\" that holds the table together: the predicates and "
"action-taking functions.\n"
"A function that looks up a data-driven function and calls it (such as "
"`segment-matcher` and `single-matcher`) is called a *dispatch function*."
msgstr ""
"Определив таблицу, нам нужно сделать две вещи.\n"
"Во-первых, определить \"клей\" скрепляющий таблицу: предикаты и функции "
"выполняющие действия.\n"
"Функция управляемая данными(нашей таблицей), которая находит функции и "
"вызывает их (такие как `segment-matcher` и `single-matcher`) называется "
"*функцией диспетчеризации*."

#: in/chapter6.md:329
msgid ""
"```lisp\n"
"(defun segment-pattern-p (pattern)\n"
"  \"Is this a segment-matching pattern like ((?* var) . pat)?\"\n"
"  (and (consp pattern) (consp (first pattern))\n"
"    (symbolp (first (first pattern)))\n"
"    (segment-match-fn (first (first pattern)))))"
msgstr ""

#: in/chapter6.md:335
msgid ""
"(defun single-pattern-p (pattern)\n"
"  \"Is this a single-matching pattern? \n"
"  E.g. (?is x predicate) (?and . patterns) (?or . patterns).\"\n"
"  (and (consp pattern)\n"
"      (single-match-fn (first pattern))))"
msgstr ""

#: in/chapter6.md:340
msgid ""
"(defun segment-matcher (pattern input bindings)\n"
"  \"Call the right function for this kind of segment pattern.\"\n"
"  (funcall (segment-match-fn (first (first pattern)))\n"
"        pattern input bindings))"
msgstr ""

#: in/chapter6.md:345
msgid ""
"(defun single-matcher (pattern input bindings)\n"
"  \"Call the right function for this kind of single pattern.\"\n"
"  (funcall (single-match-fn (first pattern))\n"
"        (rest pattern) input bindings))"
msgstr ""

#: in/chapter6.md:350
msgid ""
"(defun segment-match-fn (x)\n"
"  \"Get the segment-match function for x,\n"
"  if it is a symbol that has one.\"\n"
"  (when (symbolp x) (get x 'segment-match)))"
msgstr ""

#: in/chapter6.md:356
msgid ""
"(defun single-match-fn (x)\n"
"  \"Get the single-match function for x,\n"
"  if it is a symbol that has one.\"\n"
"  (when (symbolp x) (get x 'single-match)))\n"
"```"
msgstr ""

#: in/chapter6.md:359
msgid ""
"The last thing to do is define the individual matching functions.\n"
"First, the single-pattern matching functions:"
msgstr ""
"Последнее, что нужно сделать, это определить остальные функции "
"сопоставления.\n"
"Во превых, функции сопоставления с одним образцом:"

#: in/chapter6.md:371
msgid ""
"```lisp\n"
"(defun match-is (var-and-pred input bindings)\n"
"  \"Succeed and bind var if the input satisfies pred,\n"
"  where var-and-pred is the list (var pred).\"\n"
"  (let* ((var (first var-and-pred))\n"
"      (pred (second var-and-pred))\n"
"      (new-bindings (pat-match var input bindings)))\n"
"    (if (or (eq new-bindings fail)\n"
"        (not (funcall pred input)))\n"
"      fail\n"
"      new-bindings)))"
msgstr ""

#: in/chapter6.md:379
msgid ""
"(defun match-and (patterns input bindings)\n"
"  \"Succeed if all the patterns match the input.\"\n"
"  (cond ((eq bindings fail) fail)\n"
"      ((null patterns) bindings)\n"
"      (t (match-and (rest patterns) input\n"
"              (pat-match (first patterns) input\n"
"                  bindings)))))"
msgstr ""

#: in/chapter6.md:389
msgid ""
"(defun match-or (patterns input bindings)\n"
"  \"Succeed if any one of the patterns match the input.\"\n"
"  (if (null patterns)\n"
"      fail\n"
"        (let ((new-bindings (pat-match (first patterns)\n"
"                    input bindings)))\n"
"        (if (eq new-bindings fail)\n"
"          (match-or (rest patterns) input bindings)\n"
"          new-bindings))))"
msgstr ""

#: in/chapter6.md:397
msgid ""
"(defun match-not (patterns input bindings)\n"
"  \"Succeed if none of the patterns match the input\n"
"  This will never bind any variables.\"\n"
"  (if (match-or patterns input bindings)\n"
"      fail\n"
"      bindings))\n"
"```"
msgstr ""

#: in/chapter6.md:405
msgid ""
"Now the segment-pattern matching functions.\n"
"`segment-match` is similar to the version presented as part of ELIZA. The "
"difference is in how we determine `pos`, the position of the first element "
"of the input that could match the next element of the pattern after the "
"segment variable.\n"
"In ELIZA, we assumed that the segment variable was either the last element "
"of the pattern or was followed by a constant.\n"
"In the following version, we allow nonconstant patterns to follow segment "
"variables.\n"
"The function `first-match-pos` is added to handle this.\n"
"If the following element is in fact a constant, the same calculation is done "
"using `position`.\n"
"If it is not a constant, then we just return the first possible starting "
"position-unless that would put us past the end of the input, in which case "
"we return nil to indicate failure:"
msgstr ""
"Теперь функции сопоставления сегментных образцов.\n"
"`segment-match` аналогичен версии, представленной как часть ELIZA. Разница в "
"том, как мы определяем  `pos`, позицию первого элемента ввода, который может "
"соответствовать следующему элементу образца после сегментной переменной.\n"
"В ELIZA мы предполагали, что сегментная переменная была либо последним "
"элементом образца, либо сопровождалась константой.\n"
"В следующей версии, мы разрешаем не константные образцам следовать за "
"сегментными переменными.\n"
"Для обработки этого добавлена функция `first-match-pos`.\n"
"Если следующий элемент на самом деле является константой, тот же расчет "
"выполняется с использованием `position`.\n"
"Если это не константа, мы просто возвращаем первую возможную начальную "
"позицию - если только это не приведет к тому, что мы пройдем конец ввода, и "
"в этом случае мы возвращаем nil, чтобы указать на сбой:"

#: in/chapter6.md:424
msgid ""
"```lisp\n"
"(defun segment-match (pattern input bindings &optional (start 0))\n"
"  \"Match the segment pattern ((?* var) . pat) against input.\"\n"
"  (let ((var (second (first pattern)))\n"
"      (pat (rest pattern)))\n"
"    (if (null pat)\n"
"      (match-variable var input bindings)\n"
"      (let ((pos (first-match-pos (first pat) input start)))\n"
"        (if (null pos)\n"
"            fail\n"
"            (let ((b2 (pat-match\n"
"                    pat (subseq input pos)\n"
"                    (match-variable var (subseq input 0 pos)\n"
"                        bindings))))\n"
"              ;; If this match failed, try another longer one\n"
"              (if (eq b2 fail)\n"
"                (segment-match pattern input bindings (+ pos 1))\n"
"                b2)))))))"
msgstr ""

#: in/chapter6.md:433
msgid ""
" (defun first-match-pos (pat1 input start)\n"
"   \"Find the first position that pat1 could possibly match input,\n"
"   starting at position start. If pat1 is non-constant, then just  return "
"start.\"\n"
"   (cond ((and (atom pat1) (not (variable-p pat1)))\n"
"\t  (position pat1 input :start start :test #'equal))\n"
"\t ((<= start (length input)) start)\n"
"\t (t nil)))\n"
"```"
msgstr ""

#: in/chapter6.md:437
msgid ""
"In the first example below, the segment variable `?x` matches the sequence "
"(`b c`).\n"
"In the second example, there are two segment variables in a row.\n"
"The first successful match is achieved with the first variable, `?x`, "
"matching the empty sequence, and the second one, `?y`, matching (`b c`)."
msgstr ""
"В первом примере ниже сегментная переменная `?x` соответствует "
"последовательности (`b c`).\n"
"Во втором примере есть две сегментные переменные в строке.\n"
"Первое успешное совпадение достигается  первой переменной `?x` "
"соответствующей пустой последовательности, а второй `?y` соответствует (`b "
"c`)."

#: in/chapter6.md:442
msgid ""
"```lisp\n"
"> (pat-match '(a (?* ?x) d) '(a b c d)) => ((?X B C))\n"
"> (pat-match '(a (?* ?x) (?* ?y) d) '(a b c d))=> ((?Y B C) (?X))\n"
"```"
msgstr ""

#: in/chapter6.md:445
msgid ""
"In the next example, `?x` is first matched against nil and `?y` against (`b "
"c d` ), but that fails, so we try matching `?x` against a segment of length "
"one.\n"
"That fails too, but finally the match succeeds with `?x` matching the two-"
"element segment (`b c`), and `?y` matching (`d`)."
msgstr ""
"В следующем примере `?x` сначала сопоставляется с nil, а `?y` с (`b c d` ), "
"но это приводит к неудаче, поэтому мы пытаемся сопоставить `?x` с сегментом "
"единичной длины.\n"
"Это тоже приводит к неудаче, но наконец сопоставление проходит успешно с  `?"
"x` сопоставленным с двух элементным сегментом (`b c`) и  `?y` сопоставленным "
"с (`d`)."

#: in/chapter6.md:450
msgid ""
"```lisp\n"
" > (pat-match  '(a (?* ?x) (?* ?y) ?x ?y)  '(a b c d (b c) (d))) => ((?Y D) "
"(?X B C))\n"
"```\n"
"Given `segment-match`, it is easy to define the function to match one-or-"
"more elements and the function to match zero-or-one element:"
msgstr ""
"```lisp\n"
" > (pat-match  '(a (?* ?x) (?* ?y) ?x ?y)  '(a b c d (b c) (d))) => ((?Y D) "
"(?X B C))\n"
"```\n"
"Учитывая `segment-match`, легко определить функцию для сопоставления одного "
"или нескольких элементов и функцию для сопоставления нуля или одного "
"элемента:"

#: in/chapter6.md:455
msgid ""
"```lisp\n"
"(defun segment-match+ (pattern input bindings)\n"
"  \"Match one or more elements of input.\"\n"
"  (segment-match pattern input bindings 1))"
msgstr ""

#: in/chapter6.md:463
msgid ""
"(defun segment-match? (pattern input bindings)\n"
"  \"Match zero or one element of input.\"\n"
"  (let ((var (second (first pattern)))\n"
"      (pat (rest pattern)))\n"
"    (or (pat-match (cons var pat) input bindings)\n"
"      (pat-match pat input bindings))))\n"
"```"
msgstr ""

#: in/chapter6.md:467
msgid ""
"Finally, we supply the function to test an arbitrary piece of Lisp code.\n"
"It does this by evaluating the code with the bindings implied by the binding "
"list.\n"
"This is one of the few cases where it is appropriate to call `eval`: when we "
"want to give the user unrestricted access to the Lisp interpreter."
msgstr ""
"Наконец, мы предоставляем функцию для проверки произвольного фрагмента кода "
"Лиспа.\n"
"Это достигается путем выполнения кода с привязками подразумеваемыми списком "
"привязок.\n"
"Это один из немногих случаев, когда уместно вызвать `eval`: когда мы хотим "
"предоставить пользователю неограниченный доступ к интерпретатору Лисп."

#: in/chapter6.md:477
msgid ""
"```lisp\n"
"(defun match-if (pattern input bindings)\n"
"  \"Test an arbitrary expression involving variables\n"
"  The pattern looks like ((?if code) . rest).\"\n"
"  (and (progv (mapcar #'car bindings)\n"
"        (mapcar #'cdr bindings)\n"
"      (eval (second (first pattern))))\n"
"    (pat-match (rest pattern) input bindings)))\n"
"```"
msgstr ""
"```lisp\n"
"(defun match-if (pattern input bindings)\n"
"  \"Test an arbitrary expression involving variables\n"
"  The pattern looks like ((?if code) . rest).\"\n"
"  (and (progv (mapcar #'car bindings)\n"
"        (mapcar #'cdr bindings)\n"
"      (eval (second (first pattern))))\n"
"    (pat-match (rest pattern) input bindings)))\n"
"```\n"
"Прим. преводчика: код предложенный автором в common lisp не работает, т.к. "
"eval вычисляется в нулевом лексическом окружении, поэтому его создание с "
"помощью progv бесполезно.\n"
"Я предлагаю  реализовать эту функцию воспользовашись функцией подстановки "
"значений переменных в заданный образец с помощью функции sublis.\n"
"\n"
"\n"
"```lisp\n"
"(defun match-if (pattern input bindings)\n"
"  \"Проверить произвольное выражение с переменными\n"
"   Образец выглядит как ((?if code) . rest)\"\n"
"  (and (eval (sublis bindings (second (first pattern))))\n"
"       (pat-match (rest pattern) input bindings)))\n"
"```\n"

#: in/chapter6.md:480
msgid ""
"Here are two examples using `?if`.\n"
"The first succeeds because `(+  3 4)` is indeed `7`, and the second fails "
"because `(>  3 4)` is false."
msgstr ""
"Вот два примера использования `?if`.\n"
"Первый успешен, потому что `(+  3 4)` действительно `7`, и второй неудачен, "
"потому что `(>  3 4)` является ложным."

#: in/chapter6.md:485
msgid ""
"```lisp\n"
"> (pat-match  '(?x ?op ?y is ?z (?if (eql (?op ?x ?y) ?z))) '(3 + 4 is 7)) "
"=> ((?Z . 7) (?Y . 4) (?OP . +) (?X . 3))\n"
"> (pat-match  '(?x ?op ?y (?if (?op ?x ?y))) '(3 > 4)) => NIL\n"
"```"
msgstr ""

#: in/chapter6.md:490
msgid ""
"The syntax we have defined for patterns has two virtues: first, the syntax "
"is very general, so it is easy to extend.\n"
"Second, the syntax can be easily manipulated by `pat-match`.\n"
"However, there is one drawback: the syntax is a little verbose, and some may "
"find it ugly.\n"
"Compare the following two patterns:"
msgstr ""
"Синтаксис, который мы определили для образцов имеет два достоинства: во-"
"первых, синтаксис очень общий, поэтому его легко расширить.\n"
"Во-вторых, синтаксисом может легко управлять `pat-match`.\n"
"Однако, есть один недостаток: синтаксис многословен, и некоторые могут "
"счесть его уродливым.\n"
"Сравните следующие два образца:"

#: in/chapter6.md:495
msgid ""
"```lisp\n"
"(a (?* ?x) (?* ?y) d)\n"
"(a ?x* ?y* d)\n"
"```"
msgstr ""

#: in/chapter6.md:500
msgid ""
"Many readers find the second pattern easier to understand at a glance.\n"
"We could change `pat-match` to allow for patterns of the form `?x*`, but "
"that would mean `pat-match` would have a lot more work to do on every "
"match.\n"
"An alternative is to leave `pat-match` as is, but define another level of "
"syntax for use by human readers only.\n"
"That is, a programmer could type the second expression above, and have it "
"translated into the first, which would then be processed by `pat-match.`"
msgstr ""
"Многие читатели находят, что второй образец легче понять с первого взгляда.\n"
"Мы могли бы изменить `pat-match`, чтобы учесть образцы формы `?x*`, но это "
"означало бы, что `pat-match` будет выполнять гораздо больше работы, для "
"выполнения каждого соответствия.\n"
"Альтернативой является оставить `pat-match` как есть, но определить другой "
"уровень синтаксиса для использования только человеком читателем.\n"
"То есть программист может ввести второе выражение выше и преобразовать его в "
"первое, которое затем будет обработано с помощью `pat-match`."

#: in/chapter6.md:505
msgid ""
"In other words, we will define a facility to define a kind of pattern-"
"matching macro that will be expanded the first time the pattern is seen.\n"
"It is better to do this expansion once than to complicate `pat-match` and in "
"effect do the expansion every time a pattern is used.\n"
"(Of course, if a pattern is only used once, then there is no advantage.\n"
"But in most programs, each pattern will be used again and again.)"
msgstr ""
"Другими словами, мы определим средство для определения своего рода макроса "
"сопоставления с образцом, который будет расширен при первом просмотре "
"образца.\n"
"Лучше сделать это расширение один раз, чем усложнять `pat-match` и "
"фактически делать это расширение каждый раз, когда используется образец.\n"
"(Конечно, если образец используется только один раз, то нет никакого "
"преимущества.\n"
"Но в большинстве программ каждый образец будет использоваться снова и снова.)"

#: in/chapter6.md:508
msgid ""
"We need to define two functions: one to define pattern-matching macros, and "
"another to expand patterns that may contain these macros.\n"
"We will only allow symbols to be macros, so it is reasonable to store the "
"expansions on each symbol's property list:"
msgstr ""
"Нам нужно определить две функции: одну для определения макроса сопоставления "
"с образцом, а другую для развертывания образцов, которые могут содержать эти "
"макросы.\n"
"Мы разрешаем только символыам быть макросами, поэтому разумно хранить "
"расширение в списке свойств каждого символа:"

#: in/chapter6.md:514
msgid ""
"```lisp\n"
"(defun pat-match-abbrev (symbol expansion)\n"
"  \"Define symbol as a macro standing for a pat-match pattern.\"\n"
"  (setf (get symbol 'expand-pat-match-abbrev)\n"
"    (expand-pat-match-abbrev expansion))"
msgstr ""

#: in/chapter6.md:522
msgid ""
"(defun expand-pat-match-abbrev (pat)\n"
"  \"Expand out all pattern matching abbreviations in pat.\"\n"
"  (cond ((and (symbolp pat) (get pat 'expand-pat-match-abbrev)))\n"
"      ((atom pat) pat)\n"
"      (t (cons (expand-pat-match-abbrev (first pat))\n"
"          (expand-pat-match-abbrev (rest pat))))))\n"
"```"
msgstr ""

#: in/chapter6.md:524
msgid "We would use this facility as follows:"
msgstr "Мы бы использовали эту возможность следующим образом:"

#: in/chapter6.md:531
msgid ""
"```lisp\n"
"> (pat-match-abbrev '?x* '(?* ?x)) => (?* ?X)\n"
"> (pat-match-abbrev '?y* '(?* ?y)) => (?* ?Y)\n"
"> (setf axyd (expand-pat-match-abbrev '(a ?x* ?y* d))) => (A (?* ?X) (?* ?Y) "
"D)\n"
"> (pat-match axyd '(a b c d)) => ((?Y B C) (?X))\n"
"```"
msgstr ""

#: in/chapter6.md:534
msgid ""
"**Exercise  6**.**1** [**m**] Go back and change the ELIZA rules to use the "
"abbreviation facility.\n"
"Does this make the rules easier to read?"
msgstr ""
"**Exercise  6**.**1** [**m**] Вернитесь назад и измените правила ELIZA, "
"чтобы использовать возможность сокращения.\n"
"Легче ли стало читать правила?"

#: in/chapter6.md:537
msgid ""
"**Exercise  6**.**2** [**h**] In the few prior examples, every time there "
"was a binding of pattern variables that satisfied the input, that binding "
"was found.\n"
"Informally, show that `pat-match` will always find such a binding, or show a "
"counterexample where it fails to find one."
msgstr ""
"**Exercise  6**.**2** [**h**] В нескольких предыдущих примерах эта привязка "
"обнаруживалась каждый раз, когда выполнялась привязка переменных образца, "
"удовлетворяющих входным данным.\n"
"Неформально покажите, что `pat-match` всегда найдет такую привязку, или "
"покажите контрпример, где она не может ее найти."

#: in/chapter6.md:539
msgid "## 6.3 A Rule-Based Translator Tool"
msgstr "## 6.3 Инструмент Преобразования На Основе Правил"

#: in/chapter6.md:543
msgid ""
"As we have defined it, the pattern matcher matches one input against one "
"pattern.\n"
"In `eliza`, we need to match each input against a number of patterns, and "
"then return a result based on the rule that contains the first pattern that "
"matches.\n"
"To refresh your memory, here is the function `use-eliza-rules`:"
msgstr ""
"Как мы определили, сопоставитель с образцом сопоставляет один ввод с одним "
"образцом.\n"
"В `eliza` нам нужно сопоставить каждый ввод с рядом образцов, а затем "
"вернуть результат на основе правила, содержащего первый совпадающий "
"образец.\n"
"Чтобы освежить вашу память, вот функция `use-eliza-rules`:"

#: in/chapter6.md:554
msgid ""
"```lisp\n"
"(defun use-eliza-rules (input)\n"
"  \"Find some rule with which to transform the input.\"\n"
"  (some #'(lambda (rule)\n"
"      (let ((result (pat-match (rule-pattern rule) input)))\n"
"        (if (not (eq result fail))\n"
"          (sublis (switch-viewpoint result)\n"
"            (random-elt (rule-responses rule))))))\n"
"    *eliza-rules*))\n"
"```"
msgstr ""

#: in/chapter6.md:557
msgid ""
"It turns out that this will be a quite common thing to do: search through a "
"list of rules for one that matches, and take action according to that rule.\n"
"To turn the structure of `use-eliza-rules` into a software tool, we will "
"allow the user to specify each of the following:"
msgstr ""
"Оказывается, это довольно обычная вещь: поиск в списке правил подходящего "
"правила и выполнение действий в соответствии с этим правилом.\n"
"Чтобы превратить структуру `use-eliza-rules` в программный инструмент, мы "
"позволим пользователю указать каждое из следующих действий:"

#: in/chapter6.md:560
msgid ""
"*   What kind of rule to use.\n"
"Every rule will be characterized by an if-part and a then-part, but the ways "
"of getting at those two parts may vary."
msgstr ""
"*   * Какое правило использовать.\n"
"Каждое правило будет охарактеризовано как if-part и then-part, но способы "
"достижения этих двух частей могут отличаться."

#: in/chapter6.md:563
msgid ""
"*   What list of rules to use.\n"
"In general, each application will have its own list of rules."
msgstr ""
"*   Какой список правил использовать.\n"
"Очень часто, для каждого приложения будет свой список правил."

#: in/chapter6.md:566
msgid ""
"*   How to see if a rule matches.\n"
"By default, we will use `pat-match`, but it should be possible to use other "
"matchers."
msgstr ""
"*   Как узнать, соответствует ли правило.\n"
"По умолчанию мы будем использовать `pat-match`, но должна быть возможность "
"использование других сопоставителей."

#: in/chapter6.md:570
msgid ""
"*   What to do when a rule matches.\n"
"Once we have determined which rule to use, we have to determine what it "
"means to use it.\n"
"The default is just to substitute the bindings of the match into the then-"
"part of the rule."
msgstr ""
"*   Что делать при совпадении правила.\n"
"После того как мы определили, какое правило использовать, мы должны "
"определить, что означает его использование.\n"
"По умолчанию привязка совпадения просто подставляется в часть then-part "
"правила."

#: in/chapter6.md:572
msgid "The rule-based translater tool now looks like this:"
msgstr "Инструмент преобразования на основе правил теперь выглядит так:"

#: in/chapter6.md:586
msgid ""
"```lisp\n"
"(defun rule-based-translator\n"
"      (input rules &key (matcher #'pat-match)\n"
"        (rule-if #'first) (rule-then #'rest) (action #'sublis))\n"
"  \"Find the first rule in rules that matches input,\n"
"  and apply the action to that rule.\"\n"
"  (some\n"
"    #'(lambda (rule)\n"
"        (let ((result (funcall matcher (funcall rule-if rule)\n"
"                input)))\n"
"        (if (not (eq result fail))\n"
"          (funcall action result (funcall rule-then rule)))))\n"
"    rules))"
msgstr ""

#: in/chapter6.md:594
msgid ""
"(defun use-eliza-rules (input)\n"
"  \"Find some rule with which to transform the input.\"\n"
"  (rule-based-translator input *eliza-rules*\n"
"    :action #'(lambda (bindings responses)\n"
"          (sublis (switch-viewpoint bindings)\n"
"                (random-elt responses)))))\n"
"```"
msgstr ""

#: in/chapter6.md:596
msgid "## 6.4 A Set of Searching Tools"
msgstr "## 6.4 набор инструментов поиска"

#: in/chapter6.md:607
msgid ""
"The GPS program can be seen as a problem in *search*.\n"
"In general, a search problem involves exploring from some starting state and "
"investigating neighboring states until a solution is reached.\n"
"As in GPS, *state* means a description of any situation or state of "
"affairs.\n"
"Each state may have several neighbors, so there will be a choice of how to "
"search.\n"
"We can travel down one path until we see it is a dead end, or we can "
"consider lots of different paths at the same time, expanding each path step "
"by step.\n"
"Search problems are called *nondeterministic* because there is no way to "
"determine what is the best step to take next.\n"
"AI problems, by their very nature, tend to be nondeterministic.\n"
"This can be a source of confusion for programmers who are used to "
"deterministic problems.\n"
"In this section we will try to clear up that confusion.\n"
"This section also serves as an example of how higher-order functions can be "
"used to implement general tools that can be specified by passing in specific "
"functions."
msgstr ""
"Программа GPS может рассматриваться как проблема решаемая *поиском*.\n"
"В общем, задача поиска включает нахождение(исследование/проверка) из "
"некоторого начального состояния и исследования соседних состояний, и т.д. "
"пока не будет найдено решение(необходимое состояние).\n"
"Как и в GPS, *состояние* означает описание любой ситуации или положения "
"дел.\n"
"У каждого состояния может быть несколько соседей, поэтому необходим выбор "
"способа поиска.\n"
"Мы можем идти по одному пути, пока не увидим, что это тупик, или мы можем "
"рассматривать множество разных путей одновременно, расширяя каждый путь шаг "
"за шагом.\n"
"Проблемы поиска называются *недетерминированными*, потому что невозможно "
"определить, что лучше всего предпринять дальше.\n"
"Проблемы ИИ по самой своей природе, как правило, недетерминированы.\n"
"Это может сбивать с толку программистов, привыкших к детерминированным "
"задачам.\n"
"В этом разделе мы попытаемся прояснить эту путаницу.\n"
"Этот раздел также служит примером того, как функции высшего порядка могут "
"использоваться для реализации общих инструментов, которые могут быть "
"определены при помощи передачи специальных функций."

#: in/chapter6.md:609
msgid "Abstractly, a search problem can be characterized by four features:"
msgstr "Абстрактно задачу поиска можно охарактеризовать четырьмя признаками:"

#: in/chapter6.md:611
msgid "*   The *start* state."
msgstr "*   *Начальное/start* состояние."

#: in/chapter6.md:613
msgid "*   The *goal* state (or states)."
msgstr "*   *Целевое/goal* состояние (или состояния)."

#: in/chapter6.md:615
msgid ""
"*   The *successors*, or states that can be reached from any other state."
msgstr ""
"*   *Наследники/преемники/successors* или состояния, которые могут быть "
"достигнуты из любого другого состояния.\n"

#: in/chapter6.md:617
msgid "*   The *strategy* that determines the *order* in which we search."
msgstr "*   *Стратегия/strategy*, определяющая *порядок* поиска."

#: in/chapter6.md:624
msgid ""
"The first three features are part of the problem, while the fourth is part "
"of the solution.\n"
"In GPS, the starting state was given, along with a description of the goal "
"states.\n"
"The successors of a state were determined by consulting the operators.\n"
"The search strategy was means-ends analysis.\n"
"This was never spelled out explicitly but was implicit in the structure of "
"the whole program.\n"
"In this section we will formulate a general searching tool, show how it can "
"be used to implement several different search strategies, and then show how "
"GPS could be implemented with this tool."
msgstr ""
"Первые три признака являются частью проблемы, а четвертый - частью решения.\n"
"В GPS было дано начальное состояние вместе с описанием состояний цели.\n"
"Состояния наследники определялись путем консультаций с операторами.\n"
"Стратегия поиска заключалась в анализе конечных целей.\n"
"Это никогда не оговаривалось явно, но было скрыто в структуре всей "
"программы.\n"
"В этом разделе мы сформулируем общий инструмент поиска, покажем, как его "
"можно использовать для реализации нескольких различных стратегий поиска, а "
"затем покажем, как с помощью этого инструмента можно реализовать GPS."

#: in/chapter6.md:631
msgid ""
"The first notion we have to define is the *state space*, or set of all "
"possible states.\n"
"We can view the states as nodes and the successor relation as links in a "
"graph.\n"
"Some state space graphs will have a small number of states, while others "
"have an infinite number, but they can still be solved if we search "
"cleverly.\n"
"Some graphs will have a regular structure, while others will appear random.\n"
"We will start by considering only trees-that is, graphs where a state can be "
"reached by only one unique sequence of successor links.\n"
"Here is a tree:"
msgstr ""
"Первое понятие, которое мы должны определить, - это *пространство состояний* "
"или набор всех возможных состояний.\n"
"Мы можем рассматривать состояния как узлы, а отношения к наследнику как "
"связи на графе.\n"
"Некоторые графы пространства состояний будут иметь небольшое количество "
"состояний, в то время как другие - бесконечное количество, но их все же "
"можно решить, если мы будем искать с умом.\n"
"Некоторые графы будут иметь регулярную структуру, в то время как другие - "
"случайную.\n"
"Мы начнем с рассмотрения только деревьев, то есть графов, в которых "
"состояние может быть достигнуто только одной уникальной последовательностью "
"ссылок на наследников/преемников.\n"
"Вот дерево:"

#: in/chapter6.md:633
msgid "![u06-01](images/chapter6/u06-01.jpg)"
msgstr ""

#: in/chapter6.md:635
msgid "### Searching Trees"
msgstr "### Поиск по Дереву"

#: in/chapter6.md:646
msgid ""
"We will call our first searching tool `tree-search`, because it is designed "
"to search state spaces that are in the form of trees.\n"
"It takes four arguments: (1) a list of valid starting states, (2) a "
"predicate to decide if we have reached a goal state, (3) a function to "
"generate the successors of a state, and (4) a function that decides in what "
"order to search.\n"
"The first argument is a list rather than a single state so that `tree-"
"search` can recursively call itself after it has explored several paths "
"through the state space.\n"
"Think of the first argument not as a starting state but as a list of "
"possible states from which the goal may be reached.\n"
"This lists represents the fringe of the tree that has been explored so far.\n"
"`tree-search` has three cases: If there are no more states to consider, then "
"give up and return `fail`.\n"
"If the first possible state is a goal state, then return the successful "
"state.\n"
"Otherwise, generate the successors of the first state and combine them with "
"the other states.\n"
"Order this combined list according to the particular search strategy and "
"continue searching.\n"
"Note that `tree-search` itself does not specify any particular searching "
"strategy."
msgstr ""
"Мы назовем наш первый инструмент поиска `tree-search`, потому что он "
"предназначен для поиска в пространстве состояний, которые имеют форму "
"деревьев.\n"
"Требуется четыре аргумента: (1) список допустимых начальных состояний, (2) "
"предикат, чтобы решить, достигли ли мы целевого состояния, (3) функция, "
"чтобы генерировать преемников состояния, и (4) функция, которая решает, в "
"каком порядке искать.\n"
"Первый аргумент-это список, а не одно состояние, так что `tree-search` может "
"рекурсивно вызвать себя после того, как он исследовал несколько путей в "
"пространстве состояний.\n"
"Думайте о первом аргументе не как о начальном состоянии, а как о списке "
"возможных состояний, из которых может быть достигнута цель.\n"
"Этот список представляет собой край дерева, который был исследован до сих "
"пор.\n"
"`tree-search` имеет три случая: если больше нет состояний для рассмотрения, "
"то алгоритм сдается и возвращает `fail`.\n"
"Если первое возможное состояние - это состояние цели, то возвращается "
"успешное состояние.\n"
"В противном случае создаются наследники/преемники первого состояния и "
"присоединяются к другим состояниям.\n"
"Порядок в этом комбинированном списке устанавливается в соответствии с "
"конкретной стратегией поиска и продолжает поиск.\n"
"Обратите внимание, что `tree-search` сам по себе не определяет никакой "
"конкретной стратегии поиска."

#: in/chapter6.md:660
msgid ""
"```lisp\n"
"(defun tree-search (states goal-p successors combiner)\n"
"  \"Find a state that satisfies goal-p.\n"
"   Start with states,and search according to successors and combiner.\"\n"
"  (dbg :search \"~&; ; Search: ~  a\" states)\n"
"  (cond ((null states) fail)\n"
"      ((funcall goal-p (first states)) (first states))\n"
"      (t (tree-search\n"
"          (funcall combiner\n"
"                (funcall successors (first states))\n"
"                (rest states))\n"
"          goal-p successors combiner))))\n"
"```"
msgstr ""

#: in/chapter6.md:668
msgid ""
"The first strategy we will consider is called *depth-first search*.\n"
"In depth-first search, the longest paths are considered first.\n"
"In other words, we generate the successors of a state, and then work on the "
"first successor first.\n"
"We only return to one of the subsequent successors if we arrive at a state "
"that has no successors at all.\n"
"This strategy can be implemented by simply appending the previous states to "
"the end of the list of new successors on each iteration.\n"
"The function `depth-first-search` takes a single starting state, a goal "
"predicate, and a successor function.\n"
"It packages the starting state into a list as expected by `tree-search`, and "
"specifies append as the combining function:"
msgstr ""
"Первая стратегия, которую мы рассмотрим, называется *поиск в глубину/depth-"
"first search*.\n"
"При поиске в глубину сначала рассматриваются самые длинные пути.\n"
"Другими словами, мы создаем наследников состояния, а затем сначала работаем "
"над первым наследником.\n"
"Мы возвращаемся к одному из последующих наследников только в том случае, "
"если достигаем состояния, в котором вообще нет наследников.\n"
"Эта стратегия может быть реализована простым добавлением предыдущих "
"состояний в конец списка новых наследников на каждой итерации.\n"
"Функция `depth-first-search` принимает одно начальное состояние, предикат "
"цели и функцию-наследников.\n"
"Она упаковывает начальное состояние в список, как и ожидалось при `tree-"
"search`, и указывает append в качестве комбинирующей функции:"

#: in/chapter6.md:674
msgid ""
"```lisp\n"
"(defun depth-first-search (start goal-p successors)\n"
"  \"Search new states first until goal is reached.\"\n"
"  (tree-search (list start) goal-p successors #'append))\n"
"```"
msgstr ""

#: in/chapter6.md:680
msgid ""
"Let's see how we can search through the binary tree defined previously.\n"
"First, we define the successor function `binary-tree`.\n"
"It returns a list of two states, the two numbers that are twice the input "
"state and one more than twice the input state.\n"
"So the successors of 1 will be 2 and 3, and the successors of 2 will be 4 "
"and 5.\n"
"The `binary-tree` function generates an infinite tree of which the first 15 "
"nodes are diagrammed in our example."
msgstr ""
"Давайте посмотрим, как мы можем искать в двоичном дереве, определенном "
"ранее.\n"
"Сначала мы определяем функцию-генерации наследников `binary-tree`.\n"
"Она возвращает список из двух состояний: два числа, одно вдвое превышает "
"входное состояние, и второе на один больше первого.\n"
"Таким образом, наследниками 1 будут 2 и 3, а наследниками 2 будут 4 и 5.\n"
"Функция `binary-tree` генерирует бесконечное дерево, первые 15 узлов "
"которого показаны в нашем примере."

#: in/chapter6.md:684
msgid ""
"```lisp\n"
"(defun binary-tree (x) (list (* 2 x) (+  1 (* 2 x))))\n"
"```"
msgstr ""

#: in/chapter6.md:688
msgid ""
"To make it easier to specify a goal, we define the function is as a function "
"that returns a predicate that tests for a particular value.\n"
"Note that is does not do the test itself.\n"
"Rather, it returns a function that can be called to perform tests:"
msgstr ""
"Чтобы упростить определение цели, мы определяем функцию как функцию, которая "
"возвращает предикат, проверяющий конкретное значение.\n"
"Обратите внимание, что это не сам тест.\n"
"Скорее, он возвращает функцию, которую можно вызвать для выполнения тестов:"

#: in/chapter6.md:692
msgid ""
"```lisp\n"
"(defun is (value) #'(lambda (x) (eql x value)))\n"
"```"
msgstr ""

#: in/chapter6.md:695
msgid ""
"Now we can turn on the debugging output and search through the binary tree, "
"starting at 1, and looking for, say, 12, as the goal state.\n"
"Each line of debugging output shows the list of states that have been "
"generated as successors but not yet examined:"
msgstr ""
"Теперь мы можем включить вывод отладки и выполнить поиск в двоичном дереве, "
"начиная с 1 и ища, скажем, 12 в качестве состояния цели.\n"
"Каждая строка вывода отладки показывает список состояний, которые были "
"сгенерированы как наследники, но еще не исследованы:"

#: in/chapter6.md:713
msgid ""
"```lisp\n"
"> (debug :search) => (SEARCH)\n"
"> (depth-first-search 1 (is 12) #'binary-tree)\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (4 5 3)\n"
";; Search: (8 9 5 3)\n"
";; Search: (16 17 9 5 3)\n"
";; Search: (32 33 17 9 5 3)\n"
";; Search: (64 65 33 17 9 5 3)\n"
";; Search: (128 129 65 33 17 9 5 3)\n"
";; Search: (256 257 129 65 33 17 9 5 3)\n"
";; Search: (512 513 257 129 65 33 17 9 5 3)\n"
";; Search: (1024 1025 513 257 129 65 33 17 9 5 3)\n"
";; Search: (2048 2049 1025 513 257 129 65 33 17 9 5 3)\n"
"[Abort]\n"
"```"
msgstr ""

#: in/chapter6.md:716
msgid ""
"The problem is that we are searching an infinite tree, and the depth-first "
"search strategy just dives down the left-hand branch at every step.\n"
"The only way to stop the doomed search is to type an interrupt character."
msgstr ""
"Проблема в том, что мы ищем в бесконечном дереве, а стратегия поиска в "
"глубину просто ныряет вниз по левой ветви на каждом шаге.\n"
"Единственный способ остановить обреченный поиск - это набрать код прерывания."

#: in/chapter6.md:719
msgid ""
"An alternative strategy is *breadth-first search*, where the shortest path "
"is extended first at each step.\n"
"It can be implemented simply by appending the new successor states to the "
"end of the existing states:"
msgstr ""
"Альтернативной стратегией является *поиск в ширину/breadth-first search*, "
"когда кратчайший путь исследуется/продолжается первым на каждом шаге.\n"
"Её можно реализовать, просто добавив новые состояния-наследники в конец "
"существующих состояний:"

#: in/chapter6.md:722
msgid ""
"```lisp\n"
"(defun prepend (x y) \"Prepend y to start of x\" (append y x))"
msgstr ""

#: in/chapter6.md:727
msgid ""
"(defun breadth-first-search (start goal-p successors)\n"
"  \"Search old states first until goal is reached.\"\n"
"  (tree-search (list start) goal-p successors #'prepend))\n"
"```"
msgstr ""

#: in/chapter6.md:730
msgid ""
"The only difference between depth-first and breadth-first search is the "
"difference between `append` and `prepend`.\n"
"Here we see `breadth-first-search` in action:"
msgstr ""
"Единственная разница между поиском в глубину и в ширину - это разница между "
"`append` и `prepend`.\n"
"Здесь мы видим поиск в ширину - `breadth-first-search` - в действии:"

#: in/chapter6.md:747
msgid ""
"```lisp\n"
"> (breadth-first-search 1 (is 12) 'binary-tree)\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (3 4 5)\n"
";; Search: (4 5 6 7)\n"
";; Search: (5 6 7 8 9)\n"
";; Search: (6 7 8 9 10 11)\n"
";; Search: (7 8 9 10 11 12 13)\n"
";; Search: (8 9 10 11 12 13 14 15)\n"
";; Search: (9 10 11 12 13 14 15 16 17)\n"
";; Search: (10 11 12 13 14 15 16 17 18 19)\n"
";; Search: (11 12 13 14 15 16 17 18 19 20 21)\n"
";; Search: (12 13 14 15 16 17 18 19 20 21 22 23)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:753
msgid ""
"Breadth-first search ends up searching each node in numerical order, and so "
"it will eventually find any goal.\n"
"It is methodical, but therefore plodding.\n"
"Depth-first search will be much faster - if it happens to find the goal at "
"all.\n"
"For example, if we were looking for 2048, depth-first search would find it "
"in 12 steps, while breadth-first would take 2048 steps.\n"
"Breadth-first search also requires more storage, because it saves more "
"intermediate states."
msgstr ""
"Поиск в ширину сначала ищет соседей каждого узла в числовом порядке, и "
"поэтому он в конечном итоге найдет любую цель.\n"
"Это методично, а, следовательно медленно и тяжело.\n"
"Поиск в глубину  будет намного быстрее - если ему вообще удастся найти "
"цель.\n"
"Например, если бы мы искали 2048, то поиск в глубину занял бы 12 шагов, а "
"поиск в ширину-2048 шагов.\n"
"Поиск в ширину также требует большего объема памяти, поскольку он сохраняет "
"больше промежуточных состояний."

#: in/chapter6.md:761
msgid ""
"If the search tree is finite, then either breadth-first or depth-first will "
"eventually find the goal.\n"
"Both methods search the entire state space, but in a different order.\n"
"We will now show a depth-first search of the 15-node binary tree diagrammed "
"previously.\n"
"It takes about the same amount of time to find the goal (12) as it did with "
"breadth-first search.\n"
"It would have taken more time to find 15; less to find 8.\n"
"The big difference is in the number of states considered at one time.\n"
"At most, depth-first search considers four at a time; in general it will "
"need to store only *log2n* states to search a *n-node* tree, while breadth-"
"first search needs to store *n/2* states."
msgstr ""
"Если дерево поиска конечно, то цель в конечном итоге будет найдена либо "
"поиском в ширину, либо поиском в глубину.\n"
"Оба метода выполняют поиск во всем пространстве состояний, но в различном "
"порядке.\n"
"Теперь мы покажем поиск в глубину в двоичном дереве из 15 узлов, "
"представленном ранее.\n"
"На поиск цели (12) уходит примерно столько же времени, сколько и при поиске "
"в ширину.\n"
"Чтобы найти 15, потребовалось бы больше времени; и меньше, чтобы найти 8.\n"
"Большая разница в количестве состояний, рассматриваемых одновременно.\n"
"Самое большее, поиск в глубину рассматривает одновременно четыре; в общем, "
"для поиска по дереву *n-узлов* требуется хранить только состояния *log2 n*, "
"тогда как поиск в ширину должен сохранять состояния *n/2*."

#: in/chapter6.md:769
msgid ""
"```lisp\n"
"(defun finite-binary-tree (n)\n"
"  \"Return a successor function that generates a binary tree\n"
"  with n nodes.\"\n"
"  #'(lambda (x)\n"
"          (remove-if #'(lambda (child) (> child n))\n"
"                (binary-tree x))))"
msgstr ""

#: in/chapter6.md:771
msgid "```"
msgstr ""

#: in/chapter6.md:787
msgid ""
"```lisp\t\t\n"
"> (depth-first-search 1 (is 12) (finite-binary-tree 15))\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (4 5 3)\n"
";; Search: (8 9 5 3)\n"
";; Search: (9 5 3)\n"
";; Search: (5 3)\n"
";; Search: (10 11 3)\n"
";; Search: (11 3)\n"
";; Search: (3)\n"
";; Search: (6 7)\n"
";; Search: (12 13 7)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:789
msgid "### Guiding the Search"
msgstr "### Управление поиском"

#: in/chapter6.md:796
msgid ""
"While breadth-first search is more methodical, neither strategy is able to "
"take advantage of any knowledge about the state space.\n"
"They both search blindly.\n"
"In most real applications we will have some estimate of how far a state is "
"from the solution.\n"
"In such cases, we can implement a *best-first search*.\n"
"The name is not quite accurate; if we could really search best first, that "
"would not be a search at all.\n"
"The name refers to the fact that the state that *appears* to be best is "
"searched first."
msgstr ""
"Хотя поиск в ширину более методичен, ни одна из стратегий не может "
"использовать какие-либо знания о пространстве состояний.\n"
"Оба этих поиска ищут вслепую.\n"
"В большинстве реальных приложений мы будем иметь некоторую оценку того, "
"насколько далеко состояние находится от решения.\n"
"В таких случаях мы можем реализовать *поиск по первому наилучшему/best-"
"first*.\n"
"Название не совсем точное; если бы мы действительно могли найти первого "
"лучшего, это был бы совсем не поиск.\n"
"Название указывает на то, что вначале ищется состояние, которое *кажется* "
"лучшим."

#: in/chapter6.md:798
msgid ""
"To implement best-first search we need to add one more piece of information: "
"a cost function that gives an estimate of how far a given state is from the "
"goal."
msgstr ""
"Чтобы реализовать поиск \"первый-наилучший\", нам нужно добавить еще одну "
"информацию: функцию стоимости, которая дает оценку того, насколько далеко "
"данное состояние находится от цели."

#: in/chapter6.md:807
msgid ""
"For the binary tree example, we will use as a cost estimate the numeric "
"difference from the goal.\n"
"So if we are looking for 12, then 12 has cost 0, 8 has cost 4 and 2048 has "
"cost 2036.\n"
"The higher-order function `diff`, shown in the following, returns a cost "
"function that computes the difference from a goal.\n"
"The higher-order function sorter takes a cost function as an argument and "
"returns a combiner function that takes the lists of old and new states, "
"appends them together, and sorts the result based on the cost function, "
"lowest cost first.\n"
"(The built-in function `sort` sorts a list according to a comparison "
"function.\n"
"In this case the smaller numbers come first.\n"
"`sort` takes an optional `:key` argument that says how to compute the score "
"for each element.\n"
"Be careful - `sort` is a destructive function.)"
msgstr ""
"Например с бинарным деревом мы будем использовать в качестве оценки "
"стоимости численное отличие от цели.\n"
"Итак, если мы ищем 12, то 12 стоит 0, 8 стоит 4, а 2048 стоит 2036.\n"
"Функция высшего порядка `diff`, показанная ниже, возвращает функцию "
"стоимости, которая вычисляет отличие(дистанцию) от(до) цели.\n"
"Функция высшего порядка sorter принимает функцию стоимости в качестве "
"аргумента и возвращает объединенную функцию, которая берет списки старых и "
"новых состояний, соединяет их вместе и сортирует результат на основе функции "
"стоимости, ставя в начало наименьшую стоимость.\n"
"(Встроенная функция `sort` сортирует список в соответствии с функцией "
"сравнения.\n"
"В этом случае на первом месте стоят меньшие числа.\n"
"`sort` принимает необязательный аргумент `: key`, который говорит, как "
"вычислить цену для каждого элемента.\n"
"Будьте осторожны - `sort` - это разрушающая функция.)"

#: in/chapter6.md:812
msgid ""
"```lisp\n"
"(defun diff (num)\n"
"  \"Return the function that finds the difference from num.\"\n"
"  #'(lambda (x) (abs (- x num))))"
msgstr ""

#: in/chapter6.md:817
msgid ""
"(defun sorter (cost-fn)\n"
"  \"Return a combiner function that sorts according to cost-fn.\"\n"
"  #'(lambda (new old)\n"
"      (sort (append new old) #'< :key cost-fn)))"
msgstr ""

#: in/chapter6.md:822
msgid ""
"(defun best-first-search (start goal-p successors cost-fn)\n"
"  \"Search lowest cost states first until goal is reached.\"\n"
"  (tree-search (list start) goal-p successors (sorter cost-fn)))\n"
"```"
msgstr ""

#: in/chapter6.md:824
msgid ""
"Now, using the difference from the goal as the cost function, we can search "
"using best-first search:"
msgstr ""
"Теперь, используя отличие от цели в качестве функции стоимости, мы можем "
"искать с помощью поиска best-first:"

#: in/chapter6.md:836
msgid ""
"```lisp\n"
"> (best-first-search 1 (is 12) #'binary-tree (diff 12))\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6 2)\n"
";; Search: (14 15 6 2)\n"
";; Search: (15 6 2 28 29)\n"
";; Search: (6 2 28 29 30 31)\n"
";; Search: (12 13 2 28 29 30 31)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:841
msgid ""
"The more we know about the state space, the better we can search.\n"
"For example, if we know that all successors are greater than the states they "
"come from, then we can use a cost function that gives a very high cost for "
"numbers above the goal.\n"
"The function `price-is-right` is like `diff`, except that it gives a high "
"penalty for going over the goal.[3](#fn0025) Using this cost function leads "
"to a near-optimal search on this example.\n"
"It makes the \"mistake\" of searching 7 before 6 (because 7 is closer to "
"12), but does not waste time searching 14 and 15:"
msgstr ""
"Чем больше мы знаем о пространстве состояний, тем лучше мы можем искать.\n"
"Например, если мы знаем, что все наследники больше, чем состояния, из "
"которых они происходят, то мы можем использовать функцию стоимости, которая "
"дает очень высокую стоимость для чисел превышающих цель.\n"
"Функция `price-is-right` похожа на `diff`, за исключением того, что она дает "
"высокий штраф за превышение цели.[3](#fn0025) использование этой функции "
"стоимости приводит к почти оптимальному поиску в данном примере.\n"
"Он совершает \"ошибку\" поиска находя 7 перед 6 (потому что 7 ближе к 12), "
"но не тратит время на поиск 14 и 15:"

#: in/chapter6.md:849
msgid ""
"```lisp\n"
"(defun price-is-right (price)\n"
"  \"Return a function that measures the difference from price,\n"
"  but gives a big penalty for going over price.\"\n"
"  #'(lambda (x) (if (> x price)\n"
"              most-positive-fixnum\n"
"              (- price x))))"
msgstr ""

#: in/chapter6.md:857
msgid ""
"> (best-first-search 1 (is 12) #'binary-tree (price-is-right 12)) ;; Search: "
"(1)\n"
";; Search: (3 2)\n"
";; Search: (7 6 2)\n"
";; Search: (6 2 14 15)\n"
";; Search: (12 2 13 14 15)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:871
msgid ""
"All the searching methods we have seen so far consider ever-increasing lists "
"of states as they search.\n"
"For problems where there is only one solution, or a small number of "
"solutions, this is unavoidable.\n"
"To find a needle in a haystack, you need to look at a lot of hay.\n"
"But for problems with many solutions, it may be worthwhile to discard "
"unpromising paths.\n"
"This runs the risk of failing to find a solution at all, but it can save "
"enough space and time to offset the risk.\n"
"A best-first search that keeps only a fixed number of alternative states at "
"any one time is known as a *beam search*.\n"
"Think of searching as shining a light through the dark of the state space.\n"
"In other search strategies the light spreads out as we search deeper, but in "
"beam search the light remains tightly focused.\n"
"Beam search is a variant of best-first search, but it is also similar to "
"depth-first search.\n"
"The difference is that beam search looks down several paths at once, instead "
"of just one, and chooses the best one to look at next.\n"
"But it gives up the ability to backtrack indefinitely.\n"
"The function `beam-search` is just like `best-first-search`, except that "
"after we sort the states, we then take only the first `beam-width` states.\n"
"This is done with `subseq`; `(subseq list start end)` returns the sublist "
"that starts at position *start* and ends just before position *end*."
msgstr ""
"Все методы поиска, которые мы видели до сих пор, рассматривали постоянно "
"увеличивающиеся списки состояний, по мере выполнения поиска.\n"
"Для проблем, где есть только одно решение или небольшое число решений, это "
"неизбежно.\n"
"Чтобы найти иголку в стоге сена, нужно просмотреть кучу сена.\n"
"Но для проблем со многими решениями, возможно, стоит отказаться от "
"бесперспективных путей.\n"
"При этом возникнет риск вообще не найти решение, но это может сэкономить "
"достаточно места и времени, чтобы компенсировать этот риск.\n"
"Поиск наилучшего первого(best-first), который сохраняет только фиксированное "
"число альтернативных состояний в любой момент времени, известен как поиск по "
"лучу(*beam search*).\n"
"Думайте о поиске как о луче света сквозь тьму пространства состояний.\n"
"В других стратегиях поиска свет расширяется по мере того, какёёёёёёёёёёёёё "
"мы ищем глубже, но в поиске по лучу свет остается плотно сфокусированным.\n"
"Поиск по лучу-это вариант поиска первого лучшего(best-first), но он также "
"похож на поиск в глубину.\n"
"Разница заключается в том, что поиск по лучу смотрит на несколько путей "
"сразу, а не только на один, и выбирает лучший из них, чтобы посмотреть на "
"следующий.\n"
"Но он отказывается от возможности бесконечно возвращаться назад.\n"
"Функция `beam-search` точно такая же, как `best-first-search`, за "
"исключением того, что после сортировки состояний мы берем только первые "
"состояния `beam-width`.\n"
"Это делается с помощью `subseq`; `(subseq list start end)` возвращает "
"подсписок, который начинается в позиции *start* и заканчивается "
"непосредственно перед позицией *end*."

#: in/chapter6.md:883
msgid ""
"```lisp\n"
"(defun beam-search (start goal-p successors cost-fn beam-width)\n"
"  \"Search highest scoring states first until goal is reached,\n"
"  but never consider more than beam-width states at a time.\"\n"
"  (tree-search (list start) goal-p successors\n"
"        #'(lambda (old new)\n"
"          (let ((sorted (funcall (sorter cost-fn) old new)))\n"
"            (if (> beam-width (length sorted))\n"
"              sorted\n"
"              (subseq sorted 0 beam-width))))))\n"
"```"
msgstr ""

#: in/chapter6.md:885
msgid ""
"We can successfully search for 12 in the binary tree using a beam width of "
"only 2:"
msgstr ""
"Мы можем успешно искать 12 в двоичном дереве используя ширину луча только 2:"

#: in/chapter6.md:895
msgid ""
"```lisp\n"
"> (beam-search 1 (is 12) #'binary-tree (price-is-right 12) 2)\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6)\n"
";; Search: (6 14)\n"
";; Search: (12 13)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:898
msgid ""
"However, if we go back to the scoring function that just takes the "
"difference from 12, then beam search fails.\n"
"When it generates 14 and 15, it throws away 6, and thus loses its only "
"chance to find the goal:"
msgstr ""
"Однако если мы вернемся к функции scoring(подсчета очков), которая просто "
"принимает разницу от 12, то поиск по лучу завершится неудачей.\n"
"Когда он генерирует 14 и 15, он отбрасывает 6, и таким образом теряет свой "
"единственный шанс найти цель:"

#: in/chapter6.md:914
msgid ""
"```lisp\n"
"> (beam-search 1 (is 12) #'binary-tree (diff 12) 2)\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6)\n"
";; Search: (14 15)\n"
";; Search: (15 28)\n"
";; Search: (28 30)\n"
";; Search: (30 56)\n"
";; Search: (56 60)\n"
";; Search: (60 112)\n"
";; Search: (112 120)\n"
";; Search: (120 224)\n"
"[Abort]\n"
"```"
msgstr ""

#: in/chapter6.md:918
msgid ""
"This search would succeed if we gave a beam width of 3.\n"
"This illustrates a general principle: we can find a goal either by looking "
"at more states, or by being smarter about the states we look at.\n"
"That means having a better ordering function."
msgstr ""
"Этот поиск был бы успешным, если бы мы задали ширину луча равную 3.\n"
"Это иллюстрирует общий принцип: мы можем найти цель, либо просматривая на "
"большее количество состояний, либо будучи информированее в отношении "
"состояний, на которые мы смотрим.\n"
"Это означает, что у вас есть лучшая функция упорядочения."

#: in/chapter6.md:926
msgid ""
"Notice that with a beam width of infinity we get best-first search.\n"
"With a beam width of 1, we get depth-first search with no backup.\n"
"This could be called \"depth-only search,\" but it is more commonly known as "
"*hill-climbing*.\n"
"Think of a mountaineer trying to reach a peak in a heavy fog.\n"
"One strategy would be for the mountaineer to look at adjacent locations, "
"climb to the highest one, and look again.\n"
"This strategy may eventually hit the peak, but it may also get stuck at the "
"top of a foothill, or *local maximum*.\n"
"Another strategy would be for the mountaineer to turn back and try again "
"when the fog lifts, but in AI, unfortunately, the fog rarely lifts.[4]"
"(#fn0030)"
msgstr ""
"Обратите внимание, что при бесконечной ширине луча мы получаем поиск первого "
"лучшего.\n"
"При ширине луча 1 мы получаем поиск в глубину без возвратов.\n"
"Это можно было бы назвать \"глубинным поиском\", но он более широко известен "
"как *восхождение на холм*.\n"
"Представьте себе альпиниста, пытающегося достичь вершины в густом тумане.\n"
"Одна из стратегий заключается в том, чтобы альпинист посмотрел на соседние "
"локации, поднялся на самую высокую и снова посмотрел.\n"
"Эта стратегия может в конечном итоге достичь пика, но она также может "
"застрять на вершине предгорья или *локального максимума*.\n"
"Другая стратегия была бы для альпиниста, чтобы повернуть назад и попробовать "
"снова, когда туман поднимается, но в AI, к сожалению, туман редко "
"поднимается.[4](#fn0030)"

#: in/chapter6.md:929
msgid ""
"As a concrete example of a problem that can be solved by search, consider "
"the task of planning a flight across the North American continent in a small "
"airplane, one whose range is limited to 1000 kilometers.\n"
"Suppose we have a list of selected cities with airports, along with their "
"position in longitude and latitude:"
msgstr ""
"В качестве конкретного примера задачи, которую можно решить с помощью "
"поиска, рассмотрим задачу планирования полета через североамериканский "
"континент на небольшом самолете, дальность полета которого ограничена 1000 "
"километрами.\n"
"Предположим, у нас есть список выбранных городов с аэропортами, а также их "
"положение по долготе и широте:"

#: in/chapter6.md:932
msgid ""
"```lisp\n"
"(defstruct (city (:type list)) name long lat)"
msgstr ""

#: in/chapter6.md:946
msgid ""
"(defparameter *cities*\n"
"   '((Atlanta        84.23 33.45)      (Los Angeles       118.15 "
"34.03)     \n"
"   (Boston           71.05 42.21)      (Memphis           90.03 35.09)     \n"
"   (Chicago          87.37 41.50)      (New York          73.58 40.47)     \n"
"   (Denver           105.00 39.45)     (Oklahoma City     97.28 35.26)     \n"
"   (Eugene           123.05 44.03)     (Pittsburgh        79.57 40.27)     \n"
"   (Flagstaff        111.41 35.13)     (Quebec            71.11 46.49)     \n"
"   (Grand Jet        108.37 39.05)     (Reno              119.49 39.30)    \n"
"   (Houston          105.00 34.00)     (San Francisco     122.26 37.47)    \n"
"   (Indianapolis     86.10 39.46)      (Tampa             82.27 27.57)     \n"
"   (Jacksonville     81.40 30.22)      (Victoria          123.21 48.25)    \n"
"   (Kansas City      94.35 39.06)      (Wilmington        77.57 34.14)))   \n"
"```"
msgstr ""

#: in/chapter6.md:949
msgid ""
"This example introduces a new option to `defstruct`.\n"
"Instead of just giving the name of the structure, it is also possible to use:"
msgstr ""
"В этом примере вводится новая опция для `defstruct`.\n"
"Вместо того чтобы просто дать название структуре, можно также использовать:"

#: in/chapter6.md:953
msgid ""
"```lisp\n"
"(defstruct (structure-name (option value)...) \"optional doc\" slot...)\n"
"```"
msgstr ""

#: in/chapter6.md:956
msgid ""
"For city, the option :type is specified as `list`.\n"
"This means that cities will be implemented as lists of three elements, as "
"they are in the initial value for `*cities*`."
msgstr ""
"Для города опция :type указывается как `list`.\n"
"Это означает, что города будут реализованы в виде списков из трех элементов, "
"так как они находятся в начальном значении для `*cities*`."

#: in/chapter6.md:960
msgid ""
"The cities are shown on the map in [figure  6.1](#f0010), which has "
"connections between all cities within the 1000 kilometer range of each other."
"[5](#fn0035) This map was drawn with the help of `air-distance`, a function "
"that returns the distance in kilometers between two cities \"as the crow "
"flies.\" It will be defined later.\n"
"Two other useful functions are `neighbors`, which finds all the cities "
"within 1000 kilometers, and `city`, which maps from a name to a city.\n"
"The former uses `find-all-if`, which was defined on [page 101]"
"(B9780080571157500030.xhtml#p101) as a synonym for `remove-if-not`."
msgstr ""
"Города показаны на карте в [[figure  6.1](#f0010), которая имеет связи между "
"всеми городами в пределах 1000-километрового диапазона друг от друга. [5]"
"(#fn0035) Эта карта была нарисована с помощью функции `air-distance`, "
"которая возвращает расстояние в километрах между двумя городами \"по мере "
"полета вороны\".- Она будет определена позже.\n"
"Две другие полезные функции - это `neighbors`(соседи), которая находит все "
"города в радиусе 1000 километров, и `city`(город), которая отображает имя "
"города.\n"
"Первая использует `find-all-if`, которая была определена на [стр. 101]"
"(B9780080571157500030.xhtml#p101) как синоним для `remove-if-not`."

#: in/chapter6.md:966
msgid ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-01](images/chapter6/f06-01.jpg) |\n"
"| Figure 6.1: A Map of Some Cities      |"
msgstr ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-01](images/chapter6/f06-01.jpg) |\n"
"| Figure 6.1: Карта некоторых городов   |"

#: in/chapter6.md:974
msgid ""
"```lisp\n"
"(defun neighbors (city)\n"
"  \"Find all cities within 1000 kilometers.\"\n"
"  (find-all-if #'(lambda (c)\n"
"          (and (not (eq c city))\n"
"              (< (air-distance c city) 1000.0)))\n"
"        *cities*))"
msgstr ""

#: in/chapter6.md:979
msgid ""
"(defun city (name)\n"
"  \"Find the city with this name.\"\n"
"  (assoc name *cities*))\n"
"```"
msgstr ""

#: in/chapter6.md:983
msgid ""
"We are now ready to plan a trip.\n"
"The function `trip` takes the name of a starting and destination city and "
"does a beam search of width one, considering all neighbors as successors to "
"a state.\n"
"The cost for a state is the air distance to the destination city:"
msgstr ""
"Теперь мы готовы планировать поездку.\n"
"Функция `trip`(поездка) принимает название города отправления и назначения и "
"выполняет поиск по лучу шириной в единицу, рассматривая всех соседей как "
"преемников состояния.\n"
"Стоимость для состояния - это расстояние по воздуху до города назначения:"

#: in/chapter6.md:991
msgid ""
"```lisp\n"
"(defun trip (start dest)\n"
"  \"Search for a way from the start to dest.\"\n"
"  (beam-search start (is dest) #'neighbors\n"
"          #'(lambda (c) (air-distance c dest))\n"
"          1))\n"
"```"
msgstr ""

#: in/chapter6.md:994
msgid ""
"Here we plan a trip from San Francisco to Boston.\n"
"The result seems to be the best possible path:"
msgstr ""
"Здесь мы планируем поездку из Сан-Франциско в Бостон.\n"
"Результат кажется наилучшим из возможных путей:"

#: in/chapter6.md:1007
msgid ""
"```lisp\n"
"> (trip (city 'san-francisco) (city 'boston))\n"
";; Search: ((SAN-FRANCISCO 122.26 37.47))\n"
";; Search: ((RENO 119.49 39.3))\n"
";; Search: ((GRAND-JCT 108.37 39.05))\n"
";; Search: ((DENVER 105.0 39.45))\n"
";; Search: ((KANSAS-CITY 94.35 39.06))\n"
";; Search: ((INDIANAPOLIS 86.1 39.46))\n"
";; Search: ((PITTSBURGH 79.57 40.27))\n"
";; Search: ((BOSTON 71.05 42.21))\n"
"(BOSTON 71.05 42.21)\n"
"```"
msgstr ""

#: in/chapter6.md:1010
msgid ""
"But look what happens when we plan the return trip.\n"
"There are two detours, to Chicago and Flagstaff:"
msgstr ""
"Но посмотрите, что происходит, когда мы планируем обратный путь.\n"
"Есть два объезда, в Чикаго и Флагстафф:"

#: in/chapter6.md:1023
msgid ""
"```lisp\n"
"> (trip (city 'boston) (city 'san-francisco))\n"
";; Search: ((BOSTON 71.05 42.21))\n"
";; Search: ((PITTSBURGH 79.57 40.27))\n"
";; Search: ((CHICAGO 87.37 41.5))\n"
";; Search: ((KANSAS-CITY 94.35 39.06))\n"
";; Search: ((DENVER 105.0 39.45))\n"
";; Search: ((FLAGSTAFF 111.41 35.13))\n"
";; Search: ((RENO 119.49 39.3))\n"
";; Search: ((SAN-FRANCISCO 122.26 37.47))\n"
"(SAN-FRANCISCO 122.26 37.47)\n"
"```"
msgstr ""

#: in/chapter6.md:1027
msgid ""
"Why did `trip` go from Denver to San Francisco via Flagstaff?\n"
"Because Flagstaff is closer to the destination than Grand Junction.\n"
"The problem is that we are minimizing the distance to the destination at "
"each step, when we should be minimizing the sum of the distance to the "
"destination plus the distance already traveled."
msgstr ""
"Почему `trip` отправился из Денвера в Сан-Франциско через Флагстафф?\n"
"Потому что Флагстафф ближе к месту назначения, чем Grand Junction.\n"
"Проблема в том, что мы минимизируем расстояние до пункта назначения на "
"каждом шаге, тогда как мы должны минимизировать сумму расстояний до пункта "
"назначения плюс уже пройденное расстояние."

#: in/chapter6.md:1029
msgid "### Search Paths"
msgstr "### Поиск Путей"

#: in/chapter6.md:1035
msgid ""
"To minimize the total distance, we need some way to talk about the *path* "
"that leads to the goal.\n"
"But the functions we have defined so far only deal with individual states "
"along the way.\n"
"Representing paths would lead to another advantage: we could return the path "
"as the solution, rather than just return the goal state.\n"
"As it is, `trip` only returns the goal state, not the path to it.\n"
"So there is no way to determine what `trip` has done, except by reading the "
"debugging output."
msgstr ""
"Чтобы свести к минимуму общее расстояние, нам нужно каким-то образом "
"поговорить о пути(*path*), ведущем к цели.\n"
"Но функции, которые мы определили до сих пор, имеют дело только с отдельными "
"состояниями на этом пути.\n"
"Представление путей привело бы к еще одному преимуществу: мы могли бы "
"вернуть путь как решение, а не просто вернуть целевое состояние.\n"
"Как бы то ни было, `trip` возвращает только целевое состояние, а не путь к "
"нему.\n"
"Таким образом, нет никакого способа определить, что сделал `trip`, кроме как "
"прочитав выходные данные отладки."

#: in/chapter6.md:1040
msgid ""
"The data structure path is designed to solve both these problems.\n"
"A path has four fields: the current state, the previous partial path that "
"this path is extending, the cost of the path so far, and an estimate of the "
"total cost to reach the goal.\n"
"Here is the structure definition for path.\n"
"It uses the `:print-function` option to say that all paths are to be printed "
"with the function `print-path`, which will be defined below."
msgstr ""
"Структура данных путь(path) предназначена для решения обеих этих проблем.\n"
"Путь имеет четыре поля: текущее состояние, предыдущая часть пути, которую "
"продолжает этот путь, стоимость пути до сих пор и оценка общей стоимости до "
"достижения цели.\n"
"Вот определение структуры для path.\n"
"Она использует опцию `:print-function`, чтобы сказать, что все пути должны "
"быть напечатаны с помощью функции `print-path`, которая будет определена "
"ниже."

#: in/chapter6.md:1045
msgid ""
"```lisp\n"
"(defstruct (path (:print-function print-path))\n"
"    state (previous nil) (cost-so-far 0) (total-cost 0))\n"
"```"
msgstr ""

#: in/chapter6.md:1050
msgid ""
"The next question is how to integrate paths into the searching routines with "
"the least amount of disruption.\n"
"Clearly, it would be better to make one change to `tree-search` rather than "
"to change `depth-first-search`, `breadth-first-search`, and `beam-search`.\n"
"However, looking back at the definition of `tree-search`, we see that it "
"makes no assumptions about the structure of states, other than the fact that "
"they can be manipulated by the goal predicate, successor, and combiner "
"functions.\n"
"This suggests that we can use `tree-search` unchanged if we pass it paths "
"instead of states, and give it functions that can process paths."
msgstr ""
"Следующий вопрос заключается в том, как интегрировать пути в процедуры "
"поиска с наименьшим количеством переделок.\n"
"Очевидно, что было бы лучше внести одно изменение в `tree-search`(поиск по "
"дереву), а не менять `depth-first-search`, `breadth-first-search` и `beam-"
"search`\n"
"Однако, оглядываясь назад на определение `tree-search`, мы видим, что оно не "
"делает никаких предположений о структуре состояний, кроме того факта, что "
"ими можно манипулировать с помощью функций предиката цели, функции "
"определения приемников и функции объединителя/комбинатора.\n"
"Это предполагает, что мы можем использовать `tree-search` без изменений, "
"если мы передадим ей пути вместо состояний и предоставим ей функции, которые "
"могут обрабатывать пути."

#: in/chapter6.md:1058
msgid ""
"In the following redefinition of `trip`, the `beam-search` function is "
"called with five arguments.\n"
"Instead of passing it a city as the start state, we pass a path that has the "
"city as its state field.\n"
"The goal predicate should test whether its argument is a path whose state is "
"the destination; we assume (and later define) a version of `is` that "
"accommodates this.\n"
"The successor function is the most difficult.\n"
"Instead of just generating a list of neighbors, we want to first generate "
"the neighbors, then make each one into a path that extends the current path, "
"but with an updated cost so far and total estimated cost.\n"
"The function `path-saver` returns a function that will do just that.\n"
"Finally, the cost function we are trying to minimize is `path-total-cost`, "
"and we provide a beam width, which is now an optional argument to `trip` "
"that defaults to one:"
msgstr ""
"В следующем переопределении `trip` функция `beam-search` вызывается с пятью "
"аргументами.\n"
"Вместо того, чтобы передать ей город в качестве начального состояния, мы "
"передаем путь, который имеет город в качестве своего поля состояния.\n"
"Предикат цели должен проверить, является ли его аргумент путем, состояние "
"которого является назначением; мы предполагаем (и позже определяем) версию "
"`is`, которая вмещает её.\n"
"Функция successor(преемник) - самая сложная.\n"
"Вместо того чтобы просто генерировать список соседей, мы хотим сначала "
"сгенерировать соседей, а затем превратить каждый из них в путь, который "
"расширяет текущий путь, но с обновленной стоимостью уплаченной сих пор и "
"общей расчетной стоимостью.\n"
"Функция `path-saver` возвращает функцию, которая будет делать именно это.\n"
"Наконец, функция cost(стоимости), которую мы пытаемся минимизировать, - это "
"`path-total-cost` и мы предоставляем ширину луча, которая теперь является "
"необязательным аргументом для `trip`, и которая по умолчанию равна единице:"

#: in/chapter6.md:1070
msgid ""
"```lisp\n"
"(defun trip (start dest &optional (beam-width 1))\n"
"  \"Search for the best path from the start to dest.\"\n"
"  (beam-search\n"
"    (make-path :state start)\n"
"    (is dest :key #'path-state)\n"
"    (path-saver #'neighbors #'air-distance\n"
"          #'(lambda (c) (air-distance c dest)))\n"
"#'path-total-cost\n"
"beam-width))\n"
"```"
msgstr ""

#: in/chapter6.md:1073
msgid ""
"The calculation of `air-distance` involves some complicated conversion of "
"longitude and latitude to `x-y-z` coordinates.\n"
"Since this is a problem in solid geometry, not AI, the code is presented "
"without further comment:"
msgstr ""
"Расчет `air-distance` включает в себя некоторое сложное преобразование "
"долготы и широты в координаты `x-y-z`.\n"
"Поскольку это проблема геометрии, а не искусственного интеллекта, код "
"представлен без дальнейших комментариев:"

#: in/chapter6.md:1083
msgid ""
"```lisp\n"
"(defconstant earth-diameter 12765.0\n"
"  \"Diameter of planet earth in kilometers.\")\n"
"(defun air-distance (city1 city2)\n"
"  \"The great circle distance between two cities.\"\n"
"  (let ((d (distance (xyz-coords city1) (xyz-coords city2))))\n"
"    ;; d is the straight-line chord between the two cities,\n"
"    ;; The length of the subtending arc is given by:\n"
"    (* earth-diameter (asin (/ d 2)))))"
msgstr ""
"```lisp\n"
"(defconstant earth-diameter 12765.0\n"
"  \"Diameter of planet earth in kilometers.\")\n"
"(defun air-distance (city1 city2)\n"
"  \"The great circle distance between two cities.\"\n"
"  (let ((d (distance (xyz-coords city1) (xyz-coords city2))))\n"
"    ;; d is the straight-line chord between the two cities,\n"
"    ;; The length of the subtending arc is given by:\n"
"    (* earth-diameter (asin (/ d 2)))))"

#: in/chapter6.md:1092
msgid ""
"(defun xyz-coords (city)\n"
"  \"Returns the x,y,z coordinates of a point on a sphere.\n"
"  The center is (0 0 0) and the north pole is (0 0 1).\"\n"
"  (let ((psi (deg->radians (city-lat city)))\n"
"        (phi (deg->radians (city-long city))))\n"
"      (list (* (cos psi) (cos phi))\n"
"            (* (cos psi) (sin phi))\n"
"            (sin psi))))"
msgstr ""

#: in/chapter6.md:1098
msgid ""
"(defun distance (point1 point2)\n"
"  \"The Euclidean distance between two points.\n"
"  The points are coordinates in n-dimensional space.\"\n"
"  (sqrt (reduce #'+ (mapcar #'(lambda (a b) (expt (- a b) 2))\n"
"                point1 point2))))"
msgstr ""

#: in/chapter6.md:1103
msgid ""
"(defun deg->radians (deg)\n"
"  \"Convert degrees and minutes to radians.\"\n"
"  (* (+ (truncate deg) (* (rem  deg 1) 100/60)) pi 1/180))\n"
"```"
msgstr ""

#: in/chapter6.md:1108
msgid ""
"Before showing the auxiliary functions that implement this, here are some "
"examples that show what it can do.\n"
"With a beam width of 1, the detour to Flagstaff is eliminated, but the one "
"to Chicago remains.\n"
"With a beam width of 3, the correct optimal path is found.\n"
"In the following examples, each call to the new version of `trip` returns a "
"path, which is printed by `show-city-path`:"
msgstr ""
"Прежде чем показать вспомогательные функции, которые реализуют это, вот "
"несколько примеров, которые показывают, что она может сделать.\n"
"При ширине луча 1 проезд через Флагстаффа исключается, но остается объезд "
"через Чикаго.\n"
"При ширине луча 3 найден правильный оптимальный путь.\n"
"В следующих примерах каждый вызов новой версии `trip` возвращает путь, "
"который печатается с помощью `show-city-path`:"

#: in/chapter6.md:1120
msgid ""
"```lisp\n"
"> (show-city-path (trip (city 'san-francisco) (city 'boston) 1))\n"
"#<Path 4514.8  km: San-Francisco - Reno - Grand-Jet - Denver -\n"
"  Kansas-City - Indianapolis - Pittsburgh - Boston  >\n"
"> (show-city-path (trip (city 'boston) (city 'san-francisco) 1))\n"
"#<Path 4577.3  km: Boston - Pittsburgh - Chicago - Kansas-City -\n"
"  Denver - Grand-Jet - Reno - San-Francisco  >\n"
"> (show-city-path (trip (city 'boston) (city 'san-francisco) 3))\n"
"#<Path 4514.8  km: Boston - Pittsburgh - Indianapolis -\n"
"  Kansas-City - Denver - Grand-Jet - Reno - San-Francisco  >\n"
"```"
msgstr ""

#: in/chapter6.md:1126
msgid ""
"This example shows how search is susceptible to irregularities in the search "
"space.\n"
"It was easy to find the correct path from west to east, but the return trip "
"required more search, because Flagstaff is a falsely promising step.\n"
"In general, there may be even worse dead ends lurking in the search space.\n"
"Look what happens when we limit the airplane's range to 700 kilometers.\n"
"The map is shown in [figure 6.2](#f0015)."
msgstr ""
"Этот пример показывает, как поиск подвержен нарушениям в пространстве "
"поиска.\n"
"Было легко найти правильный путь с запада на восток, но обратный путь "
"потребовал больше поисков, потому что Флагстафф - это ложный многообещающий "
"шаг.\n"
"В общем, в пространстве поиска могут таиться еще худшие тупики.\n"
"Посмотрите, что происходит, когда мы ограничиваем дальность полета самолета "
"до 700 километров.\n"
"Карта показана на [рис. 6.2](#f0015)."

#: in/chapter6.md:1131
msgid ""
"| []()                                      |\n"
"|-------------------------------------------|\n"
"| ![f06-02](images/chapter6/f06-02.jpg)     |\n"
"| Figure 6.2: A Map of Cities within 700 km |"
msgstr ""
"| []()                                      |\n"
"|-------------------------------------------|\n"
"| ![f06-02](images/chapter6/f06-02.jpg)     |\n"
"| Рис.6.2: Карта городов с достиж. в 700 км |"

#: in/chapter6.md:1138
msgid ""
"If we try to plan a trip from Tampa to Quebec, we can run into problems with "
"the dead end at Wilmington, North Carolina.\n"
"With a beam width of 1, the path to Jacksonville and then Wilmington will be "
"tried first.\n"
"From there, each step of the path alternates between Atlanta and "
"Wilmington.\n"
"The search never gets any closer to the goal.\n"
"But with a beam width of 2, the path from Tampa to Atlanta is not discarded, "
"and it is eventually continued on to Indianapolis and eventually to Quebec.\n"
"So the capability to back up is essential in avoiding dead ends."
msgstr ""
"Если мы попытаемся спланировать поездку из Тампы в Квебек, у нас могут "
"возникнуть проблемы с тупиком в Уилмингтоне, Северная Каролина.\n"
"При ширине луча 1 путь в Джексонвилл(Jacksonville), а затем в "
"Уилмингтон(Wilmington) будет опробован в первую очередь.\n"
"Оттуда каждый шаг пути чередуется между Атлантой(Atlanta) и "
"Уилмингтоном(Wilmington).\n"
"Поиск никогда не приближается к цели.\n"
"Но при ширине Луча 2 путь из Тампы в Атланту не отбрасывается, и в конечном "
"итоге он продолжается до Индианаполиса и, в конечном счете, до Квебека.\n"
"Таким образом, возможность возврата имеет важное значение для избежания "
"тупиков."

#: in/chapter6.md:1141
msgid ""
"Now for the implementation details.\n"
"The function `is` still returns a predicate that tests for a value, but now "
"it accepts `:key` and `:test` keywords:"
msgstr ""
"Теперь перейдем к деталям реализации.\n"
"Функция `is` по-прежнему возвращает предикат, который проверяет значение, но "
"теперь она принимает ключевые слова `:key` и `:test`:"

#: in/chapter6.md:1147
msgid ""
"```lisp\n"
"(defun is (value &key (key #'identity) (test #'eql))\n"
"  \"Returns a predicate that tests for a given value.\"\n"
"  #'(lambda (path) (funcall test value (funcall key path))))\n"
"```"
msgstr ""

#: in/chapter6.md:1151
msgid ""
"The `path-saver` function returns a function that will take a path as an "
"argument and generate successors paths.\n"
"`path-saver` takes as an argument a successor function that operates on bare "
"states.\n"
"It calls this function and, for each state returned, builds up a path that "
"extends the existing path and stores the cost of the path so far as well as "
"the estimated total cost:"
msgstr ""
"Функция `path-saver` возвращает функцию, которая будет принимать путь в "
"качестве аргумента и генерировать пути-преемники.\n"
"`path-saver` принимает в качестве аргумента функцию-генерации преемников, "
"которая работает с голыми состояниями.\n"
"Она вызывает эту функцию и для каждого возвращенного состояния создает путь, "
"который расширяет существующий путь и сохраняет стоимость пути пройденного "
"до сих пор, а также предполагаемую общую стоимость:"

#: in/chapter6.md:1169
msgid ""
"```lisp\n"
"(defun path-saver (successors cost-fn cost-left-fn)\n"
"  #'(lambda (old-path)\n"
"      (let ((old-state (path-state old-path)))\n"
"        (mapcar\n"
"          #'(lambda (new-state)\n"
"            (let ((old-cost\n"
"                  (+ (path-cost-so-far old-path)\n"
"                      (funcall cost-fn old-state new-state))))\n"
"              (make-path\n"
"                :state new-state\n"
"                :previous old-path\n"
"                :cost-so-far old-cost\n"
"                :total-cost (+ old-cost (funcall cost-left-fn\n"
"                        new-state)))))\n"
"          (funcall successors old-state)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1176
msgid ""
"By default a path structure would be printed as `#S ( PATH ... )`.\n"
"But because each path has a `previous` field that is filled by another path, "
"this output would get quite verbose.\n"
"That is why we installed `print-path` as the print function for paths when "
"we defined the structure.\n"
"It uses the notation `#<...>`, which is a Common Lisp convention for "
"printing output that can not be reconstructed by `read`.\n"
"The function `show-city-path` prints a more complete representation of a "
"path.\n"
"We also define `map-path` to iterate over a path, collecting values:"
msgstr ""
"По умолчанию структура path будет напечатана как `#S ( PATH ... )`.\n"
"Но поскольку каждый путь имеет поле `previous`, которое заполняется другим "
"путем, этот вывод будет довольно подробным.\n"
"Вот почему мы установили `print-path` в качестве функции печати для путей, "
"когда определяли структуру.\n"
"Она использует обозначение `#<...>` , что является общим соглашением Lisp "
"для вывода на печать, который не может быть восстановлен с помощью `read`.\n"
"Функция `show-city-path` выводит более полное представление пути.\n"
"Мы также определяем `map-path` для итерации(прхода) по пути, для сбора "
"значений:"

#: in/chapter6.md:1182
msgid ""
"```lisp\n"
"(defun print-path (path &optional (stream t) depth)\n"
"  (declare (ignore depth))\n"
"  (format stream \"#<Path to ~a cost ~,lf>\"\n"
"        (path-state path) (path-total-cost path)))"
msgstr ""

#: in/chapter6.md:1189
msgid ""
"(defun show-city-path (path &optional (stream t))\n"
"  \"Show the length of a path, and the cities along it.\"\n"
"  (format stream \"#<Path ~,lf km: ~{~:(~a~)~^- ~}>\"\n"
"        (path-total-cost path)\n"
"        (reverse (map-path #'city-name path)))\n"
"  (values))"
msgstr ""

#: in/chapter6.md:1197
msgid ""
"(defun map-path (fn path)\n"
"  \"Call fn on each state in the path, collecting results.\"\n"
"  (if (null path)\n"
"      nil\n"
"      (cons (funcall fn (path-state path))\n"
"          (map-path fn (path-previous path)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1199
msgid "### Guessing versus Guaranteeing a Good Solution"
msgstr "### Угадывание против гарантированно хорошего решения"

#: in/chapter6.md:1206
msgid ""
"Elementary AI textbooks place a great emphasis on search algorithms that are "
"guaranteed to find the best solution.\n"
"However, in practice these algorithms are hardly ever used.\n"
"The problem is that guaranteeing the best solution requires looking at a lot "
"of other solutions in order to rule them out.\n"
"For problems with large search spaces, this usually takes too much time.\n"
"The alternative is to use an algorithm that will probably return a solution "
"that is close to the best solution, but gives no guarantee.\n"
"Such algorithms, traditionally known as *non-admissible heuristic search* "
"algorithms, can be much faster."
msgstr ""
"В учебниках по элементарному искусственному интеллекту большое внимание "
"уделяется алгоритмам поиска, которые гарантированно найдут наилучшее "
"решение.\n"
"Однако на практике эти алгоритмы практически не используются.\n"
"Проблема заключается в том, что для того, чтобы гарантировать наилучшее "
"решение, необходимо рассмотреть множество других решений, чтобы исключить "
"их.\n"
"Для проблем с большими пространствами поиска это обычно занимает слишком "
"много времени.\n"
"Альтернативой является использование алгоритма, который, вероятно, вернет "
"решение, близкое к лучшему решению, но не дает никаких гарантий.\n"
"Такие алгоритмы, традиционно известные как алгоритмы *недопустимого "
"эвристического поиска*, могут быть намного быстрее."

#: in/chapter6.md:1216
msgid ""
"Of the algorithms we have seen so far, best-first search almost, but not "
"quite, guarantees the best solution.\n"
"The problem is that it terminates a little too early.\n"
"Suppose it has calculated three paths, of cost 90, 95 and 110.\n"
"It will expand the 90 path next.\n"
"Suppose this leads to a solution of total cost 100.\n"
"Best-first search will then return that solution.\n"
"But it is possible that the 95 path could lead to a solution with a total "
"cost less than 100.\n"
"Perhaps the 95 path is only one unit away from the goal, so it could result "
"in a complete path of length 96.\n"
"This means that an optimal search should examine the 95 path (but not the "
"110 path) before exiting."
msgstr ""
"Из алгоритмов, которые мы видели до сих пор, поиск  best-first(первый "
"лучший) почти, но не совсем, гарантирует лучшее решение.\n"
"Проблема в том, что он заканчивается слишком рано.\n"
"Предположим, что он рассчитал три пути стоимостью 90, 95 и 110 долларов.\n"
"Затем он расширяет путь 90.\n"
"Предположим, что это приводит к решению общей стоимостью 100.\n"
"Поиск первого лучшего затем вернет это решение.\n"
"Но вполне возможно, что путь 95 может привести к решению с общей стоимостью "
"менее 100.\n"
"Возможно, путь 95 находится всего в одной единице от цели, поэтому он может "
"привести к полному пути длиной 96.\n"
"Это означает, что оптимальный поиск должен исследовать путь 95 (но не путь "
"110) перед завершением поиска."

#: in/chapter6.md:1223
msgid ""
"Depth-first search and beam search, on the other hand, are definitely "
"heuristic algorithms.\n"
"Depth-first search finds a solution without any regard to its cost.\n"
"With beam search, picking a good value for the beam width can lead to a "
"good, quick solution, while picking the wrong value can lead to failure, or "
"to a poor solution.\n"
"One way out of this dilemma is to start with a narrow beam width, and if "
"that does not lead to an acceptable solution, widen the beam and try again.\n"
"We will call this *iterative widening*, although that is not a standard "
"term.\n"
"There are many variations on this theme, but here is a simple one:"
msgstr ""
"С другой стороны, поиск в глубину и поиск по лучу - это определенно "
"эвристические алгоритмы.\n"
"Поиск в глубину находит решение без учета его стоимости.\n"
"При поиске по лучу выбор хорошего значения для ширины луча может привести к "
"хорошему, быстрому решению, в то время как выбор неправильного значения "
"может привести к неудаче или к плохому решению.\n"
"Один из выходов из этой дилеммы состоит в том, чтобы начать с узкой ширины "
"луча, и если это не приведет к приемлемому решению, расширить Луч и "
"попробовать снова.\n"
"Мы будем называть это итеративным расширением, хотя это не стандартный "
"термин.\n"
"Есть много вариаций на эту тему, но вот одна простая:"

#: in/chapter6.md:1235
msgid ""
"```lisp\n"
"(defun iter-wide-search (start goal-p successors cost-fn\n"
"                &key (width 1) (max 100))\n"
"  \"Search, increasing beam width from width to max.\n"
"  Return the first solution found at any width.\"\n"
"  (dbg :search \"; Width: ~d\" width)\n"
"  (unless (> width max)\n"
"    (or (beam-search start goal-p successors cost-fn width)\n"
"      (iter-wide-search start goal-p successors cost-fn\n"
"                        :width (+ width 1) :max max))))\n"
"```"
msgstr ""

#: in/chapter6.md:1237
msgid ""
"Here `iter-wide-search` is used to search through a binary tree, failing "
"with beam width 1 and 2, and eventually succeeding with beam width 3:"
msgstr ""
"Здесь `iter-wide-search` использующийся для поиска по двоичному дереву, "
"терпит неудачу с шириной луча 1 и 2, и в конечном итоге преуспевая с шириной "
"луча 3:"

#: in/chapter6.md:1262
msgid ""
"```lisp\n"
"> (iter-wide-search 1 (is 12) (finite-binary-tree 15) (diff 12))\n"
"Width: 1\n"
";; Search: (1)\n"
";; Search: (3)\n"
";; Search: (7)\n"
";; Search: (14)\n"
"; Width: 2\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6)\n"
";; Search: (14 15)\n"
";; Search: (15)\n"
";; Search: NIL\n"
"; Width: 3\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6 2)\n"
";; Search: (14 15 6)\n"
";; Search: (15 6)\n"
";; Search: (6)\n"
";; Search: (12 13)\n"
"12\n"
"```"
msgstr ""

#: in/chapter6.md:1272
msgid ""
"The name iterative widening is derived from the established term *iterative "
"deepening*.\n"
"Iterative deepening is used to control depth-first search when we don't know "
"the depth of the desired solution.\n"
"The idea is first to limit the search to a depth of 1, then 2, and so on.\n"
"That way we are guaranteed to find a solution at the minimum depth, just as "
"in breadth-first search, but without wasting as much storage space.\n"
"Of course, iterative deepening does waste some time because at each "
"increasing depth it repeats all the work it did at the previous depth.\n"
"But suppose that the average state has ten successors.\n"
"That means that increasing the depth by one results in ten times more "
"search, so only 10% of the time is wasted on repeated work.\n"
"So iterative deepening uses only slightly more time and much less space.\n"
"We will see it again in [chapters 11](B978008057115750011X.xhtml) and [18]"
"(B9780080571157500182.xhtml)."
msgstr ""
"Название итеративное расширение происходит от устоявшегося термина "
"`итеративное углубление`.\n"
"Итеративное углубление используется для управления поиском в глубину, когда "
"мы не знаем глубину искомого решения.\n"
"Идея состоит в том, чтобы сначала ограничить поиск глубиной 1, затем 2 и так "
"далее.\n"
"Таким образом, мы гарантированно найдем решение на минимальной глубине, как "
"и при поиске в ширину, но не теряя при этом много места для хранения.\n"
"Конечно, итеративное углубление действительно тратит некоторое время, потому "
"что на каждой увеличивающейся глубине оно повторяет всю работу, проделанную "
"на предыдущей глубине.\n"
"Но предположим, что среднее состояние имеет десять преемников.\n"
"Это означает, что увеличение глубины на единицу приводит к увеличению поиска "
"в десять раз, поэтому только 10% времени тратится на повторную работу.\n"
"Таким образом, итеративное углубление использует лишь немного больше времени "
"и гораздо меньше пространства.\n"
"Мы увидим это снова в [главах 11](B978008057115750011X.xhtml) и [18]"
"(B9780080571157500182.xhtml)."

#: in/chapter6.md:1274
msgid "### Searching Graphs"
msgstr "### Графы Поиска"

#: in/chapter6.md:1280
msgid ""
"So far, `tree-search` has been the workhorse behind all the searching "
"routines.\n"
"This is curious, when we consider that the city problem involves a graph "
"that is not a tree at all.\n"
"The reason `tree-search` works is that any graph can be treated as a tree, "
"if we ignore the fact that certain nodes are identical.\n"
"For example, the graph in [figure 6.3](#f0020) can be rendered as a tree.\n"
"[Figure 6.4](#f0025) shows only the top four levels of the tree; each of the "
"bottom nodes (except the 6s) needs to be expanded further."
msgstr ""
"До сих пор `tree-search` была рабочей лошадкой, стоящей за всеми поисковыми "
"процедурами.\n"
"Это любопытно, если учесть, что проблема путешествия между городами включает "
"в себя граф, который вовсе не является деревом.\n"
"Причина, по которой работает `tree-search`, заключается в том, что любой "
"граф можно рассматривать как дерево, если мы игнорируем тот факт, что "
"некоторые узлы идентичны.\n"
"Например, граф на [рис. 6.3](#f0020) может быть представлен в виде дерева.\n"
"[Рисунок 6.4](#f0025) показывает только верхние четыре уровня дерева; каждый "
"из нижних узлов (за исключением 6s) нуждается в дальнейшем расширении."

#: in/chapter6.md:1285
msgid ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-03](images/chapter6/f06-03.jpg) |\n"
"| Figure 6.3: A Graph with Six Nodes    |"
msgstr ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-03](images/chapter6/f06-03.jpg) |\n"
"| Рис. 6.3: Граф с шестью узлами        |"

#: in/chapter6.md:1290
msgid ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-04](images/chapter6/f06-04.jpg) |\n"
"| Figure 6.4: The Corresponding Tree    |"
msgstr ""
"| []()                                  |\n"
"|---------------------------------------|\n"
"| ![f06-04](images/chapter6/f06-04.jpg) |\n"
"| Рис. 6.4: Соответствующее дерево      |"

#: in/chapter6.md:1297
msgid ""
"In searching for paths through the graph of cities, we were implicitly "
"turning the graph into a tree.\n"
"That is, if `tree-search` found two paths from Pittsburgh to Kansas City "
"(via Chicago or Indianapolis), then it would treat them as two independent "
"paths, just as if there were two distinct Kansas Cities.\n"
"This made the algorithms simpler, but it also doubles the number of paths "
"left to examine.\n"
"If the destination is San Francisco, we will have to search for a path from "
"Kansas City to San Francisco twice instead of once.\n"
"In fact, even though the graph has only 22 cities, the tree is infinite, "
"because we can go back and forth between adjacent cities any number of "
"times.\n"
"So, while it is possible to treat the graph as a tree, there are potential "
"savings in treating it as a true graph."
msgstr ""
"При поиске путей через граф городов мы неявно превращали граф в дерево.\n"
"То есть, если `tree-search` найдет два пути из Питтсбурга в Канзас-Сити "
"(через Чикаго или Индианаполис), то он будет рассматривать их как два "
"независимых пути, точно так же, как если бы было два разных города Канзас.\n"
"Это упростило алгоритмы, но также удвоило количество путей, оставшихся для "
"изучения.\n"
"Если конечная цель-Сан-Франциско, нам придется искать путь из Канзас-Сити в "
"Сан-Франциско дважды, а не один раз.\n"
"На самом деле, хотя граф имеет только 22 города, дерево бесконечно, потому "
"что мы можем перемещаться между соседними городами любое количество раз.\n"
"Таким образом, хотя можно рассматривать граф как дерево, существует "
"потенциальная экономия при рассмотрении его как истинного графа."

#: in/chapter6.md:1301
msgid ""
"The function `graph-search` does just that.\n"
"It is similar to `tree-search`, but accepts two additional arguments: a "
"comparison function that tests if two states are equal, and a list of states "
"that are no longer being considered, but were examined in the past.\n"
"The difference between `graph-search` and `tree-search` is in the call to "
"`new-states`, which generates successors but eliminates states that are in "
"either the list of states currently being considered or the list of old "
"states considered in the past."
msgstr ""
"Функция `graph-search` делает именно это.\n"
"Она похожа на `tree-search`, но принимает два дополнительных аргумента: "
"функцию сравнения, которая проверяет, равны ли два состояния, и список "
"состояний, которые больше не рассматриваются, т.к были рассмотрены ранее.\n"
"Разница между `graph-search` и `tree-search` заключается в вызове `new-"
"states`, которая генерирует преемников, но устраняет состояния, которые "
"находятся либо в списке рассматриваемых в настоящее время состояний, либо в "
"списке старых состояний, рассматривавшихся в прошлом."

#: in/chapter6.md:1317
msgid ""
"```lisp\n"
"(defun graph-search (states goal-p successors combiner &optional (state= "
"#'eql) old-states)\n"
" \"Find a state that satisfies goal-p. Start with states,and search "
"according to successors and combiner.\n"
"  Don't try the same state twice.\"\n"
"  (dbg :search \"~&;; Search: ~a\" states)\n"
"  (cond ((null states) fail)\n"
"        ((funcall goal-p (first states)) (first states))\n"
"        (t (graph-search\n"
"            (funcall\n"
"              combiner\n"
"              (new-states states successors state= old-states)\n"
"              (rest states))\n"
"            goal-p successors combiner state=\n"
"            (adjoin (first states) old-states\n"
"                      :test state=)))))"
msgstr ""

#: in/chapter6.md:1326
msgid ""
"(defun new-states (states successors state= old-states)\n"
"  \"Generate successor states that have not been seen before.\"\n"
"  (remove-if\n"
"    #'(lambda (state)\n"
"      (or (member state states :test state=)\n"
"        (member state old-states :test state=)))\n"
"      (funcall successors (first states))))\n"
"```"
msgstr ""

#: in/chapter6.md:1330
msgid ""
"Using the successor function `next2`, we can search the graph shown here "
"either as a tree or as a graph.\n"
"If we search it as a graph, it takes fewer iterations and less storage space "
"to find the goal.\n"
"Of course, there is additional overhead to test for identical states, but on "
"graphs like this one we get an exponential speed-up for a constant amount of "
"overhead."
msgstr ""
"Используя функцию-преемницу `next2`, мы можем искать на графе, показанном "
"здесь, либо в виде дерева, либо в виде графа.\n"
"Если мы ищем по нему в виде графа, требуется меньше итераций и меньше места "
"для хранения, чтобы найти цель.\n"
"Конечно, существуют дополнительные накладные расходы для проверки "
"идентичности состояний, но на графах, подобных этому, мы получаем "
"экспоненциальное ускорение при постоянном объеме накладных расходов."

#: in/chapter6.md:1333
msgid ""
"```lisp\n"
"(defun next2 (x) (list (+ x 1) (+ x 2)))"
msgstr ""

#: in/chapter6.md:1356
msgid ""
"> (tree-search '(1) (is 6) #'next2 #'prepend)\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (3 3 4)\n"
";; Search: (3 4 4 5)\n"
";; Search:(4 4 5 4 5)\n"
";; Search: (4 5 4 5 5 6)\n"
";; Search: (5 4 5 5 6 5 6)\n"
";; Search: (4 5 5 6 5 6 6 7)\n"
";; Search: (5 5 6 5 6 6 7 5 6)\n"
";; Search: (5 6 5 6 6 7 5 6 6 7)\n"
";; Search: (6 5 6 6 7 5 6 6 7 6 7)\n"
"6\n"
"> (graph-search '(1) (is 6) #'next2 #'prepend)\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (3 4)\n"
";; Search: (4 5)\n"
";; Search: (5 6)\n"
";; Search: (6 7)\n"
"6\n"
"```"
msgstr ""

#: in/chapter6.md:1361
msgid ""
"The next step is to extend the `graph-search` algorithm to handle paths.\n"
"The complication is in deciding which path to keep when two paths reach the "
"same state.\n"
"If we have a cost function, then the answer is easy: keep the path with the "
"cheaper cost.\n"
"Best-first search of a graph removing duplicate states is called A* search."
msgstr ""
"Следующим шагом является расширение алгоритма графового поиска - `graph-"
"search` для обработки путей.\n"
"Сложность заключается в том, чтобы решить, какой путь выбрать, когда два "
"пути достигают одного и того же состояния.\n"
"Если у нас есть функция стоимости, то ответ прост: сохраняем путь с более "
"дешевой стоимостью.\n"
"Поиск лучшего первого(Best-first в графе, удаляющий повторяющиеся состояния, "
"называется A* поиском."

#: in/chapter6.md:1369
msgid ""
"A* search is more complicated than `graph-search` because of the need both "
"to add and to delete paths to the lists of current and old paths.\n"
"For each new successor state, there are three possibilites.\n"
"The new state may be in the list of current paths, in the list of old paths, "
"or in neither.\n"
"Within the first two cases, there are two subcases.\n"
"If the new path is more expensive than the old one, then ignore the new path "
"- it can not lead to a better solution.\n"
"If the new path is cheaper than a corresponding path in the list of current "
"paths, then replace it with the new path.\n"
"If it is cheaper than a corresponding path in the list of the old paths, "
"then remove that old path, and put the new path in the list of current paths."
msgstr ""
"Поиск A* более сложен, чем  `graph-search`, из-за необходимости как "
"добавлять, так и удалять пути в списках текущих и старых путей.\n"
"Для каждого нового состояния-преемника существует три возможности.\n"
"Новое состояние может быть в списке текущих путей, в списке старых путей или "
"ни в одном из них.\n"
"В первых двух случаях имеются две подслучая.\n"
"Если новый путь дороже старого, то игнорируйте новый путь- т.к. он не может "
"привести к лучшему решению.\n"
"Если новый путь дешевле, чем соответствующий путь в списке текущих путей, то "
"замените его новым путем.\n"
"Если он дешевле, чем соответствующий путь в списке старых путей, то удалите "
"старый путь и поместите новый путь в список текущих путей."

#: in/chapter6.md:1372
msgid ""
"Also, rather than sort the paths by total cost on each iteration, they are "
"kept sorted, and new paths are inserted into the proper place one at a time "
"using `insert-path`.\n"
"Two more functions, `better-path` and `find-path`, are used to compare paths "
"and see if a state has already appeared."
msgstr ""
"Кроме того, вместо того, чтобы сортировать пути по общей стоимости на каждой "
"итерации, они сортируются, и новые пути вставляются в нужное место по одному "
"с помощью `insert-path`.\n"
"Еще две функции `better-path` и `find-path` используются, чтобы сравнить "
"пути и посмотреть, появилось ли уже нужное состояние."

#: in/chapter6.md:1414
msgid ""
"```lisp\n"
"(defun a*-search (paths goal-p successors cost-fn cost-left-fn\n"
"                  &optional (state= #'eql) old-paths)\n"
"  \"Find a path whose state satisfies goal-p.  Start with paths,\n"
"  and expand successors, exploring least cost first.\n"
"  When there are duplicate states, keep the one with the\n"
"  lower cost and discard the other.\"\n"
"  (dbg :search \";; Search: ~a\" paths)\n"
"  (cond\n"
"    ((null paths) fail)\n"
"    ((funcall goal-p (path-state (first paths)))\n"
"     (values (first paths) paths))\n"
"    (t (let* ((path (pop paths))\n"
"              (state (path-state path)))\n"
"         ;; Update PATHS and OLD-PATHS to reflect\n"
"         ;; the new successors of STATE:\n"
"         (setf old-paths (insert-path path old-paths))\n"
"         (dolist (state2 (funcall successors state))\n"
"           (let* ((cost (+ (path-cost-so-far path)\n"
"                           (funcall cost-fn state state2)))\n"
"                  (cost2 (funcall cost-left-fn state2))\n"
"                  (path2 (make-path\n"
"                           :state state2 :previous path\n"
"                           :cost-so-far cost\n"
"                           :total-cost (+ cost cost2)))\n"
"                  (old nil))\n"
"             ;; Place the new path, path2, in the right list:\n"
"             (cond\n"
"               ((setf old (find-path state2 paths state=))\n"
"                (when (better-path path2 old)\n"
"                  (setf paths (insert-path\n"
"                                path2 (delete old paths)))))\n"
"               ((setf old (find-path state2 old-paths state=))\n"
"                (when (better-path path2 old)\n"
"                  (setf paths (insert-path path2 paths))\n"
"                  (setf old-paths (delete old old-paths))))\n"
"               (t (setf paths (insert-path path2 paths))))))\n"
"         ;; Finally, call A* again with the updated path lists:\n"
"         (a*-search paths goal-p successors cost-fn cost-left-fn\n"
"                    state= old-paths)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1416
msgid "Here are the three auxiliary functions:"
msgstr "Вот три вспомогательные функции::"

#: in/chapter6.md:1421
msgid ""
"```lisp\n"
"(defun find-path (state paths state=)\n"
"  \"Find the path with this state among a list of paths.\"\n"
"  (find state paths :key #'path-state :test state=))"
msgstr ""

#: in/chapter6.md:1425
msgid ""
"(defun better-path (pathl path2)\n"
"  \"Is path1 cheaper than path2?\"\n"
"  (< (path-total-cost path1) (path-total-cost path2)))"
msgstr ""

#: in/chapter6.md:1430
msgid ""
"(defun insert-path (path paths)\n"
"  \"Put path into the right position, sorted by total cost.\"\n"
"  ;; MERGE is a built-in function\n"
"  (merge 'list (list path) paths #'< :key #'path-total-cost))"
msgstr ""

#: in/chapter6.md:1438
msgid ""
"(defun path-states (path)\n"
"  \"Collect the states along this path.\"\n"
"  (if (null path)\n"
"      nil\n"
"      (cons (path-state path)\n"
"            (path-states (path-previous path)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1445
msgid ""
"Below we use `a*-search` to search for 6 in the graph previously shown in "
"[figure 6.3](#f0020).\n"
"The cost function is a constant 1 for each step.\n"
"In other words, the total cost is the length of the path.\n"
"The heuristic evaluation function is just the difference from the goal.\n"
"The A* algorithm needs just three search steps to come up with the optimal "
"solution.\n"
"Contrast that to the graph search algorithm, which needed five steps, and "
"the tree search algorithm, which needed ten steps-and neither of them found "
"the optimal solution."
msgstr ""
"Ниже мы используем `a*-search` для поиска 6 на графе, ранее показанном на "
"[рис. 6.3](#f0020).\n"
"Функция стоимости-это константа 1 для каждого шага.\n"
"Другими словами, общая стоимость-это длина пути.\n"
"Эвристическая функция оценки - это всего лишь отличие от цели.\n"
"A*  алгоритму  требуется всего три шага поиска, чтобы найти оптимальное "
"решение.\n"
"Сравните это с алгоритмом поиска по графу, который требовал пяти шагов, и "
"алгоритмом поиска по дереву, который требовал десяти шагов - и ни один из "
"них не нашел оптимального решения."

#: in/chapter6.md:1458
msgid ""
"```lisp\n"
"> (path-states\n"
"      (a*-search (list (make-path :state 1)) (is 6)\n"
"                    #'next2 #'(lambda (x y) 1) (diff 6)))\n"
";; Search: (#<Path to 1 cost 0.0  >)\n"
";; Search: (#<Path to 3 cost 4.0  > #<Path to 2 cost 5.0  >)\n"
";; Search: (#<Path to 5 cost 3.0  > #<Path to 4 cost 4.0  >\n"
"                #<Path to 2 cost 5.0  >)\n"
";; Search: (#<Path to 6 cost 3.0  > #<Path to 7 cost 4.0  >\n"
"                #<Path to 4 cost 4.0  > #<Path to 2 cost 5.0  >)\n"
"(6 5 3 1)\n"
"```"
msgstr ""

#: in/chapter6.md:1462
msgid ""
"It may seem limiting that these search functions all return a single "
"answer.\n"
"In some applications, we may want to look at several solutions, or at all "
"possible solutions.\n"
"Other applications are more naturally seen as optimization problems, where "
"we don't know ahead of time what counts as achieving the goal but are just "
"trying to find some action with a low cost."
msgstr ""
"Может показаться ограничивающим, что все эти функции поиска возвращают один "
"ответ.\n"
"В некоторых приложениях мы можем рассматирвать несколько решений или все "
"возможные решения.\n"
"Другие приложения более естественно рассматривать как задачи оптимизации, "
"где мы не знаем заранее, что считается достижением цели, но просто пытаемся "
"найти какое-то действие приводящее к уменьшению стоимости решения."

#: in/chapter6.md:1470
msgid ""
"It turns out that the functions we have defined are not limiting at all in "
"this respect.\n"
"They can be used to serve both these new purposes-provided we carefully "
"specify the goal predicate.\n"
"To find all solutions to a problem, all we have to do is pass in a goal "
"predicate that always fails, but saves all the solutions in a list.\n"
"The goal predicate will see all possible solutions and save away just the "
"ones that are real solutions.\n"
"Of course, if the search space is infinite this will never terminate, so the "
"user has to be careful in applying this technique.\n"
"It would also be possible to write a goal predicate that stopped the search "
"after finding a certain number of solutions, or after looking at a certain "
"number of states.\n"
"Here is a function that finds all solutions, using beam search:"
msgstr ""
"Оказывается, что функции, которые мы определили, совсем не ограничивают нас "
"в этом отношении.\n"
"Они могут быть использованы для достижения обеих этих новых целей-при "
"условии, что мы тщательно определим предикат цели.\n"
"Чтобы найти все решения проблемы, всё, что нам нужно сделать, это определить "
"и передать такой предикат цели, который всегда терпит неудачу, но сохраняет "
"все решения в списке.\n"
"Предикат цели будет видеть все возможные решения и сохранять только те, "
"которые являются реальными решениями.\n"
"Конечно, если пространство поиска бесконечно, это никогда не закончится, "
"поэтому пользователь должен быть осторожен в применении этой техники.\n"
"Также можно было бы написать предикат цели, который остановил бы поиск после "
"нахождения определенного числа решений или после просмотра определенного "
"числа состояний.\n"
"Вот функция, которая находит все решения, используя поиск по лучу:"

#: in/chapter6.md:1483
msgid ""
"```lisp\n"
"(defun search-all (start goal-p successors cost-fn beam-width)\n"
"  \"Find all solutions to a search problem, using beam search.\"\n"
"  ;; Be careful: this can lead to an infinite loop.\n"
"  (let ((solutions nil))\n"
"    (beam-search\n"
"      start #'(lambda (x)\n"
"              (when (funcall goal-p x) (push x solutions))\n"
"              nil)\n"
"      successors cost-fn beam-width)\n"
"  solutions))\n"
"```"
msgstr ""

#: in/chapter6.md:1485
msgid "## 6.5 GPS as Search"
msgstr "## 6.5 GPS как поиск"

#: in/chapter6.md:1490
msgid ""
"The GPS program can be seen as a problem in search.\n"
"For example, in the three-block blocks world, there are only 13 different "
"states.\n"
"They could be arranged in a graph and searched just as we searched for a "
"route between cities.\n"
"[Figure 6.5](#f0030) shows this graph."
msgstr ""
"Программа GPS может рассматриваться как проблема поиска.\n"
"Например, в мире трех блоков блоков есть только 13 различных состояний.\n"
"Их можно было расположить в виде графа и искать точно так же, как мы искали "
"маршрут между городами.\n"
"[Рисунок 6.5](#f0030) показывает этот граф."

#: in/chapter6.md:1495
msgid ""
"| []()                                    |\n"
"|-----------------------------------------|\n"
"| ![f06-05](images/chapter6/f06-05.jpg)   |\n"
"| Figure 6.5: The Blocks World as a Graph |"
msgstr ""
"| []()                                    |\n"
"|-----------------------------------------|\n"
"| ![f06-05](images/chapter6/f06-05.jpg)   |\n"
"| Рисунок 6.5: мир блоков в виде графа    |"

#: in/chapter6.md:1500
msgid ""
"The function `search-gps` does just that.\n"
"Like the gps function on [page 135](B9780080571157500042.xhtml#p135), it "
"computes a final state and then picks out the actions that lead to that "
"state.\n"
"But it computes the state with a beam search.\n"
"The goal predicate tests if the current state satisfies every condition in "
"the goal, the successor function finds all applicable operators and applies "
"them, and the cost function simply sums the number of actions taken so far, "
"plus the number of conditions that are not yet satisfied:"
msgstr ""
"Функция `search-gps` делает именно это.\n"
"Например, функция gps на [стр. 135](B9780080571157500042.xhtml#p135), она "
"вычисляет конечное состояние, а затем выбирает действия, которые приводят к "
"этому состоянию.\n"
"Но она вычисляет состояние с помощью поиска по лучу.\n"
"Предикат цели проверяет, удовлетворяет ли текущее состояние каждому условию "
"в цели, функция - successor находит все применимые операторы и применяет их, "
"а функция стоимости просто суммирует количество действий, выполненных до сих "
"пор, плюс количество условий, которые еще не выполнены:"

#: in/chapter6.md:1517
msgid ""
"```lisp\n"
"(defun search-gps (start goal &optional (beam-width 10))\n"
"  \"Search for a sequence of operators leading to goal.\"\n"
"  (find-all-if\n"
"    #'action-p\n"
"    (beam-search\n"
"      (cons '(start) start)\n"
"      #'(lambda (state) (subsetp goal state :test #'equal))\n"
"      #'gps-successors\n"
"      #'(lambda (state)\n"
"          (+ (count-if #'action-p state)\n"
"             (count-if #'(lambda (con)\n"
"                           (not (member-equal con state)))\n"
"                       goal)))\n"
"      beam-width)))\n"
"```"
msgstr ""

#: in/chapter6.md:1519
msgid "Here is the successor function:"
msgstr "Вот функция определения преемников(successor):"

#: in/chapter6.md:1531
msgid ""
"```lisp\n"
"(defun gps-successors (state)\n"
"  \"Return a list of states reachable from this one using ops.\"\n"
"  (mapcar\n"
"    #'(lambda (op)\n"
"        (append\n"
"          (remove-if #'(lambda (x)\n"
"                         (member-equal x (op-del-list op)))\n"
"                     state)\n"
"          (op-add-list op)))\n"
"    (applicable-ops state)))"
msgstr ""

#: in/chapter6.md:1539
msgid ""
"(defun applicable-ops (state)\n"
"  \"Return a list of all ops that are applicable now.\"\n"
"  (find-all-if\n"
"    #'(lambda (op)\n"
"        (subsetp (op-preconds op) state :test #'equal))\n"
"    *ops*))\n"
"```"
msgstr ""

#: in/chapter6.md:1542
msgid ""
"The search technique finds good solutions quickly for a variety of "
"problems.\n"
"Here we see the solution to the Sussman anomaly in the three-block blocks "
"world:"
msgstr ""
"Техника поиска быстро находит хорошие решения для самых разных задач.\n"
"Здесь мы видим решение аномалии Сассмана в мире трех блоков блоков:"

#: in/chapter6.md:1557
msgid ""
"```lisp\n"
"(setf start '((c on a) (a on table) (b on table) (space on c)\n"
"            (space on b) (space on table)))\n"
"> (search-gps start '((a on b) (b on c)))\n"
"((START)\n"
"  (EXECUTING (MOVE C FROM A TO TABLE))\n"
"  (EXECUTING (MOVE B FROM TABLE TO C))\n"
"  (EXECUTING (MOVE A FROM TABLE TO B)))\n"
"> (search-gps start '((b on c) (a on b)))\n"
"((START)\n"
"  (EXECUTING (MOVE C FROM A TO TABLE))\n"
"  (EXECUTING (MOVE B FROM TABLE TO C))\n"
"  (EXECUTING (MOVE A FROM TABLE TO B)))\n"
"```"
msgstr ""

#: in/chapter6.md:1561
msgid ""
"In these solutions we search forward from the start to the goal; this is "
"quite different from the means-ends approach of searching backward from the "
"goal for an appropriate operator.\n"
"But we could formulate means-ends analysis as forward search simply by "
"reversing start and goal: GPS's goal state is the search's start state, and "
"the search's goal predicate tests to see if a state matches GPS's start "
"state.\n"
"This is left as an exercise."
msgstr ""
"В этих решениях мы ищем вперед от начала к цели; это совершенно отличается "
"от подхода средство-анализа коненой цели (means-ends), при котором мы ищем "
"назад от цели, для достижения которой ищем применимые операторы.\n"
"Но мы могли бы сформулировать анализ конечных целей аналитически, как поиск "
"вперед, просто переставив старт и цель: состояние цели GPS - это начальное "
"состояние поиска, а предикат цели поиска проверяет, совпадает ли состояние с "
"начальным состоянием GPS.\n"
"Оставим это вам как упражнение."

#: in/chapter6.md:1563
msgid "## 6.6 History and References"
msgstr "## 6.6 истории и литература"

#: in/chapter6.md:1568
msgid ""
"Pattern matching is one of the most important tools for AI.\n"
"As such, it is covered in most textbooks on Lisp.\n"
"Good treatments include Abelson and Sussman (1984), [Wilensky (1986)]"
"(B9780080571157500285.xhtml#bb1390), [Winston and Horn (1988)]"
"(B9780080571157500285.xhtml#bb1410), and [Kreutzer and McKenzie (1990)]"
"(B9780080571157500285.xhtml#bb0680).\n"
"An overview is presented in the \"pattern-matching\" entry in *Encyclopedia "
"of AI* ([Shapiro 1990](B9780080571157500285.xhtml#bb1085))."
msgstr ""

#: in/chapter6.md:1573
msgid ""
"Nilsson's *Problem*-*Solving Methods in Artificial Intelligence* (1971) was "
"an early text-book that emphasized search as the most important defining "
"characteristic of AI.\n"
"More recent texts give less importance to search; Winston's *Artificial "
"Intelligence* (1984) gives a balanced overview, and his *Lisp* (1988) "
"provides implementations of some of the algorithms.\n"
"They are at a lower level of abstraction than the ones in this chapter.\n"
"Iterative deepening was first presented by [Korf (1985)]"
"(B9780080571157500285.xhtml#bb0640), and iterative broadening by [Ginsberg "
"and Harvey (1990)](B9780080571157500285.xhtml#bb0470)."
msgstr ""

#: in/chapter6.md:1575
msgid "## 6.7 Exercises"
msgstr "## 6.7 Упражнения"

#: in/chapter6.md:1578
msgid ""
"**Exercise  6**.**3** [**m**] Write a version of `interaetive-interpreter` "
"that is more general than the one defined in this chapter.\n"
"Decide what features can be specified, and provide defaults for them."
msgstr ""
"**Exercise  6**.**3** [**m**] Напишите более общую версию `interaetive-"
"interpreter`, чем та, которая определена в этой главе.\n"
"Решите, какую функциональность можно определить, и укажите для них значения "
"по умолчанию."

#: in/chapter6.md:1581
msgid ""
"**Exercise  6**.**4** [**m**] Define a version of `compose` that allows any "
"number of arguments, not just two.\n"
"Hint: You may want to use the function `reduce`."
msgstr ""
"**Exercise  6**.**4** [**m**] Определите версию `compose`, которая допускает "
"любое количество аргументов, а не только два.\n"
"Подсказка: вы можете использовать функцию `reduce`."

#: in/chapter6.md:1584
msgid ""
"**Exercise  6**.**5** [**m**] Define a version of `compose` that allows any "
"number of arguments but is more efficient than the answer to the previous "
"exercise.\n"
"Hint: try to make decisions when `compose` is called to build the resulting "
"function, rather than making the same decisions over and over each time the "
"resulting function is called."
msgstr ""
"**Exercise  6**.**5** [**m**] Определите версию `compose`, которая допускает "
"любое количество аргументов, но более эффективна, чем ответ на предыдущее "
"упражнение.\n"
"Подсказка: попробуйте принимать решения, когда вызывается `compose` для "
"построения результирующей функции, а не принимать одни и те же решения снова "
"и снова каждый раз, когда вызывается результирующая функция."

#: in/chapter6.md:1587
msgid ""
"**Exercise  6**.**6** [**m**] One problem with `pat-match` is that it gives "
"special significance to symbols starting with ?, which means that they can "
"not be used to match a literal pattern.\n"
"Define a pattern that matches the input literally, so that such symbols can "
"be matched."
msgstr ""
"**Exercise  6**.**6** [**m**] Одна из проблем с `pat-match` состоит в том, "
"что он придает особое значение символам, начинающимся с ?, Что означает, что "
"они не могут использоваться для сопоставления с литеральным образцом.\n"
"Определите образец, который буквально соответствует литеральному вводу, "
"чтобы такие символы можно было сопоставить."

#: in/chapter6.md:1589
msgid ""
"**Exercise  6**.**7** [**m**] Discuss the pros and cons of data-driven "
"programming compared to the conventional approach."
msgstr ""
"**Exercise  6**.**7** [**m**] Обсудите плюсы и минусы программирования, "
"управляемого данными, по сравнению с традиционным подходом.\n"

#: in/chapter6.md:1591
msgid ""
"**Exercise  6**.**8** [**m**] Write a version of `tree-search` using an "
"explicit loop rather than recursion."
msgstr ""
"**Exercise  6**.**8** [**m**] Напишите версию `tree-search` используя явный "
"цикл, а не рекурсию."

#: in/chapter6.md:1594
msgid ""
"**Exercise  6**.**9** [**m**] The `sorter` function is inefficient for two "
"reasons: it calls `append`, which has to make a copy of the first argument, "
"and it sorts the entire result, rather than just inserting the new states "
"into the already sorted *old* states.\n"
"Write a more efficient `sorter`."
msgstr ""
"**Exercise  6**.**9** [**m**] Функция `sorter` неэффективна по двум "
"причинам: она вызывает `append`, который должен сделать копию первого "
"аргумента, и сортирует весь результат, а не просто вставляет новые состояния "
"в уже отсортированные *старые* состояния.\n"
"Напишите более эффективный `sorter`."

#: in/chapter6.md:1596
msgid ""
"**Exercise  6**.**10** [**m**] Write versions of `graph-search` and `a*-"
"search` that use hash tables rather than lists to test whether a state has "
"been seen before."
msgstr ""
"**Exercise  6**.**10** [**m**] Напишите версии `graph-search` и `a*-search`, "
"которые используют хэш-таблицы, а не списки, чтобы проверить, было ли "
"состояние замечено ранее."

#: in/chapter6.md:1598
msgid ""
"**Exercise  6**.**11** [**m**] Write a function that calls `beam-search` to "
"find the first *n* solutions to a problem and returns them in a list."
msgstr ""
"**Exercise  6**.**11** [**m**] Напишите функцию, которая вызывает `beam-"
"search` для поиска первых *n* решений проблемы и возвращает их в виде списка."

#: in/chapter6.md:1602
msgid ""
"**Exercise  6**.**12** [**m**] On personal computers without floating-point "
"hardware, the `air-distance` calculation will be rather slow.\n"
"If this is a problem for you, arrange to compute the `xyz-coords` of each "
"city only once and then store them, or store a complete table of air "
"distances between cities.\n"
"Also precompute and store the neighbors of each city."
msgstr ""
"**Exercise  6**.**12** [**m**] На персональных компьютерах без оборудования "
"с плавающей запятой расчет `air-distance` будет довольно медленным.\n"
"Если для вас это проблема, договоритесь вычислять `xyz-coords` каждого "
"города только один раз, а затем сохраните их, или сохраните полную таблицу "
"расстояний между городами.\n"
"Также предварительно вычислите и сохраните соседей каждого города."

#: in/chapter6.md:1605
msgid ""
"**Exercise  6**.**13** [**d**] Write a version of GPS that uses A* search "
"instead of beam search.\n"
"Compare the two versions in a variety of domains."
msgstr ""
"**Exercise  6**.**13** [**d**] Напишите версию GPS, которая использует поиск "
"A* вместо поиска по лучу.\n"
"Сравните две версии в различных областях."

#: in/chapter6.md:1609
msgid ""
"**Exercise  6**.**14** [**d**] Write a version of GPS that allows costs for "
"each operator.\n"
"For example, driving the child to school might have a cost of 2, but calling "
"a limousine to transport the child might have a cost of 100.\n"
"Use these costs instead of a constant cost of 1 for each operation."
msgstr ""
"**Exercise  6**.**14** [**d**] Напишите версию GPS, которая учитывает "
"стоимость для каждого оператора.\n"
"Например, доставка ребенка в школу может стоить 2, а вызов лимузина для "
"перевозки ребенка может стоить 100.\n"
"Используйте эти стоимости вместо постоянной стоимости 1 для каждой операции."

#: in/chapter6.md:1611
msgid ""
"**Exercise  6**.**15** [**d**] Write a version of GPS that uses the "
"searching tools but does means-ends analysis."
msgstr ""
"**Exercise  6**.**15** [**d**] Напишите версию GPS, которая использует "
"инструменты поиска, но выполняет анализ средств и результатов."

#: in/chapter6.md:1613
msgid "## 6.8 Answers"
msgstr "## 6.8 Ответы"

#: in/chapter6.md:1618
msgid ""
"**Answer 6**.**2** Unfortunately, `pat-match` does not always find the "
"answer.\n"
"The problem is that it will only rebind a segment variable based on a "
"failure to match the rest of the pattern after the segment variable.\n"
"In all the examples above, the \"rest of the pattern after the segment "
"variable\" was the whole pattern, so `pat-match` always worked properly.\n"
"But if a segment variable appears nested inside a list, then the rest of the "
"segment variable's sublist is only a part of the rest of the whole pattern, "
"as the following example shows:"
msgstr ""
"**Answer 6**.**2** К сожалению, `pat-match` не всегда дает ответ.\n"
"Проблема в том, что он будет повторно связывать сегментную переменную только "
"в случае несоответствия остальной части шаблона после переменной сегмента.\n"
"Во всех приведенных выше примерах \"остальная часть шаблона после переменной "
"сегмента\" была всем шаблоном, поэтому `pat-match` всегда работал "
"правильно.\n"
"Но если переменная сегмента оказывается вложенной в список, то оставшаяся "
"часть подсписка переменной сегмента является только частью остальной части "
"всего образца, как показано в следующем примере:"

#: in/chapter6.md:1622
msgid ""
"```lisp\n"
"> (pat-match '(((?* ?x) (?* ?y)) ?x ?y) '((a b c d ) (a b) (c d))) => NIL\n"
"```"
msgstr ""

#: in/chapter6.md:1624
msgid ""
"The correct answer with `?x` bound to `(a b)` and `?y` bound to `(c d)` is "
"not found because the inner segment match succeeds with `?x` bound to `( )` "
"and `?y` bound to `(a b c d)`, and once we leave the inner match and return "
"to the top level, there is no going back for alternative bindings."
msgstr ""
"Правильный ответ с `?x` связывается с `(a b)` и `?y` связывается с `(c d)`, "
"не найден, потому что соответствие внутреннему сегменту выполнено успешно с "
"`?x`, привязанным к `( )` и `?y` привязан к `(a b c d)`, и как только мы "
"выйдем из внутреннего соответствия и вернемся на верхний уровень, для "
"альтернативных привязок не будет возврата."

#: in/chapter6.md:1627
msgid ""
"**Answer 6**.**3** The following version lets the user specify all four "
"components of the prompt-read-eval-print loop, as well as the streams to use "
"for input and output.\n"
"Defaults are set up as for a Lisp interpreter."
msgstr ""
"**Answer 6**.**3** Следующая версия позволяет пользователю указать все "
"четыре компонента цикла prompt-read-eval-print(REPL), а также потоки, "
"которые будут использоваться для ввода и вывода.\n"
"Значения по умолчанию устанавливаются как для интерпретатора Лиспа."

#: in/chapter6.md:1639
msgid ""
"```lisp\n"
"(defun interactive-interpreter\n"
"        (&key (read #'read) (eval #'eval) (print #'print)\n"
"          (prompt \"> \") (input t) (output t))\n"
"  \"Read an expression, evaluate it, and print the result.\"\n"
"  (loop\n"
"    (fresh-line output)\n"
"    (princ prompt output)\n"
"      (funcall print (funcall eval (funcall read input))\n"
"              output)))\n"
"```"
msgstr ""

#: in/chapter6.md:1641
msgid ""
"Here is another version that does all of the above and also handles multiple "
"values and binds the various \"history variables\" that the Lisp top-level "
"binds."
msgstr ""
"Вот еще одна версия, которая выполняет все вышеперечисленное, а также "
"обрабатывает несколько значений и связывает различные \"исторические "
"переменные\", которые связывает верхний уровень Lisp."

#: in/chapter6.md:1668
msgid ""
"```lisp\n"
"(defun interactive-interpreter\n"
"      (&key (read #'read) (eval #'eval) (print #'print)\n"
"      (prompt \"> \") (input t) (output t))\n"
"  \"Read an expression, evaluate it, and print the result(s).\n"
"  Does multiple values and binds: * ** ***-+ ++ +++/ // ///\"\n"
"  (let (* ** *** - + ++ +++ / // /// vals)\n"
"    ;; The above variables are all special, except VALS\n"
"    ;; The variable - holds the current input\n"
"    ;; * *** *** are the 3 most recent values\n"
"    ;; + ++ +++ are the 3 most recent inputs\n"
"    ;;/ // /// are the 3 most recent lists of multiple-values\n"
"    (loop\n"
"      (fresh-line output)\n"
"      (princ prompt output)\n"
"      ;; First read and evaluate an expression\n"
"      (setf - (funcall read input)\n"
"          vals (multiple-value-list (funcall eval -)))\n"
"      ;; Now update the history variables\n"
"   (setf +++ ++     /// //     *** (first ///)   \n"
"         ++ +       // /       ** (first //)     \n"
"         + -        / vals     * (first /)) \n"
"      ;; Finally print the computed value(s)\n"
"      (dolist (value vals)\n"
"        (funcall print value output)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1670
msgid "**Answer 6**.**4**"
msgstr ""

#: in/chapter6.md:1678
msgid ""
"```lisp\n"
"(defun compose (&rest functions)\n"
"  \"Return the function that is the composition of all the args. i.e.\n"
"(compose f g h) = (lambda (x) (f (g (h x)))).\" \n"
"#'(lambda (x)\n"
"      (reduce #'funcall functions :from-end t :initial-value x)))\n"
"```"
msgstr ""

#: in/chapter6.md:1680
msgid "**Answer 6**.**5**"
msgstr ""

#: in/chapter6.md:1695
msgid ""
"```lisp\n"
"(defun compose (&rest functions)\n"
"  \"Return the function that is the composition of all the args. i.e.\n"
"(compose f g h) = (lambda (x) (f (g (h x)))).\"\n"
"  (case (length functions)\n"
"    (0 #'identity)\n"
"    (1 (first functions))\n"
"    (2 (let ((f (first functions))\n"
"            (g (second functions)))\n"
"        #'(lambda (x) (funcall f (funcall g x)))))\n"
"    (t #'(lambda (x)\n"
"          (reduce #'funcall functions :from-end t\n"
"                  :initia1-value x)))))\n"
"```"
msgstr ""

#: in/chapter6.md:1697
msgid "**Answer 6**.**8**"
msgstr ""

#: in/chapter6.md:1711
msgid ""
"```lisp\n"
"(defun tree-search (states goal-p successors combiner)\n"
"\"Find a state that satisfies goal-p.\n"
"Start with states, and search according to successors and combiner.\"\n"
"  (loop\n"
"    (cond ((null states) (RETURN fail))\n"
"          ((funcall goal-p (first states))\n"
"          (RETURN (first states))\n"
"          (t (setf states\n"
"                  (funcall combiner\n"
"                          (funcall successors (first states))\n"
"                          (rest states))))))))\n"
"```"
msgstr ""

#: in/chapter6.md:1713
msgid "**Answer 6**.**9**"
msgstr ""

#: in/chapter6.md:1721
msgid ""
"```lisp\n"
"(defun sorter (cost-fn)\n"
"  \"Return a combiner function that sorts according to cost-fn.\"\n"
"  #'(lambda (new old)\n"
"      (merge 'list (sort new #'> :key cost-fn)\n"
"          old #'> :key cost-fn)))\n"
"```"
msgstr ""

#: in/chapter6.md:1723
msgid "**Answer 6**.**11**"
msgstr ""

#: in/chapter6.md:1738
msgid ""
"```lisp\n"
"(defun search-n (start n goal-p successors cost-fn beam-width)\n"
"  \"Find n solutions to a search problem, using beam search.\"\n"
"  (let ((solutions nil))\n"
"    (beam-search\n"
"      start #'(lambda (x)\n"
"          (cond ((not (funcall goal-p x)) nil)\n"
"              ((= n 0) x)\n"
"              (t (decf n)\n"
"                  (push x solutions)\n"
"                  nil)))\n"
"      successors cost-fn beam-width)\n"
"    solutions))\n"
"```"
msgstr ""

#: in/chapter6.md:1740
msgid "----------------------"
msgstr ""

#: in/chapter6.md:1742
msgid "[1](#xfn0015) The macro `handler-case` is only in ANSI Common Lisp."
msgstr "[1](#xfn0015) Макрос `handler-case` есть только в  ANSI Common Lisp."

#: in/chapter6.md:1746
msgid ""
"[2](#xfn0020) An alternative would be to reserve the question mark for "
"variables only and use another notation for these match operators.\n"
"Keywords would be a good choice, such as `:and`, `:or`, `:is`, etc."
msgstr ""
"[2](#xfn0020) В качестве альтернативы можно было бы зарезервировать "
"вопросительный знак только для переменных и использовать другие обозначения "
"для этих операторов сопоставления.\n"
"Подойдут ключевые слова, такие как `:and`, `:or`, `:is` и т. д."

#: in/chapter6.md:1749
msgid ""
"[3](#xfn0025) The built-in constant `most-positive-fixnum` is a large "
"integer, the largest that can be expressed without using bignums.\n"
"Its value depends on the implementation, but in most Lisps it is over 16 "
"million."
msgstr ""
"[3](#xfn0025) Встроенная константа `most-positive-fixnum` - это большое "
"целое число, самое большое, которое может быть выражено без использования "
"больших чисел.\n"
"Его значение зависит от реализации, но в большинстве Лиспов оно превышает 16 "
"миллионов."

#: in/chapter6.md:1751
msgid ""
"[4](#xfn0030) In [chapter 8](B978008057115750008X.xhtml) we will see an "
"example where the fog did lift: symbolic integration was once handled as a "
"problem in search, but new mathematical results now make it possible to "
"solve the same class of integration problems without search."
msgstr ""
"[4](#xfn0030) В [Главе 8](B978008057115750008X.xhtml) мы увидим пример, "
"когда туман рассеялся: когда-то символическое интегрирование рассматривалось "
"как проблема поиска, но теперь новые математические результаты позволяют "
"решать тот же класс задач интеграции без поиска."

#: in/chapter6.md:1754
msgid ""
"[5](#xfn0035) The astute reader will recognize that this graph is not a "
"tree.\n"
"The difference between trees and graphs and the implications for searching "
"will be covered later."
msgstr ""
"[5](#xfn0035) Проницательный читатель поймет, что этот граф - не дерево.\n"
"Разница между деревьями и графами и последствия для поиска будут рассмотрены "
"позже."
