# Глава 10
## Проблемы эффективности на низком уровне 

> В мире всего два качества: эффективность и неэффективность; и только два типа людей: эффективные и неэффективные

> -George Bernard Shaw

> John Bull's Other Island (1904)

Все методы повышения эффективности из предыдущей главы включали в себя довольно значительные изменения в алгоритме.
Но что происходит, когда вы уже используете лучшие алгоритмы, которые только можно представить, а производительность по-прежнему остается проблемой?
Один из ответов - найти, какие части программы используются наиболее часто, и провести микрооптимизацию этих частей.
В этой главе рассматриваются следующие шесть методов оптимизации.
Если все ваши программы работают достаточно быстро, можете пропустить эту главу.
Но если вы хотите, чтобы ваши программы работали быстрее, описанные здесь методы могут привести к ускорению в 40 или более раз.

*   Используйте декларации.

*   Избегайте обобщенных функций.

*   Избегайте сложных списков аргументов.

*   Предоставить макросы компилятора.

*   Избегайте ненужного consing-а(создания лишних списков).

*   Используйте правильные структуры данных.

## 10.1 Используйте декларации(объявления)

На компьютерах общего назначения, на которых работает Lisp, много времени тратится на проверку типов.
Вы можете повысить эффективность за счет надежности, объявив или пообещав, что определенные переменные всегда будут определенного типа.
Например, рассмотрим следующую функцию для вычисления суммы квадратов последовательности чисел:

```lisp
(defun sum-squares (seq)
  (let ((sum 0))
    (dotimes (i (length seq))
      (incf sum (square (elt seq i))))
    sum))
(defun square (x) (* x x))
```

Если эта функция будет использоваться только для суммирования векторов фиксированных чисел(fixnums), мы можем сделать её намного быстрее, добавив объявления:

```lisp
(defun sum-squares (vect)
  (declare (type (simple-array fixnum *) vect)
        (inline square) (optimize speed (safety 0)))
  (let ((sum 0))
    (declare (fixnum sum))
    (dotimes (i (length vect))
      (declare (fixnum i))
      (incf sum (the fixnum (square (svref vect i)))))))
    sum))
```

Объявление fixnum позволит компилятору напрямую использовать целочисленную арифметику, а не проверять тип каждого слагаемого.
Специальная форма (`the fixnum` ...) - это обещание, что аргумент является фиксированным числом(fixnum).
Объявление `(optimize speed (security 0))` сообщает компилятору, что функция должна быть как можно быстрее, возможно, за счет снижения безопасности кода (игнорируя типов и т. Д.).
Другими величинами, которые можно оптимизировать, являются `compilation-speed, space`(скорость компиляции, пространство) и только в ANSI Common Lisp `debug` (простота отладки).
Величинам может быть присвоено число от 0 до 3, определяющее, насколько они важны; 3 является важным и используется по умолчанию, если номер не указан.

Объявление (`inline square`) позволяет компилятору сгенерировать умножение, указанное в `square`, прямо в цикле, без явного вызова функции square.
Компилятор создаст локальную переменную для (`svref vect i`) и не будет выполнять ссылочные дважды встроенные функции, не имея никаких проблем, связанных с макросами, как описано на [страница 853] (B9780080571157500248.xhtml#p853).
Однако есть один недостаток: когда вы переопределяете встраиваемую функцию, вам может потребоваться перекомпилировать все функции, которые ее вызывают.

Вы можете объявить функцию `inline`, когда она короткая, и поэтому накладные расходы на вызов функции будут составлять значительную часть общего времени выполнения.
Вы не должны объявлять функцию `inline`, когда функция является рекурсивной, когда ее определение может измениться или когда определение функции длинное и вызывается из многих мест.

В рассматриваемом примере объявление функции встраиваемой, экономит накладные расходы на вызов функции.
В некоторых случаях возможна дальнейшая оптимизация.
Рассмотрим предикат `starts-with`:

```lisp
  (defun starts-with (list x)
    "Is x a list whose first element is x?"
    (and (consp list) (eql (first list) x)))
  )
```

Предположим, у нас есть такой фрагмент кода:

```lisp
(if (consp list) (starts-with list x) ...)
```

Если `start-with` объявлен как `inline`, этот код расширится до:

```lisp
(if (consp list) (and (consp list) (eql (first list) x)) ...)
```

что многие компиляторы упростят до:

```lisp
(if (consp list) (eql (first list) x) ...)
```

Очень немногие компиляторы делают такое упрощение функций без подсказки, предоставляемой `inline`.

Помимо исключения проверки типов во время выполнения, объявления также позволяют компилятору выбирать наиболее эффективное представление объектов данных.
Многие компиляторы поддерживают как *упакованные*(boxed), так и *распакованные*(unboxed) представления объектов данных.
Упакованное представление содержит достаточно информации, чтобы определить тип объекта.
Распакованное представление - это просто "сырые биты", с которыми компьютер может иметь дело напрямую.
Рассмотрим следующую функцию, которая используется для очистки массива 1024 x 1024 чисел с плавающей запятой, устанавливая для каждого из них ноль:

```lisp
(defun clear-m-array (array)
  (declare (optimize (speed 3) (safety 0)))
  (declare (type (simple-array single-float (1024 1024)) array))
  (dotimes (i 1024)
    (dotimes (j 1024)
      (setf (aref array i j) 0.0))))
```

В Allegro Common Lisp на Sun SPARCstation это компилируется в довольно хороший код, сравнимый с кодом, созданным компилятором C для эквивалентной программы C.
Однако, если объявления не указаны, производительность будет примерно в 40 раз хуже.

Проблема в том, что без деклараций небезопасно хранить необработанное представление `0.0` с плавающей запятой в каждом месте массива.
Вместо этого программа должна поместить в упаковку `0.0`, выделяя память для типизированного указателя на необработанные биты.
Это делается внутри вложенных циклов, поэтому в результате каждый вызов версии `clear-m-array` без объявлений вызывает функцию упаковки floating-point-boxing 1048567 раз, выделяя миллион слов памяти.
Излишне говорить, что этого следует избегать.

Не все компиляторы принимают во внимание все объявления; вы должны проверить, прежде чем тратить время на объявления, которые ваш компилятор может игнорировать.
Функцию `disassemble` можно использовать, чтобы показать, во что компилируется функция.
Например, рассмотрим тривиальную функцию сложения двух чисел.
Вот с декларациями и без:

```lisp
(defun f (x y)
  (declare (fixnum x y) (optimize (safety 0) (speed 3)))
  (the fixnum (+ x y)))
(defun g (x y) (+ x y))
```

Вот дизассемблированный код f из Allegro Common Lisp для процессора Motorola серии 68000:

```
> (disassemble 'f)
;; disassembling #<Function f @ #x83ef79  >
;; formals: x y
;; code vector @ #x83ef44
```

| []()  |          |                 |
|-------|----------|-----------------|
| `0:`  | `link`   | `a6.#0`         |
| `4:`  | `move.l` | `a2,-(a7)`      |
| `6:`  | `move.l` | `a5,-(a7)`      |
| `8:`  | `move.l` | `7(a2),a5`      |
| `12:` | `move.l` | `8(a6).d4 ; y`  |
| `16:` | `add.l`  | `12(a6),d4 ; x` |
| `20:` | `move.l` | `#1,d1`         |
| `22:` | `move.l` | `-8(a6),a5`     |
| `26:` | `unlk`   | `a6`            |
| `28:` | `rtd`    | `#8`            |

На первый взгляд это может показаться устрашающим, но вам не нужно быть экспертом в ассемблере 68000, чтобы получить некоторое представление о том, что здесь происходит.
Инструкции, помеченные 0-8 (метки в крайнем левом столбце), составляют типичную преамбулу функции для 68000.
Они связывают подпрограммы и сохраняют новый объект функции и вектор констант в регистры.
Поскольку f не использует констант, инструкции 6, 8 и 22 действительно не нужны и могут быть опущены.
Инструкции 0,4 и 26 также можно опустить, если вам не нужно видеть эту функцию в трассировке стека во время отладки.
В более поздних версиях компилятора эти инструкции отсутствуют.

В основе функции `f` лежит последовательность из двух инструкций 12-16.
Инструкция 12 извлекает `y`, а 16 добавляет `y` к `x`, оставляя результат в `d4`, который является регистром `результата`.
Инструкция 20 устанавливает регистр `dl`, `количество возвращаемых значений`, в 1.

Сравните это с кодом для `g`, который не имеет деклараций и компилируется с настройками скорости и безопасности по умолчанию:

```
> (disassemble 'g)
;; disassembling #<Function g @ #x83dbd1  >
;; formals: x y
;; code vector @ #x83db64
```

| []()  |          |                |                  |
|-------|----------|----------------|------------------|
| `0:`  | `add.l`  | `#8,31(a2)`    |                  |
| `4:`  | `sub.w`  | `#2,dl`        |                  |
| `6:`  | `beq.s`  | `12`           |                  |
| `8:`  | `jmp`    | `16(a4)`       | `; wnaerr`       |
| `12:` | `link`   | `a6,#0`        |                  |
| `16:` | `move.l` | `a2,-(a7)`     |                  |
| `18:` | `move.l` | `a5,-(a7)`     |                  |
| `20:` | `move.l` | `7(a2),a5`     |                  |
| `24:` | `tst.b`  | `-  208(a4)`   | `; signal-hit`   |
| `28`  | `beq.s`  | `34`           |                  |
| `30:` | `jsr`    | `872(a4)`      | `; process-sig`  |
| `34:` | `move.l` | `8(a6),d4`     | `; y`            |
| `38:` | `move.l` | `12(a6),d0`    | `; x`            |
| `42:` | `or.l`   | `d4,d0`        |                  |
| `44:` | `and.b`  | `#7,d0`        |                  |
| `48:` | `bne.s`  | `62`           |                  |
| `50:` | `add.l`  | `12(a6),d4 ;`  | `x`              |
| `54:` | `bvc.s`  | `76`           |                  |
| `56:` | `jsr`    | `696(a4)`      | `; add-overflow` |
| `60:` | `bra.s`  | `76`           |                  |
| `62:` | `move.l` | `12(a6),-(a7)` | `; x`            |
| `66:` | `move.l` | `d4,-(a7)`     |                  |
| `68:` | `move.l` | `#2,d1`        |                  |
| `70:` | `move.l` | `-304(a4),a0`  | `; +  _2op`      |
| `74:` | `jsr`    | `(a4)`         |                  |
| `76:` | `move.l` | `#1,d1`        |                  |
| `78:` | `move.l` | `-8(a6),a5`    |                  |
| `82:` | `unlk`   | `a6`           |                  |
| `84:` | `rtd`    | `#8`           |                  |

Посмотрите, сколько еще работы выполняется .
Первые четыре инструкции гарантируют, что правильное количество аргументов было передано в `g`.
В противном случае происходит переход к `wnaerr` (ошибка неправильного числа аргументов).
Инструкции 12-20 имеют код загрузки аргумента, который был в 0-8 в `f`.
На 24-30 выполняется проверка на наличие асинхронных сигналов, таких как нажатие пользователем клавиши прерывания.
После загрузки `x` и `y` выполняется проверка типа (42-48).
Если оба аргумента не являются фиксированными числами, то код в инструкциях 62-74 устанавливает вызов `+ _2op`, который обрабатывает приведение типов и сложение не фиксированных чисел.
Если все идет хорошо, нам не нужно вызывать эту процедуру, а вместо этого выполнять сложение по инструкции 50.
Но даже в этом случае мы не закончили - просто потому, что два аргумента были фиксированными числами, не означает, что результат будет.
Инструкции 54-56 проверяют и при необходимости переходят к процедуре переполнения.
Наконец, инструкции 76-84 возвращают окончательное значение, как и в `f`.

Некоторые некачественные компиляторы вообще игнорируют объявления.
Другим компиляторам не нужны определенные объявления, потому что они могут полагаться на специальные инструкции в базовой архитектуре.
На Lisp-машине и `f` и `g` компилируются в один и тот же код:


```
  6 PUSH    ARG|0`   ; X
  7 +       ARG|1`   ; Y
  8 RETURN  PDL-POP
```

В Lisp Machine есть микрокодированная инструкция +, которая одновременно выполняет добавление fixnum и проверяет аргументы, отличные от fixnum, переходя к подпрограмме, если любой из аргументов не является fixnum.
Оборудование выполняет ту работу, которую компилятор должен делать на обычном процессоре.
Это упрощает компилятор Lisp Machine, поэтому компиляция функции выполняется быстрее.
Однако на современных конвейерных компьютерах с кэшем инструкций микрокодирование практически не дает никаких преимуществ.
Текущая тенденция - от микрокода к компьютерам с сокращенным набором команд (RISC).

На большинстве компьютеров, скорее всего, будут полезны следующие объявления:

* `fixnum и float`.
Числа, объявленные как фиксированные числа или числа с плавающей запятой, могут обрабатываться непосредственно арифметическими инструкциями хост компьютера.
В некоторых системах одного `float` недостаточно; вы должны сказать `single-float` или `double-float`.
Другие числовые объявления, вероятно, будут проигнорированы.
Например, объявление переменной как целого числа не сильно помогает компилятору, потому что bignums тоже являются целыми числами.
Код для добавления bignums слишком сложен, чтобы вставлять его в строку, поэтому компилятор будет переходить к подпрограмме общего назначения (например, `+ _2op` в Allegro), той же подпрограмме, которую он использовал бы, если бы не было задано никаких объявлений.

*   `list и array`.
Многие системы Lisp предоставляют отдельные функции для версий списка и массива часто используемых функций работы с последовательностями.
Например, `(delete x (the list 1))` компилируется в `(sys:delete-list-eql x 1)` на Lisp Machine TI Explorer.
Другая функция, `sys:delete-vector`, используется для массивов, а обобщенная функция `delete` используется только тогда, когда компилятор не может определить тип последовательности.
Поэтому, если вы знаете, что аргументом обобщенной функции является либо `список`, либо `массив`, объявите его как таковой.

*   `simple-vector и simple-array`
Простые векторы и массивы - это те, которые не имеют общей структуры с другими массивами, не имеют указателей заполнения и не регулируются(not adjustable).
Во многих реализациях aref для `simple-vector` быстрее, чем для `vector`.
И он, безусловно, намного быстрее, чем взятие `elt` последовательности неизвестного типа.
Объявите свои массивы простыми(simple) (если они действительно таковы).

*   `(array *type*)`.
Часто бывает важно определить тип элементов массива.
Например, `(array short-float)` может занимать только половину хранилища общего массива, и такое объявление обычно позволяет выполнять вычисления с использованием собственных инструкций ЦП с плавающей запятой вместо преобразования `в` и `из` Представление чисел с плавающей запятой в Common Lisp.
Это очень важно, потому что преобразование обычно требует выделения памяти, а прямое вычисление - нет.
Спецификаторы `(simple-array *type*)` и `(vector *type*)` должны использоваться вместо `(array *type*)`, когда это применимо.
Очень распространенной ошибкой является объявление `(simple-vector *type*)`.
Это ошибка, потому что Common Lisp ожидает `(simple-vector *size*)` - не спрашивайте меня, почему.

*   `(array **dimensions*)`.
Полная форма спецификатора типа массива или `simple-array` это `(array *type dimensions*)`.
Так, например, `(array bit (* *))` представляет собой двумерный битовый массив, а `(array bit (1024 1024))` представляет собой массив размером 1024 x 1024 бит.
Очень важно указать количество измерений, когда оно известно, и менее важно указать точный размер, хотя для многомерных массивов объявление размера более важно.
Формат спецификатора векторного типа - `(vector *type size*)`.

Обратите внимание, что некоторые из этих объявлений могут применяться одновременно.
Например, в

```lisp
(position # \ . (the simple-string file-name))
```

переменная `filename` была объявлена как вектор, простой массив и последовательность типа `string-char`.
Все три обявления полезны.
Тип `simple-string` - это сокращение от `(simple-array string-char)`.

Это руководство применимо к большинству систем Common Lisp, но вам следует заглянуть в примечания по реализации для вашей конкретной системы, чтобы получить больше советов о том, как настроить ваш код.

## 10.2 Избегайте Обобщенных Функций

Common Lisp предоставляет функции с большой обобщенностью, но кто-то должен заплатить за эту обобщенность.
Например, если вы напишете `(elt x 0)`, разные машинные инструкции будут выполняться в зависимости от того, является ли x списком, строкой или вектором.
Без деклараций, проверки придется проводить во время выполнения.
Вы можете либо предоставить объявления(декларации), как в `(elt (the list x) 0)`, либо использовать более конкретную(специализированную) функцию, такую как `(first x)` в случае списков, `(char x 0)` для строк , `(aref x 0)` для векторов и `(svref x 0)` для простых векторов.
Конечно, обобщенные функции полезны - я написал `random-elt`, как показано ниже, для работы со списками, тогда как вместо этого я мог бы написать более эффективный `random-mem`.
Выбор окупился, когда `Я` захотел, чтобы функция выбирала случайный символ из строки - `random-elt` выполняет свою работу без изменений, а `random-mem` - нет.

```lisp
(defun random-elt (s) (elt s (random (length s))))
(defun random-mem (l) (nth (random (length (the list l))) l))
```

Этот пример был простым, но в более сложных случаях вы можете сделать свои функции работы с последовательностями более эффективными, если они будут явно проверять, являются ли их аргументы списками или векторами.
См. Определение `map-into` на [страница 857](B9780080571157500248.xhtml#p857).

## 10.3 Избегайте сложных списков аргументов

Функции с аргументами ключевыми словами несут большие накладные расходы.
Это также может быть верно для необязательных аргументов и аргументов `rest`, хотя обычно в меньшей степени.
Давайте посмотрим на несколько простых примеров:

```lisp
(defun reg (a b c d) (list a b c d))
(defun rst (abc &rest d) (list* a b c d))
(defun opt (&optional a b (c 1) (d (sqrt a))) (list a b c d))
(defun key (&key a b (c 1) (d (sqrt a))) (list a b c d))
```

Мы можем видеть, во что они компилируются для TI Explorer, но помните, что ваш компилятор может быть совершенно другим.

`> (disassemble 'reg)`

| []()                     |        |     |             |
|--------------------------|--------|-----|-------------|
| `      8 PUSH`           | `ARG   | 0`  | `; A`       |
| `      9 PUSH`           | `ARG   | 1`  | `; B`       |
| `    10 PUSH`            | `ARG   | 2`  | `; C`       |
| `    11 PUSH`            | `ARG   | 3`  | `; D`       |
| `    12 TAIL-REC CALL-4` | `FEF   | 3`  | `; #'LIST`  |

`> (disassemble 'rst)`

| []()                     |        |     |             |
|--------------------------|--------|-----|-------------|
| `      8 PUSH`           | `ARG   | 0`  | `; A`       |
| `      9 PUSH`           | `ARG   | 1`  | `; B`       |
| `    10 PUSH`            | `ARG   | 2`  | `; C`       |
| `    11 PUSH`            | `LOCAL | 0`  | `; D`       |
| `    12 RETURN CALL-4`   | `FEF   | 3`  | `; #'LIST*` |

При использовании обычного списка аргументов мы просто помещаем четыре переменные в стек аргументов и переходим к вызову функции list.
([Глава 22](B9780080571157500224.xhtml) объясняет, почему хвосто-рекурсивный вызов является просто оператором ветвления.)

С аргументом rest все почти так же просто.
Оказывается, на этой машине микрокод для вызывающей последовательности автоматически обрабатывает аргументы rest, сохраняя их в локальной переменной 0.
Сравним с кодом использующим необязательные аргументамы:

```
(defun opt (&optional a b (c 1) (d (sqrt a))) (list a b c d))
  > (disassemble 'opt)
```


```
  24 DISPATCH        FEF|5 ; [0=>25;1=>25;2=>25;3=>27;ELSE=>30]
  25 PUSH-NUMBER     1               
  26 POP             ARG|2 ; C     
  27 PUSH            ARG|0 ; A     
  28 PUSH CALL-1     FEF|3 ; #'SQRT
  29 POP             ARG|3 ; D     
  30 PUSH            ARG|0 ; A     
  31 PUSH            ARG|1 ; B     
  32 PUSH            ARG|2 ; C     
  33 PUSH            ARG|3 ; D     
  34 TAIL-REC CALL-4 FEF|4 ; #'LIST
```

Хотя этот язык ассемблера может быть труднее читать, оказывается, что необязательные аргументы обрабатываются очень эффективно.
Вызывающая последовательность хранит количество необязательных аргументов наверху стека, а инструкция DISPATCH использует это для индексации в таблице, хранящейся в ячейке `FEF|5` (смещение на пять слов от начала функции).
В результате в одной инструкции функция переходит в нужное место для инициализации любых неуказанных аргументов.
Таким образом, функция с предоставленными необязательными аргументами принимает только на одну инструкцию (отправку/dispatch) больше, чем в "обычном" случае.
К сожалению, аргументы ключевых слов так не работают:

```
(defun key (&key a b` (`c 1`) `(d (sqrt a))) (list a b c d))
  > (disassemble 'key)
```

```
  14 PUSH-NUMBER                1                             
  15 POP                        LOCAL|3 ; C                  
  16 PUSH                       FEF|3   ; SYS:-.KEYWORD-GARBAGE
  17 POP                        LOCAL|4                        
  18 TEST                       LOCAL|0
  19 BR-NULL                    24
  20 PUSH                       FEF|4   ; '(:A :B :C :D)
  21 SET-NIL                    PDL-PUSH
  22 PUSH-LOC                   LOCAL|1 ; A
  23 (AUX) %STORE-KEY-WORD-ARGS             
  24 PUSH                       LOCAL|1 ; A
  25 PUSH                       LOCAL|2 ; B
  26 PUSH                       LOCAL|3 ; C
  27 PUSH                       |4         
  28 EQ                         FEF|3   ; SYS::KEYWORD-GARBAGE
  29 BR-NULL                    33                            
  30 PUSH                       LOCAL|1 ; A
  31 PUSH CALL-1                FEF|5   ; #'SQRT
  32 RETURN CALL-4              FEF|6   ; #'LIST
  33 PUSH                       LOCAL|4
  34 RETURN CALL-4              FEF|6   ; #'LIST
```

Не важно уметь читать весь этот ассемблер.
Дело в том, что существуют значительные накладные расходы, даже несмотря на то, что в этой архитектуре есть специальная инструкция `(%STORE-KEY-WORD-ARGS)` для помощи при работе с аргументами ключевыми словами.

Теперь давайте посмотрим на результаты на другой системе, компиляторе Allegro для 68000.
Во-первых, вот ассемблерный код для reg, чтобы дать вам представление о минимальной последовательности вызовов: [1](# fn0015)

```
> (disassemble 'reg)
;; disassembling #<Function reg @ #x83db59  >
;; formals: a b c d
;; code vector @ #x83dblc
```

| []()  |          |                |          |
|-------|----------|----------------|----------|
| `0:`  | `link`   | `a6,#0`        |          |
| `4:`  | `move.l` | `a2,-(a7)`     |          |
| `6:`  | `move.l` | `a5,-(a7)`     |          |
| `8:`  | `move.l` | `7(a2),a5`     |          |
| `12:` | `move.l` | `20(a6),-(a7)` | `; a`    |
| `16:` | `move.l` | `16(a6).-(a7)` | `; b`    |
| `20:` | `move.l` | `12(a6),-(a7)` | `; c`    |
| `24:` | `move.l` | `8(a6),-(a7)`  | `; d`    |
| `28:` | `move.l` | `#4,dl`        |          |
| `30:` | `jsr`    | `848(a4)`      | `; list` |
| `34:` | `move.l` | `-  8(a6),a5`  |          |
| `38:` | `unlk`   | `a6`           |          |
| `40:` | `rtd`    | `#10`          |          |

Теперь мы видим, что аргументы `&rest` занимают намного больше кода в этой системе:

```
> (disassemble 'rst)
;; disassembling #<Function rst @ #x83de89  >
;; formals: a b c &rest d
code vector @ #x83de34
```

| []()  |          |                 |                         |
|-------|----------|-----------------|-------------------------|
| `0:`  | `sub.w`  | `#3,dl`         |                         |
| `2:`  | `bge.s`  | `8`             |                         |
| `4:`  | `jmp`    | `16(a4)`        | `; wnaerr`              |
| `8:`  | `move.l` | `(a7)+,al`      |                         |
| `10`: | `move.l` | `d3,-(a7)`      | `; nil`                 |
| `12`: | `sub.w`  | `#l,dl`         |                         |
| `14:` | `bit.s`  | `38`            |                         |
| `16:` | `move.l` | `al, -  52(a4)` | `; c_protected-retaddr` |
| `20:` | `jsr`    | `40(a4)`        | `; cons`                |
| `24:` | `move.l` | `d4,-(a7)`      |                         |
| `26:` | `dbra`   | `dl,20`         |                         |
| `30:` | `move.l` | `-  52(a4),al`  | `; c_protected-retaddr` |
| `34:` | `clr.l`  | `-  52(a4)`     | `; c_protected-retaddr` |
| `38:` | `move.l` | `al,`           | `-(a7)`                 |
| `40:` | `link`   | `a6,#0`         |                         |
| `44:` | `move.l` | `a2,-(a7)`      |                         |
| `46:` | `move.l` | `a5,-(a7)`      |                         |
| `48:` | `move.l` | `7(a2),a5`      |                         |
| `52:` | `move.l` | `-  332(a4),a0` | `; list*`               |
| `56:` | `move.l` | `-  8(a6),a5`   |                         |
| `60:` | `unlk`   | `a6`            |                         |
| `62`: | `move.l` | `#4,dl`         |                         |
| `64`  | `jmp`    | `(a4)`          |                         |

Цикл от 20 до 26 строит список `&rest` по одному cons за раз.
Частично сложность состоит в том, что cons-ы могут инициировать сборку мусора в любое время, поэтому список должен быть построен в месте, о котором сборщик мусора будет знать.
Функция с необязательными аргументами еще хуже, она принимает 34 инструкции (104 байта), а ключевые слова хуже всего, занимая 71 инструкцию (178 байтов) и включает цикл.
Накладные расходы для необязательных аргументов пропорциональны количеству необязательных аргументов, в то время как для ключевых слов они пропорциональны произведению количества разрешенных параметров и количества фактически предоставленных аргументов.

Хорошим руководящим принципом для подражания является использование аргументов ключевого слова в первую очередь как интерфейс для редко используемых функций и предоставление версий этих функций без ключевых слов, которые можно использовать в местах, где важна эффективность.
Рассмотрим:

```lisp
(proclaim '(inline key))
(defun key (&key a b (c 1) (d (sqrt a))) (*no-key a b c d))
(defun *no-key (a b c d) (list a b c d))
```

Здесь функция `key` используется как интерфейс к функции `no-key`, которая выполняет реальную работу.
Объявление inline должно позволить компилятору скомпилировать вызов `key` как вызов `no-key` с соответствующими аргументами:

```
> (disassemble #'(lambda (x y) (key :b x :a y)))
```

```
  10 PUSH            ARG|1 ; Y
  11 PUSH            ARG|0 ; X
  12 PUSH-NUMBER     1        
  13 PUSH            ARG|1 ; Y
  14 PUSH CALL-1     FEF|3 ; #'SORT
  15 TAIL-REC CALL-4 FEF|4 ; #'NO-KEY
```

Накладные расходы возникают только тогда, когда ключевые слова неизвестны во время компиляции.
В следующем примере компилятор вынужден вызывать `key`, а не `no-key`, потому что он не знает, каким будет ключевое слово `k` во время выполнения:

```
> (disassemble #'(lambda (k x y) (key k x :a y)))
```

```
  10 PUSH             ARG|0  ; K     
  11 PUSH             ARG|1  ; X     
  12 PUSH             FEF|3  ; ':A   
  13 PUSH             ARG|2  ; Y     
  14 TAIL-REC CALL-4  FEF|4  ; #'KEY 
```

Конечно, в этом простом примере я мог бы заменить `no-key` на `list`, но в целом это будет более сложная обработка.
Если бы я также объявил `inline` `no-key`, то получил бы следующее:

```
> (disassemble #'(lambda (x y) (key :b x :a y)))
```

```
  10 PUSH             ARG|1  ; Y
  11 PUSH             ARG|0  ; X
  12 PUSH-NUMBER      1         
  13 PUSH             ARG|1  ; Y
  14 PUSH CALL-1      FEF|3  ; #'SORT
  15 TAIL-REC CALL-4  FEF|4  ; #'LIST
```

Если хотите, вы можете определить макрос для автоматического определения интерфейса функции без ключевых слов:

```lisp
(defmacro defun* (fn-name arg-list &rest body)
```

`  "Define two functions.
one an interface to a &keyword-less`

`  version.
Proclaim the interface function inline."`

```lisp
  (if (and (member '&key arg-list)
        (not (member '&rest arg-list)))
      (let ((no-key-fn-name (symbol fn-name '*no-key))
        (args (mapcar #'first-or-self
              (set-difference
                arg-list
                lambda-list-keywords))))
      '(progn
        (proclaim '(inline ,fn-name))
        (defun ,no-key-fn-name ,args
          .,body)
        (defun ,fn-name ,arg-list
          (,no-key-fn-name .,args))))
    '(defun ,fn-name ,arg-list
      .,body)))
>(macroexpand '(defun* key (&key a b (c 1) (d (sqrt a)))
            (list a b c d)))
(PROGN (PROCLAIM '(INLINE KEY))
    (DEFUN KEY*NO-KEY (A B C D) (LIST A B C D))
    (DEFUN KEY (&KEY A B (C 1) (D (SQRT A)))
      (KEY*NO-KEY A B C D)))
>(macroexpand '(defun* reg (a b c d) (list a b c d)))
(DEFUN REG (A B C D) (LIST A B C D))
```

У этого подхода есть один недостаток: пользователь, который хочет объявить key встроенной или не встроенной, не получит ожидаемого результата.
Пользователь должен знать, что key реализован с помощью `key*no-key`, и объявить `key*no-key` встроенной.

Альтернативой является просто объявить функцию, использующую `&key`, встроенной.
Роб Маклахлан приводит пример.
В CMU Lisp функция `member` имеет следующее определение, объявленное встроенным:

```lisp
(defun member (item list &key (key #'identity)
                (test #'eql testp)(test-not nil notp))
  (do ((list list (cdr list)))
      ((null list) nil)
    (let ((car (car list)))
      (if (cond
        (testp
          (funcall test item
                (funcall key car)))
        (notp
          (not
      (funcall test-not item
            (funcall key car))))
    (t
      (funcall test item
            (funcall key car))))
  (return list)))))
```

Вызов вида `(member` [ch 1](B9780080571157500017.xhtml)`:key #'first-letter :test #'char =)` заменяется эквивалентом следующего кода.
К сожалению, не все компиляторы настолько умны с объявлениями inline.

```lisp
(do ((list list (cdr list)))
      ((null list) nil)
    (let ((car (car list)))
      (if (char  = ch (first-letter car))
        (return list))))
```

Эта глава посвящена эффективности и поэтому выступает против использования параметра ключевого слова в часто используемых функциях.
Но если принять во внимание сопровождаемость, параметры ключевых слов выглядят предпочтительнее.
Когда программа разрабатывается, и неясно, потребуются ли функции в конечном итоге дополнительные аргументы, параметры ключевых слов могут быть лучшим выбором.

10.4 Избегайте ненужного Consing(а)/построения временных списков

Может показаться, что функция `cons` выполняется довольно быстро, но, как и все функции, выделяющие новое хранилище, она имеет скрытую стоимость.
Когда используется большой объем хранилища, в конечном итоге системе приходится тратить время на сборку мусора.
Мы не упоминали об этом ранее, но на самом деле есть два важных показателя объема пространства, потребляемого программой: объем выделенного хранилища и объем используемого хранилища.
Разница в том, что хранилище используется временно, но в конечном итоге освобождается.
Lisp гарантирует, что неиспользуемое пространство в конечном итоге будет возвращено сборщиком мусора.
Это происходит автоматически - программисту нет необходимости и он не может явно освобождать память.
Проблема в том, что эффективность сборки мусора может сильно различаться.
Сборка мусора особенно тревожна для систем реального времени, потому что это может произойти в любое время.

Противоядие от проблем с мусором - избегать ненужного копирования объектов в часто используемом коде.
Попробуйте использовать деструктивные операции, такие как `nreverse, delete` и `nconc`, а не их неразрушающие аналоги (например, reverse, remove и append), когда это безопасно.
Или используйте векторы вместо списков и повторно используйте значения, а не создавайте копии.
Как обычно, такое повышение эффективности может привести к ошибкам, которые может быть трудно отладить.
Однако наиболее распространенный вид ненужного копирования можно устранить простой реорганизацией вашего кода.
Рассмотрим следующую версию `flatten`, которая возвращает список всех атомов во входных данных, сохраняя порядок.
В отличие от версии в [главе 5](B9780080571157500054.xhtml), эта версия возвращает единственный список атомов без встроенных списков.

```lisp
(defun flatten (input)
  "Return a flat list of the atoms in the input.
  Ex: (flatten '((a) (b (c) d))) => (a b c d)."
  (cond ((null input) nil)
      ((atom input) (list input))
      (t (append (flatten (first input))
            (flatten (rest input))))))
```

Это определение довольно простое, и нетрудно убедиться в его правильности.
Однако каждый вызов `append` требует копирования первого аргумента, поэтому эта версия может cons(создавать) *O*(*n*2) ячеек при входе с *n* атомами.
Проблема с этим подходом заключается в том, что он вычисляет список атомов в `first` и `rest` каждого подкомпонента ввода.
Но подсписок `first` сам по себе не является частью окончательного ответа, поэтому мы должны вызвать `append`. Мы могли бы избежать генерации мусора, заменив `append` на `nconc`, но даже тогда мы все равно будем терять время. , потому что `nconc` придется сканировать каждый подсписок, чтобы найти его конец.

В приведенной ниже версии используется *аккумулятор* для отслеживания атомов, которые были собраны в rest, и для добавления атомов в `first` по одному с помощью cons, вместо того, чтобы создавать ненужные подсписки и добавлять их.
Таким образом, не создается мусор, и ни один из подкомпонентов не проходится более одного раза.

```lisp
(defun flatten (input &optional accumulator)
  "Return a flat list of the atoms in the input.
  Ex: (flatten '((a) (b (c) d))) => (a b c d)."
  (cond ((null input) accumulator)
      ((atom input) (cons input accumulator))
      (t (flatten (first input)
            (flatten (rest input) accumulator)))))
```

Версия с аккумулятором может быть немного сложнее для понимания, но она намного эффективнее оригинальной версии.
Опытные программисты на Лиспе достаточно хорошо умеют заменять вызовы `append` на аккумуляторы.

Некоторые из ранних машин Lisp имели ненадежную сборку мусора, поэтому пользователи просто отключили сборку мусора, использовали машину в течение нескольких дней и перезагружали, когда им не хватало места.
Для большой системы виртуальной памяти это осуществимый подход, потому что виртуальная память - дешевый ресурс.
Проблема в том, что реальная память по-прежнему является дорогим ресурсом.
Когда каждая страница содержит в основном мусор и мало данных в реальном времени, система будет тратить много времени на подкачку и выгрузку данных.
Алгоритмы сжатия мусора могут перемещать живые данные, упаковывая их на минимальное количество страниц.

Некоторые алгоритмы сборки мусора были оптимизированы, чтобы особенно хорошо справляться именно с этим случаем.
Если в вашей системе есть *ephemeral* или *generational* сборщик мусора, вам не нужно так беспокоиться о недолговечных объектах.
Вместо этого проблемы будут вызывать предметы среднего возраста.
Другая проблема с такими системами возникает, когда объект в старом поколении изменяется, чтобы указывать на объект в новом поколении.
Этого следует избегать, и может оказаться, что в таких случаях reverse на самом деле быстрее, чем nreverse.
Чтобы решить, что лучше всего работает в вашей конкретной системе, разработайте несколько тестовых примеров и определите время их выполнения.

В качестве примера эффективного использования хранилища приведем версию `pat-match`, которая устраняет (почти) все consing.
В исходной версии `pat-match`, используемой в ELIZA ([страница 180](B9780080571157500066.xhtml#p180)), для представления списка привязки использовался список ассоциаций пар переменная/значение.
В этой версии используются две последовательности: последовательность переменных и последовательность значений.
Последовательности реализованы как векторы, а не списки.
Как правило, векторы занимают вдвое меньше места, чем списки, для хранения той же информации, поскольку половина каждого списка просто указывает на следующий элемент.

В этом случае экономия намного больше, чем половина.
Вместо того, чтобы создавать небольшие списки привязки для каждого частичного совпадения и добавлять к ним, когда совпадение расширяется, мы выделим достаточно большой вектор переменных и значений только один раз и будем использовать их снова и снова для каждого частичного совпадения и даже для каждого вызов `pat-match`. Для этого нам нужно знать, сколько переменных мы в настоящее время используем.
Мы могли бы инициализировать счетчик переменных нулем и увеличивать его каждый раз, когда мы находим новую переменную в образце.
Единственная трудность возникает, когда переменная счетчика превышает размер вектора.
Мы могли бы просто отказаться и напечатать сообщение об ошибке, но есть более удобные альтернативы.
Например, мы могли бы выделить больший вектор для переменных, скопировать существующие, а затем добавить новый.

Когда вектор создан, ему может быть присвоен *указатель заполнения*/*fill pointer*.
Это переменная счетчик, но она концептуально хранится внутри вектора.
Векторы с указателями заполнения действуют как нечто среднее между вектором и стеком.
Вы можете помещать новые элементы в стек с помощью функций `vector-push` или `vector-push-extend`.
Последний автоматически выделит больший вектор и при необходимости скопирует элементы.
Вы можете удалить элементы с помощью `vector-pop`, или вы можете явно посмотреть на указатель заполнения с помощью `fill-pointer`, или изменить его с помощью `setf`.
Вот несколько примеров (с `*print-array*`, установленным в t, чтобы мы могли видеть результаты):

`> (setf a (make-array 5 :fill-pointer 0))`=> `#()`

`> (vector-push 1 a)`=> `0`

`> (vector-push 2 a)`=> `1`

`> a`=> `#(1 2)`

`> (vector-pop a)`=> `2`

`> a`=> `#(1)`

`> (dotimes (i 10) (vector-push-extend 'x a))`=> `NIL`

`> a`=> `#(1 XXXXXXXXXX)`

`> (fill- pointer a)`=> `11`

`> (setf (fill-pointer a) 1)`=> `1`

`> a`=> `#(1)`

`> (find 'x a)`=> `NIL NIL ;`*FIND can't find past the fill pointer*

`> (aref a 2)`=> `X` ; *But AREF can see beyond the fill pointer*

При использовании векторов с указателями заполнения в `pat-match` общее хранилище для списков привязки вдвое превышает количество переменных в самом большом образце.
Я произвольно выбрал 10 в качестве максимального количества переменных, но даже это не является жестким пределом, потому что `vector-push-extend` может увеличить его.
В любом случае, общий объем хранилища невелик, фиксирован по размеру и амортизируется по всем вызовам `pat-match`. Это только те функции, которые указывают на ответственное использование хранилища.

Однако при таком подходе есть серьезная опасность: с возвращаемым значением нужно обращаться осторожно.
Новый `pat-match` возвращает значение `success`, когда она находит совпадение.
`success` связан с cons переменных и  векторов значений.
Вызывающая процедура может свободно ими манипулировать, но только до следующего вызова `pat-match`. В это время содержимое двух векторов может измениться.
Следовательно, если какой-либо вызывающей функции необходимо сохранить возвращаемое значение после другого вызова `pat-match`, она должна сделать копию возвращенного значения.
Так что было бы не совсем правильно говорить, что эта версия `pat-match` устраняет все недоразумения.
Она будет работать, когда в `vector-push-extend` закончится место или когда пользователю нужно сделать копию возвращенного значения.

Вот новое определение `pat-match`. Оно реализовано путем закрытия определения `pat-match` и двух его вспомогательных функций внутри `let`, которое устанавливает привязки `vars, vals` и `success` , но это не принципиально.
Вместо этого эти три переменные могли быть реализованы как глобальные переменные.
Обратите внимание, что она не поддерживает сегментные переменные или какие-либо другие опции, реализованные в `pat-match` [глава 6](B9780080571157500066.xhtml).

```lisp
(let* ((vars (make-array 10 :fill-pointer 0 :adjustable t))
      (vals (make-array 10 :fill-pointer 0 :adjustable t))
      (success (cons vars vals)))
(defun efficient-pat-match (pattern input)
  "Match pattern against input."
  (setf (fill-pointer vars) 0)
  (setf (fill-pointer vals) 0)
  (pat-match-1 pattern input))
(defun pat-match-1 (pattern input)
  (cond ((variable-p pattern) (match-var pattern input))
      ((eql pattern input) success)
      ((and (consp pattern) (consp input))
        (and (pat-match-1 (first pattern) (first input))
            (pat-match-1 (rest pattern) (rest input))))
      (t fail)))
(defun match-var (var input)
  "Match a single variable against input."
  (let ((i (position var vars)))
    (cond ((null i)
          (vector-push-extend var vars)
          (vector-push-extend input vals) success)
      ((equal input (aref vals i)) success)
      (t fail)))))
```

Пример её использования:

```lisp
>(efficient-pat-match '(?x + ?x = ?y . ?z)
                '(2 + 2 = (3 + 1) is true))
(#(?X ?Y ?Z) . #(2 (3 + 1) (IS TRUE)))
```

Расширяемые векторы с указателями заполнения удобны и намного более эффективны, чем составление списков.
Однако их использование связано с некоторыми накладными расходами, и для тех частей кода, которые должны быть наиболее эффективными, лучше всего придерживаться простых векторов.
Следующая версия `effective-pat-match` явно управляет размером векторов и явно заменяет их новыми, когда размер превышен:

```lisp
(let* ((current-size 0)
      (max-size 1)
      (vars (make-array max-size))
      (vals (make-array max-size))
      (success (cons vars vals)))
  (declare (simple-vector vars vals)
          (fixnum current-size max-size))
(defun efficient-pat-match (pattern input)
  "Match pattern against input."
  (setf current-size 0)
  (pat-match-1 pattern input))
;; pat-match-1 is unchanged
(defun match-var (var input)
  "Match a single variable against input."
  (let ((i (position var vars)))
    (cond
      ((null i)
        (when (= current-size max-size)
          ;; Make new vectors when we run out of space
          (setf max-size (* 2 max-size)
              vars (replace (make-array max-size) vars)
              vals (replace (make-array max-size) vals)
              success (cons vars vals)))
        ;; Store var and its value in vectors
        (setf (aref vars current-size) var)
        (setf (aref vals current-size) input)
```

`        (incf current-size)``        success)`

```lisp
      ((equal input (aref vals i)) success)
      (t fail)))))
```

В заключение, замена списков векторами часто может сэкономить мусор.
Но когда вам необходимо использовать списки, стоит использовать такую версию cons, которая по возможности избегает лишних конструирований.
Вот такая версия:

```lisp
(proclaim '(inline reuse-cons))
(defun reuse-cons (x y x-y)
  "Return (cons x y), or just x-y if it is equal to (cons x y)."
  (if (and (eql x (car x-y)) (eql y (cdr x-y)))
      x-y
      (cons x y)))
```

Уловка основана на определении subst в *Common Lisp the Language* Стила.
Вот определение версии `remove`, в которой используются `reuse-cons`:

```lisp
(defun remq (item list)
  "Like REMOVE, but uses EQ, and only works on lists."
  (cond ((null list) nil )
      ((eq item (first list)) (remq item (rest list)))
      (t (reuse-cons (first list)
                (remq item (rest list))
                list))))
```

### Избегайте Consing(конструирования списков): уникальные списки

Конечно, `reuse-cons` работает только тогда, когда у вас есть кандидаты на cons-ячейки.
То есть (`reuse-cons a b c`) экономит место только тогда, когда `c` равно (или может быть) равно (`cons a b`).
Для некоторых приложений полезно иметь версию `cons`, которая возвращает уникальную cons-ячейку без необходимости использовать `c` в качестве подсказки.
Мы будем называть эту версию `ucons` для `уникальных cons`. ucons поддерживает двойную хеш-таблицу: `*uniq-cons-table*` - хеш-таблица, ключи которой являются началом (`cars`) cons-ячеек.
Значение для каждого `car` - это другая хеш-таблица, ключи которой являются концом(`cdrs`) cons-ячеек.
Значение каждого `cdr` во второй таблице - это исходная cons-ячейка.
Таким образом, две разные cons-ячейки с одинаковыми `car` и `cdr` получат одно и то же значение.
Вот реализация `ucons`:

```lisp
(defvar *uniq-cons-table* (make-hash-table :test #'eq))
(defun ucons (x y)
```

`  "Return a cons s.t.
(eq (ucons x y) (ucons x y)) is true."`

```lisp
  (let ((car-table (or (gethash x *uniq-cons-table*)
                (setf (gethash x *uniq-cons-table*)
                    (make-hash-table :test #'eq)))))
    (or (gethash y car-table)
        (setf (gethash y car-table) (cons x y)))))
```

`ucons`, в отличие от `cons`, является истинной функцией: она всегда будет возвращать одно и то же значение при тех же аргументах, где "same/тождественность" измеряется с помощью eq.
Однако, если `ucons` заданы аргументы, которые равны, но не eq, она не вернет уникальный результат.
Для этого нам понадобится функция unique.
Она обладает тем свойством, что `(unique x)` эквивалентен `(unique y)` всякий раз, когда `x` и `y` равны(equal).
`unique` использует хеш-таблицу для атомов в дополнение к двойной хеш-таблице для conses.
Это необходимо, потому что строки и массивы могут быть равны(equal), не будучи eq.
Помимо `unique`, для удобства мы также определяем `ulist` и `uappend`.

```lisp
(defvar *uniq-atom-table* (make-hash-table :test #'equal))
  (defun unique (exp)
    "Return a canonical representation that is EQUAL to exp,
    such that (equal x y) implies (eq (unique x) (unique y))."
    (typecase exp
      (symbol exp)
      (fixnum exp) ;; Remove if fixnums are not eq in your Lisp
      (atom (or (gethash exp *uniq-atom-table*)
                (setf (gethash exp *uniq-atom-table*) exp)))
      (cons (unique-cons (car exp) (cdr exp)))))
  (defun unique-cons (x y)
```

`    "Return a cons s.t.
(eq (ucons x y) (ucons x2 y2)) is true`

```lisp
    whenever (equal x x2) and (equal y y2) are true."
    (ucons (unique x) (unique y)))
  (defun ulist (&rest args)
    "A uni qui fied list."
    (unique args))
  (defun uappend (x y)
    "A unique list equal to (append x y)."
    (if (null x)
        (unique y)
        (ucons (first x) (uappend (rest x) y))))
```

Приведенный выше код работает, но его можно улучшить.
Проблема в том, что когда к дереву применяется `unique`, она всегда проходит по дереву вплоть до листьев.
Функция `unique-cons` похожа на `ucons`, за исключением того, что `unique-cons` предполагает, что ее аргументы еще не уникальны.
Мы можем изменить `unique-cons`, чтобы она сначала проверяла, уникальны ли её аргументы, просматривая соответствующие хэш-таблицы:

```lisp
(defun unique-cons (x y)
```

`  "Return a cons s.t.
(eq (ucons x y) (ucons x2 y2)) is true`

```lisp
  whenever (equal x x2) and (equal y y2) are true."
  (let ((ux) (uy)) ; unique x and y
    (let ((car-table
          (or (gethash x *uniq-cons-table*)
            (gethash (setf ux (unique x)) *uniq-cons-table*)
            (setf (gethash ux *uniq-cons-table*)
                (make-hash-table :test #'eq)))))
      (or (gethash y car-table)
        (gethash (setf uy (unique y)) car-table)
        (setf (gethash uy car-table)
            (cons ux uy))))))
```

Еще одним преимуществом `unique` является то, что она помогает при индексации.
Если списки уникальны, то они могут храниться в хэш-таблице `eq` вместо `equal` хэш-таблице.
Это может привести к значительной экономии при больших размерах списков.
Хеш-таблица `eq` для списков почти так же хороша, как список свойств для символов.

### Избегайте Consing: Множественные Значения

Параметры и несколько значений также можно использовать для передачи значений, а не для создания списков.
Например, вместо:

```lisp
(defstruct point "A point in 3-D cartesian space." x y z)
(defun scale-point (k  pt)
  "Multiply a point by a constant, K."
  (make-point :x (* k (point-x pt))
                  :y (* k (point-y pt))
                  :z (* k (point-z pt))))
```

можно использовать следующий подход, который не генерирует структуры:

```lisp
(defun scale-point (k x y z)
  "Multiply the point (x,y,z) by a constant, K."
  (values (* k x) (* k y) (* k z)))
```

### Избегайте Consing: ресурсы

Иногда имеет смысл явно управлять хранением экземпляров некоторого типа данных.
Пул этих экземпляров можно назвать *resource*.
Явное управление ресурсом целесообразно, когда: (1) экземпляры создаются часто и нужны только временно; (2) легко(или просто возможно) убедиться, когда экземпляры больше не нужны; и (3) экземпляры представляют собой довольно большие структуры или для их инициализации требуется много времени, поэтому стоит использовать их повторно вместо создания новых.
Условие (2) является ключевым: если вы освободите экземпляр, который все еще используется, этот экземпляр будет таинственным образом изменен, когда он будет перераспределен.
И наоборот, если вам не удается освободить ненужные экземпляры, вы тратите ценное пространство памяти.
(В этом случае считается, что схема управления памятью дает утечку.)

Прелесть использования встроенного в Lisp управления памятью заключается в том, что в нем никогда не будет утечки и никогда не освободит используемые структуры.
Это устраняет два потенциальных источника ошибок.
Штраф, который вы платите за эту гарантию, заключается в некоторой неэффективности общего управления памятью по сравнению с настраиваемой схемой управления, предоставляемой пользователем.
Но будьте осторожны: современные методы сборки мусора сильно оптимизированы.
В частности, так называемые *сборщики мусора* *generation scavenging* или *ephemeral* чаще обращаются к недавно выделенному хранилищу на том основании, что недавно созданные объекты с большей вероятностью станут мусором.
Если вы храните мусор в своих собственных структурах данных, производительность может снизиться.

Имея в виду все эти предупреждения, вот код для управления ресурсами:

```lisp
(defmacro defresource (name &key constructor (initial-copies 0)
                       (size (max initial-copies 10)))
  (let ((resource (symbol '* (symbol name '-resource*)))
        (deallocate (symbol 'deallocate- name))
        (allocate (symbol 'allocate- name)))
    `(progn
       (defparameter ,resource (make-array ,size :fill-pointer 0))
       (defun ,allocate ()
         "Get an element from the resource pool, or make one."
         (if (= (fill-pointer ,resource) 0)
             ,constructor
             (vector-pop ,resource)))
       (defun ,deallocate (,name)
         "Place a no-longer-needed element back in the pool."
         (vector-push-extend ,name ,resource))
       ,(if (> initial-copies 0)
            `(mapc #',deallocate (loop repeat ,initial-copies
                                       collect (,allocate))))
       ',name)))
```

Допустим, у нас есть некоторая структура, называемая буфером, которую мы постоянно создавали, а затем отбрасывали.
Более того, предположим, что буферы - это довольно сложные объекты для создания, что мы знаем, что нам понадобится по крайней мере 10 из них за раз, и что нам, вероятно, никогда не понадобится больше 100 за раз.
Мы можем использовать буферный ресурс следующим образом:

```lisp
(defresource buffer :constructor (make-buffer)
            :size 100 : initial-copies 10)
```

Это расширяется до следующего кода:

```lisp
(let ((buffer-resource (make-array 100 :fill-pointer 0)))
  (defun allocate-buffer ()
    "Get an element from the resource pool, or make one."
    (if (= (fill-pointer buffer-resource) 0)
      (make-buffer)
      (vector-pop buffer-resource)))
  (defun deallocate-buffer (buffer)
    "Place a no-longer-needed element back in the pool."
    (vector-push-extend buffer buffer-resource))
  (mapc #'deallocate-buffer
        (loop repeat 10 collect (allocate-buffer)))
  'buffer)
```

Затем мы могли бы использовать:

```lisp
(let ((b (allocate-buffer)))
  ...
  (process b)
  ...
  (deallocate-buffer b)))
```

Важно помнить, что это работает, только если буфер `b` действительно может быть освобожден.
Если функция `process` где-то хранит указатель на `b`, то было бы ошибкой освобождать `b`, потому что последующее выделение может непредсказуемо изменить сохраненный буфер.
Конечно, если процесс сохранил *копию* `b`, то все в порядке.
Этот шаблон распределения и освобождения настолько распространен, что мы можем предоставить для него макрос:

```lisp
defmacro with-resource ((var resource &optional protect) &rest body)
  "Execute body with VAR bound to an instance of RESOURCE."
  (let ((allocate (symbol 'allocate- resource))
        (deallocate (symbol 'deallocate- resource)))
    (if protect
        `(let ((,var nil))
           (unwind-protect (progn (setf ,var (,allocate)) ,@body)
             (unless (null ,var) (,deallocate ,var))))
        `(let ((,var (,allocate)))
           ,@body
           (,deallocate var)))))
```

Макрос позволяет использовать необязательный аргумент, который устанавливает среду защиты `unwind`-protect, так что буфер освобождается даже при аварийном выходе из тела.
Следующие расширения должны прояснить это:

```lisp
>(macroexpand '(with-resource (b buffer)
                "..." (process b) "..."))
(let ((b (allocate-buffer)))
  "..."
  (process b)
  "..."
  (deallocate-buffer b))
> (macroexpand '(with-resource (b buffer t)
                "..." "..." (process b) "..."))
(let ((b nil))
  (unwind-protect
      (progn (setf b (allocate-buffer))
          "..."
                (process b)
                "...")
            (unless (null b)
            (deallocate-buffer b))))
```

Альтернативой полным ресурсам является сохранение одного объекта данных.
Такой подход проще, потому что нет необходимости индексировать вектор объектов, но его достаточно для некоторых приложений, таких как хвостовой рекурсивный вызов функции, которая использует только один объект за раз.

Другая возможность - сделать систему медленнее, но безопаснее, заставив функцию `deallocate` проверять, действительно ли ее аргумент является объектом правильного типа.

Имейте в виду, что использование ресурсов может поставить вас в противоречие со схемой управления хранилищем системы Lisp.
В частности, вы должны быть обеспокоены производительностью подкачки в системах виртуальной памяти.
Распространенная проблема - иметь только несколько живых объектов на каждой странице, что заставляет систему выполнять много страниц для выполнения любой работы.
Компактные сборщики мусора могут собирать живые объекты на одной странице, но использование ресурсов может этому помешать.

## 10.5 Используйте правильные структуры данных

Важно реализовать ключевые типы данных с наиболее эффективной реализацией.
Это может варьироваться от машины к машине, но есть несколько универсальных методов.
Здесь мы рассматриваем три тематических исследования.

### Правильная структура данных: переменные

В качестве примера рассмотрим реализацию переменных сопоставления с образцом.
Мы видели из инструментария `simplify`, что `variable-p` была одной из наиболее часто используемых функций.
При компиляции соответствующих выражений я отказался от всех вызовов `variable-p`, но предположим, что у нас есть приложение, которое требует использования переменных во время выполнения.
Спецификация типа данных `variable` будет включать два оператора, распознаватель `variable-p` и конструктор `make-variable`, который дает новую, ранее не использовавшуюся переменную.
(Это не было необходимо в схемах сопоставления, показанных до сих пор, но потребуется для унификации(объединения) с обратной цепочкой.) Одна реализация переменных - это символы, начинающиеся со знака #\?:

```lisp
(defun variable-p (x)
  "Is x a variable (a symbol beginning with '?')?"
  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))
(defun make-variable O "Generate a new variable" (gentemp "?"))
```

Мы могли бы попытаться ускорить процесс, изменив реализацию переменных как ключевых слов и сделав функции встраиваемыми(inline):

```lisp
(proclaim '(inline variable-p make-variable))
(defun variable-p (x) "Is x a variable?" (keywordp x))
(defun make-variable O (gentemp "X" #.(find-package "KEYWORD")))
```

(Последовательность символьных знаков функции чтения ввода(reader) #.
означает вычислить во время чтения, а не во время выполнения.) На моей машине эта реализация выполняется довольно быстро, и я принял ее как жизнеспособный компромис.
Однако были рассмотрены и другие реализации.
Одна заключался в том, чтобы иметь переменные как структуры и предоставлять макрос чтения и функцию печати:

```lisp
(defstruct (variable (:print-function print-variable)) name)
(defvar *vars* (make-hash-table))
(set-macro-character #\?
  #'(lambda (stream char)
      ;; Find an old var, or make a new one with the given name
      (declare (ignore char))
      (let ((name (read stream t nil t)))
        (or (gethash name *vars*)
          (setf (gethash name *vars*) (make-variable :name name))))))
(defun print-variable (var stream depth)
  (declare (ignore depth))
  (format stream "?~a" (var-name var)))
```

Оказалось, что на всех трех протестированных Лиспах структуры были медленнее, чем ключевые слова или символы.
Другая альтернатива - иметь ? макрос чтения возвращающий cons(пару), первым элементом в которой является, скажем, `:var`.
Для этого требуется специальная процедура вывода, чтобы преобразовать обратно в обозначение ? .
Еще одна альтернатива, которая оказалась самой быстрой из всех, заключалась в реализации переменных как отрицательных целых чисел.
Конечно, это означает, что пользователь не может использовать отрицательные целые числа где-либо еще в образцах, но это оказалось приемлемым для данного приложения.
Мораль заключается в том, чтобы знать, какие функции хорошо реализованы в вашей конкретной реализации, и стараться изо всех сил использовать их в критических ситуациях, но придерживаться наиболее простой реализации в некритических разделах.

Lisp позволяет легко полагаться на списки, но следует избегать соблазна злоупотреблять списками; использовать их там, где более уместна другая структура данных.
Например, если вам нужно получить доступ к элементам последовательности в произвольном порядке, то вектор более уместен, чем список.
Если последовательность может расти, используйте регулируемый вектор(adjustable vector).
Рассмотрим проблему сохранения информации о группе(множестве) людей и поиск этой группы.
Наивная реализация может выглядеть так:

```lisp
(defvar *people* nil "Will hold a list of people")
(defstruct person name address id-number)
(defun person-with-id (id)
  (find id *people* :key #'person-id-number))
```

В традиционном языке, таком как C, естественным решением является включение в структуру человека(person) указателя на следующего человека и создание цикла для отслеживания этих указателей.
Конечно, мы можем сделать это и в Лиспе:

```lisp
(defstruct person name address id-number next)
(defun person-with-id (id)
  (loop for person = *people* then (person-next person)
      until (null person)
      do (when (eql id (person-id-number person))
          (RETURN person))))
```

Это решение занимает меньше места и, вероятно, работает быстрее, поскольку требует меньшего количества обращений к памяти: по одному для каждого человека, а не по одному для каждого человека плюс один для каждой cons-ячейки.
Так что за использование списков приходится платить небольшую цену.
Но программисты на Лиспе считают, что цена того стоит из-за удобства и простоты кодирования и отладки, обеспечиваемых функциями общего назначения, такими как `find`.

В любом случае, если будет много людей, список определенно неправильная структура данных.
К счастью, Lisp позволяет легко переключиться на более эффективные структуры данных, например:

```lisp
(defun person-with-id (id)
  (gethash id *people*))
```

### Правильная структура данных: очереди

Очередь(*queue*) - это структура данных, в которую можно добавлять элементы сзади и удалять их спереди.
Это почти как стек, за исключением того, что в стеке элементы добавляются и удаляются с одного конца.

Списки можно использовать для реализации стеков, но существует проблема с использованием списков для реализации очередей: добавление элемента в конец требует обхода всего списка.
Таким образом, сбор *n* элементов будет *O*(*n2*) вместо *O*(*n*).

Альтернативная реализация очередей - это cons(пара) двух указателей: один на список элементов очереди (содержимое) и один на последнюю cons-ячейку в списке.
Первоначально оба указателя были бы nil.
Эта реализация фактически существовала в BBN Lisp и UCI Lisp под именем функции `tconc`:

```lisp
;;; A queue is a (contents . last) pair
(defun tconc (item q)
  "Insert item at the end of the queue."
  (setf (cdr q)
      (if (null (cdr q))
          (setf (car q) (cons item nil))
          (setf (rest (cdr q))
              (cons item nil)))))
```

Реализация `tconc` имеет тот недостаток, что добавление первого элемента к содержимому отличается от добавления последующих элементов, поэтому для решения, какое действие следует предпринять, требуется оператор `if`.
Приведенное ниже определение очередей позволяет избежать этого недостатка хитрым приемом.
Во-первых, порядок двух полей меняется на обратный(reversed).
`car` cons-ячейки - это последний элемент, а `cdr` - это содержимое.
Во-вторых, пустая очередь - это cons-ячейка, где `cdr` (поле содержимого) равно nil, а `car` (указывающий на последнее поле) - это сама cons-ячейка(указывает на себя).
В определениях ниже мы меняем имя `tconc` на более стандартное `enqueue`, а также предоставляем другие функции очереди:

```lisp
;;; A queue is a (last . contents) pair
(proclaim '(inline queue-contents make-queue enqueue dequeue
                front empty-queue-p queue-nconc))

(defun queue-contents (q) (cdr q))

(defun make-queue ()
  "Build a new queue, with no elements."
  (let ((q (cons nil nil)))
    (setf (car q) q)))

(defun enqueue (item q)
  "Insert item at the end of the queue."
  (setf (car q)
        (setf (rest (car q))
              (cons item nil)))
  q)

(defun dequeue (q)
  "Remove an item from the front of the queue."
  (pop (cdr q))
  (if (null (cdr q)) (setf (car q) q))
  q)

(defun front (q) (first (queue-contents q)))

(defun empty-queue-p (q) (null (queue-contents q)))

(defun queue-nconc (q list)
  "Add the elements of LIST to the end of the queue."
  (setf (car q)
        (last (setf (rest (car q)) list))))
```

### Правильная структура данных: таблицы

*Таблица*(table) - это структура данных, в которую можно вставить ключ и связать его со значением, а затем использовать ключ для поиска значения.
Таблицы могут выполнять другие операции, такие как подсчет количества ключей, очистка всех ключей или отображение функции для каждой пары ключ/значение.

Lisp предоставляет широкий выбор вариантов реализации таблиц.
Список ассоциаций, пожалуй, самый простой: это просто список пар ключ/значение(alists).
Подходит для небольших таблиц, до нескольких десятков пар.
Хеш-таблица разработана так, чтобы быть эффективной для больших таблиц, но может иметь значительные накладные расходы для маленьких.
Если ключи являются символами, можно использовать списки свойств(plists).
Если ключи являются целыми числами в узком диапазоне (или могут быть отображены в них), тогда вектор может быть наиболее эффективным выбором.

Здесь мы реализуем альтернативную структуру данных, *trie*.
trie реализует таблицу ключей, состоящую из конечной последовательности компонентов.
Например, если бы мы реализовали словарь как trie, каждый ключ был бы словом, а каждая буква слова была бы компонентом.
Значение ключа будет определением слова.
Вверху словаря trie находится сильноветвящаяся(multiway) ветвь, по одному пути для каждой возможной первой буквы.
У каждого узла второго уровня есть ветвь для каждой возможной второй буквы и так далее.
Чтобы найти *n* -буквенное слово, требуется *n* операций чтения.
Такая организация особенно хороша, когда информация хранится во вторичном хранилище, потому что одно чтение может привести к узлу со всеми его возможными ветвями.

Если ключи могут быть произвольными списковыми структурами, а не простой последовательностью букв, нам нужно упорядочить ключи, преобразовав их в простую последовательность.
Один из способов сделать это использует тот факт, что любое дерево может быть записано как линейная последовательность атомов и cons-операций в префиксной форме.
Таким образом, мы бы сделали следующее преобразование:

```lisp
(a (b c) d) =
```

`(cons a (cons (cons b (cons c nil)) (cons d nil)))`=

```lisp
(cons a cons cons b cons c nil cons d nil)
```

В приведенной ниже реализации tries это преобразование выполняется на лету: четыре функции пользовательского уровня: `make-trie` для создания нового дерева, `put-trie` и `get-trie` для добавления и извлечения пары ключ/значение и `delete-trie` для их удаления.

Обратите внимание, что мы используем выделенное значение для пометки удаленных элементов, и что `get-trie` возвращает два значения: фактическое найденное значение и флаг, сообщающий, было что-то найдено или нет.
Это согласуется с интерфейсом `gethash` и `find` и позволяет нам сохранять значения nil в trie.
Это ненавязчивый выбор, потому что программист, решивший не хранить значения nil, может просто проигнорировать второе значение, и все будет работать правильно.

```lisp
(defstruct trie (value nil) (arcs nil))
(defconstant trie-deleted "deleted")
(defun put-trie (key trie value)
  "Set the value of key in trie."
  (setf (trie-value (find-trie key t trie)) value))
(defun get-trie (key trie)
  "Return the value for a key in a trie, and t/nil if found."
  (let* ((key-trie (find-trie key nil trie))
        (val (if key-trie (trie-value key-trie))))
    (if (or (null key-trie) (eq  val trie-deleted))
        (values nil nil )
        (values val t))))
(defun delete-trie (key trie)
  "Remove a key from a trie."
  (put-trie key trie trie-deleted))
```

`(defun find-trie (key extend?
trie)`

```lisp
  "Find the trie node for this key.
```

`  If EXTEND?
is true, make a new node if need be."`

```lisp
  (cond ((null trie) nil )
        ((atom key)
```

`          (follow-arc key extend?
trie))`

```lisp
        (t (find-trie
              (cdr key) extend?
              (find-trie
                (car key) extend?
              (find-trie
```

`                "." extend?
trie))))))`

`(defun follow-arc (component extend?
trie)`

```lisp
  "Find the trie node for this component of the key.
```

`  If EXTEND?
is true, make a new node if need be."`

```lisp
  (let ((arc (assoc component (trie-arcs trie))))
    (cond ((not (null arc)) (cdr arc))
          ((not extend?) nil)
          (t (let ((new-trie (make-trie)))
              (push (cons component new-trie)
                  (trie-arcs trie))
              new-trie)))))
```

В реализации есть несколько тонкостей.
Сначала мы проверяем удаленные записи с помощью сравнения `eq` с выделенным маркером, строкой `trie-deleted`.
Никакой другой объект не будет `eq` к этой строке, кроме самого `trie-deleted`, так что это хороший тест.
Мы также используем особый маркер - строку "." чтобы отметить cons-ячейки.
Компоненты неявно сравниваются с этим маркером с помощью теста `eql` с помощью команды `associn follow-arc`.
Сохранение идентичности этой строки имеет решающее значение; если, например, вы перекомпилировали определение `find-trie` (без изменения определения вообще), то вы больше не могли бы найти ключи, которые были проиндексированы в существующем дереве, потому что строка "." используемая `find-trie` будет отличаться от "." в существующем дереве.

В *Программирование искусственного интеллекта* ([Charniak et al.
1987](B9780080571157500285.xhtml#bb0180)) обсуждаются варианты trie, в частности, в схеме индексирования.
Если мы всегда используем правильные списки (без не-null `cdrs`), тогда возможно более эффективное кодирование.
Как обычно, лучший тип индексирования зависит от индексируемых данных.
Следует отметить, что Charniak et al. именует trie как *сетью дискриминации(распознавания?)*(discrimination net).
В общем, этот термин относится к любому дереву с тестами в узлах.

Trie - это, конечно, разновидность дерева, но в некоторых случаях полезно преобразовать trie в ориентированный ациклический граф *dag*(directed acyclic graph).
dag - это дерево, в котором некоторые поддеревья являются общими(разделяемыми).
Представьте, что у вас есть программа коррекции орфографии со списком примерно из 50 000 слов.
Вы можете поместить их в дерево, каждое слово со значением t.
Но в этом дереве будет повторяться много поддеревьев.
Например, для списка слов, содержащего *look*, *looks*, *looked* и *looking*, а также *show*, *shows*, *showed* и *showing*, будет повторение поддерева, содержащго -s, -*ed* и -*ing*.
После того, как дерево построено, мы могли бы передать все дерево в unique, и она свернула бы общие поддеревья, сохранив память.
Конечно, вы больше не сможете добавлять или удалять ключи из dag без риска непредвиденных побочных эффектов.

Этот процесс проводился для списка из 56 000 слов.
Дерево занимало 3,2 Мбайта, а размер тега - 1.1 Mбайт.
Это все еще считалось неприемлемым, поэтому было создано более компактное кодирование dag с использованием вектора размером 0,2 МБ.
Кодирование одного и того же списка слов в хеш-таблице занимало вдвое больше места, даже при использовании специального формата для кодирования суффиксов.

Tries работают лучше всего, когда ни ключ индексации, ни ключ извлечения не содержат переменных.
Они работают достаточно хорошо, когда переменные находятся ближе к концу последовательности.
Попробуйте поискать образец `"yello?"` в словаре, где "?" символный знак обозначающий совпадение любой буквы.
Следование веткам для `"yello"` быстро приводит к единственно возможному совпадению `"yellow"`.
Напротив, выборка с образецом `"??llow» намного менее эффективна.
Функция поиска в таблице должна будет искать во всех 26 ветвях верхнего уровня, и для каждой из них рассматривать все возможные вторые буквы, а для каждого из них рассмотреть путь `"llow"`.
Прежде чем прийти к полному набору совпадений, требуется немало поисков: bellow, billow, fallow, fellow, follow, hallow, hollow, mallow, mellow, pillow, sallow, tallow, wallow, willow и yellow

Мы вернемся к проблеме селективных сетей с переменными в [раздел 14.8](B9780080571157500145.xhtml#s0040), [страница 472](B9780080571157500145.xhtml#p472).

## 10.6 Упражнения

**Exercise  10.1 [h]** Define the macro `deftable,` such that `(deftable person assoc`) will act much like a `defstruct-`it will define a set of functions for manipulating a table of people: `get-person, put-person, clear-person,` and `map-person.` The table should be implemented as an association list.
Later on, you can change the representation of the table simply by changing the form to (`deftable person hash` ), without having to change anything else in your code.
Other implementation options include property lists and vectors.
`deftable` should also take three keyword arguments: `inline`, `size` and `test`.
Here is a possible macroexpansion:

`>(macroexpand '(deftableperson hash :-inline t :size 100))`=

```lisp
  (progn
  (proclaim '(inline get-person put-person map-person))
  (defparameter *person-table*
    (make-hash-table :test #eql :size 100))
  (defun get-person (x &optional default)
    (gethash x *person-table* default))
  (defun put-person (x value)
    (setf (gethash x *person-table*) value))
  (defun clear-person () (clrhash *person-table*))
  (defun map-person (fn) (maphash fn *person-table*))
  (defsetf get-person put-person)
  'person)
```

**Exercise  10.2 [m]** We can use the :`type` option to `defstruct` to define structures implemented as lists.
However, often we have a two-field structure that we would like to implement as a cons cell rather than a two-element list, thereby cutting storage in half.
Since `defstruct` does not allow this, define a new macro that does.

**Exercise  10.3 [m]** Use `reuse - cons` to write a version of `flatten` (see [page 329](B9780080571157500108.xhtml#p329)) that shares as much of its input with its output as possible.

**Exercise  10.4 [h]** Consider the data type *set*.
A set has two main operations: adjoin an element and test for membership.
It is convenient to also add a map-over-elements operation.
With these primitive operations it is possible to build up more complex operations like union and intersection.

As mentioned in [section 3.9](B9780080571157500030.xhtml#s0095), Common Lisp provides several implementations of sets.
The simplest uses lists as the underlying representation, and provides the functions `adjoin, member, union, intersection`, and `set-difference`.
Another uses bit vectors, and a similar one uses integers viewed as bit sequences.
Analyze the time complexity of each implementation for each operation.

Next, show how *sorted lists* can be used to implement sets, and compare the operations on sorted lists to their counterparts on unsorted lists.

## 10.7 Ответы

**Answer 10.2**

```lisp
(defmacro def-cons-struct (cons car cdr &optional inline?)
  "Define aliases for cons, car and cdr."
```

`  '(progn (proclaim '(,(if inline?
'inline 'notinline)`

```lisp
                  ,car ,cdr ,cons))
          (defun ,car (x) (car x))
          (defun ,cdr (x) (cdr x))
          (defsetf ,car (x) (val) '(setf (car ,x) ,val))
          (defsetf ,cdr (x) (val) '(setf (cdr ,x) ,val))
          (defun ,cons (x y) (cons x y))))
```

**Answer 10.3**

```lisp
(defun flatten (exp &optional (so-far nil) last-cons)
  "Return a flat list of the atoms in the input.
  Ex: (flatten '((a) (b (c) d))) => (a b c d)."
  (cond ((null exp) so-far)
        ((atom exp) (reuse-cons exp so-far last-cons))
        (t (flatten (first exp)
                  (flatten (rest exp) so-far exp)
                  exp))))
```

----------------------

[1](#xfn0015) These are all done with safety 0 and speed 3.
!!!(p) {:.ftnote1}