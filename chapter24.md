# Глава 24
## ANSI Common Lisp

В этой главе кратко рассматриваются некоторые расширенные возможности Common Lisp, которые не использовались в остальной части книги.
Первая тема, пакеты, имеет решающее значение при построении больших систем, но не рассматривалась в этой книге, поскольку программы краткие.
Следующие четыре темы - обработка ошибок, красивая печать(pretty printing), ряды(series) и макрос цикла(loop) - рассматриваются в *Common Lisp the Language,* 2d edition, но не в первом издании книги.
Таким образом, они могут быть неприменимы к вашему компилятору Lisp.
Последняя тема, функции работы с последовательностями, показывает, как писать эффективные функции, которые работают как со списками, так и с векторами.

## 24.1 Пакеты(Packages)

*package*(пакет) - это таблица символов, которая отображает строки в символы, именуемые этими строками.
Когда read сталкивается с последовательностью символьных знаков вроде `list`, она использует таблицу символьных знаков, чтобы определить, что они относится к символу `list`.
Важным моментом является то, что каждое использование имени символа `list` относится к одному и тому же символу.
Это упрощает обращение к предопределенным символам, но также упрощает внесение непреднамеренных конфликтов имен.
Например, если бы я хотел подключить экспертную систему emycin из [главы 16](B9780080571157500169.xhtml) с парсером из [главы 19](B9780080571157500194.xhtml), возник бы конфликт, потому что обе программы использовали символ `defrule` означающий в них разные вещи.

Common Lisp использует систему пакетов, чтобы помочь разрешить такие конфликты.
Вместо единой таблицы символов Common Lisp допускает любое количество пакетов.
Функция `read` всегда использует текущий пакет, который определяется как значение специальной переменной `*package*`.
По умолчанию Lisp запускается в пакете `common-lisp-user`. [1](# fn0010) Это означает, что если мы введем новый символ, например, `zxv!!!(char) Â®!? + Qw` , он будет включен в этот пакет.
Преобразование строки в символ и размещение ее в пакете называется *интернированием(interning)*. Это делается автоматически с помощью `read` и может быть выполнено с помощью функции `intern`, если необходимо.
Конфликты имен возникают, когда существует конкуренция за имена внутри пакета `common-lisp-user`.

Чтобы избежать конфликтов имен, просто создайте новые символы в другом пакете, специфичном для вашей программы.
Самый простой способ реализовать это - разделить каждую систему как минимум на два файла: один для определения пакета системы, а другие - для самой системы.
Например, система `emycin` должна начинаться с файла, который определяет пакет `emycin`.
Следующая форма определяет пакет `emycin` использующий пакет `lisp`.
Это означает, что когда текущим будет пакет - `emycin`, вы все равно сможете ссылаться на все встроенные символы Лиспа.

```lisp
(make-package "EMYCIN" :use '("LISP"))
```

Файл, содержащий определение пакета, всегда должен загружаться раньше, чем остальная часть системы.
Такие файлы должны начинаться со следующего вызова, который гарантирует, что все новые символы будут интернированы в пакет `emycin`:

```lisp
(in-package "EMYCIN")
```

Пакеты используются для сокрытия информации, а также для предотвращения конфликтов имен.
Различают *внутренние(internal)* и *внешние(external)* символы.
Внешние символы - это те, на которые пользователь системы мог бы ссылаться, а внутренние символы - это те, которые помогают реализовать систему, но не нужны пользователю системы.
Символ `rule`, вероятно, будет внутренним как для пакета `emycin`, так и `parser`, но `defrule` будет внешним, потому что пользователь системы `emycin` использует `defrule` для определения новых правил.
Разработчик системы отвечает за публикацию объявления, символов которые являются внешними.
Правильный вызов:

```lisp
(export '(emycin defrule defcontext defparm yes/no yes no is))
```

Во-вторых, пользователь может сделать `emycin` текущим пакетом с помощью `(in-package "EMYCIN").` Тогда, конечно, нам понадобится только набрать `defrule`.
В-третьих, если нам нужна только часть функциональных возможностей системы, мы можем импортировать определенные символы в текущий пакет.
Например, мы могли бы вызвать `(import 'emycin:defrule)`.
С этого момента ввод `defrule` (в текущем пакете) будет ссылаться на `emycin:defrule`.
В-четвертых, если мы хотим получить полную функциональность системы, мы вызываем `(use-package "EMYCIN")`.
Это делает все внешние символы пакета emycin доступными в текущем пакете.

В то время как пакеты помогают устранить конфликты имен, `import` и `use-package` позволяют им снова появляться.
Преимущество в том, что конфликты будут только между внешними символами.
Поскольку в тщательно разработанном пакете должно быть гораздо меньше внешних символов, чем внутренних, проблема, по крайней мере, будет уменьшена.
Но если у двух пакетов есть внешний символ `defrule`, то мы не сможем выполнить `use-package` для обоих этих пакетов или `import`(импортировать) оба символа, не создавая конфликта имен.
Такие конфликты будут разрешены путем *затенения* одного или другого символа; подробнее см. *Common Lisp the Language*.

Внимательного читателя может сбить с толку различие между `"EMYCIN"` и `emycin`.
В *Common Lisp the Language* не было ясно, каким должен быть аргумент для функций пакета(package).
Таким образом, некоторые реализации сигнализируют об ошибке, когда задается символ, печатаемое имя которого является пакетом.
В ANSI Common Lisp все функции пакета определены как принимающие либо пакет, либо имя пакета (строка), либо символ, чье печатное имя является именем пакета.
Кроме того, ANSI Common Lisp добавляет удобный макрос `defpackage`.
Его можно использовать как замену отдельным вызовам `make-package`, `use-package`, `import` и `export`.
Также обратите внимание, что ANSI переименовывает `lisp package` в `common-lisp`.

```lisp
(defpackage emycin
```

  `(:use common-lisp)`

  `(:export emycin defrule defcontext defparm yes/no yes no is))`

Для получения дополнительных сведений о пакетах и системах сборки см. [Раздел 25.16](B978008057115750025X.xhtml#s0110) или *Common Lisp the Language.*

### Семь пространств имен

Один важный факт, который следует помнить о пакетах, заключается в том, что они имеют дело с символами и только косвенно имеют дело с использованием этих символов.
Например, вы можете думать о `(export 'parse)` как об экспорте функции `parse`, но на самом деле это экспорт символа `parse`, с которым может быть связано определение функции.
Однако, если символ используется для другого использования - например, в качестве переменной или типа данных - тогда это использование также становится доступным с помощью оператора `export`.

Common Lisp имеет как минимум семь пространств имен.
Два, о которых мы думаем чаще всего, - это (1) для функций и макросов и (2) для переменных.
Мы видели, что Scheme объединяет эти два пространства имен, но Common Lisp хранит их отдельно, так что в применении функции, таком как `(f)`, пространство имен функции/макроса запрашивается для значения `f`, но в `( + f)`, f рассматривается как имя переменной.
Те, кто понимает правила области видимости(scope) и протяженности(extent) Common Lisp, знают, что (3) специальные переменные образуют отдельное пространство имен из лексических переменных.
Таким образом, `f` в `(+ f)` обрабатывается либо как специальная, либо как лексическая переменная, в зависимости от того, есть ли применимое объявление `special`.
Также существует пространство имен (4) для типов данных.
Даже если `f` определен как функция и/или переменная, он также может быть определен как тип данных с помощью `defstruct`,  `deftype` или `defclass`.
Его также можно определить как (5) метку для операторов `go` c `tagbody` или (6) имени блока для операторов `return-from` внутри `block`.
Наконец, символы внутри выражения в кавычках рассматриваются как константы и, это пространство имен формы(7).
Эти символы часто используются в качестве ключей в пользовательских таблицах, и в некотором смысле каждая такая таблица определяет новое пространство имен.
Одним из примеров является пространство имен *tag*, используемое `catch` и `throw`.
Другой - это пространство имен пакетов.

Рекомендуется ограничить каждый символ только одним пространством имен.
Common Lisp не запутается, если символ используется по-разному, но человеку читать плохо, и вероятно он, запутается.

В следующем примере мы покажем использование символа `f`, сможете ли вы определить, какое из двенадцати использований `f` относится к каким пространствам имен?

```lisp
(defun f (f)
```

  `(block f`

    `(tagbody`

      `f (catch 'f`

        `(if (typep f 'f)`

          `(throw 'f (go f)))`

        `(funcall #'f (get (symbol-value 'f) 'f))))))`

## 24.2 Условия и обработка ошибок

Необычной особенностью ANSI Common Lisp является возможность обработки ошибок.
В большинстве языков программисту очень сложно исправить ошибку.
Хотя Ada и некоторые реализации C предоставляют функции для исправления ошибок, они обычно не входят в репертуар большинства программистов.
Таким образом, мы находим программы на C, которые завершаются с некорректным сообщением `Нарушение сегментации(Segmentation violation): core dumped`.

Common Lisp предоставляет один из наиболее полных и простых в использовании механизмов обработки ошибок среди всех языков программирования, что позволяет создавать более надежные программы.
Процесс обработки ошибок разделен на две части: сообщение об ошибке и ее обработка.

### Сигнализация об ошибках

*Ошибка* - это состояние, с которым программа не умеет справиться(не знает как обрабатывать).
Поскольку программа не знает, что делать, ее единственный выход - объявить о возникновении ошибки в надежде, что какая-то другая программа или пользователь будут знать, что делать.
Это сообщение называется *сигнализацией* об ошибке.
Об ошибке может сигнализировать встроенная функция Common Lisp, например, когда `(/ 3 0)` сигнализирует об ошибке деления на ноль.
Программист также может явно сигнализировать об ошибках, например, при вызове `(error "Illegal value.")`.

На самом деле, это некоторое упрощение, говорить только о *сигнализации о ошибках*. Точный термин - *сигнализация об условиях*. Некоторые условия, такие как конец файла, не считаются ошибками, но, тем не менее, они являются необычными условиями, с которыми нужно иметь дело.
Система условий в Common Lisp позволяет определять все виды условий, но мы продолжим говорить об ошибках в этом кратком обсуждении, поскольку большинство условий на самом деле являются ошибками.

### Обработка Ошибок

По умолчанию при сигнализации об ошибке запускается отладчик.
В следующем примере приглашение >> означает, что пользователь находится в отладчике, а не на верхнем уровне.

```lisp
> (/ 3 0)
Error: An attempt was made to divide by zero.
>>
```

ANSI Common Lisp предоставляет способы изменить это поведение по умолчанию.
По идее, это делается путем настройки *обработчика ошибок*, который каким-то образом обрабатывает ошибку.
Обработчики ошибок связываются динамически и используются для обработки сообщений об ошибках.
Обработчик ошибок очень похож на `catch`, а сигнализация об ошибке похожа на `throw`.
Фактически, во многих системах `catch` и` throw` реализованы с помощью системы условий обнаружения ошибок.

Самый простой способ справиться с ошибкой(обработать её) - использовать макрос `ignore-errors`.
Если ошибки не возникает, `ignore-errors` аналогичен `progn`.
Но если ошибка все-таки возникает, `ignore-errors` вернет `nil` в качестве первого значения и t в качестве второго, чтобы указать, что произошла ошибка, но без каких-либо дополнительных действий:

`> (ignore-errors (/ 3 1))`=> `3 NIL`

`> (ignore-errors (/ 3 0))`=> `NIL T`

`ignore-errors` - это очень грубый инструмент.
В интерактивном интерпретаторе `ignore-errors` может использоваться для исправления любых ошибок в ответе на один ввод и возврата к циклу чтение-процесс-печать для следующего ввода.
Если ошибки, которые игнорируются, не являются серьезными, это может быть очень эффективным способом превратить программу с ошибками в нечто полезное.

Но некоторые ошибки слишком важны, чтобы их игнорировать.
Если ошибка запущена нехваткой памяти, то ее игнорирование не поможет.
Вместо этого нам нужно найти способ освободить память и продолжить.

Система обработки условий может использоваться для обработки только определенных ошибок.
Макрос `handler-case` - удобный способ сделать это.
Как и `case`, его первый аргумент вычисляется и используется для определения того, что делать дальше.
Если об ошибке не сообщается, возвращается значение выражения.
Но если ошибка все же возникает, в следующих предложениях выполняется поиск того, который соответствует типу ошибки.
В следующем примере `handler-case` используется для обработки деления на ноль и других арифметических ошибок (возможно, потери значимости числа с плавающей запятой), но он позволяет всем другим ошибкам проходить без обработки.

```lisp
(defun div (x y)
```

  `(handler-case (/ x y)`

    `(division-by-zero () most-positive-fixnum)`

    `(arithmetic-error () 0)))`

`> (div 8 2)`=> `4`

`> (div 3 0)`=> `16777215`

```lisp
> (div 'xyzzy 1)
Error: The value of NUMBER, XYZZY, should be a number
```

За счет разумного использования `handler-case` программист может создать надежный код, который хорошо реагирует на неожиданные ситуации.
Для получения дополнительных сведений см. Главу 29 книги *Common Lisp the Language,* 2d редакции

## 24.3 Красивая Печать

ANSI Common Lisp добавляет средство для удобной печати, управляемой пользователем.
В общем, *pretty printing*(красивая печать) относится к процессу печати сложных выражений в формате, использующем отступы для улучшения читаемости.
Функция `pprint` была доступна всегда, но до ANSI Common Lisp она оставалась неопределенной и не могла быть расширена пользователем.
В главе 27 *Common Lisp the Language* 2d edition представлена удобная возможность печати, которая дает пользователю детальный контроль над печатью всех типов объектов.
Кроме того, эта функциональность интегрирована с функцией `format`.

## 24.4 Ряды(серии)

Функциональный стиль программирования с функциями высшего порядка - одна из привлекательных сторон Лиспа.
Следующее выражение для суммирования квадратных корней положительных чисел в списке `nums` является ясным и кратким

```lisp
(reduce #'+ (mapcar #'sqrt (find-all-if #'plusp nums)))
```

К сожалению, это неэффективно: и `find-all-if`, и `mapcar` составляют(cons) промежуточные списки, которые не нужны для окончательной суммы.
Следующие две версии с использованием `loop` и `dolist` эффективны, но не так красивы:

```lisp
;; Using Loop                      ;; Using dolist
(loop for num in nums      (let ((sum 0))
```

    `when (plusp num)                (dolist (num nums sum)`

    `sum (sqrt num))                        (when (plusp num)`

                                                                                                                        `(incf sum num))))`

Компромисс между этими двумя подходами обеспечивается функциональностью *series*(рядов), определенной в приложении A к *Common Lisp the Language*, 2d edition.
Пример использования рядов будет выглядеть так:

```lisp
(collect-sum (#Msqrt (choose-if #'plusp nums)))
```

Это очень похоже на функциональную версию: изменены только названия.
Однако он компилируется в эффективный итеративный код, очень похожий на версию `dolist`.

Как и каналы(pipes) (см. [Раздел 9.3](B9780080571157500091.xhtml#s0015)), элементы ряда вычисляются только тогда, когда они необходимы.
Таким образом, мы можем написать `(scan-range: from 0)`, чтобы указать бесконечный ряд целых чисел, начинающийся с 0, но если мы будем использовать, скажем, только первые пять элементов этого ряда, то будут сгенерированы только первые пять элементов.

Функциональность рядов предлагает удобную и эффективную альтернативу итерационным циклам и функциям работы с последовательностями.
Хотя эти предложенные ряды еще не приняты в качестве официальной части ANSI Common Lisp, ее включение в справочное руководство сделало их все более популярными.

## 24.5 Макрос Цикла(Loop)

Первоначальная спецификация Common Lisp включала простой макрос `loop`.
Тело цикла выполнялось многократно, пока не встречался `return`.
ANSI Common Lisp официально представляет гораздо более сложный макрос `loop`, который некоторое время использовался в ZetaLisp и его предшественниках.
В этой книге иногда использовался сложный `loop` вместо таких альтернатив, как `do`, `dotimes`, `dolist` и функций отображения(mapping).

Если ваш Лисп не включает в себя сложный макрос `loop`, в этой главе дается определение, которое будет запускать все примеры из этой книги, хотя оно не поддерживает все возможности `loop`.
Эта глава также служит примером сложного макроса.
Как и в случае с любым макросом, первое, что нужно сделать, это посмотреть на некоторые вызовы макросов и на то, во что они могут разворачиваться.
Вот два примера:

```lisp
(loop for i from 1 to n do (print (sqrt i))) =
(LET* ((I 1)
```

        `(TEMP N))`

  `(TAGBODY`

      `LOOP`

        `(IF (> I TEMP)`

              `(GO END))`

        `(PRINT (SQRT I))`

        `(SETF I (+ I 1))`

        `(GO LOOP)`

      `END))`

```lisp
(loop for v in list do (print v)) =
(LET* ((IN LIST)
```

        `(V (CAR IN)))`

      `(TAGBODY`

      `LOOP`

        `(IF (NULL IN)`

              `(GO END))`

        `(PRINT V)`

        `(SETF IN (CDR IN))`

        `(SETF V (CAR IN))`

        `(GO LOOP)`

      `END))`

Каждый цикл loop инициализирует некоторые переменные, затем входит в цикл с некоторыми проверками на выход и телом.
Итак, шаблон выглядит примерно так:

```lisp
(let* (*variables...*)
```

  `(tagbody`

    `loop`

      `(if *exit-tests*`

        `(go end))`

      *`Body`*

      `(go loop)`

    `end))`

Собственно, в общем случае нам может понадобиться больше.
Здесь может быть пролог, который появляется перед циклом, но после инициализации переменной, и точно так же может быть эпилог после цикла.
Этот эпилог может включать в себя возвращение значения, и поскольку мы хотим иметь возможность вернуться из цикла в любом случае, нам нужно обернуть его конструкцией `block`.
Итак, полный шаблон:

```lisp
(let* (*variables...*)
```

  `(block *name*`

    *`Prologue`*

    `(tagbody`

      `Loop`

        *`body`*

        `(go loop)`

      `end`

        *`epilogue`*

        `(return *result*))))`

Чтобы сгенерировать этот шаблон из тела формы цикла `loop`, мы будем использовать структуру с полями для каждой из частей шаблона:

```lisp
(defstruct loop
```

    `"Конструкция для удержания частей цикла во время его построения."`

    `(vars nil) (prologue nil) (body nil) (steps nil)`

    `(epilogue nil) (result nil) (name nil))`

Теперь макросу `loop` нужно сделать четыре вещи: (1) решить, будет ли это использование простого цикла `loop` без ключевых слов или сложного ANSI `loop`.
Если это последнее, то (2) создайте экземпляр структуры `loop`, (3) обработайте тело цикла, заполнив соответствующие поля структуры, и (4) поместите заполненные поля в шаблон.
Вот макрос `loop`:

```lisp
(defmacro loop (&rest exps)
```

    `"Supports both ANSI and simple LOOP.`

    `Warning: Not every loop keyword is supported."`

    `(if (every #'listp exps)`

        `;; No keywords implies simple loop:`

        `'(block nil (tagbody loop ,@exps (go loop)))`

        `;; otherwise process loop keywords:`

        `(let ((l (make-loop)))`

            `(parse-loop-body l exps)`

            `(fill-loop-template l))))`

```lisp
(defun fill-loop-template (l)
```

    `"Use a loop-structure instance to fill the template."`

    `'(let* .(nreverse (loop-vars l))`

        `(block ,(loop-name l)`

          `,@(nreverse (loop-prologue l)`

          `(tagbody`

            `loop`

                `,@(nreverse (loop-body l))`

                `,@(nreverse (loop-steps l))`

                `(go loop)`

            `end`

                `,@(nreverse (loop-epilogue l))`

                `(return ,(loop-result l))))))`

Большая часть работы заключается в написании `parse-loop-body`, которое берет список выражений и разбирает их в соответствующие поля структуры цикла.
Он будет использовать следующие вспомогательные функции:

```lisp
(defun add-body (l exp) (push exp (loop-body l)))
(defun add-test (l test)
```

    `"Put in a test for loop termination."`

    `(push '(if .test (go end)) (loop-body l)))`

```lisp
(defun add-var (l var init &optional (update nil update?))
```

    `"Add a variable, maybe including an update step."`

    `(unless (assoc var (loop-vars l))`

        `(push (list var init) (loop-vars l)))`

    `(when update?`

        `(push '(setq ,var ,update) (loop-steps l))))`

Есть несколько альтернативных способов реализации такого рода обработки.
Можно было бы использовать специальные переменные: `*prologue*, *body*, *epilogue*` и так далее.
Это означало бы, что нам не нужно было бы обходить структуру цикла `l`, но наличие семи новых специальных переменных создаст значительный беспорядок.
Другая возможность - использовать локальные переменные и закрыть определения `loop` вместе с функциями `add-` в этой локальном окружении:

```lisp
(let (body prologue epilogue steps vars name result)
```

    `(defmacro loop ...)`

    `(defun add-body ...)`

    `(defun add-test ...)`

    `(defun add-var ...))`

Это несколько более чистый стиль, но некоторые ранние компиляторы Common Lisp не поддерживают встраивание функций `defun`, поэтому я решил писать в стиле, который, как я знаю, будет работать во всех реализациях.
Другой вариант разработки - вернуть несколько значений для каждого из компонентов и собрать их все вместе с помощью `parse-loop-body`.
Фактически это сделано в одной из реализаций цикла `loop` на Лисп-машине, но я думаю, что это плохое решение: семь компонентов - это слишком много, чтобы отслеживать их с помощью позиционной записи.

### Анатомия Loop

Все это просто было настроено для реальной работы: синтаксического анализа выражений, составляющих цикл, с помощью функции `parse-loop-body`.
Каждый цикл состоит из последовательности предложений, где синтаксис каждого предложения определяется первым выражением предложения, которое должно быть известным символом.
Эти символы называются *ключевыми словами цикла*, хотя их нет в пакете ключевых слов.

Ключевые слова цикла будут определяться в стиле программирования управляемого данными.
У каждого ключевого слова есть функция в списке свойств под индикатором `loop-fn`.
Функция принимает три аргумента: строящуюся структуру `loop`, ближайшее выражение в теле цикла и список оставшихся после него выражений.
Функция отвечает за обновление структуры `loop` (обычно путем выполнения соответствующих вызовов функций `add-`), а затем за возврат неанализируемых выражений.
Соглашение о вызове с тремя аргументами используется потому, что многие ключевые слова смотрят только на еще одно выражение.
Таким образом, эти функции видят это выражение как свой первый аргумент, и они могут удобно возвращать свой второй аргумент как неанализируемый остаток.
Другие функции захотят более внимательно изучить второй аргумент, проанализировать некоторые из них и вернуть остальные.

Макрос `defloop` предназначен для добавления новых ключевых слов цикла.
Этот макрос обеспечивает соблюдение соглашения о вызовах с тремя аргументами.
Если пользователь предоставляет только два аргумента, то третий аргумент автоматически добавляется и возвращается как остаток.
Кроме того, если пользователь указывает другой символ, а не список аргументов, он воспринимается как псевдоним, и создается функция, которая вызывает функцию для этого ключевого слова:

```lisp
(defun parse-loop-body (l exps)
```

    `"Parse the exps based on the first exp being a keyword.`

    `Continue until all the exps are parsed."`

    `(unless (null exps)`

        `(parse-loop-body`

            `l (call-loop-fn l (first exps) (rest exps)))))`

```lisp
(defun call-loop-fn (l key exps)
```

    `"Return the loop parsing function for this keyword."`

    `(if (and (symbolp key) (get key 'loop-fn))`

        `(funcall (get key 'loop-fn) l (first exps) (rest exps))`

        `(error "Unknown loop key: "a" key)))`

```lisp
(defmacro defloop (key args &rest body)
```

    `"Define a new LOOP keyword."`

    `;; If the args do not have a third arg, one is supplied.`

    `;; Also, we can define an alias with (defloop key other-key)`

    `'(setf (get ',key 'loop-fn)`

        `,(cond ((and (symbolp args) (null body))`

            `'#'(lambda (1 x y)`

                    `(call-loop-fn l '.args (cons x y))))`

              `((and (listp args) (= (length args) 2))`

                `'#'(lambda (.@args -exps-) ,@body -exps-))`

              `(t '#'(lambda .args ,@body)))))`

Теперь мы готовы определить некоторые ключевые слова `loop`.
Каждый из следующих разделов относится (и реализует ключевые слова цикла) к разделу 26 главы *Common Lisp the Language*, 2d edition.

### Контроль Итераций (26.6)

Здесь мы определяем ключевые слова для итерации по элементам последовательности и для остановки итерации.
Рассмотрены следующие случаи, когда слова в верхнем регистре представляют собой ключевые слова цикла:

```lisp
(LOOP REPEAT n ...)
(LOOP FOR i FROM s TO e BY inc ...)
(LOOP FOR v IN l ...)
(LOOP FOR v ON l ...)
(LOOP FOR v = expr [THEN step] ...)
```

Реализация проста, хотя и несколько утомительна для сложных ключевых слов, таких как `for`.
Возьмем более простое ключевое слово - `repeat`.
Чтобы справиться с этим, мы создаем новую переменную, которая будет отсчитывать количество повторений.
Мы вызываем `add-var`, чтобы добавить эту переменную с ее начальным значением в структуру цикла.
Мы также даем этой переменной выражение обновления, которое уменьшает значение переменной на единицу каждый раз в цикле.
Затем все, что нам нужно сделать, это вызвать `add-test`, чтобы вставить код, который выйдет из цикла, когда переменная достигнет нуля:

```lisp
(defloop repeat (l times)
```

    `"(LOOP REPEAT n ...) does loop body n times."`

    `(let ((i (gensym "REPEAT")))`

        `(add-var l i times '(- ,i 1))`

        `(add-test l '(<= ,i 0))))`

Ключевое слово цикла `for` более сложен, но каждый случай может быть проанализирован так же, как `repeat`:

```lisp
(defloop as for) ;; AS is the same as FOR
(defloop for (l var exps)
```

    `"4 of the 7 cases for FOR are covered here:`

    `(LOOP FOR i FROM s TO e BY inc ...) does arithmetic iteration`

    `(LOOP FOR v IN l ...) iterates for each element of l`

    `(LOOP FOR v ON l ...) iterates for each tail of l`

    `(LOOP FOR v = expr [THEN step]) initializes and iterates v"`

    `(let ((key (first exps))`

            `(source (second exps))`

            `(rest (rest2 exps)))`

        `(ecase key`

            `((from downfrom upfrom to downto upto by)`

          `(loop-for-arithmetic l var exps))`

            `(in (let ((v (gensym "IN")))`

                      `(add-var l v source '(cdr ,v))`

                      `(add-var l var '(car ,v) '(car ,v))`

                      `(add-test l '(null ,v))`

                      `rest))`

            `(on (add-var l var source '(cdr ,var))`

                    `(add-test l '(null .var))`

                    `rest)`

            `(= (if (eq (first rest) 'then)`

                            `(progn`

                                `(pop rest)`

                                `(add-var l var source (pop rest)))`

                            `(progn`

                                `(add-var l var nil)`

                                `(add-body l '(setq ,var .source))))`

                    `rest)`

            `;; ACROSS.
BEING clauses omitted`

            `)))`

```lisp
(defun loop-for-arithmetic (l var exps)
```

    `"Parse loop expressions of the form:`

    `(LOOP FOR var [FROM | DOWNFROM | UPFROM exp1] [TO | DOWNTO | UPTO exp2]`

              `[BY exp3]"`

    `;; The prepositions BELOW and ABOVE are omitted`

    `(let ((exp1 0)`

              `(exp2 nil)`

              `(exp3 1)`

              `(down?
nil))`

        `;; Parse the keywords:`

        `(when (member (first exps) '(from downfrom upfrom))`

          `(setf exp1 (second exps)`

                  `down?
(eq (first exps) 'downfrom)`

                  `exps (rest2 exps)))`

        `(when (member (first exps) '(to downto upto))`

          `(setf exp2 (second exps)`

                  `down?
(or down?
(eq (first exps) 'downto))`

                  `exps (rest2 exps)))`

        `(when (eq (first exps) 'by)`

          `(setf exp3 (second exps)`

                  `exps (rest2 exps)))`

        `;; Add variables and tests:`

        `(add-var l var exp1`

                  `'(,(if down?
'- '+) ,var ,(maybe-temp l exp3)))`

        `(when exp2`

            `(add-test l '(,(if down?
'< '>) ,var ,(maybe-temp l exp2))))`

        `;; and return the remaining expressions:`

                  `exps))`

```lisp
(defun maybe-temp (l exp)
```

    `"Generate a temporary variable, if needed."`

    `(if (constantp exp)`

        `exp`

        `(let ((temp (gensym "TEMP")))`

            `(add-var l temp exp)`

            `temp)))`

### End-Test Control (26.7)

В этом разделе мы рассмотрим следующие предложения:

```lisp
(LOOP UNTIL test ...)
(LOOP WHILE test ...)
(LOOP ALWAYS condition ...)
(LOOP NEVER condition ...)
(LOOP THEREIS condition ...)
(LOOP ... (LOOP-FINISH) ...)
```

Каждое ключевое слово довольно простое:

```lisp
(defloop until (l test) (add-test l test))
(defloop while (l test) (add-test l '(not .test)))
(defloop always (l test)
```

    `(setf (loop-result l) t)`

    `(add-body l '(if (not ,test) (return nil))))`

```lisp
(defloop never (l test)
```

    `(setf (loop-result l) t)`

    `(add-body l '(if ,test (return nil))))`

```lisp
(defloop thereis (l test) (add-body l '(return-if ,test)))
(defmacro return-if (test)
```

    `"Return TEST if it is non-nil."`

    `(once-only (test)`

        `'(if ,test (return ,test))))`

```lisp
(defmacro loop-finish () '(go end))
```

### Сбор(Накопление) значений (26.8)

Ключевое слово `collect` представляет еще одну проблему.
Как вам собирать список выражений, представленных по одному за раз?
Ответ - рассматривать выражения как очередь, в которую мы добавляем элементы в конец, но никогда не удаляем их из начала очереди.
Затем мы можем использовать функции очереди, определенные в [разделе 10.5](B9780080571157500108.xhtml#s0025).

В отличие от других предложений, предложения накопления значений могут взаимодействовать друг с другом.
В одном цикле могут быть, скажем, два предложения `collect` и `append`, и все они строят один и тот же спискок.
Из-за этого я использую одно и то же имя переменной для аккумулятора, а не создаю новую переменную для каждого использования.
Выбранное имя сохраняется в глобальной переменной `*acc*`.
В официальном стандарте `loop` пользователь может указывать переменную с помощью модификатора `into`, но я не реализовал эту опцию.
Охватываемые предложения:

```lisp
(LOOP COLLECT item ...)
(LOOP NCONC item ...)
(LOOP APPEND item ...)
(LOOP COUNT item ...)
(LOOP SUM item ...)
(LOOP MAXIMIZE item ...)
(LOOP MINIMIZE item ...)
```

Реализация:

```lisp
(defconstant *acc* (gensym "ACC")
```

    `"Variable used for value accumulation in LOOP.")`

```lisp
;;; INTO preposition is omitted
(defloop collect (l exp)
```

    `(add-var l *acc* '(make-queue))`

    `(add-body l '(enqueue ,exp .*acc*))`

    `(setf (loop-result l) '(queue-contents ,*acc*)))`

```lisp
(defloop nconc (l exp)
```

    `(add-var l *acc* '(make-queue))`

    `(add-body l '(queue-nconc ,*acc* .exp))`

    `(setf (loop-result l) '(queue-contents .*acc*)))`

```lisp
(defloop append (l exp exps)
```

    `(call-loop-fn l 'nconc '((copy-list .exp) .,exps)))`

```lisp
(defloop count (l exp)
```

    `(add-var l *acc* 0)`

    `(add-body l '(when .exp (incf .*acc*)))`

    `(setf (loop-result l) *acc*))`

```lisp
(defloop sum (l exp)
```

    `(add-var l *acc* 0)`

    `(add-body l '(incf ,*acc* .exp))`

    `(setf (loop-result l) *acc*))`

```lisp
(defloop maximize (l exp)
```

    `(add-var l *acc* nil)`

    `(add-body l '(setf ,*acc*`

                `(if ,*acc*`

                        `(max ,*acc* ,exp)`

                        `,exp)))`

    `(setf (loop-result l) *acc*))`

```lisp
(defloop minimize (l exp)
```

    `(add-var 1 *acc* nil)`

    `(add-body l '(setf ,*acc*`

                `(if ,*acc*`

                        `(min ,*acc* ,exp)`

                        `,exp)))`

    `(setf (loop-result l) *acc*))`

```lisp
(defloop collecting collect)
(defloop nconcing nconc)
(defloop appending append)
(defloop counting count)
(defloop summing sum)
(defloop maximizing maximize)
(defloop minimizing minimize)
```

**Exercise  24.1**`loop` позволяет нам строить агрегаты (списки, максимумы, суммы и т.п.) выполняя тело цикла.
Иногда не удобно быть ограниченным  одним телом цикла(single-loop).
Например, нам может потребоваться список всех ненулевых элементов двумерного массива.
Один из способов реализовать это использовать макрос `with-collection`, который устанавливает и возвращает структуру очереди, которая создается вызовами функции `collect`.
Например:

```lisp
> (let ((A '#2a((l 0 0) (0 2 4) (0 0 3))))
```

    `(with-collection`

        `(loop for i from 0 to 2 do`

            `(loop for j from 0 to 2 do`

                `(if (> (aref a i j) 0)`

                    `(collect (aref A i j)))))))`

```lisp
(1 2 4 3)
```

Реализуйте `with-collection` и `collect`.

### Инициализация Переменных (26.9)

Предложение `with` позволяет использовать локальные переменные - я включил его, но сам вместо него рекомендую использвоать `let`.
Я не включил предлог `and`, который позволяет переменным быть вложенными на различных уровни.

`;;;; 26.9.
Variable Initializations ("and" omitted)`

```lisp
(defloop with (l var exps)
```

    `(let ((init nil))`

        `(when (eq (first exps) '=)`

            `(setf init (second exps)`

                `exps (rest2 exps)))`

        `(add-var l var init)`

        `exps))`

### Условное исполнение (26.10)

`loop` также предоставляет формы для условного исполнения.
По возможности их следует избегать, поскольку в Лиспе уже есть набор очень хороших условных макросов.
Однако иногда вы хотите, чтобы скажем, чтобы `collect` был обусловлен каким-либо тестом.
В этом случае, допустимы условные выражения цикла.
Здесь рассматриваются следующие предложения:

(`LOOP WHEN test ... CELSE ...]) ; IF` is asynonym for `WHEN`

```lisp
(LOOP UNLESS test ... [ELSE ...])
```

Здесь показан пример `when`:

`> (loop for`x `from 1 to 10`

          `when (oddp x)`

                  `collect x`

          `else collect (- x))`

```lisp
(1 -2 3 -4 5- 6 7 -8 9 -10)
```

Конечно, мы могли бы сказать `collect (if (oddp x ) x ( - x ) )` и выполнить его без условного выражения.
В условных выражениях loop есть одна дополнительная функциональность: значение теста сохраняется в переменной it для последующего использования в частях THEN или ELSE.
(Это как раз та особенность, которая заставляет некоторых людей любить `loop`, а других разводить руками в отчаянии.) Вот пример:

```lisp
> (loop for x from 1 to 10
```

        `when (second (assoc x '((l one) (3 three) (5 five))))`

        `collect it)`

```lisp
(ONE THREE FIVE)
```

Условные предложения реализовать немного сложнее, поскольку они включают синтаксический анализ других предложений.
Идея состоит в том, что `call-loop-fn` анализирует части THEN и ELSE, добавляя все необходимое в тело и другие части структуры цикла.
Затем `add-body` используется для добавления меток и опереторов go, которые при необходимости выполняют переход к указанным меткам.
Это тот же метод, который используется для компиляции условных выражений в [главе 23](B9780080571157500236.xhtml); см. функцию `comp-if` на [стр. 787](B9780080571157500236.xhtml#p787).
Вот код:

```lisp
(defloop when (l test exps)
```

    `(loop-unless l '(not ,(maybe-set-it test exps)) exps))`

```lisp
(defloop unless (l test exps)
```

    `(loop-unless l (maybe-set-it test exps) exps))`

```lisp
(defun maybe-set-it (test exps)
```

    `"Return value, but if the variable IT appears in exps,`

    `then return code that sets IT to value."`

    `(if (find-anywhere 'it exps)`

        `'(setq it .test)`

        `test))`

```lisp
(defloop if when)
(defun loop-unless (l test exps)
```

    `(let ((label (gensym "L")))`

        `(add-var l 'it nil )`

        `;; Emit code for the test and the THEN part`

        `(add-body l '(if .test (go ,label)))`

        `(setf exps (call-loop-fn l (first exps) (rest exps)))`

        `;; Optionally emit code for the ELSE part`

        `(if (eq (first exps) 'else)`

            `(progn`

                `(let ((label2 (gensym "L")))`

                    `(add-body l '(go ,label2))`

                    `(add-body l label)`

                    `(setf exps (call-loop-fn l (second exps) (rest2 exps)))`

                    `(add-body l label2)))`

                `(add-body l label)))`

    `exps)`

### Безусловное Выполнение (26.11)

Ключевые слова безусловного выполнения, это do и return:

```lisp
(defloop do (l exp exps)
```

    `(add-body l exp)`

    `(loop (if (symbolp (first exps)) (RETURN exps))`

        `(add-body l (pop exps))))`

```lisp
(defloop return (l exp) (add-body l '(return ,exp)))
```

### Различная функциональность (26.12)

Наконец, к различной функциональности относятся ключевые слова `initially` и `finally`, которые определяют пролог и эпилог цикла, а также ключевое слово named, дающее имя циклу для использования в форме `return-from`.
Я пропустил объявления типов данных и возможность деструктуризации.

```lisp
(defloop initially (l exp exps)
```

    `(push exp (loop-prologue l))`

    `(loop (if (symbolp (first exps)) (RETURN exps))`

        `(push (pop exps) (loop-prologue l))))`

```lisp
(defloop finally (l exp exps)
```

    `(push exp (loop-epilogue l))`

    `(loop (if (symbolp (first exps)) (RETURN exps))`

        `(push (pop exps) (loop-epilogue l))))`

```lisp
(defloop named (l exp) (setf (loop-name l) exp))
```

## 24.6 Функции работы с Последовательностями

Common Lisp предоставляет функции для работы с последовательностями, чтобы облегчить жизнь программисту: одну и туже функцию можно использовать для списков, векторов и строк.
Однако такая простота использования имеет свою цену.
Функции работы с последовательностями должны быть написаны очень тщательно, чтобы гарантировать их эффективность.
Есть три основных источника неопределенности, которые могут привести к неэффективности: (1) последовательности могут быть разных типов; (2) у некоторых функций есть аруменыты ключевые слова; (3) у некоторых функций есть аргумент `&rest`.
Тщательное кодирование может ограничить или устранить эти источники неэффективности, сделав как можно больше вариантов во время компиляции и сделав оставшиеся варианты вне основного цикла.

В этом разделе мы увидим, как эффективно реализовать новые ANSI функции работы с последовательностями `map-into` и обновленную функцию reduce.
Это важно для тех у кого нет компилятора ANSI.
Даже у кого есть доступ к компилятору ANSI, извлекут выгоду из используемых здесь методов повышения эффективности.

Перед определением функций работы с последовательностями, вводиться макрос `once-only`.

### Once-only: Урок по науке о макросах.

Макрос `once-only` уже давно используется в различных системах, хотя не вошел в стандарт Common Lisp.
Я включаю его сюда по двум причинам:: во-первых, он используется в следующем макросе `funcall-if`, и во-вторых, если вы понимаете, как писать и когда использовать `once-only`, то вы действительно понимаете макрос.

Во-первых, вы должны понять проблему, которую решает `once-only`.
Предположим, мы хотели иметь макрос, который умножает свой ввод на самого себя:[2](#fn0015)

```lisp
(defmacro square (x) '(* ,x ,x))
```

Это определение отлично работает в следующем случае:

```lisp
> (macroexpand '(square z)) => (* Z Z)
```

Но здесь оно не работает(правильно):

```lisp
> (macroexpand '(square (print (incf i))))
(* (PRINT (INCF I)) (PRINT (INCF I)))
```

Проблема в том, что `i` будет увеличиваться дважды, а не один раз, и будут напечатаны два различных значения, а не одно.
Нам нужно привязать `(print (incf i))` к локальной переменной, прежде чем выполнять умножение.
С другой стороны, было бы излишним привязывать z к локальной переменной в предыдущем примере.
Вот тут и пригодится `once-only`.
Он позволит нам написать определения макросов следующим образом:

```lisp
(defmacro square (x) (once-only (x) '(* ,x ,x)))
```

и сгенерированный код должен быть именно, тем какой мы хотели бы получить:

```lisp
> (macroexpand '(square z))
(* Z Z)
> (macroexpand '(square (print (incf i))))
(LET ((G3811 (PRINT (INCF I))))
```

    `(* G3811 G3811))`

Теперь вы усвоили первый урок `once-only` : вы знаете чем макросы отличаются от функций, когда дело касается аргументов с побочными эффектами, и теперь вы знаете, как с этим справиться.
Урок номер два приходит, когда вы пытаетесь написать(или даже понять) определение `once-only`- только когда вы действительно поймете природу макросов, вы сможете написать правильную версию.
Как всегда, первое, что нужно определить, это то, во что должен расширяться вызов `once-only`.
Сгенерированный код должен проверить переменную, чтобы убедиться, что она не имеет побочных эффектов, и если да, сгенерировать тело как есть; в противном случае он должен сгенерировать код для привязки новой переменной и использовать эту переменную в теле кода.
Вот примерно то, что мы хотим:

```lisp
> (macroexpand '(once-only (x) '(* ,x ,x)))
(if (side-effect-free-p x)
```

    `'(* ,x ,x)`

    `'(let ((g001 ,x))`

        `, (let ((x 'g001))`

            `'(* x ,x))))`

где `g001` - новый символ, чтобы избежать конфликтов с символом `x` или символами в теле.
Обычно мы генерируем тела макросов с использованием обратных кавычек, но если в самом деле макроса есть обратные кавычки, что делать?
Можно вкладывать backquotes(обратные кавычки) (и в  [приложении C](B9780080571157500273.xhtml) к *Common Lisp the Language*, 2d edition есть хорошее обсуждение двойных и тройных вложенных обратных кавычекhas), но это конечно не тривиально для понимания.
Я рекомендую заменить внутреннюю обратную кавычку на ее эквивалент, используя `list` и `quote`:

```lisp
(if (side-effect-free-p x)
```

    `'(* ,x ,x)`

    `(list 'let (list (list 'g001 x))`

        `(let ((x 'g001))`

            `'(* ,x ,x))))`

Теперь мы можем написать `once-only`.
Обратите внимание, что мы должны учитывать случай, когда существует более одной переменной и когда в теле содержится более одного выражения.

```lisp
(defmacro once-only (variables &rest body)
```

    `"Returns the code built by BODY.
If any of VARIABLES`

    `might have side effects.
they are evaluated once and stored`

    `in temporary variables that are then passed to BODY."`

    `(assert (every #'symbolp variables))`

    `(let ((temps (loop repeat (length variables) collect (gensym))))`

        `'(if (every #'side-effect-free-p (list .,variables))`

            `(progn .,body)`

            `(list 'let`

                `,'(list .@(mapcar #'(lambda (tmp var)`

                    `'(list '.tmp .var))`

                `temps variables))`

                  `(let .(mapcar #'(lambda (var tmp) '(.var ',tmp))`

            `variables temps)`

          `.,body)))))`

```lisp
(defun side-effect-free-p (exp)
```

    `"Is exp a constant, variable, or function,`

    `or of the form (THE type x) where x is side-effect-free?"`

    `(or (constantp exp) (atom exp) (starts-with exp 'function)`

        `(and (starts-with exp 'the)`

            `(side-effect-free-p (third exp)))))`

Здесь мы видим расширение вызова `once-only` и поторение расширений двух вызовов `square`:

```lisp
> (macroexpand '(once-only (x) '(* ,x ,x)))
(IF (EVERY #'SIDE-EFFECT-FREE-P (LIST X))
```

        `(PROGN`

            `'(* ,X ,X))`

        `(LIST 'LET (LIST (LIST 'G3763 X))`

                    `(LET ((X 'G3763))`

                        `'(* ,X ,X))))`

```lisp
> (macroexpand '(square z))
(* Z Z)
> (macroexpand '(square (print (incf i))))
(LET ((G3811 (PRINT (INCF I))))
```

    `(* G3811 G3811))`

Этот вывод был произведен с параметром `*print-gensym*` установленным в `nil`.
Если эта переменная не равна нулю, не интернированные символы печатаются с префиксом `#`:,как в `#:G3811`.
Это гарантирует, что символ не будет интернирован при последующем прочтении процедурой read.

Стоит отметить, что Common Lisp автоматически обрабатывает проблемы, связанные с многократным вычислением подчиненных форм в методах setf.
См. [стр. 884](B978008057115750025X.xhtml#p884), например.

### Избегайте черезмерного использования макросов

Мудрое слово: не увлекайтесь макросами.
Используйте макросы для представления вашей проблемы, но избегайте новых макросов при реализации вашего *решения,* за исключением случаев крайней необходимости.
Итак, это хороший стиль - вводить макрос, скажем `defrule`, который определяет правила для вашего приложения, но добавление макросов в сам код может только усложнить его использование другими.

Вот такая история.
До того, как `if` стал стандартной частью Lisp, я определил свою собственную версию `if`.
В отличии от простого `if`, моя версия принимала любое количество пар тест/результат, за которыми следовало не обязательный результат else.
В целом, расширение было:

```lisp
(if *a b c d...x)* => (cond *(a b)* (*c d*) ... (T *x*))
```

У моего `if` была еще одна особенность: символ `'that'` можно было использовать для значения самого последнего теста.
Например, я мог бы написать:

```lisp
(if (assoc item a-list)
```

    `(process (cdr that)))`

который расширялся бы до:

```lisp
(LET (THAT)
```

    `(COND`

        `((SETQ THAT (ASSOC ITEM A-LIST)) (PROCESS (CDR THAT)))))`

Это была удобная функциональность (сравните её с  => функциональностью в Scheme cond, которая обсуждалась на [стр. 778](B9780080571157500224.xhtml#p778)), но она давала обратный эффект достаточно часто, и я в конце концов отказался от своей версии `if`.
И вот почему.
Я бы написал такой код:

```lisp
(if (total-score x)
```

    `(print (/ that number-of-trials))`

    `(error "No scores"))`

а затем внес небольшое изменение:

```lisp
(if (total-score x)
```

    `(if *print-scores* (print (/ that number-of-trials)))`

    `(error "No scores"))`

Проблема в том, что переменная `that` теперь относится к `*print-scores*`, а не к `(total-score x),` как это было раньше.
Мой макрос нарушает ссылочную прозрачность.
В общем, в этом весь смысл макросов, и поэтому макросы удобны.
Но в этом случае нарушение ссылочной прозрачности может привести к путанице.

### Функция MAP-INTO

Функция `map-into` используется на [стр. 632](B9780080571157500182.xhtml#p632).
Эта функция, добавленная в ANSI версии Common Lisp, похожа на `map`, за исключением того, что вместо построения новой последовательности изменяется первый аргумент, хранящий результаты.
В этом разделе описывается, как написать эффективную версию `map-into`, используя методы, применимые к любой функции для работы с последовательностями.
Начнем с простой версии:

```lisp
(defun map-into (result-sequence function &rest sequences)
```

    `"Destructively set elements of RESULT-SEQUENCE to the results`

    `of applying FUNCTION to respective elements of SEQUENCES."`

    `(replace result-sequence (apply #'map 'list function sequences)))`

Она выполняет свою работу, но сводит на нет цель `map-into`, которая состоит в том, чтобы избежать генерации мурсора(garbage).
Вот версия, которая генерирует меньше мусора:

```lisp
(defun map-into (result-sequence function &rest sequences)
```

    `"Destructively set elements of RESULT-SEQUENCE to the results`

    `of applying FUNCTION to respective elements of SEQUENCES."`

    `(let ((n (loop for seq in (cons result-sequence sequences)`

                            `minimize (length seq))))`

        `(dotimes (i n)`

            `(setf (elt result-sequence i)`

                `(apply function`

                    `(mapcar #'(lambda (seq) (elt seq i))`

                        `sequences))))))`

У этого определения есть три проблемы.
Во-первых, оно тратит в пустую пространство: mapcar каждый раз создает новый список аргументов только для того, чтобы этот список был отброшен.
Во-вторых, оно напрасная тратит время: выполнение `setf` для `i`-го элемента списка делает алгоритм *O*(*n2*) вместо *O*(*n*), где *n* это длина списка.
В-третьих, оно слегка неверно: если `result-sequence` является вектором с указателем заполнения, то `map-into` игнорирует теущую длину `result-sequence's` и при необходимости расширяет указатель заполнения.
Следующая версия устраняет эти проблемы:

```lisp
(defun map-into (result-sequence function &rest sequences)
```

    `"Destructively set elements of RESULT-SEQUENCE to the results`

    `of applying FUNCTION to respective elements of SEQUENCES."`

    `(let ((arglist (make-list (length sequences)))`

        `(n (if (listp result-sequence)`

            `most-positive-fixnum`

            `(array-dimension result-sequence 0))))`

      `;; arglist is made into a list of args for each call`

      `;; n is the length of the longest vector`

      `(when sequences`

          `(setf n (min n (loop for seq in sequences`

              `minimize (length seq)))))`

      `;; Define some shared functions:`

      `(flet`

        `((do-one-call (i)`

            `(loop for seq on sequences`

                `for arg on arglist`

                `do (if (listp (first seq))`

                    `(setf (first arg)`

                        `(pop (first seq)))`

                    `(setf (first arg)`

                        `(aref (first seq) i))))`

            `(apply function arglist))`

        `(do-result (i)`

            `(if (and (vectorp result-sequence)`

                `(array-has-fill-pointer-p result-sequence))`

            `(setf (fill-pointer result-sequence)`

    `(max i (fill-pointer result-sequence))))))`

      `(declare (inline do-one-call))`

      `;; Decide if the result is a list or vector,`

      `;; and loop through each element`

      `(if (listp result-sequence)`

        `(loop for i from 0 to (- n 1)`

          `for r on result-sequence`

          `do (setf (first r)`

                `(do-one-call i)))`

        `(loop for i from 0 to (- n 1)`

          `do (setf (aref result-sequence i)`

                `(do-one-call i))`

          `finally (do-result n))))`

      `result-sequence))`

Здесь стоит отметить несколько моментов.
Сначала я разделил основной цикл на две версии, в одной из которых результатом является список, а в другой вектор.
Вместо дублирования кода определены локальные функции `do-one-call` и `do-result`.
Первая объявлена встроенной(inline) поскольку она часто вызывается, а вторая нет.
Аргументы вычисляются путем просмотра каждой последовательности за раз, взятием i-го элемента, если это вектор, и извлечением(popping), если последовательность это список.
Аргументы сохраняются в списке `arglist`, который предварительно выделен правильного размера.
В общем, мы вычисляем ответ достаточно эффективно, не создавая ненужного мусора.

Однако приложение могло быть выполнено более эффективно.
Подумайте, что должен сделать apply: просмотреть список аргументов и поместить каждый аргумент в место, ожидаемое соглашениями о вызове функций, а затем перейти к функции.
Некоторые реализации пердоставляют лучший способ сделать это.
Например, TI Lisp Machine предоставляет две низкоуровневые примитивные функции, `%push` и `%call`, которые компилируются в отдельные инструкции, чтобы поместить аргументы в нужные места и перейти к функции.
С этими примитивами тело `do-one-call` будет выглядеть так:

```lisp
(loop for seq on sequences
```

    `do (if (listp (first seq))`

        `(%push (pop (first seq)))`

        `(%push (aref (first seq) i))))`

```lisp
(%call function length-sequences)
```

Однко остается неэффективность.
Каждая последовательность проверяется на тип каждый раз в цикле, даже если тип остается постоянным после определения в первый раз.
Теоретически, мы огли бы закодировать отдельные циклы для каждой комбинации типов, точно так же, как мы кодировали два цикла в зависимости от типа результирующей последовательности.
Но это будет означать 2*n* циклов для *n* последовательностей, и нет никаких ограничений на то, насколько большим может быть *n*.

Возможно, стоит предоставить специализированные функции для малых значений *n*, и распределять их соответствующей функции.
Вот начало такого подхода:

```lisp
(defun map-into (result function &rest sequences)
```

    `(apply`

      `(case (length sequences)`

        `(0 (if (listp result) #'map-into-list-0 #'map-into-vect-0))`

        `(1 (if (listp result)`

          `(if (listp (first sequences))`

              `#'map-into-list-l-list #'map-into-list-1-vect)`

          `(if (listp (first sequences))`

              `#'map-into-vect-l-list #'map-into-vect-l-vect)) )`

        `(2 (if (listp result)`

          `(if (listp (first sequences))`

            `(if (listp (second sequences))`

              `#'map-into-list-2-list-list`

              `#'map-into-list-2-list-vect)`

            `...)))`

        `(t (if (listp result) #'map-into-list-n #'map-into-vect-n)))`

      `result function sequences))`

Индивидуальные функции не показаны.
Этот подход эффективен с точки зрения времени выполнения, но занимает много места, учитывая, что `map-into` относительно не понятная функция.
Если `map-into` объявлен встроенной(`inline`) и компилятор достаточно хорош, он создаст код, который просто вызывает соответствующую функцию.

### REDUCE с :key

Еще одно изменение в предложении ANSI добавление ключевого слова :key в `reduce`.
Это полезное дополнение - на самом деле, в течении многих лет я использовал функцию `reduce-by`, которая обеспечивала именно эту функциональность.
В этом разделе мы увидим, как добавить ключевое слово :key.

На верхнем уровне я определяю reduce как интерфейс к функции без ключевых слов - `reduce*`.
Обе они объявлены встроенными(proclaimed inline), поэтому при обычном использовании reduce не будет накладных расходов на ключевые слова.

```lisp
(proclaim '(inline reduce reduce*))
```

  `(defun reduce* (fn seq from-end start end key init init-p)`

          `(funcall (if (listp seq) #'reduce-list #'reduce-vect)`

                    `fn seq from-end (or start 0) end key init init-p))`

```lisp
(defun reduce (function sequence &key from-end start end key
```

                              `(initial-value nil initial-value-p))`

```lisp
        (reduce* function sequence from-end start end
```

                                    `key initial-value initial-value-p))`

Более простой случай - когда последовательность являлется вектором:

```lisp
(defun reduce-vect (fn seq from-end start end key init init-p)
```

        `(when (null end) (setf end (length seq)))`

        `(assert (<= 0 start end (length seq)) (start end)`

                            `"Illegal subsequence of ~  a --- :start ~  d :end ~  d"`

                                  `seq start end)`

      `(case (- end start)`

                  `(0 (if init-p init (funcall fn)))`

                  `(1 (if init-p`

                          `(funcall fn init (funcall-if key (aref seq start)))`

                          `(funcall-if key (aref seq start))))`

                  `(t (if (not from-end)`

                          `(let ((result`

                                  `(if init-p`

                                    `(funcall fn init`

                                      `(funcall-if key (aref seq start)))`

                                  `(funcall`

                                            `fn`

                                                    `(funcall-if key (aref seq start))`

                                                    `(funcall-if key (aref seq (+ start 1)))))))`

                          `(loop for i from (+ start (if init-p 1 2))`

                                          `to (- end 1)`

                                          `do (setf result`

                                              `(funcall`

                                                `fn result`

                                                `(funcall-if key (aref seq i)))))`

                                  `result)`

                          `(let ((result`

                                  `(if init-p`

                              `(funcall`

              `fn`

              `(funcall-if key (aref seq (- end 1)))`

                              `init)`

                    `(funcall`

                            `fn`

                              `(funcall-if key (aref seq (- end 2)))`

                              `(funcall-if key (aref seq (- end 1)))))))`

  `(loop for i from (- end (if init-p 2 3)) downto start`

                  `do (setf result`

                                `(funcall`

                                                                `fn`

                                                                `(funcall-if key (aref seq i))`

                                                                `result)))`

```lisp
result)))))
```

Когда последовательность представляет собой список, мы идем на некоторые трудности, чтобы избежать вычисления длины, так как это операция *O(n)* над списками.
Самое трудное решение - это то, что делать когда список должен быть пройден с конца.
Есть четыре варианта:

*   **recurse(рекурсивный).** Мы могли бы рекурсивно пройтись по списку, пока не дойдем до конца, а затем вычислить результаты на обратном пути от рекурсии.
Однако, некоторые реализации могут иметь довольно маленькие границы глубины рекурсивных вызовов, и системная функция, такая как reduce, никогда не должна нарушать такие ограничения.
В любом случае объем пространства стека, потребляемого этим подоходом, обычно будет больше, чем объем пространства кучи, потребляемого при следующем подходе.

*   **reverse(обратный).** Мы могли бы перевернуть список и затем считать, что `from-end` истинным.
Единственный недостаток - это время и пространство, необходимые для построения перевернутого списка.

*   **nreverse(перевернуть исходный список).** Мы могли бы разрушающе перевернуть список на месте, выполнить reduce, и затем деструктивно перевернуть список обратно в исходное состояние (возможно, с добавлением  unwind-protect).
К сожалению это неправильно.
Список может быть привязан к некоторой переменной, доступной в функции используемой при вычислении редукуии. Если это так, функция увидит перевернутый список, а не исходный список.

*   **coerce(принуждение).** Мы могли бы преобразовать список в вектор, а затем использовать `reduce-vect`.
Этот подход имеет преимущество перед подходом реверсирования(reverse) в том, что векторы обычно занимают в двое меньше памяти, чем списки. Поэтому я придерживаюсь этого подхода.

```lisp
(defmacro funcall-if (fn arg)
```

      `(once-only (fn)`

              `'(if .fn (funcall .fn .arg) .arg)))`

```lisp
(defun reduce-list (fn seq from-end start end key init init-p)
```

        `(when (null end) (setf end most-positive-fixnum))`

        `(cond ((> start 0)`

                          `(reduce-list fn (nthcdr start seq) from-end 0`

                                      `(- end start) key init init-p))`

                          `((or (null seq) (eql start end))`

                          `(if init-p init (funcall fn)))`

                          `((= (- end start) 1)`

                          `(if init-p`

                                `(funcall fn init (funcall-if key (first seq)))`

                                `(funcall-if key (first seq))))`

                    `(from-end`

                          `(reduce-vect fn (coerce seq 'vector) t start end`

                                      `key init init-p))`

                                `((null (rest seq))`

                          `(if init-p`

                                `(funcall fn init (funcall-if key (first seq)))`

                                `(funcall-if key (first seq))))`

                    `(t (let ((result`

                    `(if init-p`

                                  `(funcall`

                                                `fn init`

                                                `(funcall-if key (pop seq)))`

                                  `(funcall`

                                                `fn`

                                                `(funcall-if key (pop seq))`

                                                `(funcall-if key (pop seq))))))`

                    `(if end`

                                `(loop repeat (- end (if init-p 1 2)) while seq`

                                  `do (setf result`

                                                `(funcall`

                                                `fn result`

                                          `(funcall-if key (pop seq)))))`

                          `(loop while seq`

                                  `do (setf result`

                              `(funcall`

                                    `fn result`

                                    `(funcall-if key (pop seq)))))`

                          `result)))))`

## 24.7 Упражнения

**Exercise  24.2 [m]** Функция reduce очень полезна, особенно с ключевым словом key.
Напишите нерекурсивные определения для append и 1ength используя reduce.
Какие еще функции можно написать с помощью reduce?

**Exercise  24.3** The so-called loop keywords are not symbols in the keyword package.
The preceding code assumes they are all in the current package, but this is not quite right.
Change the definition of `loop` so that any symbol with the same name as a loop keyword acts as a keyword, regardless of the symbol's package.

**Exercise  24.4** Can there be a value for *exp* for which the following expressions are not equivalent?
Either demonstrate such an *exp* or argue why none can exist.

```lisp
(loop for x in list collect *exp*)
(mapcar #'(lambda (x) *exp)* list))
```

**Exercise  24.5** The object-oriented language Eiffel provides two interesting `loop` keywords: `invariant` and `variant`.
The former takes a Boolean-valued expression that must remain true on every iteration of the loop, and the latter takes a integervalued expression that must decrease on every iteration, but never becomes negative.
Errors are signaled if these conditions are violated.
Use def `loop` to implement these two keywords.
Make them generate code conditionally, based on a global flag.

## 24.8 Ответы

**Answer 24.1**

```lisp
(defvar *queue*)
(defun collect (item) (enqueue item *queue*))
(defmacro with-collection (&body body)
```

          `'(let ((*queue* (make-queue)))`

                                  `,@body`

                      `(queue-contents *queue*)))`

Here's another version that allows the collection variable to be named.
That way, more than one collection can be going on at the same time.

```lisp
(defun collect (item &optional (queue *queue*))
```

            `(enqueue item queue))`

```lisp
(defmacro with-collection ((&optional (queue '*queue*))
```

                                                              `&body body)`

            `'(let ((,queue (make-queue)))`

              `,@body`

            `(queue-contents .queue)))`

**Answer 24.2**

```lisp
(defun append-r (x y)
```

            `(reduce #'cons x :initial-value y :from-end t))`

```lisp
(defun length-r (list)
```

            `(reduce #'+ list :key #'(lambda (x) 1)))`

**Answer 24.4** The difference between `loop` and `mapcar` is that the former uses only one variable `x`, while the latter uses a different `x` each time.
If `x`'s extent is no bigger than its scope (as it is in most expressions) then this makes no difference.
But if any `x` is captured, giving it a longer extent, then a difference shows up.
Consider *exp =*`#'(lambda () x).`

```lisp
> (mapcar #'funcall (loop for x in '(1 2 3) collect
```

                                          `#'(lambda O x)))`

```lisp
(3 3 3)
>(mapcar #'funcall (mapcar #'(lambda (x) #'(lambda () x))
```

                                                    `'(1 2 3)))`

```lisp
(1 2 3)
```

**Answer 24.5**

```lisp
(defvar *check-invariants* t
```

            `"Should VARIANT and INVARIANT clauses in LOOP be checked?")`

```lisp
(defloop invariant (l exp)
```

            `(when *check-invariants*`

                                `(add-body l '(assert .exp () "Invariant violated."))))`

```lisp
(defloop variant (l exp)
```

  `(when *check-invariants*`

                      `(let ((var (gensym "INV")))`

                                `(add-var l var nil)`

                                `(add-body l '(setf ,var (update-variant .var .exp))))))`

          `(defun update-variant (old new)`

            `(assert (or (null old) (< new old)) ()`

                                `"Variant is not monotonically decreasing")`

            `(assert (> new 0) () "Variant is no longer positive")`

          `new)`

Here's an example:

```lisp
(defun gcd2 (a b)
```

            `"Greatest common divisor.
For two positive integer arguments."`

            `(check-type a (integer 1))`

            `(check-type b (integer 1))`

            `(loop with x = a with y = b`

                                `invariant (and (> x 0) (> y 0)) ;; (= (gcd x y) (gcd a b))`

                                `variant (max x y)`

                                `until (= x y)`

                                `do (if (> x y) (decf x y) (decf y x))`

                                `finally (return x)))`

Here the invariant is written semi-informally.
We could include the calls to `gcd`, but that seems to be defeating the purpose of `gcd2`, so that part is left as a comment.
The idea is that the comment should help the reader prove the correctness of the code, and the executable part serves to notify the lazy reader when something is demonstrably wrong at run time.

----------------------

[1](#xfn0010) Or in the user package in non-ANSI systems.
!!!(p) {:.ftnote1}

[2](#xfn0015) As was noted before, the proper way to do this is to proclaim squa re as an inline function, not a macro, but please bear with the example.
!!!(p) {:.ftnote1}