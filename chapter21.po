#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter21.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-03-13 20:01+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter21.md:3
msgid ""
"# Chapter 21\n"
"## A Grammar of English"
msgstr ""
"# Глава 21\n"
"## Грамматика английского языка"

#: in/chapter21.md:5
msgid "> Prefer geniality to grammar."
msgstr "> Предпочитаю сердечность грамматике."

#: in/chapter21.md:7
msgid "> -Henry Watson Fowler"
msgstr ""

#: in/chapter21.md:9
msgid "> *The King's English* (1906)"
msgstr ""

#: in/chapter21.md:14
msgid ""
"The previous two chapters outline techniques for writing grammars and "
"parsers based on those grammars.\n"
"It is quite straightforward to apply these techniques to applications like "
"the CD player problem where input is limited to simple sentences like \"Play "
"1 to 8 without 3.\" But it is a major undertaking to write a grammar for "
"unrestricted English input.\n"
"This chapter develops a grammar that covers all the major syntactic "
"constructions of English.\n"
"It handles sentences of much greater complexity, such as \"Kim would not "
"have been persuaded by Lee to look after the dog.\" The grammar is not "
"comprehensive enough to handle sentences chosen at random from a book, but "
"when augmented by suitable vocabulary it is adequate for a wide variety of "
"applications."
msgstr ""
"В предыдущих двух главах описываются методы написания грамматик и "
"синтаксических анализаторов на основе этих грамматик.\n"
"Эти методы довольно просто применить к приложениям, таким как проблема с "
"проигрывателем компакт-дисков, где ввод ограничен простыми предложениями, "
"такими как \"Play 1 to 8 without 3\"(Воспроизвести с 1 по 8 без 3). Но "
"написать грамматику для неограниченного ввода английского языка - серьезная "
"задача.\n"
"В этой главе разрабатывается грамматика, охватывающая все основные "
"синтаксические конструкции английского языка.\n"
"Она обрабатывает предложения гораздо большей сложности, такие как \"Kim "
"would not have been persuaded by Lee to look after the dog\"(Ли не убедил "
"Ким присматривать за собакой). Грамматика не является достаточно "
"всеобъемлющей, чтобы обрабатывать предложения, случайно выбранные из книги, "
"но когда она дополняется подходящей лексикой, она подходит для самых разных "
"применений."

#: in/chapter21.md:18
msgid ""
"This chapter is organized as a tour through the English language.\n"
"We first cover noun phrases, then verb phrases, clauses, and sentences.\n"
"For each category we introduce examples, analyze them linguistically, and "
"finally show definite clause grammar rules that correspond to the analysis."
msgstr ""
"Эта глава организована как экскурсия по английскому языку.\n"
"Сначала мы охватываем фразы существительных, затем глагольные фразы, "
"предложения(clauses) и утверждения/изречения(sentences).\n"
"Для каждой категории мы вводим примеры, анализируем их лингвистически и, "
"наконец, показываем правила грамматики определенных предложений, которые "
"соответствуют анализу."

#: in/chapter21.md:26
msgid ""
"As the last chapter should have made clear, analysis more often results in "
"complication than in simplification.\n"
"For example, starting with a simple rule like `(S --> NP VP)`, we soon find "
"that we have to add arguments to handle agreement, semantics, and gapping "
"information.\n"
"[Figure 21.1](#f0010) lists the grammatical categories and their arguments.\n"
"Note that the semantic argument, `sem`, is always last, and the gap "
"accumulators, `gap1` and `gap2`, are next-to-last whenever they occur.\n"
"All single-letter arguments denote metavariables; for example, each noun "
"phrase (category NP) will have a semantic interpretation, `sem`, that is a "
"conjunction of relations involving the variable `x`.\n"
"Similarly, the `hin modifiers` is a variable that refers to the head-the "
"thing that is being modified.\n"
"The other arguments and categories will be explained in turn, but it is "
"handy to have this figure to refer back to."
msgstr ""
"Как должно было быть ясно из предыдущей главы, анализ чаще приводит к "
"усложнению, чем к упрощению.\n"
"Например, начиная с простого правила, такого как `(S --> NP VP)`, мы вскоре "
"обнаруживаем, что должны добавлять аргументы для обработки согласования, "
"семантики и информации о пропусках(разрывах).\n"
"[Рисунок 21.1](#f0010) перечисляет грамматические категории и их аргументы.\n"
"Обратите внимание, что семантический аргумент, `sem`, всегда является "
"последним, а аккумуляторы разрывов, `gap1` и `gap2`, являются "
"предпоследними, когда они встречаются.\n"
"Все однобуквенные аргументы обозначают метапеременные; например, каждая "
"фраза существительного (категория NP) будет иметь семантическую "
"интерпретацию, `sem`, то есть конъюнкцию отношений, включающих переменную "
"`x`.\n"
"Точно так же модификаторы hin(`hin modifiers`) - это переменная, которая "
"ссылается на заголовок, то есть к изменяемой вещи.\n"
"Другие аргументы и категории будут объяснены по очереди, но полезно иметь "
"эту картинку, чтобы вернуться к ней."

#: in/chapter21.md:31
msgid ""
"| []()                                                    |\n"
"|---------------------------------------------------------|\n"
"| ![f21-01](images/chapter21/f21-01.jpg)                  |\n"
"| Figure 21.1: Grammatical Categories and their Arguments |"
msgstr ""
"| []()                                                    |\n"
"|---------------------------------------------------------|\n"
"| ![f21-01](images/chapter21/f21-01.jpg)                  |\n"
"| Рисунок 21.1: Грамматические категории и их аргументы |"

#: in/chapter21.md:33
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter21.md:35
msgid "## 21.1 Noun Phrases"
msgstr "## 21.1 Фразы существительных(Noun Phrases)"

#: in/chapter21.md:44
msgid ""
"The simplest noun phrases are names and pronouns, such as \"Kim\" and \"them."
"\" The rules for these cases are simple: we build up a semantic expression "
"from a name or pronoun, and since there can be no gap, the two gap "
"accumulator arguments are the same `(?g1)`.\n"
"Person and number agreement is propagated in the variable `?agr`, and we "
"also keep track of the *case* of the noun phrase.\n"
"English has three cases that are reflected in certain pronouns.\n"
"In the first person singular, \"I\" is the *nominative* or *subjective* "
"case, \"me\" is the *accusative* or *objective* case, and \"my\" is the "
"*genitive* case.\n"
"To distinguish them from the genitive, we refer to the nominative and the "
"objective cases as the *common* cases.\n"
"Accordingly, the three cases will be marked by the expressions `(common "
"nom), (common obj),` and gen, respectively.\n"
"Many languages of the world have suffixes that mark nouns as being one case "
"or another, but English does not.\n"
"Thus, we use the expression `(common ?)` to mark nouns."
msgstr ""
"Самыми простыми фразами существительных являются имена(names) и "
"местоимения(pronouns), например \"Kim\"(Ким) и \"them.\"(они). Правила для "
"этих случаев просты: мы создаем семантическое выражение из имени или "
"местоимения, и, поскольку разрывов быть не может, два аргумента аккумулятора "
"разрывов являются одинаковыми `(?g1)`.\n"
"Согласование лица и числа передается в переменной `?agr`, и мы также "
"отслеживаем *падеж* фразы существительного.\n"
"В английском есть три падежа, которые отражены в определенных местоимениях.\n"
"В первом лице единственного числа, \"I\"(я) - это *именительный* или "
"*субъективный* падеж, \"me\"(мне) - *винительный* или *объективный* падеж и "
"\"my\"(мой) - *родительный* падеж.\n"
"Чтобы отличить их от родительного падежа, мы называем именительный и "
"объективный падежи *общими* падежами.\n"
"Соответственно, эти три случая будут отмечены выражениями `(common nom), "
"(common obj),` и `gen` соответственно.\n"
"Во многих языках мира есть суффиксы(suffixes), обозначающие существительные "
"в том или ином падеже, но в английском нет.\n"
"Таким образом, мы используем выражение `(common ?)` Для обозначения "
"существительных."

#: in/chapter21.md:49
msgid ""
"We also distinguish between noun phrases that can be used in questions, like "
"\"who,\" and those that cannot.\n"
"The `?wh` variable has the value  `+wh` for noun phrases like \"who\" or "
"\"which one\" and `-wh` for nonquestion phrases.\n"
"Here, then, are the rules for names and pronouns.\n"
"The predicates name and `pronoun` are used to look up words in the lexicon."
msgstr ""
"Мы также различаем фразы существительных, которые можно использовать в "
"вопросах, например \"who\"(кто), и те, которые нельзя использовать.\n"
"Переменная `?wh` имеет значение `+wh` для таких фраз существительных, как "
"\"who\" или \"which one\", и `-wh` для фраз без вопросов.\n"
"Итак, вот правила для имен и местоимений.\n"
"Предикаты `name` и `pronoun` используются для поиска слов в лексиконе."

#: in/chapter21.md:53
msgid ""
"```lisp\n"
"(rule (NP ?agr (common ?) -wh ?x ?g1 ?g1 (the ?x (name ?name ?x))) ==>\n"
"  (name ?agr ?name))"
msgstr ""

#: in/chapter21.md:57
msgid ""
"(rule (NP ?agr ?case ?wh ?x ?g1 ?g1 ?sem) ==>\n"
"  (pronoun ?agr ?case ?wh ?x ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:59
msgid ""
"Plural nouns can stand alone as noun phrases, as in \"dogs,\" but singular "
"nouns need a determiner, as in \"the dog\" or \"Kim's friend's biggest dog."
"\" Plural nouns can also take a determiner, as in \"the dogs.\" The category "
"Det is used for determiners, and NP2 is used for the part of a noun phrase "
"after the determiner:"
msgstr ""
"Существительные во множественном числе могут стоять отдельно в составе фраз "
"существительных, например, \"dogs\"(собаки), но существительные в "
"единственном числе нуждаются в определителе, например, \"the dog\"(собака) "
"или \"Kim's friend's biggest dog.\"(самая большая собака друга Кима). "
"Существительные множественного числа также могут иметь определитель, "
"например, \"the dogs\"(собаки). Категория Det используется для "
"определителей, а NP2 используется для части фразы существительного после "
"определителя:"

#: in/chapter21.md:64
msgid ""
"```lisp\n"
"(rule (NP (- - - +) ?case -wh ?x ?g1 ?g2 (group ?x ?sem)) ==>\n"
"  (:ex \"dogs\") ; Plural nouns don't need a determiner\n"
"  (NP2 (- - - +) ?case ?x ?g1 ?g2 ?sem))"
msgstr ""

#: in/chapter21.md:70
msgid ""
"(rule (NP ?agr (common ?) ?wh ?x ?g1 ?g2 ?sem) ==>\n"
"  (:ex \"Every man\" \"The dogs on the beach\")\n"
"  (Det ?agr ?wh ?x ?restriction ?sem)\n"
"  (NP2 ?agr (common ?) ?x ?g1 ?g2 ?restriction))\n"
"```"
msgstr ""

#: in/chapter21.md:73
msgid ""
"Finally, a noun phrase may appear externally to a construction, in which "
"case the noun phrase passed in by the first gap argument will be consumed, "
"but no words from the input will be.\n"
"An example is the &blank; in \"Whom does Kim like &blank;?\""
msgstr ""
"Наконец, фраза существительного может появляться снаружи конструкции, и в "
"этом случае будет использована фраза существительного, переданная первым "
"аргументом разрыва,  но не слова из входных данных.\n"
"Примером может служить &blank; в \"Whom does Kim like &blank;?\"(Кому "
"нравится Ким &blank;?)"

#: in/chapter21.md:79
msgid ""
"```lisp\n"
"(rule (NP ?agr ?case ?wh ?x (gap (NP ?agr ?case ?x)) (gap nil) t)\n"
"  ==> ;; Gapped NP\n"
"  )\n"
"```"
msgstr ""

#: in/chapter21.md:82
msgid ""
"Now we address the heart of the noun phrase, the `NP2` category.\n"
"The lone rule for `NP2` says that it consists of a noun, optionally preceded "
"and followed by modifiers:"
msgstr ""
"Теперь обратимся к сути фразы существительного - категории `NP2`.\n"
"Единственное правило для `NP2` гласит, что оно состоит из существительного, "
"которому могут предшествовать модификаторы и следовать за ним:"

#: in/chapter21.md:89
msgid ""
"```lisp\n"
"(rule (NP2 ?agr (common ?) ?x ?g1 ?g2 :sem) ==>\n"
"  (modifiers pre noun ?agr () ?x (gap nil) (gap nil) ?pre)\n"
"  (noun ?agr ?slots ?x ?noun)\n"
"  (modifiers post noun ?agr ?slots ?x ?g1 ?g2 ?post))\n"
"```"
msgstr ""

#: in/chapter21.md:91
msgid "## 21.2 Modifiers"
msgstr "## 21.2 Модификаторы(Modifiers)"

#: in/chapter21.md:97
msgid ""
"Modifiers are split into type types: *Complements* are modifiers that are "
"expected by the head category that is being modified; they cannot stand "
"alone.\n"
"*Adjuncts* are modifiers that are not required but bring additional "
"information.\n"
"The distinction is clearest with verb modifiers.\n"
"In \"Kim visited Lee yesterday,\" \"visited\" is the head verb, \"Lee\" is a "
"complement, and \"yesterday\" is an adjunct.\n"
"Returning to nouns, in \"the former mayor of Boston,\" \"mayor\" is the head "
"noun, \"of Boston\" is a complement (although an optional one) and \"former"
"\" is an adjunct."
msgstr ""
"Модификаторы делятся на типы: *Дополнения*(*Complements*) - это "
"модификаторы, ожидаемые изменяемой категорией заголовка; они не могут "
"оставаться в одиночестве.\n"
"*Адъюнкты/Добавка*(Adjuncts) - это модификаторы, которые не требуются, но "
"несут дополнительную информацию.\n"
"Различие наиболее очевидно с модификаторами глаголов.\n"
"В \"Kim visited Lee yesterday\"(Ким посетил Ли вчера), \"visited\"(посетил) "
"- это заглавный глагол, \"Lee\"(Ли) - дополнение(complement), а \"yesterday"
"\"(вчера) - добавочное(adjunct).\n"
"Возвращаясь к существительным, в \"the former mayor of Boston\"(бывший мэр "
"Бостона) \"mayor\"(мэр) является заглавным существительным, \"of Boston"
"\"(Бостона) - дополнением (хотя и необязательным), а \"former\"(бывший) - "
"добвкой(adjunct)."

#: in/chapter21.md:108
msgid ""
"The predicate `modifiers` takes eight arguments, so it can be tricky to "
"understand them all.\n"
"The first two arguments tell if we are before or after the head (`pre` or "
"`post`) and what kind of head we are modifying (`noun`, `verb`, or "
"whatever).\n"
"Next is an argument that passes along any required information-in the case "
"of nouns, it is the agreement feature.\n"
"The fourth argument is a list of expected complements, here called `?"
"slots`.\n"
"Next is the metavariable used to refer to the head.\n"
"The final three arguments are the two gap accumulators and the semantics, "
"which work the same way here as we have seen before.\n"
"Notice that the lexicon entry for each `Noun` can have a list of complements "
"that are considered as postnoun modifiers, but there can be only adjuncts as "
"prenoun modifiers.\n"
"Also note that gaps can appear in the postmodifiers but not in the "
"premodifiers.\n"
"For example, we can have \"What is Kevin the former mayor of &blank;?,\" "
"where the answer might be \"Boston.\"\n"
"But even though we can construct a noun phrase like \"the education "
"president,\" where \"education\" is a prenoun modifier of \"president,\" we "
"cannot construct \"* What is George the &blank; president?,\" intending that "
"the answer be \"education.\""
msgstr ""
"Предикат `modifiers` принимает восемь аргументов, поэтому понять их все "
"может быть сложно.\n"
"Первые два аргумента говорят, находимся ли мы до или после головы (`pre` или "
"`post`) и какой тип головы мы изменяем (`noun`(существительное), "
"`verb`(глагол) или что-то еще).\n"
"Далее идет аргумент, который передает всю необходимую информацию - в случае "
"с существительными это признак согласования(agreement).\n"
"Четвертый аргумент - это список ожидаемых дополнений(complements), здесь "
"называемых `?slots`.\n"
"Далее следует метапеременная, используемая для обозначения головы.\n"
"Последние три аргумента - это два аккумулятора разрывов и семантика, которые "
"здесь работают так же, как мы видели ранее.\n"
"Обратите внимание, что в лексиконе для каждого `Noun`(Существительного) "
"может быть список дополнений(complements), которые рассматриваются как "
"модификаторы пост-существительного(postnoun), но в качестве модификаторов "
"перед существительным могут быть только добления(adjuncts).\n"
"Также обратите внимание, что разрывы могут появляться в постмодификаторах, "
"но не в предмодификаторах.\n"
"Например, у нас может быть \"What is Kevin the former mayor of &blank;?"
"\"(Кто такой Кевин, бывший мэр &blank;?), где ответ может быть \"Boston"
"\"(Бостон).\n"
"Но даже несмотря на то, что мы можем построить фразу существительного, "
"например \"the education president\"(президент образования), где \"education"
"\"(образование) является пред-существительным модификатором  \"president"
"\"(президент), мы не можем построить \"* What is George the &blank; "
"president?,\"(Что такое Джордж, президент?), имея в виду, что ответом будет "
"\"education\"(образование)."

#: in/chapter21.md:115
msgid ""
"There are four cases for modification.\n"
"First, a complement is a kind of modifier.\n"
"Second, if a complement is marked as optional, it can be skipped.\n"
"Third, an adjunct can appear in the input.\n"
"Fourth, if there are no complements expected, then there need not be any "
"modifiers at all.\n"
"The following rules implement these four cases:"
msgstr ""
"Возможны четыре варианта модификации.\n"
"Во-первых, дополнение(complement) - это своего рода модификатор.\n"
"Во-вторых, если дополнение помечено как необязательное, его можно "
"пропустить.\n"
"В-третьих, на входе может появиться адъюнкт/добавка(adjunct).\n"
"В-четвертых, если не ожидается никаких дополнений, то никаких модификаторов "
"быть не должно.\n"
"Следующие правила реализуют эти четыре случая:"

#: in/chapter21.md:121
msgid ""
"```lisp\n"
"(rule (modifiers ?pre/post ?cat ?info (?slot . ?slots) ?h\n"
"                 ?g1 ?g3 :sem) ==>\n"
"  (complement ?cat ?info ?slot ?h ?g1 ?g2 ?mod)\n"
"  (modifiers ?pre/post ?cat ?info ?slots ?h ?g2 ?g3 ?mods))"
msgstr ""

#: in/chapter21.md:125
msgid ""
"(rule (modifiers ?pre/post ?cat ?info ((? (?) ?) . ?slots) ?h\n"
"                 ?g1 ?g2 ?mods) ==>\n"
"  (modifiers ?pre/post ?cat ?info ?slots ?h ?g1 ?g2 ?mods))"
msgstr ""

#: in/chapter21.md:129
msgid ""
"(rule (modifiers ?pre/post ?cat ?info ?slots ?h ?g1 ?g3 :sem) ==>\n"
"  (adjunct ?pre/post ?cat ?info ?h ?g1 ?g2 ?adjunct)\n"
"  (modifiers ?pre/post ?cat ?info ?slots ?h ?g2 ?g3 ?mods))"
msgstr ""

#: in/chapter21.md:132
msgid ""
"(rule (modifiers ? ? ? () ? ?g1 ?g1 t) ==> )\n"
"```"
msgstr ""

#: in/chapter21.md:138
msgid ""
"We need to say more about the list of complements, or slots, that can be "
"associated with words in the lexcion.\n"
"Each slot is a list of the form (*role number form),* where the role refers "
"to some semantic relation, the number indicates the ordering of the "
"complements, and the form is the type of constituent expected: noun phrase, "
"verb phrase, or whatever.\n"
"The details will be covered in the following section on verb phrases, and "
"`complement` will be covered in the section on XPs.\n"
"For now, we give a single example.\n"
"The complement list for one sense of the verb \"visit\" is:"
msgstr ""
"Нам нужно сказать больше о списке дополнений или слотов, которые могут быть "
"связаны со словами в лексиконе(lexcion).\n"
"Каждый слот представляет собой список формы (*role number form)*/(роль номер "
"форма), где роль относится к некоторому семантическому отношению, число "
"указывает порядок дополнений, а форма - это тип ожидаемого составляющего: "
"фраза существительного, глагольная фраза, или что угодно.\n"
"Подробности будут рассмотрены в следующем разделе о глагольных фразах, а  "
"`complement`/дополнение будет рассмотрено в разделе о XP.\n"
"А пока приведем единственный пример.\n"
"Список дополнений для одного смысла глагола \"visit\"(посетить):"

#: in/chapter21.md:142
msgid ""
"```lisp\n"
"((agt 1 (NP ?)) (obj 2 (NP ?)))\n"
"```"
msgstr ""

#: in/chapter21.md:144
msgid ""
"This means that the first complement, the subject, is a noun phrase that "
"fills the agent role, and the second complement is also a noun phrase that "
"fills the object role."
msgstr ""
"Это означает, что первое дополнение, субъект(подлежащее), является фразой "
"существительного, которая выполняет роль агента, а второе дополнение также "
"является фразой существительного, которая выполняет роль объекта."

#: in/chapter21.md:146
msgid "## 21.3 Noun Modifiers"
msgstr "## 21.3 Модификаторы существительных(Noun Modifiers)"

#: in/chapter21.md:151
msgid ""
"There are two main types of prenoun adjuncts.\n"
"Most common are adjectives, as in \"big slobbery dogs.\" Nouns can also be "
"adjuncts, as in \"water meter\" or \"desk lamp.\" Here it is clear that the "
"second noun is the head and the first is the modifier: a desk lamp is a "
"lamp, not a desk.\n"
"These are known as noun-noun compounds.\n"
"In the following rules, note that we do not need to say that more than one "
"adjective is allowed; this is handled by the rules for `modifiers`."
msgstr ""
"Есть два основных типа добавок/добавлений(adjuncts) пред существительных.\n"
"Чаще всего используются прилагательные(adjectives), например, \"big slobbery "
"dogs\"(большие слюнявые собаки). Существительные также могут быть "
"добавлениями(adjuncts), как в \"water meter\"(водомер) или \"desk lamp"
"\"(настольная лампа). Здесь ясно, что второе существительное - "
"голова(главное), а первое - модификатор: desk lamp(настольная лампа) - это "
"лампа, а не стол.\n"
"Они известны как соединения существительного и существительного.\n"
"В следующих правилах обратите внимание, что нам не нужно говорить, что "
"допускается более одного прилагательного(adjective); это обрабатывается "
"правилами для `modifiers`."

#: in/chapter21.md:155
msgid ""
"```lisp\n"
"(rule (adjunct pre noun ?info ?x ?gap ?gap ?sem) ==>\n"
"  (adj ?x ?sem))"
msgstr ""

#: in/chapter21.md:160
msgid ""
"(rule (adjunct pre noun ?info ?h ?gap ?gap :sem) ==>\n"
"  (:sem (noun-noun ?h ?x))\n"
"  (noun ?agr () ?x ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:164
msgid ""
"After the noun there is a wider variety of modifiers.\n"
"Some nouns have complements, which are primarily prepositional phrases, as "
"in \"mayor of Boston.\" These will be covered when we get to the lexical "
"entries for nouns.\n"
"Prepositional phrases can be adjuncts for nouns or verbs, as in \"man in the "
"middle\" and \"slept for an hour.\" We can write one rule to cover both "
"cases:"
msgstr ""
"После существительного существует более широкий набор модификаторов.\n"
"У некоторых существительных есть дополнения(complements), которые в основном "
"являются предложными фразами(prepositional phrases), например, \"mayor of "
"Boston\"(мэр Бостона). Они будут рассмотрены, когда мы перейдем к "
"лексическим статьям для существительных.\n"
"Предложные фразы могут быть добавлениями(adjuncts) к существительным или "
"глаголам, например, \"man in the middle\"(человек посередине) и \"slept for "
"an hour\"(поспал часок). Мы можем написать одно правило для обоих случаев:"

#: in/chapter21.md:169
msgid ""
"```lisp\n"
"(rule (adjunct post ?cat ?info ?x ?g1 ?g2 ?sem) ==>\n"
"  (PP ?prep ?prep ?wh ?np ?x ?g1 ?g2 ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:172
msgid ""
"Here are the rules for prepositional phrases, which can be either a "
"preposition followed by a noun phrase or can be gapped, as in \"to whom are "
"you speaking &blank;?\"\n"
"The object of a preposition is always in the objective case: \"with him\" "
"not \"*with he.\""
msgstr ""
"Вот правила для предложных фраз, которые могут быть либо "
"предлогом(preposition), за которым следует фраза существительного, либо "
"могут быть разрывом, например, \"to whom are you speaking &blank;?\"(с кем "
"вы говорите & blank;?)\n"
"Предлог всегда находится в объективном падеже: \"with him\"(с ним), а не "
"\"*with he\"(с ним???с него)."

#: in/chapter21.md:178
msgid ""
"```lisp\n"
"(rule (PP ?prep ?role ?wh ?np ?x ?g1 ?g2 :sem) ==>\n"
"  (prep ?prep t)\n"
"  (:sem (?role ?x ?np))\n"
"  (NP ?agr (common obj) ?wh ?np ?g1 ?g2 ?np-sem))"
msgstr ""

#: in/chapter21.md:182
msgid ""
"(rule (PP ?prep ?role ?wh ?np ?x\n"
"          (gap (PP ?prep ?role ?np ?x)) (gap nil) t) ==> )\n"
"```"
msgstr ""

#: in/chapter21.md:187
msgid ""
"Nouns can be modified by present participles, past participles, and relative "
"clauses.\n"
"Examples are \"the man eating the snack,\" \"the snack eaten by the man,\" "
"and \"the man that ate the snack,\" respectively.\n"
"We will see that each verb in the lexicon is marked with an inflection, and "
"that the marker `-ing` is used for present participles while `-en` is used "
"for past participles.\n"
"The details of the `clause` will be covered later."
msgstr ""
"Существительные могут быть изменены причастиями(participles) настоящего "
"времени, причастиями прошедшего времени и относительными придаточными "
"предложениями.\n"
"Примерами являются \"the man eating the snack\"(мужчина, который ест "
"закуску), \"the snack eaten by the man\"(закуска, которую съел мужчина) и "
"\"the man that ate the snack\"(мужчина, который ел закуску) соответственно.\n"
"Мы увидим, что каждый глагол в лексиконе помечен перегибом(inflection), и "
"что маркер `-ing` используется для причастий настоящего времени, а `-en` - "
"для причастий прошедшего времени.\n"
"Детали `clause` будут рассмотрены позже."

#: in/chapter21.md:193
msgid ""
"```lisp\n"
"(rule (adjunct post noun ?agr ?x ?gap ?gap ?sem) ==>\n"
"  (:ex (the man) \"visiting me\" (the man) \"visited by me\")\n"
"  (:test (member ?infl (-ing passive)))\n"
"  (clause ?infl ?x ? ?v (gap (NP ?agr ? ?x)) (gap nil) ?sem))"
msgstr ""

#: in/chapter21.md:197
msgid ""
"(rule (adjunct post noun ?agr ?x ?gap ?gap ?sem) ==>\n"
"  (rel-clause ?agr ?x ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:200
msgid ""
"It is possible to have a relative clause where it is an object, not the "
"subject, that the head refers to: \"the snack that the man ate.\" In this "
"kind of relative clause the relative pronoun is optional: \"The snack the "
"man ate was delicious.\" The following rules say that if the relative "
"pronoun is omitted then the noun that is being modified must be an object, "
"and the relative clause should include a subject internally.\n"
"The constant `int-subj` indicates this."
msgstr ""
"Возможно иметь относительное предложение, в котором речь идет об объекте, а "
"не о субъекте: \"the snack that the man ate\"(закуска, которую съел "
"человек). В таком относительном предложении относительное местоимение "
"необязательно: \"The snack the man ate was delicious\"(Закуска, которую ел "
"человек, была восхитительна). Следующие правила гласят, что если "
"относительное местоимение опущено, то изменяемое существительное должно быть "
"объектом, а относительное предложение должно включать подлежащее внутри.\n"
"На это указывает константа `int-subj`."

#: in/chapter21.md:208
msgid ""
"```lisp\n"
"(rule (rel-clause ?agr ?x :sem) ==>\n"
"  (:ex (the man) \"that she liked\" \"that liked her\"\n"
"       \"that I know Lee liked\")\n"
"  (opt-rel-pronoun ?case ?x ?int-subj ?rel-sem)\n"
"  (clause (finite ? ?) ? ?int-subj ?v\n"
"          (gap (NP ?agr ?case ?x)) (gap nil) ?clause-sem))"
msgstr ""

#: in/chapter21.md:212
msgid ""
"(rule (opt-rel-pronoun ?case ?x ?int-subj (?type ?x)) ==>\n"
"  (:word ?rel-pro)\n"
"  (:test (word ?rel-pro rel-pro ?case ?type)))"
msgstr ""

#: in/chapter21.md:215
msgid ""
"(rule (opt-rel-pronoun (common obj) ?x int-subj t) ==> )\n"
"```"
msgstr ""

#: in/chapter21.md:217
msgid ""
"It should be noted that it is rare but not impossible to have names and "
"pronouns with modifiers: \"John the Baptist,\" \"lovely Rita, meter maid,\" "
"\"Lucy in the sky with diamonds,\" \"Sylvia in accounting on the 42nd floor,"
"\" \"she who must be obeyed.\" Here and throughout this chapter we will "
"raise the possibility of such rare cases, leaving them as exercises for the "
"reader."
msgstr ""
"Следует отметить, что редко, но возможно, встречаются имена и местоимения с "
"модификаторами: \"John the Baptist\"(Иоанн Креститель), «прекрасная Рита, "
"метровая горничная», «Люси в небе с бриллиантами», «Сильвия в бухгалтерии на "
"42 этаже. , \"\" та, которой нужно повиноваться \". Здесь и в этой главе мы "
"будем поднимать вероятность таких редких случаев, оставляя их в качестве "
"упражнений для читателя."

#: in/chapter21.md:219
msgid "## 21.4 Determiners"
msgstr "## 21.4 Определители(Determiners)"

#: in/chapter21.md:223
msgid ""
"We will cover three kinds of determiners.\n"
"The simplest is the article: \"a dog\" or \"the dogs.\" We also allow "
"genitive pronouns, as in \"her dog,\" and numbers, as in \"three dogs.\" The "
"semantic interpretation of a determiner-phrase is of the form (*quantifier "
"variable restriction*).\n"
"For example, `(a ?x (dog ?x) )` or `((number 3) ?x (dog ?x))`."
msgstr ""
"Мы рассмотрим три типа определителей.\n"
"Самым простым является артикль: «собака» или «собаки». Также разрешены "
"местоимения в родительном падеже, например «ее собака», и числа, например, "
"«три собаки». Семантическая интерпретация определителя-фразы имеет форму (* "
"ограничение переменной квантификатора *).\n"
"Например, `(a? X (dog? X))` или `((number 3)? X (dog? X))`."

#: in/chapter21.md:229
msgid ""
"```lisp\n"
"(rule (Det ?agr ?wh ?x ?restriction (?art ?x ?restriction)) ==>\n"
"  (:ex \"the\" \"every\")\n"
"  (art ?agr ?art)\n"
"  (:test (if (= ?art wh) (= ?wh +wh) (= ?wh -wh))))"
msgstr ""

#: in/chapter21.md:234
msgid ""
"(rule (Det ?agr ?wh ?x ?r (the ?x ?restriction)) ==>\n"
"  (:ex \"his\" \"her\")\n"
"  (pronoun ?agr gen ?wh ?y ?sem)\n"
"  (:test (and* ((genitive ?y ?x) ?sem ?r) ?restriction)))"
msgstr ""

#: in/chapter21.md:239
msgid ""
"(rule (Det ?agr -wh ?x ?r ((number ?n) ?x ?r)) ==>\n"
"  (:ex \"three\")\n"
"  (cardinal ?n ?agr))\n"
"```"
msgstr ""

#: in/chapter21.md:244
msgid ""
"These are the most important determiner types, but there are others, and "
"there are pre- and postdeterminers that combine in restricted combinations.\n"
"Predeterminers include all, both, half, double, twice, and such.\n"
"Postdeterminers include every, many, several, and few.\n"
"Thus, we can say \"all her many good ideas\" or \"all the King's men.\" But "
"we can not say \"*all much ideas\" or \"*the our children.\" The details are "
"complicated and are omitted from this grammar."
msgstr ""
"Это наиболее важные типы детерминаторов, но есть и другие, и есть пре- и "
"постдетерминаторы, которые объединяются в ограниченные комбинации.\n"
"Предопределители включают все, оба, половину, двойную, двойную и тому "
"подобное.\n"
"Постдетерминаторы включают каждый, многие, несколько и несколько.\n"
"Таким образом, мы можем сказать «все ее многочисленные хорошие идеи» или "
"«все люди короля». Но мы не можем сказать «* все много идей» или «* наши "
"дети». Детали сложны и опускаются в этой грамматике."

#: in/chapter21.md:246
msgid "## 21.5 Verb Phrases"
msgstr "## 21.5 Глагольные фразы(Verb Phrases)"

#: in/chapter21.md:250
msgid ""
"Now that we have defined `modifiers`, verb phrases are easy.\n"
"In fact, we only need two rules.\n"
"The first says a verb phrase consists of a verb optionally preceded and "
"followed by modifiers, and that the meaning of the verb phrase includes the "
"fact that the subject fills some role:"
msgstr ""
"Теперь, когда мы определили `модификаторы`, глагольные фразы сделать проще.\n"
"На самом деле нам нужно всего два правила.\n"
"Первая гласит, что глагольная фраза состоит из глагола, которому "
"необязательно предшествуют модификаторы, и что значение глагольной фразы "
"включает тот факт, что подлежащее выполняет некоторую роль:"

#: in/chapter21.md:259
msgid ""
"```lisp\n"
"(rule (VP ?infl ?x ?subject-slot ?v ?g1 ?g2 :sem) ==>\n"
"  (:ex \"sleeps\" \"quickly give the dog a bone\")\n"
"  (modifiers pre verb ? () ?v (gap nil) (gap nil) ?pre-sem)\n"
"  (:sem (?role ?x ?v)) (:test (= ?subject-slot (?role 1 ?)))\n"
"  (verb ?verb ?infl (?subject-slot . ?slots) ?v ?v-sem)\n"
"  (modifiers post verb ? ?slots ?v ?g1 ?g2 ?mod-sem))\n"
"```"
msgstr ""

#: in/chapter21.md:267
msgid ""
"The `VP` category takes seven arguments.\n"
"The first is an inflection, which represents the tense of the verb.\n"
"To describe the possibilities for this argument we need a quick review of "
"some basic linguistics.\n"
"A sentence must have a *finite* verb, meaning a verb in the present or past "
"tense.\n"
"Thus, we say \"Kim likes Lee,\" not \"*Kim liking Lee.\" Subject-predicate "
"agreement takes effect for finite verbs but not for any other tense.\n"
"The other tenses show up as complements to other verbs.\n"
"For example, the complement to \"want\" is an infinitive: \"Kim wants *to "
"like* Lee\" and the complement to the modal auxiliary verb \"would\" is a "
"nonfinite verb: \"Kim would *like* Lee.\" If this were in the present tense, "
"it would be \"likes,\" not \"like.\" The inflection argument takes on one of "
"the forms in the table here:"
msgstr ""
"Категория VP принимает семь аргументов.\n"
"Первый - это склонение/изменение(inflection), которое представляет собой "
"время глагола.\n"
"Чтобы описать возможности этого аргумента, нам нужен быстрый обзор некоторых "
"основ лингвистики.\n"
"В предложении должен быть *конечный* глагол(*finite* verb), означающий "
"глагол в настоящем или прошедшем времени.\n"
"Таким образом, мы говорим: \"Kim likes Lee,\"(Ким нравится Ли), а не \"*Kim "
"liking Lee\". Согласование подлежащего(субьекта) и сказуемого(предиката) "
"действует для конечных глаголов, но не для любого другого времени.\n"
"Другие времена появляются как дополнения к другим глаголам.\n"
"Например, дополнение к \"want\" - это инфинитив: \"Kim wants *to like* Lee"
"\"(Kim хочет *нравиться* Lee), а дополнение к модальному вспомогательному "
"глаголу \"would\" - это не бесконечный глагол: \"Kim would *like* Lee.\". "
"Если бы это было в настоящем времени, это было бы \"likes\", а не \"like\". "
"Аргумент склонения/изменения принимает одну из форм в таблице:"

#: in/chapter21.md:276
msgid ""
"| Expression              | Type               | Example   |\n"
"|-------------------------|--------------------|-----------|\n"
"| `(finite ?agr present)` | present tense      | eat, eats |\n"
"| `(finite ?agr past)`    | past tense         | ate       |\n"
"| `nonfinite`             | nonfinite          | eat       |\n"
"| `infinitive`            | infinitive         | to eat    |\n"
"| `-en`                   | past participle    | eaten     |\n"
"| `-ing`                  | present participle | eating    |"
msgstr ""

#: in/chapter21.md:284
msgid ""
"The second argument is a metavariable that refers to the subject, and the "
"third is the subject's complement slot.\n"
"We adopt the convention that the subject slot must always be the first among "
"the verb's complements.\n"
"The other slots are handled by the postverb modifiers.\n"
"The fourth argument is a metavariable indicating the verb phrase itself.\n"
"The final three are the familiar gap and semantics arguments.\n"
"As an example, if the verb phrase is the single word \"slept,\" then the "
"semantics of the verb phrase will be `(and (past ?v) (sleep ?v))`.\n"
"Of course, adverbs, complements, and adjuncts will also be handled by this "
"rule."
msgstr ""
"Второй аргумент - это метапеременная, которая относится к субъекту, а третий "
"- слот дополнения субъекта.\n"
"Мы принимаем соглашение, согласно которому слот подлежащего всегда должен "
"быть первым среди дополнений глагола.\n"
"Остальные слоты обрабатываются модификаторами postverb.\n"
"Четвертый аргумент - это метапеременная, указывающая саму глагольную фразу.\n"
"Последние три - знакомые аргументы разрыв и семантика(и третий???).\n"
"Например, если глагольная фраза представляет собой единственное слово \"slept"
"\"спал), то семантика глагольной фразы будет `(and (past ?v) (sleep ?v))`.\n"
"Конечно, по этому правилу также будут обрабатываться наречия(adverbs), "
"дополнения(complements) и добавления(adjuncts)."

#: in/chapter21.md:289
msgid ""
"The second rule for verb phrases handles auxiliary verbs, such as \"have,\" "
"\"is\" and \"would.\" Each auxiliary verb (or `aux`) produces a verb phrase "
"with a particular inflection when followed by a verb phrase with the "
"required inflection.\n"
"To repeat an example, \"would\" produces a finite phrase when followed by a "
"nonfinite verb.\n"
"\"Have\" produces a nonfinite when followed by a past participle.\n"
"Thus, \"would have liked\" is a finite verb phrase."
msgstr ""
"Второе правило для глагольных фраз касается вспомогательных "
"глаголов(auxiliary verbs), таких как \"have\"(иметь), \"is\"(есть) и \"would"
"\"(будет). Каждый вспомогательный глагол (или `aux`) производит глагольную "
"фразу с определенным изменением/склонением, когда за ней следует глагольная "
"фраза с требуемым изменением.\n"
"Чтобы повторить пример, \"would\"(будет) дает конечную фразу, за которой "
"следует бесконечный(nonfinite) глагол.\n"
"\"Have\" дает неопределенное значение, если за ним следует причастие "
"прошедшего времени.\n"
"Таким образом, \"would have liked\" - это конечная глагольная фраза."

#: in/chapter21.md:293
msgid ""
"We also need to account for negation.\n"
"The word \"not\" can not modify a bare main verb but can follow an auxiliary "
"verb.\n"
"That is, we can't say \"*Kim not like Lee,\" but we can add an auxiliary to "
"get \"Kim does not like Lee.\""
msgstr ""
"Мы также должны учитывать отрицание.\n"
"Слово \"not\"(не) может изменять основной глагол, но может следовать за "
"вспомогательным глаголом.\n"
"То есть мы не можем сказать \"*Kim not like Lee\"(Ким не любит Ли), но мы "
"можем добавить вспомогательный элемент, чтобы получить \"Kim does not like "
"Lee.\"."

#: in/chapter21.md:302
msgid ""
"```lisp\n"
"(rule (VP ?infl ?x ?subject-slot ?v ?g1 ?g2 :sem) ==>\n"
"  (:ex \"is sleeping\" \"would have given a bone to the dog.\"\n"
"       \"did not sleep\" \"was given a bone by this old man\")\n"
"  ;; An aux verb, followed by a VP\n"
"  (aux ?infl ?needs-infl ?v ?aux)\n"
"  (modifiers post aux ? () ?v (gap nil) (gap nil) ?mod)\n"
"  (VP ?needs-infl ?x ?subject-slot ?v ?g1 ?g2 ?vp))"
msgstr ""

#: in/chapter21.md:306
msgid ""
"(rule (adjunct post aux ? ?v ?gap ?gap (not ?v)) ==>\n"
"  (:word not))\n"
"```"
msgstr ""

#: in/chapter21.md:308
msgid "## 21.6 Adverbs"
msgstr "## 21.6 Наречия(Adverbs)"

#: in/chapter21.md:311
msgid ""
"Adverbs can serve as adjuncts before or after a verb: \"to boldly go,\" \"to "
"go boldly.\" There are some limitations on where they can occur, but it is "
"difficult to come up with firm rules; here we allow any adverb anywhere.\n"
"We define the category `advp` for adverbial phrase, but currently restrict "
"it to a single adverb."
msgstr ""
"Наречия могут служить дополнением до или после глагола: \"to boldly go"
"\"(смело идти), \"to go boldly\". Существуют некоторые ограничения "
"относительно того, где они могут возникать, но трудно придумать твердые "
"правила; здесь мы разрешаем любое наречие где угодно.\n"
"Мы определяем категорию `advp` для фразы наречия, но в настоящее время "
"ограничиваем ее одним наречием."

#: in/chapter21.md:315
msgid ""
"```lisp\n"
"(rule (adjunct ?pre/post verb ?info ?v ?g1 ?g2 ?sem) ==>\n"
"  (advp ?wh ?v ?g1 ?g2 ?sem))"
msgstr ""

#: in/chapter21.md:318
msgid ""
"(rule (advp ?wh ?v ?gap ?gap ?sem) ==>\n"
"  (adverb ?wh ?v ?sem))"
msgstr ""

#: in/chapter21.md:321
msgid ""
"(rule (advp ?wh ?v (gap (advp ?v)) (gap nil) t) ==> )\n"
"```"
msgstr ""

#: in/chapter21.md:323
msgid "## 21.7 Clauses"
msgstr "## 21.7 Предложения(Clauses)"

#: in/chapter21.md:328
msgid ""
"A clause consists of a subject followed by a predicate.\n"
"However, the subject need not be realized immediately before the predicate.\n"
"For example, in \"Alice promised Bob to lend him her car\" there is an inf "
"initive clause that consists of the predicate \"to lend him her car\" and "
"the subject \"Alice.\" The sentence as a whole is another clause.\n"
"In our analysis, then, a clause is a subject followed by a verb phrase, with "
"the possibility that the subject will be instantiated by something from the "
"gap arguments:"
msgstr ""
"Предложение состоит из подлежащего/субъекта(subject ), за которым следует "
"предикат/сказуемое(predicate).\n"
"Однако субъект не обязательно должен быть реализован непосредственно перед "
"сказуемым.\n"
"Например, в фразе \"Alice promised Bob to lend him her car\"(Алиса обещала "
"Бобу одолжить ему свою машину) есть инфинитивное предложение, которое "
"состоит из предиката \"to lend him her car\"(одолжить ему свою машину) и "
"подлежащего \"Alice\"(Алиса). Высказывание(sentence) в целом - это еще одно "
"предложение.\n"
"Таким образом, в нашем анализе предложение - это подлежащее, за которым "
"следует глагольная фраза, с возможностью того, что субъект будет "
"конкретизирован каким-то из аргументов разрыва:"

#: in/chapter21.md:335
msgid ""
"```lisp\n"
"(rule (clause ?infl ?x ?int-subj ?v ?gap1 ?gap3 :sem) ==>\n"
"  (subject ?agr ?x ?subj-slot ?int-subj ?gap1 ?gap2 ?subj-sem)\n"
"  (VP ?infl ?x ?subj-slot ?v ?gap2 ?gap3 ?pred-sem)\n"
"  (:test (subj-pred-agree ?agr ?infl)))\n"
"```"
msgstr ""

#: in/chapter21.md:344
msgid ""
"There are now two possibilities for `subject`.\n"
"In the first case it has already been parsed, and we pick it up from the gap "
"list.\n"
"If that is so, then we also need to find the agreement feature of the "
"subject.\n"
"If the subject was a noun phrase, the agreement will be present in the gap "
"list.\n"
"If it was not, then the agreement is third-person singular.\n"
"An example of this is \" *That the Red Sox won* surprises me,\" where the "
"italicized phrase is a non-NP subject.\n"
"The fact that we need to use \"surprises\" and not \"surprise\" indicates "
"that it is third-person singular.\n"
"We will see that the code `(- - + -)` is used for this."
msgstr ""
"Теперь есть две возможности для `subject`.\n"
"В первом случае он уже проанализирован, и мы берем его из списка "
"gap(разрыва).\n"
"Если это так, то нам также необходимо найти признак согласования субьекта.\n"
"Если субьектом была фраза существительного, соглашение будет присутствовать "
"в списке разрывов.\n"
"Если его не было, то согласование от третьего лица единственного числа.\n"
"Примером этого является \" *That the Red Sox won* surprises me\"(Что Red Sox "
"выиграл меня удивляет), где выделенная курсивом фраза субьект не-NP.\n"
"Тот факт, что нам нужно использовать \"surprises\"(сюрпризы), а не \"surprise"
"\"(удивление), указывает на то, что это слово от третьего лица единственного "
"числа.\n"
"Мы увидим, что для этого используется код `(- - + -)`."

#: in/chapter21.md:354
msgid ""
"```lisp\n"
"(rule (subject ?agree ?x ?subj-slot ext-subj\n"
"               (gap ?subj) (gap nil) t) ==>\n"
"  ;; Externally realized subject (the normal case for S)\n"
"  (:test (slot-constituent ?subj-slot ?subj ?x ?)\n"
"         (if (= ?subj (NP ?agr ?case ?x))\n"
"             (= ?agree ?agr)\n"
"             (= ?agree (- - + -))))) ;Non-NP subjects are 3sing\n"
"```"
msgstr ""

#: in/chapter21.md:359
msgid ""
"In the second case we just parse a noun phrase as the subject.\n"
"Note that the fourth argument to `subject` is either `ext-subj` or `int-"
"subj` depending on if the subject is realized internally or externally.\n"
"This will be important when we cover sentences in the next section.\n"
"In case it was not already clear, the second argument to both `clause` and "
"`subject` is the metavariable representing the subject."
msgstr ""
"Во втором случае мы просто разбираем именную фразу как подлежащее.\n"
"Обратите внимание, что четвертый аргумент для `subject` - это `ext-subj` или "
"`int-subj` в зависимости от того, реализуется ли субъект внутренне или "
"внешне.\n"
"Это будет важно, когда мы рассмотрим предложения в следующем разделе.\n"
"Если это еще не было ясно, второй аргумент для `clause` и `subject` - это "
"метапеременная, представляющая тему."

#: in/chapter21.md:365
msgid ""
"```lisp\n"
"(rule (subject ?agr ?x (?role 1 (NP ?x)) int-subj ?gap ?gap ?sem)\n"
"  ==>\n"
"  (NP ?agr (common nom) ?wh ?x (gap nil) (gap nil) ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:367
msgid ""
"Finally, the rules for subject-predicate agreement say that only finite "
"predicates need to agree with their subject:"
msgstr ""
"Наконец, правила согласования субъект-предикат говорят, что только конечные "
"предикаты должны согласовываться со своим субъектом:"

#: in/chapter21.md:372
msgid ""
"```lisp\n"
"(<- (subj-pred-agree ?agr (finite ?agr ?)))\n"
"(<- (subj-pred-agree ? ?infl) (atom ?infl))\n"
"```"
msgstr ""

#: in/chapter21.md:374
msgid "## 21.8 Sentences"
msgstr "## 21.8 Изречения/Утверждения/Высказывания(Sentences)"

#: in/chapter21.md:380
msgid ""
"In the previous chapter we allowed only simple declarative sentences.\n"
"The current grammar supports commands and four kinds of questions in "
"addition to declarative sentences.\n"
"It also supports *thematic fronting:* placing a nonsubject at the beginning "
"of a sentence to emphasize its importance, as in \"*Smith* he says his name "
"is\" or *\"Murder,* she wrote\" or *\"ln God* we trust.\" In the last "
"example it is a prepositional phrase, not a noun phrase, that occurs first.\n"
"It is also possible to have a subject that is not a noun phrase: *\"That the "
"dog didn't bark* puzzled Holmes.\" To support all these possibilities, we "
"introduce a new category, `XP`, which stands for any kind of phrase.\n"
"A declarative sentence is then just an XP followed by a clause, where the "
"subject of the clause may or may not turn out to be the XP:"
msgstr ""
"В предыдущей главе мы разрешили использовать только простые "
"повествовательные предложения.\n"
"Текущая грамматика поддерживает команды и четыре типа вопросов в дополнение "
"к декларативным предложениям.\n"
"Она также поддерживает *тематическое оформление:* размещение не "
"субъекта(nonsubject) в начале предложения, чтобы подчеркнуть его важность, "
"например, в словах \"*Smith* he says his name is\"(Смит он говорит, что его "
"зовут) или *\"Murder,* she wrote\"(Убийство, написала она) или *\"In God* we "
"trust\"(В Бога мы верим). В последнем примере первой встречается "
"предложная(prepositional phrase), а не фраза существительного.\n"
"Также возможно иметь субъект, который не является фразой существительного: *"
"\"That the dog didn't bark* puzzled Holmes.\"(То, что собака не лаяла, "
"озадачило Холмса). Для поддержки всех этих возможностей мы вводим новую "
"категорию `XP`, которая обозначает любые фразы.\n"
"Тогда декларативное предложение - это просто XP, за которым следует "
"предложение, где предметом предложения может оказаться, а может и не "
"оказаться XP:"

#: in/chapter21.md:388
msgid ""
"```lisp\n"
"(rule (S ?s :sem) ==>\n"
"  (:ex \"Kim likes Lee\" \"Lee, I like _\" \"In god, we trust _\"\n"
"       \"Who likes Lee?\" \"Kim likes who?\")\n"
"  (XP ?kind ?constituent ?wh ?x (gap nil) (gap nil) ?topic-sem)\n"
"  (clause (finite ? ?) ?x ? ?s (gap ?constituent) (gap nil) ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:391
msgid ""
"As it turns out, this rule also serves for two types of questions.\n"
"The simplest kind of question has an interrogative noun phrase as its "
"subject: \"Who likes Lee?\" or \"What man likes Lee?\" Another kind is the "
"so-called *echo question*, which can be used only as a reply to another "
"statement: if I tell you Kim likes Jerry Lewis, you could reasonably reply "
"\"Kim likes *who*?\" Both these question types have the same structure as "
"declarative sentences, and thus are handled by the same rule."
msgstr ""
"Как оказалось, это правило также служит для двух типов вопросов.\n"
"В самом простом вопросе предметом является вопросительная фраза "
"существителього: \"Who likes Lee?\"(Кому нравится Ли?) или \"What man likes "
"Lee?\"(Какой мужчина любит Ли?). Другой вид - это так называемый *вопрос-эхо "
"*, который может использоваться только как ответ на другое утверждение: если "
"я скажу вам, что Ким нравится Джерри Льюис, вы можете разумно ответить: "
"\"Kim likes *who*?\"(Ким нравится *кто*?). Оба эти типа вопросов имеют ту же "
"структуру, что и повествовательные предложения, и поэтому обрабатываются "
"одним и тем же правилом."

#: in/chapter21.md:393
msgid ""
"The following table lists some sentences that can be parsed by this rule, "
"showing the XP and subject of each."
msgstr ""
"В следующей таблице перечислены некоторые изречения, которые могут быть "
"проанализированы с помощью этого правила, с указанием опыта и темы каждого "
"из них."

#: in/chapter21.md:401
msgid ""
"| Sentence                  | XP                 | Subject            |\n"
"|---------------------------|--------------------|--------------------|\n"
"| Kim likes Lee             | Kim                | Kim                |\n"
"| Lee, Kim likes            | Lee                | Kim                |\n"
"| In god, we trust          | In god             | we                 |\n"
"| That Kim likes Lee amazes | That Kim likes Lee | That Kim likes Lee |\n"
"| Who likes Lee?            | Who                | Who                |"
msgstr ""

#: in/chapter21.md:405
msgid ""
"The most common type of command has no subject at all: \"Be quiet\" or \"Go "
"to your room.\" When the subject is missing, the meaning is that the command "
"refers to *you*, the addressee of the command.\n"
"The subject can also be mentioned explicitly, and it can be \"you,\" as in "
"\"You be quiet,\" but it need not be: \"Somebody shut the door\" or "
"\"Everybody sing along.\" We provide a rule only for commands with subject "
"omitted, since it can be difficult to distinguish a command with a subject "
"from a declarative sentence.\n"
"Note that commands are always nonfinite."
msgstr ""
"Самый распространенный тип команды вообще не имеет темы: \"Be quiet\"(Тихо) "
"или \"Go to your room\"(Иди в свою комнату). Если тема отсутствует, это "
"означает, что команда относится к *вам*, адресату команды.\n"
"Субъект также может быть упомянута явно, и это может быть \"you\"(ты), "
"например \"You be quiet\"(ты - молчи), но это не обязательно: \"Somebody "
"shut the door\"(Кто-нибудь, закройте дверь) или \"Everybody sing along\"(Все "
"подпевают). Мы предоставляем правило только для команд с опущенным "
"субъектом, так как бывает сложно отличить команду с субъектом от "
"декларативного предложения.\n"
"Обратите внимание, что команды всегда не бесконечны(nonfinite)."

#: in/chapter21.md:415
msgid ""
"```lisp\n"
"(rule (S ?s :sem) ==>\n"
"  ;; Commands have implied second-person subject\n"
"  (:ex \"Give the dog a bone.\")\n"
"  (:sem (command ?s))\n"
"  (:sem (listener ?x))\n"
"  (clause nonfinite ?x ext-subj ?s\n"
"          (gap (NP ? ? ?x)) (gap nil) ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:417
msgid ""
"Another form of command starts with \"let,\" as in \"Let me see what I can do"
"\" and \"Let us all pray.\" The second word is better considered as the "
"object of \"let\" rather than the subject of the sentence, since the subject "
"would have to be \"I\" or \"we.\" This kind of command can be handled with a "
"lexical entry for \"let\" rather than with an additional rule."
msgstr ""
"Другая форма команды начинается с \"let\"(давай), например, \"Let me see "
"what I can do\"(дай мне посмотреть, что я могу сделать) и \"Let us all pray"
"\"(давайте все помолимся). Второе слово лучше рассматривать как объект \"let"
"\", а не как подлежащее в предложении, так как подлежащим должно быть \"I"
"\"(я) или \"we\"(мы). Этот вид команд может обрабатываться с помощью "
"лексической записи для \"let\", а не с помощью дополнительного правила."

#: in/chapter21.md:421
msgid ""
"We now consider questions.\n"
"Questions that can be answered by yes or no have the subject and auxiliary "
"verb inverted: \"Did you see him?\" or \"Should I have been doing this?\" "
"The latter example shows that it is only the first auxiliary verb that comes "
"before the subject.\n"
"The category `aux-inv-S` is used to handle this case:"
msgstr ""
"Теперь рассмотрим вопросы(questions).\n"
"В вопросах, на которые можно ответить положительно или отрицательно, "
"подлежащее и вспомогательный глагол меняются местами: \"Did you see him?"
"\"(Вы его видели?). или \"Should I have been doing this?\"(Я должен был это "
"делать?) Последний пример показывает, что перед подлежащим(субъектом) стоит "
"только первый вспомогательный глагол.\n"
"Категория `aux-inv-S` используется для обработки этого случая:"

#: in/chapter21.md:427
msgid ""
"```lisp\n"
"(rule (S ?s (yes-no ?s ?sem)) ==>\n"
"  (:ex \"Does Kim like Lee?\" \"Is he a doctor?\")\n"
"  (aux-inv-S nil ?s ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:429
msgid ""
"Questions that begin with a wh-phrase also have the auxiliary verb before "
"the subject, as in \"Who did you see?\" or \"Why should I have been doing "
"this?\" The first constituent can also be a prepositional phrase: \"For whom "
"am I doing this?\" The following rule parses an XP that must have the  `+wh` "
"feature and then parses an `aux-inv-S` to arrive at a question:"
msgstr ""
"Вопросы, начинающиеся с wh-фразы, также имеют перед подлежащим "
"вспомогательный глагол, например, \"Who did you see?\"(Кого вы видели?) или "
"\"Why should I have been doing this?\"(Почему я должен был это делать?) "
"Первая составляющая также может быть предложной фразой: \"For whom am I "
"doing this?\"(Для кого я это делаю?) Следующее правило анализирует XP, "
"которая должна иметь функцию `+wh`, а затем анализирует `aux-inv-S`, чтобы "
"прийти к вопросу:"

#: in/chapter21.md:437
msgid ""
"```lisp\n"
"(rule (S ?s :sem) ==>\n"
"  (:ex \"Who does Kim like _?\" \"To whom did he give it _?\"\n"
"       \"What dog does Kim like _?\")\n"
"  (XP ?slot ?constituent +wh ?x (gap nil) (gap nil) ?subj-sem)\n"
"  (aux-inv-S ?constituent ?s ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:439
msgid ""
"A question can also be signaled by rising intonation in what would otherwise "
"be a declarative statement: \"You want some?\" Since we don't have "
"intonation information, we won't include this kind of question."
msgstr ""
"Вопрос также может быть обозначен возрастающей интонацией в том, что в "
"противном случае было бы декларативным заявлением: \"You want some?\"(Вы "
"хотите немного?) Поскольку у нас нет информации об интонации, мы не будем "
"включать такие вопросы."

#: in/chapter21.md:442
msgid ""
"The implementation for `aux-inv-S` is straightforward: parse an auxiliary "
"and then a clause, pausing to look for modifiers in between.\n"
"(So far, a \"not\" is the only modifier allowed in that position.)"
msgstr ""
"Реализация для `aux-inv-S` проста: проанализируйте вспомогательное, а затем "
"предложение, сделав паузу для поиска модификаторов между ними.\n"
"(Пока что в этой позиции разрешен только модификатор \"not\"(не).)"

#: in/chapter21.md:451
msgid ""
"```lisp\n"
"(rule (aux-inv-S ?constituent ?v :sem) ==>\n"
"  (:ex \"Does Kim like Lee?\" (who) \"would Kim have liked\")\n"
"  (aux (finite ?agr ?tense) ?needs-infl ?v ?aux-sem)\n"
"  (modifiers post aux ? () ?v (gap nil) (gap nil) ?mod)\n"
"  (clause ?needs-infl ?x int-subj ?v (gap ?constituent) (gap nil)\n"
"          ?clause-sem))\n"
"```"
msgstr ""

#: in/chapter21.md:459
msgid ""
"There is one more case to consider.\n"
"The verb \"to be\" is the most idiosyncratic in English.\n"
"It is the only verb that has agreement differences for anything besides "
"third-person singular.\n"
"And it is also the only verb that can be used in an `aux-inv-S` without a "
"main verb.\n"
"An example of this is \"Is he a doctor?,\" where \"is\" clearly is not an "
"auxiliary, because there is no main verb that it could be auxiliary to.\n"
"Other verb can not be used in this way: \"*Seems he happy?\" and \"* Did "
"they it?\" are ungrammatical.\n"
"The only possibility is \"have,\" as in \"Have you any wool?,\" but this use "
"is rare."
msgstr ""
"Следует рассмотреть еще один случай.\n"
"Глагол \"to be\"(быть) - самый идиосинкразический в английском языке.\n"
"Это единственный глагол, у которого есть отличия от всего, кроме третьего "
"лица единственного числа.\n"
"И это также единственный глагол, который может использоваться в `aux-inv-S` "
"без главного глагола.\n"
"Примером этого является \"Is he a doctor?,\"(Он врач?), Где \"is\" явно не "
"вспомогательный, потому что нет главного глагола, к которому он мог бы быть "
"вспомогательным.\n"
"Другой глагол нельзя использовать таким образом: \"*Seems he happy?"
"\"(Кажется, он счастлив?) и \"* Did they it?\"(Они это сделали?) вне "
"грамматики.\n"
"Единственная возможность - это \"have\"(иметь), как в \"Have you any wool?"
"\"(У тебя есть шерсть?), Но такое использование редко."

#: in/chapter21.md:461
msgid ""
"The following rule parses a verb, checks to see that it is a version of \"be,"
"\" and then parses the subject and the modifiers for the verb."
msgstr ""
"Следующее правило анализирует глагол, проверяет, является ли он версией \"be"
"\"(быть), а затем анализирует подлежащее и модификаторы глагола."

#: in/chapter21.md:472
msgid ""
"```lisp\n"
"(rule (aux-inv-S ?ext ?v :sem) ==>\n"
"  (:ex \"Is he a doctor?\")\n"
"  (verb ?be (finite ?agr ?) ((?role ?n ?xp) . ?slots) ?v ?sem)\n"
"  (:test (word ?be be))\n"
"  (subject ?agr ?x (?role ?n ?xp) int-subj\n"
"           (gap nil) (gap nil) ?subj-sem)\n"
"  (:sem (?role ?v ?x))\n"
"  (modifiers post verb ? ?slots ?v (gap ?ext) (gap nil) ?mod-sem))\n"
"```"
msgstr ""

#: in/chapter21.md:474
msgid "## 21.9 XPs"
msgstr ""

#: in/chapter21.md:477
msgid ""
"All that remains in our grammar is the XP category.\n"
"XPs are used in two ways: First, a phrase can be extraposed, as in \"*In "
"god* we trust,\" where \"in god\" will be parsed as an XP and then placed on "
"the gap list until it can be taken off as an adjunct to \"trust.\" Second, a "
"phrase can be a complement, as in \"He wants *to be a fireman,\"* where the "
"infinitive phrase is a complement of \"wants.\""
msgstr ""
"Все, что осталось в нашей грамматике, - это категория XP.\n"
"XP используются двумя способами: во-первых, фраза может быть "
"экстраполирована, например, \"*In god* we trust\", где \"in god\"(в Бога) "
"будет анализироваться как XP, а затем помещаться в список gap(разрыва) до "
"тех пор, пока его нельзя будет убрать. как добавка(adjunct) к \"trust"
"\"(верим). Во-вторых, фраза может быть дополнением(complement), например, "
"\"He wants *to be a fireman\"*(Он хочет быть пожарным), где инфинитивная "
"фраза является дополнением \"wants\"(хочет)."

#: in/chapter21.md:480
msgid ""
"As it turns out, the amount of information that needs to appear in a gap "
"list is slightly different from the information that appears in a complement "
"slot.\n"
"For example, one sense of the verb \"want\" has the following complement "
"list:"
msgstr ""
"Как оказалось, количество информации, которая должна появиться в списке "
"gap(разрывов), немного отличается от информации, которая появляется в слоте "
"дополнения(complement).\n"
"Например, одно из значений глагола \"want\"(хочу) имеет следующий список "
"дополнений:"

#: in/chapter21.md:484
msgid ""
"```lisp\n"
"((agt 1 (NP ?x)) (con 3 (VP infinitive ?x)))\n"
"```"
msgstr ""

#: in/chapter21.md:488
msgid ""
"This says that the first complement (the subject) is a noun phrase that "
"serves as the agent of the wanting, and the second is an infinitive verb "
"phrase that is the concept of the wanting.\n"
"The subject of this verb phrase is the same as the subject of the wanting, "
"so in \"She wants to go home\" it is she who both wants and goes.\n"
"(Contrast this to \"He persuaded her to go home,\" where it is he that "
"persuades, but she that goes.)"
msgstr ""
"Это говорит о том, что первое дополнение (подлежащее/субъект) - это фраза "
"существительного, которая служит агентом желания, а вторая - инфинитивная "
"глагольная фраза, которая является концепцией желания.\n"
"Субъект этой глагольной фразы совпадает с субъектом желания, поэтому в \"She "
"wants to go home\"(Она хочет пойти домой) именно она и хочет, и идет.\n"
"(Сравните это с фразой \"He persuaded her to go home\"(Он убедил ее пойти "
"домой), где именно он убеждает, а она идет.)"

#: in/chapter21.md:492
msgid ""
"But when we put a noun phrase on a gap list, we need to include its number "
"and case as well as the fact that it is an NP and its metavariable, but we "
"don't need to include the fact that it is an agent.\n"
"This difference means we have two choices: either we can merge the notions "
"of slots and gap lists so that they use a common notation containing all the "
"information that either can use, or we need some way of mapping between "
"them.\n"
"I made the second choice, on the grounds that each notation was complicated "
"enough without bringing in additional information."
msgstr ""
"Но когда мы помещаем фразу сущетствительного в список gap(разрывов), нам "
"нужно указать ее номер и регистр, а также тот факт, что это NP и ее "
"метапеременная, но нам не нужно включать тот факт, что это агент.\n"
"Это различие означает, что у нас есть два варианта: либо мы можем объединить "
"понятия слотов и списков разрывов, чтобы они использовали общую нотацию, "
"содержащую всю информацию, которую можно использовать, либо нам нужен какой-"
"то способ сопоставления между ними.\n"
"Я сделал второй выбор на том основании, что каждое обозначение было "
"достаточно сложным, без дополнительной информации."

#: in/chapter21.md:498
msgid ""
"The relation `slot-constituent` maps between the slot notation used for "
"complements and the constituent notation used in gap lists.\n"
"There are eight types of complements, five of which can appear in gap lists: "
"noun phrases, clauses, prepositional phrases, the word \"it\" (as in \"it is "
"raining\"), and adverbial phrases.\n"
"The three phrases that are allowed only as complements are verb phrases, "
"particles (such as \"up\" in \"look up the number\"), and adjectives.\n"
"Here is the mapping between the two notations.\n"
"The *** indicates no mapping:"
msgstr ""
"Отношение `slot-constituent` выполняет отображение между используемым "
"обозначением слота, используемым для дополнений, и составляющим "
"обозначением, используемым в списках разрывов(gap).\n"
"Существует восемь типов дополнений, пять из которых могут появляться в "
"списках разрывов: фразы существительных, предложения, предложные фразы, "
"слово \"it\"(оно) (например, \"it is raining\"(идет дождь)) и наречные "
"фразы(adverbial phrases).\n"
"Три фразы, которые разрешены только в качестве дополнения, - это глагольные "
"фразы, частицы (например, \"up\"(вверх) в \"look up the number\"(поиске "
"числа)) и прилагательные(adjectives).\n"
"Вот соответствие между двумя обозначениями.\n"
"*** означает отсутствие сопоставления:"

#: in/chapter21.md:512
msgid ""
"```lisp\n"
"(<- (slot-constituent (?role ?n (NP ?x))\n"
"                      (NP ?agr ?case ?x) ?x ?h))\n"
"(<- (slot-constituent (?role ?n (clause ?word ?infl))\n"
"                      (clause ?word ?infl ?v) ?v ?h))\n"
"(<- (slot-constituent (?role ?n (PP ?prep ?np))\n"
"                      (PP ?prep ?role ?np ?h) ?np ?h))\n"
"(<- (slot-constituent (?role ?n it)            (it ? ? ?x) ?x ?))\n"
"(<- (slot-constituent (manner 3 (advp ?x))     (advp ?v) ? ?v))\n"
"(<- (slot-constituent (?role ?n (VP ?infl ?x)) *** ? ?))\n"
"(<- (slot-constituent (?role ?n (Adj ?x))      *** ?x ?))\n"
"(<- (slot-constituent (?role ?n (P ?particle)) *** ? ?))\n"
"```"
msgstr ""

#: in/chapter21.md:515
msgid ""
"We are now ready to define compi ement.\n"
"It takes a slot description, maps it into a constituent, and then calls `XP` "
"to parse that constituent:"
msgstr ""
"Теперь мы готовы определить дополнение(complement).\n"
"Она берет описание слота, сопоставляет его с составной частью, а затем "
"вызывает `XP` для анализа этой составляющей:"

#: in/chapter21.md:524
msgid ""
"```lisp\n"
"(rule (complement ?cat ?info (?role ?n ?xp) ?h ?gap1 ?gap2 :sem)\n"
"  ==>\n"
"  ;; A complement is anything expected by a slot\n"
"  (:sem (?role ?h ?x))\n"
"  (:test (slot-constituent (?role ?n ?xp) ?constituent ?x ?h))\n"
"  (XP ?xp ?constituent ?wh ?x ?gap1 ?gap2 ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:529
msgid ""
"The category `XP` takes seven arguments.\n"
"The first two are the slot we are trying to fill and the constituent we need "
"to fill it.\n"
"The third is used for any additional information, and the fourth is the "
"metavariable for the phrase.\n"
"The last three supply gap and semantic information."
msgstr ""
"Категория `XP` принимает семь аргументов.\n"
"Первые два - это слот, который мы пытаемся заполнить, и компонент, который "
"нам нужен для его заполнения.\n"
"Третья используется для любой дополнительной информации, а четвертая - "
"метапеременная для фразы.\n"
"Последние три предоставляют разрыв(gap) и смысловую информацию."

#: in/chapter21.md:531
msgid "Here are the first five XP categories:"
msgstr "Вот первые пять категорий XP:"

#: in/chapter21.md:536
msgid ""
"```lisp\n"
"(rule (XP (PP ?prep ?np) (PP ?prep ?role ?np ?h) ?wh ?np\n"
"          ?gap1 ?gap2 ?sem) ==>\n"
"  (PP ?prep ?role ?wh ?np ?h ?gap1 ?gap2 ?sem))"
msgstr ""

#: in/chapter21.md:539
msgid ""
"(rule (XP (NP ?x) (NP ?agr ?case ?x) ?wh ?x ?gap1 ?gap2 ?sem) ==>\n"
"  (NP ?agr ?case ?wh ?x ?gap1 ?gap2 ?sem))"
msgstr ""

#: in/chapter21.md:542
msgid ""
"(rule (XP it (it ? ? ?x) -wh ?x ?gap ?gap t) ==>\n"
"  (:word it))"
msgstr ""

#: in/chapter21.md:548
msgid ""
"(rule (XP (clause ?word ?infl) (clause ?word ?infl ?v) -wh ?v\n"
"          ?gap1 ?gap2 ?sem) ==>\n"
"  (:ex (he thinks) \"that she is tall\")\n"
"  (opt-word ?word)\n"
"  (clause ?infl ?x int-subj ?v ?gap1 ?gap2 ?sem))"
msgstr ""

#: in/chapter21.md:553
msgid ""
"(rule (XP (?role ?n (advp ?v)) (advp ?v) ?wh ?v ?gap1 ?gap2 ?sem)\n"
"  ==>\n"
"  (advp ?wh ?v ?gap1 ?gap2 ?sem))\n"
"```"
msgstr ""

#: in/chapter21.md:557
msgid ""
"The category `opt-word` parses a word, which may be optional.\n"
"For example, one sense of \"know\" subcategorizes for a clause with an "
"optional \"that\": we can say either \"I know that he's here\" or \"I know "
"he's here.\" The complement list for \"know\" thus contains the slot `(con 2 "
"(clause (that) (finite ? ?)))`.\n"
"If the \"that\" had been obligatory, it would not have parentheses around it."
msgstr ""
"Категория `opt-word` анализирует слово, что может быть необязательным.\n"
"Например, одно значение \"know\"(знать) подкатегории для предложения с "
"необязательным \"that\"(что): мы можем сказать либо \"I know that he's here"
"\"(Я знаю, что он здесь), либо \"I know he's here\"(Я знаю, что он здесь). "
"Таким образом, список дополнений для \"know\"(знать) содержит слот `(con 2 "
"(clause (that) (finite ? ?)))`.\n"
"Если бы \"that\"(это) было обязательным, вокруг него не было бы скобок."

#: in/chapter21.md:563
msgid ""
"```lisp\n"
"(rule (opt-word ?word) ==> (:word ?word))\n"
"(rule (opt-word (?word)) ==> (:word ?word))\n"
"(rule (opt-word (?word)) ==>)\n"
"```"
msgstr ""

#: in/chapter21.md:565
msgid "Finally, here are the three XPs that can not be extraposed:"
msgstr "Наконец, вот три XP, которые нельзя экстраполировать:"

#: in/chapter21.md:570
msgid ""
"```lisp\n"
"(rule (XP (VP ?infl ?x) *** -wh ?v ?gap1 ?gap2 ?sem) ==>\n"
"  (:ex (he promised her) \"to sleep\")\n"
"  (VP ?infl ?x ?subj-slot ?v ?gap1 ?gap2 ?sem))"
msgstr ""

#: in/chapter21.md:573
msgid ""
"(rule (XP (Adj ?x) *** -wh ?x ?gap ?gap ?sem) ==>\n"
"  (Adj ?x ?sem))"
msgstr ""

#: in/chapter21.md:577
msgid ""
"(rule (XP (P ?particle) *** -wh ?x ?gap ?gap t) ==>\n"
"  (prep ?particle t))\n"
"```"
msgstr ""

#: in/chapter21.md:579
msgid "## 21.10 Word Categories"
msgstr "## 21.10 Категории слов(Word Categories)"

#: in/chapter21.md:583
msgid ""
"Each word category has a rule that looks words up in the lexicon and assigns "
"the right features.\n"
"The relation `word` is used for all lexicon access.\n"
"We will describe the most complicated word class, `verb`, and just list the "
"others."
msgstr ""
"Каждая категория слов имеет правило, которое ищет слова в лексиконе и "
"присваивает им нужные характеристики.\n"
"Отношение `word`(слово) используется для доступа к лексикону.\n"
"Мы опишем самый сложный класс слов, `verb`(глагол), и просто перечислим "
"остальные."

#: in/chapter21.md:589
msgid ""
"Verbs are complex because they often are *polysemous-*they have many "
"meanings.\n"
"In addition, each meaning can have several different complement lists.\n"
"Thus, an entry for a verb in the lexicon will consist of the verb form, its "
"inflection, and a list of senses, where each sense is a semantics followed "
"by a list of possible complement lists.\n"
"Here is the entry for the verb \"sees,\" indicating that it is a present-"
"tense verb with three senses.\n"
"The understand sense has two complement lists, which correspond to \"He sees"
"\" and \"He sees that you are right.\" The `look` sense has one complement "
"list corresponding to \"He sees the picture,\" and the `dating` sense, "
"corresponding to \"He sees her (only on Friday nights),\" has the same "
"complement list."
msgstr ""
"Глаголы сложны, потому что они часто *многозначны* -  имеют много значений.\n"
"Кроме того, каждое значение может иметь несколько различных списков "
"дополнений(complement).\n"
"Таким образом, запись для глагола в лексиконе будет состоять из формы "
"глагола, его изменения(inflection) и списка значений, где каждое значение "
"представляет собой семантику, за которой следует список возможных списков "
"дополнений.\n"
"Вот запись для глагола \"sees\"(видит), указывающая на то, что это глагол в "
"настоящем времени с тремя смыслами.\n"
"Смысл понимания имеет два дополнительных списка, которые соответствуют \"He "
"sees\"(Он видит) и \"He sees that you are right\"(Он видит, что вы правы»). "
"Смысл `look`(взгляд) имеет один дополнительный список, соответствующий \"He "
"sees the picture\"(Он видит картинку), а смысл `dating`(свидание), "
"соответствующее \"He sees her (only on Friday nights)\"(Он увидит ее (только "
"в пятницу вечером)), имеет тот же дополнительный список."

#: in/chapter21.md:599
msgid ""
"```lisp\n"
"(?- (word sees verb ?infl ?senses))\n"
"?INFL = (FINITE (--+-) PRESENT)\n"
"?SENSES = ((UNDERSTAND ((AGT 1 (NP ?3)))\n"
"                ((EXP 1 (NP ?4))\n"
"                  (CON 2 (CLAUSE (THAT) (FINITE ?5 ?6)))))\n"
"          (LOOK ((AGT 1 (NP ?7)) (OBJ 2 (NP ?8))))\n"
"          (DATING ((AGT 1 (NP ?9)) (OBJ 2 (NP ?10)))))\n"
"```"
msgstr ""

#: in/chapter21.md:602
msgid ""
"The category `verb` takes five arguments: the verb itself, its inflection, "
"its complement list, its metavariable, and its semantics.\n"
"The `member` relations are used to pick a sense from the list of senses and "
"a complement list from the list of lists, and the semantics is built from "
"semantic predicate for the chosen sense and the metavariable for the verb:"
msgstr ""
"Категория `verb`(глагол) принимает пять аргументов: сам глагол, его "
"изменения, его список дополнений, его метапеременных и его семантику.\n"
"Отношения `member` используются для выбора смысла из списка смыслов и "
"дополнительного списка из списка списков, а семантика строится из "
"семантического предиката для выбранного смысла и метапеременной для глагола:"

#: in/chapter21.md:613
msgid ""
"```lisp\n"
"(rule (verb ?verb ?infl ?slots ?v :sem) ==>\n"
"  (:word ?verb)\n"
"  (:test (word ?verb verb ?infl ?senses)\n"
"         (member (?sem . ?subcats) ?senses)\n"
"         (member ?slots ?subcats)\n"
"         (tense-sem ?infl ?v ?tense-sem))\n"
"  (:sem ?tense-sem)\n"
"  (:sem (?sem ?v)))\n"
"```"
msgstr ""

#: in/chapter21.md:618
msgid ""
"It is difficulty to know how to translate tense information into a semantic "
"interpretation.\n"
"Different applications will have different models of time and thus will want "
"different interpretations.\n"
"The relation `tense-sem` gives semantics for each tense.\n"
"Here is a very simple definition of `tense-sem`:"
msgstr ""
"Трудно уметь(знать как) перевести временную(tense) информацию в смысловую "
"интерпретацию.\n"
"Разные приложения будут иметь разные модели времени и, следовательно, будут "
"нуждаться в разных интерпретациях.\n"
"Отношение `tense-sem` дает семантику для каждого времени.\n"
"Вот очень простое определение `tense-sem`:"

#: in/chapter21.md:627
msgid ""
"```lisp\n"
"(<- (tense-sem (finite ? ?tense) ?v (?tense ?v)))\n"
"(<- (tense-sem -ing ?v (progressive ?v)))\n"
"(<- (tense-sem -en  ?v (past-participle ?v)))\n"
"(<- (tense-sem infinitive ?v t))\n"
"(<- (tense-sem nonfinite ?v t))\n"
"(<- (tense-sem passive ?v (passive ?v)))\n"
"```"
msgstr ""

#: in/chapter21.md:629
msgid "Auxiliary verbs and modal verbs are listed separately:"
msgstr "Вспомогательные глаголы и модальные глаголы указаны отдельно:"

#: in/chapter21.md:635
msgid ""
"```lisp\n"
"(rule (aux ?infl ?needs-infl ?v ?tense-sem) ==>\n"
"  (:word ?aux)\n"
"  (:test (word ?aux aux ?infl ?needs-infl)\n"
"         (tense-sem ?infl ?v ?tense-sem)))"
msgstr ""

#: in/chapter21.md:640
msgid ""
"(rule (aux (finite ?agr ?tense) nonfinite ?v (?sem ?v)) ==>\n"
"  (:word ?modal)\n"
"  (:test (word ?modal modal ?sem ?tense)))\n"
"```"
msgstr ""

#: in/chapter21.md:643
msgid ""
"Nouns, pronouns, and names are also listed separately, although they have "
"much in common.\n"
"For pronouns we use quantifier `wh` or `pro`, depending on if it is a wh-"
"pronoun or not."
msgstr ""
"Существительные, местоимения и имена также указаны отдельно, хотя у них "
"много общего.\n"
"Для местоимений мы используем квантификатор `wh` или `pro`, в зависимости от "
"того, является это местоимением wh-pronoun или нет."

#: in/chapter21.md:648
msgid ""
"```lisp\n"
"(rule (noun ?agr ?slots ?x (?sem ?x)) ==>\n"
"  (:word ?noun)\n"
"  (:test (word ?noun noun ?agr ?slots ?sem)))"
msgstr ""

#: in/chapter21.md:653
msgid ""
"(rule (pronoun ?agr ?case ?wh ?x (?quant ?x (?sem ?x))) ==>\n"
"  (:word ?pro)\n"
"  (:test (word ?pro pronoun ?agr ?case ?wh ?sem)\n"
"         (if (= ?wh +wh) (= ?quant wh) (= ?quant pro))))"
msgstr ""

#: in/chapter21.md:658
msgid ""
"(rule (name ?agr ?name) ==>\n"
"  (:word ?name)\n"
"  (:test (word ?name name ?agr)))\n"
"```"
msgstr ""

#: in/chapter21.md:660
msgid "Here are the rules for the remaining word classes:"
msgstr "Вот правила для остальных классов слов:"

#: in/chapter21.md:665
msgid ""
"```lisp\n"
"(rule (adj ?x (?sem ?x)) ==>\n"
"  (:word ?adj)\n"
"  (:test (word ?adj adj ?sem)))"
msgstr ""

#: in/chapter21.md:667
msgid "(rule (adj ?x ((nth ?n) ?x)) ==> (ordinal ?n))"
msgstr ""

#: in/chapter21.md:671
msgid ""
"(rule (art ?agr ?quant) ==>\n"
"  (:word ?art)\n"
"  (:test (word ?art art ?agr ?quant)))"
msgstr ""

#: in/chapter21.md:675
msgid ""
"(rule (prep ?prep t) ==>\n"
"  (:word ?prep)\n"
"  (:test (word ?prep prep)))"
msgstr ""

#: in/chapter21.md:682
msgid ""
"(rule (adverb ?wh ?x ?sem) ==>\n"
"  (:word ?adv)\n"
"  (:test (word ?adv adv ?wh ?pred)\n"
"         (if (= ?wh +wh)\n"
"             (= ?sem (wh ?y (?pred ?x ?y)))\n"
"             (= ?sem (?pred ?x)))))"
msgstr ""

#: in/chapter21.md:687
msgid ""
"(rule (cardinal ?n ?agr) ==>\n"
"  (:ex \"five\")\n"
"  (:word ?num)\n"
"  (:test (word ?num cardinal ?n ?agr)))"
msgstr ""

#: in/chapter21.md:695
msgid ""
"(rule (cardinal ?n ?agr) ==>\n"
"  (:ex \"5\")\n"
"  (:word ?n)\n"
"  (:test (numberp ?n)\n"
"         (if (= ?n 1)\n"
"             (= ?agr (- - + -))    ;3sing\n"
"             (= ?agr (- - - +))))) ;3plur"
msgstr ""

#: in/chapter21.md:701
msgid ""
"(rule (ordinal ?n) ==>\n"
"  (:ex \"fifth\")\n"
"  (:word ?num)\n"
"  (:test (word ?num ordinal ?n)))\n"
"```"
msgstr ""

#: in/chapter21.md:703
msgid "## 21.11 The Lexicon"
msgstr "## 21.11 Лексикон(Lexicon)"

#: in/chapter21.md:710
msgid ""
"The lexicon itself consists of a large number of entries in the `word` "
"relation, and it would certainly be possible to ask the lexicon writer to "
"make a long list of `word` facts.\n"
"But to make the lexicon easier to read and write, we adopt three useful "
"tools.\n"
"First, we introduce a system of abbreviations.\n"
"Common expressions can be abbreviated with a symbol that will be expanded by "
"`word.` Second, we provide the macros verb and `noun` to cover the two most "
"complex word classes.\n"
"Third, we provide a macro `word` that makes entries into a hash table.\n"
"This is more efficient than compiling a `word` relation consisting of "
"hundreds of Prolog clauses."
msgstr ""
"Сам лексикон состоит из большого количества записей в отношении "
"`word`(слово), и, безусловно, можно было бы попросить составителя словаря "
"составить длинный список фактов `word`.\n"
"Но чтобы облегчить чтение и запись лексики, мы используем три полезных "
"инструмента.\n"
"Во-первых, введем систему сокращений(abbreviations).\n"
"Общие выражения могут быть сокращены с помощью символа, который будет "
"расширен `word.`. Во-вторых, мы предоставляем макрос `verb` и `noun` для "
"охвата двух наиболее сложных классов слов.\n"
"В-третьих, мы предоставляем макрос `word`, который делает записи в хеш-"
"таблице.\n"
"Это более эффективно, чем составление отношения слова, состоящего из сотен "
"предложений Пролога."

#: in/chapter21.md:712
msgid ""
"The implementation of these tools is left for the next section; here we show "
"the actual lexicon, starting with the list of abbreviations."
msgstr ""
"Реализация этих инструментов оставлена для следующего раздела; здесь мы "
"показываем фактическую лексику, начиная со списка сокращений."

#: in/chapter21.md:726
msgid ""
"The first set of abbreviations defines the agreement features.\n"
"The obvious way to handle agreement is with two features, one for person and "
"one for number.\n"
"So first-person singular might be represented (1 `sing`).\n"
"A problem arises when we want to describe verbs.\n"
"Every verb except \"be\" makes the distinction only between third- person "
"singular and all the others.\n"
"We don't want to make five separate entries in the lexicon to represent all "
"the others.\n"
"One alternative is to have the agreement feature be a set of possible "
"values, so all the others would be a single set of five values rather than "
"five separate values.\n"
"This makes a big difference in cutting down on backtracking.\n"
"The problem with this approach is keeping track of when to intersect sets.\n"
"Another approach is to make the agreement feature be a list of four binary "
"features, one each for first-person singular, first-person plural, third-"
"person singular, and third-person plural.\n"
"Then \"all the others\" can be represented by the list that is negative in "
"the third feature and unknown in all the others.\n"
"There is no way to distinguish second-person singular from plural in this "
"scheme, but English does not make that distinction.\n"
"Here are the necessary abbreviations:"
msgstr ""
"Первый набор сокращений определяет особенности соглашения.\n"
"Очевидный способ добиться согласия - использовать две функции: одну для "
"лица(person), а другую - для числа.\n"
"Таким образом, можно представить единственное число от первого лица (1 "
"`sing`).\n"
"Проблема возникает, когда мы хотим описать глаголы.\n"
"Каждый глагол, кроме \"be\"(быть), делает различие только между третьим "
"лицом единственного числа и всеми остальными.\n"
"Мы не хотим делать в лексиконе пять отдельных записей, чтобы представить все "
"остальные.\n"
"Одна альтернатива - использовать функцию согласования в виде набора "
"возможных значений, чтобы все остальные были единым набором из пяти "
"значений, а не из пяти отдельных значений.\n"
"Это имеет большое значение для сокращения количества откатов.\n"
"Проблема с этим подходом состоит в том, чтобы отслеживать, когда пересекать "
"множества.\n"
"Другой подход состоит в том, чтобы сделать функциональность согласования "
"списком из четырех двоичных функциональностей, по одной для единственного "
"числа от первого лица, от первого лица во множественном числе, от третьего "
"лица в единственном числе и от третьего лица во множественном числе.\n"
"Тогда \"все остальные\" могут быть представлены списком, который отрицателен "
"для третьего признака и неизвестен для всех остальных.\n"
"В этой схеме нет способа отличить второе лицо единственного числа от "
"множественного числа, но в английском языке такое различие не проводится.\n"
"Вот необходимые сокращения:"

#: in/chapter21.md:735
msgid ""
"```lisp\n"
"(abbrev 1sing       (+ - - -))\n"
"(abbrev 1plur       (- + - -))\n"
"(abbrev 3sing       (- - + -))\n"
"(abbrev 3plur       (- - - +))\n"
"(abbrev 2pers       (- - - -))\n"
"(abbrev ~3sing      (? ? - ?))\n"
"```"
msgstr ""

#: in/chapter21.md:737
msgid ""
"The next step is to provide abbreviations for some of the common verb "
"complement lists:"
msgstr ""
"Следующий шаг - предоставить сокращения для некоторых распространенных "
"списков дополнений глаголов:"

#: in/chapter21.md:759
msgid ""
"``lisp\n"
"(abbrev v/intrans   ((agt 1 (NP ?))))\n"
"(abbrev v/trans     ((agt 1 (NP ?)) (obj 2 (NP ?))))\n"
"(abbrev v/ditrans   ((agt 1 (NP ?)) (goal 2 (NP ?)) (obj 3 (NP ?))))\n"
"(abbrev v/trans2    ((agt 1 (NP ?)) (obj 2 (NP ?)) (goal 2 (PP to ?))))\n"
"(abbrev v/trans4    ((agt 1 (NP ?)) (obj 2 (NP ?)) (ben 2 (PP for ?))))\n"
"(abbrev v/it-null   ((nil 1 it)))\n"
"(abbrev v/opt-that  ((exp 1 (NP ?)) (con 2 (clause (that) (finite ? ?)))))\n"
"(abbrev v/subj-that ((con 1 (clause that (finite ? ?))) (exp 2 (NP ?))))\n"
"(abbrev v/it-that   ((nil 1 it) (exp 2 (NP ?))\n"
"                     (con 3 (clause that (finite ? ?)))))\n"
"(abbrev v/inf       ((agt 1 (NP ?x)) (con 3 (VP infinitive ?x))))\n"
"(abbrev v/promise   ((agt 1 (NP ?x)) (goal (2) (NP ?y))\n"
"                     (con 3 (VP infinitive ?x))))\n"
"(abbrev v/persuade  ((agt 1 (NP ?x)) (goal 2 (NP ?y))\n"
"                     (con 3 (VP infinitive ?y))))\n"
"(abbrev v/want      ((agt 1 (NP ?x)) (con 3 (VP infinitive ?x))))\n"
"(abbrev v/p-up      ((agt 1 (NP ?)) (pat 2 (NP ?)) (nil 3 (P up))))\n"
"(abbrev v/pp-for    ((agt 1 (NP ?)) (pat 2 (PP for ?))))\n"
"(abbrev v/pp-after  ((agt 1 (NP ?)) (pat 2 (PP after ?))))\n"
"```"
msgstr ""

#: in/chapter21.md:761
msgid "### Verbs"
msgstr "### Глаголы(Verbs)"

#: in/chapter21.md:763
msgid ""
"The macro `verb` allows us to list verbs in the form below, where the "
"spellings of each tense can be omitted if the verb is regular:"
msgstr ""
"Макрос `verb` позволяет нам перечислять глаголы в форме ниже, где написание "
"каждого времени может быть опущено, если глагол правильный:"

#: in/chapter21.md:765
msgid ""
"(`verb` (*base past-tense past-participle present-participle present-"
"plural* ) (*semantics complement-list*...) ...)"
msgstr ""

#: in/chapter21.md:769
msgid ""
"For example, in the following list \"ask\" is regular, so only its base-form "
"spelling is necessary.\n"
"\"Do,\" on the other hand, is irregular, so each form is spelled out.\n"
"The haphazard list includes verbs that are either useful for examples or "
"illustrate some unusual complement list."
msgstr ""
"Например, в следующем списке слово \"ask\"(спросить) является обычным, "
"поэтому необходимо только его написание в основной форме.\n"
"\"Do,\" с другой стороны, является неправильным, поэтому каждая форма "
"прописана.\n"
"В случайный список входят глаголы, которые либо полезны в качестве примеров, "
"либо иллюстрируют какой-то необычный список дополнений."

#: in/chapter21.md:800
msgid ""
"```lisp\n"
"(verb (ask) (query v/ditrans))\n"
"(verb (delete) (delete v/trans))\n"
"(verb (do did done doing does) (perform v/trans))\n"
"(verb (eat ate eaten) (eat v/trans))\n"
"(verb (give gave given giving) (give-1 v/trans2 v/ditrans)\n"
"      (donate v/trans v/intrans))\n"
"(verb (go went gone going goes))\n"
"(verb (have had had having has) (possess v/trans))\n"
"(verb (know knew known) (know-that v/opt-that) (know-of v/trans))\n"
"(verb (like) (like-1 v/trans))\n"
"(verb (look) (look-up v/p-up) (search v/pp-for)\n"
"      (take-care v/pp-after) (look v/intrans))\n"
"(verb (move moved moved moving moves)\n"
"      (self-propel v/intrans) (transfer v/trans2))\n"
"(verb (persuade) (persuade v/persuade))\n"
"(verb (promise) (promise v/promise))\n"
"(verb (put put put putting))\n"
"(verb (rain) (rain v/it-null))\n"
"(verb (saw) (cut-with-saw v/trans v/intrans))\n"
"(verb (see saw seen seeing) (understand v/intrans v/opt-that)\n"
"      (look v/trans) (dating v/trans))\n"
"(verb (sleep slept) (sleep v/intrans))\n"
"(verb (surprise) (surprise v/subj-that v/it-that))\n"
"(verb (tell told) (tell v/persuade))\n"
"(verb (trust) (trust v/trans ((agt 1 (NP ?)) (obj 2 (PP in ?)))))\n"
"(verb (try tried tried trying tries) (attempt v/inf))\n"
"(verb (visit) (visit v/trans))\n"
"(verb (want) (desire v/want v/persuade))\n"
"```"
msgstr ""

#: in/chapter21.md:802
msgid "### Auxiliary Verbs"
msgstr "### Вспомогательные глаголы(Auxiliary Verbs)"

#: in/chapter21.md:806
msgid ""
"Auxiliary verbs are simple enough to be described directly with the word "
"macro.\n"
"Each entry lists the auxiliary itself, the tense it is used to construct, "
"and the tense it must be followed by.\n"
"The auxiliaries \"have\" and \"do\" are listed, along with \"to,\" which is "
"used to construct infinitive clauses and thus can be treated as if it were "
"an auxiliary."
msgstr ""
"Вспомогательные глаголы достаточно просты, чтобы их можно было описать "
"непосредственно словом макрос.\n"
"Каждая запись перечисляет само вспомогательное средство, время, которое оно "
"используется для построения, и время, за которым оно должно следовать.\n"
"Вспомогательные элементы \"have\" и \"do\" перечислены вместе с \"to\", "
"которое используется для создания инфинитивных предложений и, таким образом, "
"может рассматриваться как вспомогательное."

#: in/chapter21.md:813
msgid ""
"```lisp\n"
"(word have    aux nonfinite -en)\n"
"(word have    aux (finite ~3sing present) -en)\n"
"(word has     aux (finite 3sing present) -en)\n"
"(word had     aux (finite ? past) -en)\n"
"(word having  aux -ing -en)"
msgstr ""

#: in/chapter21.md:817
msgid ""
"(word do      aux (finite ~3sing present) nonfinite)\n"
"(word does    aux (finite  3sing present) nonfinite)\n"
"(word did     aux (finite  ?     past)    nonfinite)"
msgstr ""

#: in/chapter21.md:820
msgid ""
"(word to      aux infinitive nonfinite)\n"
"```"
msgstr ""

#: in/chapter21.md:825
msgid ""
"The auxiliary \"be\" is special: in addition to its use as both an auxiliary "
"and main verb, it also is used in passives and as the main verb in aux-"
"inverted sentences.\n"
"The function `copula` is used to keep track of all these uses.\n"
"It will be defined in the next section, but you can see it takes two "
"arguments, a list of senses for the main verb, and a list of entries for the "
"auxiliary verb.\n"
"The three senses correspond to the examples \"He is a fool,\" \"He is a "
"Republican,\" and \"He is in Indiana,\" respectively."
msgstr ""
"Вспомогательное \"be\" является особенным: помимо использования в качестве "
"вспомогательного и основного глагола, оно также используется в пассивных "
"формах и в качестве основного глагола в предложениях с инвертированными "
"вспомогательными словами.\n"
"Функция `copula` используется для отслеживания всех этих случаев "
"использования.\n"
"Она будет определена в следующем разделе, но вы можете видеть, что она "
"принимает два аргумента, список значений для основного глагола и список "
"записей для вспомогательного глагола.\n"
"Эти три смысла соответствуют примерам \"He is a fool\"(Он дурак), \"He is a "
"Republican\"(Он республиканец) и \"He is in Indiana\"(Он в Индиане) "
"соответственно."

#: in/chapter21.md:840
msgid ""
"```lisp\n"
"(copula\n"
"  '((nil      ((nil 1 (NP ?x)) (nil 2 (Adj ?x))))\n"
"    (is-a     ((exp 1 (NP ?x)) (arg2 2 (NP ?y))))\n"
"    (is-loc   ((exp 1 (NP ?x)) (?prep 2 (PP ?prep ?)))))\n"
"  '((be       nonfinite -ing)\n"
"    (been     -en -ing)\n"
"    (being    -ing -en)\n"
"    (am       (finite 1sing present) -ing)\n"
"    (is       (finite 3sing present) -ing)\n"
"    (are      (finite 2pers present) -ing)\n"
"    (were     (finite (- - ? ?) past) -ing)   ; 2nd sing or pl\n"
"    (was      (finite (? - ? -) past) -ing))) ; 1st or 3rd sing\n"
"```"
msgstr ""

#: in/chapter21.md:844
msgid ""
"Following are the modal auxiliary verbs.\n"
"Again, it is difficult to specify semantics for them.\n"
"The word \"not\" is also listed here; it is not an auxiliary, but it does "
"modify them."
msgstr ""
"Ниже приведены модальные вспомогательные глаголы.\n"
"Опять же, для них сложно указать семантику.\n"
"Слово \"not\"(не) также указано здесь; это не вспомогательное средство, но "
"оно их модифицирует."

#: in/chapter21.md:855
msgid ""
"```lisp\n"
"(word can    modal able      past)\n"
"(word could  modal able      present)\n"
"(word may    modal possible  past)\n"
"(word might  modal possible  present)\n"
"(word shall  modal mandatory past)\n"
"(word should modal mandatory present)\n"
"(word will   modal expected  past)\n"
"(word would  modal expected  present)\n"
"(word must   modal necessary present)"
msgstr ""

#: in/chapter21.md:858
msgid ""
"(word not not)\n"
"```"
msgstr ""

#: in/chapter21.md:860
msgid "### Nouns"
msgstr "### Существительные(Nouns)"

#: in/chapter21.md:864
msgid ""
"No attempt has been made to treat nouns seriously.\n"
"We list enough nouns here to make some of the examples work.\n"
"The first noun shows a complement list that is sufficient to parse \"the "
"destruction of the city by the enemy.\""
msgstr ""
"Не было сделано никаких попыток серьезно относиться к существительным.\n"
"Мы перечисляем здесь достаточное количество существительных, чтобы некоторые "
"примеры работали.\n"
"Первое существительное показывает список дополнений, достаточный, чтобы "
"разобрать \"the destruction of the city by the enemy\"(разрушение города "
"противником)."

#: in/chapter21.md:885
msgid ""
"```lisp\n"
"(noun destruction * destruction\n"
"      (pat (2) (PP of ?)) (agt (2) (PP by ?)))\n"
"(noun beach)\n"
"(noun bone)\n"
"(noun box boxes)\n"
"(noun city cities)\n"
"(noun color)\n"
"(noun cube)\n"
"(noun doctor)\n"
"(noun dog dogs)\n"
"(noun enemy enemies)\n"
"(noun file)\n"
"(noun friend friends friend (friend-of (2) (PP of ?)))\n"
"(noun furniture *)\n"
"(noun hat)\n"
"(noun man men)\n"
"(noun saw)\n"
"(noun woman women)\n"
"```"
msgstr ""

#: in/chapter21.md:887
msgid "### Pronouns"
msgstr "### Местоимения(Names)"

#: in/chapter21.md:890
msgid ""
"Here we list the nominative, objective, and genitive pronouns, followed by "
"interrogative and relative pronouns.\n"
"The only thing missing are reflexive pronouns, such as \"myself.\""
msgstr ""
"Здесь мы перечисляем именительные, объективные и родительные местоимения, за "
"которыми следуют вопросительные и относительные местоимения.\n"
"Не хватает только возвратных местоимений, таких как \"myself\"(я)."

#: in/chapter21.md:899
msgid ""
"```lisp\n"
"(word I     pronoun 1sing (common nom) -wh speaker)\n"
"(word we    pronoun 1plur (common nom) -wh speaker+other)\n"
"(word you   pronoun 2pers (common   ?) -wh listener)\n"
"(word he    pronoun 3sing (common nom) -wh male)\n"
"(word she   pronoun 3sing (common nom) -wh female)\n"
"(word it    pronoun 3sing (common   ?) -wh anything)\n"
"(word they  pronoun 3plur (common nom) -wh anything)"
msgstr ""

#: in/chapter21.md:905
msgid ""
"(word me    pronoun 1sing (common obj) -wh speaker)\n"
"(word us    pronoun 1plur (common obj) -wh speaker+other)\n"
"(word him   pronoun 3sing (common obj) -wh male)\n"
"(word her   pronoun 3sing (common obj) -wh female)\n"
"(word them  pronoun 3plur (common obj) -wh anything)"
msgstr ""

#: in/chapter21.md:914
msgid ""
"(word my    pronoun 1sing gen -wh speaker)\n"
"(word our   pronoun 1plur gen -wh speaker+other)\n"
"(word your  pronoun 2pers gen -wh listener)\n"
"(word his   pronoun 3sing gen -wh male)\n"
"(word her   pronoun 3sing gen -wh female)\n"
"(word its   pronoun 3sing gen -wh anything)\n"
"(word their pronoun 3plur gen -wh anything)\n"
"(word whose pronoun 3sing gen +wh anything)"
msgstr ""

#: in/chapter21.md:919
msgid ""
"(word who   pronoun ? (common ?) +wh person)\n"
"(word whom  pronoun ? (common obj) +wh person)\n"
"(word what  pronoun ? (common ?) +wh thing)\n"
"(word which pronoun ? (common ?) +wh thing)"
msgstr ""

#: in/chapter21.md:925
msgid ""
"(word who   rel-pro ? person)\n"
"(word which rel-pro ? thing)\n"
"(word that  rel-pro ? thing)\n"
"(word whom  rel-pro (common obj) person)\n"
"```"
msgstr ""

#: in/chapter21.md:927
msgid "### Names"
msgstr "### Имена(Names)"

#: in/chapter21.md:929
msgid "The following names were convenient for one example or another:"
msgstr "Для того или иного примера удобны следующие имена:"

#: in/chapter21.md:937
msgid ""
"```lisp\n"
"(word God   name 3sing)  (word Lynn  name 3sing)\n"
"(word Jan   name 3sing)  (word Mary  name 3sing)\n"
"(word John  name 3sing)  (word NY    name 3sing)\n"
"(word Kim   name 3sing)  (word LA    name 3sing)\n"
"(word Lee   name 3sing)  (word SF    name 3sing)\n"
"```"
msgstr ""

#: in/chapter21.md:939
msgid "### Adjectives"
msgstr "### Прилагательные(Adjectives)"

#: in/chapter21.md:941
msgid "Here are a few adjectives:"
msgstr "Вот несколько прилагательных:"

#: in/chapter21.md:948
msgid ""
"```lisp\n"
"(word big   adj big)    (word bad   adj bad)\n"
"(word old   adj old)    (word smart adj smart)\n"
"(word green adj green)  (word red   adj red)\n"
"(word tall  adj tall)   (word fun   adj fun)\n"
"```"
msgstr ""

#: in/chapter21.md:950
msgid "### Adverbs"
msgstr "### Наречия(Adverbs)"

#: in/chapter21.md:952
msgid "The adverbs covered here include interrogatives:"
msgstr "Приведенные здесь наречия включают вопросительные:"

#: in/chapter21.md:956
msgid ""
"```lisp\n"
"(word quickly adv -wh quickly)\n"
"(word slowly  adv -wh slowly)"
msgstr ""

#: in/chapter21.md:962
msgid ""
"(word where   adv +wh loc)\n"
"(word when    adv +wh time)\n"
"(word why     adv +wh reason)\n"
"(word how     adv +wh manner)\n"
"```"
msgstr ""

#: in/chapter21.md:964
msgid "### Articles"
msgstr "### Артикли(Articles)"

#: in/chapter21.md:966
msgid "The common articles are listed here:"
msgstr "Общие артикли перечислены здесь:"

#: in/chapter21.md:976
msgid ""
"```lisp\n"
"(word the   art 3sing the)\n"
"(word the   art 3plur group)\n"
"(word a     art 3sing a)\n"
"(word an    art 3sing a)\n"
"(word every art 3sing every)\n"
"(word each  art 3sing each)\n"
"(word all   art 3sing all)\n"
"(word some  art ?     some)"
msgstr ""

#: in/chapter21.md:981
msgid ""
"(word this  art 3sing this)\n"
"(word that  art 3sing that)\n"
"(word these art 3plur this)\n"
"(word those art 3plur that)"
msgstr ""

#: in/chapter21.md:985
msgid ""
"(word what  art ?     wh)\n"
"(word which art ?     wh)\n"
"```"
msgstr ""

#: in/chapter21.md:987
msgid "### Cardinal and Ordinal Numbers"
msgstr "### Кардинальные(Cardinal) и порядковые(Ordinal) числа"

#: in/chapter21.md:990
msgid ""
"We can take advantage of `format's` capabilities to fill up the lexicon.\n"
"To go beyond 20, we would need a subgrammar of numbers."
msgstr ""
"Мы можем воспользоваться возможностями `format`, чтобы пополнить лексикон.\n"
"Чтобы выйти за пределы 20, нам понадобится подграмматика чисел."

#: in/chapter21.md:995
msgid ""
"```lisp\n"
";; This puts in numbers up to twenty, as if by\n"
";; (word five cardinal 5 3plur)\n"
";; (word fifth ordinal 5)"
msgstr ""

#: in/chapter21.md:1001
msgid ""
"(dotimes (i 21)\n"
"  (add-word (read-from-string (format nil \"~r\" i))\n"
"            'cardinal i (if (= i 1) '3sing '3plur))\n"
"  (add-word (read-from-string (format nil \"~:r\" i)) 'ordinal i))\n"
"```"
msgstr ""

#: in/chapter21.md:1003
msgid "### Prepositions"
msgstr "### Предлоги(Prepositions)"

#: in/chapter21.md:1005
msgid "Here is a fairly complete list of prepositions:"
msgstr "Вот довольно полный список предлогов:"

#: in/chapter21.md:1020
msgid ""
"```lisp\n"
"(word above prep)  (word about prep)  (word around prep)\n"
"(word across prep) (word after prep)  (word against prep)\n"
"(word along prep)  (word at prep)     (word away prep)\n"
"(word before prep) (word behind prep) (word below prep)\n"
"(word beyond prep) (word by prep)     (word down prep)\n"
"(word for prep)    (word from prep)   (word in prep)\n"
"(word of prep)     (word off prep)    (word on prep)\n"
"(word out prep)    (word over prep)   (word past prep)\n"
"(word since prep)  (word through prep)(word throughout prep)\n"
"(word till prep)   (word to prep)     (word under prep)\n"
"(word until prep)  (word up prep)     (word with prep)\n"
"(word without prep)\n"
"```"
msgstr ""

#: in/chapter21.md:1022
msgid "## 21.12 Supporting the Lexicon"
msgstr "## 21.12 Поддержка лексикона"

#: in/chapter21.md:1026
msgid ""
"This section describes the implementation of the macros `word`, `verb, "
"noun`, and `abbrev.` Abbreviations are stored in a hash table.\n"
"The macro `abbr`e`v` and the functions `get-abbrev` and `clear-abbrevs` "
"define the interface.\n"
"We will see how to expand abbreviations later."
msgstr ""
"В этом разделе описывается реализация макросов `word`, `verb, noun`  и "
"`abbrev.` Сокращения(Abbreviations) хранятся в хеш-таблице.\n"
"Макрос `abbrev` и функции `get-abbrev` и `clear-abbrevs` определяют "
"интерфейс.\n"
"Мы увидим, как расширять аббревиатуры позже."

#: in/chapter21.md:1029
msgid ""
"```lisp\n"
"(defvar *abbrevs* (make-hash-table))"
msgstr ""

#: in/chapter21.md:1033
msgid ""
"(defmacro abbrev (symbol definition)\n"
"  \"Make symbol be an abbreviation for definition.\"\n"
"  `(setf (gethash ',symbol *abbrevs*) ',definition))"
msgstr ""

#: in/chapter21.md:1037
msgid ""
"(defun clear-abbrevs () (clrhash *abbrevs*))\n"
"(defun get-abbrev (symbol) (gethash symbol *abbrevs*))\n"
"```"
msgstr ""

#: in/chapter21.md:1042
msgid ""
"Words are also stored in a hash table.\n"
"Currently, words are symbols, but it might be a better idea to use strings "
"for words, since then we could maintain capitalization information.\n"
"The macro `word` or the function `add-word` adds a word to the lexicon.\n"
"When used as an index into the hash table, each word returns a list of "
"entries, where the first element of each entry is the word's category, and "
"the other elements depend on the category."
msgstr ""
"Слова(words) также хранятся в хеш-таблице.\n"
"В настоящее время слова являются символами, но, возможно, было бы лучше "
"использовать для слов строки, поскольку тогда мы могли бы поддерживать "
"информацию о заглавных буквах.\n"
"Макрос `word` или функция `add-word` добавляет слово в лексикон.\n"
"При использовании в качестве индекса в хэш-таблице каждое слово возвращает "
"список записей, где первый элемент каждой записи является категорией слова, "
"а остальные элементы зависят от категории."

#: in/chapter21.md:1045
msgid ""
"```lisp\n"
"(defvar *words* (make-hash-table :size 500))"
msgstr ""

#: in/chapter21.md:1049
msgid ""
"(defmacro word (word cat &rest info)\n"
"  \"Put word, with category and subcat info, into lexicon.\"\n"
"  `(add-word ',word ',cat .,(mapcar #'kwote info)))"
msgstr ""

#: in/chapter21.md:1055
msgid ""
"(defun add-word (word cat &rest info)\n"
"  \"Put word, with category and other info, into lexicon.\"\n"
"  (push (cons cat (mapcar #'expand-abbrevs-and-variables info))\n"
"        (gethash word *words*))\n"
"  word)"
msgstr ""

#: in/chapter21.md:1058
msgid ""
"(defun kwote (x) (list 'quote x))\n"
"```"
msgstr ""

#: in/chapter21.md:1061
msgid ""
"The function `expand-abbrevs-and-variables` expands abbreviations and "
"substitutes variable structures for symbols beginning with ?.\n"
"This makes it easier to make a copy of the structure, which will be needed "
"later."
msgstr ""
"Функция `expand-abbrevs-and-variables` раскрывает сокращения и заменяет "
"структуры переменных для символов начинающиеся с ?.\n"
"Это упрощает изготовление копии структуры, которая понадобится позже."

#: in/chapter21.md:1086
msgid ""
"```lisp\n"
"(defun expand-abbrevs-and-variables (exp)\n"
"  \"Replace all variables in exp with vars, and expand abbrevs.\"\n"
"  (let ((bindings nil))\n"
"    (labels\n"
"      ((expand (exp)\n"
"         (cond\n"
"           ((lookup exp bindings))\n"
"           ((eq exp '?) (?))\n"
"           ((variable-p exp)\n"
"            (let ((var (?)))\n"
"              (push (cons exp var) bindings)\n"
"              var))\n"
"           ((consp exp)\n"
"            (reuse-cons (expand (first exp))\n"
"                        (expand (rest exp))\n"
"                        exp))\n"
"           (t (multiple-value-bind (expansion found?)\n"
"                  (get-abbrev exp)\n"
"                (if found?\n"
"                    (expand-abbrevs-and-variables expansion)\n"
"                    exp))))))\n"
"      (expand exp))))\n"
"```"
msgstr ""

#: in/chapter21.md:1093
msgid ""
"Now we can store words in the lexicon, but we need some way of getting them "
"out.\n"
"The function `word/n` takes a word (which must be instantiated to a symbol) "
"and a category and optional additional information and finds the entries in "
"the lexicon for that word that unify with the category and additional "
"information.\n"
"For each match, it calls the supplied continuation.\n"
"This means that `word/n` is a replacement for a long list of word facts.\n"
"There are three differences: `word/n` hashes, so it will be faster; it is "
"incremental (you can add a word at a time without needing to recompile); and "
"it can not be used when the word is unbound.\n"
"(It is not difficult to change it to handle an unbound word using `maphash`, "
"but there are better ways of addressing that problem.)"
msgstr ""
"Теперь мы можем хранить слова в лексиконе, но нам нужен какой-то способ их "
"извлечения.\n"
"Функция `word/n` принимает слово (которое должно быть преобразовано в "
"символ), категорию и необязательную дополнительную информацию и находит "
"записи в лексиконе для этого слова, которые объединяются с категорией и "
"дополнительной информацией.\n"
"Для каждого совпадения она вызывает предоставленное продолжение.\n"
"Это означает, что `word/n` заменяет длинный список словесных фактов.\n"
"Есть три отличия:`word/n` хеширует, поэтому она будет быстрее; она "
"инкрементна (вы можете добавлять слово за раз без необходимости "
"перекомпилировать); и её нельзя использовать, когда слово не связано.\n"
"(Нетрудно изменить её для обработки несвязанного слова с помощью `maphash`, "
"но есть более эффективные способы решения этой проблемы.)"

#: in/chapter21.md:1107
msgid ""
"```lisp\n"
"(defun word/n (word cat cont &rest info)\n"
"  \"Retrieve a word from the lexicon.\"\n"
"  (unless (unbound-var-p (deref word))\n"
"    (let ((old-trail (fill-pointer *trail*)))\n"
"      (dolist (old-entry (gethash word *words*))\n"
"        (let ((entry (deref-copy old-entry)))\n"
"          (when (and (consp entry)\n"
"                     (unify! cat (first entry))\n"
"                     (unify! info (rest entry)))\n"
"            (funcall cont)))\n"
"        (undo-bindings! old-trail)))))\n"
"```"
msgstr ""

#: in/chapter21.md:1110
msgid ""
"Note that `word/n` does not follow our convention of putting the "
"continuation last.\n"
"Therefore, we will need the following additional functions:"
msgstr ""
"Обратите внимание, что `word/n`` не следует нашему соглашению помещать "
"продолжение последним.\n"
"Поэтому нам потребуются следующие дополнительные функции:"

#: in/chapter21.md:1118
msgid ""
"```lisp\n"
"(defun word/2 (w cat cont) (word/n w cat cont))\n"
"(defun word/3 (w cat a cont) (word/n w cat cont a))\n"
"(defun word/4 (w cat a b cont) (word/n w cat cont a b))\n"
"(defun word/5 (w cat a b c cont) (word/n w cat cont a b c))\n"
"(defun word/6 (w cat a b c d cont) (word/n w cat cont a b c d))\n"
"```"
msgstr ""

#: in/chapter21.md:1123
msgid ""
"We could create the whole lexicon with the macro `word`, but it is "
"convenient to create specific macros for some classes.\n"
"The macro `noun` is used to generate two entries, one for the singular and "
"one for the plural.\n"
"The arguments are the base noun, optionally followed by the plural (which "
"defaults to the base plus \"s\"), the semantics (which defaults to the "
"base), and a list of complements.\n"
"Mass nouns, like \"furniture,\" have only one entry, and are marked by an "
"asterisk where the plural would otherwise be."
msgstr ""
"Мы могли бы создать целый лексикон с помощью макроса `word`, но для "
"некоторых классов удобно создавать определенные макросы.\n"
"Макрос `noun`(существительное) используется для создания двух записей, одна "
"для единственного числа, а вторая - для множественного.\n"
"Аргументы - это существительное с основанием, за которым может следовать "
"множественное число (по умолчанию - основание плюс \"s\"), семантика (по "
"умолчанию - основание) и список дополнений.\n"
"Массовые существительные, такие как \"furniture\"(мебель), имеют только одну "
"запись и помечены звездочкой вместо множественного числа."

#: in/chapter21.md:1128
msgid ""
"```lisp\n"
"(defmacro noun (base &rest args)\n"
"  \"Add a noun and its plural to the lexicon.\"\n"
"  `(add-noun-form ',base ,@(mapcar #'kwote args)))"
msgstr ""

#: in/chapter21.md:1137
msgid ""
"(defun add-noun-form (base &optional (plural (symbol base 's))\n"
"                      (sem base) &rest slots)\n"
"  (if (eq plural '*)\n"
"      (add-word base 'noun '? slots sem)\n"
"      (progn\n"
"        (add-word base 'noun '3sing slots sem)\n"
"        (add-word plural 'noun '3plur slots sem))))\n"
"```"
msgstr ""

#: in/chapter21.md:1145
msgid ""
"Verbs are more complex.\n"
"Each verb has seven entries: the base or nonfinite, the present tense "
"singular and plural, the past tense, the past-participle, the present-"
"participle, and the passive.\n"
"The macro `verb` automatically generates all seven entries.\n"
"Verbs that do not have all of them can be handled by individual calls to "
"`word`.\n"
"We automatically handle the spelling for the simple cases of adding \"s,\" "
"\"ing,\" and \"ed,\" and perhaps stripping a trailing vowel.\n"
"More irregular spellings have to be specified explicitly.\n"
"Here are three examples of the use of `verb`:"
msgstr ""
"Глаголы более сложные.\n"
"Каждый глагол состоит из семи элементов: основного или нефинитного, "
"настоящего времени единственного и множественного числа, прошедшего времени, "
"причастия прошедшего времени, причастия настоящего и пассивного.\n"
"Макрос `verb` автоматически генерирует все семь записей.\n"
"Глаголы, у которых нет всех из них, могут обрабатываться отдельными вызовами "
"`word`.\n"
"Мы автоматически обрабатываем орфографию для простых случаев добавления \"s,"
"\" \"ing\" и \"ed,\" и, возможно, удаления конечной гласной.\n"
"Необходимо явно указать более неправильное написание.\n"
"Вот три примера использования `verb`:"

#: in/chapter21.md:1151
msgid ""
"```lisp\n"
"(verb (do did done doing does) (perform v/trans))\n"
"(verb (eat ate eaten) (eat v/trans))\n"
"(verb (trust) (trust v/trans ((agt 1 (NP ?)) (obj 2 (PP in ?)))))\n"
"```"
msgstr ""

#: in/chapter21.md:1153
msgid "And here is the macro definition:"
msgstr "А вот определение макроса:"

#: in/chapter21.md:1158
msgid ""
"```lisp\n"
"(defmacro verb ((base &rest forms) &body senses)\n"
"  \"Enter a verb into the lexicon.\"\n"
"  `(add-verb ',senses ',base ,@(mapcar #'kwote (mklist forms))))"
msgstr ""

#: in/chapter21.md:1175
msgid ""
"(defun add-verb (senses base &optional\n"
"                 (past (symbol (strip-vowel base) 'ed))\n"
"                 (past-part past)\n"
"                 (pres-part (symbol (strip-vowel base) 'ing))\n"
"                 (plural (symbol base 's)))\n"
"  \"Enter a verb into the lexicon.\"\n"
"  (add-word base 'verb 'nonfinite senses)\n"
"  (add-word base 'verb '(finite ~3sing present) senses)\n"
"  (add-word past 'verb '(finite ? past) senses)\n"
"  (add-word past-part 'verb '-en senses)\n"
"  (add-word pres-part 'verb '-ing senses)\n"
"  (add-word plural 'verb '(finite 3sing present) senses)\n"
"  (add-word past-part 'verb 'passive\n"
"            (mapcar #'passivize-sense\n"
"                    (expand-abbrevs-and-variables senses))))\n"
"```"
msgstr ""

#: in/chapter21.md:1179
msgid ""
"This uses a few auxiliary functions.\n"
"First, `strip-vowel` removes a vowel if it is the last character of the "
"given argument.\n"
"The idea is that for a verb like \"fire,\" stripping the vowel yields \"fir,"
"\" from which we can get \"fired\" and \"firing\" automatically."
msgstr ""
"При этом используются несколько вспомогательных функций.\n"
"Во-первых, `strip-vowel` удаляет гласную, если это последний символ данного "
"аргумента.\n"
"Идея состоит в том, что для глагола, такого как \"fire\"(гореть), удаление "
"гласного дает \"fir\", из которого мы можем автоматически получить \"fired\" "
"и \"firing\"."

#: in/chapter21.md:1188
msgid ""
"```lisp\n"
"(defun strip-vowel (word)\n"
"  \"Strip off a trailing vowel from a string.\"\n"
"  (let* ((str (string word))\n"
"         (end (- (length str) 1)))\n"
"    (if (vowel-p (char str end))\n"
"        (subseq str 0 end)\n"
"        str)))"
msgstr ""

#: in/chapter21.md:1191
msgid ""
"(defun vowel-p (char) (find char \"aeiou\" :test #'char-equal))\n"
"```"
msgstr ""

#: in/chapter21.md:1194
msgid ""
"We also provide a function to generate automatically the passive sense with "
"the proper complement list(s).\n"
"The idea is that the subject slot of the active verb becomes an optional "
"slot marked by the preposition \"by,\" and any slot that is marked with "
"number 2 can be promoted to become the subject:"
msgstr ""
"Мы также предоставляем функцию для автоматической генерации пассивного "
"смысла с соответствующими списками дополнений.\n"
"Идея состоит в том, что слот подлежащего активного глагола становится "
"необязательным слотом, отмеченным предлогом \"by\", и любой слот, отмеченный "
"цифрой 2, может быть повышен до подлежащего(subject):"

#: in/chapter21.md:1199
msgid ""
"```lisp\n"
"(defun passivize-sense (sense)\n"
"  ;; The first element of sense is the semantics; rest are slots\n"
"  (cons (first sense) (mapcan #'passivize-subcat (rest sense))))"
msgstr ""

#: in/chapter21.md:1212
msgid ""
"(defun passivize-subcat (slots)\n"
"  \"Return a list of passivizations of this subcat frame.\"\n"
"  ;; Whenever the 1 slot is of the form (?any 1 (NP ?)),\n"
"  ;; demote the 1 to a (3), and promote any 2 to a 1.\n"
"  (when (and (eql (slot-number (first slots)) 1)\n"
"             (starts-with (third (first slots)) 'NP))\n"
"    (let ((old-1 `(,(first (first slots)) (3) (PP by ?))))\n"
"      (loop for slot in slots\n"
"            when (eql (slot-number slot) 2)\n"
"            collect `((,(first slot) 1 ,(third slot))\n"
"                      ,@(remove slot (rest slots))\n"
"                      ,old-1)))))"
msgstr ""

#: in/chapter21.md:1215
msgid ""
"(defun slot-number (slot) (first-or-self (second slot)))\n"
"```"
msgstr ""

#: in/chapter21.md:1217
msgid ""
"Finally, we provide a special function just to define the copula, \"be.\""
msgstr ""
"Наконец, мы предоставляем специальную функцию только для определения связки "
"\"be\"(быть)."

#: in/chapter21.md:1228
msgid ""
"```lisp\n"
"(defun copula (senses entries)\n"
"  \"Copula entries are both aux and main verb.\"\n"
"  ;; They also are used in passive verb phrases and aux-inv-S\n"
"  (dolist (entry entries)\n"
"    (add-word (first entry) 'aux (second entry) (third entry))\n"
"    (add-word (first entry) 'verb (second entry) senses)\n"
"    (add-word (first entry) 'aux (second entry) 'passive)\n"
"    (add-word (first entry) 'be)))\n"
"```"
msgstr ""

#: in/chapter21.md:1232
msgid ""
"The remaining functions are used for testing, debugging, and extending the "
"grammar.\n"
"First, we need functions to clear everything so that we can start over.\n"
"These functions can be placed at the top of the lexicon and grammar files, "
"respectively:"
msgstr ""
"Остальные функции используются для тестирования, отладки и расширения "
"грамматики.\n"
"Во-первых, нам нужны функции, чтобы очистить все, чтобы мы могли начать "
"заново.\n"
"Эти функции можно разместить в верхней части файлов лексики и грамматики "
"соответственно:"

#: in/chapter21.md:1237
msgid ""
"```lisp\n"
"(defun clear-lexicon ()\n"
"  (clrhash *words*)\n"
"  (clear-abbrevs))"
msgstr ""

#: in/chapter21.md:1242
msgid ""
"(defun clear-grammar ()\n"
"  (clear-examples)\n"
"  (clear-db))\n"
"```"
msgstr ""

#: in/chapter21.md:1249
msgid ""
"Testing could be done with `run-examples`, but it is convenient to provide "
"another interface, the macro `try` (and its corresponding function, `try-"
"dcg`).\n"
"Both macro and function can be invoked three ways.\n"
"With no argument, all the examples stored by : ex are run.\n"
"When the name of a category is given, all the examples for that category "
"alone are run.\n"
"Finally, the user can supply both the name of a category and a list of words "
"to test whether those words can be parsed as that category.\n"
"This option is only available for categories that are listed in the "
"definition:"
msgstr ""
"Тестирование может быть выполнено с помощью `run-examples`, но удобно "
"предоставить другой интерфейс, макрос `try` (и соответствующую ему функцию "
"`try-dcg`).\n"
"И макрос, и функцию можно вызывать тремя способами.\n"
"Без аргументов запускаются все примеры, хранящиеся в: ex.\n"
"Когда указано имя категории, запускаются все примеры только для этой "
"категории.\n"
"Наконец, пользователь может указать как название категории, так и список "
"слов, чтобы проверить, могут ли эти слова быть проанализированы как эта "
"категория.\n"
"Эта опция доступна только для категорий, перечисленных в определении:"

#: in/chapter21.md:1256
msgid ""
"```lisp\n"
"(defmacro try (&optional cat &rest words)\n"
"  \"Tries to parse WORDS as a constituent of category CAT.\n"
"  With no words, runs all the :ex examples for category.\n"
"  With no cat, runs all the examples.\"\n"
"  `(try-dcg ',cat ',words))"
msgstr ""

#: in/chapter21.md:1275
msgid ""
"(defun try-dcg (&optional cat words)\n"
"  \"Tries to parse WORDS as a constituent of category CAT.\n"
"  With no words, runs all the :ex examples for category.\n"
"  With no cat, runs all the examples.\"\n"
"  (if (null words)\n"
"      (run-examples cat)\n"
"      (let ((args `((gap nil) (gap nil) ?sem ,words ())))\n"
"        (mapc #'test-unknown-word words)\n"
"        (top-level-prove\n"
"          (ecase cat\n"
"            (np `((np ? ? ?wh ?x ,@args)))\n"
"            (vp `((vp ?infl ?x ?sl ?v ,@args)))\n"
"            (pp `((pp ?prep ?role ?wh ?x ,@args)))\n"
"            (xp `((xp ?slot ?constituent ?wh ?x ,@args)))\n"
"            (s  `((s ? ?sem ,words ())))\n"
"            (rel-clause `((rel-clause ? ?x ?sem ,words ())))\n"
"            (clause `((clause ?infl ?x ?int-subj ?v ?g1 ?g2\n"
"                              ?sem ,words ()))))))))"
msgstr ""

#: in/chapter21.md:1281
msgid ""
"(defun test-unknown-word (word)\n"
"  \"Print a warning message if this is an unknown word.\"\n"
"  (unless (or (gethash word *words*) (numberp word))\n"
"    (warn \"~&Unknown word: ~a\" word)))\n"
"```"
msgstr ""

#: in/chapter21.md:1283
msgid "## 21.13 Other Primitives"
msgstr "## 21.13 Другие примитивы"

#: in/chapter21.md:1286
msgid ""
"To support the : `test` predicates made in various grammar rules we need "
"definitions of the Prolog predicates `if, member, =, numberp`, and `atom`.\n"
"They are repeated here:"
msgstr ""
"Для поддержки предикатов:  `test`, созданных в различных правилах "
"грамматики, нам нужны определения предикатов Пролога `if, member, =, "
"numberp` и `atom`.\n"
"Они повторяются здесь:"

#: in/chapter21.md:1307
msgid ""
"```lisp\n"
"(<- (if ?test ?then) (if ?then ?else (fail)))\n"
"(<- (if ?test ?then ?else) (call ?test) ! (call ?then))\n"
"(<- (if ?test ?then ?else) (call ?else))\n"
"(<- (member ?item (?item . ?rest)))\n"
"(<- (member ?item (?x . ?rest)) (member ?item ?rest))\n"
"(<- (= ?x ?x))\n"
"(defun numberp/1 (x cont)\n"
"    (when (numberp (deref x))\n"
"      (funcall cont)))\n"
"(defun atom/1 (x cont)\n"
"    (when (atom (deref x))\n"
"      (funcall cont)))\n"
"(defun call/1 (goal cont)\n"
"    \"Try to prove goal by calling it.\"\n"
"    (deref goal)\n"
"    (apply (make-predicate (first goal)\n"
"                    (length (args goal)))\n"
"            (append (args goal) (list cont))))\n"
"```"
msgstr ""

#: in/chapter21.md:1309
msgid "## 21.14 Examples"
msgstr "## 21.14 Примеры"

#: in/chapter21.md:1313
msgid ""
"Here are some examples of what the parser can handle.\n"
"I have edited the output by changing variable names like `?168` to more "
"readable names like `?J`.\n"
"The first two examples show that nested clauses are supported and that we "
"can extract a constituent from a nested clause:"
msgstr ""
"Вот несколько примеров того, что может обрабатывать парсер.\n"
"Я отредактировал вывод, изменив имена переменных, такие как `?168`, на более "
"читаемые имена, такие как `?J`.\n"
"Первые два примера показывают, что поддерживаются вложенные предложения и "
"что мы можем извлечь составляющую из вложенного предложения:"

#: in/chapter21.md:1329
msgid ""
"```lisp\n"
"> (try S John promised Kim to persuade Lee to sleep)\n"
"?SEM = (AND (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)\n"
"            (PAST ?P) (PROMISE ?P)\n"
"            (GOAL ?P ?K) (THE ?K (NAME KIM ?K))\n"
"            (CON ?P ?PER) (PERSUADE ?PER) (GOAL ?PER ?L)\n"
"            (THE ?L (NAME LEE ?L)) (CON ?PER ?S) (SLEEP ?S));\n"
"> (try S Who did John promise Kim to persuade to sleep)\n"
"?SEM = (AND (WH ?W (PERSON ?W)) (PAST ?P)\n"
"            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)\n"
"            (PROMISE ?P) (GOAL ?P ?K)\n"
"            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)\n"
"            (PERSUADE ?PER) (GOAL ?PER ?W)\n"
"            (CON ?PER ?S) (SLEEP ?S));\n"
"```"
msgstr ""

#: in/chapter21.md:1332
msgid ""
"In the next example, the \"when\" can be interpreted as asking about the "
"time of any of the three events: the promising, the persuading, or the "
"sleeping.\n"
"The grammar finds all three."
msgstr ""
"В следующем примере \"when\"(когда) можно интерпретировать как вопрос о "
"времени любого из трех событий: обещания, убеждения или сна.\n"
"Грамматика находит все три."

#: in/chapter21.md:1357
msgid ""
"```lisp\n"
">(try S When did John promise Kim to persuade Lee to sleep)\n"
"?SEM = (AND (WH ?W (TIME ?S ?W)) (PAST ?P)\n"
"            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)\n"
"            (PROMISE ?P) (GOAL ?P ?K)\n"
"            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)\n"
"            (PERSUADE ?PER) (GOAL ?PER ?L)\n"
"            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)\n"
"            (SLEEP ?S));\n"
"?SEM = (AND (WH ?W (TIME ?PER ?W)) (PAST ?P)\n"
"            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)\n"
"            (PROMISE ?P) (GOAL ?P ?K)\n"
"            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)\n"
"            (PERSUADE ?PER) (GOAL ?PER ?L)\n"
"            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)\n"
"            (SLEEP ?S));\n"
"?SEM = (AND (WH ?W (TIME ?P ?W)) (PAST ?P)\n"
"            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)\n"
"            (PROMISE ?P) (GOAL ?P ?K)\n"
"            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)\n"
"            (PERSUADE ?PER) (GOAL ?PER ?L)\n"
"            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)\n"
"            (SLEEP ?S)).\n"
"```"
msgstr ""

#: in/chapter21.md:1360
msgid ""
"The next example shows auxiliary verbs and negation.\n"
"It is ambiguous between an interpretation where Kim is searching for Lee and "
"one where Kim is looking at something unspecified, on Lee's behalf."
msgstr ""
"В следующем примере показаны вспомогательные глаголы и отрицание.\n"
"Это неоднозначно между интерпретацией, в которой Ким ищет Ли, и "
"интерпретацией, в которой Ким смотрит на что-то неопределенное от имени Ли."

#: in/chapter21.md:1372
msgid ""
"```lisp\n"
">(try S Kim would not have been looking for Lee)\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?S ?K)\n"
"            (EXPECTED ?S) (NOT ?S) (PAST-PARTICIPLE ?S)\n"
"            (PROGRESSIVE ?S) (SEARCH ?S) (PAT ?S ?L)\n"
"            (PAT ?S ?L) (THE ?L (NAME LEE ?L)));\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?2 ?K)\n"
"            (EXPECTED ?2) (NOT ?2) (PAST-PARTICIPLE ?LOOK)\n"
"            (PROGRESSIVE ?LOOK) (LOOK ?LOOK) (FOR ?LOOOK ?L)\n"
"            (THE ?L (NAME LEE ?L)));\n"
"```"
msgstr ""

#: in/chapter21.md:1374
msgid "The next two examples are unambiguous:"
msgstr "Следующие два примера однозначны:"

#: in/chapter21.md:1391
msgid ""
"```lisp\n"
">(try s It should not surprise you that Kim does not like Lee)\n"
"?SEM = (AND (MANDATORY ?2) (NOT ?2) (SURPRISE ?2) (EXP ?2 ?Y0U)\n"
"            (PRO ?YOU (LISTENER ?YOU)) (CON ?2 ?LIKE)\n"
"            (THE ?K (NAME KIM ?K)) (AGT ?LIKE ?K)\n"
"            (PRESENT ?LIKE) (NOT ?LIKE) (LIKE-1 ?LIKE)\n"
"            (OBJ ?LIKE ?L) (THE ?L (NAME LEE ?L)));\n"
">(try s Kim did not want Lee to know that the man knew her)\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?W ?K) (PAST ?W)\n"
"            (NOT ?W) (DESIRE ?W) (GOAL ?W ?L)\n"
"            (THE ?L (NAME LEE ?L)) (CON ?W ?KN)\n"
"            (KNOW-THAT ?KN) (CON ?KN ?KN2)\n"
"            (THE ?M (MAN ?M)) (AGT ?KN2 ?M) (PAST ?KN2)\n"
"            (KNOW-OF ?KN2) (OBJ ?KN2 ?HER)\n"
"            (PRO ?HER (FEMALE ?HER))).\n"
"```"
msgstr ""

#: in/chapter21.md:1396
msgid ""
"The final example appears to be unambiguous, but the parser finds four "
"separate parses.\n"
"The first is the obvious interpretation where the looking up is done "
"quickly, and the second has quickly modifying the surprise.\n"
"The last two interpretations are the same as the first two; they are "
"artifacts of the search process.\n"
"A disambiguation procedure should be equipped to weed out such duplicates."
msgstr ""
"Последний пример кажется недвусмысленным, но синтаксический анализатор "
"находит четыре отдельных анализа.\n"
"Первая - это очевидная интерпретация, когда поиск выполняется быстро, а "
"вторая - быстро изменяет удивление.\n"
"Последние две интерпретации такие же, как и первые две; они являются "
"артефактами поискового процесса.\n"
"Должна быть оборудована процедура устранения неоднозначности, чтобы отсеять "
"такие дубликаты."

#: in/chapter21.md:1416
msgid ""
"```lisp\n"
">(try s That Kim looked her up quickly surprised me)\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU1 ?K) (PAST ?LU1)\n"
"            (LOOK-UP ?LU1) (PAT ?LU1 ?H) (PRO ?H (FEMALE ?H))\n"
"            (QUICKLY ?LU1) (CON ?S ?LU1) (PAST ?S) (SURPRISE ?S)\n"
"            (EXP ?S ?ME1) (PRO ?ME1 (SPEAKER ?ME1)));\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU2 ?K) (PAST ?LU2)\n"
"            (LOOK-UP ?LU2) (PAT ?LU2 ?H) (PRO ?H (FEMALE ?H))\n"
"            (CON ?S ?LU2) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)\n"
"            (EXP ?S ?ME2) (PRO ?ME2 (SPEAKER ?ME2)));\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU3 ?K) (PAST ?LU3)\n"
"            (LOOK-UP ?LU3) (PAT ?LU3 ?H) (PRO ?H (FEMALE ?H))\n"
"            (QUICKLY ?LU3) (CON ?S ?LU3) (PAST ?S) (SURPRISE ?S)\n"
"            (EXP ?S ?ME3) (PRO ?ME3 (SPEAKER ?ME3)));\n"
"?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU4 ?K) (PAST ?LU4)\n"
"            (LOOK-UP ?LU4) (PAT ?LU4 ?H) (PRO ?H (FEMALE ?H))\n"
"            (CON ?S ?LU4) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)\n"
"            (EXP ?S ?ME4) (PRO ?ME4 (SPEAKER ?ME4)));\n"
"```"
msgstr ""

#: in/chapter21.md:1418
msgid "## 21.15 History and References"
msgstr "## 21.15 История и ссылки"

#: in/chapter21.md:1421
msgid ""
"[Chapter 20](B9780080571157500200.xhtml) provides some basic references on "
"natural language.\n"
"Here we will concentrate on references that provide:"
msgstr ""

#: in/chapter21.md:1424
msgid ""
"1.  A comprehensive grammar of English.\n"
"!!!(p) {:.numlist}"
msgstr ""

#: in/chapter21.md:1427
msgid ""
"2.  A complete implementation.\n"
"!!!(p) {:.numlist}"
msgstr ""

#: in/chapter21.md:1430
msgid ""
"There are a few good textbooks that partially address both issues.\n"
"Both [Winograd (1983)](B9780080571157500285.xhtml#bb1395) and [Allen (1987)]"
"(B9780080571157500285.xhtml#bb0030) do a good job of presenting the major "
"grammatical features of English and discuss implementation techniques, but "
"they do not provide actual code."
msgstr ""

#: in/chapter21.md:1436
msgid ""
"There are also a few textbooks that concentrate on the second issue.\n"
"[Ramsey and Barrett (1987)](B9780080571157500285.xhtml#bb0975) and [Walker "
"et al.\n"
"(1990)](B9780080571157500285.xhtml#bb1295) provide chapter-length "
"implementations at about the same level of detail as this chapter.\n"
"Both are recommended.\n"
"[Pereira and Shieber 1987](B9780080571157500285.xhtml#bb0945) and [Gazdar "
"and Mellish 1989](B9780080571157500285.xhtml#bb0445) are book-length "
"treatments, but because they cover a variety of parsing techniques rather "
"than concentrating on one in depth, they are actually less comprehensive."
msgstr ""

#: in/chapter21.md:1441
msgid ""
"Several linguists have made serious attempts at addressing the first issue.\n"
"The largest is the aptly named A *Comprehensive Grammar of Contemporary "
"English* by Quirk, Greenbaum, Leech and Svartik (1985).\n"
"More manageable (although hardly concise) is their abridged edition, *A "
"Concise Grammar of Contemporary English.* Both editions contain a gold mine "
"of examples and facts about the English langauge, but the authors do not "
"attempt to write rigorous rules.\n"
"[Harris (1982)](B9780080571157500285.xhtml#bb0510) and [Huddleston (1984)]"
"(B9780080571157500285.xhtml#bb0555) offer less complete grammars with "
"greater linguistic rigor."
msgstr ""

#: in/chapter21.md:1444
msgid ""
"Naomi [Sager (1981)](B9780080571157500285.xhtml#bb1035) presents the most "
"complete computerized grammar ever published.\n"
"The grammar is separated into a simple, neat, context-free component and a "
"rather baroque augmentation that manipulates features."
msgstr ""

#: in/chapter21.md:1446
msgid "## 21.16 Exercises"
msgstr "## 21.16 Упражнения"

#: in/chapter21.md:1449
msgid ""
"**Exercise  21.1 [m]** Change the grammar to account better for *mass nouns."
"* The current grammar treats mass nouns by making them vague between "
"singular and plural, which is incorrect.\n"
"They should be treated separately, since there are determiners such as \"much"
"\" that work only with mass nouns, and other determiners such as \"these\" "
"that work only with plural count nouns."
msgstr ""

#: in/chapter21.md:1452
msgid ""
"**Exercise  21.2 [m]** Change the grammar to make a distinction between "
"*attributive* and *predicative* adjectives.\n"
"Most adjectives fail into both classes, but some can be used only "
"attributively, as in \"an *utter* fool\" but not \" * the fool is *utter.\"* "
"Other adjectives can only be used predicatively, as in \"the woman was "
"*loath* to admit it\" but not \"*a *loath* (to admit it) woman.\""
msgstr ""

#: in/chapter21.md:1455
msgid ""
"**Exercise  21.3 [h]** Implement complement lists for adjectives, so that "
"\"loath\" would take an obligatory infinitive complement, and \"proud\" "
"would take an optional (PP of) complement.\n"
"In connection to the previous exercise, note that it is rare if not "
"impossible for attributive adjectives to take complements: \"he is proud,\" "
"\"he is proud of his country\" and \"a proud citizen\" are all acceptable, "
"but \"*a proud of his country citizen\" is not."
msgstr ""

#: in/chapter21.md:1457
msgid ""
"**Exercise  21.4 [m]** Add rules to advp to allow for adverbs to modify "
"other adverbs, as in \"extremely likely\" or \"very strongly.\""
msgstr ""

#: in/chapter21.md:1463
msgid ""
"**Exercise  21.5 [h]** Allow adverbs to modify adjectives, as in \"very good"
"\" or \"really delicious.\" The syntax will be easy, but it is harder to get "
"a reasonable semantics.\n"
"While you're at it, make sure that you can handle adjectives with so-called "
"*noninter- sective* semantics.\n"
"Some adjectives can be handled by intersective semantics: a red circle is "
"something that is red and is a circle.\n"
"But for other adjectives, this model does not work: a former senator is not "
"something that is former and is a senator-a former senator is not a senator "
"at all.\n"
"Similarly, a toy elephant is not an elephant."
msgstr ""

#: in/chapter21.md:1465
msgid ""
"The semantics should be represented by something doser to `((toy elephant) ?"
"x)` rather than `(and (toy ?x) (elephant ?x))`."
msgstr ""

#: in/chapter21.md:1468
msgid ""
"**Exercise  21.6 [m]** Write a function that notices punctuation instead of "
"ignoring it.\n"
"It should work something like this:"
msgstr ""

#: in/chapter21.md:1473
msgid ""
"```lisp\n"
"(string->words \"Who asked Lee, Kim and John?\")\n"
"(WHO ASKED LEE |,| KIM AND JOHN |?|)\n"
"```"
msgstr ""

#: in/chapter21.md:1475
msgid ""
"**Exercise  21.7 [m]** Change the grammar to allow optional punctuation "
"marks at the end of sentences and before relative clauses."
msgstr ""

#: in/chapter21.md:1478
msgid ""
"**Exercise  21.8 [m]** Change the grammar to allow conjunction with more "
"than two elements, using commas.\n"
"Can these rules be generated automatically by `conj-rule?`"
msgstr ""

#: in/chapter21.md:1483
msgid ""
"**Exercise  21.9 [h]** Make a distinction between *restrictive* and "
"*nonrestrictive* relative clauses.\n"
"In \"The truck *that has 4-wheel drive* costs $5000,\" the italicized "
"relative clause is restrictive.\n"
"It serves to identify the truck and thus would be part of the quantifier's "
"restriction.\n"
"The complete sentence might be interpreted as:"
msgstr ""

#: in/chapter21.md:1488
msgid ""
"```lisp\n"
"(and (the ?x (and (truck ?x) (4-wheel-drive ?x)))\n"
"        (costs ?x $5000))\n"
"```"
msgstr ""

#: in/chapter21.md:1490
msgid ""
"Contrast this to \"The truck, which has 4-wheel drive, costs $5000.\" Here "
"the relative clause is nonrestrictive and thus belongs outside the "
"quantifier's restriction:"
msgstr ""

#: in/chapter21.md:1495
msgid ""
"```lisp\n"
"(and (the ?x (truck ?x))\n"
"      (4-wheel-drive ?x) (costs ?x $5000))\n"
"```"
msgstr ""

#: in/chapter21.md:1499
msgid ""
"Part V\n"
"The Rest of Lisp\n"
"!!!(p) {:.parttitle}"
msgstr ""
