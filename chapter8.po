#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter8.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-01-13 09:28+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter8.md:3
msgid ""
"# Chapter 8\n"
"## Symbolic Mathematics: A Simplification Program"
msgstr ""
"# Глава 8\n"
"## Символьная Математика: Программа Упрощения"

#: in/chapter8.md:5
msgid "> *Our life is frittered away by detail....*"
msgstr "> *Наша жизнь испорчена деталями....*"

#: in/chapter8.md:7
msgid "> *Simplify, simplify.*"
msgstr "> *Упрощай, упрощай.*"

#: in/chapter8.md:9
msgid "> -Henry David Thoreau, *Walden* (1854)"
msgstr ""

#: in/chapter8.md:16
msgid ""
"\"Symbolic mathematics\" is to numerical mathematics as algebra is to "
"arithmetic: it deals with variables and expressions rather than just "
"numbers.\n"
"Computers were first developed primarily to solve arithmetic problems: to "
"add up large columns of numbers, to multiply many-digit numbers, to solve "
"systems of linear equations, and to calculate the trajectories of "
"ballistics.\n"
"Encouraged by success in these areas, people hoped that computers could also "
"be used on more complex problems; to differentiate or integrate a "
"mathematical expression and come up with another expression as the answer, "
"rather than just a number.\n"
"Several programs were developed along these lines in the 1960s and 1970s.\n"
"They were used primarily by professional mathematicians and physicists with "
"access to large mainframe computers.\n"
"Recently, programs like MATHLAB, DERIVE, and MATHEMATICA have given these "
"capabilities to the average personal computer user."
msgstr ""
"\"Символьная математика\" относится к числовой математике так же, как "
"алгебра к арифметике: она имеет дело с переменными и выражениями, а не "
"только с числами.\n"
"Первоначально компьютеры были разработаны в первую очередь для решения "
"арифметических задач: для суммирования длинных числовых столбцов, для "
"умножения многозначных чисел, для решения систем линейных уравнений и для "
"расчета траекторий баллистики.\n"
"Ободренные успехом в этих областях, люди надеялись, что компьютеры можно "
"будет использовать и для решения более сложных задач; дифференцировать или "
"интегрировать математическое выражение и получить другое выражение в "
"качестве ответа, а не просто число.\n"
"Несколько программ были разработаны в этом направлении в 1960-х и 1970-х "
"годах.\n"
"Они использовались в основном профессиональными математиками и физиками, "
"имеющими доступ к большим мэйнфреймам.\n"
"Недавно такие программы, как MATHLAB, DERIVE и MATHEMATICA, предоставили эти "
"возможности среднему пользователю персонального компьютера."

#: in/chapter8.md:22
msgid ""
"It is interesting to look at some of the history of symbolic algebra, "
"beginning in 1963 with SAINT, James Slagle's program to do symbolic "
"integration.\n"
"Originally, SAINT was heralded as a triumph of AI.\n"
"It used general problem-solving techniques, similar in kind to GPS, to "
"search for solutions to difficult problems.\n"
"The program worked its way through an integration problem by choosing among "
"the techniques known to it and backing up when an approach failed to pan "
"out.\n"
"SAINT's behavior on such problems was originally similar to (and eventually "
"much better than) the performance of undergraduate calculus students."
msgstr ""
"Интересно взглянуть на историю символической алгебры, которая началась в "
"1963 году с SAINT, программы Джеймса Слэгла по символьному интегрированию.\n"
"Первоначально SAINT был провозглашен триумфом AI.\n"
"Он использовал общие методы решения проблем, аналогичные GPS, для поиска "
"решений сложных проблем.\n"
"Программа преодолела проблему интеграции, выбрав один из известных ей "
"методов и выполняла откат назад, когда какой-либо подход не удавался.\n"
"Поведение SAINT при решении таких задач изначально было подобно (а в "
"конечном итоге намного лучше) результативности студентов-математиков."

#: in/chapter8.md:27
msgid ""
"Over time, the AI component of symbolic integration began to disappear.\n"
"Joel Moses implemented a successor to SAINT called SIN.\n"
"It used many of the same techniques, but instead of relying on search to "
"find the right combination of techniques, it had additional mathematical "
"knowledge that led it to pick the right technique at each step, without any "
"provision for backing up and trying an alternative.\n"
"SIN solved more problems and was much faster than SAINT, although it was not "
"perfect: it still occasionally made the wrong choice and failed to solve a "
"problem it could have."
msgstr ""
"Со временем ИИ-компонент символьной интеграции начал исчезать.\n"
"Джоиль Мозес реализовал преемника SAINT назвав его SIN.\n"
"Он использовал многие из тех же самых методов, но вместо того, чтобы "
"полагаться на поиск, чтобы найти правильную комбинацию методов, он имел "
"дополнительные математические знания, которые заставляли программу выбирать "
"правильную технику на каждом шаге, без какого-либо обеспечения возвратов "
"назад и альтернативных попыток.\n"
"SIN решал больше проблем и был гораздо быстрее SAINT, хотя и не был "
"совершенным: он все еще иногда делал неправильный выбор и мог не решить "
"проблему, которую ему задали."

#: in/chapter8.md:32
msgid ""
"By 1970, the mathematician R.\n"
"Risch and others developed algorithms for indefinite integration of any "
"expression involving algebraic, logarithmic, or exponential extensions of "
"rational functions.\n"
"In other words, given a \"normal\" function, the Risch algorithm will return "
"either the indefinite integral of the function or an indication that no "
"closed-form integral is possible in terms of elementary functions.\n"
"Such work effectively ended the era of considering integration as a problem "
"in search."
msgstr ""
"К 1970 году математик Р.Риш и другие разработали алгоритмы неопределенного "
"интегрирования любого выражения, включающего алгебраические, логарифмические "
"или экспоненциальные расширения рациональных функций.\n"
"Другими словами, для \"нормальной\" функции алгоритм Риша вернет либо "
"неопределенный интеграл функции, либо указание на то, что интеграл в "
"замкнутой форме невозможен в терминах элементарных функций.\n"
"Эта работа положила конец эпохе рассмотрения интегрирования как проблемы "
"поиска."

#: in/chapter8.md:38
msgid ""
"SIN was further refined, merged with parts of the Risch algorithm, and put "
"into the evolving MACSYMA [1](#fn0010) program.\n"
"For the most part, refinement of MACSYMA consisted of the incorporation of "
"new algorithms.\n"
"Few heuristics of any sort survive.\n"
"Today MACSYMA is no longer considered an AI program.\n"
"It is used daily by scientists and mathematicians, while ELIZA and STUDENT "
"are now but historical footnotes."
msgstr ""
"SIN был дополнительно доработан, объединен с частями алгоритма Риша и "
"включен в развивающуюся программу MACSYMA [1] (#fn0010).\n"
"По большей части усовершенствование MACSYMA состояло из включения новых "
"алгоритмов.\n"
"Лишь немногие эвристики выживают.\n"
"Сегодня MACSYMA больше не считается программой ИИ.\n"
"Её ежедневно используют ученые и математики, в то время как ELIZA и STUDENT "
"теперь являются лишь историческими сносками."

#: in/chapter8.md:43
msgid ""
"With ELIZA and STUDENT we were able to develop miniature programs that "
"duplicated most of the features of the original.\n"
"We won't even try to develop a program worthy of the name MACSYMA; instead "
"we will settle for a modest program to do symbolic simplification, which we "
"will call (simply) `simplifier`.\n"
"Then, we will extend `simplifier` to do differentiation, and some "
"integration problems.\n"
"The idea is that given an expression like (2 - 1)*x* + 0, we want the "
"program to compute the simplified form *x*."
msgstr ""
"С помощью ELIZA и STUDENT мы смогли разработать миниатюрные программы, "
"которые дублировали большинство функций оригинала.\n"
"Мы даже не будем пытаться разработать программу, достойную названия MACSYMA; "
"вместо этого мы довольствуемся скромной программой для символического "
"упрощения, которую мы будем называть (просто) `simplifier`.\n"
"Затем мы расширим `simplifier`, чтобы выполнять дифференцирование и "
"некоторые задачи интегрирования.\n"
"Идея состоит в том, что при таком выражении, как (2-1)*x* + 0, мы хотим, "
"чтобы программа вычисляла упрощенную форму *x*."

#: in/chapter8.md:49
msgid ""
"According to the *Mathematics Dictionary* (James and James 1949), the word "
"\"simplified\" is \"probably the most indefinite term used seriously in "
"mathematics.\" The problem is that \"simplified\" is relative to what you "
"want to use the expression for next.\n"
"Which is simpler, *x*2 + 3*x* + 2 or (*x* + 1)(*x* + 2)?\n"
"The first makes it easier to integrate or differentiate, the second easier "
"to find roots.\n"
"We will be content to limit ourselves to \"obvious\" simplifications.\n"
"For example, *x* is almost always preferable to 1*x* + 0."
msgstr ""
"Согласно *Математическому словарю* (Джеймс и Джеймс, 1949), слово "
"\"упрощенный\" - это \"вероятно, самый неопределенный термин, серьезно "
"используемый в математике\". Проблема в том, что \"упрощение\" относится к "
"тому, что вы хотите использовать для следующего выражения.\n"
"Что проще: *x* 2 + 3 *x* + 2 или (*x* + 1) (*x* + 2)?\n"
"Первое упрощает интегрирование или дифференцирование, второе - поиск "
"корней.\n"
"Мы ограничимся \"очевидными\" упрощениями.\n"
"Например, *x* почти всегда предпочтительнее 1 *x* + 0."

#: in/chapter8.md:51
msgid "## 8.1 Converting Infix to Prefix Notation"
msgstr "## 8.1 Преобразование инфиксной в префиксную нотацию"

#: in/chapter8.md:58
msgid ""
"We will represent simplifications as a list of rules, much like the rules "
"for STUDENT and ELIZA.\n"
"But since each simplification rule is an algebraic equation, we will store "
"each one as an exp rather than as a `rule`.\n"
"To make things more legible, we will write each expression in infix form, "
"but store them in the prefix form expected by `exp`.\n"
"This requires an `infix->prefix` function to convert infix expressions into "
"prefix notation.\n"
"We have a choice as to how general we want our infix notation to be.\n"
"Consider:"
msgstr ""
"Мы представим упрощения в виде списка правил, очень похожих на правила для "
"STUDENT и ELIZA.\n"
"Но поскольку каждое правило упрощения представляет собой алгебраическое "
"уравнение, мы будем хранить каждое из них как exp, а не как `rule`.\n"
"Чтобы сделать вещи более понятными, мы будем писать каждое выражение в "
"инфиксной форме, но хранить их в префиксной форме, ожидаемой `exp`.\n"
"Для этого требуется функция `infix->prefix` для преобразования инфиксных "
"выражений в префиксную нотацию.\n"
"У нас есть выбор, насколько общими мы хотим, чтобы наша инфиксная нотация "
"была.\n"
"Рассмотрим:"

#: in/chapter8.md:65
msgid ""
"```lisp\n"
"(((a * (x ^ 2)) + (b * x)) + c)\n"
"(a * x ^ 2 + b * x + c)\n"
"(a x ^ 2 + b x + c)\n"
"a x^2 + b*x+c\n"
"```"
msgstr ""

#: in/chapter8.md:68
msgid ""
"The first is fully parenthesized infix, the second makes use of operator "
"precedence (multiplication binds tighter than addition and is thus performed "
"first), and the third makes use of implicit multiplication as well as "
"operator precedence.\n"
"The fourth requires a lexical analyzer to break Lisp symbols into pieces."
msgstr ""
"Первый инфиксный, заключенный в круглые скобки, второй использует приоритет "
"операторов (умножение связывает сильнее, чем сложение, и поэтому выполняется "
"первым), а третий использует неявное умножение, а также приоритет "
"операторов.\n"
"Четвертый требует наличия лексического анализатора, чтобы разбивать символы "
"Лиспа на части."

#: in/chapter8.md:78
msgid ""
"Suppose we only wanted to handle the fully parenthesized case.\n"
"To write `infix->prefix`, one might first look at `prefix->infix` (on [page "
"228](B9780080571157500078.xhtml#p228)) trying to adapt it to our new "
"purposes.\n"
"In doing so, the careful reader might discover a surprise: `infix->prefix` "
"and `prefix->infix` are in fact the exact same function!\n"
"Both leave atoms unchanged, and both transform three-element lists by "
"swapping the `exp-op` and `exp-lhs`.\n"
"Both apply themselves recursively to the (possibly rearranged) input list.\n"
"Once we discover this fact, it would be tempting to avoid writing `infix-"
">prefix`, and just call `prefix->infix` instead.\n"
"Avoid this temptation at all costs.\n"
"Instead, define `infix->prefix` as shown below.\n"
"The intent of your code will be clearer:"
msgstr ""
"Предположим, мы хотим обработать только случай, при котором выражение "
"полностью заключено в круглые скобки.\n"
"Чтобы написать `infix->prefix`, можно сначала взглянуть на `prefix->infix` "
"(на [стр. 228] (B9780080571157500078.xhtml#p228)), попытавшись приспособить "
"его к нашим новым целям.\n"
"При этом внимательный читатель может обнаружить сюрприз: `infix->prefix` и "
"`prefix->infix` на самом деле являются одной и той же функцией!\n"
"Обе оставляют атомы без изменений, и обе преобразуют трехэлементные списки, "
"меняя местами `exp-op` и `exp-lhs`.\n"
"Обе применяются рекурсивно к (возможно, измененному) входному списку.\n"
"Как только мы обнаружим этот факт, возникнет соблазн не писать `infix-"
">prefix`, а вместо этого просто вызвать `prefix->infix`.\n"
"Избегайте этого искушения любой ценой.\n"
"Вместо этого определите `infix->prefix`, как показано ниже.\n"
"Предназначение вашего кода будет более ясным:"

#: in/chapter8.md:84
msgid ""
"```lisp\n"
"(defun infix->prefix (infix-exp)\n"
"  \"Convert fully parenthesized infix-exp to a prefix expression\"\n"
"  ;; Don't use this version for non-fully parenthesized exps!\n"
"```"
msgstr ""

#: in/chapter8.md:86
msgid "  `(prefix->infix infix-exp))`"
msgstr ""

#: in/chapter8.md:91
msgid ""
"As we saw above, fully parenthesized infix can be quite ugly, with all those "
"extra parentheses, so instead we will use operator precedence.\n"
"There are a number of ways of doing this, but the easiest way for us to "
"proceed is to use our previously defined tool `rule-based-translator` and "
"its subtool, `pat-match.` Note that the third clause of `infix->prefix`, the "
"one that calls `rule-based-translator` is unusual in that it consists of a "
"single expression.\n"
"Most cond-clauses have two expressions: a test and a result, but ones like "
"this mean, \"Evaluate the test, and if it is non-nil, return it.\n"
"Otherwise go on to the next clause.\""
msgstr ""
"Как мы видели выше, полностью заключенная в круглые скобки инфиксная запись "
"может быть довольно уродливой, со всеми этими дополнительными круглыми "
"скобками, поэтому вместо этого мы будем использовать приоритет операторов.\n"
"Есть несколько способов сделать это, но самый простой способ продолжить - "
"использовать наш ранее определенный инструмент `rule-based-translator` и его "
"подинструмент `pat-match`. Обратите внимание, что третье предложение `infix-"
">prefix`, то, которое вызывает `rule-based-translator`, необычно тем, что "
"состоит из одного выражения.\n"
"Большинство условных предложений имеют два выражения: тест и результат, но "
"такие, как это, означают: \"Вычислить тест и, если результат не равен nil, "
"вернуть вычисленное значение.\n"
"В противном случае переходите к следующему предложению\"."

#: in/chapter8.md:112
msgid ""
"```lisp\n"
"(defun infix->prefix (exp)\n"
"  \"Translate an infix expression into prefix notation.\"\n"
"  ;; Note we cannot do implicit multiplication in this system\n"
"  (cond ((atom exp) exp)\n"
"        ((= (length exp) 1) (infix->prefix (first exp)))\n"
"        ((rule-based-translator exp *infix->prefix-rules*\n"
"           :rule-if #'rule-pattern :rule-then #'rule-response\n"
"           :action\n"
"           #'(lambda (bindings response)\n"
"               (sublis (mapcar\n"
"                         #'(lambda (pair)\n"
"                             (cons (first pair)\n"
"                                   (infix->prefix (rest pair))))\n"
"                         bindings)\n"
"                       response))))\n"
"        ((symbolp (first exp))\n"
"         (list (first exp) (infix->prefix (rest exp))))\n"
"        (t (error \"Illegal exp\"))))\n"
"```"
msgstr ""

#: in/chapter8.md:114
msgid ""
"Because we are doing mathematics in this chapter, we adopt the mathematical "
"convention of using certain one-letter variables, and redefine `variable-p` "
"so that variables are only the symbols `m` through `z`."
msgstr ""
"Поскольку в этой главе мы занимаемся математикой, мы принимаем "
"математическое соглашение об использовании некоторых однобуквенных "
"переменных и переопределим `variable-p` так, чтобы переменные представляли "
"собой только символы от `m` до `z`."

#: in/chapter8.md:120
msgid ""
"```lisp\n"
"(defun variable-p (exp)\n"
"  \"Variables are the symbols M through Z.\"\n"
"  ;; put x,y,z first to find them a little faster\n"
"  (member exp '(x y z m n o p q r s t u v w)))"
msgstr ""

#: in/chapter8.md:124
msgid ""
";; Define x+ and y+ as a sequence:\n"
"(pat-match-abbrev 'x+ '(?+ x))\n"
"(pat-match-abbrev 'y+ '(?+ y))"
msgstr ""

#: in/chapter8.md:127
msgid ""
"(defun rule-pattern (rule) (first rule))\n"
"(defun rule-response (rule) (second rule))"
msgstr ""

#: in/chapter8.md:140
msgid ""
"(defparameter *infix->prefix-rules*\n"
"  (mapcar #'expand-pat-match-abbrev\n"
"    '(((x+ = y+) (= x y))\n"
"      ((- x+)    (- x))\n"
"      ((+ x+)    (+ x))\n"
"      ((x+ + y+) (+ x y))\n"
"      ((x+ - y+) (- x y))\n"
"      ((x+ * y+) (* x y))\n"
"      ((x+ / y+) (/ x y))\n"
"      ((x+ ^ y+) (^ x y)))))\n"
"  \"A list of rules, ordered by precedence.\")\n"
"```"
msgstr ""

#: in/chapter8.md:142
msgid "## 8.2 Simplification Rules"
msgstr "## 8.2 Правила Упрощения"

#: in/chapter8.md:146
msgid ""
"Now we are ready to define the simplification rules.\n"
"We use the definition of the data types rule and exp ([page 221]"
"(B9780080571157500078.xhtml#p221)) and `prefix->infix` ([page 228]"
"(B9780080571157500078.xhtml#p228)) from STUDENT.\n"
"They are repeated here:"
msgstr ""
"Теперь мы готовы определить правила упрощения.\n"
"Мы используем определение типа данных rule и exp ([стр. 221]"
"(B9780080571157500078.xhtml#p221)) и `prefix->infix` ([page 228]"
"(B9780080571157500078.xhtml#p228)) из STUDENT.\n"
"Они повторяются здесь:"

#: in/chapter8.md:152
msgid ""
"```lisp\n"
"(defstruct (rule (:type list)) pattern response)\n"
"(defstruct (exp (:type list)\n"
"                (:constructor mkexp (lhs op rhs)))\n"
"  op lhs rhs)"
msgstr ""

#: in/chapter8.md:155
msgid ""
"(defun exp-p (x) (consp x))\n"
"(defun exp-args (x) (rest x))"
msgstr ""

#: in/chapter8.md:163
msgid ""
"(defun prefix->infix (exp)\n"
"  \"Translate prefix to infix expressions.\"\n"
"  (if (atom exp) exp\n"
"      (mapcar #'prefix->infix\n"
"              (if (binary-exp-p exp)\n"
"                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))\n"
"                  exp))))"
msgstr ""

#: in/chapter8.md:167
msgid ""
"(defun binary-exp-p (x)\n"
"  (and (exp-p x) (= (length (exp-args x)) 2)))\n"
"```"
msgstr ""

#: in/chapter8.md:171
msgid ""
"We also use `rule-based-translator` ([page 188](B9780080571157500066."
"xhtml#p188)) once again, this time on a list of simplification rules.\n"
"A reasonable list of simplification rules is shown below.\n"
"This list covers the four arithmetic operators, addition, subtraction, "
"multiplication, and division, as well as exponentiation (raising to a "
"power), denoted by the symbol \"^\""
msgstr ""
"Мы также снова используем `rule-based-translator` ([page 188]"
"(B9780080571157500066.xhtml#p188)), на этот раз со списком правил "
"упрощения.\n"
"Разумный список правил упрощения показан ниже.\n"
"Этот список охватывает четыре арифметических оператора: сложение, вычитание, "
"умножение и деление, а также возведение в степень(exp), обозначаемый "
"символом \"^\""

#: in/chapter8.md:175
msgid ""
"Again, it is important to note that the rules are ordered, and that later "
"rules will be applied only when earlier rules do not match.\n"
"So, for example, 0 / 0 simplifies to `undefined,` and not to 1 or 0, because "
"the rule for 0 / 0 comes before the other rules.\n"
"See [exercise 8.8](#st0045) for a more complete treatment of this."
msgstr ""
"Опять же, важно отметить, что правила упорядочены, и что более поздние "
"правила будут применяться только тогда, когда более ранние правила не "
"совпадают.\n"
"Так, например, 0/0 упрощается до `undefined`, а не до 1 или 0, потому что "
"правило для 0 / 0 предшествует другим правилам.\n"
"См. [Упражнение 8.8](#st0045) для более полной обработки этого."

#: in/chapter8.md:208
msgid ""
"```lisp\n"
"(setf *simplification-rules* (mapcar #'simp-rule '(\n"
"  (x + 0  = x)\n"
"  (0 + x  = x)\n"
"  (x + x  = 2 * x)\n"
"  (x - 0  = x)\n"
"  (0 - x  = - x)\n"
"  (x - x  = 0)\n"
"  (- - x  = x)\n"
"  (x * 1  = x)\n"
"  (1 * x  = x)\n"
"  (x * 0  = 0)\n"
"  (0 * x  = 0)\n"
"  (x * x  = x ^ 2)\n"
"  (x / 0  = undefined)\n"
"  (0 / x  = 0)\n"
"  (x / 1  = x)\n"
"  (x / x  = 1)\n"
"  (0 ^ 0  = undefined)\n"
"  (x ^ 0  = 1)\n"
"  (0 ^ x  = 0)\n"
"  (1 ^ x  = 1)\n"
"  (x ^ 1  = x)\n"
"  (x ^ -1 = 1 / x)\n"
"  (x * (y / x) = y)\n"
"  ((y / x) * x = y)\n"
"  ((y * x) / x = y)\n"
"  ((x * y) / x = y)\n"
"  (x + - x = 0)\n"
"  ((- x) + x = 0)\n"
"  (x + y - x = y)\n"
"  )))"
msgstr ""

#: in/chapter8.md:211
msgid ""
"(defun ^ (x y) \"Exponentiation\" (expt x y))\n"
"```"
msgstr ""

#: in/chapter8.md:216
msgid ""
"We are now ready to go ahead and write the simplifier.\n"
"The main function, `simplifier` will repeatedly print a prompt, read an "
"input, and print it in simplified form.\n"
"Input and output is in infix and the computation is in prefix, so we need to "
"convert accordingly; the function simp does this, and the function "
"`simplify` takes care of a single prefix expression.\n"
"It is summarized in [figure  8.1](#f0010)."
msgstr ""
"Теперь мы готовы приступить к написанию упростителя.\n"
"Основная функция, `simpleifier`, будет многократно печатать приглашение-"
"подсказку, читать ввод и печатать его в упрощенной форме.\n"
"Ввод и вывод находятся в инфиксном виде, а вычисления - в префиксном, "
"поэтому нам нужно их соответственно преобразовать; функция simp делает это, "
"а функция `simpleify` заботится о единственном префиксном выражении.\n"
"Это кратко показано на [рис. 8.1](#f0010)."

#: in/chapter8.md:221
msgid ""
"| []()                                    |\n"
"|-----------------------------------------|\n"
"| ![f08-01](images/chapter8/f08-01.jpg)   |\n"
"| Figure 8.1: Glossary for the Simplifier |"
msgstr ""
"| []()                                    |\n"
"|-----------------------------------------|\n"
"| ![f08-01](images/chapter8/f08-01.jpg)   |\n"
"| Figure 8.1: Словарь для Simplifier |"

#: in/chapter8.md:223
msgid "(ed: this should be a markdown table)"
msgstr ""

#: in/chapter8.md:225
msgid "Here is the program:"
msgstr "Вот программа:"

#: in/chapter8.md:232
msgid ""
"```lisp\n"
"(defun simplifier ()\n"
"  \"Read a mathematical expression, simplify it, and print the result.\"\n"
"  (loop\n"
"    (print 'simplifier>)\n"
"    (print (simp (read)))))"
msgstr ""

#: in/chapter8.md:234
msgid "(defun simp (inf) (prefix->infix (simplify (infix->prefix inf))))"
msgstr ""

#: in/chapter8.md:239
msgid ""
"(defun simplify (exp)\n"
"  \"Simplify an expression by first simplifying its components.\"\n"
"  (if (atom exp) exp\n"
"      (simplify-exp (mapcar #'simplify exp))))"
msgstr ""

#: in/chapter8.md:249
msgid ""
";;; simplify-exp is redefined below\n"
"(defun simplify-exp (exp)\n"
"  \"Simplify using a rule, or by doing arithmetic.\"\n"
"  (cond ((rule-based-translator exp *simplification-rules*\n"
"           :rule-if #'exp-lhs :rule-then #'exp-rhs\n"
"           :action #'(lambda (bindings response)\n"
"                       (simplify (sublis bindings response)))))\n"
"        ((evaluable exp) (eval exp))\n"
"        (t exp)))"
msgstr ""

#: in/chapter8.md:257
msgid ""
"(defun evaluable (exp)\n"
"  \"Is this an arithmetic expression that can be evaluated?\"\n"
"  (and (every #'numberp (exp-args exp))\n"
"       (or (member (exp-op exp) '(+ - * /))\n"
"           (and (eq (exp-op exp) '^)\n"
"                (integerp (second (exp-args exp)))))))\n"
"```"
msgstr ""

#: in/chapter8.md:267
msgid ""
"The function `simplify` assures that any compound expression will be "
"simplified by first simplifying the arguments and then calling `simplify-exp."
"` This latter function searches through the simplification rules, much like "
"`use-eliza-rules` and `translate-to-expression`.\n"
"When it finds a match, `simplify-exp` substitutes in the proper variable "
"values and calls `simplify` on the result, `simplify-exp` also has the "
"ability to call `eval` to simplify an arithmetic expression to a number.\n"
"As in STUDENT, it is for the sake of this eval that we require expressions "
"to be represented as lists in prefix notation.\n"
"Numeric evaluation is done *after* checking the rules so that the rules can "
"intercept expressions like (/ 1 0) and simplify them to `undefined`.\n"
"If we did the numeric evaluation first, these expressions would yield an "
"error when passed to eval.\n"
"Because Common Lisp supports arbitrary precision rational numbers "
"(fractions), we are guaranteed there will be no round-off error, unless the "
"input explicitly includes inexact (floating-point) numbers.\n"
"Notice that we allow computations involving the four arithmetic operators, "
"but exponentiation is only allowed if the exponent is an integer.\n"
"That is because expressions like (^ 4 1/2) are not guaranteed to return 2 "
"(the exact square root of 4); the answer might be 2.0 (an inexact number).\n"
"Another problem is that -  2 is also a square root of 4, and in some "
"contexts it is the correct one to use."
msgstr ""
"Функция `simpleify` гарантирует, что любое составное выражение будет "
"упрощено, если сначала упростить аргументы, а затем вызвать `simpleify-exp`. "
"Эта последняя функция выполняет поиск по правилам упрощения, подобно `use-"
"eliza-rules` и `translate-to-expression`.\n"
"Когда она находит совпадение, `simpleify-exp` заменяет правильные значения "
"переменных и вызывает `simplify` для результата, `simplify-exp` также имеет "
"возможность вызвать `eval`, чтобы упростить арифметическое выражение до "
"числа.\n"
"Как и в STUDENT, именно ради этого eval мы и требуем, чтобы выражения были "
"представлены в виде списков в префиксной нотации.\n"
"Числовое вычисление выполняется *после* проверки правил, чтобы правила могли "
"перехватывать выражения вроде (/ 1 0) и упрощать их до ʻundefined`.\n"
"Если бы мы сначала выполнили числовое вычисление, эти выражения выдали бы "
"ошибку при передаче в eval.\n"
"Поскольку Common Lisp поддерживает рациональные числа (дроби) произвольной "
"точности, мы гарантируем, что не будет ошибки округления, если только "
"входные данные явно не включают неточные (с плавающей запятой) числа.\n"
"Обратите внимание, что мы разрешаем вычисления с участием четырех "
"арифметических операторов, но возведение в степень разрешено только в том "
"случае, если показатель степени является целым числом.\n"
"Это потому, что выражения типа (^ 4 1/2) не гарантируют возврата 2 (точный "
"квадратный корень из 4); ответ может быть 2.0 (неточное число).\n"
"Другая проблема заключается в том, что - 2 также является квадратным корнем "
"из 4, и в некоторых случаях это правильный вариант."

#: in/chapter8.md:270
msgid ""
"The following trace shows some examples of the simplifier in action.\n"
"First we show that it can be used as a calculator; then we show more "
"advanced problems."
msgstr ""
"На следующей трассировке показаны некоторые примеры работы упрощателя.\n"
"Сначала мы покажем, что его можно использовать как калькулятор; затем мы "
"показываем более сложные задачи."

#: in/chapter8.md:290
msgid ""
"```lisp\n"
">(simplifier)\n"
"SIMPLIFIER  > (2 + 2)\n"
"4\n"
"SIMPLIFIER  > (5 * 20 + 30 + 7)\n"
"137\n"
"SIMPLIFIER  > (5 * x - (4 + 1) * x)\n"
"0\n"
"SIMPLIFIER  > (y / z * (5 * x - (4 + 1) * x))\n"
"0\n"
"SIMPLIFIER  > ((4-3) * x + (y / y - 1) * z)\n"
"X\n"
"SIMPLIFIER  > (1 * f(x) + 0)\n"
"(F X)\n"
"SIMPLIFIER  > (3 * 2 * X)\n"
"(3 * (2 * X))\n"
"SIMPLIFIER  > [Abort]\n"
">\n"
"```"
msgstr ""

#: in/chapter8.md:294
msgid ""
"Here we have terminated the loop by hitting the abort key on the terminal.\n"
"(The details of this mechanism varies from one implementation of Common Lisp "
"to another.) The simplifier seems to work fairly well, although it errs on "
"the last example: `(3 * (2 * X ) )` should simplify to `( 6 * X )`.\n"
"In the next section, we will correct that problem."
msgstr ""
"Здесь мы завершили цикл нажатием клавиши прерывания на терминале.\n"
"(Детали этого механизма варьируются от одной реализации Common Lisp к "
"другой). Simplifier, похоже, работает довольно хорошо, хотя в последнем "
"примере он ошибся: `(3 * (2 * X))`, а должно упроститься до `(6 * X)`.\n"
"В следующем разделе мы исправим эту проблему."

#: in/chapter8.md:296
msgid "## 8.3 Associativity and Commutativity"
msgstr "## 8.3 Ассоциативность и коммутативность"

#: in/chapter8.md:301
msgid ""
"We could easily add a rule to rewrite `(3 * (2 *X))` as `((3 * 2) * X)` "
"andhence `(6 * X)`.\n"
"The problem is that this rule would also rewrite `(X*(2*3))` as `((X* 2) * "
"3)`, unless we had a way to limit the rule to apply only when it would group "
"numbers together.\n"
"Fortunately, `pat-match` does provide just this capability, with the `?is` "
"pattern.\n"
"We could write this rule:"
msgstr ""
"Мы могли бы легко добавить правило, чтобы переписать `(3 * (2 * X))` как "
"`((3 * 2) * X)` и затем `(6 * X)`.\n"
"Проблема в том, что это правило также перепишет `(X * (2 * 3))` как `((X * "
"2) * 3)`, если только у нас не будет способа ограничить применение правила "
"только тогда, когда оно будет группировать числа вместе.\n"
"К счастью, `pat-match` действительно предоставляет именно такую возможность, "
"использованием  образца `?is`.\n"
"Мы могли бы написать это правило:"

#: in/chapter8.md:305
msgid ""
"```lisp\n"
"(((?is n numberp) * ((?is m numberp) * x)) = ((n * m) * x))\n"
"```"
msgstr ""

#: in/chapter8.md:314
msgid ""
"This transforms `(3 * (2 * x))` into `((3 * 2) * x)`, and hence into `(6 * "
"x)`.\n"
"Unfortunately, the problem is not as simple as that.\n"
"We also want to simplify `((2 * x) * (y * 3))` to `(6 *(x * y))`.\n"
"We can do a better job of gathering numbers together by adopting three "
"conventions.\n"
"First, make numbers first in products: change `x * 3` to `3 * x`.\n"
"Second, combine numbers in an outer expression with a number in an inner "
"expression: change `3 *(5 * x)` to `(3 * 5)* x`.\n"
"Third, move numbers out of inner expressions whenever possible: change `(3 * "
"x) *y` to `3 *(x * y)`.\n"
"We adopt similar conventions for addition, except that we prefer numbers "
"last there: `x + 1` instead of `l + x`."
msgstr ""
"Оно преобразует `(3 * (2 * x))` в `((3 * 2) * x)` и следовательно, в `(6 * "
"x)`.\n"
"К сожалению, проблема не так проста.\n"
"Мы также хотим упростить `((2 * x) * (y * 3))` до `(6 * (x * y))`.\n"
"Мы можем сделать улучшить работу по группировке чисел вместе, приняв три "
"соглашения.\n"
"Во-первых, первыми ставить числа в продукциях: измените `x * 3` на `3 * x`.\n"
"Во-вторых, совмещать числа во внешнем выражении с числом во внутреннем "
"выражении: измените `3 *(5 * x)` на `(3 * 5)* x`.\n"
"В-третьих, по возможности уберать числа из внутренних выражений: измените "
"`(3 * x) *y` на `3 * (x * y)`.\n"
"Мы принимаем аналогичные соглашения для сложения, за исключением того, что "
"мы предпочитаем ставить числа последними: `x + 1` вместо `1 + x`."

#: in/chapter8.md:320
msgid ""
"```lisp\n"
";; Define n and m as numbers; s as a non-number:\n"
"(pat-match-abbrev 'n '(?is n numberp))\n"
"(pat-match-abbrev 'm '(?is m numberp))\n"
"(pat-match-abbrev 's '(?is s not-numberp))"
msgstr ""

#: in/chapter8.md:322
msgid "(defun not-numberp (x) (not (numberp x)))"
msgstr ""

#: in/chapter8.md:328
msgid ""
"(defun simp-rule (rule)\n"
"  \"Transform a rule into proper format.\"\n"
"  (let ((exp (infix->prefix rule)))\n"
"    (mkexp (expand-pat-match-abbrev (exp-lhs exp))\n"
"     (exp-op exp) (exp-rhs exp))))"
msgstr ""

#: in/chapter8.md:340
msgid ""
"(setf *simplification-rules*\n"
" (append *simplification-rules* (mapcar #'simp-rule\n"
"  '((s * n = n * s)\n"
"    (n * (m * x) = (n * m) * x)\n"
"    (x * (n * y) = n * (x * y))\n"
"    ((n * x) * y = n * (x * y))\n"
"    (n + s = s + n)\n"
"    ((x + m) + n = x + n + m)\n"
"    (x + (y + n) = (x + y) + n)\n"
"    ((x + n) + y = (x + y) + n)))))\n"
"```"
msgstr ""

#: in/chapter8.md:343
msgid ""
"With the new rules in place, we are ready to try again.\n"
"For some problems we get just the right answers:"
msgstr ""
"С новыми правилами мы готовы попробовать еще раз.\n"
"На некоторые вопросы мы получаем только правильные ответы:"

#: in/chapter8.md:357
msgid ""
"```lisp\n"
"> (simplifier)\n"
"SIMPLIFIER  > (3 * 2 * x)\n"
"(6 * X)\n"
"SIMPLIFIER  > (2 * x * x * 3)\n"
"(6 * (X ^ 2))\n"
"SIMPLIFIER  > (2 * x * 3 * y * 4 * z * 5 * 6)\n"
"(720 * (X * (Y * Z)))\n"
"SIMPLIFIER  > (3 + x + 4 + x)\n"
"((2 * X) + 7)\n"
"SIMPLIFIER  > (2 * x * 3 * x * 4 * (l / x) * 5 * 6)\n"
"(720 * X)\n"
"```"
msgstr ""

#: in/chapter8.md:359
msgid ""
"Unfortunately, there are other problems that aren't simplified properly:"
msgstr ""
"К сожалению, есть и другие проблемы, которые не упрощаются должным образом:"

#: in/chapter8.md:368
msgid ""
"```lisp\n"
"SIMPLIFIER  > (3 + x + 4 - x)\n"
"((X + (4 - X)) + 3)\n"
"SIMPLIFIER  > (x + y + y + x)\n"
"(X + (Y + (Y + X)))\n"
"SIMPLIFIER  > (3 * x + 4 * x)\n"
"((3 * X) + (4 * X))\n"
"```"
msgstr ""

#: in/chapter8.md:370
msgid "We will return to these problems in [section 8.5](#s0030)."
msgstr "Мы вернемся к этим проблемам в [разделе 8.5](#s0030)."

#: in/chapter8.md:373
msgid ""
"**Exercise  8.1** Verify that the set of rules just prior does indeed "
"implement the desired conventions, and that the conventions have the proper "
"effect, and always terminate.\n"
"As an example of a potential problem, what would happen if we used the rule "
"`(x * n = n * x)` instead of the rule `(s * n = n * s)?`"
msgstr ""
"**Exercise  8.1** Убедитесь, что набор правил, только что введенный, "
"действительно реализует желаемые соглашения, и что соглашения имеют "
"надлежащий эффект и всегда заканчиваются.\n"
"В качестве примера потенциальной проблемы, что произойдет, если мы "
"используем правило `(x * n = n * x)` вместо правила `(s * n = n * s)?`"

#: in/chapter8.md:375
msgid "## 8.4 Logs, Trig, and Differentiation"
msgstr "## 8.4 Логарифмы, Тригонометические функции и Дифференцирование."

#: in/chapter8.md:379
msgid ""
"In the previous section, we restricted ourselves to the simple arithmetic "
"functions, so as not to intimidate those who are a little leery of complex "
"mathematics.\n"
"In this section, we add a little to the mathematical complexity, without "
"having to alter the program itself one bit.\n"
"Thus, the mathematically shy can safely skip to the next section without "
"feeling they are missing any of the fun."
msgstr ""
"В предыдущем разделе мы ограничились простыми арифметическими функциями, "
"чтобы не пугать тех, кто немного недоверчив к сложной математике.\n"
"В этом разделе мы немного добавим к математической сложности, не изменяя "
"саму программу ни на йоту.\n"
"Таким образом, математически застенчивые могут спокойно перейти к следующему "
"разделу, не чувствуя, что они упускают что-то интересное."

#: in/chapter8.md:385
msgid ""
"We start off by representing some elementary properties of the logarithmic "
"and trigonometric functions.\n"
"The new rules are similar to the \"zero and one\" rules we needed for the "
"arithmetic operators, except here the constants e and `pi` (*e* = 2.71828... "
"and *&pi;* = 3.14159...) are important in addition to 0 and 1.\n"
"We also throw in some rules relating logs and exponents, and for sums and "
"differences of logs.\n"
"The rules assume that complex numbers are not allowed.\n"
"If they were, log *ex* (and even *xy*) would have multiple values, and it "
"would be wrong to arbitrarily choose one of these values."
msgstr ""
"Мы начнем с представления некоторых элементарных свойств логарифмических и "
"тригонометрических функций.\n"
"Новые правила аналогичны правилам \"нулей и единиц\", которые нам нужны для "
"арифметических операторов, за исключением того, что здесь важны константы "
"`e` и `pi` (*e* = 2.71828... и *&pi;* = 3.14159...), в дополнение к 0 и 1.\n"
"Мы также вводим некоторые правила, относящиеся к логарифмам и экспонентам, а "
"также к суммам и разностям логорифмов.\n"
"Правила предполагают, что комплексные числа не допускаются.\n"
"Если бы это было так, log *ex* (и даже *xy*) имел бы несколько значений, и "
"было бы неправильно произвольно выбирать одно из этих значений."

#: in/chapter8.md:407
msgid ""
"```lisp\n"
"(setf *simplification-rules*\n"
" (append *simplification-rules* (mapcar #'simp-rule '(\n"
"  (log 1         = 0)\n"
"  (log 0         = undefined)\n"
"  (log e         = 1)\n"
"  (sin 0         = 0)\n"
"  (sin pi        = 0)\n"
"  (cos 0         = 1)\n"
"  (cos pi        = -1)\n"
"  (sin(pi / 2)   = 1)\n"
"  (cos(pi / 2)   = 0)\n"
"  (log (e ^ x)   = x)\n"
"  (e ^ (log x)   = x)\n"
"  ((x ^ y) * (x ^ z) = x ^ (y + z))\n"
"  ((x ^ y) / (x ^ z) = x ^ (y - z))\n"
"  (log x + log y = log(x * y))\n"
"  (log x - log y = log(x / y))\n"
"  ((sin x) ^ 2 + (cos x) ^ 2 = 1)\n"
"  ))))\n"
"```"
msgstr ""

#: in/chapter8.md:414
msgid ""
"Now we would like to go a step further and extend the system to handle "
"differentiation.\n"
"This is a favorite problem, and one which has historical significance: in "
"the summer of 1958 John McCarthy decided to investigate differentiation as "
"an interesting symbolic computation problem, which was difficult to express "
"in the primitive programming languages of the day.\n"
"This investigation led him to see the importance of functional arguments and "
"recursive functions in the field of symbolic computation.\n"
"For example, McCarthy invented what we now call `mapcar` to express the idea "
"that the derivative of a sum is the sum of the derivative function applied "
"to each argument.\n"
"Further work led McCarthy to the publication in October 1958 of MIT AI Lab "
"Memo No.\n"
"1: \"An Algebraic Language for the Manipulation of Symbolic Expressions,\" "
"which defined the precursor of Lisp."
msgstr ""
"Теперь мы хотели бы пойти еще дальше и расширить систему, чтобы справиться с "
"дифференцированием.\n"
"Это любимая проблема, и она имеет историческое значение: летом 1958 года "
"Джон Маккарти решил исследовать дифференцирование как интересную проблему "
"символических вычислений, которую было трудно выразить на примитивных языках "
"программирования того времени.\n"
"Это исследование привело его к пониманию важности функциональных аргументов "
"и рекурсивных функций в области символьных вычислений.\n"
"Например, Маккарти изобрел то, что мы теперь называем `mapcar`, чтобы "
"выразить идею о том, что производная суммы является суммой производной "
"функции, примененной к каждому аргументу.\n"
"Дальнейшая работа привела Маккарти к публикации в октябре 1958 года Записки "
"MIT AI Lab No.\n"
"1: \"Алгебраический язык для манипулирования символическими выражениями\", "
"который определил предшественника Lisp."

#: in/chapter8.md:420
msgid ""
"In McCarthy's work and in many subsequent texts you can see symbolic "
"differentiation programs with a simplification routine tacked on the end to "
"make the output more readable.\n"
"Here, we take the opposite approach: the simplification routine is central, "
"and differentiation is handled as just another operator, with its own set of "
"simplification rules.\n"
"We will require a new infix-to-prefix translation rule.\n"
"While we're at it, we'll add a rule for indefinite integration as well, "
"although we won't write simplification rules for integration yet.\n"
"Here are the new notations:"
msgstr ""
"В работе Маккарти и во многих последующих текстах вы можете увидеть "
"программы символического дифференцирования с процедурой упрощения, "
"выполняемой в конце, чтобы сделать вывод более читаемым.\n"
"Здесь мы используем противоположный подход: процедура упрощения является "
"центральной, а дифференцирование рассматривается как просто еще один "
"оператор со своим собственным набором правил упрощения.\n"
"Нам потребуется новое правило преобразования infix-to-prefix(инфикса в "
"префикс).\n"
"В то же время мы добавим правило для неопределенного интегрирования, хотя мы "
"еще не будем писать правил упрощения для интегрирования.\n"
"Вот новые обозначения:"

#: in/chapter8.md:426
msgid ""
"| []()        |             |             |\n"
"|-------------|-------------|-------------|\n"
"| math        | infix       | prefix      |\n"
"| *dy*/*dx*   | `d y / d x` | `(d y x)`   |\n"
"| *&int; ydx* | `Int y d x` | `(int y x)` |"
msgstr ""

#: in/chapter8.md:428
msgid "And here are the necessary infix-to-prefix rules:"
msgstr ""
"А вот и необходимые правила перехода infix-to-prefix(от инфикса к префиксу):"

#: in/chapter8.md:443
msgid ""
"```lisp\n"
"(defparameter *infix->prefix-rules*\n"
"      (mapcar #'expand-pat-match-abbrev\n"
"          '(((x+ = y+) (= x y))\n"
"          ((- x+) (- x))\n"
"          ((+ x+) (+ x))\n"
"          ((x+ + y+) (+ x y))\n"
"          ((x+ - y+) (- x y))\n"
"          ((d y+ / d x) (d y x))        ;*** New rule\n"
"          ((Int y+ d x) (int y x))    ;*** New rule\n"
"          ((x+ * y+) (* x y))\n"
"          ((x+ / y+) (/ x y))\n"
"          ((x+ ^ y+) (^ x y)))))\n"
"```"
msgstr ""

#: in/chapter8.md:447
msgid ""
"Since the new rule for differentiation occurs before the rule for division, "
"there won't be any confusion with a differential being interpreted as a "
"quotient.\n"
"On the other hand, there is a potential problem with integrals that contain "
"`d` as a variable.\n"
"The user can always avoid the problem by using (`d`) instead of `d` inside "
"an integral."
msgstr ""
"Поскольку новое правило для дифференцирования стоит раньше правила для "
"деления, не будет никакой путаницы с дифференциалом, интерпретируемым как "
"частное.\n"
"С другой стороны, существует потенциальная проблема с интегралами, которые "
"содержат `d` в качестве переменной.\n"
"Пользователь всегда может избежать этой проблемы, используя (`d`) вместо `d` "
"внутри интеграла."

#: in/chapter8.md:449
msgid ""
"Now we augment the simplification rules, by copying a differentiation table "
"out of a reference book:"
msgstr ""
"Теперь мы дополняем правила упрощения, копируя таблицу дифференцирования из "
"справочника:"

#: in/chapter8.md:469
msgid ""
"```lisp\n"
"(setf *simplification-rules*\n"
" (append *simplification-rules* (mapcar #'simp-rule '(\n"
"  (d x / d x       = 1)\n"
"  (d (u + v) / d x = (d u / d x) + (d v / d x))\n"
"  (d (u - v) / d x = (d u / d x) - (d v / d x))\n"
"  (d (- u) / d x   = - (d u / d x))\n"
"  (d (u * v) / d x = u * (d v / d x) + v * (d u / d x))\n"
"  (d (u / v) / d x = (v * (d u / d x) - u * (d v / d x))\n"
"                     / v ^ 2) ; [This corrects an error in the first "
"printing]\n"
"  (d (u ^ n) / d x = n * u ^ (n - 1) * (d u / d x))\n"
"  (d (u ^ v) / d x = v * u ^ (v - 1) * (d u / d x)\n"
"                   + u ^ v * (log u) * (d v / d x))\n"
"  (d (log u) / d x = (d u / d x) / u)\n"
"  (d (sin u) / d x = (cos u) * (d u / d x))\n"
"  (d (cos u) / d x = - (sin u) * (d u / d x))\n"
"  (d (e ^ u) / d x = (e ^ u) * (d u / d x))\n"
"  (d u / d x       = 0)))))\n"
"```"
msgstr ""

#: in/chapter8.md:474
msgid ""
"We have added a default rule, `(d u / d x = 0)`; this should only apply when "
"the expression `u` is free of the variable `x` (that is, when u is not a "
"function of `x`).\n"
"We could use `?if` to check this, but instead we rely on the fact that "
"differentiation is closed over the list of operators described here-as long "
"as we don't introduce any new operators, the answer will always be correct.\n"
"Note that there are two rules for exponentiation, one for the case when the "
"exponent is a number, and one when it is not.\n"
"This was not strictly necessary, as the second rule covers both cases, but "
"that was the way the rules were written in the table of differentials I "
"consulted, so I left both rules in."
msgstr ""
"Мы добавили правило по умолчанию `(d u / d x = 0)`; оно должно применяться "
"только тогда, когда выражение `u` свободно от переменной `x` (то есть когда "
"u не является функцией `x`).\n"
"Мы могли бы использовать `?if`, чтобы проверить это, но вместо этого мы "
"полагаемся на то, что дифференцирование ограничено списком операторов, "
"описанных здесь - так что, до тех пор, пока мы не введем никаких новых "
"операторов, ответ всегда будет правильным.\n"
"Обратите внимание, что есть два правила для возведения в степень, одно для "
"случая, когда показатель степени является числом, и одно, когда это не так.\n"
"В этом не было строгой необходимости, поскольку второе правило охватывает "
"оба случая, но именно так правила были записаны в таблице дифференциалов, с "
"которой я консультировался, поэтому я оставил оба правила."

#: in/chapter8.md:501
msgid ""
"```lisp\n"
"SIMPLIFIER  > (d (x + x) / d x)\n"
"2\n"
"SIMPLIFIER  > (d (a * x ^ 2 + b * x + c) / d x)\n"
"((2 * (A * X)) + B)\n"
"SIMPLIFIER  > (d ((a * x ^ 2 + b * x + c) / x) / d x)\n"
"((((A * (X ^ 2)) + ((B * X) + C)) - (X * ((2 * (A * X)) + B)))\n"
"/ (X ^ 2))\n"
"SIMPLIFIER  > (log ((d (x + x) / d x) / 2))\n"
"0\n"
"SIMPLIFIER  > (log(x + x) - log x)\n"
"(LOG 2)\n"
"SIMPLIFIER  > (x ^ cos pi)\n"
"(1 / X)\n"
"SIMPLIFIER  > (d (3 * x + (cos x) / x) / d x)\n"
"((((COS X) - (X * (- (SIN X)))) / (X ^ 2)) + 3)\n"
"SIMPLIFIER  > (d ((cos x) / x) / d x)\n"
"(((COS X) - (X * (- (SIN X)))) / (X ^ 2))\n"
"SIMPLIFIER  > (d (3 * x ^ 2 + 2 * x + 1) / d x)\n"
"((6 * X) + 2)\n"
"SIMPLIFIER  > (sin(x + x) ^ 2 + cos(d x ^ 2 / d x) ^ 2)\n"
"1\n"
"SIMPLIFIER  > (sin(x + x) * sin(d x ^ 2 / d x) +\n"
"      cos(2 * x) * cos(x * d 2 * y / d y))\n"
"1\n"
"```"
msgstr ""

#: in/chapter8.md:503
msgid ""
"The program handles differentiation problems well and is seemingly clever in "
"its use of the identity sin2*x* + cos2*x* = 1."
msgstr ""
"Программа хорошо справляется с проблемами дифференцирования и, по-видимому, "
"умна в использовании тождества sin^2*x* + cos^2*x* = 1."

#: in/chapter8.md:505
msgid "## 8.5 Limits of Rule-Based Approaches"
msgstr "## 8.5 Пределы применения подходов основанных на правилах"

#: in/chapter8.md:508
msgid ""
"In this section we return to some examples that pose problems for the "
"simplifier.\n"
"Here is a simple one:"
msgstr ""
"В этом разделе мы вернемся к некоторым примерам, которые создают проблемы "
"для упрощателя.\n"
"Вот простой пример"

#: in/chapter8.md:510
msgid "`SIMPLIFIER  > (x + y + y + x)`=> `(X + (Y + (Y + X)))`"
msgstr ""

#: in/chapter8.md:514
msgid ""
"We would prefer `2 * (x + y)`.\n"
"The problem is that, although we went to great trouble to group numbers "
"together, there was no effort to group non-numbers.\n"
"We could write rules of the form:"
msgstr ""
"Мы бы предпочли `2 * (x + y)`.\n"
"Проблема в том, что, хотя мы приложили много усилий, чтобы сгруппировать "
"числа вместе, не было никаких усилий, чтобы сгруппировать не-числа.\n"
"Мы могли бы написать правила вида:"

#: in/chapter8.md:519
msgid ""
"```lisp\n"
"(y + (y + x) = (2 * y) + x)\n"
"(y + (x + y) = (2 * y) + x)\n"
"```"
msgstr ""

#: in/chapter8.md:522
msgid ""
"These would work for the example at hand, but they would not work for `(x + "
"y + z + y + x)`.\n"
"For that we would need more rules:"
msgstr ""
"Они будут работать для рассматриваемого примера, но они не будут работать "
"для `(x + y + z + y + x)'.\n"
"Для этого нам понадобится больше правил:"

#: in/chapter8.md:529
msgid ""
"```lisp\n"
"(y + (z + (y + x)) = (2 * y) + x + z)\n"
"(y + (z + (x + y)) = (2 * y) + x + z)\n"
"(y + ((y + x) + z) = (2 * y) + x + z)\n"
"(y + ((x + y) + z) = (2 * y) + x + z)\n"
"```"
msgstr ""

#: in/chapter8.md:537
msgid ""
"To handle all the cases, we would need an infinite number of rules.\n"
"The pattern-matching language is not powerful enough to express this "
"succintly.\n"
"It might help if nested sums (and products) were unnested; that is, if we "
"allowed + to take an arbitrary number of arguments instead of just one.\n"
"Once the arguments are grouped together, we could sort them, so that, say, "
"all the `ys` appear before `z` and after `x`.\n"
"Then like terms could be grouped together.\n"
"We have to be careful, though.\n"
"Consider these examples:"
msgstr ""
"Чтобы справиться со всеми случаями, нам понадобится бесконечное число "
"правил.\n"
"Язык сопоставления с образцом недостаточно силен, чтобы выразить это "
"кратко.\n"
"Могло бы помочь, если бы вложенные суммы (и произведения) были невложенными; "
"то есть, если бы мы позволили + принять произвольное число аргументов вместо "
"только одного.\n"
"Как только аргументы сгруппированы вместе, мы можем отсортировать их так, "
"чтобы, скажем, все `ys` появлялись перед `z` и после `x`.\n"
"Тогда подобные термины можно было бы сгруппировать вместе.\n"
"Но мы должны быть осторожны.\n"
"Рассмотрим следующие примеры:"

#: in/chapter8.md:544
msgid ""
"```lisp\n"
"SIMPLIFIER  > (3 * x + 4 * x)\n"
"((3 * X) + (4 * X))\n"
"SIMPLIFIER  > (3 * x + y + x + 4 * x)\n"
"((3 * X) + (Y + (X + (4 * X))))\n"
"```"
msgstr ""

#: in/chapter8.md:547
msgid ""
"We would want `(3 * x)` to sort to the same place as `x` and `(4 * x )` so "
"that they could all be combined to `(8 * x)`.\n"
"In [chapter 15](B9780080571157500157.xhtml), we develop a new version of the "
"program that handles this problem."
msgstr ""
"Мы бы хотели, чтобы `(3 * x)` сортировался в то же место, что и `x` и `(4 * "
"x)`, чтобы все они могли быть объединены в `(8 * x)`.\n"
"В [главе 15](B9780080571157500157.xhtml) мы разрабатываем новую версию "
"программы, которая решает эту проблему."

#: in/chapter8.md:549
msgid "## 8.6 Integration"
msgstr "## 8.6 Интегрирование"

#: in/chapter8.md:555
msgid ""
"So far, the algebraic manipulations have been straightforward.\n"
"There is a direct algorithm for computing the derivative of every "
"expression.\n"
"When we consider integrals, or antiderivatives,[2](#fn0015) the picture is "
"much more complicated.\n"
"As you may recall from freshman calculus, there is a fine art to computing "
"integrals.\n"
"In this section, we try to see how far we can get by encoding just a few of "
"the many tricks available to the calculus student."
msgstr ""
"До сих пор алгебраические манипуляции были простыми.\n"
"Существует прямой алгоритм вычисления производной каждого выражения.\n"
"Когда мы рассматриваем интегралы или первообразные [2](# fn0015), картина "
"намного сложнее.\n"
"Как вы, возможно, помните из исчисления для первокурсников, вычисление "
"интегралов - это настоящее искусство.\n"
"В этом разделе мы пытаемся увидеть, как далеко мы можем зайти, кодируя лишь "
"некоторые из множества приемов, доступных изучающему математику."

#: in/chapter8.md:562
msgid ""
"The first step is to recognize that entries in the simplification table will "
"not be enough.\n"
"Instead, we will need an algorithm to evaluate or \"simplify\" integrals.\n"
"We will add a new case to `simplify-exp` to check each operator to see if it "
"has a simplification function associated with it.\n"
"These simplification functions will be associated with operators through the "
"functions `set-simp-fn` and `simp-fn`.\n"
"If an operator does have a simplification function, then that function will "
"be called instead of consulting the simplification rules.\n"
"The simplification function can elect not to handle the expression after all "
"by returning nil, in which case we continue with the other simplification "
"methods."
msgstr ""
"Первый шаг - признать, что записей в таблице упрощения будет недостаточно.\n"
"Вместо этого нам понадобится алгоритм для вычисления или \"упрощения\" "
"интегралов.\n"
"Мы добавим новый случай в `simpleify-exp`, чтобы проверить каждый оператор, "
"чтобы увидеть, связана ли с ним функция упрощения.\n"
"Эти функции упрощения будут связаны с операторами через функции `set-simp-"
"fn` и `simp-fn`.\n"
"Если у оператора есть функция упрощения, то эта функция будет вызываться "
"вместо обращения к правилам упрощения.\n"
"Функция упрощения может решить не обрабатывать выражение в конце концов, "
"возвращая nil, и в этом случае мы продолжим использовать другие методы "
"упрощения."

#: in/chapter8.md:566
msgid ""
"```lisp\n"
"(defun simp-fn (op) (get op 'simp-fn))\n"
"(defun set-simp-fn (op fn) (setf (get op 'simp-fn) fn))"
msgstr ""

#: in/chapter8.md:577
msgid ""
"(defun simplify-exp (exp)\n"
"  \"Simplify using a rule, or by doing arithmetic,\n"
"  or by using the simp function supplied for this operator.\"\n"
"  (cond ((simplify-by-fn exp))                             ;***\n"
"        ((rule-based-translator exp *simplification-rules*\n"
"           :rule-if #'exp-lhs :rule-then #'exp-rhs\n"
"           :action #'(lambda (bindings response)\n"
"                       (simplify (sublis bindings response)))))\n"
"        ((evaluable exp) (eval exp))\n"
"        (t exp)))"
msgstr ""

#: in/chapter8.md:588
msgid ""
"(defun simplify-by-fn (exp)\n"
"  \"If there is a simplification fn for this exp,\n"
"  and if applying it gives a non-null result,\n"
"  then simplify the result and return that.\"\n"
"  (let* ((fn (simp-fn (exp-op exp)))\n"
"         (result (if fn (funcall fn exp))))\n"
"    (if (null result)\n"
"        nil\n"
"        (simplify result))))\n"
"```"
msgstr ""

#: in/chapter8.md:592
msgid ""
"Freshman calculus classes teach a variety of integration techniques.\n"
"Fortunately, one technique-the derivative-divides technique-can be adopted "
"to solve most of the problems that come up at the freshman calculus level, "
"perhaps 90% of the problems given on tests.\n"
"The basic rule is:"
msgstr ""
"На уроках математического анализа первокурсникам преподаются различные "
"методы интегрирования.\n"
"К счастью, одина техника - метод разделения переменных - может быть "
"использован для решения большинства проблем, которые возникают на уровне "
"математики первокурсников, возможно, 90% задач, заданных при проверке.\n"
"Основное правило:"

#: in/chapter8.md:594
msgid "&int;fxdx=&int;fududxdx."
msgstr ""

#: in/chapter8.md:596
msgid "![si1_e](images/chapter8/si1_e.gif)"
msgstr ""

#: in/chapter8.md:600
msgid ""
"As an example, consider *&int; x* sin(*x*2) *dx*.\n"
"Using the substitution *u* = *x*2, we can differentiate to get *du*/*dx* = "
"2*x*.\n"
"Then by applying the basic rule, we get:"
msgstr ""
"В качестве примера рассмотрим *&int; x* sin(*x*2) *dx*.\n"
"Используя подстановку *u* = *x*2, мы можем дифференцировать, чтобы получить "
"*du*/*dx* = 2*x*.\n"
"Затем, применяя основное правило, мы получаем:"

#: in/chapter8.md:602
msgid "&int;xsinx2dx=12&int;sinududxdx=12&int;sinudu."
msgstr ""

#: in/chapter8.md:604
msgid "![si2_e](images/chapter8/si2_e.gif)"
msgstr ""

#: in/chapter8.md:607
msgid ""
"Assume we have a table of integrals that includes the rule *&int;* sin(*x*) "
"*dx* = - cos(*x*).\n"
"Then we can get the final answer:"
msgstr ""
"Предположим, что у нас есть таблица интегралов, включающая правило *&int;* "
"sin(*x*) *dx* = - cos(*x*).\n"
"Тогда мы сможем получить окончательный ответ:"

#: in/chapter8.md:609
msgid "-12cosx2."
msgstr ""

#: in/chapter8.md:611
msgid "![si3_e](images/chapter8/si3_e.gif)"
msgstr ""

#: in/chapter8.md:613
msgid ""
"Abstracting from this example, the general algorithm for integrating an "
"expression *y* with respect to *x* is:"
msgstr ""
"Если абстрагироваться от этого примера, общий алгоритм интегрирования "
"выражения *y* относительно *x* следующий:"

#: in/chapter8.md:616
msgid ""
"1.  Pick a factor of *y*, callingit *f*(*u*).\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Выберите коэффициент *y*, называя его *f*(*u*).\n"
"!!!(p) {:.numlist}"

#: in/chapter8.md:619
msgid ""
"2.  Compute the derivative *du*/*dx*.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Вычислить производную *du*/*dx*.\n"
"!!!(p) {:.numlist}"

#: in/chapter8.md:622
msgid ""
"3.  Divide *y* by *f*(*u*) x *du*/*dx*, calling the quotient *k*.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Разделите *y* на *f*(*u*) x *du*/*dx*, получив коэффициэнт *k*.\n"
"!!!(p) {:.numlist}"

#: in/chapter8.md:625
msgid ""
"4.  If *k* is a constant (with respect to *x*), then the result is *k &int; "
"f*(*u*)*du*.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Если *k* является константой (по отношению к *x*), то результат будет *k "
"&int; f*(*u*)*du*.\n"
"!!!(p) {:.numlist}"

#: in/chapter8.md:629
msgid ""
"This algorithm is nondeterministic, as there may be many factors of *y*.\n"
"In our example, *f*(*u*) = sin(*x*2), *u* = *x*2, and *du*/*dx* = 2*x*.\n"
"So k=12 !!!(span) {:.hiddenClass} ![si4_e](images/chapter8/si4_e.gif), and "
"the answer is -12cosx2 !!!(span) {:.hiddenClass} ![si5_e](images/chapter8/"
"si5_e.gif)."
msgstr ""
"Этот алгоритм недетерминирован, так как может быть много факторов *y*.\n"
"В нашем примере *f*(*u*) = sin(*x*2), *u* = *x*2, and *du*/*dx* = 2*x*.\n"
"Итак, k=12 !!!(span) {:.hiddenClass} ![si4_e](images/chapter8/si4_e.gif), и "
"ответ будет -12cosx2 !!!(span) {:.hiddenClass} ![si5_e](images/chapter8/"
"si5_e.gif)."

#: in/chapter8.md:634
msgid ""
"The first step in implementing this technique is to make sure that division "
"is done correctly.\n"
"We need to be able to pick out the factors of *y*, divide expressions, and "
"then determine if a quotient is free of *x*.\n"
"The function `factorize` does this.\n"
"It keeps a list of factors and a running product of constant factors, and "
"augments them with each call to the local function `fac`."
msgstr ""
"Первый шаг в реализации этой техники - убедиться, что разделение выполнено "
"правильно.\n"
"Нам нужно иметь возможность выбирать множители *y*, разделять выражения, а "
"затем определять, свободны ли частные(коэффициэнты) от *x*.\n"
"Это делает функция `factorize`.\n"
"Она хранит список факторов и текущее произведение постоянных факторов и "
"дополняет их с каждым вызовом локальной функции `fac`."

#: in/chapter8.md:669
msgid ""
"```lisp\n"
"(defun factorize (exp)\n"
"  \"Return a list of the factors of exp^n,\n"
"  where each factor is of the form (^ y n).\"\n"
"  (let ((factors nil)\n"
"        (constant 1))\n"
"    (labels\n"
"      ((fac (x n)\n"
"         (cond\n"
"           ((numberp x)\n"
"            (setf constant (* constant (expt x n))))\n"
"           ((starts-with x '*)\n"
"            (fac (exp-lhs x) n)\n"
"            (fac (exp-rhs x) n))\n"
"           ((starts-with x '/)\n"
"            (fac (exp-lhs x) n)\n"
"            (fac (exp-rhs x) (- n)))\n"
"           ((and (starts-with x '-) (length=1 (exp-args x)))\n"
"            (setf constant (- constant))\n"
"            (fac (exp-lhs x) n))\n"
"           ((and (starts-with x '^) (numberp (exp-rhs x)))\n"
"            (fac (exp-lhs x) (* n (exp-rhs x))))\n"
"           (t (let ((factor (find x factors :key #'exp-lhs\n"
"                                  :test #'equal)))\n"
"                (if factor\n"
"                    (incf (exp-rhs factor) n)\n"
"                    (push `(^ ,x ,n) factors)))))))\n"
"      ;; Body of factorize:\n"
"      (fac exp 1)\n"
"      (case constant\n"
"        (0 '((^ 0 1)))\n"
"        (1 factors)\n"
"        (t `((^ ,constant 1) .,factors))))))\n"
"```"
msgstr ""

#: in/chapter8.md:671
msgid ""
"`factorize` maps from an expression to a list of factors, but we also need "
"`unfactorize` to turn a list back into an expression:"
msgstr ""
"`factorize`  отображает выражение в список факторов, но нам также нужно "
"`unfactorize`, чтобы превратить список обратно в выражение:"

#: in/chapter8.md:679
msgid ""
"```lisp\n"
"(defun unfactorize (factors)\n"
"  \"Convert a list of factors back into prefix form.\"\n"
"  (cond ((null factors) 1)\n"
"        ((length=1 factors) (first factors))\n"
"        (t `(* ,(first factors) ,(unfactorize (rest factors))))))\n"
"```"
msgstr ""

#: in/chapter8.md:684
msgid ""
"The derivative-divides method requires a way of dividing two expressions.\n"
"We do this by factoring each expression and then dividing by cancelling "
"factors.\n"
"There may be cases where, for example, two factors in the numerator could be "
"multiplied together to cancel a factor in the denominator, but this "
"possibility is not considered.\n"
"It turns out that most problems from freshman calculus do not require such "
"sophistication."
msgstr ""
"Метод разделения на производные(метод разделения переменных) требует "
"разделения двух выражений.\n"
"Мы делаем это путем факторизации каждого выражения, а затем отмены деления "
"на коэффициенты(факторы).\n"
"Могут быть случаи, когда, например, два множителя в числителе можно "
"перемножить, чтобы отменить множитель в знаменателе, но такая возможность не "
"рассматривается.\n"
"Оказывается, что большинство задач по математике первокурсников не требуют "
"такой сложности."

#: in/chapter8.md:697
msgid ""
"```lisp\n"
"(defun divide-factors (numer denom)\n"
"  \"Divide a list of factors by another, producing a third.\"\n"
"  (let ((result (mapcar #'copy-list numer)))\n"
"    (dolist (d denom)\n"
"      (let ((factor (find (exp-lhs d) result :key #'exp-lhs\n"
"                          :test #'equal)))\n"
"        (if factor\n"
"            (decf (exp-rhs factor) (exp-rhs d))\n"
"            (push `(^ ,(exp-lhs d) ,(- (exp-rhs d))) result))))\n"
"    (delete 0 result :key #'exp-rhs)))\n"
"```"
msgstr ""

#: in/chapter8.md:699
msgid ""
"Finally, the predicate `free-of` returns true if an expression does not have "
"any occurrences of a particular variable in it."
msgstr ""
"Наконец, предикат `free-of` возвращает истину, если в выражении нет "
"вхождений определенной переменной."

#: in/chapter8.md:704
msgid ""
"```lisp\n"
"(defun free-of (exp var)\n"
"  \"True if expression has no occurrence of var.\"\n"
"  (not (find-anywhere var exp)))"
msgstr ""

#: in/chapter8.md:712
msgid ""
"(defun find-anywhere (item tree)\n"
"  \"Does item occur anywhere in tree?  If so, return it.\"\n"
"  (cond ((eql item tree) tree)\n"
"        ((atom tree) nil)\n"
"        ((find-anywhere item (first tree)))\n"
"        ((find-anywhere item (rest tree)))))\n"
"```"
msgstr ""

#: in/chapter8.md:714
msgid ""
"In `factorize` we made use of the auxiliary function `length=1.` The "
"function call `(length=l x)` is faster than `(= (length x) 1)` because the "
"latter has to compute the length of the whole list, while the former merely "
"has to see if the list has a `rest` element or not."
msgstr ""
"В `factorize` мы использовали вспомогательную функцию `length=1`. Вызов "
"функции `(length=l x)` быстрее, чем `(= (length x) 1)`, потому что последняя "
"должна вычислять длину всего списока, в то время как первая просто должна "
"смотреть, есть ли в списке элемент `rest` или нет."

#: in/chapter8.md:720
msgid ""
"```lisp\n"
"(defun length=l (x)\n"
"  \"Is X a list of length 1?\"\n"
"  (and (consp x) (null (rest x))))\n"
"```"
msgstr ""

#: in/chapter8.md:726
msgid ""
"Given these preliminaries, the function `integrate` is fairly easy.\n"
"We start with some simple cases for integrating sums and constant "
"expressions.\n"
"Then, we factor the expression and split the list of factors into two: a "
"list of constant factors, and a list of factors containing *x*.\n"
"(This is done with `partition-if`, a combination of `remove-if` and `remove-"
"if-not`.) Finally, we call `deriv-divides`, giving it a chance with each of "
"the factors.\n"
"If none of them work, we return an expression indicating that the integral "
"is unknown."
msgstr ""
"Учитывая эти предварительные сведения, функция `integrate` довольно проста.\n"
"Начнем с нескольких простых случаев интегрирования сумм и постоянных "
"выражений.\n"
"Затем мы факторизируем выражение и разбиваем список факторов на два: список "
"постоянных факторов и список факторов, содержащий *x*.\n"
"(Это делается с помощью `partition-if`, комбинации `remove-if` и `remove-if-"
"not`.) Наконец, мы вызываем `deriv-divides`, давая ему шанс с каждым из "
"факторов.\n"
"Если ни один из них не сработает, мы возвращаем выражение, указывающее, что "
"интеграл неизвестен."

#: in/chapter8.md:754
msgid ""
"```lisp\n"
"(defun integrate (exp x)\n"
"  ;; First try some trivial cases\n"
"  (cond\n"
"    ((free-of exp x) `(* ,exp x))          ; Int c dx = c*x\n"
"    ((starts-with exp '+)                  ; Int f + g  =\n"
"     `(+ ,(integrate (exp-lhs exp) x)      ;   Int f + Int g\n"
"         ,(integrate (exp-rhs exp) x)))\n"
"    ((starts-with exp '-)\n"
"     (ecase (length (exp-args exp))\n"
"       (1 (integrate (exp-lhs exp) x))     ; Int - f = - Int f\n"
"       (2 `(- ,(integrate (exp-lhs exp) x) ; Int f - g  =\n"
"              ,(integrate (exp-rhs exp) x)))))  ; Int f - Int g\n"
"    ;; Now move the constant factors to the left of the integral\n"
"    ((multiple-value-bind (const-factors x-factors)\n"
"         (partition-if #'(lambda (factor) (free-of factor x))\n"
"                       (factorize exp))\n"
"       (identity ;simplify\n"
"         `(* ,(unfactorize const-factors)\n"
"             ;; And try to integrate:\n"
"             ,(cond ((null x-factors) x)\n"
"                    ((some #'(lambda (factor)\n"
"                               (deriv-divides factor x-factors x))\n"
"                           x-factors))\n"
"                    ;; <other methods here>\n"
"                    (t `(int? ,(unfactorize x-factors) ,x)))))))))\n"
"```"
msgstr ""

#: in/chapter8.md:767
msgid ""
"```lisp\n"
"(defun partition-if (pred list)\n"
"  \"Return 2 values: elements of list that satisfy pred,\n"
"  and elements that don't.\"\n"
"  (let ((yes-list nil)\n"
"        (no-list nil))\n"
"    (dolist (item list)\n"
"      (if (funcall pred item)\n"
"          (push item yes-list)\n"
"          (push item no-list)))\n"
"    (values (nreverse yes-list) (nreverse no-list))))\n"
"```"
msgstr ""

#: in/chapter8.md:771
msgid ""
"Note that the place in integrate where other techniques could be added is "
"marked.\n"
"We will only implement the derivative-divides method.\n"
"It turns out that the function is a little more complicated than the simple "
"four-step algorithm outlined before:"
msgstr ""
"Обратите внимание, в integrate отмечено место, где можно было бы добавить "
"другие методы.\n"
"Мы будем реализовывать только метод разделения переменных(derivative-"
"divides).\n"
"Оказывается, эта функция немного сложнее, чем простой четырехэтапный "
"алгоритм, описанный ранее:"

#: in/chapter8.md:796
msgid ""
"```lisp\n"
"(defun deriv-divides (factor factors x)\n"
"  (assert (starts-with factor '^))\n"
"  (let* ((u (exp-lhs factor))              ; factor = u^n\n"
"         (n (exp-rhs factor))\n"
"         (k (divide-factors\n"
"              factors (factorize `(* ,factor ,(deriv u x))))))\n"
"    (cond ((free-of k x)\n"
"           ;; Int k*u^n*du/dx dx = k*Int u^n du\n"
"           ;;                    = k*u^(n+1)/(n+1) for n/=1\n"
"           ;;                    = k*log(u) for n=1\n"
"           (if (= n -1)\n"
"               `(* ,(unfactorize k) (log ,u))\n"
"               `(/ (* ,(unfactorize k) (^ ,u ,(+ n 1)))\n"
"                   ,(+ n 1))))\n"
"          ((and (= n 1) (in-integral-table? u))\n"
"           ;; Int y'*f(y) dx = Int f(y) dy\n"
"           (let ((k2 (divide-factors\n"
"                       factors\n"
"                       (factorize `(* ,u ,(deriv (exp-lhs u) x))))))\n"
"             (if (free-of k2 x)\n"
"                 `(* ,(integrate-from-table (exp-op u) (exp-lhs u))\n"
"                     ,(unfactorize k2))))))))\n"
"```"
msgstr ""

#: in/chapter8.md:805
msgid ""
"There are three cases.\n"
"In any case, all factors are of the form `(^ u n)`, so we separate the "
"factor into a base, `u`, and exponent, `n`.\n"
"If *u* or *un* evenly divides the original expression (here represented as "
"factors), then we have an answer.\n"
"But we need to check the exponent, because *&int; undu* is *u**n*+1/(*n* + "
"1) for *n*&ne; -  1, but it is log (*u*) for *n* = -  1.\n"
"But there is a third case to consider.\n"
"The factor may be something like `(^ (sin (^ x 2)) 1)`, in which case we "
"should consider *f*(*u*) = sin(*x*2).\n"
"This case is handled with the help of an integral table.\n"
"We don't need a derivative table, because we can just use the simplifier for "
"that."
msgstr ""
"Есть три случая.\n"
"В любом случае, все множители имеют вид `(^ u n)`, поэтому мы разделяем "
"множитель на основание `u` и показатель степени `n`.\n"
"Если *u* или *un* равномерно делит исходное выражение (здесь представлено "
"как множители), то у нас есть ответ.\n"
"Но нам нужно проверить экспоненту, потому что *&int; undu* равен *u**n*+1/"
"(*n* + 1) для *n*&ne; - 1, но это log(*u*) для *n* = - 1.\n"
"Но следует рассмотреть третий случай.\n"
"Фактор может быть чем-то вроде `(^ (sin (^ x 2)) 1)`, и в этом случае мы "
"должны учитывать *f*(*u*) = sin(*x*2).\n"
"Этот случай обрабатывается с помощью таблицы интегрирования.\n"
"Нам не нужна таблица производных, потому что мы можем просто использовать "
"для этого simplifier."

#: in/chapter8.md:808
msgid ""
"```lisp\n"
"(defun deriv (y x) (simplify `(d ,y ,x)))"
msgstr ""

#: in/chapter8.md:815
msgid ""
"(defun integration-table (rules)\n"
"  (dolist (i-rule rules)\n"
"    ;; changed infix->prefix to simp-rule - norvig Jun 11 1996\n"
"    (let ((rule (simp-rule i-rule)))\n"
"      (setf (get (exp-op (exp-lhs (exp-lhs rule))) 'int)\n"
"            rule))))"
msgstr ""

#: in/chapter8.md:819
msgid ""
"(defun in-integral-table? (exp)\n"
"  (and (exp-p exp) (get (exp-op exp) 'int)))"
msgstr ""

#: in/chapter8.md:823
msgid ""
"(defun integrate-from-table (op arg)\n"
"  (let ((rule (get op 'int)))\n"
"    (subst arg (exp-lhs (exp-lhs (exp-lhs rule))) (exp-rhs rule))))"
msgstr ""

#: in/chapter8.md:835
msgid ""
"(integration-table\n"
"  '((Int log(x) d x = x * log(x) - x)\n"
"    (Int exp(x) d x = exp(x))\n"
"    (Int sin(x) d x = - cos(x))\n"
"    (Int cos(x) d x = sin(x))\n"
"    (Int tan(x) d x = - log(cos(x)))\n"
"    (Int sinh(x) d x = cosh(x))\n"
"    (Int cosh(x) d x = sinh(x))\n"
"    (Int tanh(x) d x = log(cosh(x)))\n"
"    ))\n"
"```"
msgstr ""

#: in/chapter8.md:838
msgid ""
"The last step is to install integrate as the simplification function for the "
"operator Int.\n"
"The obvious way to do this is:"
msgstr ""
"Последний шаг - установить integrate как функцию упрощения для оператора "
"Int.\n"
"Очевидный способ сделать это:"

#: in/chapter8.md:842
msgid ""
"```lisp\n"
"(set-simp-fn 'Int 'integrate)\n"
"```"
msgstr ""

#: in/chapter8.md:847
msgid ""
"Unfortunately, that does not quite work.\n"
"The problem is that integrate expects two arguments, corresponding to the "
"two arguments *`y`* and *`x`* in `( Int *y x*)`.\n"
"But the convention for simplification functions is to pass them a single "
"argument, consisting of the whole expression `( Int *y x*)`.\n"
"We could go back and edit `simplify-exp` to change the convention, but "
"instead I choose to make the conversion this way:"
msgstr ""
"К сожалению, это не совсем так.\n"
"Проблема в том, что integrate ожидает два аргумента, соответствующих двум "
"аргументам *`y`* и *`x`* в (Int *y x*)`.\n"
"Но соглашение для функций упрощения заключается в передаче им одного "
"аргумента, состоящего из всего выражения `(Int *y x*)`.\n"
"Мы могли бы вернуться и отредактировать `simpleify-exp`, чтобы изменить "
"соглашение, но вместо этого я предпочёл сделать преобразование следующим "
"образом:"

#: in/chapter8.md:852
msgid ""
"```lisp\n"
"(set-simp-fn 'Int #'(lambda (exp)\n"
"          (integrate (exp-lhs exp) (exp-rhs exp))))\n"
"```"
msgstr ""

#: in/chapter8.md:854
msgid ""
"Here are some examples, taken from [chapters 8](#c0040) and [9]"
"(B9780080571157500091.xhtml) of *Calculus* ([Loomis 1974]"
"(B9780080571157500285.xhtml#bb0750)):"
msgstr ""
"Вот несколько примеров, взятых из [глав 8](#c0040) и [9]"
"(B9780080571157500091.xhtml) из *Calculus* ([Loomis 1974]"
"(B9780080571157500285.xhtml#bb0750)):"

#: in/chapter8.md:871
msgid ""
"```lisp\n"
"SIMPLIFIER  > (Int x * sin(x ^ 2) d x)\n"
"(1/2 * (- (COS (X ^ 2))))\n"
"SIMPLIFIER  > (Int ((3 * x ^ 3) - 1 / (3 * x ^ 3)) d x)\n"
"((3 * ((X ^ 4) / 4)) - (1/3 * ((X ^ -2) / -2)))\n"
"SIMPLIFIER  > (Int (3 * x + 2) ^ -2/3 d x)\n"
"(((3 * X) + 2) ^ 1/3)\n"
"SIMPLIFIER  > (Int sin(x) ^ 2 * cos(x) d x)\n"
"(((SIN X) ^ 3) / 3)\n"
"SIMPLIFIER  > (Int sin(x) / (1 + cos(x)) d x)\n"
"(-1 * (LOG ((COS X) + 1)))\n"
"SIMPLIFIER  > (Int (2 * x + 1) / (x ^ 2 + x - 1) d x)\n"
"(LOG ((X ^ 2) + (X - 1)))\n"
"SIMPLIFIER  > (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)\n"
"(8 * ((1/3 * (((X ^ 3) + 2) ^ -2)) / -2))\n"
"```"
msgstr ""

#: in/chapter8.md:874
msgid ""
"All the answers are correct, although the last one could be made simpler.\n"
"One quick way to simplify such an expression is to factor and unfactor it, "
"and then simplify again:"
msgstr ""
"Все ответы верны, хотя последний можно было бы сделать проще.\n"
"Один из быстрых способов упростить такое выражение - это разложить на "
"множители(факторизовать) и дефакторизовать, а затем снова упростить:"

#: in/chapter8.md:882
msgid ""
"```lisp\n"
"(set-simp-fn 'Int\n"
"    #'(lambda (exp)\n"
"      (unfactorize\n"
"        (factorize\n"
"          (integrate (exp-lhs exp) (exp-rhs exp))))))\n"
"```"
msgstr ""

#: in/chapter8.md:884
msgid "With this change, we get:"
msgstr "С этим изменением мы получаем:"

#: in/chapter8.md:889
msgid ""
"```lisp\n"
"SIMPLIFIER  > (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)\n"
"(-4/3 * (((X ^ 3) + 2) ^ -2))\n"
"```"
msgstr ""

#: in/chapter8.md:891
msgid "## 8.7 History and References"
msgstr "## 8.7 История и ссылки"

#: in/chapter8.md:899
msgid ""
"A brief history is given in the introduction to this chapter.\n"
"An interesting point is that the history of Lisp and of symbolic algebraic "
"manipulation are deeply intertwined.\n"
"It is not too gross an exaggeration to say that Lisp was invented by John "
"McCarthy to express the symbolic differentiation algorithm.\n"
"And the development of the first high-quality Lisp system, MacLisp, was "
"driven largely by the needs of MACSYMA, one of the first large Lisp "
"systems.\n"
"See [McCarthy 1958](B9780080571157500285.xhtml#bb0790) for early Lisp "
"history and the differentiation algorithm, and [Martin and Fateman 1971]"
"(B9780080571157500285.xhtml#bb0775) and [Moses (1975)](B9780080571157500285."
"xhtml#bb0875) for more details on MACSYMA.\n"
"A comprehensive book on computer algebra systems is [Davenport 1988]"
"(B9780080571157500285.xhtml#bb0270).\n"
"It covers the MACSYMA and REDUCE systems as well as the algorithms behind "
"those systems."
msgstr ""

#: in/chapter8.md:903
msgid ""
"Because symbolic differentiation is historically important, it is presented "
"in a number of text books, from the original Lisp 1.5 Primer ([Weissman 1967]"
"(B9780080571157500285.xhtml#bb1370)) and Allen's influential [*Anatomy of "
"Lisp* (1978)](B9780080571157500285.xhtml#bb0040) to recent texts like "
"[Brooks 1985](B9780080571157500285.xhtml#bb0135), [Hennessey 1989]"
"(B9780080571157500285.xhtml#bb0530), and [Tanimoto 1990]"
"(B9780080571157500285.xhtml#bb1220).\n"
"Many of these books use rules or data-driven programming, but each treats "
"differentiation as the main task, with simplification as a separate "
"problem.\n"
"None of them use the approach taken here, where differentiation is just "
"another kind of simplification."
msgstr ""

#: in/chapter8.md:908
msgid ""
"The symbolic integration programs SAINT and SIN are covered in [Slagle 1963]"
"(B9780080571157500285.xhtml#bb1115) and [Moses 1967](B9780080571157500285."
"xhtml#bb0870), respectively.\n"
"The mathematical solution to the problem of integration in closed term is "
"addressed in [Risch 1969](B9780080571157500285.xhtml#bb0985), but be warned; "
"this paper is not for the mathematically naive, and it has no hints on "
"programming the algorithm.\n"
"A better reference is [Davenport et al.\n"
"1988](B9780080571157500285.xhtml#bb0270)."
msgstr ""

#: in/chapter8.md:911
msgid ""
"In this book, techniques for improving the efficiency of algebraic "
"manipulation are covered in [sections 9.6](B9780080571157500091.xhtml#s0035) "
"and [10.4](B9780080571157500108.xhtml#s0025).\n"
"[Chapter 15](B9780080571157500157.xhtml) presents a reimplementation that "
"does not use pattern-matching, and is closer to the techniques used in "
"MACSYMA."
msgstr ""

#: in/chapter8.md:913
msgid "## 8.8 Exercises"
msgstr ""

#: in/chapter8.md:916
msgid ""
"**Exercise  8.2 [s]** Some notations use the operator ** instead of ^ to "
"indicate exponentiation.\n"
"`Fix infix->prefix` so that either notation is allowed."
msgstr ""

#: in/chapter8.md:919
msgid ""
"**Exercise  8.3 [m]** Can the system as is deal with imaginary numbers?\n"
"What are some of the difficulties?"
msgstr ""

#: in/chapter8.md:925
msgid ""
"**Exercise  8.4 [h]** There are some simple expressions involving sums that "
"are not handled by the `integrate` function.\n"
"The function can integrate *a*x *x*2 + *b*x *x* + *c* but not 5 x (*a*x *x*2 "
"+ *b*x *x* + *c*).\n"
"Similarly, it can integrate *x*4 + 2 x *x*3 + *x*2 but not (*x*2 + *x*)2, "
"and it can do *x*3 + *x*2 + *x* + 1 but not (*x*2 + 1) x (*x* + 1).\n"
"Modify `integrate` so that it expands out products (or small exponents) of "
"sums.\n"
"You will probably want to try the usual techniques first, and do the "
"expansion only when that fails."
msgstr ""

#: in/chapter8.md:928
msgid ""
"**Exercise  8.5 [d]** Another very general integration technique is called "
"integration by parts.\n"
"It is based on the rule:"
msgstr ""

#: in/chapter8.md:930
msgid "&int;udv=uv-&int;vdu"
msgstr ""

#: in/chapter8.md:932
msgid "![si6_e](images/chapter8/si6_e.gif)"
msgstr ""

#: in/chapter8.md:934
msgid "So, for example, given"
msgstr ""

#: in/chapter8.md:936
msgid "&int;xcosxdx"
msgstr ""

#: in/chapter8.md:938
msgid "![si7_e](images/chapter8/si7_e.gif)"
msgstr ""

#: in/chapter8.md:941
msgid ""
"we can take *u* = *x*, *dv* = cos *xdx*.\n"
"Then we can determine *v* = sin *x* by integration, and come up with the "
"solution:"
msgstr ""

#: in/chapter8.md:943
msgid "&int;xcosxdx=xsinx-&int;sinxx1dx=xsinx+cosx"
msgstr ""

#: in/chapter8.md:945
msgid "![si8_e](images/chapter8/si8_e.gif)"
msgstr ""

#: in/chapter8.md:951
msgid ""
"It is easy to program an integration by parts routine.\n"
"The hard part is to program the control component.\n"
"Integration by parts involves a recursive call to `integrate`, and of all "
"the possible ways of breaking up the original expression into a *u* and a "
"*dv*, few, if any, will lead to a successful integration.\n"
"One simple control rule is to allow integration by parts only at the top "
"level, not at the recursive level.\n"
"Implement this approach."
msgstr ""

#: in/chapter8.md:954
msgid ""
"**Exercise  8.6 [d]** A more complicated approach is to try to decide which "
"ways of breaking up the original expression are promising and which are "
"not.\n"
"Derive some heuristics for making this division, and reimplement `integrate` "
"to include a search component, using the search tools of [chapter 6]"
"(B9780080571157500066.xhtml)."
msgstr ""

#: in/chapter8.md:957
msgid ""
"Look in a calculus textbook to see how *&int;* sin2*xdx* is evaluated by two "
"integrations by parts and a division.\n"
"Implement this technique as well."
msgstr ""

#: in/chapter8.md:960
msgid ""
"**Exercise  8.7 [m]** Write simplification rules for predicate calculus "
"expressions.\n"
"For example,"
msgstr ""

#: in/chapter8.md:967
msgid ""
"```lisp\n"
"(true and x = x)\n"
"(false and x = false)\n"
"(true or x = true)\n"
"(false or x = false)\n"
"```"
msgstr ""

#: in/chapter8.md:971
msgid ""
"**Exercise  8.8 [m]** The simplification rule `(x / 0 = undefined)` is "
"necessary to avoid problems with division by zero, but the treatment of "
"`undefined` is inadequate.\n"
"For example, the expression `((0 / 0) - (0 / 0))` will simplify to zero, "
"when it should simplify to `undefined`.\n"
"Add rules to propagate `undefined` values and prevent them from being "
"simplified away."
msgstr ""

#: in/chapter8.md:973
msgid ""
"**Exercise  8.9 [d]** Extend the method used to handle `undefined` to handle "
"`+  infinity` and `-infinity` as well."
msgstr ""

#: in/chapter8.md:975
msgid "----------------------"
msgstr ""

#: in/chapter8.md:981
msgid ""
"[1](#xfn0010)MACSYMA is the Project MAC SYMbolic MAthematics program.\n"
"Project MAC is the MIT research organization that was the precursor of MIT's "
"Laboratory for Computer Science.\n"
"MAC stood either for Machine-Aided Cognition or Multiple-Access Computer, "
"according to one of their annual reports.\n"
"The cynical have claimed that MAC really stood for Man Against Computer.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter8.md:984
msgid ""
"[2](#xfn0015) The term antiderivative is more correct, because of branch "
"point problems.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter8.md:988
msgid ""
"Part III\n"
"Tools and Techniques\n"
"!!!(p) {:.parttitle}"
msgstr ""
