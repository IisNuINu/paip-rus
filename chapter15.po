#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter15.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-14 10:35+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter15.md:3
msgid ""
"# Chapter 15\n"
"## Symbolic Mathematics with Canonical Forms"
msgstr ""
"# Глава 15\n"
"## Символическая математика с каноническими формами"

#: in/chapter15.md:5
msgid "> Anything simple always interests me."
msgstr "> Меня всегда интересует все простое."

#: in/chapter15.md:7
msgid "> -David Hockney"
msgstr ""

#: in/chapter15.md:11
msgid ""
"[Chapter 8](B978008057115750008X.xhtml) started with high hopes: to take an "
"existing pattern matcher, copy down some mathematical identities out of a "
"reference book, and come up with a usable symbolic algebra system.\n"
"The resulting system *was* usable for some purposes, and it showed that the "
"technique of rule-based translation is a powerful one.\n"
"However, the problems of [section 8.5](B978008057115750008X.xhtml#s0030) "
"show that not everything can be done easily and efficiently within the rule-"
"based pattern matching framework."
msgstr ""
"[Глава 8](B978008057115750008X.xhtml) началась с больших надежд: взять "
"существующий сопоставитель с образцом, скопировать некоторые математические "
"тождества из справочника и придумать пригодную для использования систему "
"символьной алгебры.\n"
"Получившаяся система *была* применима для некоторых целей, и она показала, "
"что техника преобразования на основе правил является мощной.\n"
"Однако проблемы [раздел 8.5](B978008057115750008X.xhtml#s0030) показывают, "
"что не все можно сделать легко и эффективно в рамках инструментария "
"сопоставления с образцом на основе правил."

#: in/chapter15.md:14
msgid ""
"There are important mathematical transformations that are difficult to "
"express in the rule-based approach.\n"
"For example, dividing two polynomials to obtain a quotient and remainder is "
"a task that is easier to express as an algorithm-a program-than as a rule or "
"set of rules."
msgstr ""
"Существуют важные математические преобразования, которые трудно выразить с "
"помощью подхода, основанного на правилах.\n"
"Например, деление двух многочленов для получения частного и остатка - это "
"задача, которую легче выразить в виде алгоритма или программы, чем правила "
"или набора правил."

#: in/chapter15.md:19
msgid ""
"In addition, there is a problem with efficiency.\n"
"Pieces of the input expressions are simplified over and over again, and much "
"time is spent interpreting rules that do not apply.\n"
"[Section 9.6](B9780080571157500091.xhtml#s0035) showed some techniques for "
"speeding up the program by a factor of 100 on inputs of a dozen or so "
"symbols, but for expressions with a hundred or so symbols, the speed-up is "
"not enough.\n"
"We can do better by designing a specialized representation from the ground "
"up."
msgstr ""
"Кроме того, есть проблема с эффективностью.\n"
"Части входных выражений снова и снова упрощаются, и много времени уходит на "
"интерпретацию неприменимых правил.\n"
"[Раздел 9.6](B9780080571157500091.xhtml#s0035) показал некоторые методы "
"ускорения программы в 100 раз при вводе примерно дюжины символов, но для "
"выражений с примерно сотней символов такого ускорения недостаточно.\n"
"Мы можем добиться большего, если спроектируем специализированное "
"представление с нуля."

#: in/chapter15.md:28
msgid ""
"Serious algebraic manipulation programs generally enforce a notion of "
"*canonical simplification.* That is, expressions are converted into a "
"canonical internal format that may be far removed from the input form.\n"
"They are then manipulated, and translated back to external form for output.\n"
"Of course, the simplifier we have already does this kind of translation, to "
"some degree.\n"
"It translates `(3 + x + -3 + y)` into `(+ x y)` internally, and then outputs "
"it as `(x + y)`.\n"
"But a *canonical* representation must have the property that any two "
"expressions that are equal have identical canonical forms.\n"
"In our system the expression `(5 + y + x + -5)`is translated to the internal "
"form `(+ y x)`, which is not identical to `(+ x y)`, even though the two "
"expressions are equal.\n"
"Thus, our system is not canonical.\n"
"Most of the problems of the previous section stem from the lack of a "
"canonical form."
msgstr ""
"Программы серьезных алгебраических манипуляций обычно применяют понятие "
"*канонического упрощения*. То есть выражения преобразуются в канонический "
"внутренний формат, который может быть далек от формы ввода.\n"
"Затем ими манипулируют и переводят обратно во внешнюю форму для вывода.\n"
"Конечно, упрощатель, который у нас уже есть, в некоторой степени выполняет "
"такой перевод.\n"
"Он внутренне переводит `(3 + x + -3 + y)` в `(+ x y)`, а затем выводит его "
"как `(x + y)`.\n"
"Но *каноническое* представление должно обладать тем свойством, что любые два "
"равных выражения имеют идентичные канонические формы.\n"
"В нашей системе выражение `(5 + y + x + -5)` преобразуется во внутреннюю "
"форму `(+ y x)`, которая не идентична `(+ x y)`, даже если эти два выражения "
"равны.\n"
"Таким образом, наша система не является канонической.\n"
"Большинство проблем предыдущего раздела проистекают из отсутствия "
"канонической формы."

#: in/chapter15.md:36
msgid ""
"Adhering to canonical form imposes grave restrictions on the "
"representation.\n"
"For example, *x2*-  1 and (*x*- 1)(*x* + 1) are equal, so they must be "
"represented identically.\n"
"One way to insure this is to multiply out all factors and collect similar "
"terms.\n"
"So (*x*- 1)(*x* + 1) is *x2*- *x* + *x*- 1, which simplifies to *x2*-  1, in "
"whatever the canonical internal form is.\n"
"This approach works fine for *x2*- 1, but for an expression like (*x*- "
"1)1000, multiplying out all factors would be quite time- (and space-) "
"consuming.\n"
"It is hard to find a canonical form that is ideal for all problems.\n"
"The best we can do is choose one that works well for the problems we are "
"most likely to encounter."
msgstr ""
"Соблюдение канонической формы накладывает серьезные ограничения на "
"представление.\n"
"Например, *x2*- 1 и (*x* - 1) (*x* + 1) равны, поэтому они должны быть "
"представлены одинаково.\n"
"Один из способов гарантировать это - перемножить все факторы и собрать "
"аналогичные термины.\n"
"Итак, (*x*- 1)(*x* + 1) равно *x2* - *x* + *x* - 1, что упрощается до *x2* - "
"1 в любой канонической внутренней форме.\n"
"Этот подход отлично работает для *x2* - 1, но для такого выражения, как (*x* "
"- 1) 1000, умножение всех факторов потребует много времени (и места).\n"
"Трудно найти каноническую форму, идеально подходящую для всех задач.\n"
"Лучшее, что мы можем сделать, это выбрать ту, которая хорошо подходит для "
"проблем, с которыми мы, скорее всего, столкнемся."

#: in/chapter15.md:38
msgid "## 15.1 A Canonical Form for Polynomials"
msgstr "## 15.1 Каноническая форма для многочленов(полиномов)"

#: in/chapter15.md:41
msgid ""
"This section will concentrate on a canonical form for *polynomials.* "
"Mathematically speaking, a polynomial is a function (of one or more "
"variables) that can be computed using only addition and multiplication.\n"
"We will speak of a polynomial's *main variable, coefficients,* and *degree.* "
"In the polynomial:"
msgstr ""
"В этом разделе мы сконцентрируемся на канонической форме для *многочленов* С "
"математической точки зрения, многочлен - это функция (от одной или "
"нескольких переменных), которую можно вычислить, используя только сложение и "
"умножение.\n"
"Мы будем говорить о *основной переменной многочлена(полинома), "
"коэффициентах* и *степени*. В полиноме:"

#: in/chapter15.md:43
msgid "5xx3+bxx2+cxx+1"
msgstr ""

#: in/chapter15.md:45
msgid "![si1_e](images/chapter15/si1_e.gif)"
msgstr ""

#: in/chapter15.md:48
msgid ""
"the main variable is *x,* the degree is 3 (the highest power of *x*), and "
"the coefficients are 5, *b, c* and 1.\n"
"We can define an input format for polynomials as follows:"
msgstr ""
"основная переменная *x*, степень равна 3 (наивысшая степень *x*), а "
"коэффициенты равны 5, *b, c* и 1.\n"
"Мы можем определить входной формат для полиномов следующим образом:"

#: in/chapter15.md:51
msgid ""
"1.  Any Lisp number is a polynomial.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Любое число Лиспа является многочленом.\n"
"!!!(p) {:.numlist}"

#: in/chapter15.md:54
msgid ""
"2.  Any Lisp symbol is a polynomial.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Любой символ Лиспа является многочленом.\n"
"!!!(p) {:.numlist}"

#: in/chapter15.md:57
msgid ""
"3.  If *p* and *q* are polynomials, so are (*p + q*) and (*p * q*).\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Если *p* и *q* - многочлены, то (*p + q*) и (*p * q*) - тоже.\n"
"!!!(p) {:.numlist}"

#: in/chapter15.md:60
msgid ""
"4.  If *p* is a polynomial and *n* is a positive integer, then (*p* ^ *n*) "
"is a polynomial.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Если *p* - многочлен, а *n* - положительное целое число, то (*p* ^ *n*) "
"- многочлен.\n"
"!!!(p) {:.numlist}"

#: in/chapter15.md:62
msgid ""
"However, the input format cannot be used as the canonical form, because it "
"would admit both `(x + y)` and `(y + x)`, and both `4` and `(2 + 2)`."
msgstr ""
"Однако формат ввода нельзя использовать в качестве канонической формы, "
"потому что он допускает как `(x + y)`, так и `(y + x)`, а также `4` и `(2 + "
"2)`."

#: in/chapter15.md:69
msgid ""
"Before considering a canonical form for polynomials, let us see why "
"polynomials were chosen as the target domain.\n"
"First, the volume of programming needed to support canonical forms for a "
"larger class of expressions grows substantially.\n"
"To make things easier, we have eliminated complications like log and trig "
"functions.\n"
"Polynomials are a good choice because they are closed under addition and "
"multiplication: the sum or product of any two polynomials is a polynomial.\n"
"If we had allowed division, the result would not be closed, because the "
"quotient of two polynomials need not be a polynomial.\n"
"As a bonus, polynomials are also closed under differentiation and "
"integration, so we can include those operators as well."
msgstr ""
"Прежде чем рассматривать каноническую форму для многочленов, давайте "
"посмотрим, почему многочлены были выбраны в качестве целевой области.\n"
"Во-первых, существенно возрастает объем программирования, необходимый для "
"поддержки канонических форм для более широкого класса выражений.\n"
"Чтобы упростить задачу, мы устранили такие сложности, как функции "
"log(логарифмические) и trig(тригонометрические).\n"
"Многочлены - хороший выбор, потому что они замкнуты относительно сложения и "
"умножения: сумма или произведение любых двух многочленов является "
"многочленом.\n"
"Если бы мы разрешили деление, результат не был бы замкнут, потому что "
"частное двух многочленов не обязательно должно быть многочленом.\n"
"В качестве бонуса многочлены также замыкаются при дифференцировании и "
"интегрировании, поэтому мы также можем включить эти операторы."

#: in/chapter15.md:74
msgid ""
"Second, for sufficiently large classes of expressions it becomes not just "
"difficult but impossible to define a canonical form.\n"
"This may be surprising, and we don't have space here to explain exactly why "
"it is so, but here is an argument: Consider what would happen if we added "
"enough functionality to duplicate all of Lisp.\n"
"Then \"converting to canonical form\" would be the same as \"running a "
"program.\" But it is an elementary result of computability theory that it is "
"in general impossible to determine the result of running an arbitrary "
"program (this is known as the halting problem).\n"
"Thus, it is not surprising that it is impossible to canonicalize complex "
"expressions."
msgstr ""
"Во-вторых, для достаточно больших классов выражений становится не просто "
"сложно, но и невозможно определить каноническую форму.\n"
"Это может показаться удивительным, и у нас нет места, чтобы объяснить, "
"почему это так, но вот аргумент: подумайте, что бы произошло, если бы мы "
"добавили достаточно функциональности, чтобы дублировать весь Лисп.\n"
"Тогда \"преобразование в каноническую форму\" будет таким же, как \"запуск "
"программы\". Но элементарным результатом теории вычислимости является то, "
"что в общем случае невозможно определить результат выполнения произвольной "
"программы (это известно как проблема остановки).\n"
"Таким образом, неудивительно, что невозможно канонизировать сложные "
"выражения."

#: in/chapter15.md:76
msgid ""
"Our task is to convert a polynomial as previously defined into some "
"canonical form.[1](#fn0015) Much of the code and some of the commentary on "
"this format and the routines to manipulate it was written by Richard "
"Fateman, with some enhancements made by Peter Klier."
msgstr ""
"Наша задача - преобразовать ранее определенный многочлен в некоторую "
"каноническую форму. [1](#fn0015) Большая часть кода и некоторые комментарии "
"к этому формату и процедурам для управления им были написаны Ричардом "
"Фейтманом с некоторыми усовершенствованиями. пользователя Peter Klier."

#: in/chapter15.md:81
msgid ""
"The first design decision is to assume that we will be dealing mostly with "
"*dense* polynomials, rather than *sparse* ones.\n"
"That is, we expect most of the polynomials to be like *ax*3*+ bx*2*+ cx* + "
"*d,* not like *ax*100*+ bx*50 + *c.* For dense polynomials, we can save "
"space by representing the main variable (*x* in these examples) and the "
"individual coefficients (*a*, *b*, *c*, and *d* in these examples) "
"explicitly, but representing the exponents only implicitly, by position.\n"
"Vectors will be used instead of lists, to save space and to allow fast "
"access to any element.\n"
"Thus, the representation of 5*x*3+ 10*x*2+ 20*x +* 30 will be the vector:"
msgstr ""
"Первое дизайнерское решение - предположить, что мы будем иметь дело в "
"основном с *плотными* многочленами, а не с *разреженными*.\n"
"То есть мы ожидаем, что большинство многочленов будут похожи на *ax * 3 * + "
"bx * 2 * + cx * + * d,* не на *ax * 100 * + bx * 50 + * c.* Для плотных "
"многочленов мы можем сэкономить место, представив основную переменную (*x* в "
"этих примерах) и отдельные коэффициенты (*a*, *b*, *c* и *d* в этих "
"примерах) явно, но представляя экспоненты только неявно , по позиции.\n"
"Вместо списков будут использоваться векторы, чтобы сэкономить место и "
"обеспечить быстрый доступ к любому элементу.\n"
"Таким образом, представление 5 * x * 3 + 10 * x * 2 + 20 * x + * 30 будет "
"вектором:"

#: in/chapter15.md:85
msgid ""
"```lisp\n"
"#(x 30 20 10 5)\n"
"```"
msgstr ""

#: in/chapter15.md:88
msgid ""
"The main variable, *x*, is in the 0th element of the vector, and the "
"coefficient of the *i*th power of *x* is in element *i* + 1 of the vector.\n"
"A single variable is represented as a vector whose first coefficient is 1, "
"and a number is represented as itself:"
msgstr ""
"Основная переменная *x* находится в 0-м элементе вектора, а коэффициент при "
"*i* -й степени *x* находится в элементе *i* + 1 вектора.\n"
"Одиночная переменная представлена как вектор, первый коэффициент которого "
"равен 1, а число представлено как само себя:"

#: in/chapter15.md:94
msgid ""
"| []()              |                                        |\n"
"|-------------------|----------------------------------------|\n"
"| `#(x 30 20 10 5)` | represents 5*x*3 + 10*x*2 + 20*x* + 30 |\n"
"| `#(x 0 1)`        | represents *x*                         |\n"
"| `5`               | represents 5                           |"
msgstr ""

#: in/chapter15.md:99
msgid ""
"The fact that a number is represented as itself is a possible source of "
"confusion.\n"
"The number 5, for example, is a polynomial by our mathematical definition of "
"polynomials.\n"
"But it is represented as 5, not as a vector, so `(typep 5 'polynomial)` will "
"be false.\n"
"The word \"polynomial\" is used ambiguously to refer to both the "
"mathematical concept and the Lisp type, but it should be clear from context "
"which is meant."
msgstr ""
"Тот факт, что число представлено самим собой, может вызвать путаницу.\n"
"Число 5, например, является многочленом согласно нашему математическому "
"определению многочленов.\n"
"Но он представлен как 5, а не как вектор, поэтому `(typep 5 'polynomial)` "
"будет ложным.\n"
"Слово \"многочлен\" используется неоднозначно для обозначения как "
"математической концепции, так и типа Лисп, но из контекста должно быть ясно, "
"что имеется в виду."

#: in/chapter15.md:101
msgid ""
"A glossary for the canonical simplifier program is given in [figure  15.1]"
"(#f0010)."
msgstr ""
"Глоссарий программы канонического упрощения приведен на [рисунок 15.1]"
"(#f0010)."

#: in/chapter15.md:106
msgid ""
"| []()                                                        |\n"
"|-------------------------------------------------------------|\n"
"| ![f15-01](images/chapter15/f15-01.jpg)                      |\n"
"| Figure 15.1: Glossary for the Symbolic Manipulation Program |"
msgstr ""
"| []()                                                        |\n"
"|-------------------------------------------------------------|\n"
"| ![f15-01](images/chapter15/f15-01.jpg)                      |\n"
"| Рисунок 15.1: Глоссарий программы символьной манипуляции |"

#: in/chapter15.md:108
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter15.md:112
msgid ""
"The functions defining the type `polynomial` follow.\n"
"Because we are concerned with efficiency, we proclaim certain short "
"functions to be compiled inline, use the specific function `svref` (simple-"
"vector reference) rather than the more general aref, and provide "
"declarations for the polynomials using the special form the.\n"
"More details on efficiency issues are given in [Chapter 9]"
"(B9780080571157500091.xhtml)."
msgstr ""
"Функции, определяющие тип `polynomial`-полинома, следуют ниже.\n"
"Поскольку нас интересует эффективность, мы объявляем, что некоторые короткие "
"функции компилируются inline-встроенно, используем конкретную функцию "
"`svref` (simple-vector reference/ссылка на простой вектор), а не более общую "
"aref, и предоставляем объявления для многочленов с использованием "
"специальной формы the.\n"
"Более подробная информация по вопросам эффективности приведена в [Глава 9]"
"(B9780080571157500091.xhtml)."

#: in/chapter15.md:116
msgid ""
"```lisp\n"
"(proclaim '(inline main-var degree coef\n"
"```"
msgstr ""

#: in/chapter15.md:118
msgid "              `var= var> poly make-poly))`"
msgstr ""

#: in/chapter15.md:125
msgid ""
"```lisp\n"
"(deftype polynomial () 'simple-vector)\n"
"(defun main-var (p) (svref (the polynomial p) 0))\n"
"(defun coef (p i)  (svref (the polynomial p) (+ i 1)))\n"
"(defun degree (p)  (-(length (the polynomial p)) 2))\n"
"```"
msgstr ""

#: in/chapter15.md:131
msgid ""
"We had to make another design decision in defining `coef`, the function to "
"extract a coefficient from a polynomial.\n"
"As stated above, the *i*th coefficient of a polynomial is in element *i* + 1 "
"of the vector.\n"
"If we required the caller of coef to pass in *i* + 1 to get *i,* we might be "
"able to save a few addition operations.\n"
"The design decision was that this would be too confusing and error prone.\n"
"Thus, coef expects to be passed *i* and does the addition itself."
msgstr ""
"Нам пришлось принять еще одно дизайнерское решение при определении `coef`, "
"функции для извлечения коэффициента из полинома.\n"
"Как указано выше, *i* -ый коэффициент многочлена находится в элементе "
"вектора *i* + 1.\n"
"Если мы потребуем, чтобы вызывающий `coef` передал *i* + 1, чтобы получить "
"*i*, мы могли бы сэкономить несколько операций сложения.\n"
"Дизайнерское решение заключалось в том, что это будет слишком запутанным и "
"подверженным ошибкам.\n"
"Таким образом, coef ожидает передачи *i* и выполняет сложение самостоятельно."

#: in/chapter15.md:134
msgid ""
"For our format, we will insist that main variables be symbols, while "
"coefficients can be numbers or other polynomials.\n"
"A \"production\" version of the program might have to account for main "
"variables like `(sin x)`, as well as other complications like + and * with "
"more than two arguments, and noninteger powers."
msgstr ""
"В нашем формате мы будем настаивать на том, чтобы основные переменные были "
"символами, а коэффициенты могли быть числами или другими многочленами.\n"
"\"Производственная\" версия программы может учитывать основные переменные, "
"такие как `(sin x)`, а также другие сложности, такие как + и * с более чем "
"двумя аргументами и нецелочисленными степенями."

#: in/chapter15.md:138
msgid ""
"Now we can extract information from a polynomial, but we also need to build "
"and modify polynomials.\n"
"The function `poly` takes a variable and some coefficients and builds a "
"vector representing the polynomial.\n"
"`make-poly` takes a variable and a degree and produces a polynomial with all "
"zero coefficients."
msgstr ""
"Теперь мы можем извлекать информацию из многочлена, но нам также необходимо "
"создавать и изменять многочлены.\n"
"Функция `poly` принимает переменную и некоторые коэффициенты и строит "
"вектор, представляющий многочлен.\n"
"`make-poly` принимает переменную и степень и производит/создает многочлен со "
"всеми нулевыми коэффициентами."

#: in/chapter15.md:144
msgid ""
"```lisp\n"
"(defun poly (x &rest coefs)\n"
"  \"Make a polynomial with main variable x\n"
"  and coefficients in increasing order.\"\n"
"  (apply #'vector x coefs))"
msgstr ""

#: in/chapter15.md:151
msgid ""
"(defun make-poly (x degree)\n"
"  \"Make the polynomial 0 + 0*x + 0*x^2 + ... 0*x^degree\"\n"
"  (let ((p (make-array (+ degree 2) :initial-element 0)))\n"
"    (setf (main-var p) x)\n"
"    p))\n"
"```"
msgstr ""

#: in/chapter15.md:153
msgid ""
"A polynomial can be altered by setting its main variable or any one of its "
"coefficients using the following `defsetf` forms."
msgstr ""
"Многочлен можно изменить, установив его основную переменную или любой из его "
"коэффициентов, используя следующие формы `defsetf`."

#: in/chapter15.md:157
msgid ""
"```lisp\n"
"(defsetf main-var (p) (val)\n"
"  `(setf (svref (the polynomial ,p) 0) ,val))"
msgstr ""

#: in/chapter15.md:161
msgid ""
"(defsetf coef (p i) (val)\n"
"  `(setf (svref (the polynomial ,p) (+ ,i 1)) ,val))\n"
"```"
msgstr ""

#: in/chapter15.md:163
msgid ""
"The function `poly` constructs polynomials in a fashion similar to `list` or "
"`vector`: with an explicit list of the contents, `make-poly`, on the other "
"hand, is like `make-array`: it makes a polynomial of a specified size."
msgstr ""
"Функция `poly` конструирует многочлены аналогично `list` или `vector`: с "
"явным списком содержимого, `make-poly`, с другой стороны, похожа на `make-"
"array`: она создает многочлен заданного размера."

#: in/chapter15.md:173
msgid ""
"We provide `setf` methods for modifying the main variable and coefficients.\n"
"Since this is the first use of `defsetf`, it deserves some explanation.\n"
"A `defsetf` form takes a function (or macro) name, an argument list, and a "
"second argument list that must consist of a single argument, the value to be "
"assigned.\n"
"The body of the form is an expression that stores the value in the proper "
"place.\n"
"So the `defsetf` for `main-var` says that `(setf (main-varp) val)` is "
"equivalent to `(setf (svref (the polynomial p) 0) val)`.\n"
"A `defsetf` is much like a `defmacro`, but there is a little less burden "
"placed on the writer of `defsetf`.\n"
"Instead of passing `p` and `val` directly to the `setf` method, Common Lisp "
"binds local variables to these expressions, and passes those variables to "
"the `setf` method.\n"
"That way, the writer does not have to worry about evaluating the expressions "
"in the wrong order or the wrong number of times.\n"
"It is also possible to gain finer control over the whole process with "
"`define-setf-method`, as explained on [page 884](B978008057115750025X."
"xhtml#p884)."
msgstr ""
"Мы предоставляем методы `setf` для изменения основной переменной и "
"коэффициентов.\n"
"Поскольку это первое использование `defsetf`, оно заслуживает некоторых "
"пояснений.\n"
"Форма `defsetf` принимает имя функции (или макроса), список аргументов и "
"второй список аргументов, который должен состоять из одного аргумента, "
"значения, которое должно быть присвоено.\n"
"Тело формы - это выражение, в котором значение хранится в нужном месте.\n"
"Таким образом, `defsetf` для `main-var` говорит, что `(setf (main-varp) "
"val)` эквивалентно `(setf (svref (the polynomial p) 0) val)`.\n"
"`defsetf` очень похож на `defmacro`, но на писателя `defsetf` ложится "
"немного меньше бремени.\n"
"Вместо передачи `p` и `val` непосредственно методу `setf`, Common Lisp "
"связывает локальные переменные с этими выражениями и передает эти переменные "
"методу `setf`.\n"
"Таким образом, писателю не нужно беспокоиться об вычислении выражений в "
"неправильном порядке или неправильном количестве раз.\n"
"Также возможно получить более точный контроль над всем процессом с помощью "
"`define-setf-method`, как описано на [стр. 884](B978008057115750025X."
"xhtml#p884)."

#: in/chapter15.md:180
msgid ""
"The functions `poly+poly, poly*poly` and `poly^n` perform addition, "
"multiplication, and exponentiation of polynomials, respectively.\n"
"They are defined with several helping functions.\n"
"`k*poly` multiplies a polynomial by a constant, `k`, which may be a number "
"or another polynomial that is free of polynomial `p`'s main variable.\n"
"`poly*same` is used to multiply two polynomials with the same main "
"variable.\n"
"For addition, the functions `k+poly` and `poly+same` serve analogous "
"purposes.\n"
"With that in mind, here's the function to convert from prefix to canonical "
"form:"
msgstr ""
"Функции `poly+poly, poly*poly и poly^n` выполняют сложение, умножение и "
"возведение в степень многочленов соответственно.\n"
"Они определены с несколькими вспомогательными функциями.\n"
"`k*poly` умножает многочлен на константу,`k`, которая может быть числом или "
"другим многочленом, не содержащим главной переменной многочлена `p`.\n"
"`poly*same` используется для умножения двух многочленов на одну и ту же "
"главную переменную.\n"
"Кроме того, аналогичным целям служат функции `k+poly` и `poly+same`.\n"
"Имея это в виду, вот функция для преобразования префикса в каноническую "
"форму:"

#: in/chapter15.md:193
msgid ""
"```lisp\n"
"(defun prefix->canon (x)\n"
"  \"Convert a prefix Lisp expression to canonical form.\n"
"  Exs: (+ (^ x 2) (* 3 x)) => #(x 0 3 1)\n"
"       (- (* (- x 1) (+ x 1)) (- (^ x 2) 1)) => 0\"\n"
"  (cond ((numberp x) x)\n"
"        ((symbolp x) (poly x 0 1))\n"
"        ((and (exp-p x) (get (exp-op x) 'prefix->canon))\n"
"         (apply (get (exp-op x) 'prefix->canon)\n"
"                (mapcar #'prefix->canon (exp-args x))))\n"
"        (t (error \"Not a polynomial: ~a\" x))))\n"
"```"
msgstr ""

#: in/chapter15.md:199
msgid ""
"It is data-driven, based on the `prefix->canon` property of each operator.\n"
"In the following we install the appropriate functions.\n"
"The existing functions `poly*poly` and `poly^n` can be used directly.\n"
"But other operators need interface functions.\n"
"The operators + and - need interface functions that handle both unary and "
"binary."
msgstr ""
"Она управляется данными и основана на свойстве `prefix->canon` каждого "
"оператора.\n"
"Далее мы устанавливаем соответствующие функции.\n"
"Существующие функции `poly*poly` и `poly^n` можно использовать напрямую.\n"
"Но другим операторам нужны интерфейсные функции.\n"
"Операторам + и - нужны интерфейсные функции, которые обрабатывают как "
"унарные, так и бинарные(двойные) данные."

#: in/chapter15.md:204
msgid ""
"```lisp\n"
"(dolist (item '((+ poly+) (- poly-) (* poly*poly)\n"
"                (^ poly^n) (D deriv-poly)))\n"
"  (setf (get (first item) 'prefix->canon) (second item)))"
msgstr ""

#: in/chapter15.md:210
msgid ""
"(defun poly+ (&rest args)\n"
"  \"Unary or binary polynomial addition.\"\n"
"  (ecase (length args)\n"
"    (1 (first args))\n"
"    (2 (poly+poly (first args) (second args)))))"
msgstr ""

#: in/chapter15.md:218
msgid ""
"(defun poly- (&rest args)\n"
"  \"Unary or binary polynomial subtraction.\"\n"
"  (ecase (length args)\n"
"    (0 0)\n"
"    (1 (poly*poly -1 (first args)))\n"
"    (2 (poly+poly (first args) (poly*poly -1 (second args))))))\n"
"```"
msgstr ""

#: in/chapter15.md:221
msgid ""
"The function `prefix->canon` accepts inputs that were not part of our "
"definition of polynomials: unary positive and negation operators and binary "
"subtraction and differentiation operators.\n"
"These are permissible because they can all be reduced to the elementary + "
"and * operations."
msgstr ""
"Функция `prefix->canon` принимает входные данные, которые не были частью "
"нашего определения многочленов: унарные операторы положительного и "
"отрицательного значений, а также бинарные операторы вычитания и "
"дифференцирования.\n"
"Это допустимо, потому что все они могут быть сведены к элементарным "
"операциям + и *."

#: in/chapter15.md:226
msgid ""
"Remember that our problems with canonical form all began with the inability "
"to decide which was simpler: `(+ x y)` or `(+ y x)`.\n"
"In this system, we define a canonical form by imposing an ordering on "
"variables (we use alphabetic ordering as defined by `string>`).\n"
"The rule is that a polynomial `p` can have coefficients that are polynomials "
"in a variable later in the alphabet than `p`'s main variable, but no "
"coefficients that are polynomials in variables earlier than `p`'s main "
"variable.\n"
"Here's how to compare variables:"
msgstr ""
"Помните, что наши проблемы с канонической формой начались с неспособности "
"решить, что проще: `(+ x y)` или `(+ y x)`.\n"
"В этой системе мы определяем каноническую форму, налагая порядок на "
"переменные (мы используем алфавитный порядок, как определено `string>`).\n"
"Правило состоит в том, что полином `p` может иметь коэффициенты, которые "
"являются полиномами от переменной, расположенной позже в алфавите, чем "
"основная переменная `p`, но не коэффициенты, которые являются полиномами от "
"переменных, предшествующих основной переменной `p`.\n"
"Вот как сравнивать переменные:"

#: in/chapter15.md:231
msgid ""
"```lisp\n"
"(defun var= (x y) (eq x y))\n"
"(defun var> (x y) (string> x y))\n"
"```"
msgstr ""

#: in/chapter15.md:236
msgid ""
"The canonical form of the variable `x` will be `#(x 0 1)`, which is 0 x *x*0 "
"+ 1 x *x*1.\n"
"The canonical form of `(+ x y)` is `#(x #(y 0 1) 1)`.\n"
"It couldn't be `#(y #(x 0 1) 1)`, because then the resulting polynomial "
"would have a coefficient with a lesser main variable.\n"
"The policy of ordering variables assures canonicality, by properly grouping "
"like variables together and by imposing a particular ordering on expressions "
"that would otherwise be commutative."
msgstr ""
"Каноническая форма переменной `x` будет `#(x 0 1)`, что равно 0 x *x*0 + 1 x "
"*x*1.\n"
"Каноническая форма `(+ x y)` это `#(x #(y 0 1) 1)`.\n"
"Она не может быть `#(y #(x 0 1) 1)`, потому что тогда полученный многочлен "
"будет иметь коэффициент с меньшей основной переменной.\n"
"Политика упорядочивания переменных обеспечивает каноничность за счет "
"правильного группирования одинаковых переменных вместе и наложения "
"определенного порядка на выражения, которые в противном случае были бы "
"коммутативными."

#: in/chapter15.md:238
msgid "Here, then, is the code for adding two polynomials:"
msgstr "Итак, вот код для сложения двух многочленов:"

#: in/chapter15.md:249
msgid ""
"```lisp\n"
"(defun poly+poly (p q)\n"
"  \"Add two polynomials.\"\n"
"  (normalize-poly\n"
"    (cond\n"
"      ((numberp p)                      (k+poly p q))\n"
"      ((numberp q)                      (k+poly q p))\n"
"      ((var= (main-var p) (main-var q)) (poly+same p q))\n"
"      ((var> (main-var q) (main-var p)) (k+poly q p))\n"
"      (t                                (k+poly p q)))))"
msgstr ""

#: in/chapter15.md:258
msgid ""
"(defun k+poly (k p)\n"
"  \"Add a constant k to a polynomial p.\"\n"
"  (cond ((eql k 0) p)                 ;; 0 + p = p\n"
"        ((and (numberp k) (numberp p))\n"
"         (+ k p))                     ;; Add numbers\n"
"        (t (let ((r (copy-poly p)))   ;; Add k to x^0 term of p\n"
"             (setf (coef r 0) (poly+poly (coef r 0) k))\n"
"             r))))"
msgstr ""

#: in/chapter15.md:269
msgid ""
"(defun poly+same (p q)\n"
"  \"Add two polynomials with the same main variable.\"\n"
"  ;; First assure that q is the higher degree polynomial\n"
"  (if (> (degree p) (degree q))\n"
"      (poly+same q p)\n"
"      ;; Add each element of p into r (which is a copy of q).\n"
"      (let ((r (copy-poly q)))\n"
"        (loop for i from 0 to (degree p) do\n"
"              (setf (coef r i) (poly+poly (coef r i) (coef p i))))\n"
"        r)))"
msgstr ""

#: in/chapter15.md:274
msgid ""
"(defun copy-poly (p)\n"
"  \"Make a copy a polynomial.\"\n"
"  (copy-seq p))\n"
"```"
msgstr ""

#: in/chapter15.md:276
msgid "and the code for multiplying polynomials:"
msgstr "и код для умножения многочленов:"

#: in/chapter15.md:287
msgid ""
"```lisp\n"
"(defun poly*poly (p q)\n"
"  \"Multiply two polynomials.\"\n"
"  (normalize-poly\n"
"    (cond\n"
"      ((numberp p)                      (k*poly p q))\n"
"      ((numberp q)                      (k*poly q p))\n"
"      ((var= (main-var p) (main-var q)) (poly*same p q))\n"
"      ((var> (main-var q) (main-var p)) (k*poly q p))\n"
"      (t                                (k*poly p q)))))"
msgstr ""

#: in/chapter15.md:302
msgid ""
"(defun k*poly (k p)\n"
"  \"Multiply a polynomial p by a constant factor k.\"\n"
"  (cond\n"
"    ((eql k 0)         0)       ;; 0 * p = 0\n"
"    ((eql k 1)         p)       ;; 1 * p = p\n"
"    ((and (numberp k)\n"
"          (numberp p)) (* k p)) ;; Multiply numbers\n"
"    (t ;; Multiply each coefficient\n"
"     (let ((r (make-poly (main-var p) (degree p))))\n"
"       ;; Accumulate result in r;  r[i] = k*p[i]\n"
"       (loop for i from 0 to (degree p) do\n"
"             (setf (coef r i) (poly*poly k (coef p i))))\n"
"       r))))\n"
"```"
msgstr ""

#: in/chapter15.md:307
msgid ""
"The hard part is multiplying two polynomials with the same main variable.\n"
"This is done by creating a new polynomial, `r`, whose degree is the sum of "
"the two input polynomials `p` and `q`.\n"
"Initially, all of `r`'s coefficients are zero.\n"
"A doubly nested loop multiplies each coefficient of `p` and `q` and adds the "
"`result` into the appropriate coefficient of `r`."
msgstr ""
"Сложная часть - это умножение двух многочленов на одну и ту же главную "
"переменную.\n"
"Это делается путем создания нового полинома, `r`, степень которого является "
"суммой двух входных полиномов `p` и `q`.\n"
"Первоначально все коэффициенты `r` равны нулю.\n"
"Дважды вложенный цикл умножает каждый коэффициент `p` и `q` и добавляет "
"результат к соответствующему коэффициенту `r`."

#: in/chapter15.md:323
msgid ""
"```lisp\n"
"(defun poly*same (p q)\n"
"  \"Multiply two polynomials with the same variable.\"\n"
"  ;; r[i] = p[0]*q[i] + p[1]*q[i-1] + ...\n"
"  (let* ((r-degree (+ (degree p) (degree q)))\n"
"         (r (make-poly (main-var p) r-degree)))\n"
"    (loop for i from 0 to (degree p) do\n"
"          (unless (eql (coef p i) 0)\n"
"            (loop for j from 0 to (degree q) do\n"
"                  (setf (coef r (+ i j))\n"
"                        (poly+poly (coef r (+ i j))\n"
"                                   (poly*poly (coef p i)\n"
"                                              (coef q j)))))))\n"
"    r))\n"
"```"
msgstr ""

#: in/chapter15.md:328
msgid ""
"Both `poly+poly` and `poly*poly` make use of the function `normalize-poly` "
"to \"normalize\" the `result`.\n"
"The idea is that `(- (^ 5) (^ x 5))` should return 0, not `#(x 0 0 0 0 0 "
"0)`.\n"
"Note that `normal` ize`-poly` is a destructive operation: it calls `delete,` "
"which can actually alter its argument.\n"
"Normally this is a dangerous thing, but since `normalize-poly` is replacing "
"something with its conceptual equal, no harm is done."
msgstr ""
"И `poly+poly`, и `poly*poly` используют функцию `normalize-poly` для "
"\"нормализации\" результата.\n"
"Идея состоит в том, что `(- (^ 5) (^ x 5))` должен возвращать 0, а не `#(x 0 "
"0 0 0 0 0)`.\n"
"Обратите внимание, что `normalize-poly` - это деструктивная операция: она "
"вызывает `delete`, что может фактически изменить ее аргумент.\n"
"Обычно это опасно, но поскольку `normalize-poly` заменяет что-то его "
"концептуальным эквивалентом, никакого вреда не происходит."

#: in/chapter15.md:342
msgid ""
"```lisp\n"
"(defun normalize-poly (p)\n"
"  \"Alter a polynomial by dropping trailing zeros.\"\n"
"  (if (numberp p)\n"
"      p\n"
"      (let ((p-degree (- (position 0 p :test (complement #'eql)\n"
"                                       :from-end t)\n"
"                         1)))\n"
"        (cond ((<= p-degree 0) (normalize-poly (coef p 0)))\n"
"              ((< p-degree (degree p))\n"
"               (delete 0 p :start p-degree))\n"
"              (t p)))))\n"
"```"
msgstr ""

#: in/chapter15.md:345
msgid ""
"There are a few loose ends to clean up.\n"
"First, the exponentiation function:"
msgstr ""
"Есть несколько незакрепленных концов, которые нужно исправить.\n"
"Во-первых, функция возведения в степень:"

#: in/chapter15.md:349
msgctxt "in/chapter15.md:349"
msgid ""
"```lisp\n"
"(defun poly^n (p n)\n"
"```"
msgstr ""

#: in/chapter15.md:351
msgctxt "in/chapter15.md:351"
msgid "  `\"Raise polynomial p to the nth power, n>=0.\"`"
msgstr ""

#: in/chapter15.md:353
msgctxt "in/chapter15.md:353"
msgid "  `(check-type n (integer 0 *))`"
msgstr ""

#: in/chapter15.md:355
msgctxt "in/chapter15.md:355"
msgid "  `(cond ((= n 0) (assert (not (eql p 0))) 1)`"
msgstr ""

#: in/chapter15.md:357
msgctxt "in/chapter15.md:357"
msgid "      `((integerp p) (expt p n))`"
msgstr ""

#: in/chapter15.md:359
msgctxt "in/chapter15.md:359"
msgid "      `(t (poly*poly p (poly^n p (- n 1))))))`"
msgstr ""

#: in/chapter15.md:361
msgid "## 15.2 Differentiating Polynomials"
msgstr "## 15.2 Дифференцирование Многочленов"

#: in/chapter15.md:363
msgid ""
"The differentiation routine is easy, mainly because there are only two "
"operators (+ and \\*) to deal with:"
msgstr ""
"Процедура дифференцирования проста, в основном потому, что нужно иметь дело "
"только с двумя операторами (+ и \\ *):"

#: in/chapter15.md:395
msgid ""
"```lisp\n"
"(defun deriv-poly (p x)\n"
"  \"Return the derivative, dp/dx, of the polynomial p.\"\n"
"  ;; If p is a number or a polynomial with main-var > x,\n"
"  ;; then p is free of x, and the derivative is zero;\n"
"  ;; otherwise do real work.\n"
"  ;; But first, make sure X is a simple variable,\n"
"  ;; of the form #(X 0 1).\n"
"  (assert (and (typep x 'polynomial) (= (degree x) 1)\n"
"         (eql (coef x 0) 0) (eql (coef x 1) 1)))\n"
"  (cond\n"
"    ((numberp p) 0)\n"
"    ((var> (main-var p) (main-var x)) 0)\n"
"    ((var= (main-var p) (main-var x))\n"
"     ;; d(a + bx + cx^2 + dx^3)/dx = b + 2cx + 3dx^2\n"
"     ;; So, shift the sequence p over by 1, then\n"
"     ;; put x back in, and multiply by the exponents\n"
"     (let ((r (subseq p 1)))\n"
"       (setf (main-var r) (main-var x))\n"
"       (loop for i from 1 to (degree r) do\n"
"             (setf (coef r i) (poly*poly (+ i 1) (coef r i))))\n"
"       (normalize-poly r)))\n"
"    (t ;; Otherwise some coefficient may contain x.  Ex:\n"
"     ;; d(z + 3x + 3zx^2 + z^2x^3)/dz\n"
"     ;; = 1 +  0 +  3x^2 +  2zx^3\n"
"     ;; So copy p, and differentiate the coefficients.\n"
"     (let ((r (copy-poly p)))\n"
"       (loop for i from 0 to (degree p) do\n"
"             (setf (coef r i) (deriv-poly (coef r i) x)))\n"
"       (normalize-poly r)))))\n"
"```"
msgstr ""

#: in/chapter15.md:398
msgid ""
"**Exercise  15.1 [h]** Integrating polynomials is not much harder than "
"differentiating them.\n"
"For example:"
msgstr ""
"**Упражнение 15.1 [h]** Интегрировать многочлены не намного сложнее, чем их "
"дифференцировать.\n"
"Например:"

#: in/chapter15.md:400
msgid "&int;ax2+bxdx=ax33+bx22+c."
msgstr ""

#: in/chapter15.md:402
msgid "![si2_e](images/chapter15/si2_e.gif)"
msgstr ""

#: in/chapter15.md:404
msgid ""
"Write a function to integrate polynomials and install it in `prefix->canon`."
msgstr ""
"Напишите функцию для интеграции многочленов и установите ее в `prefix-"
">canon`."

#: in/chapter15.md:409
msgid ""
"**Exercise  15.2 [m]** Add support for *definite* integrals, such as &int;"
"abydx !!!(span) {:.hiddenClass} ![si3_e](images/chapter15/si3_e.gif).\n"
"You will need to make up a suitable notation and properly install it in both "
"`infix->prefix` and `prefix->canon`.\n"
"A full implementation of this feature would have to consider infinity as a "
"bound, as well as the problem of integrating over singularises.\n"
"You need not address these problems."
msgstr ""
"**Упражнение 15.2 [m]** Добавьте поддержку *определенных* интегралов, таких "
"как &int;abydx !!!(span) {:.hiddenClass} ![si3_e](images/chapter15/si3_e."
"gif).\n"
"Вам нужно будет составить подходящую нотацию и правильно установить ее как в "
"`infix->prefix`, так и в `prefix->canon`.\n"
"Полная реализация этой функции должна рассматривать бесконечность как "
"границу, а также проблему интегрирования по сингулярностям.\n"
"Вам не нужно заниматься этими проблемами."

#: in/chapter15.md:411
msgid "## 15.3 Converting between Infix and Prefix"
msgstr "## 15.3 Преобразование между инфиксом и префиксом"

#: in/chapter15.md:415
msgid ""
"All that remains is converting from canonical form back to prefix form, and "
"from there back to infix form.\n"
"This is a good point to extend the prefix form to allow expressions with "
"more than two arguments.\n"
"First we show an updated version of `prefix->infix` that handles multiple "
"arguments:"
msgstr ""
"Остается только преобразовать каноническую форму обратно в префиксную, а "
"оттуда обратно в инфиксную.\n"
"Это хороший момент для расширения формы префикса, чтобы можно было "
"использовать выражения с более чем двумя аргументами.\n"
"Сначала мы показываем обновленную версию `prefix->infix`, которая "
"обрабатывает несколько аргументов:"

#: in/chapter15.md:425
msgid ""
"```lisp\n"
"(defun prefix->infix (exp)\n"
"  \"Translate prefix to infix expressions.\n"
"  Handles operators with any number of args.\"\n"
"  (if (atom exp)\n"
"      exp\n"
"      (intersperse\n"
"        (exp-op exp)\n"
"        (mapcar #'prefix->infix (exp-args exp)))))"
msgstr ""

#: in/chapter15.md:435
msgid ""
"(defun intersperse (op args)\n"
"  \"Place op between each element of args.\n"
"  Ex: (intersperse '+ '(a b c)) => '(a + b + c)\"\n"
"  (if (length=1 args)\n"
"      (first args)\n"
"      (rest (loop for arg in args\n"
"               collect op\n"
"               collect arg))))\n"
"```"
msgstr ""

#: in/chapter15.md:437
msgid "Now we need only convert from canonical form to prefix:"
msgstr "Теперь нам нужно только преобразовать из канонической формы в префикс:"

#: in/chapter15.md:451
msgid ""
"```lisp\n"
"(defun canon->prefix (p)\n"
"  \"Convert a canonical polynomial to a lisp expression.\"\n"
"  (if (numberp p)\n"
"      p\n"
"      (args->prefix\n"
"        '+ 0\n"
"        (loop for i from (degree p) downto 0\n"
"              collect (args->prefix\n"
"                        '* 1\n"
"                        (list (canon->prefix (coef p i))\n"
"                              (exponent->prefix\n"
"                                (main-var p) i)))))))"
msgstr ""

#: in/chapter15.md:458
msgid ""
"(defun exponent->prefix (base exponent)\n"
"  \"Convert canonical base^exponent to prefix form.\"\n"
"  (case exponent\n"
"    (0 1)\n"
"    (1 base)\n"
"    (t `(^ ,base ,exponent))))"
msgstr ""

#: in/chapter15.md:472
msgid ""
"(defun args->prefix (op identity args)\n"
"  \"Convert arg1 op arg2 op ... to prefix form.\"\n"
"  (let ((useful-args (remove identity args)))\n"
"    (cond ((null useful-args) identity)\n"
"          ((and (eq op '*) (member 0 args)) 0)\n"
"          ((length=1 args) (first useful-args))\n"
"          (t (cons op (mappend\n"
"                        #'(lambda (exp)\n"
"                            (if (starts-with exp op)\n"
"                                (exp-args exp)\n"
"                                (list exp)))\n"
"                        useful-args))))))\n"
"```"
msgstr ""

#: in/chapter15.md:474
msgid "Finally, here's a top level to make use of all this:"
msgstr "Наконец, вот верхний уровень, чтобы все это использовать:"

#: in/chapter15.md:479
msgid ""
"```lisp\n"
"(defun canon (infix-exp)\n"
"  \"Canonicalize argument and convert it back to infix\"\n"
"  (prefix->infix (canon->prefix (prefix->canon (infix->prefix infix-exp)))))"
msgstr ""

#: in/chapter15.md:486
msgid ""
"(defun canon-simplifier ()\n"
"  \"Read an expression, canonicalize it, and print the result.\"\n"
"  (loop\n"
"    (print 'canon>)\n"
"    (print (canon (read)))))\n"
"```"
msgstr ""

#: in/chapter15.md:488
msgid "and an example of it in use:"
msgstr "и пример его использования:"

#: in/chapter15.md:504
msgid ""
"```lisp\n"
"> (canon-simplifier)\n"
"CANON> (3 + x + 4 - x)\n"
"7\n"
"CANON> (x + y + y + x)\n"
"((2 * X) + (2 * Y))\n"
"CANON> (3 * x + 4 * x)\n"
"(7 * X)\n"
"CANON> (3 * x + y + x + 4 * x)\n"
"((8 * X) + Y)\n"
"CANON> (3 * x + y + z + x + 4 * x)\n"
"((8 * X) + (Y + Z))\n"
"CANON> ((x + 1) ^ 10)\n"
"((X ^ 10) + (10 * (X ^ 9)) + (45 * (X ^ 8)) + (120 * (X ^ 7))\n"
"```"
msgstr ""

#: in/chapter15.md:506
msgid "  `+ (210 * (X ^ 6)) + (252 * (X ^ 5)) + (210 * (X ^ 4))`"
msgstr ""

#: in/chapter15.md:508
msgid "  `+ (120 * (X ^ 3)) + (45 * (X ^ 2)) + (10 * X) + 1)`"
msgstr ""

#: in/chapter15.md:513
msgid ""
"```lisp\n"
"CANON> ((x + 1) ^ 10 + (x - 1) ^ 10)\n"
"((2 * (X ^ 10)) + (90 * (X ^ 8)) + (420 * (X ^ 6))\n"
"```"
msgstr ""

#: in/chapter15.md:515
msgid "  `+ (420 * (X ^ 4)) + (90 * (X ^ 2)) + 2)`"
msgstr ""

#: in/chapter15.md:520
msgid ""
"```lisp\n"
"CANON> ((x + 1) ^ 10 - (x - 1) ^ 10)\n"
"((20 * (X ^ 8)) + (240 * (X ^ 7)) + (504 * (X ^ 5))\n"
"```"
msgstr ""

#: in/chapter15.md:522
msgid "  `+ (240 * (X ^ 3)) + (20 * X))`"
msgstr ""

#: in/chapter15.md:534
msgid ""
"```lisp\n"
"CANON> (3 * x ^ 3 + 4 * x * y * (x - 1) + x ^ 2 * (x + y))\n"
"((4 * (X ^ 3)) + ((5 * Y) * (X ^ 2)) + ((-4 * Y) * X))\n"
"CANON> (3 * x ^ 3 + 4 * x * w * (x - 1) + x ^ 2 * (x + w))\n"
"((((5 * (X ^ 2)) + (-4 * X)) * W) + (4 * (X ^ 3)))\n"
"CANON> (d (3 * x ^ 2 + 2 * x + 1) / d x)\n"
"((6 * X) + 2)\n"
"CANON> (d(z + 3 * x + 3 * z * x ^ 2 + z ^ 2 * x ^ 3) / d z)\n"
"(((2 * Z) * (X ^ 3)) + (3 * (X ^ 2)) + 1)\n"
"CANON> [Abort]\n"
"```"
msgstr ""

#: in/chapter15.md:536
msgid "## 15.4 Benchmarking the Polynomial Simplifier"
msgstr "## 15.4 Сравнительный анализ упрощения многочленов/полиномов"

#: in/chapter15.md:545
msgid ""
"Unlike the rule-based program, this version gets all the answers right.\n"
"Not only is the program correct (at least as far as these examples go), it "
"is also fast.\n"
"We can compare it to the canonical simplifier originally written for MACSYMA "
"by William Martin (circa 1968), and modified by Richard Fateman.\n"
"The modified version was used by Richard Gabriel in his suite of Common Lisp "
"benchmarks (1985).\n"
"The benchmark program is called `frpoly`, because it deals with polynomials "
"and was originally written in the dialect Franz Lisp.\n"
"The `frpoly` benchmark encodes polynomials as lists rather than vectors, and "
"goes to great lengths to be efficient.\n"
"Otherwise, it is similar to the algorithms used here (although the code "
"itself is quite different, using progs and gos and other features that have "
"fallen into disfavor in the intervening decades).\n"
"The particular benchmark we will use here is raising 1 ***+** x + y + z* to "
"the 15th power:"
msgstr ""
"В отличие от программы, основанной на правилах, эта версия дает правильные "
"ответы на все вопросы.\n"
"Программа не только правильная (по крайней мере, в этих примерах), она еще и "
"быстрая.\n"
"Мы можем сравнить его с каноническим упрощением, первоначально написанным "
"для MACSYMA Уильямом Мартином (около 1968 г.) и модифицированным Ричардом "
"Фейтманом.\n"
"Модифицированная версия была использована Ричардом Габриэлем в его наборе "
"тестов Common Lisp (1985).\n"
"Программа тестирования называется `frpoly`, потому что она имеет дело с "
"полиномами и изначально была написана на диалекте Franz Lisp.\n"
"Тест `frpoly` кодирует многочлены в виде списков, а не векторов, и делает "
"все возможное, чтобы быть эффективной.\n"
"В остальном она похожа на используемые здесь алгоритмы (хотя сам код "
"совершенно другой, в нем используются progs и gos и другие функциональности, "
"которые пришли в немилость за прошедшие десятилетия).\n"
"Конкретный тест, который мы будем использовать здесь, возводит 1 ***+** x + "
"y + z* в 15-ю степень:"

#: in/chapter15.md:549
msgid ""
"```lisp\n"
"(defun r15-test ()\n"
"```"
msgstr ""

#: in/chapter15.md:551
msgid "  `(let ((r (prefix->canon'(+ 1 (+ x (+ y z))))))`"
msgstr ""

#: in/chapter15.md:553
msgid "    `(time (poly^n r 15))`"
msgstr ""

#: in/chapter15.md:555
msgid "    `nil))`"
msgstr ""

#: in/chapter15.md:560
msgid ""
"This takes .97 seconds on our system.\n"
"The equivalent test with the original `frpoly` code takes about the same "
"time: .98 seconds.\n"
"Thus, our program is as fast as production-quality code.\n"
"In terms of storage space, vectors use about half as much storage as lists, "
"because half of each cons cell is a pointer, while vectors are all useful "
"data.[2](#fn0020)"
msgstr ""
"В нашей системе это занимает 0,97 секунды.\n"
"Эквивалентный тест с исходным кодом `frpoly` занимает примерно такое же "
"время: 0,98 секунды.\n"
"Таким образом, наша программа работает так же быстро, как и код "
"производственного качества.\n"
"Что касается места для хранения, векторы используют примерно половину "
"памяти, чем списки, потому что половина каждой cons-ячейки является "
"указателем, а все векторы - это полезные данные. [2](#fn0020)"

#: in/chapter15.md:568
msgid ""
"How much faster is the polynomial-based code than the rule-based version?\n"
"Unfortunately, we can't answer that question directly.\n"
"We can time `(simp ' ( (1 + x + y + z) ^ 15)))`.\n"
"This takes only a tenth of a second, but that is because it is doing no work "
"at all-the answer is the same as the input!\n"
"Alternately, we can take the expression computed by `(poly^n r 15)`, convert "
"it to prefix, and pass that `to simplify.\n"
"simplify` takes 27.8 seconds on this, so the rule-based version is much "
"slower.\n"
"[Section 9.6](B9780080571157500091.xhtml#s0035) describes ways to speed up "
"the rule-based program, and a comparison of timing data appears on [page 525]"
"(#p525)."
msgstr ""
"Насколько быстрее код на основе полиномов, чем версия на основе правил?\n"
"К сожалению, мы не можем ответить на этот вопрос напрямую.\n"
"Мы можем время `(simp ' ( (1 + x + y + z) ^ 15)))`.\n"
"Это занимает всего десятую долю секунды, но это потому, что он не выполняет "
"никакой работы - ответ такой же, как и ввод!\n"
"В качестве альтернативы, мы можем взять выражение, вычисленное с помощью "
"`(poly^n r 15)`, преобразовать его в префикс и передать это `для упрощения.\n"
"Упрощение занимает 27,8 секунды, поэтому версия на основе правил работает "
"намного медленнее.\n"
"[Раздел 9.6](B9780080571157500091.xhtml#s0035) описывает способы ускорения "
"программы, основанной на правилах, а сравнение данных времени появляется на "
"[страница 525](#p525)."

#: in/chapter15.md:573
msgid ""
"There are always surprises when it comes down to measuring timing data.\n"
"For example, the alert reader may have noticed that the version of `poly^n` "
"defined above requires *n* multiplications.\n"
"Usually, exponentiation is done by squaring a value when the exponent is "
"even.\n"
"Such an algorithm takes only log *n* multiplications instead of *n.* We can "
"add a line to the definition of `poly^n` to get an *O*(log *n*) algorithm:"
msgstr ""
"Когда дело доходит до измерения временных данных, всегда есть сюрпризы.\n"
"Например, читатель предупреждений мог заметить, что версия `poly^n`, "
"определенная выше, требует умножений на *n*.\n"
"Обычно возведение в степень выполняется возведением в квадрат значения, "
"когда показатель степени четный.\n"
"Такой алгоритм использует только log *n* умножений вместо *n.* Мы можем "
"добавить строку к определению `poly^n`, чтобы получить алгоритм *O*(log *n*):"

#: in/chapter15.md:577
msgctxt "in/chapter15.md:577"
msgid ""
"```lisp\n"
"(defun poly^n (p n)\n"
"```"
msgstr ""

#: in/chapter15.md:579
msgctxt "in/chapter15.md:579"
msgid "  `\"Raise polynomial p to the nth power, n>=0.\"`"
msgstr ""

#: in/chapter15.md:581
msgctxt "in/chapter15.md:581"
msgid "  `(check-type n (integer 0 *))`"
msgstr ""

#: in/chapter15.md:583
msgctxt "in/chapter15.md:583"
msgid "  `(cond ((= n 0) (assert (not (eql p 0))) 1)`"
msgstr ""

#: in/chapter15.md:585
msgctxt "in/chapter15.md:585"
msgid "      `((integerp p) (expt p n))`"
msgstr ""

#: in/chapter15.md:587
msgid "      `((evenp n) (poly^2 (poly^n p (/ n 2)))) ;***`"
msgstr ""

#: in/chapter15.md:589
msgctxt "in/chapter15.md:589"
msgid "      `(t (poly*poly p (poly^n p (- n 1))))))`"
msgstr ""

#: in/chapter15.md:593
msgid ""
"```lisp\n"
"(defun poly^2 (p) (poly*poly p p))\n"
"```"
msgstr ""

#: in/chapter15.md:597
msgid ""
"The surprise is that this takes *longer* to raise `*r*` to the 15th power.\n"
"Even though it does fewer `poly*poly` operations, it is doing them on more "
"complex arguments, and there is more work altogether.\n"
"If we use this version of `poly^n,` then `r15-test` takes 1.6 seconds "
"instead of .98 seconds."
msgstr ""
"Сюрприз в том, что возведение `*r*` в 15-ю степень занимает *больше* "
"времени.\n"
"Несмотря на то, что он выполняет меньше операций `poly*poly`, он выполняет "
"их с более сложными аргументами, и в целом работы требуется больше.\n"
"Если мы используем эту версию `poly^n`, то `r15-test` занимает 1,6 секунды "
"вместо 0,98 секунды. "

#: in/chapter15.md:604
msgid ""
"By the way, this is a perfect example of the conceptual power of recursive "
"functions.\n"
"We took an existing function, poly^n, added a single cond clause, and "
"changed it from an *O*(*n*) to *O*(log *n*) algorithm.\n"
"(This turned out to be a bad idea, but that's beside the point.\n"
"It would be a good idea for raising integers to powers.) The reasoning that "
"allows the change is simple: First, *pn* is certainly equal to (*p**n*/2)2 "
"when *n* is even, so the change can't introduce any wrong answers.\n"
"Second, the change continues the policy of decrementing *n* on every "
"recursive call, so the function must eventually termina te (when *n =* 0).\n"
"If it gives no wrong answers, and it terminates, then it must give the right "
"answer."
msgstr ""
"Кстати, это прекрасный пример концептуальной мощи рекурсивных функций.\n"
"Мы взяли существующую функцию poly^n, добавили одно предложение cond и "
"изменили алгоритм с *O*(*n*) на *O*(log *n*).\n"
"(Это оказалось плохой идеей, но это не относится к делу.\n"
"Было бы неплохо возводить целые числа в степени.) Рассуждения, позволяющие "
"сделать это изменение, просты: во-первых, * pn * определенно равно "
"(*p**n*/2)2, когда *n* четно, поэтому изменение не может привести к "
"неправильным ответам.\n"
"Во-вторых, изменение продолжает политику уменьшения *n* при каждом "
"рекурсивном вызове, поэтому функция должна в конечном итоге завершиться "
"(когда *n =* 0).\n"
"Если она не дает неправильных ответов и завершается, значит, она должна дать "
"правильный ответ."

#: in/chapter15.md:607
msgid ""
"In contrast, making the change for an iterative algorithm is more complex.\n"
"The initial algorithm is simple:"
msgstr ""
"Напротив, внести изменения в итерационный алгоритм более сложно.\n"
"Первоначальный алгоритм прост:"

#: in/chapter15.md:611
msgctxt "in/chapter15.md:611"
msgid ""
"```lisp\n"
"(defun poly^n (p n)\n"
"```"
msgstr ""

#: in/chapter15.md:613
msgctxt "in/chapter15.md:613"
msgid "  `(let ((result 1))`"
msgstr ""

#: in/chapter15.md:615
msgid "    `(loop repeat n do (setf result (poly*poly p result)))`"
msgstr ""

#: in/chapter15.md:617
msgctxt "in/chapter15.md:617"
msgid "    `result))`"
msgstr ""

#: in/chapter15.md:619
msgid ""
"But to change it, we have to change the repeat loop to a `while` loop, "
"explicitly put in the decrement of *n*, and insert a test for the even case:"
msgstr ""
"Но чтобы изменить его, мы должны изменить цикл повторения на цикл `while`, "
"явно указать декремент *n* и вставить тест для четного случая: "

#: in/chapter15.md:623
msgctxt "in/chapter15.md:623"
msgid ""
"```lisp\n"
"(defun poly^n (p n)\n"
"```"
msgstr ""

#: in/chapter15.md:625
msgctxt "in/chapter15.md:625"
msgid "  `(let ((result 1))`"
msgstr ""

#: in/chapter15.md:627
msgid "    `(loop while (> n 0)`"
msgstr ""

#: in/chapter15.md:629
msgid "      `do (if (evenp n)`"
msgstr ""

#: in/chapter15.md:631
msgid "          `(setf p (poly^2 p)`"
msgstr ""

#: in/chapter15.md:633
msgid "              `n (/ n 2))`"
msgstr ""

#: in/chapter15.md:635
msgid "          `(setf result (poly*poly p result)`"
msgstr ""

#: in/chapter15.md:637
msgid "              `n (- n 1))))`"
msgstr ""

#: in/chapter15.md:639
msgctxt "in/chapter15.md:639"
msgid "    `result))`"
msgstr ""

#: in/chapter15.md:641
msgid ""
"For this problem, it is clear that thinking recursively leads to a simpler "
"function that is easier to modify."
msgstr ""
"Для этой проблемы ясно, что рекурсивное мышление приводит к более простой "
"функции, которую легче изменить. "

#: in/chapter15.md:651
msgid ""
"It turns out that this is not the final word.\n"
"Exponentiation of polynomials can be done even faster, with a little more "
"mathematical sophistication.\n"
"[Richard Fateman's 1974](B9780080571157500285.xhtml#bb0380) paper on "
"Polynomial Multiplication analyzes the complexity of a variety of "
"exponentiation algorithms.\n"
"Instead of the usual asymptotic analysis (e.g.\n"
"*O*(*n*) or *O*(*n*2)), he uses a fine-grained analysis that computes the "
"constant factors (e.g.\n"
"1000 x *n* or 2 x *n*2).\n"
"Such analysis is crucial for small values of *n*.\n"
"It turns out that for a variety of polynomials, an exponentiation algorithm "
"based on the binomial theorem is best.\n"
"The binomial theorem states that"
msgstr ""
"Оказывается, это не последнее слово.\n"
"Возведение в степень многочленов может быть выполнено еще быстрее, с немного "
"большей математической сложностью.\n"
"[Ричард Фейтман, 1974](B9780080571157500285.xhtml#bb0380) статья о "
"полиномиальном умножении анализирует сложность множества алгоритмов "
"возведения в степень.\n"
"Вместо обычного асимптотического анализа (например,\n"
"*O*(*n*) or *O*(*n*2)), он использует детальный анализ, который вычисляет "
"постоянные коэффициенты (например,\n"
"1000 x *n* or 2 x *n*2).\n"
"Такой анализ важен для малых значений *n*.\n"
"Оказывается, что для множества многочленов лучше всего подходит алгоритм "
"возведения в степень, основанный на биномиальной теореме.\n"
"Биномиальная теорема утверждает, что"

#: in/chapter15.md:653
msgid "a+bn=&Sigma;i=0nn!i!n-i!aibn-i"
msgstr ""

#: in/chapter15.md:655
msgid "![si4_e](images/chapter15/si4_e.gif)"
msgstr ""

#: in/chapter15.md:657
msgid "for example,"
msgstr "например,"

#: in/chapter15.md:659
msgid "a+b3=b3+3ab2+3a2b+a3"
msgstr ""

#: in/chapter15.md:661
msgid "![si5_e](images/chapter15/si5_e.gif)"
msgstr ""

#: in/chapter15.md:667
msgid ""
"We can use this theorem to compute a power of a polynomial all at once, "
"instead of computing it by repeated multiplication or squaring.\n"
"Of course, a polynomial will in general be a sum of more than two "
"components, so we have to decid`e` how to split it into the *a* and *b* "
"pieces.\n"
"There are two obvious ways: either eut the polynomial in half, so that *a* "
"and *b* will be of equal size, or split off one component at a time.\n"
"Fateman shows that the latter method is more efficient in most cases.\n"
"In other words, a polynomial k1xn+k2xn-1+k3xn-2+... !!!(span) {:."
"hiddenClass} ![si6_e](images/chapter15/si6_e.gif) will be treated as the sum "
"*a + b* where *a*=  *k*1*xn* and *b* is the rest of the polynomial."
msgstr ""
"Мы можем использовать эту теорему, чтобы вычислить степень многочлена сразу, "
"вместо того, чтобы вычислять ее многократным умножением или возведением в "
"квадрат.\n"
"Конечно, многочлен, как правило, представляет собой сумму более чем двух "
"компонентов, поэтому мы должны решить, как разбить его на части *a* и *b*.\n"
"Есть два очевидных способа: либо разделить многочлен пополам, чтобы *a* и "
"*b* были одинакового размера, либо разделить по одному компоненту за раз.\n"
"Фейтман показывает, что последний метод в большинстве случаев более "
"эффективен.\n"
"Другими словами, полином k1xn+k2xn-1+k3xn-2+... !!!(span) {:.hiddenClass} !"
"[si6_e](images/chapter15/si6_e.gif) будет рассматриваться как сумма   *a*=  "
"*k*1*xn* и *b* - остальная часть многочлена."

#: in/chapter15.md:671
msgid ""
"Following is the code for binomial exponentiation.\n"
"It is somewhat messy, because the emphasis is on efficiency.\n"
"This means reusing some data and using `p-add-into!` instead of the more "
"general `poly+poly`."
msgstr ""
"Ниже приведен код для биномиального возведения в степень.\n"
"Он несколько беспорядочен, потому что упор делается на эффективность.\n"
"Это означает повторное использование некоторых данных и использование `p-add-"
"into!` Вместо более общего `poly+poly`."

#: in/chapter15.md:705
msgid ""
"```lisp\n"
"(defun poly^n (p n)\n"
"  \"Raise polynomial p to the nth power, n>=0.\"\n"
"  ;; Uses the binomial theorem\n"
"  (check-type n (integer 0 *))\n"
"  (cond\n"
"    ((= n 0) 1)\n"
"    ((integerp p) (expt p n))\n"
"    (t ;; First: split the polynomial p = a + b, where\n"
"     ;; a = k*x^d and b is the rest of p\n"
"     (let ((a (make-poly (main-var p) (degree p)))\n"
"           (b (normalize-poly (subseq p 0 (- (length p) 1))))\n"
"           ;; Allocate arrays of powers of a and b:\n"
"           (a^n (make-array (+ n 1)))\n"
"           (b^n (make-array (+ n 1)))\n"
"           ;; Initialize the result:\n"
"           (result (make-poly (main-var p) (* (degree p) n))))\n"
"       (setf (coef a (degree p)) (coef p (degree p)))\n"
"       ;; Second: Compute powers of a^i and b^i for i up to n\n"
"       (setf (aref a^n 0) 1)\n"
"       (setf (aref b^n 0) 1)\n"
"       (loop for i from 1 to n do\n"
"             (setf (aref a^n i) (poly*poly a (aref a^n (- i 1))))\n"
"             (setf (aref b^n i) (poly*poly b (aref b^n (- i 1)))))\n"
"       ;; Third: add the products into the result,\n"
"       ;; so that result[i] = (n choose i) * a^i * b^(n-i)\n"
"       (let ((c 1)) ;; c helps compute (n choose i) incrementally\n"
"         (loop for i from 0 to n do\n"
"               (p-add-into! result c\n"
"                            (poly*poly (aref a^n i)\n"
"                                 (aref b^n (- n i))))\n"
"               (setf c (/ (* c (- n i)) (+ i 1)))))\n"
"       (normalize-poly result)))))"
msgstr ""

#: in/chapter15.md:717
msgid ""
"(defun p-add-into! (result c p)\n"
"  \"Destructively add c*p into result.\"\n"
"  (if (or (numberp p)\n"
"          (not (var= (main-var p) (main-var result))))\n"
"      (setf (coef result 0)\n"
"            (poly+poly (coef result 0) (poly*poly c p)))\n"
"      (loop for i from 0 to (degree p) do\n"
"            (setf (coef result i)\n"
"                  (poly+poly (coef result i) (poly*poly c (coef p i))))))\n"
"  result)\n"
"```"
msgstr ""

#: in/chapter15.md:720
msgid ""
"Using this version of `poly^n, r15-test` takes only .23 seconds, four times "
"faster than the previous version.\n"
"The following table compares the times for `r15-test` with the three "
"versions of `poly^n`, along with the times for applying `simply` to the "
"`r15` polynomial, for various versions of `simplify`:"
msgstr ""
"Использование этой версии `poly^n, r15-test` занимает всего 0,23 секунды, "
"что в четыре раза быстрее, чем в предыдущей версии.\n"
"В следующей таблице сравнивается время для `r15-test` с тремя версиями "
"`poly^n`, а также время для применения `simply` к полиному `r15` для "
"различных версий `simplify`:"

#: in/chapter15.md:734
msgid ""
"|      | program                 | secs | speed-up |\n"
"|------|-------------------------|------|----------|\n"
"|      | **rule-based versions** |      |          |\n"
"| 1    | original                | 27.8 | -        |\n"
"| 2    | memoization             | 7.7  | 4        |\n"
"| 3    | memo+index              | 4.0  | 7        |\n"
"| 4    | compilation only        | 2.5  | 11       |\n"
"| 5    | memo+compilation        | 1.9  | 15       |\n"
"|      | **canonical versions**  |      |          |\n"
"| 6    | squaring `poly^n`       | 1.6  | 17       |\n"
"| 7    | iterative `poly^n`      | .98  | 28       |\n"
"| 8    | binomial `poly^n`       | .23  | 120      |"
msgstr ""

#: in/chapter15.md:738
msgid ""
"As we remarked earlier, the general techniques of memoization, indexing, and "
"compilation provide for dramatic speed-ups.\n"
"However, in the end, they do not lead to the fastest program.\n"
"Instead, the fastest version was achieved by throwing out the original rule-"
"based program, replacing it with a canonical-form-based program, and fine-"
"tuning the algorithms within that program, using mathematical analysis."
msgstr ""
"Как мы уже отмечали ранее, общие методы (memoization)запоминания, индексации "
"и компиляции значительно ускоряют работу.\n"
"Однако в конечном итоге они не приводят к самой быстрой программе.\n"
"Вместо этого самая быстрая версия была достигнута за счет отказа от исходной "
"программы, основанной на правилах, замены ее программой, основанной на "
"канонической форме, и тонкой настройки алгоритмов в этой программе с "
"использованием математического анализа."

#: in/chapter15.md:740
msgid ""
"Now that we have achieved a sufficiently fast system, the next two sections "
"concentrate on making it more powerful."
msgstr ""
"Теперь, когда мы создали достаточно быструю систему, в следующих двух "
"разделах мы сосредоточимся на том, чтобы сделать ее более мощной."

#: in/chapter15.md:742
msgid "## 15.5 A Canonical Form for Rational Expressions"
msgstr "## 15.5 Каноническая форма рациональных выражений"

#: in/chapter15.md:746
msgid ""
"A *rational* number is defined as a fraction: the quotient of two integers.\n"
"A *rational expression* is hereby defined as the quotient of two "
"polynomials.\n"
"This section presents a canonical form for rational expressions."
msgstr ""
"*Рациональное* число определяется как дробь: частное двух целых чисел.\n"
"*Рациональное выражение* определяется как отношение двух многочленов.\n"
"В этом разделе представлена каноническая форма рациональных выражений."

#: in/chapter15.md:751
msgid ""
"First, a number or polynomial will continue to be represented as before.\n"
"The quotient of two polynomials will be represented as a cons cells of "
"numerator and denominator pairs.\n"
"However, just as Lisp automatically reduces rational numbers to simplest "
"form (6/8 is represented as 3/4), we must reduce rational expressions.\n"
"So, for example, (*x*2- 1)/(*x*- 1) must be reduced to *x* + 1, not left as "
"a quotient of two polynomials."
msgstr ""
"Во-первых, число или многочлен будет по-прежнему представляться, как и "
"раньше.\n"
"Частное двух многочленов(полиномов) будет представлено как cons-ячейки пар - "
"числитель и знаменатель.\n"
"Однако так же, как Lisp автоматически приводит рациональные числа к "
"простейшей форме (6/8 представлено как 3/4), мы должны сокращать "
"рациональные выражения.\n"
"Так, например, (*x*2- 1)/(*x*- 1) нужно сократить до *x* + 1, а не оставить "
"как частное двух многочленов."

#: in/chapter15.md:754
msgid ""
"The following functions build and access rational expressions but do not "
"reduce to simplest form, except in the case where the denominator is a "
"number.\n"
"Building up the rest of the functionality for full rational expressions is "
"left to a series of exercises:"
msgstr ""
"Следующие функции создают рациональные выражения и обращаются к ним, но не "
"сводятся к простейшей форме, за исключением случая, когда знаменателем "
"является число.\n"
"Создание остальной функциональности для полноценного рационального выражения "
"остается за серией упражнений:"

#: in/chapter15.md:761
msgid ""
"```lisp\n"
"(defun make-rat (numerator denominator)\n"
"  \"Build a rational: a quotient of two polynomials.\"\n"
"  (if (numberp denominator)\n"
"      (k*poly (/ 1 denominator) numerator)\n"
"      (cons numerator denominator)))"
msgstr ""

#: in/chapter15.md:768
msgid ""
"(defun rat-numerator (rat)\n"
"  \"The numerator of a rational expression.\"\n"
"  (typecase rat\n"
"    (cons (car rat))\n"
"    (number (numerator rat))\n"
"    (t rat)))"
msgstr ""

#: in/chapter15.md:776
msgid ""
"(defun rat-denominator (rat)\n"
"  \"The denominator of a rational expression.\"\n"
"  (typecase rat\n"
"    (cons (cdr rat))\n"
"    (number (denominator rat))\n"
"    (t 1)))\n"
"```"
msgstr ""

#: in/chapter15.md:779
msgid ""
"**Exercise  15.3 [s]** Modify `prefix->canon` to accept input of the form "
"`x / y` and to return rational expressions instead of polynomials.\n"
"Also allow for input of the form `x ^ - n`."
msgstr ""
"**Упражнение 15.3 [s ** Измените `prefix-> canon`, чтобы принимать входные "
"данные в форме `x / y` и возвращать рациональные выражения вместо "
"многочленов.\n"
"Также разрешите ввод формы `x ^ - n`."

#: in/chapter15.md:784
msgid ""
"**Exercise  15.4 [m]** Add arithmetic routines for multiplication, addition, "
"and division of rational expressions.\n"
"Call them `rat*rat, rat+rat`, and `rat/rat` respectively.\n"
"They will call upon `poly*poly.\n"
"poly+poly` and a new function, `poly/poly`, which is defined in the next "
"exercise."
msgstr ""
"**Exercise 15.4 [m]** Добавьте арифметические процедуры для умножения, "
"сложения и деления рациональных выражений.\n"
"Назовите их `rat*rat, rat+rat`, и `rat/rat` соответственно.\n"
"Они будут вызывать `poly*poly.\n"
"poly+poly` и новую функцию `poly/poly`, которая определена в следующем "
"упражнении."

#: in/chapter15.md:786
msgid ""
"**Exercise  15.5 [h]** Define `poly-gcd`, which computes the greatest common "
"divisor of two polynomials."
msgstr ""
"**Упражнение 15.5 [h]** Определите `poly-gcd`, которая вычисляет наибольший "
"общий делитель двух многочленов."

#: in/chapter15.md:790
msgid ""
"**Exercise  15.6 [h]** Using `poly-gcd`, define the function `poly/poly`, "
"which will implement division for polynomials.\n"
"Polynomials are closed under addition and multiplication, so `poly+poly` and "
"`poly*poly` both returned polynomials.\n"
"Polynomials are not closed under division, so `poly/poly` will return a "
"rational expression."
msgstr ""
"**Упражнение 15.6 [h]** Используя `poly-gcd`, определите функцию `poly/"
"poly`, которая будет реализовывать деление для многочленов.\n"
"Многочлены замкныты для сложения и умножения, поэтому обе возвращают "
"многочлены `poly+poly` и `poly*poly`.\n"
"Многочлены не замкнуты для деления, поэтому `poly/poly` вернет рациональное "
"выражение."

#: in/chapter15.md:792
msgid "## 15.6 Extending Rational Expressions"
msgstr "## 15.6 Расширение рациональных выражений"

#: in/chapter15.md:796
msgid ""
"Now that we can divide polynomials, the final step is to reinstate the "
"logarithmic, exponential, and trigonometrie functions.\n"
"The problem is that if we allow all these functions, we get into problems "
"with canonical form again.\n"
"For example, the following three expressions are all equivalent  :"
msgstr ""
"Теперь, когда мы можем делить многочлены, последний шаг - восстановить "
"логарифмическую, экспоненциальную и тригонометрическую функции.\n"
"Проблема в том, что если мы разрешим все эти функции, мы снова столкнемся с "
"проблемами канонической формы.\n"
"Например, следующие три выражения эквивалентны:"

#: in/chapter15.md:798
msgid "sinxcosx-&pi;2eix-e-ix2i"
msgstr ""

#: in/chapter15.md:800
msgid "![si7_e](images/chapter15/si7_e.gif)"
msgstr ""

#: in/chapter15.md:805
msgid ""
"If we are interested in assuring we have a canonical form, the safest thing "
"is to allow only *e**x*** and log(*x*).\n"
"All the other functions can be defined in terms of these two.\n"
"With this extension, the set of expressions we can form is closed under "
"differentiation, and it is possible to canonicalize expressions.\n"
"The `result` is a mathematically sound construction known as a "
"*differentiable field.* This is precisely the construct that is assumed by "
"the Risch integration algorithm ([Risch 1969](B9780080571157500285."
"xhtml#bb0985),[1979](B9780080571157500285.xhtml#bb0990))."
msgstr ""
"Если нас интересует каноническая форма, безопаснее всего разрешить только "
"*e**x*** и log(*x*).\n"
"Все остальные функции могут быть определены в терминах этих двух.\n"
"С помощью этого расширения набор выражений, которые мы можем формировать "
"замыкание при дифференцировании, и можно канонизировать выражения.\n"
"`result` - это математически обоснованная конструкция, известная как "
"*дифференцируемое поле.* Это именно та конструкция, которую предполагает "
"алгоритм интегрирования Риша ([Risch 1969](B9780080571157500285."
"xhtml#bb0985), [1979](B9780080571157500285.xhtml)#bb0990))."

#: in/chapter15.md:812
msgid ""
"The disadvantage of this minimal extension is that answers may be expressed "
"in unfamiliar terms.\n"
"The user asks for *d* sin(*x2*)*/dx,* expecting a simple answer in terms of "
"cos, and is surprised to see a complex answer involving *eix*.\n"
"Because of this problem, most computer algebra systems have made more "
"radical extensions, allowing sin, cos, and other functions.\n"
"These systems are treading on thin mathematical ice.\n"
"Algorithms that would be guaranteed to work over a simple differentiable "
"field may fail when the domain is extended this way.\n"
"In general, the result will not be a wrong answer but rather the failure to "
"find an answer at all."
msgstr ""
"Недостатком этого минимального расширения является то, что ответы могут быть "
"выражены незнакомыми терминами.\n"
"Пользователь спрашивает *d* sin(*x2*)*/dx,* ожидая простого ответа в "
"терминах cos, и с удивлением видит сложный ответ, включающий *eix*.\n"
"Из-за этой проблемы большинство систем компьютерной алгебры сделали более "
"радикальные расширения, допустив sin, cos и другие функции.\n"
"Эти системы ступают по тонкому математическому льду.\n"
"Алгоритмы, которые гарантированно работают с простым дифференцируемым полем, "
"могут дать сбой при таком расширении области.\n"
"В общем, результатом будет не неправильный ответ, а скорее невозможность "
"найти ответ вообще."

#: in/chapter15.md:814
msgid "## 15.7 History and References"
msgstr "## 15.7 История и ссылки"

#: in/chapter15.md:819
msgid ""
"A brief history of symbolic algebra systems is given in [chapter 8]"
"(B978008057115750008X.xhtml).\n"
"[Fateman (1979)](B9780080571157500285.xhtml#bb0385), [Martin and Fateman "
"(1971)](B9780080571157500285.xhtml#bb0775), and [Davenport et al.\n"
"(1988)](B9780080571157500285.xhtml#bb0270) give more details on the MACSYMA "
"system, on which this chapter is loosely based.\n"
"[Fateman (1991)](B9780080571157500285.xhtml#bb0390) discusses the `frpoly` "
"benchmark and introduces the vector implementation used in this chapter."
msgstr ""

#: in/chapter15.md:821
msgid "## 15.8 Exercises"
msgstr ""

#: in/chapter15.md:823
msgid ""
"**Exercise 15.7 [h]** Implement an extension of the rationals to include "
"logarithmic, exponential, and trigonometrie functions."
msgstr ""

#: in/chapter15.md:825
msgid ""
"**Exercise 15.8 [m]** Modify `deriv` to handle the extended rational "
"expressions."
msgstr ""

#: in/chapter15.md:829
msgid ""
"**Exercise 15.9 [d]** Adapt the integration routine from [section 8.6]"
"(B9780080571157500078.xhtml#s0035) ([page 252](B978008057115750008X."
"xhtml#p252)) to the rational expression representation.\n"
"[Davenport et al.\n"
"1988](B9780080571157500285.xhtml#bb0270) may be useful."
msgstr ""

#: in/chapter15.md:831
msgid ""
"**Exercise 15.10 [s]** Give several reasons why constant polynomials, like "
"3, are represented as integers rather than as vectors."
msgstr ""

#: in/chapter15.md:833
msgid "## 15.9 Answers"
msgstr "## 15.9 Ответы"

#: in/chapter15.md:835
msgid "**Answer 15.4**"
msgstr ""

#: in/chapter15.md:843
msgid ""
"```lisp\n"
"(defun rat*rat (x y)\n"
"  \"Multiply rationals: a/b * c/d = a*c/b*d\"\n"
"  (poly/poly (poly*poly (rat-numerator x)\n"
"                        (rat-numerator y))\n"
"             (poly*poly (rat-denominator x)\n"
"                        (rat-denominator y))))"
msgstr ""

#: in/chapter15.md:853
msgid ""
"(defun rat+rat (x y)\n"
"  \"Add rationals: a/b + c/d = (a*d + c*b)/b*d\"\n"
"  ;; Bug fix by dst 4/6/92; b and c were switched\n"
"  (let ((a (rat-numerator x))\n"
"        (b (rat-denominator x))\n"
"        (c (rat-numerator y))\n"
"        (d (rat-denominator y)))\n"
"    (poly/poly (poly+poly (poly*poly a d) (poly*poly c b))\n"
"               (poly*poly b d))))"
msgstr ""

#: in/chapter15.md:858
msgid ""
"(defun rat/rat (x y)\n"
"  \"Divide rationals: a/b / c/d = a*d/b*c\"\n"
"  (rat*rat x (make-rat (rat-denominator y) (rat-numerator y))))\n"
"```"
msgstr ""

#: in/chapter15.md:860
msgid "**Answer 15.6**"
msgstr ""

#: in/chapter15.md:864
msgid ""
"```lisp\n"
"(defun poly/poly (p q)\n"
"```"
msgstr ""

#: in/chapter15.md:866
msgid "  `\"Divide p by q: if d is the greatest common divisor of p and q`"
msgstr ""

#: in/chapter15.md:870
msgid ""
"  `then p/q = (p/d) / (q/d).\n"
"Note if q-1.\n"
"then p/q = p.\"`"
msgstr ""

#: in/chapter15.md:872
msgid "  `(if (eql q 1)`"
msgstr ""

#: in/chapter15.md:874
msgid "      `p`"
msgstr ""

#: in/chapter15.md:876
msgid "      `(let ((d (poly-gcd p q)))`"
msgstr ""

#: in/chapter15.md:878
msgid "        `(make-rat (poly/poly p d)`"
msgstr ""

#: in/chapter15.md:880
msgid "                `(poly/poly q d)))))`"
msgstr ""

#: in/chapter15.md:884
msgid ""
"**Answer 15.10** (1) An integer takes less time and space to process.\n"
"(2) Representing numbers as a polynomial would cause an infinit`e` regress, "
"because the coefficients would be numbers.\n"
"(3) Unless a policy was decided upon, the representation would not be "
"canonical, since `#(x 3)` and `#(y 3)` both represent 3."
msgstr ""

#: in/chapter15.md:886
msgid "----------------------"
msgstr ""

#: in/chapter15.md:890
msgid ""
"[1](#xfn0015) In fact, the algebraic properties of polynomial arithmetic and "
"its generalizations fit so well with ideas in data abstraction that an "
"extended example (in Scheme) on this topic is provided in *Structure and "
"Interpretation of Computer Programs* by Abelson and Sussman (see section "
"2.4.3, [pages 153](B9780080571157500054.xhtml#p153)-[166]"
"(B9780080571157500054.xhtml#p166)).\n"
"We'll pursue a slightly different approach here.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter15.md:894
msgid ""
"[2](#xfn0020) Note: systems that use `\"`cdr-coding`\"` take about the same "
"space for lists that are allocated all at once as for vectors.\n"
"But cdr-coding is losing favor as RISC chips replace microcoded processors.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
