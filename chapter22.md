# Глава 22
## Scheme: Необычный Лисп

> Лучшие продуманные схемы мышей и людей

> -Robert Burns (1759-1796)

В этой главе представлен диалект Лиспа - Scheme и его интерпретатор.
Хотя маловероятно, что вы будете использовать этот интерпретатор для серьезного программирования, понимание того, как работает интерпретатор, может дать вам лучшее представление о том, как работает Lisp, и, таким образом, сделать вас лучшим программистом.
Интерпретатор Scheme используется вместо Common Lisp, потому что Scheme проще, а также потому, что Scheme - важный язык, о котором стоит знать.

Scheme - единственный диалект Lisp, помимо Common Lisp, который в настоящее время процветает.
В то время как Common Lisp пытается стандартизировать все важные функции, которые в настоящее время используются программистами Lisp, Scheme пытается предоставить минимальный набор очень мощных функций, которые можно использовать для реализации других.
Интересно, что среди всех языков программирования в мире Scheme - один из самых маленьких, а Common Lisp - один из самых больших.
Руководство по Scheme занимает всего 45 страниц (только 38, если вы опустите пример, библиографию и указатель), а *Common Lisp the Language*, 2-е издание, составляет 1029 страниц.
Вот неполный список способов, которые делают Scheme проще, чем Common Lisp:

1.  Scheme имеет меньше встроенных функций и специальных форм.
!!!(p) {:.numlist}

2.  В Scheme нет специальных переменных, только лексические переменные.
!!!(p) {:.numlist}

3.  Scheme использует одно и то же пространство имен для функций и переменных (и всего остального).
!!!(p) {:.numlist}

4.  Scheme вычисляет(оценивает) функциональную часть вызова функции точно так же, как аргументы.
!!!(p) {:.numlist}

5.  Функции Scheme не могут иметь дополнительных(опциональных) параметров и параметров ключевых слов.
Однако они могут иметь эквивалент параметра `&rest`.
!!!(p) {:.numlist}

6.  В Scheme нет `block, return, go, orthrow`; есть одна функция `(call / cc)`, которая заменяет их все (и делает гораздо больше).
!!!(p) {:.numlist}

7.  В Scheme нет пакетов.
Лексические переменные могут использоваться для реализации структур, подобных пакетам.
!!!(p) {:.numlist}

8.  Scheme, как стандарт, не имеет макросов, хотя большинство реализаций предоставляют макросы в качестве расширения.
!!!(p) {:.numlist}

9.  Scheme не имеет специальных форм для зацикливания; вместо этого он просит пользователя использовать рекурсию и обещает эффективно реализовать рекурсию.
!!!(p) {:.numlist}

Пять основных специальных форм в Scheme - это `quote` и `if`, которые такие же, как в Common Lisp; `begin` и `set! `, которые просто разные варианты написания `progn` и `setq`; и `lambda`, что и в Common Lisp, за исключением того, что перед ним не требуется #.
Кроме того, Scheme позволяет использовать переменные, константы (числа, строки и символы) и вызовы функций.
Вызов функции отличается, потому что сама функция вычисляется(оценивается) так же, как и аргументы.
В Common Lisp (`f x`) означает поиск привязки функции `f` и применение ее к значению `x`.
На Scheme `(f x)` означает вычисление `f` (в данном случае путем поиска значения переменной `f`), вычисление `x` (путем поиска значения переменной точно таким же образом), а затем применение функцию к аргументу.
В позиции функции может быть любое выражение, и оно вычисляется так же, как аргументы.
Другое отличие состоит в том, что Scheme использует `# t` и `#f` для значений  true и false вместо `t` и `nil`.
Пустой список обозначается `()`, и он отличается от ложного значения #f.
Есть также незначительные лексические различия в соглашениях для комплексных чисел и чисел в разных основаниях, но их можно игнорировать для всех программ в этой книге.
Кроме того, в схеме один макрос, `define`, служит для определения как переменных, так и функций.

| Scheme                          | Common Lisp                             |
|---------------------------------|-----------------------------------------|
| *var*                           | *var*                                   |
| *constant*                      | *constant*                              |
| (`quote`*x*) or '*x*            | (`quote`*x*) or '*x*                    |
| (`begin`*x*...)                 | (`progn`*x*...)                         |
| (`set!`*var x*)                 | (`setq`*var x*)                         |
| (`if`*pab*)                     | (`if`*pab*)                             |
| (`lambda`*parms x*...)          | `#'` (`lambda`*parms x*...)             |
| (*fn arg*...)                   | (*fn arg*...) or (`funcall`*fn arg*...) |
| `#t`                            | `t`                                     |
| `#f`                            | `nil`                                   |
| `( )`                           | `nil`                                   |
| (`define`*varexp*)              | (`defparameter`*var exp*)               |
| (`define` (*fnparm*...) *body*) | (`defun`*fn* (*parm*...) *body*)        |

**Exercise  22**.**1** [**s**] Что вычислит следующее выражение на Scheme?
Сколько ошибок оно имеет в качестве выражения Common Lisp?

```lisp
((if (= (+  2 2) 4)
      (lambda (x y) (+ (* x y) 12))
      cons)
  5
  6)
```

Множество функций, таких как `car`, `cdr`, `cons`, `append`, +, `*` и `list`, одинаковы (или почти одинаковы) в обоих диалектах.
Однако в Scheme есть некоторые правила написания, которые отличаются от Common Lisp.
Большинство мутаторов(деструктивных функций) Scheme, таких как `set!`, оканчиваются на '`!`'. В Common Lisp нет общепринятого соглашения для этого; некоторые мутаторы начинаются с `n` (`nreverse, nsubst, nintersection`), в то время как другие имеют своеобразные имена (`delete versus remove`).
Scheme будет использовать согласованные имена - `reverse`! и `remove`! - если эти функции были вообще определены(в стандарте они не определены).
Большинство предикатов Scheme оканчиваются на '`?`', а не на '`p`'.
Это делает предикаты более очевидными и устраняет сложные соглашения о добавлении дефиса перед `p`. [1](#fn0010) Единственная проблема с этим соглашением заключается в разговорной речи: `equal?` Произносится как "равно-знак-вопроса" или  "равный-q" или, возможно равно, с возрастающей интонацией?
Это сделало бы Scheme языком тонов, как китайский.

В Scheme применение `car` или `cdr` к пустому списку является ошибкой.
Несмотря на то, что Scheme имеет `cons`, результат называется `pair`(`парой`), а не cons-ячейкой, поэтому предикатом будет `pair?`, а не `consp`.

Scheme распознает, что не все лямбда-выражения будут "функциями" в соответствии с математическим определением функции, и поэтому вместо этого использует термин "процедура".
Вот неполный список соответствий между двумя диалектами:

| Scheme Procedure | Common Lisp Function |
|------------------|----------------------|
| `char-ready?`    | `listen`             |
| `char?`          | `characterp`         |
| `eq?`            | `eq`                 |
| `equal?`         | `equal`              |
| `eqv?`           | `eql`                |
| `even?`          | `evenp`              |
| `for-each`       | `mapc`               |
| `integer?`       | `integerp`           |
| `list->string`   | `coerce`             |
| `list->vector`   | `coerce`             |
| `list-ref`       | `nth`                |
| `list-tail`      | `nthcdr`             |
| `map`            | `mapcar`             |
| `negative?`      | `minusp`             |
| `pair?`          | `consp`              |
| `procedure?`     | `functionp`          |
| `set!`           | `setq`               |
| `set-car!`       | `replaca`            |
| `vector-set!`    | `setf`               |
| `string-set!`    | `setf`               |

## 22.1 Интерпретатор Scheme

Как мы видели, интерпретатор принимает программу(или выражение) в качестве входных данных и возвращает значение, вычисленное этой программой.
Таким образом, Lisp функция `eval` является интерпретатором, и это, по сути, функция которую мы пытаемся написать в этом разделе.
Однако мы должны быть осторожны, так как можно спутать понятия интерпретатора и компилятора.
Компилятор принимает программу в качестве входных данных и производит в качестве выходных данных перевод этой программы на какой-либо другой язык - обычно это язык, который можно напрямую(или с большей легкостью) выполнить на некоторой машине.
Таким образом, также можно написать `eval`, скомпилировав аргумент и затем интерпретировать полученную программу на машинном уровне.
Большинство современных систем Lisp поддерживают обе возможности, хотя некоторые некоторые только интерпретируют код на прямую, а другие компилируют весь код перед его выполнением.
Чтобы прояснить различие, мы не будем писать функцию с именем `eval`.
Вместо этого, мы напишем версии двух функций: `interp`, интерпретатор Scheme, и в следующей главе, `comp`, компилятор Scheme.

Интерпретор обрабатывающий примитивы Scheme, легко написать.
В интерпретаторе `interp`, главное условие имеет восемь случаев, соответствующих пяти специальным формам, символам, другим атомам и применению процедур (также известным как вызовы функций).
На данный момент мы будем придерживаться `t` и `nil` вместо `#t` и `#f`.
После разработки простого интерпретатора мы добавим поддержку макросов, затем разработаем интерпретатор с хвостовой рекурсией и, наконец, интерпретатор с передачей продолжения(continuation-passing).
(Эти термины будут определены, когда придет время.).
Глоссарий(словарь) для `interp` приведен на [рисунке 22.1](#f0010).

| | **Функции верхнего уровня** |
|---|---|
| `scheme` | Scheme цикл чтения-интерпретации-печати/REPL(read-interp-print) |
| `interp` | Интерпретирует/вычисляет (оценивает) выражение в сред окружения.|
| `def-scheme-macro` | Определяет макрос Scheme. |
| | **Специальные переменные** |
| `*scheme-procs*` | Некоторые процедуры сохраняемые в глобальной среде окружения. |
| | **Вспомогательные функции** |
| `set-var!` | Установить значение для переменной |
| `get-var` | Получить значение для переменной в окружающей среде. |
| `set-global-var!` | Установить значение для глобальной переменной. |
| `get-global-var` | Получить значение переменной из глобальной окружающей среды. |
| `extend-env` | Добавить в окружающую среду несколько переменных и значений. |
| `init-scheme-iterp` | Инициализирует некоторые глобальные переменные. |
| `init-scheme-proc` | Определяет простую(примитивную) процедуру Scheme. |
| `scheme-macro` | Получает макрос Scheme для символа. |
| `scheme-macro-expand` | Макрорасширение выражения Scheme. |
| `maybe-add` | Добаить элемент в начало не одноэлементного списка. |
| `print-proc` | Распечатать процедуру. |
| | **Типы Данных (только для версии с хвостовой рекурсией)** |
| `proc` | Процедура Scheme. |
| | **Функции (только в версии с продолжениями)** |
| `interp-begin` | Интерпретирует выражение `begin`. |
| `interp-call` | Интерпретирует применение функции. |
| `map-interp` | Сопоставляет `interp` со списком. |
| `call/cc` | вызызов с текущим продолжением. |
| | **Ранее определенные функции** |
| `lastl` | Выбирает последний элемент из списка. |
| `length=1` | Проверяет что список имеет длину 1? |
| Таблица 22.1: Словарь для интерпретатора Scheme |

У простого интерпретатора есть восем случаев, о которых нужно беспокоиться: (1) Если выражение является символом, найдите его значение в окружающей среде.
(2) Если это атом, который не является символом(такой как число), просто верните его.
В противном случае выражение должно быть списком.
(3) Если оно начинается с `quote`, вернуть выражение в кавычках.
(4) Если оно начинается с `begin`, интерпретировать каждое подвыражение, и вернуть значение последнего.
(5) Если оно начинается с `set!`, интерпретируйте значение, а затем установите для переменной это значение.
(6) Если оно начинается с `if`, интерпретируйте условное выражение, и в зависимости от того истинно оно или нет интерпретируйте then-часть или else-часть.
(7) Если оно начинается с `lambda`, создайте новую процедуру - замыкание для текущей окружающей среды.
(8) В противном случае, это должно быть применение процедуры.
Интерпретируйте процедуру и все аргументы и примените значение процедуры к значениям аргументов.

```lisp
(defun interp (x &optional env)
  "Interpret (evaluate) the expression x in the environment env."
  (cond
    ((symbolp x) (get-var x env))
    ((atom x) x)
    ((case (first x)
       (QUOTE  (second x))
       (BEGIN  (last1 (mapcar #'(lambda (y) (interp y env))
                              (rest x))))
       (SET!   (set-var! (second x) (interp (third x) env) env))
       (IF     (if (interp (second x) env)
                   (interp (third x) env)
                   (interp (fourth x) env)))
       (LAMBDA (let ((parms (second x))
                     (code (maybe-add 'begin (rest2 x))))
                 #'(lambda (&rest args)
                     (interp code (extend-env parms args env)))))
       (t      ;; a procedure application
               (apply (interp (first x) env)
                      (mapcar #'(lambda (v) (interp v env))
                              (rest x))))))))
```

Окружающая среда(environment/окружение/среда/среда окружения) представлена в виде ассоциативного списка парами переменная/значение(variable/value), за исключением глобальной окружающей среды, которая представлена значениями в свойстве `global-val` для символов.
Было бы проще представить глобальное окружение так же, как локальную среду, но более эффективно использовать списки свойств, чем большой глобальный ассоциативный список(a-list).
Более того, глобальная среда отличается тем, что каждый символ определяется неявно в глобальном оружении, в то время как локальная окружающая среда содержит только переменные, которые явно упомянуты (в `lambda` выражении).

В качестве примера предположим, что мы интерпретируем вызов функции `(f 1 2 3)`, и что функция `f` была определена следующим выражением Scheme:

`(set!
f (lambda (a b c) (+ a (g b c))))`

Затем мы интерпретируем `( f 1 2 3 )` интерпретируя тело `f` с окружающей средой:

```lisp
((a 1) (b 2) (c 3))
```

Процедуры Scheme реализованы как функции Common Lisp, и фактически все типы данных Scheme реализованы соответствующими типами Common Lisp.
Я включил функцию `init-scheme-interp` для инициализации нескольких глобальных значений и повторяю определения `last1` и `length=1`:

```lisp
(defun set-var! (var val env)
  "Set a variable to a value, in the given or global environment."
  (if (assoc var env)
      (setf (second (assoc var env)) val)
      (set-global-var! var val))
  val)

(defun get-var (var env)
  "Get the value of a variable, from the given or global environment."
    (if (assoc var env)
        (second (assoc var env))
        (get-global-var var)))

(defun set-global-var! (var val)
  (setf (get var 'global-val) val))

(defun get-global-var (var)
  (let* ((default "unbound")
         (val (get var 'global-val default)))
    (if (eq val default)
        (error "Unbound scheme variable: ~a" var)
        val)))

(defun extend-env (vars vals env)
  "Add some variables and values to an environment."
  (nconc (mapcar #'list vars vals) env))

(defparameter *scheme-procs*
  '(+ - * / = < > <= >= cons car cdr not append list read member
    (null? null) (eq? eq) (equal? equal) (eqv? eql)
    (write prin1) (display princ) (newline terpri)))

(defun init-scheme-interp ()
  "Initialize the scheme interpreter with some global variables."
  ;; Define Scheme procedures as CL functions:
  (mapc #'init-scheme-proc *scheme-procs*)
  ;; Define the boolean `constants'. Unfortunately, this won't
  ;; stop someone from saying: (set! t nil)
  (set-global-var! t t)
  (set-global-var! nil nil))

(defun init-scheme-proc (f)
  "Define a Scheme procedure as a corresponding CL function."
  (if (listp f)
      (set-global-var! (first f) (symbol-function (second f)))
      (set-global-var! f (symbol-function f))))
```

```lisp
(defun maybe-add (op exps &optional if-nil)
  "For example, (maybe-add 'and exps t) returns
  t if exps is nil, exps if there is only one,
  and (and exp1 exp2...) if there are several exps."
  (cond ((null exps) if-nil)
              ((length=1 exps) (first exps))
              (t (cons op exps))))
(defun length=1 (x)
  "Is x a list of length 1?"
  (and (consp x) (null (cdr x))))
(defun lastl (list)
  "Return the last element (not last cons cell) of list"
  (first (last list)))
```

Чтобы протестировать интерпретатор, мы добавляем простой цикл чтения-выполнения-печати(REPL- read-eval-print loop):

```lisp
(defun scheme ()
  "A Scheme read-eval-print loop (using interp)"
  (init-scheme-interp)
  (loop (format t "~&==> ")
        (print (interp (read) nil))))
```

А теперь мы готовы опробовать интерпретатор. 
Обратите внимание, что приглашение Common Lisp это ">," а приглашение Scheme это "==>."

```lisp
> (scheme)
==> (+  2 2)
4
==> ((if (=  1 2) * +) 3 4)
7
==> ((if (=  1 1) * +) 3 4)
12
```

`==> (set!
fact (lambda (n)`

```lisp
                (if (= n 0) 1
                    (* n (fact (- n 1))))))
#<DTP-LEXICAL-CLOSURE 36722615  >
==> (fact 5)
120
```

`==> (set!
table (lambda (f start end)`

```lisp
                    (if (<= start end)
                        (begin
                          (write (list start (f start)))
                          (newline)
                          (table f (+ start 1) end)))))
#<DTP-LEXICAL-CLOSURE 41072172  >
==> (table fact 1 10)
(1 1)
(2 2)
(3 6)
(4 24)
(5 120)
(6 720)
(7 5040)
(8 40320)
(9 362880)
(10 3628800)
NIL
==> (table (lambda (x) (* x x x)) 5 10)
(5 125)
(6 216)
(7 343)
(8 512)
(9 729)
(10 1000)
NIL
==> [ABORT]
```

## 22.2 Синтаксическое расширение с помощью Макросов

Scheme имеет ряд специальных форм, не перечисленных выше.
Фактически, Scheme использует термин "синтаксис" там, где мы используем "специальная форма." 
Остальной синтаксис можно определить как "производные выражения" в терминах пяти примитивов.
Стандарт Scheme не признает концепцию макросов, но ясно, что "производное выражение" похоже на макрос, и мы будем реализовывать их с помощью макросов.
Следующие формы используются (почти) одинаково в Scheme и Common Lisp:

```lisp
let let* and or do cond case
```

Одно отличие состоит в том, что Scheme менее снисходительно относится к тому, что считается связыванием в `let`, `let*` и `do`.
Каждая привязка должна быть `(`*var init*`)`; просто `(`*var*`)` или *var* не допустимы.
В do, привязка может быть либо (*var init step*), либо (*var init*).
Обратите внимание, что `do*` отсутствует.
Другое отличие заключается в  `case` и `cond`.
Где Common Lisp использует символ `t` или `otherwise` для обозначения последнего случая, Scheme использует `else`.
Последние три синтаксических расширения уникальны для Scheme:

```lisp
(define *var val*)      *or*          (define (*proc*-*name arg*...) *body*...)
(delay *expression*)
(letrec ((*var init*)...) *body*...)
```

`define` это комбинация  `defun` и `defparameter`.
В своей первой форме он присваивает значение переменной.
Поскольку в Scheme нет специальных переменных, она ничем не отличается от `set!`.
(Есть разница, когда определение вложено в другое определение, но это еще не рассматривается.) 
Во второй форме оно определяет функцию.
`delay` используется для задержки вычислений, как описано в [разделе 9.3](B9780080571157500091.xhtml#s0020), стр. 281.
`letrec` аналогичен `let`.
Разница в том, что все формы *init* вычисляются в окружающей среде, которая включает все *vars*(переменные*).
Таким образом, `letrec` можно использовать для определения локальных рекурсивных функций, как это делает `labels` в Common Lisp.

Первым шагом в реализации этих синтаксических расширений является изменение `interp`, позволяющее использовать макросы.
Нужно добавить одно предложение, но мы повторим все определение:

```lisp
(defun interp (x &optional env)
  "Interpret (evaluate) the expression x in the environment env."
  (cond
    ((symbolp x) (get-var x env))
    ((atom x) x)
    ((case (first x)
       (QUOTE  (second x))
       (BEGIN  (last1 (mapcar #'(lambda (y) (interp y env))
                              (rest x))))
       (SET!   (set-var! (second x) (interp (third x) env) env))
       (IF     (if (interp (second x) env)
                   (interp (third x) env)
                   (interp (fourth x) env)))
       (LAMBDA (let ((parms (second x))
                     (code (maybe-add 'begin (rest2 x))))
                 #'(lambda (&rest args)
                     (interp code (extend-env parms args env)))))
       (t      ;; a procedure application
               (apply (interp (first x) env)
                      (mapcar #'(lambda (v) (interp v env))
                              (rest x))))))))
```

Теперь мы предоставим механизм для определения макросов.
Определения макросов могут быть на любом языке; самый простой выбор - это сама Scheme или Common Lisp.
Я выбрал второе.
Это дает понять, что макросы не являются частью самой Scheme, а используются для реализации Scheme.
Если бы мы хотели пердложить программисту Scheme возможность/функциональность создания мароса, мы бы сделали другой выбор.
(Но тогда мы обязательно добавим обозначение/запись обратных кавычек, которая очень полезна при написании макросов.) `def-scheme-macro` (который сам по себе является макросом) предоставляет способ добавления новых макросов Scheme.
Он делает это, сохраняя функцию Common Lisp в свойстве символа `scheme-macro`.
Эта функция, получив список аргументов, возвращает код, в который должен быть расширен вызов макроса.
Функция `scheme-macro` проверяет, имеет ли символ прикрепленный к нему макрос, а `scheme-macro-expand` выполняет фактическое расширение макроса:

```lisp
(defun scheme-macro (symbol)
  (and (symbolp symbol) (get symbol 'scheme-macro)))
(defmacro def-scheme-macro (name parmiist &body body)
  "Define a Scheme macro."
  '(setf (get ',name 'scheme-macro)
        #'(lambda .parmlist ..body)))
(defun scheme-macro-expand (x)
  "Macro-expand this Scheme expression."
  (if (and (listp x) (scheme-macro (first x)))
              (scheme-macro-expand
                (apply (scheme-macro (first x)) (rest x)))
              x))
```

Вот определение девяти важных в Scheme макросов:

```lisp
(def-scheme-macro let (bindings &rest body)
  '((lambda .(mapcar #'first bindings) . ,body)
    .,(mapcar #'second bindings)))
(def-scheme-macro let* (bindings &rest body)
  (if (null bindings)
              '(begin .,body)
              '(let (,(first bindings))
          (let* ,(rest bindings) . ,body))))
(def-scheme-macro and (&rest args)
  (cond ((null args) 'T)
          ((length=1 args) (first args))
          (t '(if ,(first args)
                    (and . ,(rest args))))))
(def-scheme-macro or (&rest args)
  (cond ((null args) 'nil)
        ((length=1 args) (first args))
        (t (let ((var (gensym)))
                '(let ((,var ,(first args)))
                  (if ,var ,var (or . ,(rest args))))))))
(def-scheme-macro cond (&rest clauses)
  (cond ((null clauses) nil)
          ((length=1 (first clauses))
            '(or ,(first clauses) (cond .,(rest clauses))))
          ((starts-with (first clauses) 'else)
            '(begin .,(rest (first clauses))))
          (t '(if ,(first (first clauses))
                    (begin .,(rest (first clauses)))
                    (cond .,(rest clauses))))))
(def-scheme-macro case (key &rest clauses)
  (let ((key-val (gensym "KEY")))
    '(let ((,key-val ,key))
      (cond ,@(mapcar
                #'(lambda (clause)
                    (if (starts-with clause 'else)
                        clause
                        '((member ,key-val ',(first clause))
                                .,(rest clause))))
                clauses)))))
(def-scheme-macro define (name &rest body)
  (if (atom name)
```

`              '(begin (set!
,name . ,body) ',name)`

```lisp
              '(define ,(first name)
          (lambda ,(rest name) . ,body))))
(def-scheme-macro delay (computation)
  '(lambda () ,computation))
(def-scheme-macro letrec (bindings &rest body)
  '(let ,(mapcar #'(lambda (v) (list (first v) nil)) bindings)
```

`        ,@(mapcar #'(lambda (v) '(set!
. ,v)) bindings)`

```lisp
      .,body))
```

Мы можем протестировать возможность использовать макросов:

```lisp
> (scheme-macro-expand '(and p q)) => (IF P (AND Q))
> (scheme-macro-expand '(and q)) Q
```

`> (scheme-macro-expand '(let ((x 1) (y 2)) (+ x y)))`=>

```lisp
((LAMBDA (X Y) (+ X Y)) 1 2)
> (scheme-macro-expand
    '(letrec
```

`        ((even?
(lambda (x) (or (= x 0) (odd?
(- x 1)))))`

`          (odd?
(lambda (x) (even?
(- x 1)))))`

`        (even?
z)))`=>

`(LET ((EVEN?
NIL)`

`              (ODD?
NIL))`

`  (SET!
EVEN?
(LAMBDA (X) (OR (= X 0) (ODD?
(- X 1)))))`

`  (SET!
ODD?
(LAMBDA (X) (EVEN?
(- X 1))))`

`  (EVEN?
Z))`

```lisp
> (scheme)
==> (define (reverse 1)
```

`      (if (null?
1) nil`

```lisp
            (append (reverse (cdr 1)) (list (car 1)))))
REVERSE
==> (reverse '(a b c d))
(D C B A)
==> (let* ((x 5) (y (+ x x)))
      (if (or (= x 0) (and (<  0 y) (< y 20)))
            (list x y)
            (+ y x)))
(5 10)
```

Макрос `define` похож на `set!`, за исключением того, что он возвращает символ, а не значение, присвоенное символу.
Кроме того, `define` предоставляет необязательный синтаксис для определения функций - он служит целям как `defun`, так и `defvar`.
Синтаксис (`define` (*fn* . *args*) .*body*) является сокращением (`define`*fn* (`lambda`*args* . *body*)).

Кроме того, Scheme предоставляет нотацию, в которой  `define` можно использовать внутри определения функции таким образом, чтобы оно работало как `let`, а не как `set!.`

Преимущетсво подхода базирующегося на макросах к специальным формам состоит в том, что нам не нужно изменять интерпретатор для добавления новых специальных форм.
Интерпретатор остается простым, даже когда язык растет.
Это также относится к компилятору, как мы увидим в следующем разделе.

## 22.3 Правильный Интерпретатор Хвостовой Рекурсии

К сожалению, представленный выше интерпретатор не может претендовать на гордое имя Scheme, потому что настоящая Scheme должна правильно обрабатывать хвостовую рекурсию.
Наш интерпретатор обрабатывает хвостовую рекурсию только при запуске в  Common Lisp, который сам является обрабатывающим хвостовую рекурсию.
Чтобы увидеть проблему, рассмотрим следующую процедуру Scheme:

```lisp
(define (traverse lyst)
  (if lyst (traverse (cdr lyst))))
```

Трассируйте функцию `interp` и выполните `(interp '(traverse '(a b c d)))`.
Вложенные вызовы функции `interp` проходят на 16 уровней в глубину.
Как правило, уровень вложенности в 4 плюс 3 раза больше длины списка.
Каждый вызов `interp` требует Common Lisp выделил часть памяти в стеке, поэтому для очень длинных списков у нас в конечном итоге закончится память.
Чтобы получить звание Scheme, язык должен гарантировать, что у такой программы не закончится память.

Проблема в этом примере заключается в двух местах.
Каждый раз, когда мы интерпретируем форму `if` или вызов процедуры, мы спускаемся с другого рекурсивного уровня в `interp`.
Но этот дополнительный уровень не нужен.
Рассмотрим форму `if`.
Разумеется, необходимо рекурсивно вызвать `interp` , чтобы решить верен ли тест или нет.
Ради аргумента, предположим, что тест верен.
Затем мы снова вызываем `interp` для части *then*.
Этот рекурсивный вызов вернет значение, которое затем будет немедленно возвращено как значение исходного вызова.

Альтернативой является замена рекурсивного вызова `interp` на переименование переменных с последующим выполнением оператора `goto`.
То есть, вместо вызова `interp` и, таким образом, привязки нового экземпляра переменной `x` к части *then*, мы просто присваиваем часть *then* переменной `x`, и переходим к началу подпрограммы `interp`.
Это работает, потому что мы знаем, что нам больше не нужно использовать старое значение `x`.
Аналогичный прием используется для устранения рекурсивного вызова для последнего выражения в форме `begin`.
(Многие программисты были обучены "структурным программированием", что операторы `goto` вредны.
В этом случае `goto` необходим для эффективной реализации низкоуровневой функции.)

Последнее, что нам нужно сделать, это явно управлять процедурами Scheme.
Вместо реализации процедур Scheme как замыканий Common Lisp мы определим структуру, `proc`, которая будет содержать код, окружающую среду, список параметров и, возможно, имя процедуры.
Затем, когда мы вычисляем вызов процедуры, мы можем присвоить тело процедуры `x`, а не рекурсивно вызывать `interp`.

```lisp
(defstruct (proc (:print-function print-proc))
  "Represent a Scheme procedure"
  code (env nil)(name nil) (parms nil))
```

Ниже приведен интерпретатор с правильной хвостовой рекурсией.
Макрос `prog` устанавливает `tagbody`, внутри которого мы можем использовать операторы `go` для перехода к меткам, а также он устанавливает `block`, из которого мы можем возвращать значение.
Он также может связывать переменные, подобно `let`, хотя в этом случае список переменных пуст.
Любой символ в теле `prog` считается меткой.
В этом случае метка :`INTERP` является целью операторов ветвления `(GO: INTERP)`.
Я использую прописные буквы, чтобы указать, что используются операторы перехода, но это соглашение не получило широкого распространения.

```lisp
(defun interp (x &optional env)
  "Evaluate the expression x in the environment env.
  This version is properly tail-recursive."
  (prog ()
    :INTERP
    (return
      (cond
        ((symbolp x) (get-var x env))
        ((atom x) x)
        ((scheme-macro (first x))
          (setf x (scheme-macro-expand x)) (go :INTERP))
        ((case (first x)
            (QUOTE (second x))
            (BEGIN (pop x) ; pop off the BEGIN to get at the args
                      ;; Now interpret all but the last expression
                      (loop while (rest x) do (interp (pop x) env))
                      ;; Finally, rename the last expression as x
                      (setf x (first x))
                      (GO :INTERP))
```

`            (SET!    (set-var!
(second x) (interp (third x) env) env))`

```lisp
            (IF              (setf x (if (interp (second x) env)
                                (third x)
                                (fourth x)))
                      ;; That is, rename the right expression as x
                      (GO :INTERP))
            (LAMBDA (make-proc :env env :parms (second x)
                                :code (maybe-add 'begin (rest2 x))))
            (t      ;; a procedure application
                    (let ((proc (interp (first x) env))
                          (args (mapcar #'(lambda (v) (interp v env))
                                                      (rest x))))
                      (if (proc-p proc)
                            ;; Execute procedure with rename+goto
                            (progn
                              (setf x (proc-code proc))
                              (setf env (extend-env (proc-parms proc) args
                                                                          (proc-env proc)))
                              (GO :INTERP))
                            ;; else apply primitive procedure
                            (apply proc args))))))))))
(defun print-proc (proc &optional (stream *standard-output*) depth)
  (declare (ignore depth))
  (format stream "{~a}" (or (proc-name proc) '??)))
```

Трассируя хвосто-рекурсивную версию `interp`, вы можете видеть, что вызовы `traverse` спускаются только на три рекурсивных уровня `interp`, независимо от длины пройденного списка.

Обратите внимание, что мы не утверждаем, что этот интерпретатор не выделяет памяти при выполнении хвостовых рекурсивных вызовов.
Действительно, он тратит довольно много памяти на вычисление аргументов и построение окружающей среды.
Утверждается, что поскольку хранилище выделяется в куче, а не в стеке, его может вернуть сборщик мусора.
Таким образом, даже если `traverse` применяется к бесконечно длинному списку (т. е. круговому списку), интерпретатор никогда не исчерпает пространство - он всегда сможет собрать мусор и продолжить работу.

В этот интерпретатор можно внести много улучшений, но лучше потратить усилия на улучшение компилятора, а не интерпретатора.
Следующая глава посвящена именно этому.

## 22.4 Throw, Catch и Call/cc

Хвостовая рекурсия имеет решающее значение для Scheme.
Идея состоит в том, что когда язык гарантированно оптимизирует хвостовые рекурсивные вызовы, тогда нет необходимости в специальных формах для выполнения итераций.
Все циклы можно писать с помощью рекурсии, не беспокоясь о переполнении стека выполнения.
Она помогает сохранить простоту языка и исключает использование оператора `goto`, признанного бедствием в движении за структурное программирование.
Однако бывают случаи, когда какой-то нелокальный выход - лучшая альтернатива.
Предположим, что в вашей программе происходит какое-то неожиданное событие.
Лучшее действие - распечатать сообщение об ошибке и вернуться на верхний уровень вашей программы.
Это можно сделать тривиально с помощью оператора goto.
Без него каждую функцию на пути вызова пришлось бы изменить, чтобы принимать либо действительный результат, либо указание на исключительное условие, которое просто передается на следующий уровень.

В Common Lisp для такого нелокального выхода предусмотрены функции `throw` и `catch`.
Скотт Циммерман, бессменный чемпион мира по фрисби, также работает программистом в южнокалифорнийской фирме.
Однажды он сказал мне: "Я начинаю изучать Лисп, и это должен быть хороший язык, потому что в нем есть  `throw` и `catch`. К сожалению для Скотта, слова `throw` и `catch` относятся не к фрисби, а к передаче управления.
Это обе специальные формы со следующим синтаксисом:

```lisp
(catch tag body...)
(throw tag value)
```

Первый аргумент `catch` - это тег или метка.
Остальные аргументы вычисляются по одному, и возвращается значение последнего из них.
Таким образом, `catch` очень похож на `progn`.
Разница в том, что если какой-либо код в динамическом экстенте(внутри) тела `catch` вычисляет специальную форму `throw`, то управление немедленно передается за охватывающий `catch` с тем же тегом.

Например, форма

```lisp
(catch 'tag
  (print 1) (throw 'tag 2) (print 3))
```

печатает `1` и возвращает `2`, не выводя на печать `3`.
Более представительный пример:

```lisp
(defun print-table (l)
  (catch 'not-a-number (mapcar #'print-sqrt-abs l)))
(defun print-sqrt-abs (x)
  (print (sqrt (abs (must-be-number x)))))
(defun must-be-number (x)
  (if (numberp x) x
      (throw 'not-a-number "huh?")))
> (print-table '(1 4 -9 x 10 20))
1
2
3
"huh?"
```

Здесь `print-table` вызывает `print-sqrt-abs`, который вызывает `must-be-number`.
Первые три раза все в порядке, и печатаются значения 1,2,3.
В следующий раз `x` не будет числом, поэтому значение `"huh?"` будет выброшено(throw) в тег `not-a-number`, установленный `catch` в `f`.
Этот throw(Бросок) обходит ожидающие вызовы к `abs`, `sqrt` и `print`, а также остаток вызова `mapcar`.

Этот вид управления предоставляется в Scheme с помощью очень общей и мощной процедуры, `call-with-current-continue`, которая часто сокращается до `call/cc`.
`call/cc` - это обычная процедура (не особая форма, такая как `throw` и `catch`), которая принимает единственный аргумент.
Давайте назовем аргумент `computation`(вычислением).
`computation` должна быть процедурой с одним аргументом.
Когда вызывается `call/cc`, он вызывает `computation`, и все, что возвращает `computation`, является значением вызова `call/cc`.
Уловка заключается в том, что процедура `computation` также принимает аргумент (который мы назовем `cc`), который является другой процедурой, представляющей текущую точку продолжения.
Если `cc` применяется к какому-либо значению, это значение возвращается как значение вызова `call/cc`.
Вот некоторые примеры:

```lisp
> (scheme)
=> (+  1 (call/cc (lambda (cc) (+  20 300))))
321
```

В этом примере игнорируется `cc` и вычисляется просто `(+ 1 (+ 20 300))`.
Точнее, это эквивалент:

```lisp
((lambda (val) (+  1  val))
  (+  20 300))
```

В следующем примере действительно используется `cc`:

```lisp
=> (+  1 (call/cc (lambda (cc) (+  20 (cc 300)))))
301
```

Он передает `300` в `cc`, минуя добавление `20`.
Он фактически выбрасывает `300` из вычислений в точку перехвата, установленную `call/cc`.
Это эквивалентно:

```lisp
((lambda (val) (+  1  val))
  300)
```

или в:

```lisp
((lambda (val) (+  1  val))
  (catch 'cc
    ((lambda (v) (+  20 v))
      (throw 'cc 300))))
```

Вот как будет выглядеть механизм `throw/catch` на Scheme:

```lisp
(define (print-table l )
  (call/cc
    (lambda (escape)
```

`      (set!
not-a-number escape)`

```lisp
      (map print-sqrt-abs l))))
(define (print-sqrt-abs x)
  (write (sqrt (abs (must-be-number x)))))
(define (must-be-number x)
  (if (numberp x) x
      (not-a-number "huh?")))
(define (map fn l)
```

`  (if (null?
l)`

```lisp
      '()
      (cons (fn (first l))
              (map fn (rest 1)))))
```

Возможность вернуться к ожидающей точке вычисления полезна для обработки ошибок и прерываний такого рода.
Однако поистине удивительная, замечательная особенность `call/cc` - это возможность возвращаться к точке продолжения более одного раза.
Рассмотрим небольшое изменение:

```lisp
=> (+  1 (call/cc (lambda (cc)
```

`                      (set!
old-cc  cc)`

```lisp
                      (+  20 (cc 300)))))
301
=> (old-cc 500)
501
```

Здесь мы сначала вычислили 301, как и раньше, но попутно сохранили `cc` в глобальной переменной `old-cc`.
После этого вызов `(old-cc 500)` возвращает (во второй раз) к точке в вычислении, где добавляется 1, на этот раз возвращая `501`.
Эквивалентный код Common Lisp приводит к ошибке:

```lisp
> (+  1 (catch 'tag (+  20 (throw 'tag 300))))
301
> (throw 'tag 500)
*Error*: *there was no pending CATCH for the tag TAG*
```

Другими словами, продолжения `call/cc` имеют неограниченную протяженность(extent), в то время как теги throw/catch имеют только динамическую протяженность(extent).

Мы можем использовать `call/cc` для реализации автоматического поиска с возвратом(backtracking) (среди прочего).
Предположим, у нас есть специальная форма, `amb`, "неоднозначный" оператор, который возвращает один из своих аргументов, выбранных случайным образом.
Мы могли бы написать:

```lisp
(define (integer) (amb 1 (+  1 (integer))))
```

а вызов `integer` вернет некоторое случайное положительное целое число.
Вдобавок предположим, что у нас есть функция `fail`, которая вообще не возвращается, а вместо этого заставляет выполняться продолжение с предыдущей точки `amb` с другим выбором.
Тогда мы могли бы написать краткий [2](#fn0015) код отслеживания с возвратом, как показано ниже:

```lisp
(define (prime)
  (let ((n (integer)))
```

`  (if (prime?
n) n (fail))))`

Если `prime?` - это предикат, который возвращает истину только тогда, когда его аргумент - простое(prime) число, то prime всегда будет возвращать некоторое `простое(prime)`число, определенное путем генерации случайных целых чисел.
Хотя это выглядит как серьезное изменение языка - добавление обратного отслеживания и недетерминизма - оказывается, что `amb` и `fail` могут быть довольно легко реализованы с помощью `cal1/cc`.
Во-первых, нам нужно сделать `amb` макросом:

```lisp
(def-scheme-macro amb (x y)
  '(random-choice (lambda () ,x) (lambda () ,y))))
```

В остальном это чистая Scheme.
Мы ведем список `backtrack-points`(точек возврата), которые реализованы как функции без аргументов.
Чтобы вернуться назад, мы просто вызываем одну из этих функций.
Вот что делает `fail`.
Функция `choose-first` принимает две функции и подталкивает вторую вместе с надлежащим продолжением к `backtrack-points`, а затем вызывает первую, возвращая это значение.
Функция `random-choice` - это то, во что расширяется `amb`: она решает, какой выбор будет первым, а какой - вторым.
(Обратите внимание, что в Scheme принято записывать глобальные переменные, такие как `backtrack-points`, без звездочек.)

```lisp
(define backtrack-points nil)
(define (fail)
  (let ((last-choice (car backtrack-points)))
```

`    (set!
backtrack-points (cdr backtrack-points))`

```lisp
    (last-choice)))
(define (random-choice f g)
  (if (=  1 (random 2))
      (choose-first f g)
      (choose-first g f)))
(define (choose-first f g)
  (call/cc
    (lambda (k)
```

`      (set!
backtrack-points`

```lisp
            (cons (lambda () (k (g))) backtrack-points))
      (f))))
```

Это реализует хронологическое обратное отслеживание(backtracking), как в Prolog.
Однако на самом деле у нас есть свобода делать и другие виды обратного отслеживания.
Вместо того, чтобы `fail` брал первый элемент из `backtrack-points`, мы могли бы выбрать случайный элемент.
Или мы могли бы провести более сложный анализ, чтобы выбрать хорошую точку возврата.

`call/cc` может использоваться для реализации различных структур управления.
В качестве другого примера, многие реализации Lisp предоставляют функцию `reset`, которая прерывает текущее вычисление и возвращает управление циклу чтения-оценки-печати верхнего уровня.
reset можно довольно легко определить с помощью `call/cc`.
Хитрость заключается в том, чтобы захватить продолжение, которое находится на верхнем уровне, и сохранить его для использования в будущем.
Следующее выражение, вычисленное на верхнем уровне, сохраняет соответствующее продолжение в значении reset:

`(call/cc (lambda (cc) (set!
reset (lambda ()`

```lisp
                                (cc "Back to top level")))))
```

**Exercise 22.2 [m]** Можете ли вы реализовать `call/cc` в Common Lisp?

**Exercise 22.3 [s]** Can you implement `amb` and `fail` in Common Lisp?

**Exercise 22.4 [m]**`fail` could be written

`(define (fail) ((pop backtrack-points)))` if we had the pop macro in Scheme.

Write `pop.`

## 22.5 Интерпретатор с поддержкой Call/cc

Интересно, что чем больше может предложить хост-язык, тем проще написать интерпретатор.
Возможно, самая сложная часть написания интерпретатора (или компилятора) Лиспа - это сборка мусора.
Написав наш интерпретатор на Лиспе, мы полностью обошли эту проблему - основной язык автоматически собирает мусор.
Точно так же, если мы используем Common Lisp, который имеет хвостовую рекурсию, то наш интерпретатор тоже будет использовать её, без каких-либо специальных действий.
Если нет, то интерпретатор должен быть переписан, чтобы позаботиться о хвостовой рекурсии, как мы видели выше.

То же самое и с `call/cc`.
Если наш основной язык обеспечивает предоставляет продолжения с неограниченным экстентом(временем существования), то реализовать `call/cc` тривиально.
Если нет, мы должны переписать весь интерпретатор, чтобы он явно обрабатывал продолжения.
Лучший способ сделать это - сделать `interp` функцией трех аргументов: выражения, окружения и продолжения.
Значит, придется изменить и верхний уровень.
Вместо того, чтобы заставлять `interp` возвращать значение, которое распечатывается, мы просто передаем ему функцию `print` как продолжение:

```lisp
(defun scheme ()
    "A Scheme read-eval-print loop (using interp).
    Handles call/cc by explicitly passing continuations."
    (init-scheme-interp)
    (loop (format t "~&==> ")
              (interp (read) nil #'print)))
```

Теперь мы готовы заняться `interp`.
Для ясности мы возьмём за базу его на не хвостово-рекурсивную версию.
Случаи символов, атомов, макросов и `quote`(цитаты) почти такие же, как и раньше.
Разница в том, что результат каждого вычисления передается продолжению `cc`, а не просто возвращается.

Остальные случаи более сложные, потому что все они требуют явного представления продолжений.
Это означает, что вызовы `interp` не могут быть вложенными.
Вместо этого мы вызываем `interp` с продолжением, которое включает еще один вызов `interp`.
Например, чтобы интерпретировать (`if p x y`), мы сначала вызываем `interp` для второго элемента формы, предиката `p`.
Продолжением этого вызова является функция, которая проверяет значение `p` и интерпретирует соответственно `x` или `y`, используя исходное продолжение для рекурсивного вызова `interp`.
Остальные случаи аналогичны.
Одним из важных изменений является то, что процедуры Scheme реализованы как функции Lisp, где первым аргументом является продолжение:

```lisp
(defun interp (x env cc)
  "Evaluate the expression x in the environment env,
  and pass the result to the continuation cc."
  (cond
    ((symbolp x) (funcall cc (get-var x env)))
    ((atom x) (funcall cc x))
    ((scheme-macro (first x))
      (interp (scheme-macro-expand x) env cc))
    ((case (first x)
          (QUOTE (funcall cc (second x)))
          (BEGIN (interp-begin (rest x) env cc))
(SET!    (interp (third x) env
                    #'(lambda (val)
```

`                          (funcall cc (set-var!
(second x)`

```lisp
                                                                        val env)))))
(IF      (interp (second x) env
                    #'(lambda (pred)
                          (interp (if pred (third x) (fourth x))
                                env cc))))
(LAMBDA (let ((parms (second x))
                  (code (maybe-add 'begin (rest2 x))))
              (funcall
                cc
                #'(lambda (cont &rest args)
                    (interp code
                              (extend-env parms args env)
                              cont)))))
(t      (interp-call x env cc))))))
```

Определены несколько вспомогательных функций в том же стиле передачи продолжения:

```lisp
(defun interp-begin (body env cc)
  "Interpret each element of BODY, passing the last to CC."
  (interp (first body) env
          #'(lambda (val)
              (if (null (rest body))
                      (funcall cc val)
                      (interp-begin (rest body) env cc)))))
(defun interp-call (call env cc)
  "Interpret the call (f x...) and pass the result to CC."
  (map-interp call env
                  #'(lambda (fn-and-args)
                      (apply (first fn-and-args)
                                cc
                                (rest fn-and-args)))))
(defun map-interp (list env cc)
  "Interpret each element of LIST, and pass the list to CC."
  (if (null list)
        (funcall cc nil)
        (interp (first list) env
                  #'(lambda (x)
                      (map-interp (rest list) env
                                #'(lambda (y)
                                (funcall cc (cons x y))))))))
```

Поскольку процедуры Scheme ожидают продолжения в качестве первого аргумента, нам нужно переопределить `init-scheme-proc` для установки процедур, которые принимают и применяют продолжение:

```lisp
(defun init-scheme-proc (f)
  "Define a Scheme procedure as a corresponding CL function."
  (if (listp f)
      (set-global-var! (first f) (symbol-function (second f)))
      (set-global-var! f (symbol-function f))))
```

Нам также нужно определить `call/cc`.
Подумайте на мгновение о том, что должен делать `call/cc`.
Как и все процедуры Scheme, он принимает текущее продолжение в качестве первого аргумента.
Второй аргумент - это процедура - вычисление, которое нужно выполнить.
`call/cc` выполняет вычисление, вызывая процедуру.
Это обычный вызов, поэтому он использует текущее продолжение.
Сложность состоит в том, что `call/cc` передает вычисление в качестве аргумента.
Он передает процедуру выхода, которая может быть вызвана для возврата в ту же точку, в которую был бы возвращен исходный вызов `call/cc`.
Как только работа `call/cc` будет понятна, реализация станет очевидной:

```lisp
(defun call/cc (cc computation)
  "Make the continuation accessible to a Scheme procedure."
  (funcall computation cc
           ;; Package up CC into a Scheme function:
           #'(lambda (cont val)
               (declare (ignore cont))
               (funcall cc val))))

;; Now install call/cc in the global environment
(set-global-var! 'call/cc #'call/cc)
(set-global-var! 'call-with-current-continuation #'call/cc)
```

## 22.6 История и Ссылки

Lisp interpreters and AI have a long history together.
MIT AI Lab Memo No.
1 ([McCarthy 1958](B9780080571157500285.xhtml#bb0790)) was the first paper on Lisp.
McCarthy's students were working on a Lisp compiler, had written certain routines-`read`, `print`, etc.-`in` assembly language, and were trying to develop a full Lisp interpreter in assembler.
Sometime around the end of 1958, McCarthy wrote a theoretical paper showing that Lisp was powerful enough to write the universal function, `eval`.
A programmer on the project, Steve Russell, saw the paper, and, according to McCarthy:

> Steve Russell said, look, why don't I program this `eval` and-you remember the interpreter-and I said to him, ho, ho, you're confusing theory with practice, this `eval` is intended for reading not for computing.
But he went ahead and did it.
That is, he compiled the `eval` in my paper into 704 machine code fixing bugs and then advertised this as a Lisp interpreter, which it certainly was.[3](#fn0020)

So the first Lisp interpreter was the result of a programmer ignoring his boss's advice.
The first compiler was for the Lisp 1.5 system ([McCarthy et al.
1962](B9780080571157500285.xhtml#bb0815)).
The compiler was written in Lisp; it was probably the first compiler written in its own language.

Allen's *Anatomy of lisp* (1978) was one of the first overviews of Lisp implementation techniques, and it remains one of the best.
However, it concentrates on the dynamic-scoping Lisp dialects that were in use at the time.
The more modern view of a lexically scoped Lisp was documented in an influential pair of papers by Guy Steele ([1976a](B9780080571157500285.xhtml#bb1130),[b](B9780080571157500285.xhtml#bb1135)).
His papers "Lambda: the ultimate goto" and "Compiler optimization based on viewing lambda as rename plus goto" describe properly tail-recursive interpreters and compilers.

The Scheme dialect was invented by Gerald Sussman and Guy Steele around 1975 (see their MIT AI Memo 349).
The *Revised*4*Report on the Algorithmic Language Scheme* ([Clinger et al.
1991](B9780080571157500285.xhtml#bb0205)) is the definitive reference manual for the current version of Scheme.

[Abelson and Sussman (1985)](B9780080571157500285.xhtml#bb0010) is probably the best introduction to computer science ever written.
It may or may not be a coincidence that it uses Scheme as the programming language.
It includes a Scheme interpreter.
Winston and Horn's *Lisp* (1989) also develops a Lisp interpreter.

The `amb` operator for nondeterministic choice was proposed by [John McCarthy (1963)](B9780080571157500285.xhtml#bb0800) and used in SCHEMER ([Zabih et al.
1987](B9780080571157500285.xhtml#bb1440)), a nondeterministic Lisp.
[Ruf and Weise (1990)](B9780080571157500285.xhtml#bb1015) present another implementation of backtracking in Scheme that incorporates all of logic programming.

## 22.7 Упражнения

**Exercise  22.5 [m]** Хотя Scheme не обеспечивает полноценной поддержки необязательных аргументов и аргументов ключевых слов, он поддерживает параметры rest.
Измените интерпретатор для поддержки синтаксиса Scheme для параметров rest:

| Scheme                     | Common Lisp                       |
|----------------------------|-----------------------------------|
| (`lambda x`*body*)         | (`lambda` (`&rest x`) *body*)     |
| (`lambda (x y . z)`*body*) | (`lambda` (`x y &rest z`) *body*) |

**Exercise  22.6 [h]** The representation of environments is somewhat wasteful.
Currently it takes 3*n* cons cells to represent an environment with *n* variables.
Change the representation to take less space.

**Exercise  22.7 [m]** As we've implemented macros, they need to be expanded each time they are encountered.
This is not so bad for the compiler-you expand the source code and compile it, and then never refer to the source code again.
But for the interpreter, this treatment of macros is most unsatisfactory: the work of macroexpansion must be done again and again.
How can you eliminate this duplicated effort?

**Exercise  22.8 [m]** It turns out Scheme allows some additional syntax in `let` and `cond`.
First, there is the "named-let" expression, which binds initial values for variables but also defines a local function that can be called within the body of the `let`.
Second, `cond` recognizes the symbol => when it is the second element of a cond clause, and treats it as a directive to pass the value of the test (when it is not false) to the third element of the clause, which must be a function of one argument.
Here are two examples:

```lisp
(define (fact n)
  ;; Iterative factorial; does not grow the stack
  (let loop ((result 1) (i n))
    (if (= i 0) result (loop (* result i) (- i 1)))))
(define (lookup key alist)
  ;; Find key's value in alist
  (cond ((assoc key alist) => cdr)
          (else #f)))
```

These are equivalent to:

```lisp
(define (fact n)
  (letrec
    ((loop (lambda (result i)
                (if (= i 0)
                    result
                    (loop (* result i) (- i 1))))))
    (loop 1 n)))
(define (lookup key alist)
  (let ((g0030 (assoc key alist)))
    (if g0030
        (cdr g0030)
        #f)))
```

Write macro definitions for `let` and `cond` allowing these variations.

**Exercise  22.9 [h]** Some Scheme implementations permit `define` statements inside the body of a `lambda` (and thus of a `define`, `let`, `let*`, or `letrec` as well).
Here is an example:

```lisp
(define (length l)
  (define (len l n)
```

`    (if (null?
l) n (len (cdr l) (+ n 1))))`

```lisp
  (len l 0))
```

The internal definition of len is interpreted not as defining a global name but rather as defining a local name as if with `letrec`.
The above definition is equivalent to:

```lisp
(define (length l)
  (letrec ((len (lambda (l n)
```

`                      (if (null?
l) n (len (cdr l) (+ n 1))))))`

```lisp
    (len l 0)))
```

Make changes to the interpreter to allow this kind of internal definition.

**Exercise  22.10** Scheme programmers are often disdainful of the `function` or `#`' notation in Common Lisp.
Is it possible (without changing the compiler) to make Common Lisp accept `(lambda ( ) ... )` instead of `#` ' `(lambda ( ) ... )` and `fn` instead of `#`'`fn?`

**Exercise  22.11 [m]** The top level of the continuation-passing version of `scheme` includes the call: `(interp (read)``nil` #'`print)`.
Will this always result in some value being printed?
Or is it possible that the expression read might call some escape function that ignores the value without printing anything?

**Exercise  22.12 [h]** What would have to be added or changed to turn the Scheme interpreter into a Common Lisp interpreter?

**Exercise  22.13 [h]** How would you change the interpreter to allow for multiple values?
Explain how this would be done both for the first version of the interpreter and for the continuation-passing version.

## 22.8 Ответы

**Answer 22.2** Невозможно реализовать полный `call/cc` для Common Lisp, но следующее работает для случаев, когда продолжение используется только с динамическим экстентом:

```lisp
(defun call/cc (cc computation)
  "Make the continuation accessible to a Scheme procedure."
  (funcall computation cc
           ;; Package up CC into a Scheme function:
           #'(lambda (cont val)
               (declare (ignore cont))
               (funcall cc val))))
```

**Answer 22.3** No.
`fail` requires continuations with dynamic extent.

**Answer 22.5** We need only modify `extend` - `env` to know about an atomic `vars` list.
While we're at it, we might as well add some error checking:

```lisp
(defun extend-env (vars vals env)
  "Add some variables and values to an environment."
  (cond ((null vars)
          (assert (null vals) ( ) "Too many arguments supplied")
          env)
          ((atom vars)
            (cons (list vars vals) env))
          (t (assert (rest vals) ( ) "Too few arguments supplied")
              (cons (list (first vars) (first vals))
                      (extend-env (rest vars) (rest vals) env)))))
```

**Answer 22.6** Storing the environment as an association list, `((*var val*)...)`, makes it easy to look up variables with `assoc`.
We could save one cons cell per variable just by changing to `((*var* . *val*)...)`.
But even better is to switch to a different representation, one presented by Steele and Sussman in *The Art of the Interpreter* (1978).
In this representation we switch from a single list of var/val pairs to a list of frames, where each frame is a var-list/val-list pair.
It looks like this:

```lisp
(((*var*...) . (*val*...))
  ((*var*...) . (*val*...))
...)
```

Now `extend-env` is trivial:

```lisp
(defun extend-env (vars vals env)
  "Add some variables and values to an environment."
  (nconc (mapcar #'list vars vals) env))
```

The advantage of this approach is that in most cases we already have a list of variables (the procedure's parameter list) and values (from the `mapcar` of `interp` over the arguments).
So it is cheaper to just cons these two lists together, rather than arranging them into pairs.
Of course, `get-var` and `set-var`!
become more complex.

**Answer 22.7** One answer is to destructively alter the source code as it is macro-expanded, so that the next time the source code is interpreted, it will already be expanded.
The following code takes care of that:

```lisp
(defun scheme-macro-expand (x)
  (displace x (apply (scheme-macro (first x)) (rest x))))
(defun displace (old new)
  "Destructively change old cons-cell to new value."
  (if (consp new)
        (progn (setf (car old) (car new))
                      (setf (cdr old) (cdr new))
                      old)
        (displace old '(begin ,new))))
```

One drawback to this approach is that the user's source code is actually changed, which may make debugging confusing.
An alternative is to expand into something that keeps both the original and macro-expanded code around:

```lisp
(defun displace (old new)
  "Destructively change old to a DISPLACED structure."
  (setf (car old) 'DISPLACED)
  (setf (cdr old) (list new old))
  old)
```

This means that `DISPLACED` is a new special form, and we need a clause for it in the interpreter.
It would look something like this:

```lisp
(case (first x)
  ...
  (DISPLACED (interp (second x) env))
  ...
```

We'd also need to modify the printing routines to print just `old` whenever they see `(displaced old new)`.

**Answer 22.8**

```lisp
(def-scheme-macro let (vars &rest body)
  (if (symbolp vars)
        ;; named let
        (let ((f vars) (vars (first body)) (body (rest body)))
          '(letrec ((,f (lambda ,(mapcar #'first vars) .,body)))
                (,f .,(mapcar #'second vars))))
        ;; "regular" let
        '((lambda ,(mapcar #'first vars) . ,body)
```

`          .
,(mapcar #'second vars)))))`

```lisp
(def-scheme-macro cond (&rest clauses)
  (cond ((null clauses) nil)
        ((length=1 (first clauses))
         `(or ,(first clauses) (cond .,(rest clauses))))
        ((starts-with (first clauses) 'else)
         `(begin .,(rest (first clauses))))
        ((eq (second (first clauses)) '=>)
            (assert (= (length (first clauses)) 3))
            (let ((var (gensym)))
            '(let ((,var ,(first (first clauses))))
                (if ,var (,(third (first clauses)) ,var)
                          (cond .,(rest clauses))))))
        (t `(if ,(first (first clauses))
                (begin .,(rest (first clauses)))
                (cond .,(rest clauses))))))
```

**Answer 22.10** It is easy to define `lambda` as a macro, eliminating the need for `#'(lambda ...)`:

```lisp
(defmacro lambda (args &rest body)
  '(function (lambda .args .@body)))
```

If this were part of the Common Lisp standard, I would gladly use it.
But because it is not, I have avoided it, on the grounds that it can be confusing.

It is also possible to write a new function-defining macro that would do the following type of expansion:

```lisp
(defn double (x) (* 2 x)) =>
(defparameter double (defun double (x) (* 2 x)))
```

This makes `double` a special variable, so we can write `double` instead of `#'double`.
But this approach is not recommended-it is dangerous to define special variables that violate the asterisk convention, and the Common Lisp compiler may not be able to optimize special variable references the way it can `function` special forms.
Also, this approach would not interact properly with `flet` and `labels`.

----------------------

[1](#xfn0010) One writes `numberp` because there is no hyphen in `number` but `random-state-p` because there is a hyphen in `random-state`.
However, `defstruct` concatenates `-p` in all its predicates, regardless of the presence of a hyphen in the structure's name.
!!!(p) {:.ftnote1}

[2](#xfn0015) although inefficient
!!!(p) {:.ftnote1}

[3](#xfn0020) McCarthy's words from a talk on the history of Lisp, 1974, recorded by [Stoyan (1984)](B9780080571157500285.xhtml#bb1205).
!!!(p) {:.ftnote1}