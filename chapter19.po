#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter19.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-03-04 09:15+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter19.md:3
msgid ""
"# Chapter 19\n"
"## Introduction to Natural Language"
msgstr ""
"# Глава 19\n"
"## Введение в естественный язык"

#: in/chapter19.md:8
msgid ""
"> Language is everywhere.\n"
"It permeates our thoughts mediates our relations with others, and even "
"creeps into our dreams.\n"
"The overwhelming bulk of human knowledge is stored and transmitted in "
"language.\n"
"Language is so ubiquitous that we take it for granted but without it, "
"society as we know it would be impossible."
msgstr ""
"> Язык везде.\n"
"Он проникает в наши мысли, опосредует наши отношения с другими людьми и даже "
"проникает в наши мечты.\n"
"Подавляющая часть человеческих знаний хранится и передается на языке.\n"
"Язык настолько распространен, что мы принимаем его как должное, но без него "
"общество, которое мы знаем, было бы невозможно."

#: in/chapter19.md:10
msgid "> -Ronand Langacker"
msgstr ""

#: in/chapter19.md:12
msgid "> Language and its Structure (1967)"
msgstr "> Language and its Structure(Язык и его структура) (1967)"

#: in/chapter19.md:19
msgid ""
"Anatural language is a language spoken by people, such as English, German, "
"or Tagalog.\n"
"This is in opposition to artificial languages like Lisp, FORTRAN, or Morse "
"code.\n"
"Natural language processing is an important part of AI because language is "
"intimately connected to thought.\n"
"One measure of this is the number of important books that mention language "
"and thought in the title: in AI, Schank and Colby's *Computer Models of "
"Thought and Language;* in linguistics, Whorf's *Language, Thought, and "
"Reality* (and Chomsky's *Language and Mind;)* in philosophy, Fodor's *The "
"Language of Thought;* and in psychology, Vygotsky's *Thought and Language* "
"and John Anderson's *Language, Memory, and Thought.* Indeed, language is the "
"trait many think of as being the most characteristic of humans.\n"
"Much controversy has been generated over the question of whether animais, "
"especially primates and dolphins, can use and \"understand\" language.\n"
"Similar controversy surrounds the same question asked of computers."
msgstr ""
"Естественный язык - это язык, на котором говорят люди, например английский, "
"немецкий или тагальский.\n"
"Они противопоставляются искусственным языкам, таким как Lisp, FORTRAN или "
"код Морзе.\n"
"Обработка естественного языка - важная часть ИИ, потому что язык тесно "
"связан с мыслью.\n"
"Одним из показателей этого является количество важных книг, в названии "
"которых упоминаются язык и мысль: в ИИ - *Компьютерные модели мысли и языка* "
"Шэнка и Колби; в лингвистике - *Язык, мышление и реальность* Уорфа (и "
"Хомского *Язык и разум;)* в философии - *Язык мышления* Фодора; в психологии "
"- *Мысль и язык* Выготского и *Язык, память и мысль* Джона Андерсона. "
"Действительно, язык - это черта, которую многие считают наиболее характерный "
"для людей.\n"
"Много споров вызвал вопрос о том, могут ли животные, особенно приматы и "
"дельфины, использовать и \"понимать\" язык.\n"
"Подобный спор связан с тем же вопросом, который задают о компьютерах."

#: in/chapter19.md:24
msgid ""
"The study of language has been traditionally separated into two broad "
"classes: syntax, or grammar, and semantics, or meaning.\n"
"Historically, syntax has achieved the most attention, largely because on the "
"surface it is more amenable to formai and semiformal methods.\n"
"Although there is evidence that the boundary between the two is at best "
"fuzzy, we still maintain the distinction for the purposes of these notes.\n"
"We will cover the \"easier\" part, syntax, first, and then move on to "
"semantics."
msgstr ""
"Изучение языка традиционно делится на два широких класса: синтаксис, или "
"грамматика, и семантика, или значение.\n"
"Исторически синтаксис привлекал к себе наибольшее внимание, в основном "
"потому, что на первый взгляд он более податлив для формальных и "
"полуформальных методов.\n"
"Хотя есть свидетельства того, что граница между ними в лучшем случае "
"нечеткая, мы по-прежнему сохраняем различие для целей этих заметок.\n"
"Сначала мы рассмотрим \"более простую\" часть, синтаксис, а затем перейдем к "
"семантике."

#: in/chapter19.md:29
msgid ""
"A good artificial language, like Lisp or C, is unambiguous.\n"
"There is only one interpretation for a valid Lisp expression.\n"
"Of course, the interpretation may depend on the state of the current state "
"of the Lisp world, such as the value of global variables.\n"
"But these dependencies can be explicitly enumerated, and once they are "
"spelled out, then there can only be one meaning for the expression.[1]"
"(#fn0015)"
msgstr ""
"Хороший искусственный язык, такой как Лисп или Си, однозначен.\n"
"Есть только одна интерпретация действительного выражения Лиспа.\n"
"Конечно, интерпретация может зависеть от текущего состояния мира Лиспа, "
"такого как значение глобальных переменных.\n"
"Но эти зависимости можно перечислить явно, и как только они будут прописаны, "
"выражение может иметь только одно значение. [1](#fn0015)"

#: in/chapter19.md:34
msgid ""
"Natural language does not work like this.\n"
"Natural expressions are inherently ambiguous, depending on any number of "
"factors that can never be quite spelled out completely.\n"
"It is perfectly reasonable for two people to disagree on what some other "
"person meant by a natural language expression.\n"
"(Lawyers and judges make their living largely by interpreting natural "
"language expressions-laws-that are meant to be unambiguous but are not.)"
msgstr ""
"Естественный язык так не работает.\n"
"Естественные выражения по своей природе неоднозначны, в зависимости от "
"множества факторов, которые невозможно описать полностью.\n"
"Совершенно разумно, чтобы два человека не пришли к согласию относительно "
"того, что другой человек имел в виду под выражением естественного языка.\n"
"(Адвокаты и судьи зарабатывают себе на жизнь в основном интерпретацией "
"выражений на естественном языке - законов, которые должны быть "
"недвусмысленными, но это не так.)"

#: in/chapter19.md:37
msgid ""
"This chapter is a brief introduction to natural language processing.\n"
"The next chapter gives a more thorough treatment from the point of view of "
"logic grammars, and the chapter after that puts it all together into a full-"
"fledged system."
msgstr ""
"Эта глава представляет собой краткое введение в обработку естественного "
"языка.\n"
"В следующей главе дается более подробное рассмотрение с точки зрения "
"логических грамматик, а в следующей главе все это сведено воедино в "
"полноценную систему."

#: in/chapter19.md:39
msgid "## 19.1 Parsing with a Phrase-Structure Grammar"
msgstr "## 19.1 Разбор с помощью грамматики фразовой структуры"

#: in/chapter19.md:44
msgid ""
"To parse a sentence means to recover the constituent structure of the "
"sentence-to discover what sequence of generation rules could have been "
"applied to come up with the sentence.\n"
"In general, there may be several possible derivations, in which case we say "
"the sentence is grammatically ambiguous.\n"
"In certain circles, the term \"parse\" means to arrive at an understanding "
"of a sentence's meaning, not just its grammatical form.\n"
"We will attack that more difficult question later."
msgstr ""
"Анализировать предложение означает восстанавливать составную структуру "
"предложения - выяснять, какая последовательность правил генерации могла быть "
"применена, чтобы составить предложение.\n"
"В общем, может быть несколько возможных путях вывода(производных), и в этом "
"случае мы говорим, что предложение грамматически неоднозначно.\n"
"В определенных кругах термин \"parse/синтаксический анализ\" означает "
"достижение понимания значения предложения, а не только его грамматической "
"формы.\n"
"Позже мы ответим на этот более сложный вопрос."

#: in/chapter19.md:46
msgid ""
"We start with the grammar defined on [page 39](B9780080571157500029."
"xhtml#p39) for the generate program:"
msgstr ""
"Начнем с грамматики, определенной на [стр. 39](B9780080571157500029."
"xhtml#p39) для программы generate(создания):"

#: in/chapter19.md:49
msgid ""
"```lisp\n"
"(defvar *grammar* nil \"The grammar used by GENERATE.\")"
msgstr ""

#: in/chapter19.md:58
msgid ""
"(defparameter *grammarl*\n"
"      '((Sentence -> (NP VP))\n"
"          (NP -> (Art Noun))\n"
"          (VP -> (Verb NP))\n"
"          (Art -> the a)\n"
"          (Noun -> man ball woman table)\n"
"          (Verb -> hit took saw liked)))\n"
"```"
msgstr ""

#: in/chapter19.md:62
msgid ""
"Our parser takes as input a list of words and returns a structure containing "
"the parse tree and the unparsed words, if any.\n"
"That way, we can parse the remaining words under the next category to get "
"compound rules.\n"
"For example, in parsing \"the man saw the table,\" we would first parse "
"\"the man,\" returning a structure representing the noun phrase, with the "
"remaining words \"saw the table.\" This remainder would then be parsed as a "
"verb phrase, returning no remainder, and the two phrases could then be "
"joined to form a parse that is a complete sentence with no remainder."
msgstr ""
"Наш синтаксический анализатор принимает на вход список слов и возвращает "
"структуру, содержащую дерево синтаксического анализа и непроанализированные "
"слова, если таковые имеются.\n"
"Таким образом, мы можем проанализировать оставшиеся слова в следующей "
"категории, чтобы получить составные правила.\n"
"Например, при синтаксическом анализе \"the man saw the table\"(человек "
"увидел таблицу/стол) мы сначала проанализируем \"the man\"(мужчина/человек), "
"вернув стрктуру, представляющую именную фразу(noun phrase), с оставшимися "
"словами \"saw the table.(увидел стол). Этот остаток затем будет "
"проанализирован как глагольная фраза(verb phrase), не возвращая остатка, и "
"две фразы затем могут быть объединены в форму синтаксического анализа, "
"который является полным предложением без остатка."

#: in/chapter19.md:71
msgid ""
"Before proceeding, I want to make a change in the representation of grammar "
"rules.\n"
"Currently, rules have a left-hand side and a list of alternative right-hand "
"sides.\n"
"But each of these alternatives is really a separate rule, so it would be "
"more modular to write them separately.\n"
"For the `generate` program it was fine to have them all together, because "
"that made processing choices easier, but now I want a more flexible "
"representation.\n"
"Later on we will want to add more information to each rule, like the "
"semantics of the assembled left-hand side, and constraints between "
"constituents on the right-hand side, so the rules would become quite large "
"indeed if we didn't split up the alternatives.\n"
"I also take this opportunity to clear up the confusion between words and "
"category symbols.\n"
"The convention is that a right-hand side can be either an atom, in which "
"case it is a word, or a list of symbols, which are then all interpreted as "
"categories.\n"
"To emphasize this, I include \"noun\" and \"verb\" as nouns in the grammar "
"`*grammar3*`, which is otherwise equivalent to the previous `*grammarl*`."
msgstr ""
"Прежде чем продолжить, я хочу изменить представление правил грамматики.\n"
"В настоящее время правила имеют левую часть и список альтернативных правых "
"частей.\n"
"Но каждая из этих альтернатив - это действительно отдельное правило, поэтому "
"было бы более модульным писать их отдельно.\n"
"Для программы `generate` было нормально иметь их все вместе, потому что это "
"облегчало выбор обработки, но теперь мне нужно более гибкое представление.\n"
"Позже мы захотим добавить дополнительную информацию к каждому правилу, такую ​​"
"как семантика собранной левой части и ограничения между составляющими в "
"правой части, так что правила действительно стали бы довольно большими, если "
"бы мы не разделились. альтернативы.\n"
"Я также пользуюсь этой возможностью, чтобы прояснить путаницу между словами "
"и символами категорий.\n"
"По соглашению правая часть может быть либо атомом, и в этом случае это "
"слово, либо списком символов, которые затем все интерпретируются как "
"категории.\n"
"Чтобы подчеркнуть это, я включил \"noun\"(существительное) и \"verb"
"\"(глагол) как существительные в грамматику `*grammar3*`, которая в "
"остальном эквивалентна предыдущей `*grammarl*`."

#: in/chapter19.md:81
msgid ""
"```lisp\n"
"(defparameter *grammar3*\n"
"  '((Sentence -> (NP VP))\n"
"    (NP -> (Art Noun))\n"
"    (VP -> (Verb NP))\n"
"    (Art -> the) (Art -> a)\n"
"    (Noun -> man) (Noun -> ball) (Noun -> woman) (Noun -> table)\n"
"    (Noun -> noun) (Noun -> verb)\n"
"    (Verb -> hit) (Verb -> took) (Verb -> saw) (Verb -> liked)))"
msgstr ""

#: in/chapter19.md:84
msgid ""
"(setf *grammar* *grammar3*)\n"
"```"
msgstr ""

#: in/chapter19.md:88
msgid ""
"I also define the data types `rule, parse`, and `tree`, and some functions "
"for getting at the rules.\n"
"Rules are defined as structures of type list with three slots: the left-hand "
"side, the arrow (which should always be represented as the literal ->) and "
"the right-hand side.\n"
"Compare this to the treatment on [page 40](B9780080571157500029.xhtml#p40)."
msgstr ""
"Я также определяю типы данных `rule, parse` и `tree`, а также некоторые "
"функции для доступа к правилам.\n"
"Rule(Правила) определены как структуры типа list(списка) с тремя слотами: "
"левая сторона, стрелка (которая всегда должна быть представлена как литерал -"
">) и правая сторона.\n"
"Сравните это с трактовкой на [стр. 40](B9780080571157500029.xhtml#p40)."

#: in/chapter19.md:91
msgctxt "in/chapter19.md:91"
msgid ""
"```lisp\n"
"(defstruct (rule (:type list)) lhs -> rhs sem)"
msgstr ""

#: in/chapter19.md:93
msgid "(defstruct (parse) \"A parse tree and a remainder.\" tree rem)"
msgstr ""

#: in/chapter19.md:98
msgid ""
";; Trees are of the form: (lhs . rhs)\n"
"(defun new-tree (cat rhs) (cons cat rhs))\n"
"(defun tree-lhs (tree) (first tree))\n"
"(defun tree-rhs (tree) (rest tree))"
msgstr ""

#: in/chapter19.md:100
msgid "(defun parse-lhs (parse) (tree-lhs (parse-tree parse)))"
msgstr ""

#: in/chapter19.md:105
msgid ""
"(defun lexical-rules (word)\n"
"  \"Return a list of rules with word on the right hand side.\"\n"
"  (or (find-all word *grammar* :key #'rule-rhs :test #'equal)\n"
"      (mapcar #'(lambda (cat) `(,cat -> ,word)) *open-categories*)))"
msgstr ""

#: in/chapter19.md:110
msgid ""
"(defun rules-starting-with (cat)\n"
"  \"Return a list of rules where cat starts the rhs.\"\n"
"  (find-all cat *grammar*\n"
"            :key #'(lambda (rule) (first-or-nil (rule-rhs rule)))))"
msgstr ""

#: in/chapter19.md:115
msgid ""
"(defun first-or-nil (x)\n"
"  \"The first element of x if it is a list; else nil.\"\n"
"  (if (consp x) (first x) nil))\n"
"```"
msgstr ""

#: in/chapter19.md:120
msgid ""
"Now we're ready to define the parser.\n"
"The main function parser takes a list of words to parse.\n"
"It calls parse, which returns a list of all parses that parse some "
"subsequence of the words, starting at the beginning.\n"
"parser keeps only the parses with no remainder-that is, the parses that span "
"all the words."
msgstr ""
"Теперь мы готовы определить парсер.\n"
"Синтаксический анализатор(parser) основной функции принимает список слов для "
"анализа.\n"
"Она вызывает синтаксический анализ(parse), которая возвращает список всех "
"синтаксических анализов, которые анализируют некоторую подпоследовательность "
"слов, начиная с начала.\n"
"parser сохраняет только синтаксический анализ без остатка, то есть "
"синтаксический анализ, охватывающий все слова."

#: in/chapter19.md:125
msgid ""
"```lisp\n"
"(defun parser (words)\n"
"  \"Return all complete parses of a list of words.\"\n"
"  (mapcar #'parse-tree (complete-parses (parse words))))"
msgstr ""

#: in/chapter19.md:130
msgid ""
"(defun complete-parses (parses)\n"
"  \"Those parses that are complete (have no remainder).\"\n"
"  (find-all-if #'null parses :key #'parse-rem))\n"
"```"
msgstr ""

#: in/chapter19.md:135
msgid ""
"The function parse looks at the first word and considers each category it "
"could be.\n"
"It makes a parse of the first word under each category, and calls extend - "
"parse to try to continue to a complete parse.\n"
"parse uses mapcan to append together all the resulting parses.\n"
"As an example, suppose we are trying to parse \"the man took the ball.\" pa "
"rse would find the single lexical rule for \"the\" and call extend-parse "
"with a parse with tree (Art the) and remainder \"man took the ball,\" with "
"no more categories needed."
msgstr ""
"Функция parse смотрит на первое слово и рассматривает каждую категорию, в "
"которую оно может входить.\n"
"Она выполняет синтаксический анализ первого слова в каждой категории и "
"вызывает `extend-parse`, чтобы попытаться продолжить полный синтаксический "
"анализ.\n"
"parse использует `mapcan` для объединения всех результатов синтаксического "
"анализа.\n"
"В качестве примера предположим, что мы пытаемся разобрать \"the man took the "
"ball.\"(мужчина взял мяч). parse найдет единственное лексическое правило для "
"\"the\" и вызовет extend-parse с синтаксическим анализом с tree (Art the) и "
"остатком \"man took the ball\" без дополнительных категорий."

#: in/chapter19.md:143
msgid ""
"`extend-parse` has two cases.\n"
"If the partial parse needs no more categories to be complete, then it "
"returns the parse itself, along with any parses that can be formed by "
"extending parses starting with the partial parse.\n"
"In our example, there is one rule starting with `Art`, namely `(NP -> (Art "
"Noun))`, so the function would try to extend the parse tree (`NP (Art the))` "
"with remainder \"man took the ball,\" with the category `Noun` needed.\n"
"That call to `extend-parse` represents the second case.\n"
"We first parse \"man took the ball,\" and for every parse that is of "
"category `Noun` (there will be only one), we combine with the partial "
"parse.\n"
"In this case we get `(NP (Art the) (Noun man))`.\n"
"This gets extended as a sentence with a VP needed, and eventually we get a "
"parse of the complete list of words."
msgstr ""
"У `extend-parse` есть два случая.\n"
"Если для частичного синтаксического анализа не требуется больше категорий, "
"он возвращает сам синтаксический анализ вместе с любыми анализами, которые "
"могут быть сформированы путем расширения синтаксических анализов, начиная с "
"частичного анализа.\n"
"В нашем примере есть одно правило, начинающееся с `Art`, а именно `(NP -> "
"(Art Noun))`, поэтому функция будет пытаться расширить дерево "
"синтаксического анализа (`NP (Art the))` с остатком \"man took the ball\" с "
"категорией существительного(`Noun`).\n"
"Вызов метода `extension-parse` представляет собой второй случай.\n"
"Сначала мы анализируем \"man took the ball,\", и для каждого синтаксического "
"анализа, относящегося к категории `Noun`(Существительное) (будет только "
"один), мы объединяем его с частичным синтаксическим анализом.\n"
"В этом случае мы получаем `(NP (Art the) (Noun man))`.\n"
"Это расширяется как предложение с необходимым VP, и в конечном итоге мы "
"получаем синтаксический анализ полного списка слов."

#: in/chapter19.md:152
msgid ""
"```lisp\n"
"(defun parse (words)\n"
"  \"Bottom-up parse, returning all parses of any prefix of words.\"\n"
"  (unless (null words)\n"
"    (mapcan #'(lambda (rule)\n"
"                (extend-parse (rule-lhs rule) (list (first words))\n"
"                              (rest words) nil))\n"
"            (lexical-rules (first words)))))"
msgstr ""

#: in/chapter19.md:173
msgid ""
"(defun extend-parse (lhs rhs rem needed)\n"
"  \"Look for the categories needed to complete the parse.\"\n"
"  (if (null needed)\n"
"      ;; If nothing needed, return parse and upward extensions\n"
"      (let ((parse (make-parse :tree (new-tree lhs rhs) :rem rem)))\n"
"        (cons parse\n"
"              (mapcan\n"
"                #'(lambda (rule)\n"
"                    (extend-parse (rule-lhs rule)\n"
"                                  (list (parse-tree parse))\n"
"                                  rem (rest (rule-rhs rule))))\n"
"                (rules-starting-with lhs))))\n"
"      ;; otherwise try to extend rightward\n"
"      (mapcan\n"
"        #'(lambda (p)\n"
"            (if (eq (parse-lhs p) (first needed))\n"
"                (extend-parse lhs (append1 rhs (parse-tree p))\n"
"                              (parse-rem p) (rest needed))))\n"
"        (parse rem))))\n"
"```"
msgstr ""

#: in/chapter19.md:175
msgid "This makes use of the auxiliary function append1:"
msgstr "Это использует вспомогательную функцию append1:"

#: in/chapter19.md:181
msgid ""
"```lisp\n"
"(defun append1 (items item)\n"
"  \"Add item to end of list of items.\"\n"
"  (append items (list item)))\n"
"```"
msgstr ""

#: in/chapter19.md:183
msgid "Some examples of the parser in action are shown here:"
msgstr "Здесь показаны некоторые примеры работы парсера:"

#: in/chapter19.md:196
msgid ""
"```lisp\n"
"> (parser '(the table))\n"
"((NP (ART THE) (NOUN TABLE)))\n"
"> (parser '(the ball hit the table))\n"
"((SENTENCE (NP (ART THE) (NOUN BALL))\n"
"                            (VP (VERB HIT)\n"
"                                      (NP (ARTTHE) (NOUN TABLE)))))\n"
"> (parser '(the noun took the verb))\n"
"((SENTENCE (NP (ART THE) (NOUN NOUN))\n"
"                            (VP (VERB TOOK)\n"
"                                      (NP (ARTTHE) (NOUN VERB)))))\n"
"```"
msgstr ""

#: in/chapter19.md:198
msgid "## 19.2 Extending the Grammar and Recognizing Ambiguity"
msgstr "## 19.2 Расширение грамматики и распознавание двусмысленности"

#: in/chapter19.md:202
msgid ""
"Overall, the parser seems to work fine, but the range of sentences we can "
"parse is quite limited with the current grammar.\n"
"The following grammar includes a wider variety of linguistic phenomena: "
"adjectives, prepositional phrases, pronouns, and proper names.\n"
"It also uses the usual linguistic conventions for category names, summarized "
"in the table below:"
msgstr ""
"В целом, парсер, похоже, работает нормально, но диапазон предложений, "
"которые мы можем разобрать, весьма ограничен текущей грамматикой.\n"
"Следующая грамматика включает более широкий спектр языковых фонем: "
"прилагательные(adjectives), предложные(prepositional) фразы - Устойчивые "
"выражения с предлогами, местоимения(pronouns) и имена собственные(proper "
"names).\n"
"Она также использует обычные лингвистические соглашения для названий "
"категорий, кратко изложенные в таблице ниже:"

#: in/chapter19.md:217
msgid ""
"|      | Category                         | Examples                   |\n"
"|------|----------------------------------|----------------------------|\n"
"| S    | Sentence                         | *John likes Mary*          |\n"
"| NP   | Noun Phrase                      | *John; a blue table*       |\n"
"| VP   | Verb Phrase                      | *likes Mary; hit the ball* |\n"
"| PP   | Prepositional Phrase             | *to Mary; with the man*    |\n"
"| A    | Adjective                        | *little; blue*             |\n"
"| A  + | A list of one or more adjectives | *little blue*              |\n"
"| D    | Determiner                       | *the; a*                   |\n"
"| N    | Noun                             | *ball; table*              |\n"
"| Name | Proper Name                      | *John; Mary*               |\n"
"| P    | Preposition                      | *to; with*                 |\n"
"| Pro  | Pronoun                          | *you; me*                  |\n"
"| V    | Verb                             | *liked; hit*               |"
msgstr ""

#: in/chapter19.md:219
msgid "Here is the grammar:"
msgstr "Вот грамматика:"

#: in/chapter19.md:244
msgid ""
"```lisp\n"
"(defparameter *grammar4*\n"
"  '((S -> (NP VP))\n"
"    (NP -> (D N))\n"
"    (NP -> (D A+ N))\n"
"    (NP -> (NP PP))\n"
"    (NP -> (Pro))\n"
"    (NP -> (Name))\n"
"    (VP -> (V NP))\n"
"    (VP -> (V))\n"
"    (VP -> (VP PP))\n"
"    (PP -> (P NP))\n"
"    (A+ -> (A))\n"
"    (A+ -> (A A+))\n"
"    (Pro -> I) (Pro -> you) (Pro -> he) (Pro -> she)\n"
"    (Pro -> it) (Pro -> me) (Pro -> him) (Pro -> her)\n"
"    (Name -> John) (Name -> Mary)\n"
"    (A -> big) (A -> little) (A -> old) (A -> young)\n"
"    (A -> blue) (A -> green) (A -> orange) (A -> perspicuous)\n"
"    (D -> the) (D -> a) (D -> an)\n"
"    (N -> man) (N -> ball) (N -> woman) (N -> table) (N -> orange)\n"
"    (N -> saw) (N -> saws) (N -> noun) (N -> verb)\n"
"    (P -> with) (P -> for) (P -> at) (P -> on) (P -> by) (P -> of) (P -> "
"in)\n"
"    (V -> hit) (V -> took) (V -> saw) (V -> liked) (V -> saws)))"
msgstr ""

#: in/chapter19.md:247
msgid ""
"(setf *grammar* *grammar4*)\n"
"```"
msgstr ""

#: in/chapter19.md:250
msgid ""
"Now we can parse more interesting sentences, and we can see a phenomenon "
"that was not present in the previous examples: ambiguous sentences.\n"
"The sentence \"The man hit the table with the ball\" has two parses, one "
"where the ball is the thing that hits the table, and the other where the "
"ball is on or near the table, parser finds both of these parses (although of "
"course it assigns no meaning to either parse):"
msgstr ""
"Теперь мы можем разбирать более интересные предложения и можем увидеть "
"явление, которого не было в предыдущих примерах: неоднозначные предложения.\n"
"Предложение \"The man hit the table with the ball\"(\"Человек ударил мячом "
"по столу\") имеет два анализа, в одном из где мяч(ball) - это предмет, "
"который попадает в стол(table), а в другом - когда мяч находится на столе "
"или рядом с ним, синтаксический анализатор находит оба этих анализа (хотя "
"конечно, он не придает никакого значения/смысла ни одному синтаксическому "
"анализу):"

#: in/chapter19.md:261
msgid ""
"```lisp\n"
"> (parser '(The man hit the table with the ball))\n"
"((S (NP (D THE) (N MAN))\n"
"      (VP (VP (V HIT) (NP (D THE) (N TABLE)))\n"
"          (PP (P WITH) (NP (DTHE) (N BALL)))))\n"
"(S (NP (D THE) (N MAN))\n"
"      (VP (V HIT)\n"
"          (NP (NP (D THE) (N TABLE))\n"
"                        (PP (P WITH) (NP (DTHE) (N BALL)))))))\n"
"```"
msgstr ""

#: in/chapter19.md:264
msgid ""
"Sentences are not the only category that can be ambiguous, and not all "
"ambiguities have to be between parses in the same category.\n"
"Here we see a phrase that is ambiguous between a sentence and a noun phrase:"
msgstr ""
"Предложения(Sentences) - не единственная категория, которая может быть "
"неоднозначной, и не все неоднозначности должны быть между синтаксическими "
"анализами в одной и той же категории.\n"
"Здесь мы видим двусмысленную фразу между предложением и фразой "
"существительного(noun phrase):"

#: in/chapter19.md:270
msgid ""
"```lisp\n"
"> (parser '(the orange saw))\n"
"((S (NP (D THE) (N ORANGE)) (VP (V SAW)))\n"
"  (NP (D THE) (A  + (A ORANGE)) (N SAW)))\n"
"```"
msgstr ""

#: in/chapter19.md:272
msgid "## 19.3 More Efficient Parsing"
msgstr "## 19.3 Более эффективный анализ"

#: in/chapter19.md:278
msgid ""
"With more complex grammars and longer sentences, the parser starts to slow "
"down.\n"
"The main problem is that it keeps repeating work.\n"
"For example, in parsing \"The man hit the table with the ball,\" it has to "
"reparse \"with the ball\" for both of the resulting parses, even though in "
"both cases it receives the same analysis, a PP.\n"
"We have seen this problem before and have already produced an answer: "
"memoization (see [section 9.6](#s0035)).\n"
"To see how much memoization will help, we need a benchmark:"
msgstr ""
"При использовании более сложных грамматик и более длинных предложений "
"синтаксический анализатор начинает замедляться.\n"
"Основная проблема в том, что он постоянно повторяет работу.\n"
"Например, при синтаксическом анализе \"The man hit the table with the ball,"
"\"(Человек ударил мячом по столу) он должен повторить анализ \"with the ball"
"\" для обоих результирующих синтаксических анализов, даже если в обоих "
"случаях он получает один и тот же анализ, PP.\n"
"Мы видели эту проблему раньше и уже получили ответ: мемоизация (см. [Раздел "
"9.6](#s0035)).\n"
"Чтобы увидеть, насколько поможет мемоизация, нам нужен тест:"

#: in/chapter19.md:287
msgid ""
"```lisp\n"
"> (setf s (generate 's))\n"
"(THE PERSPICUOUS BIG GREEN BALL BY A BLUE WOMAN WITH A BIG MAN\n"
"    HIT A TABLE BY THE SAW BY THE GREEN ORANGE)\n"
"> (time (length (parser s)))\n"
"Evaluation of (LENGTH (PARSER S)) took 33.11 Seconds of elapsed time.\n"
"10\n"
"```"
msgstr ""

#: in/chapter19.md:290
msgid ""
"The sentence S has 10 parses, since there are two ways to parse the subject "
"NP and five ways to parse the VP.\n"
"It took 33 seconds to discover these 10 parses with the parse function as it "
"was written."
msgstr ""
"Предложение S имеет 10 синтаксических разборов, поскольку есть два способа "
"синтаксического анализа подлежащего NP и пять способов синтаксического "
"анализа VP.\n"
"На обнаружение этих 10 синтаксических анализов с помощью функции "
"синтаксического анализа в том виде, в котором она была написана, "
"потребовалось 33 секунды."

#: in/chapter19.md:293
msgid ""
"We can improve this dramatically by memoizing parse (along with the table- "
"lookup functions).\n"
"Besides memoizing, the only change is to clear the memoization table within "
"parser."
msgstr ""
"Мы можем значительно улучшить это, запомнив синтаксический анализ (вместе с "
"функциями поиска по таблице).\n"
"Помимо мемоизации, единственное изменение - очистить таблицу мемоизации в "
"парсере."

#: in/chapter19.md:298
msgid ""
"```lisp\n"
"(memoize 'lexical-rules)\n"
"(memoize 'rules-starting-with)\n"
"(memoize 'parse :test #'eq)"
msgstr ""

#: in/chapter19.md:304
msgid ""
"(defun parser (words)\n"
"  \"Return all complete parses of a list of words.\"\n"
"  (clear-memoize 'parse) ;***\n"
"  (mapcar #'parse-tree (complete-parses (parse words))))\n"
"```"
msgstr ""

#: in/chapter19.md:309
msgid ""
"In normal human language use, memoization would not work very well, since "
"the interpretation of a phrase depends on the context in which the phrase "
"was uttered.\n"
"But with context-f ree grammars we have a guarantee that the context cannot "
"af f ect the interpretation.\n"
"The call `(parse words)` must return all possible parses for the words.\n"
"We are free to choose between the possibilities based on contextual "
"information, but context can never supply a new interpretation that is not "
"in the context-free list of parses."
msgstr ""
"При обычном использовании человеческого языка мемоизация не будет работать "
"очень хорошо, поскольку интерпретация фразы зависит от контекста, в котором "
"она была произнесена.\n"
"Но с контекстно-свободными грамматиками у нас есть гарантия, что контекст не "
"может повлиять на интерпретацию.\n"
"Вызов `(parse words)` должен возвращать все возможные синтаксические разборы "
"слов.\n"
"Мы свободны выбирать между возможностями, основанными на контекстной "
"информации, но контекст никогда не может предоставить новую интерпретацию, "
"которая не входит в контекстно-свободный список синтаксических анализов."

#: in/chapter19.md:311
msgid ""
"The function use is introduced to tell the table-lookup functions that they "
"are out of date whenever the grammar changes:"
msgstr ""
"Функция `use` вводиться, чтобы сообщить функциям поиска в таблице, что они "
"устарели при изменении грамматики:"

#: in/chapter19.md:319
msgid ""
"```lisp\n"
"(defun use (grammar)\n"
"  \"Switch to a new grammar.\"\n"
"  (clear-memoize 'rules-starting-with)\n"
"  (clear-memoize 'lexical-rules)\n"
"  (length (setf *grammar* grammar)))\n"
"```"
msgstr ""

#: in/chapter19.md:321
msgid "Now we run the benchmark again with the memoized version of pa rse:"
msgstr ""
"Теперь мы снова запускаем тест с мемоизированной версией синтаксического "
"анализа:"

#: in/chapter19.md:327
msgid ""
"```lisp\n"
"> (time (length (parser s)))\n"
"Evaluation of (LENGTH (PARSER S 's)) took .13 Seconds of elapsed time.\n"
"10\n"
"```"
msgstr ""

#: in/chapter19.md:333
msgid ""
"By memoizing p a r s e we reduce the parse time f rom 33 to.\n"
"13 seconds, a 250-f old speed- up.\n"
"We can get a more systematic comparison by looking at a range of examples.\n"
"For example, consider sentences of the form \"The man hit the table [with "
"the ball]*\" for zero or more repetitions of the PP \"with the ball.\" In "
"the following table we record N, the number of repetitions of the PP, along "
"with the number of resulting parses,[2](#fn0020) and for both memoized and "
"unmemoized versions of parse, the number of seconds to produce the parse, "
"the number of parses per second (PPS), and the number of recursive calls to "
"`parse`.\n"
"The performance of the memoized version is quite acceptable; for N=5, a 20-"
"word sentence is parsed into 132 possibilities in .68 seconds, as opposed to "
"the 20 seconds it takes in the unmemoized version."
msgstr ""
"Мемоизируя `parse`, мы сокращаем время синтаксического анализа с 33 до 13 "
"секунд, ускорение 250 процентов.\n"
"Мы можем получить более систематическое сравнение, посмотрев на ряд "
"примеров.\n"
"Например, рассмотрите предложения формы \"The man hit the table [with the "
"ball]*\"(Человек ударил по столу [мячом]) для нуля или более повторений PP "
"\"with the ball\"(с мячом). В следующей таблице мы записываем N, количество "
"повторений PP, вместе с количеством результирующих синтаксических анализов, "
"[2](# fn0020) и для мемоизированных и немомизированных версий "
"синтаксического анализа, количество секунд для выполнения синтаксического "
"анализа, количество парсингов в секунду (PPS) и количество рекурсивных "
"вызовов parse.\n"
"Производительность мемоизированной версии вполне приемлема; для N = 5 "
"предложение из 20 слов разбирается на 132 варианта за 0,68 секунды, в "
"отличие от 20 секунд, которые требуются в незапоминающей версии."

#: in/chapter19.md:346
msgid ""
"|      |        | Memoized |     |       | Unmemoized |     |       |\n"
"| N    | Parses | Secs     | PPS | Calls | Secs       | PPS | Calls |\n"
"|------|--------|----------|-----|-------|------------|-----|-------|\n"
"| 0    | 1      | 0.02     | 60  | 4     | 0.02       | 60  | 17    |\n"
"| 1    | 2      | 0.02     | 120 | 11    | 0.07       | 30  | 96    |\n"
"| 2    | 5      | 0.05     | 100 | 21    | 0.23       | 21  | 381   |\n"
"| 3    | 14     | 0.10     | 140 | 34    | 0.85       | 16  | 1388  |\n"
"| 4    | 42     | 0.23     | 180 | 50    | 3.17       | 13  | 4999  |\n"
"| 5    | 132    | 0.68     | 193 | 69    | 20.77      | 6   | 18174 |\n"
"| 6    | 429    | 1.92     | 224 | 91    | -          |     |       |\n"
"| 7    | 1430   | 5.80     | 247 | 116   | -          |     |       |\n"
"| 8    | 4862   | 20.47    | 238 | 144   | -          |     |       |"
msgstr ""

#: in/chapter19.md:349
msgid ""
"**Exercise  19.1 [h]** It seems that we could be more efficient still by "
"memoizing with a table consisting of a vector whose length is the number of "
"words in the input (plus one).\n"
"Implement this approach and see if it entails less overhead than the more "
"general hash table approach."
msgstr ""
"**Упражнение 19.1 [h]** Кажется, что мы могли бы быть более эффективными, "
"если бы запомнили таблицу, состоящую из вектора, длина которого равна "
"количеству слов во входных данных (плюс один).\n"
"Реализуйте этот подход и посмотрите, повлечет ли он меньше накладных "
"расходов, чем более общий подход с хэш-таблицей."

#: in/chapter19.md:351
msgid "## 19.4 The Unknown-Word Problem"
msgstr "## 19.4 Проблема с неизвестным словом"

#: in/chapter19.md:357
msgid ""
"As it stands, the parser cannot deal with unknown words.\n"
"Any sentence containing a word that is not in the grammar will be rejected, "
"even if the program can parse all the rest of the words perfectly.\n"
"One way of treating unknown words is to allow them to be any of the \"open-"
"class\" categories-nouns, verbs, adjectives, and names, in our grammar.\n"
"An unknown word will not be considered as one of the \"closed-class\" "
"categories-prepositions, determiners, or pronouns.\n"
"This can be programmed very simply by having `lexical-rules` return a list "
"of these open-class rules for every word that is not already known."
msgstr ""
"В его нынешнем виде парсер не может работать с неизвестными словами.\n"
"Любое предложение, содержащее слово, которого нет в грамматике, будет "
"отклонено, даже если программа сможет идеально проанализировать все "
"остальные слова.\n"
"Один из способов обращения с неизвестными словами - позволить им быть любой "
"из категорий \"open-class\"(открытого класса) - существительными, глаголами, "
"прилагательными и именами в нашей грамматике.\n"
"Неизвестное слово не будет рассматриваться как одна из категорий \"closed-"
"class\"(закрытого класса) - предлогов, определителей или местоимений.\n"
"Это можно очень просто запрограммировать, заставив `lexical-rules` "
"возвращать список этих правил открытого класса для каждого слова, которое "
"еще не известно."

#: in/chapter19.md:361
msgid ""
"```lisp\n"
"(defparameter *open-categories* '(N V A Name)\n"
"  \"Categories to consider for unknown words\")"
msgstr ""

#: in/chapter19.md:367
msgid ""
"(defun lexical-rules (word)\n"
"  \"Return a list of rules with word on the right hand side.\"\n"
"  (or (find-all word *grammar* :key #'rule-rhs :test #'equal)\n"
"      (mapcar #'(lambda (cat) `(,cat -> ,word)) *open-categories*)))\n"
"```"
msgstr ""

#: in/chapter19.md:370
msgid ""
"With memoization of lexical - rules, this means that the lexicon is expanded "
"every time an unknown word is encountered.\n"
"Let's try this out:"
msgstr ""
"При запоминании лексических правил это означает, что лексикон расширяется "
"каждый раз, когда встречается неизвестное слово.\n"
"Давайте попробуем это:"

#: in/chapter19.md:382
msgid ""
"```lisp\n"
"> (parser '(John liked Mary))\n"
"((S (NP (NAME JOHN))\n"
"            (VP (V LIKED) (NP (NAME MARY)))))\n"
"> (parser '(Dana liked Dale))\n"
"((S (NP (NAME DANA))\n"
"            (VP (V LIKED) (NP (NAME DALE)))))\n"
"> (parser '(the rab zaggled the woogly quax))\n"
"((S (NP (D THE) (N RAB))\n"
"            (VP (V ZAGGLED) (NP (D THE) (A  + (A WOOGLY)) (N QUAX)))))\n"
"```"
msgstr ""

#: in/chapter19.md:386
msgid ""
"We see the parser works as well with words it knows (John and Mary) as with "
"new words (Dana and Dale), which it can recognize as names because of their "
"position in the sentence.\n"
"In the last sentence in the example, it recognizes each unknown word "
"unambiguously.\n"
"Things are not always so straightforward, unfortunately, as the following "
"examples show:"
msgstr ""
"Мы видим, что синтаксический анализатор также работает со словами, которые "
"он знает (Джон и Мэри), так и с новыми словами (Дана и Дейл), которые он "
"может распознавать как имена из-за их положения в предложении.\n"
"В последнем предложении в примере он однозначно распознает каждое "
"неизвестное слово.\n"
"К сожалению, не всегда все так просто, как показывают следующие примеры:"

#: in/chapter19.md:404
msgid ""
"```lisp\n"
"> (parser '(the slithy toves gymbled))\n"
"((S (NP (D THE) (N SLITHY)) (VP (V TOVES) (NP (NAME GYMBLED))))\n"
"  (S (NP (D THE) (A  + (A SLITHY)) (N TOVES)) (VP (V GYMBLED)))\n"
"  (NP (D THE) (A  + (A SLITHY) (A  + (A TOVES))) (N GYMBLED)))\n"
"> (parser '(the slithy toves gymbled on the wabe))\n"
"((S (NP (D THE) (N SLITHY))\n"
"      (VP (VP (V TOVES) (NP (NAME GYMBLED)))\n"
"            PP (P ON) (NP (D THE) (N WABE)))))\n"
"(S (NP (D THE) (N SLITHY))\n"
"      (VP (V TOVES) (NP (NP (NAME GYMBLED))\n"
"            (PP (P ON) (NP (D THE) (N WABE))))))\n"
"(S (NP (D THE) (A  + (A SLITHY)) (N TOVES))\n"
"        (VP (VP (V GYMBLED)) (PP (P ON) (NP (D THE) (N WABE)))))\n"
"(NP (NP (D THE) (A  + (A SLITHY) (A  + (A TOVES))) (N GYMBLED))\n"
"        (PP (P ON) (NP (D THE) (N WABE)))))\n"
"```"
msgstr ""

#: in/chapter19.md:406
msgid ""
"If the program knew morphology-that a *y* at the end of a word often signais "
"an adjective, an *s* a plural noun, and an *ed* a past-tense verb-then it "
"could do much better."
msgstr ""
"Если бы программа знала морфологию - что *y* в конце слова часто означает "
"прилагательное(adjective), *s* - существительное во множественном числе, а "
"*ed* - глагол в прошедшем времени, - тогда он мог бы добиться большего."

#: in/chapter19.md:408
msgid "## 19.5 Parsing into a Semantic Representation"
msgstr "## 19.5 Анализ семантического представления"

#: in/chapter19.md:417
msgid ""
"Syntactic parse trees of a sentence may be interesting, but by themselves "
"they're not very useful.\n"
"We use sentences to communicate ideas, not to display grammatical "
"structures.\n"
"To explore the idea of the semantics, or meaning, of a phrase, we need a "
"domain to talk about.\n"
"Imagine the scenario of a compact dise player capable of playing back "
"selected songs based on their track number.\n"
"Imagine further that this machine has buttons on the front panel indicating "
"numbers, as well as words such as \"play,\" \"to,\" \"and,\" and \"without."
"\" If you then punch in the sequence of buttons \"play 1 to 5 without 3,\" "
"you could reasonably expect the machine to respond by playing tracks 1,2,4, "
"and 5.\n"
"After a few such successful interactions, you might say that the machine "
"\"understands\" a limited language.\n"
"The important point is that the utility of this machine would not be "
"enhanced much if it happened to display a parse tree of the input.\n"
"On the other hand, you would be justifiably annoyed if it responded to "
"\"play 1 to 5 without 3\" by playing 3 or skipping 4."
msgstr ""
"Синтаксические деревья синтаксического разбора предложения могут быть "
"интересными, но сами по себе они не очень полезны.\n"
"Мы используем предложения для передачи идей, а не для отображения "
"грамматических структур.\n"
"Чтобы исследовать идею семантики или значения фразы, нам нужна область для "
"обсуждения.\n"
"Представьте себе сценарий проигрывателя  компакт-дисков, способного "
"воспроизводить выбранные песни на основе их номеров треков.\n"
"Далее представьте, что на передней панели этой машины есть кнопки, "
"обозначающие числа, а также такие слова, как \"play\"(играть), \"to\"(до), "
"\"and\"(и) и \"without\"(без). Если затем вы нажмете последовательность "
"кнопок \"play 1 to 5 without 3\"(воспроизвести с 1 по 5 без 3), можно было "
"бы разумно ожидать, что машина отреагирует воспроизведением треков 1, 2, 4 и "
"5.\n"
"После нескольких таких успешных взаимодействий можно сказать, что машина "
"\"понимает\" ограниченный язык.\n"
"Важным моментом является то, что полезность этой машины не сильно улучшилась "
"бы, если бы она отображала дерево синтаксического анализа входных данных.\n"
"С другой стороны, вы были бы оправданно раздражены, если бы она "
"отреагировала на \"play 1 to 5 without 3\", сыграв 3 или пропустив 4."

#: in/chapter19.md:425
msgid ""
"Now let's stretch the imagination one more time by assuming that this CD "
"player comes equipped with a full Common Lisp compiler, and that we are now "
"in charge of writing the parser for its input language.\n"
"Let's first consider the relevant data structures.\n"
"We need to add a component for the semantics to both the rule and tree "
"structures.\n"
"Once we've done that, it is clear that trees are nothing more than instances "
"of rules, so their definitions should reflect that.\n"
"Thus, I use an : incl ude defstruct to define trees, and I specify no copier "
"function, because copy-tree is already a Common Lisp function, and I don't "
"want to redefine it.\n"
"To maintain consistency with the old new-tree function (and to avoid having "
"to put in all those keywords) I define the constructor new-tree.\n"
"This option to `defstruct makes (new-tree a b c)` equivalent to `(make-tree :"
"lhs a :sem b :rhs c)`."
msgstr ""
"Теперь давайте расширим воображение еще раз, предположив, что этот "
"проигрыватель компакт-дисков оснащен полным компилятором Common Lisp, и что "
"теперь мы отвечаем за написание синтаксического анализатора для его языка "
"ввода.\n"
"Давайте сначала рассмотрим соответствующие структуры данных.\n"
"Нам нужно добавить компонент семантики как в структуру правил, так и в "
"древовидную структуру.\n"
"Как только мы это сделаем, станет ясно, что деревья - это не что иное, как "
"экземпляры правил, поэтому их определения должны это отражать.\n"
"Таким образом, я использую команду: include defstruct для определения "
"деревьев, и я не указываю функцию  копирования, потому что  copy-tree уже "
"является функцией Common Lisp, и я не хочу ее переопределять.\n"
"Чтобы поддерживать согласованность со старой функцией new-tree (и чтобы не "
"вводить все эти ключевые слова), я определяю конструктор `new-tree`.\n"
"Эта опция `defstruct makes (new-tree a b c)` эквивалентна `(make-tree :lhs "
"a :sem b :rhs c)`."

#: in/chapter19.md:428
msgctxt "in/chapter19.md:428"
msgid ""
"```lisp\n"
"(defstruct (rule (:type list)) lhs -> rhs sem)"
msgstr ""

#: in/chapter19.md:432
msgid ""
"(defstruct (tree (:type list) (:include rule) (:copier nil)\n"
"                 (:constructor new-tree (lhs sem rhs))))\n"
"```"
msgstr ""

#: in/chapter19.md:438
msgid ""
"We will adopt the convention that the semantics of a word can be any Lisp "
"object.\n"
"For example, the semantics of the word \"1\" could be the object 1, and the "
"semantics of \"without\" could be the function set-di fference.\n"
"The semantics of a tree is formed by taking the semantics of the rule that "
"generated the tree and applying it (as a function) to the semantics of the "
"constituents of the tree.\n"
"Thus, the grammar writer must insure that the semantic component of rules "
"are functions that expect the right number of arguments.\n"
"For example, given the rule"
msgstr ""
"Мы примем соглашение, согласно которому семантика слова может быть любым "
"объектом Lisp.\n"
"Например, семантика слова \"1\" может быть объектом 1, а семантика \"without"
"\"(без) может быть функцией `set-difference`.\n"
"Семантика дерева формируется путем взятия семантики правила, которое "
"сгенерировало дерево, и ее применения (как функции) к семантике составляющих "
"дерева.\n"
"Таким образом, автор грамматики должен убедиться, что семантический "
"компонент правил - это функции, которые ожидают правильное количество "
"аргументов.\n"
"Например, учитывая правило"

#: in/chapter19.md:442
msgid ""
"```lisp\n"
"(NP -> (NP CONJ NP) infix-funcall)\n"
"```"
msgstr ""

#: in/chapter19.md:446
msgid ""
"then the semantics of the phrase \"1 to 5 without 3\" could be determined by "
"first determining the semantics of\"1 to 5\" tobe(l 2 3 4 5),of\"without"
"\"tobe set-`difference`, and of \"3\" to be (3).\n"
"After these sub-constituents are determined, the rule is applied by calling "
"the function `infix-funcall` with the three arguments (1 2 3 4 5), `set-"
"difference`, and (3).\n"
"Assuming that `infix-funcall` is defined to apply its second argument to the "
"other two arguments, the resuit will be (1 2 4 5)."
msgstr ""
"тогда семантика фразы \"1 to 5 without 3\" может быть определена путем "
"определения сначала семантикой \"1 to 5\"(от 1 до 5) как (1 2 3 4 5), "
"\"without\" как `set-difference` и 3 как (3).\n"
"После того, как эти подкомпоненты определены, правило применяется путем "
"вызова функции `infix-funcall` с тремя аргументами (1 2 3 4 5), `set-"
"difference` и (3).\n"
"Предполагая, что `infix-funcall` определен для применения своего второго "
"аргумента к двум другим аргументам, результат будет (1 2 4 5)."

#: in/chapter19.md:448
msgid ""
"This may make more sense if we look at a complete grammar for the CD player "
"problem:"
msgstr ""
"Это может иметь больше смысла, если мы посмотрим на полную грамматику "
"проблемы с проигрывателем компакт-дисков:"

#: in/chapter19.md:460
msgid ""
"```lisp\n"
"(use\n"
"  '((NP -> (NP CONJ NP) infix-funcall)\n"
"    (NP -> (N)          list)\n"
"    (NP -> (N P N)      infix-funcall)\n"
"    (N ->  (DIGIT)      identity)\n"
"    (P ->  to           integers)\n"
"    (CONJ -> and        ordered-union)\n"
"    (CONJ -> without    ordered-set-difference)\n"
"    (N -> 1 1) (N -> 2 2) (N -> 3 3) (N -> 4 4) (N -> 5 5)\n"
"    (N -> 6 6) (N -> 7 7) (N -> 8 8) (N -> 9 9) (N -> 0 0)))"
msgstr ""

#: in/chapter19.md:465
msgid ""
"(defun integers (start end)\n"
"  \"A list of all the integers in the range [start...end] inclusive.\"\n"
"  (if (> start end) nil\n"
"      (cons start (integers (+ start 1) end))))"
msgstr ""

#: in/chapter19.md:470
msgid ""
"(defun infix-funcall (arg1 function arg2)\n"
"  \"Apply the function to the two arguments\"\n"
"  (funcall function arg1 arg2))\n"
"```"
msgstr ""

#: in/chapter19.md:476
msgid ""
"Consider the first three grammar rules, which are the only nonlexical "
"rules.\n"
"The first says that when two NPs are joined by a conjunction, we assume the "
"translation of the conjunction will be a function, and the translation of "
"the phrase as a whole is derived by calling that function with the "
"translations of the two NPs as arguments.\n"
"The second rule says that a single noun (whose translation should be a "
"number) translates into the singleton list consisting of that number.\n"
"The third rule is similar to the first, but concerns joining Ns rather than "
"NPs.\n"
"The overall intent is that the translation of an NP will always be a list of "
"integers, representing the songs to play."
msgstr ""
"Рассмотрим первые три грамматических правила, которые являются единственными "
"нелексическими правилами.\n"
"Первое говорит, что когда два NP соединяются conjunction(соединением), мы "
"предполагаем, что перевод соединения будет функцией, а перевод фразы в целом "
"получается путем вызова этой функции с переводами двух NP в качестве "
"аргументов.\n"
"Второе правило гласит, что одно существительное (перевод которого должен "
"быть числом) переводится в одноэлементный список, состоящий из этого числа.\n"
"Третье правило похоже на первое, но касается joining(присоединения) Ns, а не "
"NP.\n"
"Общая цель состоит в том, чтобы перевод NP всегда был списком целых чисел, "
"представляющих песни для воспроизведения."

#: in/chapter19.md:480
msgid ""
"As for the lexical rules, the conjunction \"and\" translates to the union "
"function, \"without\" translates to the function that subtracts one set from "
"another, and \"to\" translates to the function that generates a list of "
"integers between two end points.\n"
"The numbers \"0\" to \"9\" translate to themselves.\n"
"Note that both lexical rules like \"`CONJ ->` and\" and nonlexical rules "
"like \"`NP -> (N P N)`\" can have functions as their semantic translations; "
"in the first case, the function will just be returned as the semantic "
"translation, whereas in the second case the function will be applied to the "
"list of constituents."
msgstr ""
"Что касается лексических правил, союз \"and\"(и) переводится в функцию "
"union(объединения), \"without\"(без) переводится в функцию, которая вычитает "
"один набор из другого, а \"to\"(в) переводится в функцию, которая генерирует "
"список целых чисел между двумя конечными точками.\n"
"Цифры от \"0\" до \"9\" переводятся сами в себя.\n"
"Обратите внимание, что как лексические правила, такие как \"`CONJ ->` and\", "
"так и нелексические правила, такие как \"`NP -> (N P N)`\", могут иметь "
"функции в качестве своих семантических переводов; в первом случае функция "
"будет просто возвращена как семантический перевод, тогда как во втором "
"случае функция будет применена к списку составляющих."

#: in/chapter19.md:486
msgid ""
"Only minor changes are needed to pa rse to support this kind of semantic "
"processing.\n"
"As we see in the following, we add a sem argument to extend - parse and "
"arrange to pass the semantic components around properly.\n"
"When we have gathered all the right-hand-side components, we actually do the "
"function application.\n"
"All changes are marked with ***.\n"
"We adopt the convention that the semantic value `nil` indicates failure, and "
"we discard all such parses."
msgstr ""
"Для поддержки такого рода семантической обработки требуются лишь "
"незначительные изменения.\n"
"Как мы увидим ниже, мы добавляем аргумент sem для расширения - "
"синтаксического анализа и упорядочивания для правильной передачи "
"семантических компонентов.\n"
"Когда мы собрали все компоненты с правой стороны, мы фактически выполняем "
"применение(вызов) функции.\n"
"Все изменения отмечены ***.\n"
"Мы принимаем соглашение, согласно которому семантическое значение `nil` "
"указывает на сбой, и отбрасываем все такие синтаксические анализы."

#: in/chapter19.md:496
msgid ""
"```lisp\n"
"(defun parse (words)\n"
"  \"Bottom-up parse, returning all parses of any prefix of words.\n"
"  This version has semantics.\"\n"
"  (unless (null words)\n"
"    (mapcan #'(lambda (rule)\n"
"                (extend-parse (rule-lhs rule) (rule-sem rule) ;***\n"
"                              (list (first words)) (rest words) nil))\n"
"            (lexical-rules (first words)))))"
msgstr ""

#: in/chapter19.md:520
msgid ""
"(defun extend-parse (lhs sem rhs rem needed) ;***\n"
"  \"Look for the categories needed to complete the parse.\n"
"  This version has semantics.\"\n"
"  (if (null needed)\n"
"      ;; If nothing is needed, return this parse and upward extensions,\n"
"      ;; unless the semantics fails\n"
"      (let ((parse (make-parse :tree (new-tree lhs sem rhs) :rem rem)))\n"
"        (unless (null (apply-semantics (parse-tree parse))) ;***\n"
"          (cons parse\n"
"                (mapcan\n"
"                  #'(lambda (rule)\n"
"                      (extend-parse (rule-lhs rule) (rule-sem rule) ;***\n"
"                                    (list (parse-tree parse)) rem\n"
"                                    (rest (rule-rhs rule))))\n"
"                  (rules-starting-with lhs)))))\n"
"      ;; otherwise try to extend rightward\n"
"      (mapcan\n"
"        #'(lambda (p)\n"
"            (if (eq (parse-lhs p) (first needed))\n"
"                (extend-parse lhs sem (append1 rhs (parse-tree p)) ;***\n"
"                              (parse-rem p) (rest needed))))\n"
"        (parse rem))))\n"
"```"
msgstr ""

#: in/chapter19.md:522
msgid "We need to add some new functions to support this:"
msgstr "Нам нужно добавить несколько новых функций для поддержки этого:"

#: in/chapter19.md:532
msgid ""
"```lisp\n"
"(defun apply-semantics (tree)\n"
"  \"For terminal nodes, just fetch the semantics.\n"
"  Otherwise, apply the sem function to its constituents.\"\n"
"  (if (terminal-tree-p tree)\n"
"      (tree-sem tree)\n"
"      (setf (tree-sem tree)\n"
"            (apply (tree-sem tree)\n"
"                   (mapcar #'tree-sem (tree-rhs tree))))))"
msgstr ""

#: in/chapter19.md:537
msgid ""
"(defun terminal-tree-p (tree)\n"
"  \"Does this tree have a single word on the rhs?\"\n"
"  (and (length=1 (tree-rhs tree))\n"
"       (atom (first (tree-rhs tree)))))"
msgstr ""

#: in/chapter19.md:542
msgid ""
"(defun meanings (words)\n"
"  \"Return all possible meanings of a phrase.  Throw away the syntactic part."
"\"\n"
"  (remove-duplicates (mapcar #'tree-sem (parser words)) :test #'equal))\n"
"```"
msgstr ""

#: in/chapter19.md:544
msgid "Here are some examples of the meanings that the parser can extract:"
msgstr "Вот несколько примеров значений, которые может извлечь парсер:"

#: in/chapter19.md:546
msgid "(meanings '(1 to 5 without 3))"
msgstr ""

#: in/chapter19.md:548
msgid "((1 2 4 5))"
msgstr ""

#: in/chapter19.md:550
msgid "(meanings '(1 to 4 and 7 to 9))"
msgstr ""

#: in/chapter19.md:552
msgid "((1 2 3 4 7 8 9))"
msgstr ""

#: in/chapter19.md:554
msgid "(meanings '(1 to 6 without 3 and 4))"
msgstr ""

#: in/chapter19.md:556
msgid "((12 4 5 6)"
msgstr ""

#: in/chapter19.md:558
msgid "(1 2 5 6))"
msgstr ""

#: in/chapter19.md:562
msgid ""
"The example \"(1 to 6 without 3 and 4)\" is ambiguous.\n"
"The first reading corresponds to \"((1 to 6) without 3) and 4,\" while the "
"second corresponds to \"(1 to 6) without (3 and 4).\" The syntactic "
"ambiguity leads to a semantic ambiguity-the two meanings have different "
"lists of numbers in them.\n"
"However, it seems that the second reading is somehow better, in that it "
"doesn't make a lot of sense to talk of adding 4 to a set that already "
"includes it, which is what the first translation does."
msgstr ""
"Пример \"(1 to 6 without 3 and 4)\"-(от 1 до 6 без 3 и 4)  неоднозначен.\n"
"Первое прочтение соответствует \"((1 to 6) without 3) and 4\", а второе "
"соответствует \"(1 to 6) without (3 and 4)\". Синтаксическая неоднозначность "
"приводит к семантической неоднозначности - два значения имеют в себе разные "
"списки чисел.\n"
"Однако кажется, что второе прочтение в чем-то лучше, поскольку не имеет "
"большого смысла говорить о добавлении 4 к набору, который уже включает его, "
"что и делает первый перевод."

#: in/chapter19.md:567
msgid ""
"We can upgrade the lexicon to account for this.\n"
"The following lexicon insists that \"and\" conjoins disjoint sets and that "
"\"without\" removes only elements that were already in the first argument.\n"
"If these conditions do not hold, then the translation will return nil, and "
"the parse will fail.\n"
"Note that this also means that an empty list, such as \"3 to 2,\" will also "
"fail."
msgstr ""
"Мы можем обновить лексикон, чтобы учесть это.\n"
"Следующая лексика утверждает, что \"and\" соединяет непересекающиеся "
"множества и что \"without\" удаляет только элементы, которые уже были в "
"первом аргументе.\n"
"Если эти условия не выполняются, перевод вернет nil, и синтаксический анализ "
"завершится неудачно.\n"
"Обратите внимание, что это также означает, что пустой список, такой как \"3 "
"to 2\"» также не сработает."

#: in/chapter19.md:572
msgid ""
"The previous grammar only allowed for the numbers 0 to 9.\n"
"We can allow larger numbers by stringing together digits.\n"
"So now we have two rules for numbers: a number is either a single digit, in "
"which case the value is the digit itself (the i denti ty function), or it is "
"a number followed by another digit, in which case the value is 10 times the "
"number plus the digit.\n"
"We could alternately have specified a number to be a digit followed by a "
"number, or even a number followed by a number, but either of those "
"formulations would require a more complex semantic interpretation."
msgstr ""
"Предыдущая грамматика допускала только цифры от 0 до 9.\n"
"Мы можем допустить большее число, соединяя цифры вместе.\n"
"Итак, теперь у нас есть два правила для чисел: число - это либо одна цифра, "
"и в этом случае значение является самой цифрой (функция identity), либо это "
"число, за которым следует другая цифра, и в этом случае значение равно 10-"
"кратное число плюс цифра.\n"
"В качестве альтернативы мы могли бы указать число как цифру, за которой "
"следует число, или даже число, за которым следует число, но любая из этих "
"формулировок потребует более сложной семантической интерпретации."

#: in/chapter19.md:587
msgid ""
"```lisp\n"
"(use\n"
"  '((NP -> (NP CONJ NP) infix-funcall)\n"
"    (NP -> (N)          list)\n"
"    (NP -> (N P N)      infix-funcall)\n"
"    (N ->  (DIGIT)      identity)\n"
"    (N ->  (N DIGIT)    10*N+D)\n"
"    (P ->  to           integers)\n"
"    (CONJ -> and        union*)\n"
"    (CONJ -> without    set-diff)\n"
"    (DIGIT -> 1 1) (DIGIT -> 2 2) (DIGIT -> 3 3)\n"
"    (DIGIT -> 4 4) (DIGIT -> 5 5) (DIGIT -> 6 6)\n"
"    (DIGIT -> 7 7) (DIGIT -> 8 8) (DIGIT -> 9 9)\n"
"    (DIGIT -> 0 0)))"
msgstr ""

#: in/chapter19.md:592
msgid ""
"(defun union* (x y) (if (null (intersection x y)) (append x y)))\n"
"(defun set-diff (x y) (if (subsetp y x) (ordered-set-difference x y)))\n"
"(defun 10*N+D (N D) (+ (* 10 N) D))\n"
"```"
msgstr ""

#: in/chapter19.md:594
msgid ""
"With this new grammar, we can get single interpretations out of most "
"reasonable inputs:"
msgstr ""
"С помощью этой новой грамматики мы можем получить единственные интерпретации "
"из наиболее разумных входных данных:"

#: in/chapter19.md:607
msgid ""
"```lisp\n"
"> (meanings '(1 to 6 without 3 and 4))\n"
"((1 2 5 6))\n"
"> (meanings '(1 and 3 to 7 and 9 without 5 and 6))\n"
"((13 4 7 9))\n"
"> (meanings '(1 and 3 to 7 and 9 without 5 and 2))\n"
"((1 3 4 6 7 9 2))\n"
"> (meanings '(1 9 8 to 2 0 1))\n"
"((198 199 200 201))\n"
"> (meanings '(1 2 3))\n"
"(123 (123))\n"
"```"
msgstr ""

#: in/chapter19.md:609
msgid ""
"The example \"1 2 3\" shows an ambiguity between the number 123 and the list "
"(123), but all the others are unambiguous."
msgstr ""
"Пример \"1 2 3\" показывает неоднозначность между числом 123 и списком "
"(123), но все остальные однозначны."

#: in/chapter19.md:611
msgid "## 19.6 Parsing with Preferences"
msgstr "## 19.6 Разбор с Предпочтениями(Preferences)"

#: in/chapter19.md:618
msgid ""
"One reason we have unambiguous interpretations is that we have a very "
"limited domain of interpretation: we are dealing with sets of numbers, not "
"lists.\n"
"This is perhaps typical of the requests faced by a CD player, but it does "
"not account for all desired input.\n"
"For example, if you had a favorite song, you couldn't hear it three times "
"with the request \"1 and 1 and 1\" under this grammar.\n"
"We need some compromise between the permissive grammar, which generated all "
"possible parses, and the restrictive grammar, which eliminates too many "
"parses.\n"
"To get the \"best\" interpretation out of an arbitrary input, we will not "
"only need a new grammar, we will also need to modify the program to compare "
"the relative worth of candidate interpretations.\n"
"In other words, we will assign each interpretation a numeric score, and then "
"pick the interpretation with the highest score."
msgstr ""
"Одна из причин, по которой у нас есть однозначные интерпретации, заключается "
"в том, что у нас очень ограниченная область интерпретации: мы имеем дело с "
"наборами чисел, а не со списками.\n"
"Это, возможно, типично для запросов, с которыми сталкивается проигрыватель "
"компакт-дисков, но не учитывает весь желаемый ввод.\n"
"Например, если у вас была любимая песня, вы не могли услышать ее трижды с "
"запросом \"1 and 1 and 1\" по этой грамматике.\n"
"Нам нужен некоторый компромисс между разрешающей грамматикой, которая "
"генерирует все возможные синтаксические анализы, и ограничительной "
"грамматикой, которая устраняет слишком много синтаксических анализов.\n"
"Чтобы получить \"лучшую\" интерпретацию произвольного ввода, нам потребуется "
"не только новая грамматика, но и модифицировать программу, чтобы сравнить "
"относительную ценность возможных интерпретаций.\n"
"Другими словами, мы присвоим каждой интерпретации числовой балл, а затем "
"выберем интерпретацию с наивысшим баллом."

#: in/chapter19.md:621
msgid ""
"We start by once again modifying the rule and tree data types to include a "
"score component.\n"
"As with the sem component, this will be used to hold first a function to "
"compute a score and then eventually the score itself."
msgstr ""
"Мы начнем с того, что еще раз изменим  правила и дерево типов данных, чтобы "
"включить в них компонент оценки.\n"
"Как и в случае с компонентом sem, он будет использоваться для хранения "
"сначала функции для вычисления оценки, а затем, в конечном итоге, самой "
"оценки."

#: in/chapter19.md:626
msgid ""
"```lisp\n"
"(defstruct (rule (:type list)\n"
"                 (:constructor rule (lhs -> rhs &optional sem score)))\n"
"  lhs -> rhs sem score)"
msgstr ""

#: in/chapter19.md:630
msgid ""
"(defstruct (tree (:type list) (:include rule) (:copier nil)\n"
"                 (:constructor new-tree (lhs sem score rhs))))\n"
"```"
msgstr ""

#: in/chapter19.md:634
msgid ""
"Note that we have added the constructor function rul e.\n"
"The intent is that the sem and score component of grammar rules should be "
"optional.\n"
"The user does not have to supply them, but the function use will make sure "
"that the function rul e is called to fill in the missing sem and score "
"values with nil."
msgstr ""
"Обратите внимание, что мы добавили функцию-конструктор `rule`.\n"
"Намерение состоит в том, что компоненты sem и score в правилах грамматики "
"должны быть необязательными(опциональными).\n"
"Пользователь не обязан их указывать, но использование функции гарантирует, "
"что функция rule будет вызвана для заполнения отсутствующих значений sem и "
"score с помощью nil."

#: in/chapter19.md:644
msgid ""
"```lisp\n"
"(defun use (grammar)\n"
"  \"Switch to a new grammar.\"\n"
"  (clear-memoize 'rules-starting-with)\n"
"  (clear-memoize 'lexical-rules)\n"
"  (length (setf *grammar*\n"
"                (mapcar #'(lambda (r) (apply #'rule r))\n"
"                        grammar))))\n"
"```"
msgstr ""

#: in/chapter19.md:648
msgid ""
"Now we modify the parser to keep track of the score.\n"
"The changes are again minor, and mirror the changes needed to add "
"semantics.\n"
"There are two places where we put the score into trees as we create them, "
"and one place where we apply the scoring function to its arguments."
msgstr ""
"Теперь модифицируем синтаксический анализатор, чтобы отслеживать "
"баллы(score).\n"
"Изменения снова незначительны и отражают изменения, необходимые для "
"добавления семантики.\n"
"Есть два места, где мы помещаем баллы в деревья при их создании, и одно "
"место, где мы применяем функцию подсчета баллов к её аргументам."

#: in/chapter19.md:659
msgid ""
"```lisp\n"
"(defun parse (words)\n"
"  \"Bottom-up parse, returning all parses of any prefix of words.\"\n"
"  This version has semantics and preference scores.\"\n"
"  (unless (null words)\n"
"    (mapcan #'(lambda (rule)\n"
"                (extend-parse (rule-lhs rule) (rule-sem rule)\n"
"                              (rule-score rule) (list (first words)) ;***\n"
"                              (rest words) nil))\n"
"            (lexical-rules (first words)))))"
msgstr ""

#: in/chapter19.md:687
msgid ""
"(defun extend-parse (lhs sem score rhs rem needed) ;***\n"
"  \"Look for the categories needed to complete the parse.\n"
"  This version has semantics and preference scores.\"\n"
"  (if (null needed)\n"
"      ;; If nothing is needed, return this parse and upward extensions,\n"
"      ;; unless the semantics fails\n"
"      (let ((parse (make-parse :tree (new-tree lhs sem score rhs) ;***\n"
"                               :rem rem)))\n"
"        (unless (null (apply-semantics (parse-tree parse)))\n"
"          (apply-scorer (parse-tree parse)) ;***\n"
"          (cons parse\n"
"                (mapcan\n"
"                  #'(lambda (rule)\n"
"                      (extend-parse\n"
"                        (rule-lhs rule) (rule-sem rule)\n"
"                        (rule-score rule) (list (parse-tree parse)) ;***\n"
"                        rem (rest (rule-rhs rule))))\n"
"                  (rules-starting-with lhs)))))\n"
"      ;; otherwise try to extend rightward\n"
"      (mapcan\n"
"        #'(lambda (p)\n"
"            (if (eq (parse-lhs p) (first needed))\n"
"                (extend-parse lhs sem score\n"
"                              (append1 rhs (parse-tree p)) ;***\n"
"                              (parse-rem p) (rest needed))))\n"
"        (parse rem))))\n"
"```"
msgstr ""

#: in/chapter19.md:699
msgid ""
"Again we need some new functions to support this.\n"
"Most important is appl y - scorer, which computes the score for a tree.\n"
"If the tree is a terminal (a word), then the function just looks up the "
"score associated with that word.\n"
"In this grammar all words have a score of 0, but in a grammar with ambiguous "
"words it would be a good idea to give lower scores for infrequently used "
"senses of ambiguous words.\n"
"If the tree is a nonterminal, then the score is computed in two steps.\n"
"First, all the scores of the constituents of the tree are added up.\n"
"Then, this is added to a measure for the tree as a whole.\n"
"The rule associated with each tree will have either a number attached to it, "
"which is added to the sum, or a function.\n"
"In the latter case, the function is applied to the tree, and the resuit is "
"added to obtain the final score.\n"
"As a final special case, if the function returns nil, then we assume it "
"meant to return zero.\n"
"This will simplify the definition of some of the scoring functions."
msgstr ""
"И снова нам нужны новые функции для поддержки этого.\n"
"Самой важной является `apply-scorer`, которая вычисляет баллы для дерева.\n"
"Если дерево является терминалом (словом), тогда функция просто ищет "
"оценку(баллы), связанную с этим словом.\n"
"В этой грамматике все слова имеют оценку 0, но в грамматике с неоднозначными "
"словами было бы неплохо дать более низкие оценки для редко используемых "
"значений неоднозначных слов.\n"
"Если дерево нетерминальное, то оценка(баллы) вычисляется в два этапа.\n"
"Сначала складываются все баллы составляющих дерева.\n"
"Затем это добавляется к мере для дерева в целом.\n"
"Правило, связанное с каждым деревом, будет иметь либо номер, который "
"добавляется к сумме, либо функцию.\n"
"В последнем случае функция применяется к дереву, и результат добавляется для "
"получения окончательной оценки.\n"
"В качестве последнего особого случая, если функция возвращает nil, мы "
"предполагаем, что она должна была вернуть ноль.\n"
"Это упростит определение некоторых функций подсчета очков."

#: in/chapter19.md:714
msgid ""
"```lisp\n"
"(defun apply-scorer (tree)\n"
"  \"Compute the score for this tree.\"\n"
"  (let ((score (or (tree-score tree) 0)))\n"
"    (setf (tree-score tree)\n"
"          (if (terminal-tree-p tree)\n"
"              score\n"
"              ;; Add up the constituent's scores,\n"
"              ;; along with the tree's score\n"
"              (+ (sum (tree-rhs tree) #'tree-score-or-0)\n"
"                 (if (numberp score)\n"
"                     score\n"
"                     (or (apply score (tree-rhs tree)) 0)))))))\n"
"```"
msgstr ""

#: in/chapter19.md:716
msgid "Here is an accessor function to pick out the score from a tree:"
msgstr "Вот функция доступа, позволяющая выбрать баллы из дерева:"

#: in/chapter19.md:721
msgid ""
"```lisp\n"
"(defun tree-score-or-0 (tree)\n"
"    (if (numberp (tree-score tree)) (tree-score tree) 0))\n"
"```"
msgstr ""

#: in/chapter19.md:727
msgid ""
"Here is the updated grammar.\n"
"First, I couldn't resist the chance to add more features to the grammar.\n"
"I added the postnominal adjectives \"shuffled,\" which randomly permutes the "
"list of songs, and \"reversed,\" which reverses the order of play.\n"
"I also added the operator \"repeat,\" as in \"1 to 3 repeat 5,\" which "
"repeats a list a certain number of times.\n"
"I also added brackets to allow input that says explicitly how it should be "
"parsed."
msgstr ""
"Вот обновленная грамматика.\n"
"Во-первых, я не мог отказаться от возможности добавить больше возможностей в "
"грамматику.\n"
"Я добавил постноминальные прилагательные \"shuffled\"(перемешанный), которые "
"случайным образом меняют  список песен, и \"reversed\"(обратный), который "
"меняет порядок воспроизведения на обратный.\n"
"Я также добавил оператор \"repeat\"(повтор), например \"1 to 3 repeat 5\", "
"который повторяет список определенное количество раз.\n"
"Я также добавил скобки, чтобы разрешить ввод, который явно говорит о том, "
"как его следует анализировать."

#: in/chapter19.md:749
msgid ""
"```lisp\n"
"(use\n"
"  '((NP -> (NP CONJ NP) infix-funcall  infix-scorer)\n"
"    (NP -> (N P N)      infix-funcall  infix-scorer)\n"
"    (NP -> (N)          list)\n"
"    (NP -> ([ NP ])     arg2)\n"
"    (NP -> (NP ADJ)     rev-funcall    rev-scorer)\n"
"    (NP -> (NP OP N)    infix-funcall)\n"
"    (N  -> (D)          identity)\n"
"    (N  -> (N D)        10*N+D)\n"
"    (P  -> to           integers       prefer<)\n"
"    ([  -> [            [)\n"
"    (]  -> ]            ])\n"
"    (OP -> repeat       repeat)\n"
"    (CONJ -> and        append         prefer-disjoint)\n"
"    (CONJ -> without    ordered-set-difference prefer-subset)\n"
"    (ADJ -> reversed    reverse        inv-span)\n"
"    (ADJ -> shuffled    permute        prefer-not-singleton)\n"
"    (D -> 1 1) (D -> 2 2) (D -> 3 3) (D -> 4 4) (D -> 5 5)\n"
"    (D -> 6 6) (D -> 7 7) (D -> 8 8) (D -> 9 9) (D -> 0 0)))\n"
"```"
msgstr ""

#: in/chapter19.md:758
msgid ""
"The following scoring functions take trees as inputs and compute bonuses or "
"penalties for those trees.\n"
"The scoring function `prefer  <`, used for the word \"to,\" gives a one-"
"point penalty for reversed ranges: \"5 to 1\" gets a score of -1, while \"1 "
"to 5\" gets a score of 0.\n"
"The scorer for \"and,\" `prefer-disjoint`, gives a one-point penalty for "
"intersecting lists: \"1 to 3 and 7 to 9\" gets a score of 0, while \"1 to 4 "
"and 2 to 5\" gets -1.\n"
"The \"x without y\" scorer, `prefer-subset`, gives a three-point penalty "
"when the y list has elements that aren't in the x list.\n"
"It also awards points in inverse proportion to the length (in words) of the "
"x phrase.\n"
"The idea is that we should prefer to bind \"without\" tightly to some small "
"expression on the left.\n"
"If the final scores corne out as positive or as nonintegers, then this "
"scoring component is responsible, since all the other components are "
"negative intgers.\n"
"The \"x shuffled\" scorer, `prefer-not-singleton`, is similar, except that "
"there the penalty is for shuffling a list of less than two songs."
msgstr ""
"Следующие функции оценки принимают деревья в качестве входных данных и "
"вычисляют бонусы или штрафы для этих деревьев.\n"
"Функция подсчета баллов `prefer<`, используемая для слова \"to\"(к), дает "
"штраф в один балл за обратные диапазоны: \"5 to 1\" получает оценку -1, в то "
"время как \"1 to 5\" получает оценку 0.\n"
"scorer(функция подсчета баллов) для \"and\", `prefer-disjoint`, дает штраф в "
"один балл для пересечения списков: \"1 to 3 and 7 to 9\" получает оценку "
"0(нет пересечения), а \"1 to 4 and 2 to 5\" получает - 1.\n"
"Функция подсчета баллов \"x without y\"(x без y), `prefer-subset`, дает "
"трехочковый штраф, если в списке y есть элементы, которых нет в списке x.\n"
"Она также присуждает очки обратно пропорционально длине (в словах) фразе x.\n"
"Идея в том, что мы должны предпочесть жестко привязать \"without\" к какому-"
"нибудь небольшому выражению слева.\n"
"Если окончательные оценочные баллы оказываются положительными или нецелыми, "
"то ответственным является этот компонент подсчета, поскольку все другие "
"компоненты являются отрицательными целыми числами.\n"
"Функция подсчета баллов \"x shuffled\",  `prefer-not-singleton`, аналогична, "
"за исключением того, что здесь штрафом является перетасовка списка из менее "
"чем двух песен."

#: in/chapter19.md:767
msgid ""
"```lisp\n"
"(defun prefer< (x y) (if (>= (sem x) (sem y)) -1))\n"
"(defun prefer-disjoint (x y) (if (intersection (sem x) (sem y)) -1))\n"
"(defun prefer-subset (x y)\n"
"  (+ (inv-span x) (if (subsetp (sem y) (sem x)) 0 -3)))\n"
"(defun prefer-not-singleton (x)\n"
"  (+ (inv-span x) (if (< (length (sem x)) 2) -4 0)))\n"
"```"
msgstr ""

#: in/chapter19.md:769
msgid ""
"The `infix-scorer` and `rev-scorer` functionsdon'taddanythingnew, they "
"justassure that the previously mentioned scoring functions will get applied "
"in the right place."
msgstr ""
"Функции i`infix-scorer` и `rev-scorer` не добавляют ничего нового, они "
"просто гарантируют, что ранее упомянутые функции подсчета баллов будут "
"применены в нужном месте."

#: in/chapter19.md:773
msgid ""
"```lisp\n"
"(defun infix-scorer (arg1 scorer arg2)\n"
"  (funcall (tree-score scorer) arg1 arg2))"
msgstr ""

#: in/chapter19.md:776
msgid ""
"(defun rev-scorer (arg scorer) (funcall (tree-score scorer) arg))\n"
"```"
msgstr ""

#: in/chapter19.md:778
msgid ""
"Here are the functions mentioned in the grammar, along with some useful "
"utilities:"
msgstr ""
"Вот функции, упомянутые в грамматике, а также некоторые полезные утилиты:"

#: in/chapter19.md:781
msgid ""
"```lisp\n"
"(defun arg2 (a1 a2 &rest a-n) (declare (ignore a1 a-n)) a2)"
msgstr ""

#: in/chapter19.md:783
msgid "(defun rev-funcall (arg function) (funcall function arg))"
msgstr ""

#: in/chapter19.md:789
msgid ""
"(defun repeat (list n)\n"
"  \"Append list n times.\"\n"
"  (if (= n 0)\n"
"      nil\n"
"      (append list (repeat list (- n 1)))))"
msgstr ""

#: in/chapter19.md:794
msgid ""
"(defun span-length (tree)\n"
"  \"How many words are in tree?\"\n"
"  (if (terminal-tree-p tree) 1\n"
"      (sum (tree-rhs tree) #'span-length)))"
msgstr ""

#: in/chapter19.md:796
msgid "(defun inv-span (tree) (/ 1 (span-length tree)))"
msgstr ""

#: in/chapter19.md:798
msgid "(defun sem (tree) (tree-sem tree))"
msgstr ""

#: in/chapter19.md:805
msgid ""
"(defun integers (start end)\n"
"  \"A list of all the integers in the range [start...end] inclusive.\n"
"  This version allows start > end.\"\n"
"  (cond ((< start end) (cons start (integers (+ start 1) end)))\n"
"        ((> start end) (cons start (integers (- start 1) end)))\n"
"        (t (list start))))"
msgstr ""

#: in/chapter19.md:811
msgid ""
"(defun sum (numbers &optional fn)\n"
"  \"Sum the numbers, or sum (mapcar fn numbers).\"\n"
"  (if fn\n"
"      (loop for x in numbers sum (funcall fn x))\n"
"      (loop for x in numbers sum x)))"
msgstr ""

#: in/chapter19.md:819
msgid ""
"(defun permute (bag)\n"
"  \"Return a random permutation of the given input list.\"\n"
"  (if (null bag)\n"
"      nil\n"
"      (let ((e (random-elt bag)))\n"
"        (cons e (permute (remove e bag :count 1 :test #'eq))))))\n"
"```"
msgstr ""

#: in/chapter19.md:821
msgid "We will need a way to show off the preference rankings:"
msgstr "Нам понадобится способ показать рейтинг предпочтений:"

#: in/chapter19.md:830
msgid ""
"```lisp\n"
"(defun all-parses (words)\n"
"  (format t \"~%Score  Semantics~25T~a\" words)\n"
"  (format t \"~%=====  =========~25T============================~%\")\n"
"  (loop for tree in (sort (parser words) #'> :key #'tree-score)\n"
"    do (format t \"~5,1f  ~9a~25T~a~%\" (tree-score tree) (tree-sem tree)\n"
"               (bracketing tree)))\n"
"  (values))"
msgstr ""

#: in/chapter19.md:838
msgid ""
"(defun bracketing (tree)\n"
"  \"Extract the terminals, bracketed with parens.\"\n"
"  (cond ((atom tree) tree)\n"
"        ((length=1 (tree-rhs tree))\n"
"         (bracketing (first (tree-rhs tree))))\n"
"        (t (mapcar #'bracketing (tree-rhs tree)))))\n"
"```"
msgstr ""

#: in/chapter19.md:840
msgid "Now we can try some examples:"
msgstr "Теперь мы можем попробовать несколько примеров:"

#: in/chapter19.md:844
msgid ""
"```\n"
"> (all-parses '(1 to 6 without 3 and 4))\n"
"```"
msgstr ""

#: in/chapter19.md:851
msgid ""
"| []()      |                |                                |\n"
"|-----------|----------------|--------------------------------|\n"
"| `Score`   | `Semantics`    | `(1 TO 6 WITHOUT 3 AND 4)`     |\n"
"| `=======` | `===========`  | `========================`     |\n"
"| `0.3`     | `(12 5 6)`     | `((1 TO 6) WITHOUT (3 AND 4))` |\n"
"| `-0.7`    | `(12 4 5 6 4)` | `(((1 TO 6) WITHOUT 3) AND 4)` |"
msgstr ""

#: in/chapter19.md:855
msgid ""
"```\n"
"> (all-parses '(1 and 3 to 7 and 9 without 5 and 6))\n"
"```"
msgstr ""

#: in/chapter19.md:874
msgid ""
"| []()      |                     "
"|                                                |\n"
"|-----------|---------------------|------------------------------------------------|\n"
"| `Score`   | `Semantics`         | `(1 AND 3 T0 7 AND 9 WITHOUT 5 AND "
"6)`         |\n"
"| `=======` | `===========`       | "
"`=================================`            |\n"
"| `0.2`     | `(1 3 4 7 9)`       | `(1 AND (((3 T0 7) AND 9) WITHOUT (5 AND "
"6)))` |\n"
"| `0.1`     | `(1 3 4 7 9)`       | `(((1 AND (3 T0 7)) AND 9) WITHOUT (5 "
"AND 6))` |\n"
"| `0.1`     | `(1 3 4 7 9)`       | `((1 AND ((3 T0 7) AND 9)) WITHOUT (5 "
"AND 6))` |\n"
"| `-0.8`    | `(1 3 4 6 7 9 6)`   | `((1 AND (((3 T0 7) AND 9) WITHOUT 5)) "
"AND 6)` |\n"
"| `-0.8`    | `(1 3 4 6 7 9 6)`   | `(1 AND ((((3 T0 7) AND 9) WITHOUT 5) "
"AND 6))` |\n"
"| `-0.9`    | `(1 3 4 6 7 9 6)`   | `((((1 AND (3 T0 7)) AND 9) WITHOUT 5) "
"AND 6)` |\n"
"| `-0.9`    | `(1 3 4 6 7 9 6)`   | `(((1 AND ((3 T0 7) AND 9)) WITHOUT 5) "
"AND 6)` |\n"
"| `-2.0`    | `(1 3 4 5 6 7 9)`   | `((1 AND (3 TO 7)) AND (9 WITHOUT (5 AND "
"6)))` |\n"
"| `-2.0`    | `(1 3 4 5 6 7 9)`   | `(1 AND ((3 TO 7) AND (9 WITHOUT (5 AND "
"6))))` |\n"
"| `-3.0`    | `(1 3 4 5 6 7 9 6)` | `(((1 AND (3 TO 7)) AND (9 WITHOUT 5)) "
"AND 6)` |\n"
"| `-3.0`    | `(1 3 4 5 6 7 9 6)` | `((1 AND (3 TO 7)) AND ((9 WITHOUT 5) "
"AND 6))` |\n"
"| `-3.0`    | `(1 3 4 5 6 7 9 6)` | `((1 AND ((3 TO 7) AND (9 WITHOUT 5))) "
"AND 6)` |\n"
"| `-3.0`    | `(1 3 4 5 6 7 9 6)` | `(1 AND (((3 T0 7) AND (9 WITHOUT 5)) "
"AND 6))` |\n"
"| `-3.0`    | `(1 3 4 5 6 7 9 6)` | `(1 AND ((3 T0 7) AND ((9 WITHOUT 5) AND "
"6)))` |"
msgstr ""

#: in/chapter19.md:878
msgid ""
"```\n"
"> (all -parses '(1 and 3 to 7 and 9 without 5 and 2))\n"
"```"
msgstr ""

#: in/chapter19.md:897
msgid ""
"| []()     |                     "
"|                                                |\n"
"|----------|---------------------|------------------------------------------------|\n"
"| `Score`  | `Semantics`         | `(1 AND 3 T0 7 AND 9 WITHOUT 5 AND "
"2)`         |\n"
"| `======` | `================`  | "
"`===================================`          |\n"
"| `0.2`    | `(1 3 4 6 7 9 2)`   | `((1 AND (((3 T0 7) AND 9) WITHOUT 5)) "
"AND 2)` |\n"
"| `0.2`    | `(1 3 4 6 7 9 2)`   | `(1 AND ((((3 T0 7) AND 9) WITHOUT 5) AND "
"2))` |\n"
"| `0.1`    | `(1 3 4 6 7 9 2)`   | `((((1 AND (3 T0 7)) AND 9) WITHOUT 5) "
"AND 2)` |\n"
"| `0.1`    | `(1 3 4 6 7 9 2)`   | `(((1 AND ((3 T0 7) AND 9)) WITHOUT 5) "
"AND 2)` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9 2)` | `(((1 AND (3 T0 7)) AND (9 WITHOUT 5)) "
"AND 2)` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9 2)` | `((1 AND (3 T0 7)) AND ((9 WITHOUT 5) AND "
"2))` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9)`   | `((1 AND (3 T0 7)) AND (9 WITHOUT (5 AND "
"2)))` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9 2)` | `((1 AND ((3 T0 7) AND (9 WITHOUT 5))) "
"AND 2)` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9 2)` | `(1 AND (((3 T0 7) AND (9 WITHOUT 5)) AND "
"2))` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9 2)` | `(1 AND ((3 T0 7) AND ((9 WITHOUT 5) AND "
"2)))` |\n"
"| `-2.0`   | `(1 3 4 5 6 7 9)`   | `(1 AND ((3 T0 7) AND (9 WITHOUT (5 AND "
"2))))` |\n"
"| `-2.8`   | `(1 3 4 6 7 9)`     | `(1 AND (((3 T0 7) AND 9) WITHOUT (5 AND "
"2)))` |\n"
"| `-2.9`   | `(1 3 4 6 7 9)`     | `(((1 AND (3 T0 7)) AND 9) WITHOUT (5 AND "
"2))` |\n"
"| `-2.9`   | `(1 3 4 6 7 9)`     | `((1 AND ((3 T0 7) AND 9)) WITHOUT (5 AND "
"2))` |"
msgstr ""

#: in/chapter19.md:904
msgid ""
"In each case, the preference rules are able to assign higher scores to more "
"reasonable interpretations.\n"
"It turns out that, in each case, all the interpretations with positive "
"scores represent the same set of numbers, while interpretations with "
"negative scores seem worse.\n"
"Seeing all the scores in gory detail may be of academic interest, but what "
"we really want is something to pick out the best interpretation.\n"
"The following code is appropriate for many situations.\n"
"It picks the top scorer, if there is a unique one, or queries the user if "
"several interpretations tie for the best score, and it complains if there "
"are no valid parses at all.\n"
"The query-user function may be useful in many applications, but note that "
"meani ng uses it only as a default; a program that had some automatic way of "
"deciding could supply another `tie-breaker` function to meani ng."
msgstr ""
"В каждом случае правила предпочтений могут присваивать более высокие баллы "
"более разумным интерпретациям.\n"
"Оказывается, в каждом случае все интерпретации с положительными оценками "
"представляют собой один и тот же набор чисел, тогда как интерпретации с "
"отрицательными оценками кажутся хуже.\n"
"Просмотр всех оценок в мрачных деталях может представлять академический "
"интерес, но на самом деле нам нужно что-то, чтобы выбрать лучшую "
"интерпретацию.\n"
"Следующий код подходит для многих ситуаций.\n"
"Он выбирает лучшую функцию подсчета баллов(scorer), если есть уникальный, "
"или запрашивает пользователя, совпадают ли несколько интерпретаций для "
"лучшего результата, и жалуется, если вообще нет действительных "
"синтаксических анализов.\n"
"Функция query-user может быть полезна во многих приложениях, но обратите "
"внимание, что meaning использует ее только по умолчанию; программа, у "
"которой был некоторый автоматический способ принятия решений, могла бы "
"предоставить еще одну функцию `tie-breaker`."

#: in/chapter19.md:918
msgid ""
"```lisp\n"
"(defun meaning (words &optional (tie-breaker #'query-user))\n"
"  \"Choose the single top-ranking meaning for the words.\"\n"
"  (let* ((trees (sort (parser words) #'> :key #'tree-score))\n"
"         (best-score (if trees (tree-score (first trees)) 0))\n"
"         (best-trees (delete best-score trees\n"
"                             :key #'tree-score :test-not #'eql))\n"
"         (best-sems (delete-duplicates (mapcar #'tree-sem best-trees)\n"
"                                       :test #'equal)))\n"
"    (case (length best-sems)\n"
"      (0 (format t \"~&Sorry, I didn't understand that.\") nil)\n"
"      (1 (first best-sems))\n"
"      (t (funcall tie-breaker best-sems)))))"
msgstr ""

#: in/chapter19.md:929
msgid ""
"(defun query-user (choices &optional\n"
"                           (header-str \"~&Please pick one:\")\n"
"                           (footer-str \"~&Your choice? \"))\n"
"  \"Ask user to make a choice.\"\n"
"  (format *query-io* header-str)\n"
"  (loop for choice in choices for i from 1 do\n"
"        (format *query-io* \"~&~3d: ~a\" i choice))\n"
"  (format *query-io* footer-str)\n"
"  (nth (- (read) 1) choices))\n"
"```"
msgstr ""

#: in/chapter19.md:931
msgid "Here we see some final examples:"
msgstr "Здесь мы видим несколько заключительных примеров:"

#: in/chapter19.md:943
msgid ""
"```lisp\n"
"> (meaning '(1 to 5 without 3 and 4))\n"
"(1 2 5)\n"
"> (meaning '(1 to 5 without 3 and 6))\n"
"(1 2 4 5 6)\n"
"> (meaning '(1 to 5 without 3 and 6 shuffled))\n"
"(6 4 1 2 5)\n"
"> (meaning '([ 1 to 5 without [ 3 and 6 ] ] reversed))\n"
"(5 4 2 1)\n"
"> (meaning '(1 to 5 to 9))\n"
"```"
msgstr ""

#: in/chapter19.md:946
msgid ""
"`Sorry.\n"
"I didn't understand that.`"
msgstr ""

#: in/chapter19.md:954
msgid ""
"```lisp\n"
"NIL\n"
"> (meaning '(1 to 5 without 3 and 7 repeat 2))\n"
"Please pick one:\n"
"      1: (12 4 5 7 12 4 5 7)\n"
"      2: (12 4 5 7 7)\n"
"```"
msgstr ""

#: in/chapter19.md:957
msgid ""
"`Your choice?\n"
"1`"
msgstr ""

#: in/chapter19.md:961
msgid ""
"```lisp\n"
"(1 2 4 5 7 1 2 4 5 7)\n"
"```"
msgstr ""

#: in/chapter19.md:965
msgid ""
"```\n"
"> (all-parses '(1 to 5 without 3 and 7 repeat 2))\n"
"```"
msgstr ""

#: in/chapter19.md:975
msgid ""
"| []()         |                         "
"|                                           |\n"
"|--------------|-------------------------|-------------------------------------------|\n"
"| `Score`      | `Semantics`             | `(1 TO 5 WITHOUT 3 AND 7 REPEAT "
"2)`       |\n"
"| `==========` | `=========`             | "
"`===========================`             |\n"
"| `0.3`        | `(1 2 4 5 7 1 2 4 5 7)` | `((((1 TO 5) WITHOUT 3) AND 7) "
"REPEAT 2)` |\n"
"| `0.3`        | `(1 2 4 5 7 7)`         | `(((1 TO 5) WITHOUT 3) AND (7 "
"REPEAT 2))` |\n"
"| `-2.7`       | `(1 2 4 5 1 2 4 5)`     | `(((1 TO 5) WITHOUT (3 AND 7)) "
"REPEAT 2)` |\n"
"| `-2.7`       | `(1 2 4 5)`             | `((1 TO 5) WITHOUT ((3 AND 7) "
"REPEAT 2))` |\n"
"| `-2.7`       | `(1 2 4 5)`             | `((1 TO 5) WITHOUT (3 AND (7 "
"REPEAT 2)))` |"
msgstr ""

#: in/chapter19.md:984
msgid ""
"This last example points out a potential problem: I wasn't sure what was a "
"good scoring function for \"repeat\", so I left it blank, it defaulted to 0, "
"and we end up with two parses with the same score.\n"
"This example suggests that \"repeat\" should probably involve `inv-span` "
"like the other modifiers, but perhaps other factors should be involved as "
"well.\n"
"There can be a complicated interplay between phrases, and it is not always "
"clear where to assign the score.\n"
"For example, it doesn't make much sense to repeat a \"without\" phrase; that "
"is, the bracketing `(x without (y repeat n))` is probably a bad one.\n"
"But the scorer for \"without\" nearly handles that already.\n"
"It assigns a penalty if its right argument is not a subset of its left.\n"
"Unfortunately, repeated elements are not counted in sets, so for example, "
"the list (1 2 3 1 2 3) is a subset of (1 2 3 4).\n"
"However, we could change the scorer for \"without\" to test for `sub-bag-p` "
"(not a built-in Common Lisp function) instead, and then \"repeat\" would not "
"have to be concerned with that case."
msgstr ""
"Этот последний пример указывает на потенциальную проблему: я не был уверен, "
"какая функция оценки для \"repeat\" была хорошей, поэтому я оставил ее "
"пустым, по умолчанию она была равна 0, и в итоге мы получили два анализа с "
"одинаковыми баллами.\n"
"Этот пример предполагает, что \"repeat\", вероятно, должен включать в себя "
"`inv-span`, как и другие модификаторы, но, возможно, должны быть "
"задействованы и другие факторы.\n"
"Между фразами может быть сложное взаимодействие, и не всегда ясно, где "
"выставить оценку.\n"
"Например, нет смысла повторять фразу \"without\"(без); то есть фраза `(x "
"without (y repeat n))`, вероятно, плохая.\n"
"Но scorer  для  \"without\" уже почти справляется с этим.\n"
"Он назначает штраф, если его правый аргумент не является подмножеством его "
"левого аргумента.\n"
"К сожалению, повторяющиеся элементы не учитываются в множествах, поэтому, "
"например, список (1 2 3 1 2 3) является подмножеством (1 2 3 4).\n"
"Тем не менее, мы могли бы изменить scorer для \"without\", чтобы вместо "
"этого проверять `sub-bag-p` (не встроенную функцию Common Lisp), и тогда "
"\"repeat\" не должен был бы иметь дело с этим случаем."

#: in/chapter19.md:986
msgid "## 19.7 The Problem with Context-Free Phrase-Structure Rules"
msgstr "## 19.7 Проблема с правилами структуры фраз без контекста"

#: in/chapter19.md:991
msgid ""
"The fragment of English grammar we specified in [section 19.2](#s0015) "
"admits a variety of ungrammatical phrases.\n"
"For example, it is equally happy with both \"I liked her\" and \"me liked "
"she.\" Only the first of these should be accepted; the second should be "
"ruled out.\n"
"Similarly, our grammar does not state that verbs have to agree with their "
"subjects in person and number.\n"
"And, since the grammar has no notion of meaning, it will accept sentences "
"that are semantically anomalous (or at least unusual), such as \"the table "
"liked the man.\""
msgstr ""
"Фрагмент грамматики английского языка, который мы указали в [раздел 19.2]"
"(#s0015), допускает множество неграмматических фраз.\n"
"Например, он одинаково доволен как \"I liked her\"(она мне понравилась), так "
"и  \"me liked she.\". Следует принять только первое из них; второй следует "
"исключить.\n"
"Точно так же наша грамматика не утверждает, что глаголы должны "
"согласовываться со своим подлежащим лично и численно.\n"
"И поскольку грамматика не имеет понятия значения, она будет принимать "
"предложения, которые семантически аномальны (или, по крайней мере, "
"необычны), например, \"the table liked the man.\"(столу понравился человек)."

#: in/chapter19.md:998
msgid ""
"There are also some technical problems with context-free grammars.\n"
"For example, it can be shown that no context-free grammar can be written to "
"account for the language consisting of just the strings ABC, AABBCC, "
"AAABBBCCC, and so forth, where each string has an equal number of As, Bs, "
"and Cs.\n"
"Yet sentences roughly of that form show up (admittedly rarely) in natural "
"languages.\n"
"An example is \"Robin and Sandy loved and hated Pat and Kim, respectively.\" "
"While there is still disagreement over whether it is possible to generate "
"natural languages with a context-free grammar, clearly it is much easier to "
"use a more powerful grammatical formalism.\n"
"For example, consider solving the subject-predicate agreement problem.\n"
"It is possible to do this with a context-free language including categories "
"like singular-NP, plural-NP, singular-VP, and plural-VP, but it is far "
"easier to augment the grammatical formalism to allow passing features "
"between constituents."
msgstr ""
"Есть также некоторые технические проблемы с контекстно-свободной "
"грамматикой.\n"
"Например, можно показать, что никакая контекстно-свободная грамматика не "
"может быть написана для учета языка, состоящего только из строк ABC, AABBCC, "
"AAABBBCCC и т. Д., Где каждая строка имеет равное количество As, Bs и Cs. .\n"
"Тем не менее, предложения примерно такой формы появляются (правда, редко) на "
"естественных языках.\n"
"Пример: \"Robin and Sandy loved and hated Pat and Kim, respectively.\"(Робин "
"и Сэнди любили и ненавидели Пэт и Ким соответственно). Хотя все еще "
"существуют разногласия по поводу возможности создания естественных языков с "
"помощью контекстно-свободной грамматики, очевидно, что гораздо проще "
"использовать более мощный грамматический формализм.\n"
"Например, рассмотрите решение проблемы согласования субъект-предикат.\n"
"Это возможно сделать с помощью контекстно-свободного языка, включая такие "
"категории, как singular-NP, plural-NP, singular-VP, и plural-VPP, но гораздо "
"проще расширить грамматический формализм, чтобы разрешить передачу функций "
"между составляющими."

#: in/chapter19.md:1003
msgid ""
"It should be noted that context-free phrase-structure rules turned out to be "
"very useful for describing programming languages.\n"
"Starting with Algol 60, the formalism has been used under the name *Backus-"
"NaurForm* (BNF) by computer scientists.\n"
"In this book we are more interested in natural languages, so in the next "
"chapter we will see a more powerful formalism known as *unification grammar* "
"that can handle the problem of agreement, as well as other difficulties.\n"
"Furthermore, *unification grammars* allow a natural way of attaching "
"semantics to a parse."
msgstr ""
"Следует отметить, что контекстно-свободные правила структуры фраз оказались "
"очень полезными для описания языков программирования.\n"
"Начиная с Algol 60, этот формализм использовался компьютерными учеными под "
"названием *Backus-NaurForm* (BNF).\n"
"В этой книге нас больше интересуют естественные языки, поэтому в следующей "
"главе мы увидим более мощный формализм, известный как *unification "
"grammar*(объединяющая грамматика), который может решить проблему "
"согласования, а также другие трудности.\n"
"Более того, *Объединенные/унифицированные грамматики* позволяют естественным "
"образом присоединять семантику к синтаксическому анализу."

#: in/chapter19.md:1005
msgid "## 19.8 History and References"
msgstr "## 19.8 История и ссылки"

#: in/chapter19.md:1012
msgid ""
"There is a class of parsing algorithms known as *chart parsers* that "
"explicitly cache partial parses and reuse them in constructing larger "
"parses.\n"
"Earley's algorithm (1970) is the first example, and Martin [Kay (1980)]"
"(B9780080571157500285.xhtml#bb0605) gives a good overview of the field and "
"introduces a data structure, the *chart*, for storing substrings of a "
"parse.\n"
"[Winograd (1983)](B9780080571157500285.xhtml#bb1395) gives a complex (five-"
"page) specification of a chart parser.\n"
"None of these authors have noticed that one can achieve the same results by "
"augmenting a simple (one-page) parser with memoization.\n"
"In fact, it is possible to write a top-down parser that is even more "
"succinct.\n"
"(See [exercise 19.3](#p2455) below.)"
msgstr ""

#: in/chapter19.md:1014
msgid ""
"For a general overview of natural language processing, my preferences (in "
"order) are [Allen 1987](B9780080571157500285.xhtml#bb0030), [Winograd 1983]"
"(B9780080571157500285.xhtml#bb1395) or [Gazdar and Mellish 1989]"
"(B9780080571157500285.xhtml#bb0445)."
msgstr ""

#: in/chapter19.md:1016
msgid "## 19.9 Exercises"
msgstr "## 19.9 Упражнения"

#: in/chapter19.md:1019
msgid ""
"**Exercise  19.2 [m-h]** Experiment with the grammar and the parser.\n"
"Find sentences it cannot parse correctly, and try to add new syntactic rules "
"to account for them."
msgstr ""

#: in/chapter19.md:1024
msgid ""
"**Exercise  19.3 [m-h]** The parser works in a bottom-up fashion.\n"
"Write a top-down parser, and compare it to the bottom-up version.\n"
"Can both parsers work with the same grammar?\n"
"If not, what constraints on the grammar does each parsing strategy impose?"
msgstr ""

#: in/chapter19.md:1028
msgid ""
"**Exercise  19.4 [h]** Imagine an interface to a dual cassette deck.\n"
"Whereas the CD player had one assumed verb, \"play,\" this unit has three "
"explicit verb forms: \"record,\" \"play,\" and \"erase.\" There should also "
"be modifiers \"from\" and \"to,\" where the object of a \"to\" is either 1 "
"or 2, indicating which cassette to use, and the object of a \"from\" is "
"either 1 or 2, or one of the symbols PHONO, CD, or AUX.\n"
"It's up to you to design the grammar, but you should allow input something "
"like the following, where I have chosen to generate actual Lisp code as the "
"meaning:"
msgstr ""

#: in/chapter19.md:1036
msgid ""
"```lisp\n"
"> (meaning '(play 1 to 5 from CD shuffled and\n"
"                          record 1 to 5 from CD and 1 and 3 and 7 from 1))\n"
"(PROGN (PLAY '(15 2 3 4) :FROM 'CD)\n"
"              (RECORD '(12345) :FROM 'CD)\n"
"              (RECORD '(1 3 7) :FROM '1))\n"
"```"
msgstr ""

#: in/chapter19.md:1039
msgid ""
"This assumes that the functions play and record take keyword arguments (with "
"defaults) for : `from` and : `to`.\n"
"You could also extend the grammar to accommodate an automatic timer, with "
"phrases like \"at 3:00.\""
msgstr ""

#: in/chapter19.md:1041
msgid ""
"**Exercise  19.5 [m]** In the definition of `permute`, repeated here, why is "
"the :`test # ' eq needed?`"
msgstr ""

#: in/chapter19.md:1050
msgid ""
"```lisp\n"
"(defun permute (bag)\n"
"      \"Return a random permutation of the given input list.\"\n"
"      (if (null bag)\n"
"              nil\n"
"              (let ((e (random-elt bag)))\n"
"                  (cons e (permute (remove e bag :count 1 :test #'eq))))))\n"
"```"
msgstr ""

#: in/chapter19.md:1053
msgid ""
"**Exercise  19.6 [m]** The definition of `permute` takes *O*(*n*2).\n"
"Replace it by an *O*(*n*) algorithm."
msgstr ""

#: in/chapter19.md:1055
msgid "## 19.10 Answers"
msgstr "## 19.10 Ответы"

#: in/chapter19.md:1057
msgid "**Answer 19.1**"
msgstr ""

#: in/chapter19.md:1066
msgid ""
"```lisp\n"
"(defun parser (words)\n"
"      \"Return all complete parses of a list of words.\"\n"
"      (let* ((table (make-array (+ (length words) 1) :initial-element 0))\n"
"                        (parses (parse words (length words) table)))\n"
"          (mapcar #'parse-tree (complete-parses parses))))\n"
"(defun parse (words num-words table)\n"
"```"
msgstr ""

#: in/chapter19.md:1069
msgid ""
"`      \"Bottom-up parse.\n"
"returning all parses of any prefix of words.\"`"
msgstr ""

#: in/chapter19.md:1104
msgid ""
"```lisp\n"
"      (unless (null words)\n"
"          (let ((ans (aref table num-words)))\n"
"              (if (not (eq ans 0))\n"
"                      ans\n"
"                      (setf (aref table num-words)\n"
"                                    (mapcan #'(lambda (rule)\n"
"                                                            (extend-parse "
"(rule-lhs rule)\n"
"                                                                                        (list "
"(firstwords))\n"
"                                                                                        (rest "
"words) nil\n"
"                                                                                        (- "
"num-words 1) table))\n"
"                                                        (lexical-rules "
"(first words))))))))\n"
"(defun extend-parse (lhs rhs rem needed num-words table)\n"
"      \"Look for the categories needed to complete the parse.\"\n"
"      (if (null needed)\n"
"            ;; If nothing is needed, return this parse and upward "
"extensions\n"
"            (let ((parse (make-parse :tree (new-tree lhs rhs) :rem rem)))\n"
"                (cons parse\n"
"                            (mapcan\n"
"                          #'(lambda (rule)\n"
"                                          (extend-parse (rule-lhs rule)\n"
"                                                                      (list "
"(parse-tree parse))\n"
"                                                                        rem "
"(rest (rule-rhs rule))\n"
"                                                                        num-"
"words table))\n"
"                                  (rules-starting-with lhs))))\n"
"              ;; otherwise try to extend rightward\n"
"              (mapcan\n"
"                  #'(lambda (p)\n"
"                          (if (eq (parse-lhs p) (first needed))\n"
"                                    (extend-parse lhs (appendl rhs (parse-"
"tree p))\n"
"                                                                (parse-rem "
"p) (rest needed)\n"
"                                                                (length "
"(parse-rem p)) table)))\n"
"                  (parse rem num-words table))))\n"
"```"
msgstr ""

#: in/chapter19.md:1106
msgid ""
"It turns out that, for the Lisp system used in the timings above, this "
"version is no faster than normal memoization."
msgstr ""

#: in/chapter19.md:1112
msgid ""
"**Answer 19.3** Actually, the top-down parser is a little easier (shorter) "
"than the bottom-up version.\n"
"The problem is that the most straightforward way of implementing a top-down "
"parser does not handle so-called *left recursive* rules-rules of the form "
"`(X -> (X ...))`.\n"
"This includes rules we've used, like `(NP -> (NP and NP))`.\n"
"The problem is that the parser will postulate an NP, and then postulate that "
"it is of the form `(NP and NP)`, and that the first NPof that expression is "
"ofthe form `(NP and NP)`, and so on.\n"
"An infinite structure of NPs is explored before even the first word is "
"considered."
msgstr ""

#: in/chapter19.md:1115
msgid ""
"Bottom-up parsers are stymied by rules with null right-hand sides: `(X -> "
"O)`.\n"
"Note that I was careful to exclude such rules in my grammars earlier."
msgstr ""

#: in/chapter19.md:1140
msgid ""
"```lisp\n"
"(defun parser (words &optional (cat 's))\n"
"      \"Parse a list of words; return only parses with no remainder.\"\n"
"      (mapcar #'parse-tree (compiete-parses (parse words cat))))\n"
"(defun parse (tokens start-symbol)\n"
"      \"Parse a list of tokens, return parse trees and remainders.\"\n"
"      (if (eq (first tokens) start-symbol)\n"
"              (list (make-parse :tree (first tokens) :rem (rest tokens)))\n"
"              (mapcan #'(lambda (rule)\n"
"                                      (extend-parse (lhs rule) nil tokens "
"(rhs rule)))\n"
"                                  (rules-for start-symbol))))\n"
"(defun extend-parse (lhs rhs rem needed)\n"
"      \"Parse the remaining needed symbols.\"\n"
"      (if (null needed)\n"
"              (list (make-parse :tree (cons lhs rhs) :rem rem))\n"
"              (mapcan\n"
"                  #'(lambda (p)\n"
"                            (extend-parse lhs (append rhs (list (parse-tree "
"p)))\n"
"                                                            (parse-rem p) "
"(rest needed)))\n"
"                  (parse rem (first needed)))))\n"
"(defun rules-for (cat)\n"
"      \"Return all the rules with category on lhs\"\n"
"      (find-all cat *grammar* :key #'rule-lhs))\n"
"```"
msgstr ""

#: in/chapter19.md:1147
msgid ""
"**Answer 19.5** If it were omitted, then : test would default `to #'eql`, "
"and it would be possible to remove the \"wrong\" element from the list.\n"
"Consider the list (1.0 1.0) in an implementation where floating-point "
"numbers are `eql` but not `eq`.\n"
"if `random-elt` chooses the first 1.0 first, then everything is satisfactory-"
"the resuit list is the same as the input list.\n"
"However, if `random-elt` chooses the second 1.0, then the second 1.0 will be "
"the first element of the answer, but `remove` will remove the wrong 1.0!\n"
"It will remove the first 1.0, and the final answer will be a list with two "
"pointers to the second 1.0 and none to the first.\n"
"In other words, we could have:"
msgstr ""

#: in/chapter19.md:1152
msgid ""
"```lisp\n"
"  > (member (first x) (permute x) :test #'eq)\n"
"  NIL\n"
"```"
msgstr ""

#: in/chapter19.md:1154
msgid "**Answer 19.6**"
msgstr ""

#: in/chapter19.md:1163
msgid ""
"```lisp\n"
"(defun permute (bag)\n"
"      \"Return a random permutation of the bag.\"\n"
"      ;; It is done by converting the bag to a vector, but the\n"
"      ;; resuit is always the same type as the input bag.\n"
"      (let ((bag-copy (replace (make-array (length bag)) bag))\n"
"                  (bag-type (if (listp bag) 'list (type-of bag))))\n"
"```"
msgstr ""

#: in/chapter19.md:1166
msgid ""
"`            (coerce (permute-vector!\n"
"bag-copy) bag-type)))`"
msgstr ""

#: in/chapter19.md:1169
msgid ""
"`(defun permute-vector!\n"
"(vector)`"
msgstr ""

#: in/chapter19.md:1177
msgid ""
"```lisp\n"
"      \"Destructively permute (shuffle) the vector.\"\n"
"      (loop for i from (length vector) downto 2 do\n"
"                  (rotatef (aref vector (- i 1))\n"
"                                    (aref vector (random i))))\n"
"vector)\n"
"```"
msgstr ""

#: in/chapter19.md:1180
msgid ""
"The answer uses `rotatef`, a relative of `setf` that swaps 2 or more "
"values.\n"
"That is, `(rotatef a b)` is like:"
msgstr ""

#: in/chapter19.md:1187
msgid ""
"```lisp\n"
"(let ((temp a))\n"
"      (setf a b)\n"
"      (setf b temp)\n"
"      nil)\n"
"```"
msgstr ""

#: in/chapter19.md:1189
msgid ""
"Rarely, `rotatef` is used with more than two arguments, `(rotatef a b c)` is "
"like:"
msgstr ""

#: in/chapter19.md:1197
msgid ""
"```lisp\n"
"(let ((temp a))\n"
"      (setf a b)\n"
"      (setf b c)\n"
"      (setf c temp)\n"
"      nil)\n"
"```"
msgstr ""

#: in/chapter19.md:1199
msgid "----------------------"
msgstr ""

#: in/chapter19.md:1202
msgid ""
"[1](#xfn0015) Some erroneous expressions are underspecified and may return "
"different results in different implementations, but we will ignore that "
"problem.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter19.md:1207
msgid ""
"[2](#xfn0020) The number of parses of sentences of this kind is the same as "
"the number of bracketings of a arithmetic expression, or the number of "
"binary trees with a given number of leaves.\n"
"The resulting sequence (1,2,5,14,42,...) is known as the Catalan Numbers.\n"
"This kind of ambiguity is discussed by [Church and Patil (1982)]"
"(B9780080571157500285.xhtml#bb0200) in their article *Coping with Syntactic "
"Ambiguity, or How to Put the Block in the Box on the Table.*\n"
"!!!(p) {:.ftnote1}"
msgstr ""
