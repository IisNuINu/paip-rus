#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter18.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-02-27 11:58+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter18.md:3
msgid ""
"# Chapter 18\n"
"## Search and the Game of Othello"
msgstr ""
"# Глава 18\n"
"## Поиски и игра Отелло"

#: in/chapter18.md:5
msgid ""
"> In the beginner's mind there are endless possibilities; in the expert's "
"there are few."
msgstr "> В сознании новичка есть бесконечные возможности; в экспертном мало."

#: in/chapter18.md:7
msgid "> -Suzuki Roshi, Zen Master"
msgstr ""

#: in/chapter18.md:15
msgid ""
"**G**ame playing has been the target of much early work in AI for three "
"reasons.\n"
"First, the rules of most games are formalized, and they can be implemented "
"in a computer program rather easily.\n"
"Second, in many games the interface requirements are trivial.\n"
"The computer need only print out its moves and read in the opponent's "
"moves.\n"
"This is true for games like chess and checkers, but not for ping-pong and "
"basketball, where vision and motor skills are crucial.\n"
"Third, playing a good game of chess is considered by many an intellectual "
"achievement.\n"
"Newell, Shaw, and Simon say, \"Chess is the intellectual game *par "
"excellence*,\" and Donald Michie called chess the \"*Drosophila "
"melanogaster* of machine intelligence,\" meaning that chess is a relatively "
"simple yet interesting domain that can lead to advances in AI, just as study "
"of the fruit fly served to advance biology."
msgstr ""
"**Г**еймерские игры были целью многих ранних работ в области ИИ по трем "
"причинам.\n"
"Во-первых, правила большинства игр формализованы, и их довольно легко "
"реализовать в компьютерной программе.\n"
"Во-вторых, во многих играх требования к интерфейсу тривиальны.\n"
"Компьютеру нужно только распечатать свои ходы и прочитать ходы противника.\n"
"Это верно для таких игр, как шахматы и шашки, но не для пинг-понга и "
"баскетбола, где решающее значение имеют зрение и моторика.\n"
"В-третьих, хорошая игра в шахматы считается многими интеллектуальным "
"достижением.\n"
"Ньюэлл, Шоу и Саймон говорят: \"Шахматы - интеллектуальная игра * par "
"excellence *\", а Дональд Мичи назвал шахматы \"Дрозофила(мушка для "
"испытаний)*Drosophila melanogaster* машинного интеллекта», имея в виду, что "
"шахматы - относительно простая, но интересная область, которая может "
"привести к достижениям в области искусственного интеллекта, точно так же, "
"как изучение плодовой мухи способствовало развитию биологии."

#: in/chapter18.md:21
msgid ""
"Today there is less emphasis on game playing in AI.\n"
"It has been realized that techniques that work well in the limited domain of "
"a board game do not necessarily lead to intelligent behavior in other "
"domains.\n"
"Also, as it turns out, the techniques that allow computers to play well are "
"not the same as the techniques that good human players use.\n"
"Humans are capable of recognizing abstract patterns learned from previous "
"games, and formulating plans of attack and defense.\n"
"While some computer programs try to emulate this approach, the more "
"successful programs work by rapidly searching thousands of possible "
"sequences of moves, making fairly superficial evaluations of the worth of "
"each sequence."
msgstr ""
"Сегодня ИИ уделяет меньше внимания играм.\n"
"Было понято, что методы, которые хорошо работают в ограниченной области "
"настольной игры, не обязательно приводят к разумному поведению в других "
"областях.\n"
"Кроме того, как оказалось, методы, позволяющие компьютерам играть хорошо, "
"отличаются от техник, которые используют хорошие игроки-люди.\n"
"Люди способны распознавать абстрактные модели, извлеченные из предыдущих "
"игр, и разрабатывать планы атаки и защиты."

#: in/chapter18.md:30
msgid ""
"While much previous work on game playing has concentrated on chess and "
"checkers, this chapter demonstrates a program to play the game of Othello.[1]"
"(#fn0015) Othello is a variation on the nineteenth-century game Reversi.\n"
"It is an easy game to program because the rules are simpler than chess.\n"
"Othello is also a rewarding game to program, because a simple search "
"technique can yield an excellent player.\n"
"There are two reasons for this.\n"
"First, the number of legal moves per turn is low, so the search is not too "
"explosive.\n"
"Second, a single Othello move can flip a dozen or more opponent pieces.\n"
"This makes it difficult for human players to visualize the long-range "
"consequences of a move.\n"
"Search-based programs are not confused, and thus do well relative to humans."
msgstr ""
"В то время как большая часть предыдущей работы по игре была сосредоточена на "
"шахматах и шашках, в этой главе демонстрируется программа для игры в Отелло. "
"[1](# fn0015) Отелло - это разновидность игры Реверси девятнадцатого века.\n"
"Программировать эту игру легко, потому что правила проще, чем в шахматах.\n"
"\"Отелло\" также полезно программировать, потому что простой метод поиска "
"может дать отличного игрока.\n"
"На это есть две причины.\n"
"Во-первых, количество разрешенных ходов за ход невелико, поэтому поиск не "
"слишком взрывной.\n"
"Во-вторых, один ход Отелло может перевернуть дюжину или более фигур "
"противника.\n"
"Это мешает игрокам-людям визуализировать отдаленные последствия своего "
"хода.\n"
"Программы, основанные на поиске, это не сбивают с толку и, таким образом, "
"хорошо работают по сравнению с людьми."

#: in/chapter18.md:37
msgid ""
"The very name \"Othello\" derives from the fact that the game is so "
"unpredictable, like the Moor of Venice.\n"
"The name may also be an allusion to the line, \"Your daughter and the Moor "
"are now making the beast with two backs,\"[2](#fn0020) since the game pieces "
"do indeed have two backs, one white and one black.\n"
"In any case, the association between the game and the play carries over to "
"the name of several programs: Cassio, Iago, and Bill.\n"
"The last two will be discussed in this chapter.\n"
"They are equal to or better than even champion human players.\n"
"We will be able to develop a simplified version that is not quite a champion "
"but is much better than beginning players."
msgstr ""
"Само название \"Отелло\" происходит от того, что игра настолько "
"непредсказуема, как венецианский мавр.\n"
"Название также может быть намеком на фразу: \"Ваша дочь и мавр теперь делают "
"зверя с двумя спинами\" [2](#fn0020), поскольку у игровых фишек "
"действительно есть две спинки, одна белая и одна черная.\n"
"В любом случае связь между игрой и спектаклем переносится на названия "
"нескольких программ: Кассио, Яго и Билла.\n"
"Последние два будут рассмотрены в этой главе.\n"
"Они равны или даже лучше, чем игроки-чемпионы.\n"
"Мы сможем разработать упрощенную версию, которая не будет чемпионом, но "
"будет намного лучше, чем у начинающих игроков."

#: in/chapter18.md:39
msgid "## 18.1 The Rules of the Game"
msgstr "## 18.1 Правила игры"

#: in/chapter18.md:53
msgid ""
"Othello is played on a 8-by-8 board, which is initially set up with four "
"pieces in the center, as shown in [figure 18.1](#f0010).\n"
"The two players, black and white, alternate turns, with black playing "
"first.\n"
"On each turn, a player places a single piece of his own color on the board.\n"
"No piece can be moved once it is placed, but subsequent moves may flip a "
"piece from one color to another.\n"
"Each piece must be placed so that it *brackets* one or more opponent "
"pieces.\n"
"That is, when black plays a piece there must be a line (horizontal, "
"vertical, or diagonal) that goes through the piece just played, then through "
"one or more white pieces, and then to another black piece.\n"
"The intervening white pieces are flipped over to black.\n"
"If there are bracketed white pieces in more than one direction, they are all "
"flipped.\n"
"[Figure 18.2 (a)](#f0015) indicates the legal moves for black with small "
"dots.\n"
"[Figure 18.2 (b)](#f0015) shows the position after black moves to square "
"b4.\n"
"Players alternate turns, except that a player who has no legal moves must "
"pass.\n"
"When neither player has any moves, the game is over, and the player with the "
"most pieces on the board wins.\n"
"This usually happens because there are no empty squares left, but it "
"occasionally happens earlier in the game."
msgstr ""
"В Отелло играют на доске 8 на 8, которая изначально расставлена ​​с четырьмя "
"фигурами в центре, как показано на [рис. 18.1](#f0010).\n"
"Два игрока, черный и белый, по очереди ходят, причем черные играют первыми.\n"
"На каждом ходу игрок кладет на доску фишку своего цвета.\n"
"После размещения фишку нельзя переместить, но последующие ходы могут "
"перевернуть фишку из одного цвета в другой.\n"
"Каждая фишка должна быть размещена таким образом, чтобы *скреплять* одну или "
"несколько фишек соперника.\n"
"То есть, когда черные играют фигуру, должна быть линия (горизонтальная, "
"вертикальная или диагональная), которая проходит через только что сыгранную "
"фигуру, затем через одну или несколько белых фигур, а затем через другую "
"черную фигуру.\n"
"Промежуточные белые фигуры переворачиваются на черные.\n"
"Если белые фигуры в квадратных скобках расположены более чем в одном "
"направлении, они все переворачиваются.\n"
"[Рисунок 18.2 (a)](#f0015) указывает допустимые ходы черных маленькими "
"точками.\n"
"[Рисунок 18.2 (b)](#f0015) показывает позицию после того, как черные "
"перейдут на поле b4.\n"
"Игроки ходят по очереди, за исключением того, что пасовать должен игрок, у "
"которого нет разрешенных ходов.\n"
"Когда ни один из игроков не имеет ходов, игра заканчивается, и побеждает "
"игрок с наибольшим количеством фигур на доске.\n"
"Обычно это происходит из-за того, что не осталось пустых квадратов, но "
"иногда это случается в игре и раньше."

#: in/chapter18.md:58
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-01](images/chapter18/f18-01.jpg) |\n"
"| Figure 18.1: The Othello Board         |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-01](images/chapter18/f18-01.jpg) |\n"
"| Рисунок 18.1: Доска Отелло         |"

#: in/chapter18.md:63
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-02](images/chapter18/f18-02.jpg) |\n"
"| Figure 18.2: Legal Othello Moves       |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-02](images/chapter18/f18-02.jpg) |\n"
"| Рисунок 18.2: Законные перемещения в Отелло       |"

#: in/chapter18.md:65
msgid "## 18.2 Representation Choices"
msgstr "## 18.2 Варианты представления"

#: in/chapter18.md:70
msgid ""
"In developing an Othello program, we will want to test out various "
"strategies, playing those strategies against each other and against human "
"players.\n"
"We may also want our program to allow two humans to play a game.\n"
"Therefore, our main function, `othello`, will be a monitoring function that "
"takes as arguments two strategies.\n"
"It uses these strategies to get each player's moves, and then applies these "
"moves to a representation of the game board, perhaps printing out the board "
"as it goes."
msgstr ""
"При разработке программы \"Отелло\" мы захотим протестировать различные "
"стратегии, используя стратегии играть друг против друга и против игроков-"
"людей.\n"
"Мы также можем захотеть, чтобы наша программа позволяла двум людям играть в "
"игру.\n"
"Следовательно, наша основная функция, `othello`, будет функцией мониторинга, "
"которая принимает в качестве аргументов две стратегии.\n"
"Она использует эти стратегии для получения ходов каждого игрока, а затем "
"применяет эти ходы к представлению игрового поля, возможно, распечатывая "
"доску по мере ее продвижения."

#: in/chapter18.md:74
msgid ""
"The first choice to make is how to represent the board and the pieces on "
"it.\n"
"The board is an 8-by-8 square, and each square can be filled by a black or "
"white piece or can be empty.\n"
"Thus, an obvious representation choice is to make the board an 8-by-8 array, "
"where each element of the array is the symbol `black, white,` or `nil`."
msgstr ""
"Первый выбор, который нужно сделать, - как представить доску и фигуры на "
"ней.\n"
"Доска представляет собой квадрат 8 на 8, и каждый квадрат может быть "
"заполнен черной или белой фигурой или может быть пустым.\n"
"Таким образом, очевидный выбор представления состоит в том, чтобы сделать "
"доску массивом 8 на 8, где каждый элемент массива представляет собой символ "
"`black/черный`, `white/белый` или `nil/ничего`."

#: in/chapter18.md:78
msgid ""
"Notice what is happening here: we are following the usual Lisp convention of "
"implementing an *enumerated type* (the type of pieces that can fill a "
"square) as a set of symbols.\n"
"This is an appropriate representation because it supports the primary "
"operation on elements of an enumerated type: test for equality using eq.\n"
"It also supports input and output quite handily."
msgstr ""
"Обратите внимание на то, что здесь происходит: мы следуем обычному "
"соглашению Лиспа о реализации *перечислимого типа* (типа частей, которые "
"могут заполнять квадрат) как набора символов.\n"
"Это подходящее представление, поскольку оно поддерживает основную операцию "
"над элементами перечислимого типа: проверка на равенство с помощью eq.\n"
"Оно также легко поддерживает ввод и вывод."

#: in/chapter18.md:81
msgid ""
"In many other languages (such as C or Pascal), enumerated types are "
"implemented as integers.\n"
"In Pascal one could declare:"
msgstr ""
"Во многих других языках (например, C или Pascal) перечисляемые типы "
"реализованы как целые числа.\n"
"В Паскале можно было объявить:"

#: in/chapter18.md:85
msgid ""
"```lisp\n"
"type piece = (black, white, empty);\n"
"```"
msgstr ""

#: in/chapter18.md:93
msgid ""
"to define `piece` as a set of three elements that is treated as a subtype of "
"the integers.\n"
"The language does not allow for direct input and output of such types, but "
"equality can be checked.\n"
"An advantage of this approach is that an element can be packed into a small "
"space.\n"
"In the Othello domain, we anticipate that efficiency will be important, "
"because one way to pick a good move is to look at a large number of possible "
"sequences of moves, and choose a sequence that leads toward a favorable "
"result.\n"
"Thus, we are willing to look hard at alternative representations to find an "
"efficient one.\n"
"It takes only two bits to represent one of the three possible types, while "
"it takes many more (perhaps 32) to represent a symbol.\n"
"Thus, we may save space by representing pieces as small integers rather than "
"symbols."
msgstr ""
"чтобы определить `piece` как набор из трех элементов, который "
"рассматривается как подтип целых чисел.\n"
"Язык не допускает прямого ввода и вывода таких типов, но равенство можно "
"проверить.\n"
"Преимущество этого подхода в том, что элемент можно разместить в небольшом "
"пространстве.\n"
"В области Отелло мы ожидаем, что эффективность будет важна, потому что один "
"из способов выбрать хороший ход - это посмотреть на большое количество "
"возможных последовательностей ходов и выбрать последовательность, которая "
"приводит к благоприятному результату.\n"
"Таким образом, мы готовы внимательно изучить альтернативные представления, "
"чтобы найти эффективное.\n"
"Для представления одного из трех возможных типов требуется всего два бита, "
"тогда как для представления символа требуется гораздо больше (возможно, "
"32).\n"
"Таким образом, мы можем сэкономить место, представляя pieces(части) в виде "
"небольших целых чисел(small integers), а не символов."

#: in/chapter18.md:106
msgid ""
"Next, we consider the board.\n"
"The two-dimensional array seems like such an obvious choice that it is hard "
"to imagine a better representation.\n"
"We could consider an 8-element list of 8-element lists, but this would just "
"waste space (for the cons cells) and time (in accessing the later elements "
"of the lists).\n"
"However, we will have to implement two other abstract data types that we "
"have not yet considered: the square and the direction.\n"
"We will need, for example, to represent the square that a player chooses to "
"move into.\n"
"This will be a pair of integers, such as 4,5.\n"
"We could represent this as a two-element list, or more compactly as a cons "
"cell, but this still means that we may have to generate garbage (create a "
"cons cell) every time we want to refer to a new square.\n"
"Similarly, we need to be able to scan in a given direction from a square, "
"looking for pieces to flip.\n"
"Directions will be represented as a pair of integers, such as +1,-1.\n"
"One clever possibility is to use complex numbers for both squares and "
"directions, with the real component mapped to the horizontal axis and the "
"imaginary component mapped to the vertical axis.\n"
"Then moving in a given direction from a square is accomplished by simply "
"adding the direction to the square.\n"
"But in most implementations, creating new complex numbers will also generate "
"garbage."
msgstr ""
"Далее рассматриваем доску.\n"
"Двумерный массив кажется настолько очевидным выбором, что трудно представить "
"лучшее представление.\n"
"Мы могли бы рассмотреть 8-элементный список из 8-ми элементов, но это просто "
"потеряло бы пространство (для cons-ячеек) и время (при доступе к более "
"поздним элементам списков).\n"
"Однако нам придется реализовать два других абстрактных типа данных, которые "
"мы еще не рассматривали: square(клетка) и direction(направление).\n"
"Нам понадобится, например, изобразить клетку, в который игрок выбирает "
"двигаться.\n"
"Это будет пара целых чисел, например 4,5.\n"
"Мы могли бы представить его как список из двух элементов или, более "
"компактно, как cons-ячейку, но это все равно означает, что нам, возможно, "
"придется генерировать мусор (создавать cons-ячейку) каждый раз, когда мы "
"хотим обратиться к новой клетке.\n"
"Точно так же нам нужно иметь возможность сканировать в заданном "
"направлении(direction) от клетки в поисках частей, которые нужно "
"перевернуть.\n"
"Направления(direction) будут представлены парой целых чисел, например + 1, "
"-1.\n"
"Одна из умных возможностей - использовать комплексные числа как для клеток, "
"так и для направлений, при этом действительный компонент отображается на "
"горизонтальной оси, а мнимый компонент - на вертикальную ось.\n"
"Затем перемещение в заданном направлении от клетки выполняется простым "
"добавлением направления к клетке.\n"
"Но в большинстве реализаций создание новых комплексных чисел также "
"генерирует мусор."

#: in/chapter18.md:109
msgid ""
"Another possibility is to represent squares (and directions) as two distinct "
"integers, and have the routines that manipulate them accept two arguments "
"instead of one.\n"
"This would be efficient, but it is losing an important abstraction: that "
"squares (and directions) are conceptually single objects."
msgstr ""
"Другая возможность состоит в том, чтобы представить клетку (и направления) "
"как два различных целых числа, а процедуры, которые ими управляют, принимают "
"два аргумента вместо одного.\n"
"Это было бы эффективно, но теряется важная абстракция: клетки (и "
"направления) концептуально являются едиными объектами."

#: in/chapter18.md:115
msgid ""
"A way out of this dilemma is to represent the board as a one-dimensional "
"vector.\n"
"Squares are represented as integers in the range 0 to 63.\n"
"In most implementations, small integers (fixnums) are represented as "
"immediate data that can be manipulated without generating garbage.\n"
"Directions can also be implemented as integers, representing the numerical "
"difference between adjacent squares along that direction.\n"
"To get a feel for this, take a look at the board:"
msgstr ""
"Выход из этой дилеммы - представление доски в виде одномерного вектора.\n"
"Клетки представлены целыми числами в диапазоне от 0 до 63.\n"
"В большинстве реализаций маленькие целые числа (fixnums) представлены как "
"непосредственные данные, которыми можно манипулировать, не создавая мусора.\n"
"Направления также могут быть реализованы как целые числа, представляющие "
"числовую разницу между соседними квадратами вдоль этого направления.\n"
"Чтобы почувствовать это, взгляните на доску:"

#: in/chapter18.md:126
msgid ""
"```lisp\n"
" 0  1  2  3  4  5  6  7\n"
" 8  9 10 11 12 13 14 15\n"
"16 17 18 19 20 21 22 23\n"
"24 25 26 27 28 29 30 31\n"
"32 33 34 35 36 37 38 39\n"
"40 41 42 43 44 45 46 47\n"
"48 49 50 51 52 53 54 55\n"
"56 57 58 59 60 61 62 63\n"
"```"
msgstr ""

#: in/chapter18.md:129
msgid ""
"You can see that the direction +1 corresponds to movement to the right, +7 "
"corresponds to diagonal movement downward and to the left, +8 is downward, "
"and +9 is diagonally downward and to the right.\n"
"The negations of these numbers (-1, -7, -8, -9) represent the opposite "
"directions."
msgstr ""
"Вы можете видеть, что направление +1 соответствует движению вправо, +7 "
"соответствует диагональному движению вниз и влево, +8 - вниз, а +9 - по "
"диагонали вниз и вправо.\n"
"Отрицания этих чисел (-1, -7, -8, -9) представляют противоположные "
"направления."

#: in/chapter18.md:133
msgid ""
"There is one complication with this scheme: we need to know when we hit the "
"edge of the board.\n"
"Starting at square 0, we can move in direction +1 seven times to arrive at "
"the right edge of the board, but we aren't allowed to move in that direction "
"yet again to arrive at square 8.\n"
"It is possible to check for the edge of the board by considering quotients "
"and remainders modulo 8, but it is somewhat complicated and expensive to do "
"so."
msgstr ""
"У этой схемы есть одна сложность: нам нужно знать, когда мы попадаем на край "
"доски.\n"
"Начиная с клетки 0, мы можем двигаться в направлении +1 семь раз, чтобы "
"добраться до правого края доски, но нам не разрешено снова двигаться в этом "
"направлении, чтобы добраться до клетки 8.\n"
"Можно проверить край доски, рассматривая частные и остатки по модулю 8, но "
"это довольно сложно и дорого."

#: in/chapter18.md:139
msgid ""
"A simpler solution is to represent the edge of the board explicitly, by "
"using a 100-element vector instead of a 64-element vector.\n"
"The outlying elements are filled with a marker indicating that they are "
"outside the board proper.\n"
"This representation wastes some space but makes edge detection much "
"simpler.\n"
"It also has the minor advantage that legal squares are represented by "
"numbers in the range 11-88, which makes them easier to understand while "
"debugging.\n"
"Here's the new 100-element board:"
msgstr ""
"Более простое решение - явно представить край доски с помощью вектора из 100 "
"элементов вместо вектора из 64 элементов.\n"
"Внешние элементы отмечены маркером, указывающим на то, что они находятся за "
"пределами доски.\n"
"Это представление занимает немного места, но значительно упрощает "
"обнаружение границ.\n"
"Оно также имеет небольшое преимущество в том, что допустимые клетки "
"представлены числами в диапазоне 11-88, что упрощает их понимание во время "
"отладки.\n"
"Вот новая доска из 100 элементов:"

#: in/chapter18.md:152
msgid ""
"```lisp\n"
" 0  1  2  3  4  5  6  7  8  9\n"
"10 11 12 13 14 15 16 17 18 19\n"
"20 21 22 23 24 25 26 27 28 29\n"
"30 31 32 33 34 35 36 37 38 39\n"
"40 41 42 43 44 45 46 47 48 49\n"
"50 51 52 53 54 55 56 57 58 59\n"
"60 61 62 63 64 65 66 67 68 69\n"
"70 71 72 73 74 75 76 77 78 79\n"
"80 81 82 83 84 85 86 87 88 89\n"
"90 91 92 93 94 95 96 97 98 99\n"
"```"
msgstr ""

#: in/chapter18.md:158
msgid ""
"The horizontal direction is now &plusmn;1, vertical is &plusmn;10, and the "
"diagonals are &plusmn;9 and &plusmn;11.\n"
"We'll tentatively adopt this latest representation, but leave open the "
"possibility of changing to another format.\n"
"With this much decided, we are ready to begin.\n"
"[Figure 18.3](#f0020) is the glossary for the complete program.\n"
"A glossary for a second version of the program is on [page 623](#p623)."
msgstr ""
"Горизонтальное направление теперь &plusmn;1, вертикальное &plusmn;10, а "
"диагонали &plusmn;9 и &plusmn;11.\n"
"Мы предварительно примем это последнее представление, но оставим возможность "
"перехода на другой формат.\n"
"Приняв это решение, мы готовы начать.\n"
"[Рисунок 18.3](#f0020) - это глоссарий для полной программы.\n"
"Глоссарий второй версии программы находится на [стр. 623](#p623)."

#: in/chapter18.md:163
msgid ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f18-03](images/chapter18/f18-03.jpg)        |\n"
"| Figure 18.3: Glossary for the Othello Program |"
msgstr ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f18-03](images/chapter18/f18-03.jpg)        |\n"
"| Рисунок 18.3: Глоссарий программы Отелло |"

#: in/chapter18.md:165
msgid "*(ed: this should be a markdown table)*"
msgstr ""

#: in/chapter18.md:168
msgid ""
"What follows is the code for directions and pieces.\n"
"We explicitly define the type `piece` to be a number from `empty` to `outer` "
"(0 to 3), and define the function `name-of` to map from a piece number to a "
"character: a dot for empty, `@` for black, 0 for white, and a question mark "
"(which should never be printed) for `outer`."
msgstr ""
"Далее следует код directions(направлений) и pieces(частей).\n"
"Мы явно определяем тип `piece` как число от `empty` до `outer` (от 0 до 3), "
"и определяем функцию `name-of` для сопоставления номера piece(части) с "
"символом: точка для пустого, `@` для черного, 0 для белого и вопросительный "
"знак (который никогда не следует печатать) для `outer`."

#: in/chapter18.md:171
msgid ""
"```lisp\n"
"(defconstant all-directions '(-11 -10 -9 -1 1 9 10 11))"
msgstr ""

#: in/chapter18.md:176
msgid ""
"(defconstant empty 0 \"An empty square\")\n"
"(defconstant black 1 \"A black piece\")\n"
"(defconstant white 2 \"A white piece\")\n"
"(defconstant outer 3 \"Marks squares outside the 8x8 board\")"
msgstr ""

#: in/chapter18.md:178
msgid "(deftype piece () `(integer ,empty ,outer))"
msgstr ""

#: in/chapter18.md:180
msgid "(defun name-of (piece) (char \".@O?\" piece))"
msgstr ""

#: in/chapter18.md:183
msgid ""
"(defun opponent (player) (if (eql player black) white black))\n"
"```"
msgstr ""

#: in/chapter18.md:188
msgid ""
"And here is the code for the board.\n"
"Note that we introduce the function `bref`, for \"board reference\" rather "
"than using the built-in function `aref`.\n"
"This facilitates possible changes to the representation of boards.\n"
"Also, even though there is no contiguous range of numbers that represents "
"the legal squares, we can define the constant `all-squares` to be a list of "
"the 64 legal squares, computed as those numbers from 11 to 88 whose value "
"mod 10 is between 1 and 8."
msgstr ""
"А вот код board(доски).\n"
"Обратите внимание, что мы вводим функцию `bref` для \"ссылок на доске\", а "
"не используем встроенную функциюи`aref`.\n"
"Это облегчает возможные изменения в представлении досок.\n"
"Кроме того, даже несмотря на то, что не существует непрерывного диапазона "
"чисел, который представляет допустимые квадраты, мы можем определить "
"константу `all-squares` как список из 64 разрешенных клеток, вычисленных как "
"числа от 11 до 88, значение которых по модулю 10 равно от 1 до 8."

#: in/chapter18.md:191
msgid ""
"```lisp\n"
"(deftype board () '(simple-array piece (100)))"
msgstr ""

#: in/chapter18.md:195
msgid ""
"(defun bref (board square) (aref board square))\n"
"(defsetf bref (board square) (val)\n"
"  `(setf (aref ,board ,square) ,val))"
msgstr ""

#: in/chapter18.md:198
msgid ""
"(defun copy-board (board)\n"
"  (copy-seq board))"
msgstr ""

#: in/chapter18.md:201
msgid ""
"(defconstant all-squares\n"
"  (loop for i from 11 to 88 when (<= 1 (mod i 10) 8) collect i))"
msgstr ""

#: in/chapter18.md:214
msgid ""
"(defun initial-board ()\n"
"  \"Return a board, empty except for four pieces in the middle.\"\n"
"  ;; Boards are 100-element vectors, with elements 11-88 used,\n"
"  ;; and the others marked with the sentinel OUTER.  Initially\n"
"  ;; the 4 center squares are taken, the others empty.\n"
"  (let ((board (make-array 100 :element-type 'piece\n"
"                           :initial-element outer)))\n"
"    (dolist (square all-squares)\n"
"      (setf (bref board square) empty))\n"
"    (setf (bref board 44) white   (bref board 45) black\n"
"          (bref board 54) black   (bref board 55) white)\n"
"    board))"
msgstr ""

#: in/chapter18.md:233
msgid ""
"(defun print-board (&optional (board *board*) clock)\n"
"  \"Print a board, along with some statistics.\"\n"
"  ;; First print the header and the current score\n"
"  (format t \"~2&    a b c d e f g h   [~c=~2a ~c=~2a (~@d)]\"\n"
"          (name-of black) (count black board)\n"
"          (name-of white) (count white board)\n"
"          (count-difference black board))\n"
"  ;; Print the board itself\n"
"  (loop for row from 1 to 8 do\n"
"        (format t \"~&  ~d \" row)\n"
"        (loop for col from 1 to 8\n"
"              for piece = (bref board (+ col (* 10 row)))\n"
"              do (format t \"~c \" (name-of piece))))\n"
"  ;; Finally print the time remaining for each player\n"
"  (when clock\n"
"    (format t \"  [~c=~a ~c=~a]~2&\"\n"
"            (name-of black) (time-string (elt clock black))\n"
"            (name-of white) (time-string (elt clock white)))))"
msgstr ""

#: in/chapter18.md:239
msgid ""
"(defun count-difference (player board)\n"
"  \"Count player's pieces minus opponent's pieces.\"\n"
"  (- (count player board)\n"
"     (count (opponent player) board)))\n"
"```"
msgstr ""

#: in/chapter18.md:241
msgid ""
"Now let's take a look at the initial board, as it is printed by `print-"
"board`, and by a raw `write` (I added the line breaks to make it easier to "
"read):"
msgstr ""
"Теперь давайте посмотрим на исходную доску, поскольку она печатается с "
"помощью `print-board` и необработанной `write` (я добавил разрывы строк, "
"чтобы было легче читать):"

#: in/chapter18.md:257
msgid ""
"```lisp\n"
"> (write (initial-board)   > (print-board (initial-board))\n"
"          :array t)\n"
"#(3 3 3 3 3 3 3 3 3 3                  1 2 3 4 5 6 7 8[@=2 0=2 (+0)]\n"
"    3 0 0 0 0 0 0 0 0 3            10 . . . . . . . .\n"
"    3 0 0 0 0 0 0 0 0 3            20 . . . . . . . .\n"
"    3 0 0 0 0 0 0 0 0 3            30 . . . . . . . .\n"
"    3 0 0 0 2 1 0 0 0 3            40 . . . 0 @ . . .\n"
"    3 0 0 0 1 2 0 0 0 3            50 . . . @ 0 . . .\n"
"    3 0 0 0 0 0 0 0 0 3            60 . . . . . . . .\n"
"    3 0 0 0 0 0 0 0 0 3            70 . . . . . . . .\n"
"    3 0 0 0 0 0 0 0 0 3            80 . . . . . . . .\n"
"    3 3 3 3 3 3 3 3 3 3)\n"
"#<ART-2B-100 -72570734>    NIL\n"
"```"
msgstr ""

#: in/chapter18.md:259
msgid ""
"Notice that `print-board` provides some additional information: the number "
"of pieces that each player controls, and the difference between these two "
"counts."
msgstr ""
"Обратите внимание, что `print-board` предоставляет некоторую дополнительную "
"информацию: количество фигур, которыми владеет каждый игрок, и разницу между "
"этими двумя значениями."

#: in/chapter18.md:269
msgid ""
"The next step is to handle moves properly: given a board and a square to "
"move to, update the board to reflect the effects of the player moving to "
"that square.\n"
"This means flipping some of the opponent's pieces.\n"
"One design decision is whether the procedure that makes moves, `make-move`, "
"will be responsible for checking for error conditions.\n"
"My choice is that `make-move` assumes it will be passed a legal move.\n"
"That way, a strategy can use the function to explore sequences of moves that "
"are known to be valid without slowing `make-move` down.\n"
"Of course, separate procedures will have to insure that a move is legal.\n"
"Here we introduce two terms: a *valid* move is one that is syntactically "
"correct: an integer from 11 to 88 that is not off the board.\n"
"A *legal* move is a valid move into an empty square that will flip at least "
"one opponent.\n"
"Here's the code:"
msgstr ""
"Следующим шагом является правильная обработка ходов: учитывая доску и "
"клетку, на которые нужно перейти, обновите доску, чтобы отразить эффекты "
"перемещения игрока на эту клетку.\n"
"Это означает перебрасывание фигур противника.\n"
"Одно из проектных решений состоит в том, будет ли процедура, выполняющая "
"ходы, `make-move`, отвечать за проверку условий ошибки.\n"
"Я решил, что `make-move` предполагает, что будет принят законный ход.\n"
"Таким образом, стратегия может использовать эту функцию для исследования "
"последовательности ходов, которые заведомо допустимы, без замедления `make-"
"move`.\n"
"Конечно, чтобы убедиться, что перемещение законно, потребуются отдельные "
"процедуры.\n"
"Здесь мы вводим два термина: *valid/действительный* ход - это тот, который "
"синтаксически правильный: целое число от 11 до 88, которое не выходит за "
"пределы доски.\n"
"*legal/законный* ход - это допустимый ход в пустую клетку, который "
"перевернет хотя бы одного противника.\n"
"Вот код:"

#: in/chapter18.md:274
msgid ""
"```lisp\n"
"(defun valid-p (move)\n"
"  \"Valid moves are numbers in the range 11-88 that end in 1-8.\"\n"
"  (and (integerp move) (<= 11 move 88) (<= 1 (mod move 10) 8)))"
msgstr ""

#: in/chapter18.md:281
msgid ""
"(defun legal-p (move player board)\n"
"  \"A Legal move must be into an empty square, and it must\n"
"  flip at least one opponent piece.\"\n"
"  (and (eql (bref board move) empty)\n"
"       (some #'(lambda (dir) (would-flip? move player board dir))\n"
"             all-directions)))"
msgstr ""

#: in/chapter18.md:290
msgid ""
"(defun make-move (move player board)\n"
"  \"Update board to reflect move by player\"\n"
"  ;; First make the move, then make any flips\n"
"  (setf (bref board move) player)\n"
"  (dolist (dir all-directions)\n"
"    (make-flips move player board dir))\n"
"  board)\n"
"```"
msgstr ""

#: in/chapter18.md:295
msgid ""
"Now all we need is to `make-flips`.\n"
"To do that, we search in all directions for a *bracketing* piece: a piece "
"belonging to the player who is making the move, which sandwiches a string of "
"opponent pieces.\n"
"If there are no opponent pieces in that direction, or if an empty or outer "
"piece is hit before the player's piece, then no flips are made.\n"
"Note that `would-flip?` is a semipredicate that returns false if no flips "
"would be made in the given direction, and returns the square of the "
"bracketing piece if there is one."
msgstr ""
"Теперь все, что нам нужно, это `make-flips`.\n"
"Для этого мы ищем во всех направлениях фишку *в скобках*: фигура, "
"принадлежащая игроку, который делает ход, которая бутербродирует(находиться "
"в рядах фигур противника) цепочку фигур противника\n"
"Если в этом направлении нет фишек соперника или если перед фишкой игрока "
"попадает пустая или внешняя фишка, то броски не производятся.\n"
"Обратите внимание, что  `would-flip?` - это полупредикат, который возвращает "
"false, если никакие перевороты не будут выполнены в данном направлении, и "
"возвращает клетку фигуры \"в скобках\", если таковая имеется."

#: in/chapter18.md:303
msgid ""
"```lisp\n"
"(defun make-flips (move player board dir)\n"
"  \"Make any flips in the given direction.\"\n"
"  (let ((bracketer (would-flip? move player board dir)))\n"
"    (when bracketer\n"
"      (loop for c from (+ move dir) by dir until (eql c bracketer)\n"
"            do (setf (bref board c) player)))))"
msgstr ""

#: in/chapter18.md:313
msgid ""
"(defun would-flip? (move player board dir)\n"
"  \"Would this move result in any flips in this direction?\n"
"  If so, return the square number of the bracketing piece.\"\n"
"  ;; A flip occurs if, starting at the adjacent square, c, there\n"
"  ;; is a string of at least one opponent pieces, bracketed by\n"
"  ;; one of player's pieces\n"
"  (let ((c (+ move dir)))\n"
"    (and (eql (bref board c) (opponent player))\n"
"         (find-bracketing-piece (+ c dir) player board dir))))"
msgstr ""

#: in/chapter18.md:321
msgid ""
"(defun find-bracketing-piece (square player board dir)\n"
"  \"Return the square number of the bracketing piece.\"\n"
"  (cond ((eql (bref board square) player) square)\n"
"        ((eql (bref board square) (opponent player))\n"
"         (find-bracketing-piece (+ square dir) player board dir))\n"
"        (t nil)))\n"
"```"
msgstr ""

#: in/chapter18.md:328
msgid ""
"Finally we can write the function that actually monitors a game.\n"
"But first we are faced with one more important choice: how will we represent "
"a player?\n"
"We have already distinguished between black and white's pieces, but we have "
"not decided how to ask black or white for their moves.\n"
"I choose to represent player's strategies as functions.\n"
"Each function takes two arguments: the color to move (black or white) and "
"the current board.\n"
"The function should return a legal move number."
msgstr ""
"Наконец, мы можем написать функцию, которая действительно отслеживает игру.\n"
"Но сначала перед нами стоит еще один важный выбор: как мы будем представлять "
"игрока?\n"
"Мы уже различали фигуры черных и белых, но еще не решили, как запрашивать "
"ходы черных или белых.\n"
"Я предпочитаю представлять стратегии игрока как функции.\n"
"Каждая функция принимает два аргумента: цвет для перемещения (черный или "
"белый) и текущую доску.\n"
"Функция должна возвращать допустимый номер хода."

#: in/chapter18.md:352
msgid ""
"```lisp\n"
"(defun othello (bl-strategy wh-strategy\n"
"                &optional (print t) (minutes 30))\n"
"  \"Play a game of othello.  Return the score, where a positive\n"
"  difference means black, the first player, wins.\"\n"
"  (let ((board (initial-board))\n"
"        (clock (make-array (+ 1 (max black white))\n"
"                           :initial-element\n"
"                           (* minutes 60\n"
"                              internal-time-units-per-second))))\n"
"    (catch 'game-over\n"
"      (loop for *move-number* from 1\n"
"            for player = black then (next-to-play board player print)\n"
"            for strategy = (if (eql player black)\n"
"                               bl-strategy\n"
"                               wh-strategy)\n"
"            until (null player)\n"
"            do (get-move strategy player board print clock))\n"
"      (when print\n"
"        (format t \"~&The game is over.  Final result:\")\n"
"        (print-board board clock))\n"
"      (count-difference black board))))\n"
"```"
msgstr ""

# Notes:
# Add Note
#: in/chapter18.md:359
msgid ""
"We need to be able to determine who plays next at any point.\n"
"The rules say that players alternate turns, but if one player has no legal "
"moves, the other can move again.\n"
"When neither has a legal move, the game is over.\n"
"This usually happens because there are no empty squares left, but it "
"sometimes happens earlier in the game.\n"
"The player with more pieces at the end of the game wins.\n"
"If neither player has more, the game is a draw."
msgstr ""
"Мы должны иметь возможность определять, кто будет играть следующим в любой "
"момент.\n"
"Правила гласят, что игроки ходят по очереди, но если у одного игрока нет "
"разрешенных ходов, другой может двигаться снова.\n"
"Когда ни один из них не имеет возможности сделать ход, игра окончена.\n"
"Обычно это происходит из-за того, что не остается пустых квадратов, но "
"иногда это происходит и раньше в игре.\n"
"Побеждает игрок, у которого в конце игры будет больше фигур.\n"
"Если ни у одного игрока нет преимущества, игра заканчивается вничью."

#: in/chapter18.md:371
msgid ""
"```lisp\n"
"(defun next-to-play (board previous-player print)\n"
"  \"Compute the player to move next, or NIL if nobody can move.\"\n"
"  (let ((opp (opponent previous-player)))\n"
"    (cond ((any-legal-move? opp board) opp)\n"
"          ((any-legal-move? previous-player board)\n"
"           (when print\n"
"             (format t \"~&~c has no moves and must pass.\"\n"
"                     (name-of opp)))\n"
"           previous-player)\n"
"          (t nil))))"
msgstr ""

#: in/chapter18.md:377
msgid ""
"(defun any-legal-move? (player board)\n"
"  \"Does player have any legal moves in this position?\"\n"
"  (some #'(lambda (move) (legal-p move player board))\n"
"        all-squares))\n"
"```"
msgstr ""

#: in/chapter18.md:380
msgid ""
"Note that the argument `print` (of `othello`, `next-to-play`, and below, "
"`get-move`) determines if information about the progress of the game will be "
"printed.\n"
"For an interactive game, `print` should be true, but it is also possible to "
"play a \"batch\" game with `print` set to false."
msgstr ""
"Обратите внимание, что аргумент `print` (of `othello`, `next-to-play`, и "
"ниже, `get-move`) определяет, будет ли напечатана информация о ходе игры.\n"
"Для интерактивной игры `print` должен быть истинным, но также можно играть в "
"\"пакетную\" игру с `print`, установленным в false."

#: in/chapter18.md:385
msgid ""
"In `get-move` below, the player's strategy function is called to determine "
"his move.\n"
"Illegal moves are detected, and proper moves are reported when `print` is "
"true.\n"
"The strategy function is passed a number representing the player to move "
"(black or white) and a copy of the board.\n"
"If we passed the *real* game board, the function could cheat by changing the "
"pieces on the board!"
msgstr ""
"В `get-move` ниже вызывается функция strategy(стратегии) игрока, чтобы "
"определить его ход.\n"
"Выявляются незаконные ходы, и правильные ходы сообщаются, когда `print` "
"имеет значение true.\n"
"В функцию strategy передается число, представляющее игрока, который должен "
"ходить (черный или белый), и копия доски.\n"
"Если бы мы прошли *настоящую* игровую доску, функция могла бы обмануть, "
"меняя фигуры на доске!"

#: in/chapter18.md:400
msgid ""
"```lisp\n"
"(defun get-move (strategy player board print)\n"
"    \"Call the player's strategy function to get a move.\n"
"    Keep calling until a legal move is made.\"\n"
"    (when print (print-board board))\n"
"    (let ((move (funcall strategy player (copy-board board))))\n"
"        (cond\n"
"            ((and (valid-p move) (legal-p move player board))\n"
"              (when print\n"
"                  (format t \"~&~c moves to ~d.\" (name-of player) move))\n"
"              (make-move move player board))\n"
"            (t (warn \"Illegal move: ~d\" move)\n"
"                (get-move strategy player board print)))))\n"
"```"
msgstr ""

#: in/chapter18.md:402
msgid "Here we define two simple strategies:"
msgstr "Здесь мы определяем две простые стратегии:"

#: in/chapter18.md:409
msgid ""
"```lisp\n"
"(defun human (player board)\n"
"    \"A human player for the game of Othello\"\n"
"    (declare (ignore board))\n"
"    (format t \"~&~c to move: \" (name-of player))\n"
"    (read))"
msgstr ""

#: in/chapter18.md:413
msgid ""
"(defun random-strategy (player board)\n"
"    \"Make any legal move.\"\n"
"    (random-elt (legal-moves player board)))"
msgstr ""

#: in/chapter18.md:419
msgid ""
"(defun legal-moves (player board)\n"
"    \"Returns a list of legal moves for player\"\n"
"    (loop for move in all-squares\n"
"        when (legal-p move player board) collect move))\n"
"```"
msgstr ""

#: in/chapter18.md:422
msgid ""
"We are now in a position to play the game.\n"
"The expression"
msgstr ""
"Теперь мы можем играть в эту игру.\n"
"Выражение"

#: in/chapter18.md:426
msgid ""
"`(othello #'human #'human)` will let two people play against each other.\n"
"Alternately, `(othello #' random-strategy #'human)` will allow us to match "
"our wits against a particularly poor strategy.\n"
"The rest of this chapter shows how to develop a better strategy."
msgstr ""
"`(othello #'human #'human)` позволит двум людям играть друг против друга.\n"
"В качестве альтернативы `(othello #'random-strategy #'human)` позволит нам "
"сопоставить наш ум с особенно плохой стратегией.\n"
"Остальная часть этой главы показывает, как разработать лучшую стратегию."

#: in/chapter18.md:428
msgid "## 18.3 Evaluating Positions"
msgstr "## 18.3 Оценка позиций"

#: in/chapter18.md:435
msgid ""
"The random-move strategy is, of course, a poor one.\n"
"We would like to make a good move rather than a random move, but so far we "
"don't know what makes a good move.\n"
"The only positions we are able to evaluate for sure are final positions: "
"when the game is over, we know that the player with the most pieces wins.\n"
"This suggests a strategy: choose the move that maximizes `count-difference`, "
"the piece differential.\n"
"The function `maximize-difference` does just that.\n"
"It calls `maximizer`, a higher-order function that chooses the best move "
"according to an arbitrary evaluation function."
msgstr ""
"Стратегия random-move(случайного хода), конечно, плохая.\n"
"Мы хотели бы сделать хороший ход, а не случайный, но пока мы не знаем, что "
"дает ход хорошим.\n"
"Единственные позиции, которые мы можем точно оценить, - это финальные "
"позиции: когда игра окончена, мы знаем, что побеждает игрок с наибольшим "
"количеством фигур.\n"
"Это предлагает стратегию: выберите ход, который максимизирует `count-"
"difference`(количество различий), разность фигур.\n"
"Именно этим и занимается функция `maximize-difference`.\n"
"Он вызывает `maximizer`, функцию высшего порядка, которая выбирает лучший "
"ход в соответствии с произвольной оценочной функцией."

#: in/chapter18.md:440
msgid ""
"```lisp\n"
"(defun maximize-difference (player board)\n"
"  \"A strategy that maximizes the difference in pieces.\"\n"
"  (funcall (maximizer #'count-difference) player board))"
msgstr ""

#: in/chapter18.md:458
msgid ""
"(defun maximizer (eval-fn)\n"
"  \"Return a strategy that will consider every legal move,\n"
"  apply EVAL-FN to each resulting board, and choose\n"
"  the move for which EVAL-FN returns the best score.\n"
"  FN takes two arguments: the player-to-move and board\"\n"
"  #'(lambda (player board)\n"
"      (let* ((moves (legal-moves player board))\n"
"             (scores (mapcar #'(lambda (move)\n"
"         (funcall\n"
"          eval-fn\n"
"          player\n"
"          (make-move move player\n"
"               (copy-board board))))\n"
"                             moves))\n"
"             (best  (apply #'max scores)))\n"
"        (elt moves (position best scores)))))\n"
"```"
msgstr ""

#: in/chapter18.md:461
msgid ""
"**Exercise  18.1** Play some games with `maximize-difference` against "
"`random-strategy` and `human`.\n"
"How good is `maximize-difference`?"
msgstr ""
"**Упражнение 18.1** Поиграйте в несколько игр с `maximize-difference` против "
"`random-strategy` и `human`.\n"
"Насколько хороша `maximize-difference`?"

#: in/chapter18.md:466
msgid ""
"Those who complete the exercise will quickly see that the `maximize-"
"difference` player does better than random, and may even beat human players "
"in their first game or two.\n"
"But most humans are able to improve, learning to take advantage of the "
"overly greedy play of `maximize-difference`.\n"
"Humans learn that the edge squares, for example, are valuable because the "
"player dominating the edges can surround the opponent, while it is difficult "
"to recapture an edge.\n"
"This is especially true of corner squares, which can never be recaptured."
msgstr ""
"Те, кто завершит это упражнение, быстро увидят, что игрок `maximize-"
"difference` лучше, чем случайный, и может даже победить игроков-людей в "
"своей первой или второй игре.\n"
"Но большинство людей способны совершенствоваться, научившись извлекать "
"выгоду из чрезмерно жадной игры `maximize-difference`(максимизировать "
"разницу).\n"
"Люди узнают, что, например, крайние клетки ценны, потому что игрок, "
"доминирующий на краях, может окружить противника, в то время как захватить "
"край трудно.\n"
"Особенно это касается угловых клеток, которые невозможно отбить."

#: in/chapter18.md:474
msgid ""
"Using this knowledge, a clever player can temporarily sacrifice pieces to "
"obtain edge and corner squares in the short run, and win back pieces in the "
"long run.\n"
"We can approximate some of this reasoning with the `weighted-squares` "
"evaluation function.\n"
"Like `count-difference`, it adds up all the player's pieces and subtracts "
"the opponents, but each piece is weighted according to the square it "
"occupies.\n"
"Edge squares are weighted highly, corner squares higher still, and squares "
"adjacent to the corners and edges have negative weights, because occupying "
"these squares often gives the opponent a means of capturing the desirable "
"square.\n"
"[Figure 18.4](#f0025) shows the standard nomenclature for edge squares: X, "
"A, B, and C.\n"
"In general, X and C squares are to be avoided, because taking them gives the "
"opponent a chance to take the corner.\n"
"The `weighted-squares` evaluation function reflects this."
msgstr ""
"Используя эти знания, умный игрок может временно пожертвовать фишками, чтобы "
"получить крайние и угловые поля в краткосрочной перспективе и отыграть фишки "
"в долгосрочной перспективе.\n"
"Мы можем аппроксимировать некоторые из этих рассуждений с помощью оценочной "
"функции `weighted-squares`(взвешенных клеток).\n"
"Как и `count-difference`, она складывает все фишки игрока и вычитает "
"противников, но каждая фишка взвешивается в соответствии с занимаемой ею "
"клеткой.\n"
"Квадраты с гранями имеют высокий вес, угловые квадраты еще выше, а квадраты, "
"прилегающие к углам и краям, имеют отрицательный вес, потому что занятие "
"этих квадратов часто дает противнику возможность захватить желаемый "
"квадрат.\n"
"[Рисунок 18.4] (#f0025) показывает стандартную номенклатуру краевых клеток: "
"X, A, B и C.\n"
"В общем, следует избегать клеток X и C, потому что их взятие дает противнику "
"шанс занять угол.\n"
"Функция оценки `weighted-squares`(взвешенных клеток) отражает это."

#: in/chapter18.md:479
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-04](images/chapter18/f18-04.jpg) |\n"
"| Figure 18.4: Names for Edge Squares    |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f18-04](images/chapter18/f18-04.jpg) |\n"
"| Рисунок 18.4: Названия краевых клеток    |"

#: in/chapter18.md:492
msgid ""
"```lisp\n"
"(defparameter *weights*\n"
"  '#(0   0   0  0  0  0  0   0   0 0\n"
"     0 120 -20 20  5  5 20 -20 120 0\n"
"     0 -20 -40 -5 -5 -5 -5 -40 -20 0\n"
"     0  20  -5 15  3  3 15  -5  20 0\n"
"     0   5  -5  3  3  3  3  -5   5 0\n"
"     0   5  -5  3  3  3  3  -5   5 0\n"
"     0  20  -5 15  3  3 15  -5  20 0\n"
"     0 -20 -40 -5 -5 -5 -5 -40 -20 0\n"
"     0 120 -20 20  5  5 20 -20 120 0\n"
"     0   0   0  0  0  0  0   0   0 0))"
msgstr ""

#: in/chapter18.md:502
msgid ""
"(defun weighted-squares (player board)\n"
"  \"Sum of the weights of player's squares minus opponent's.\"\n"
"  (let ((opp (opponent player)))\n"
"    (loop for i in all-squares\n"
"          when (eql (bref board i) player)\n"
"          sum (aref *weights* i)\n"
"          when (eql (bref board i) opp)\n"
"          sum (- (aref *weights* i)))))\n"
"```"
msgstr ""

#: in/chapter18.md:506
msgid ""
"**Exercise  18.2** Compare strategies by evaluating the two forms below.\n"
"What happens?\n"
"Is this a good test to determine which strategy is better?"
msgstr ""
"**Упражнение 18.2** Сравните стратегии, вычислив две формы ниже.\n"
"Что просходит?\n"
"Это хороший тест, чтобы определить, какая стратегия лучше?"

#: in/chapter18.md:513
msgid ""
"```lisp\n"
"(othello (maximizer #'weighted-squares)\n"
"                  (maximizer #'count-difference) nil)\n"
"(othello (maximizer #'count-difference)\n"
"                  (maximizer #'weighted-squares) nil)\n"
"```"
msgstr ""

#: in/chapter18.md:515
msgid "## 18.4 Searching Ahead: Minimax"
msgstr "## 18.4 Поиск Ahead(Заглядывая Вперед): Minimax"

#: in/chapter18.md:522
msgid ""
"Even the weighted-squares strategy is no match for an experienced player.\n"
"There are two ways we could improve the strategy.\n"
"First, we could modify the evaluation function to take more information into "
"account.\n"
"But even without changing the evaluation function, we can improve the "
"strategy by searching ahead.\n"
"Instead of choosing the move that leads immediately to the highest score, we "
"can also consider the opponent's possible replies, our replies to those "
"replies, and so on.\n"
"By searching through several levels of moves, we can steer away from "
"potential disaster and find good moves that were not immediately apparent."
msgstr ""
"Даже стратегия weighted-squares(взвешенных клеток) не подходит для опытного "
"игрока.\n"
"Есть два способа улучшить стратегию.\n"
"Во-первых, мы могли бы изменить функцию оценки, чтобы учесть больше "
"информации.\n"
"Но даже не изменяя функцию оценки, мы можем улучшить стратегию, заглянув "
"вперед.\n"
"Вместо того чтобы выбирать ход, который сразу приводит к наивысшему "
"количеству очков, мы также можем рассмотреть возможные ответы оппонента, "
"наши ответы на эти ответы и так далее.\n"
"Просматривая несколько уровней ходов, мы можем избежать потенциальной "
"катастрофы и найти хорошие ходы, которые не были очевидны сразу."

#: in/chapter18.md:524
msgid ""
"Another way to look at the `maximizer` function is as a search function that "
"searches only one level, or *ply*, deep:"
msgstr ""
"Другой способ взглянуть на функцию `maximizer` - как на функцию поиска, "
"которая ищет только один уровень или *ply/*слой, в глубину:"

#: in/chapter18.md:526
msgid "![u18-01](images/chapter18/u18-01.jpg)"
msgstr ""

#: in/chapter18.md:529
msgid ""
"The top of the tree is the current board position, and the squares below "
"that indicate possible moves.\n"
"The `maximizer` function evaluates each of these and picks the best move, "
"which is underlined in the diagram."
msgstr ""
"Верхняя часть дерева - это текущая позиция на доске, а квадраты ниже "
"указывают на возможные ходы.\n"
"Функция `maximizer` оценивает каждый из них и выбирает лучший ход, который "
"подчеркнут на диаграмме."

#: in/chapter18.md:533
msgid ""
"Now let's see how a 3-ply search might go.\n"
"The first step is to apply `maximizer` to the positions just above the "
"bottom of the tree.\n"
"Suppose we get the following values:"
msgstr ""
"Теперь посмотрим, как может пройти трехслойный поиск(3-ply).\n"
"Первый шаг - применить `maximizer` к позициям чуть выше нижней части "
"дерева.\n"
"Предположим, мы получили следующие значения:"

#: in/chapter18.md:535
msgid "![u18-02](images/chapter18/u18-02.jpg)"
msgstr ""

#: in/chapter18.md:540
msgid ""
"Each position is shown as having two possible legal moves, which is "
"unrealistic but makes the diagram fit on the page.\n"
"In a real game, five to ten legal moves per position is typical.\n"
"The values at the leaves of the tree were computed by applying the "
"evaluation function, while the values one level up were computed by "
"`maximizer`.\n"
"The result is that we know what our best move is for any of the four "
"positions just above the bottom of the tree."
msgstr ""
"Каждая позиция показана как имеющая два возможных допустимых хода, что "
"нереально, но позволяет разместить диаграмму на странице.\n"
"В реальной игре обычно от пяти до десяти разрешенных ходов на позицию.\n"
"Значения в листьях дерева были вычислены с применением функции оценки, в то "
"время как значения на один уровень выше были вычислены с помощью "
"`maximizer`.\n"
"В результате мы знаем, какой наш лучший ход для любой из четырех позиций "
"чуть выше нижней части дерева."

#: in/chapter18.md:544
msgid ""
"Going up a level, it is the opponent's turn to move.\n"
"We can assume the opponent will choose the move that results in the minimal "
"value to us, which would be the maximal value to the opponent.\n"
"Thus, the opponent's choices would be the 10- and 9-valued positions, "
"avoiding the 20- and 23-valued positions."
msgstr ""
"Поднимаясь на уровень выше, наступает очередь соперника двигаться.\n"
"Мы можем предположить, что противник выберет ход, который принесет нам "
"минимальную ценность, которая будет максимальной ценностью для оппонента.\n"
"Таким образом, противник может выбрать 10- и 9-значные позиции, избегая 20- "
"и 23-значных позиций."

#: in/chapter18.md:546
msgid "![u18-03](images/chapter18/u18-03.jpg)"
msgstr ""

#: in/chapter18.md:548
msgid ""
"Now it is our turn to move again, so we apply `maximizer` once again to get "
"the final value of the top-level position:"
msgstr ""
"Теперь наша очередь двигаться снова, поэтому мы снова применяем `maximizer`, "
"чтобы получить окончательное значение позиции верхнего уровня:"

#: in/chapter18.md:550
msgid "![u18-04](images/chapter18/u18-04.jpg)"
msgstr ""

#: in/chapter18.md:553
msgid ""
"If the opponent plays as expected, we will always follow the left branch of "
"the tree and end up at the position with value 10.\n"
"If the opponent plays otherwise, we will end up at a position with a better "
"value."
msgstr ""
"Если оппонент играет так, как ожидалось, мы всегда будем следовать за левой "
"ветвью дерева и окажемся на позиции со значением 10.\n"
"Если противник будет играть иначе, мы окажемся в более выгодной позиции."

#: in/chapter18.md:557
msgid ""
"This kind of search is traditionally called a *minimax* search, because of "
"the alternate application of the `maximizer` and a hypothetical `minimizer` "
"function.\n"
"Notice that only the leaf positions in the tree are looked at by the "
"evaluation function.\n"
"The value of all other positions is determined by minimizing and maximizing."
msgstr ""
"Этот вид поиска традиционно называется поиском *minimax*(минимакс) из-за "
"альтернативного применения функции `maximizer` и гипотетической функции "
"`minimizer`.\n"
"Обратите внимание, что функция оценки просматривает только позиции листьев в "
"дереве.\n"
"Значение(ценность) всех остальных позиций определяется минимизацией и "
"максимизацией."

#: in/chapter18.md:562
msgid ""
"We are almost ready to code the minimax algorithm, but first we have to make "
"a few design decisions.\n"
"First, we could write two functions, `minimax` and `maximin`, which "
"correspond to the two players' analyses.\n"
"However, it is easier to write a single function that maximizes the value of "
"a position for a particular player.\n"
"In other words, by adding the player as a parameter, we avoid having to "
"write two otherwise identical functions."
msgstr ""
"Мы почти готовы написать алгоритм алгоритм minimax, но сначала нам нужно "
"принять несколько конструктивных решений.\n"
"Во-первых, мы могли бы написать две функции, `minimax` и `maximin`, которые "
"соответствуют анализу двух игроков.\n"
"Однако проще написать одну функцию, которая максимизирует ценность позиции "
"для конкретного игрока.\n"
"Другими словами, добавляя игрока в качестве параметра, мы избавляемся от "
"необходимости писать две идентичные функции."

#: in/chapter18.md:568
msgid ""
"Second, we have to decide if we are going to write a general minimax "
"searcher or an Othello-specific searcher.\n"
"I decided on the latter for efficiency reasons, and because there are some "
"Othello-specific complications that need to be accounted for.\n"
"First, it is possible that a player will not have any legal moves.\n"
"In that case, we want to continue the search with the opponent to move.\n"
"If the opponent has no moves either, then the game is over, and the value of "
"the position can be determined with finality by counting the pieces."
msgstr ""
"Во-вторых, мы должны решить, собираемся ли мы написать поисковую программу "
"общего минимаксного или специфического для Отелло поисковика.\n"
"Я выбрал второй вариант из соображений эффективности, а также потому, что "
"есть некоторые специфические для Отелло осложнения, которые необходимо "
"учитывать.\n"
"Во-первых, возможно, что у игрока не будет разрешенных ходов.\n"
"В этом случае мы хотим продолжить поиски движения противника.\n"
"Если у соперника тоже нет ходов, то игра окончена, и значение(ценность) "
"позиции можно окончательно определить путем подсчета фишек."

#: in/chapter18.md:576
msgid ""
"Third, we need to decide the interaction between the normal evaluation "
"function and this final evaluation that occurs when the game is over.\n"
"We could insist that each evaluation function determine when the game is "
"over and do the proper computation.\n"
"But that overburdens the evaluation functions and may lead to wasteful "
"checking for the end of game.\n"
"Instead, I implemented a separate `final-value` evaluation function, which "
"returns 0 for a draw, a large positive number for a win, and a large "
"negative number for a loss.\n"
"Because fixnum arithmetic is most efficient, the constants `most-positive-"
"fixnum` and `most-negative-fixnum` are used.\n"
"The evaluation functions must be careful to return numbers that are within "
"this range.\n"
"All the evaluation functions in this chapter will be within range if fixnums "
"are 20 bits or more."
msgstr ""
"В-третьих, нам нужно определить взаимодействие между нормальной функцией "
"оценки и этой окончательной оценкой, которая происходит по окончании игры.\n"
"Мы могли бы настоять на том, чтобы каждая функция оценки определяла, когда "
"игра окончена, и выполняла правильные вычисления.\n"
"Но это перегружает оценочные функции и может привести к бесполезной проверке "
"в конце игры.\n"
"Вместо этого я реализовал отдельную функцию оценки `final-value`, которая "
"возвращает 0 для ничьей, большое положительное число для выигрыша и большое "
"отрицательное число для проигрыша.\n"
"Поскольку арифметика фиксированных целых чисел(fixnum) наиболее эффективна, "
"используются константы `most-positive-fixnum` и `most-negative-fixnum`.\n"
"Функции оценки должны быть аккуратны, чтобы возвращать числа, которые "
"находятся в этом диапазоне.\n"
"Все оценочные функции в этой главе будут в пределах допустимого диапазона, "
"если фиксированные числа(fixnums) составляют 20 или более бит."

#: in/chapter18.md:579
msgid ""
"In a tournament, it is not only important who wins and loses, but also by "
"how much.\n"
"If we were trying to maximize the margin of victory, then `final-value` "
"would be changed to include a small factor for the final difference."
msgstr ""
"В турнире важно не только, кто выиграет и проиграет, но и насколько.\n"
"Если бы мы пытались максимизировать вероятность победы, тогда `final-value` "
"было бы изменено, чтобы включить небольшой коэффициент для окончательной "
"разницы."

#: in/chapter18.md:583
msgid ""
"```lisp\n"
"(defconstant winning-value most-positive-fixnum)\n"
"(defconstant losing-value  most-negative-fixnum)"
msgstr ""

#: in/chapter18.md:591
msgid ""
"(defun final-value (player board)\n"
"  \"Is this a win, loss, or draw for player?\"\n"
"  (case (signum (count-difference player board))\n"
"    (-1 losing-value)\n"
"    ( 0 0)\n"
"    (+1 winning-value)))\n"
"```"
msgstr ""

#: in/chapter18.md:599
msgid ""
"Fourth, and finally, we need to decide on the parameters for the minimax "
"function.\n"
"Like the other evaluation functions, it needs the player to move and the "
"current board as parameters.\n"
"It also needs an indication of how many ply to search, and the static "
"evaluation function to apply to the leaf positions.\n"
"Thus, minimax will be a function of four arguments.\n"
"What will it return?\n"
"It needs to return the best move, but it also needs to return the value of "
"that move, according to the static evaluation function.\n"
"We use multiple values for this."
msgstr ""
"И, наконец, в-четвертых, нам нужно определиться с параметрами функции "
"minimax.\n"
"Как и другие функции оценки, она требует, для перемещения(хода) - игрока и "
"текущей доски, в качестве параметров.\n"
"Также требуется указание количества слоев для поиска(ply) и функция "
"статической оценки, применяемой к позициям листьев.\n"
"Таким образом, minimax будет функцией четырех аргументов.\n"
"Что она вернет?\n"
"Она должна вернуть лучший ход, но она также должна вернуть "
"ценность(значение) этого хода в соответствии со статической функцией "
"оценки.\n"
"Для этого мы используем несколько значений."

#: in/chapter18.md:626
msgid ""
"```lisp\n"
"(defun minimax (player board ply eval-fn)\n"
"  \"Find the best move, for PLAYER, according to EVAL-FN,\n"
"  searching PLY levels deep and backing up values.\"\n"
"  (if (= ply 0)\n"
"      (funcall eval-fn player board)\n"
"      (let ((moves (legal-moves player board)))\n"
"        (if (null moves)\n"
"            (if (any-legal-move? (opponent player) board)\n"
"                (- (minimax (opponent player) board\n"
"                            (- ply 1) eval-fn))\n"
"                (final-value player board))\n"
"            (let ((best-move nil)\n"
"                  (best-val nil))\n"
"              (dolist (move moves)\n"
"                (let* ((board2 (make-move move player\n"
"                                          (copy-board board)))\n"
"                       (val (- (minimax\n"
"                                 (opponent player) board2\n"
"                                 (- ply 1) eval-fn))))\n"
"                  (when (or (null best-val)\n"
"                            (> val best-val))\n"
"                    (setf best-val val)\n"
"                    (setf best-move move))))\n"
"              (values best-val best-move))))))\n"
"```"
msgstr ""

#: in/chapter18.md:631
msgid ""
"The `minimax` function cannot be used as a strategy function as is, because "
"it takes too many arguments and returns too many values.\n"
"The functional `minimax-searcher` returns an appropriate strategy.\n"
"Remember that a strategy is a function of two arguments: the player and the "
"board.\n"
"`get-move` is responsible for passing the right arguments to the function, "
"so the strategy need not worry about where the arguments come from."
msgstr ""
"Функция  `minimax` не может использоваться как функция стратегии как есть, "
"потому что она принимает слишком много аргументов и возвращает слишком много "
"значений.\n"
"Функционал `minimax-searcher` возвращает подходящую стратегию.\n"
"Помните, что стратегия - это функция двух аргументов: игрока и доски.\n"
"`get-move` отвечает за передачу правильных аргументов функции, поэтому "
"стратегии не нужно беспокоиться о том, откуда эти аргументы."

#: in/chapter18.md:641
msgid ""
"```lisp\n"
"(defun minimax-searcher (ply eval-fn)\n"
"  \"A strategy that searches PLY levels and then uses EVAL-FN.\"\n"
"  #'(lambda (player board)\n"
"      (multiple-value-bind (value move)\n"
"          (minimax player board ply eval-fn)\n"
"        (declare (ignore value))\n"
"        move)))\n"
"```"
msgstr ""

#: in/chapter18.md:644
msgid ""
"We can test the minimax strategy, and see that searching ahead 3 ply is "
"indeed better than looking at only 1 ply.\n"
"I show only the final result, which demonstrates that it is indeed an "
"advantage to be able to look ahead:"
msgstr ""
"Мы можем протестировать минимаксную стратегию и увидеть, что поиск вперед на "
"3-и слоя действительно лучше, чем смотреть только на 1-й слой.\n"
"Я показываю только окончательный результат, который демонстрирует, что иметь "
"возможность смотреть вперед - действительно преимущество:"

#: in/chapter18.md:650
msgid ""
"```lisp\n"
"> (othello (minimax-searcher 3 #'count-difference)\n"
"                  (maximizer #'count-difference))\n"
"...\n"
"```"
msgstr ""

#: in/chapter18.md:653
msgctxt "in/chapter18.md:653"
msgid ""
"`The game is over.\n"
"Final result:`"
msgstr ""

#: in/chapter18.md:665
msgid ""
"```lisp\n"
"      1 2 3 4 5 6 7 8      [@=53 0=0 (+53)]\n"
"10 @ @ @ @ @ @ @ @\n"
"20 @ @ @ @ @ @ @ @\n"
"30 @ @ @ @ @ @ @ @\n"
"40 @ @ @ @ @ @ @ @\n"
"50 @ @ @ @ @ @ @ @\n"
"60 . . @ @ @ @ @ @\n"
"70 . . . @ @ @ @ @\n"
"80 . . . . @ @ . .\n"
"```"
msgstr ""

#: in/chapter18.md:667
msgid "## 18.5 Smarter Searching: Alpha-Beta Search"
msgstr "## 18.5 Интеллектуальный поиск: альфа-бета поиск"

#: in/chapter18.md:672
msgid ""
"The problem with a full minimax search is that it considers too many "
"positions.\n"
"It looks at every line of play, including many improbable ones.\n"
"Fortunately, there is a way to find the optimal line of play without looking "
"at every possible position.\n"
"Let's go back to our familiar search tree:"
msgstr ""
"Проблема с полным минимаксным(minimax) поиском в том, что он учитывает "
"слишком много позиций.\n"
"Он смотрит(проверяет) на каждую линию игры, в том числе и на множество "
"невероятных.\n"
"К счастью, есть способ найти оптимальную линию игры, не обращая внимания на "
"все возможные позиции.\n"
"Вернемся к нашему знакомому дереву поиска:"

#: in/chapter18.md:674
msgid "![u18-05](images/chapter18/u18-05.jpg)"
msgstr ""

#: in/chapter18.md:681
msgid ""
"Here we have marked certain positions with question marks.\n"
"The idea is that the whole search tree evaluates to 10 regardless of the "
"value of the positions labeled ?*i*.\n"
"Consider the position labeled ?1.\n"
"It does not matter what this position evaluates to, because the opponent "
"will always choose to play toward the 10-position, to avoid the possibility "
"of the 15.\n"
"Thus, we can cut off the search at this point and not consider the ?-"
"position.\n"
"This kind of cutoff has historically been called a *beta* cutoff."
msgstr ""
"Здесь мы отметили определенные позиции вопросительными знаками.\n"
"Идея состоит в том, что все дерево поиска оценивается как 10 независимо от "
"значения позиций с меткой ?*i*.\n"
"Рассмотрим позицию с меткой ?1.\n"
"Не имеет значения, как оценивается эта позиция, потому что противник всегда "
"будет выбирать игру в сторону 10-й позиции, чтобы избежать возможности 15-й "
"позиции.\n"
"Таким образом, мы можем прервать поиск на этом этапе и не рассматривать ?- "
"позицию.\n"
"Такой вид отсечки исторически назывался отсечкой *beta*(бета)."

#: in/chapter18.md:686
msgid ""
"Now consider the position labeled ?4.\n"
"It does not matter what this position evaluates to, because we will always "
"prefer to choose the 10 position at the left branch, rather than giving the "
"opponent a chance to play to the 9-position.\n"
"This is an *alpha* cutoff.\n"
"Notice that it cuts off a whole subtree of positions below it (labeled ?2 "
"and ?3)."
msgstr ""
"Теперь рассмотрим позицию ?4.\n"
"Не имеет значения, как оценивается эта позиция, потому что мы всегда будем "
"предпочитать выбирать позицию 10 на левой ветви, а не давать противнику "
"возможность играть в позиции 9.\n"
"Это отсечка *alpha*(альфа).\n"
"Обратите внимание, что она отсекает целое поддерево позиций под ним "
"(помеченных ?2 и ?3)."

#: in/chapter18.md:695
msgid ""
"In general, we keep track of two parameters that bound the true value of the "
"current position.\n"
"The lower bound is a value we know we can achieve by choosing a certain line "
"of play.\n"
"The idea is that we need not even consider moves that will lead to a value "
"lower than this.\n"
"The lower bound has traditionally been called *alpha,* but we will name it "
"`achievable`.\n"
"The upper bound represents a value the opponent can achieve by choosing a "
"certain line of play.\n"
"It has been called *beta*, but we will call it `cutoff`.\n"
"Again, the idea is that we need not consider moves with a higher value than "
"this (because then the opponent would avoid the move that is so good for "
"us).\n"
"The alpha-beta algorithm is just minimax, but with some needless evaluations "
"pruned by these two parameters."
msgstr ""
"В общем, мы отслеживаем два параметра, которые ограничивают истинное "
"значение текущей позиции.\n"
"Нижняя граница - это значение, которое, как мы знаем, мы можем достичь, "
"выбрав определенную линию игры.\n"
"Идея состоит в том, что нам даже не нужно рассматривать ходы, которые "
"приведут к более низкому значению, чем это.\n"
"Нижнюю границу традиционно называют *альфа*, но мы будем называть ее "
"`achievable`(достижимой).\n"
"Верхняя граница представляет значение, которого может достичь противник, "
"выбрав определенную линию игры.\n"
"Оно было названо *beta*, но мы будем называть его `cutoff`(отсечением).\n"
"Опять же, идея состоит в том, что нам не нужно рассматривать ходы с более "
"высоким значением(оценкой), чем эта (потому что тогда противник избежит "
"хода, который так хорош для нас).\n"
"Алгоритм alpha-beta(альфа-бета) просто minimax(минимаксный), но без "
"необходимости некоторых ненужных оценок, отсеченных этими двумя параметрами."

#: in/chapter18.md:698
msgid ""
"In deeper trees with higher branching factors, many more evaluations can be "
"pruned.\n"
"In general, a tree of depth *d* and branching factor *b* requires *bd* "
"evaluations for full minimax, and as few as *b**d*/2 evaluations with alpha-"
"beta minimax."
msgstr ""
"На более глубоких деревьях с более высокими коэффициентами ветвления можно "
"обрезать гораздо больше оценок.\n"
"В общем, дерево глубины *d* и коэффициента ветвления *b* требует *bd* оценок "
"для полного minimax(минимакса) и всего лишь *b**d*/2 оценок с минимаксом "
"альфа-бета."

#: in/chapter18.md:703
msgid ""
"To implement alpha-beta search, we add two more parameters to the function "
"`minimax` and rename it `alpha-beta`.\n"
"`achievable` is the best score the player can achieve; it is what we want to "
"maximize.\n"
"The `cutoff` is a value that, when exceeded, will make the opponent choose "
"another branch of the tree, thus making the rest of the current level of the "
"tree irrelevant.\n"
"The test `until (>= achievable cutoff)` in the penultimate line of `minimax` "
"does the cutoff; all the other changes just involve passing the parameters "
"around properly."
msgstr ""
"Чтобы реализовать поиск по альфа-бета, мы добавляем еще два параметра к "
"функции `minimax` и переименовываем ее в `alpha-beta`.\n"
"`achievable`(достижимо) - это лучший результат, который может набрать игрок; "
"это то, что мы хотим максимизировать.\n"
"`cutoff`(обрезка) - это значение, при превышении которого противник выберет "
"другую ветвь дерева, таким образом, оставшаяся часть текущего уровня дерева "
"не будет иметь значения.\n"
"Проверка `until (>= achievable cutoff)` в предпоследней строке `minimax` "
"выполняет отсечку; все остальные изменения просто включают правильную "
"передачу параметров."

#: in/chapter18.md:731
msgid ""
"```lisp\n"
"(defun alpha-beta (player board achievable cutoff ply eval-fn)\n"
"  \"Find the best move, for PLAYER, according to EVAL-FN,\n"
"  searching PLY levels deep and backing up values,\n"
"  using cutoffs whenever possible.\"\n"
"  (if (= ply 0)\n"
"      (funcall eval-fn player board)\n"
"      (let ((moves (legal-moves player board)))\n"
"        (if (null moves)\n"
"            (if (any-legal-move? (opponent player) board)\n"
"                (- (alpha-beta (opponent player) board\n"
"                               (- cutoff) (- achievable)\n"
"                               (- ply 1) eval-fn))\n"
"                (final-value player board))\n"
"            (let ((best-move (first moves)))\n"
"              (loop for move in moves do\n"
"                (let* ((board2 (make-move move player\n"
"                                          (copy-board board)))\n"
"                       (val (- (alpha-beta\n"
"                                 (opponent player) board2\n"
"                                 (- cutoff) (- achievable)\n"
"                                 (- ply 1) eval-fn))))\n"
"                  (when (> val achievable)\n"
"                    (setf achievable val)\n"
"                    (setf best-move move)))\n"
"                until (>= achievable cutoff))\n"
"              (values achievable best-move))))))"
msgstr ""

#: in/chapter18.md:741
msgid ""
"(defun alpha-beta-searcher (depth eval-fn)\n"
"  \"A strategy that searches to DEPTH and then uses EVAL-FN.\"\n"
"  #'(lambda (player board)\n"
"      (multiple-value-bind (value move)\n"
"          (alpha-beta player board losing-value winning-value\n"
"                      depth eval-fn)\n"
"        (declare (ignore value))\n"
"        move)))\n"
"```"
msgstr ""

#: in/chapter18.md:744
msgid ""
"It must be stressed that `alpha-beta` computes the exact same result as the "
"full-search version of `minimax`.\n"
"The only advantage of the cutoffs is making the search go faster by "
"considering fewer positions."
msgstr ""
"Следует подчеркнуть, что `alpha-beta` вычисляет тот же результат, что и "
"версия `minimax` с полным поиском.\n"
"Единственное преимущество отсечки - ускорение поиска за счет меньшего "
"количества позиций."

#: in/chapter18.md:746
msgid "## 18.6 An Analysis of Some Games"
msgstr "## 18.6 Анализ некоторых игр"

#: in/chapter18.md:750
msgid ""
"Now is a good time to stop and analyze where we have gone.\n"
"We've demonstrated a program that can play a *legal* game of Othello, and "
"some strategies that may or may not play a *good* game.\n"
"First, we'll look at some individual games to see the mistakes made by some "
"strategies, and then we'll generate some statistics for series of games."
msgstr ""
"Сейчас хорошее время, чтобы остановиться и проанализировать, куда мы ушли.\n"
"Мы продемонстрировали программу, которая может играть в *legal*(легальную) "
"игру Отелло, а также некоторые стратегии, которые могут сыграть или не "
"сыграть в *хорошую* игру.\n"
"Сначала мы рассмотрим некоторые отдельные игры, чтобы увидеть ошибки, "
"допущенные некоторыми стратегиями, а затем сгенерируем некоторую статистику "
"для серий игр."

#: in/chapter18.md:756
msgid ""
"Is the weighted-squares measure a good one?\n"
"We can compare it to a strategy of maximizing the number of pieces.\n"
"Such a strategy would of course be perfect if it could look ahead to the end "
"of the game, but the speed of our computers limits us to searching only a "
"few ply, even with cutoffs.\n"
"Consider the following game, where black is maximizing the difference in the "
"number of pieces, and white is maximizing the weighted sum of squares.\n"
"Both search to a depth of 4 ply:"
msgstr ""
"Насколько хорошо взвешивание клеток?\n"
"Мы можем сравнить его со стратегией максимального увеличения количества "
"деталей.\n"
"Такая стратегия, конечно, была бы идеальной, если бы она могла смотреть в "
"будущее до конца игры, но скорость наших компьютеров ограничивает нас "
"поиском только несколькими слоями, даже с отсечками.\n"
"Рассмотрим следующую игру, в которой черные максимизируют разницу в "
"количестве фигур, а белые максимизируют взвешенную сумму клеток.\n"
"Оба ищут на глубину 4 слоя:"

#: in/chapter18.md:761
msgid ""
"```lisp\n"
"> (othello (alpha-beta-searcher 4 #'count-difference)\n"
"                      (alpha-beta-searcher 4 #'weighted-squares))\n"
"```"
msgstr ""

#: in/chapter18.md:764
msgid ""
"Black is able to increase the piece difference dramatically as the game "
"progresses.\n"
"After 17 moves, white is down to only one piece:"
msgstr ""
"Черные могут резко увеличить разницу в фигурах по ходу игры.\n"
"После 17 ходов у белых остается только одна фигура:"

#: in/chapter18.md:776
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=20 0=1 (+19)]\n"
"    10 0 @ . . . . . .\n"
"    20 . @ . . . @ @ .\n"
"    30 @ @ @ @ @ @ . .\n"
"    40 . @ . @ @ . . .\n"
"    50 @ @ @ @ @ @ . .\n"
"    60 . . @ . . . . .\n"
"    70 . . . . . . . .\n"
"    80 . . . . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:779
msgid ""
"Although behind by 19 points, white is actually in a good position, because "
"the piece in the corner is safe and threatens many of black's pieces.\n"
"White is able to maintain good position while being numerically far behind "
"black, as shown in these positions later in the game:"
msgstr ""
"Несмотря на отставание на 19 очков, белые на самом деле находятся в хорошей "
"позиции, потому что фигура в углу безопасна и угрожает многим фигурам "
"черных.\n"
"Белые могут сохранять хорошую позицию, численно сильно отставая от черных, "
"как показано в следующих позициях позже в партии:"

#: in/chapter18.md:800
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=32 0=15 (+17)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 @ @ @ @ @\n"
"    30 @ @ 0 0 @ 0 @ @\n"
"    40 0 0 @ @ @ @ @ @\n"
"    50 @ 0 @ @ @ @ . .\n"
"    60 @ @ 0 @ @ 0 . .\n"
"    70 @ . . @ @ . . .\n"
"    80 . . . . . . . .\n"
"          1 2 3 4 5 6 7 8    [@=34 0=19 (+15)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 @ @ @ @ @\n"
"    30 @ @ 0 0 @ 0 @ @\n"
"    40 0 @ 0 @ @ @ @ @\n"
"    50 0 @ 0 @ @ @ @ .\n"
"    60 0 @ 0 @ @ @ . .\n"
"    70 0 @ @ @ @ . . .\n"
"    80 0 @ 0 . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:802
msgid ""
"After some give-and-take, white gains the advantage for good by capturing "
"eight pieces on a move to square 85 on the third-to-last move of the game:"
msgstr ""
"После некоторого компромисса белые навсегда получают преимущество, захватив "
"восемь фигур на ходу на клетке 85 на предпоследнем ходу игры:"

#: in/chapter18.md:835
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=31 0=30 (+1)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 0 @ @ @ 0\n"
"    30 @ @ 0 0 0 @ @ 0\n"
"    40 0 @ 0 0 0 @ @ 0\n"
"    50 0 @ 0 @ 0 @ @ 0\n"
"    60 0 @ 0 @ @ @ @ 0\n"
"    70 0 @ @ @ @ @ 0 0\n"
"    80 0 @ @ @ . . .0\n"
"0 moves to 85.\n"
"          1 2 3 4 5 6 7 8    [@=23 0=39 (-16)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 0 @ @ @ 0\n"
"    30 @ @ 0 0 0 @ @ 0\n"
"    40 0 @ 0 0 0 @ @ 0\n"
"    50 0 @ 0 @ 0 @ @ 0\n"
"    60 0 @ 0 @ 0 @ 0 0\n"
"    70 0 @ @ 0 0 0 0 0\n"
"    80 0 0 0 0 0 . . 0\n"
"@ moves to 86.\n"
"          1 2 3 4 5 6 7 8    [@=26 0=37 (-11)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 0 @ @ @ 0\n"
"    30 @ @ 0 0 0 @ @ 0\n"
"    40 0 @ 0 0 0 @ @ 0\n"
"    50 0 @ 0 @ 0 @ @ 0\n"
"    60 0 @ 0 @ 0 @ 0 0\n"
"    70 0 @ @ 0 @ @ 0 0\n"
"    80 0 0 0 0 0 @ . 0\n"
"0 moves to 87.\n"
"```"
msgstr ""

#: in/chapter18.md:838
msgctxt "in/chapter18.md:838"
msgid ""
"`The game is over.\n"
"Final result:`"
msgstr ""

#: in/chapter18.md:851
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=24 0=40 (-16)]\n"
"    10 0 0 0 0 @ @ 0 0\n"
"    20 @ @ 0 0 @ @ @ 0\n"
"    30 @ @ 0 0 0 @ @ 0\n"
"    40 0 @ 0 0 0 @ @ 0\n"
"    50 0 @ 0 @ 0 @ @ 0\n"
"    60 0 @ 0 @ 0 @ 0 0\n"
"    70 0 @ @ 0 @ 0 0 0\n"
"    80 0 0 0 0 0 0 0 0\n"
"-16\n"
"```"
msgstr ""

#: in/chapter18.md:854
msgid ""
"White ends up winning by 16 pieces.\n"
"Black's strategy was too greedy: black was willing to give up position (all "
"four corners and all but four of the edge squares) for temporary gains in "
"material."
msgstr ""
"Белые выигрывают 16 фигурами.\n"
"Стратегия черных была слишком жадной: черные были готовы отказаться от "
"позиции (все четыре угла и все поля, кроме четырех) ради временного "
"материального выигрыша."

#: in/chapter18.md:858
msgid ""
"Increasing the depth of search does not compensate for a faulty evaluation "
"function.\n"
"In the following game, black's search depth is increased to 6 ply, while "
"white's is kept at 4.\n"
"The same things happen, although black's doom takes a bit longer to unfold."
msgstr ""
"Увеличение глубины поиска не компенсирует ошибочную функцию оценки.\n"
"В следующей игре глубина поиска черных увеличивается до 6 слоев, а у белых "
"остается 4.\n"
"Происходит то же самое, хотя судьба черных разворачивается немного дольше."

#: in/chapter18.md:863
msgid ""
"```lisp\n"
"> (othello (alpha-beta-searcher 6 #'count-difference)\n"
"                      (alpha-beta-searcher 4 #'weighted-squares))\n"
"```"
msgstr ""

#: in/chapter18.md:865
msgid "Black slowly builds up an advantage:"
msgstr "Черные медленно наращивают перевес:"

#: in/chapter18.md:877
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=21 0=8 (+13)]\n"
"    10 . . @ @ @ @ @ .\n"
"    20 . @ . @ 0 @ . .\n"
"    30 0 @ @ 0 @ 0 0 .\n"
"    40 . @ . @ 0 @ 0 .\n"
"    50 . @ @ @ @ @ . .\n"
"    60 . @ . @ . 0 . .\n"
"    70 . . . . . . . .\n"
"    80 . . . . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:880
msgid ""
"But at this point white has clear access to the upper left corner, and "
"through that corner threatens to take the whole top edge.\n"
"Still, black maintains a material edge as the game goes on:"
msgstr ""
"Но в этот момент белые имеют свободный доступ к верхнему левому углу и через "
"этот угол угрожают захватить весь верхний край.\n"
"Тем не менее, черные сохраняют материальное преимущество в ходе игры:"

#: in/chapter18.md:892
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=34 0=11 (+23)]\n"
"    10 0 . @ @ @ @ @ .\n"
"    20 . 0 0 @ @ @ . .\n"
"    30 0 @ 0 0 @ @ @ @\n"
"    40 @ @ @ @ 0 @ @ .\n"
"    50 @ @ @ @ @ 0 @ .\n"
"    60 @ @ @ @ @ @ 0 0\n"
"    70 @ . . @ . . @ 0\n"
"    80 . . . . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:894
msgid "But eventually white's weighted-squares strategy takes the lead:"
msgstr ""
"Но в конечном итоге стратегия белых с взвешенными полями выходит вперед:"

#: in/chapter18.md:906
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=23 0=27 (-4)]\n"
"    10 0 0 0 0 0 0 0 0\n"
"    20 @ @ 0 @ @ @ . .\n"
"    30 0 @ 0 0 @ @ @ @\n"
"    40 0 @ 0 @ 0 @ @ .\n"
"    50 0 @ 0 @ @ 0 @ .\n"
"    60 0 0 0 @ @ @ 0 0\n"
"    70 0 . 0 @ . . @ 0\n"
"    80 0 . . . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:908
msgid "and is able to hold on to win:"
msgstr "и умеет держаться за победу:"

#: in/chapter18.md:921
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=24 0=40 (-16)]\n"
"    10 0 0 0 0 0 0 0 0\n"
"    20 @ @ 0 @ 0 0 @ @\n"
"    30 0 @ 0 0 @ @ @ @\n"
"    40 0 @ 0 0 @ @ @ 0\n"
"    50 0 0 @ @ 0 @ 0 0\n"
"    60 0 0 0 @ 0 @ @ 0\n"
"    70 0 0 0 0 @ @ 0 0\n"
"    80 0 0 0 0 0 @ @ 0\n"
"-16\n"
"```"
msgstr ""

#: in/chapter18.md:926
msgid ""
"This shows that brute-force searching is not a panacea.\n"
"While it is helpful to be able to search deeper, greater gains can be made "
"by making the evaluation function more accurate.\n"
"There are many problems with the weighted-squares evaluation function.\n"
"Consider again this position from the first game above:"
msgstr ""
"Это показывает, что перебор не панацея.\n"
"Хотя полезно иметь возможность искать глубже, можно получить больше выгоды, "
"сделав функцию оценки более точной.\n"
"Есть много проблем с функцией вычисления взвешенных клеток.\n"
"Снова рассмотрим эту позицию из первой игры выше:"

#: in/chapter18.md:938
msgid ""
"```lisp\n"
"          1 2 3 4 5 6 7 8    [@=20 0=1 (+19)]\n"
"    10 0 @ . . . . . .\n"
"    20 . @ . . . @ @ .\n"
"    30 @ @ @ @ @ @ . .\n"
"    40 . @ . @ @ . . .\n"
"    50 @ @ @ @ @ @ . .\n"
"    60 . @ . . . . . .\n"
"    70 . . . . . . . .\n"
"    80 . . . . . . . .\n"
"```"
msgstr ""

#: in/chapter18.md:946
msgid ""
"Here white, playing the weighted-squares strategy, chose to play 66.\n"
"This is probably a mistake, as 13 would extend white's dominance of the top "
"edge, and allow white to play again (since black would have no legal "
"moves).\n"
"Unfortunately, white rejects this move, primarily because square 12 is "
"weighted as -20.\n"
"Thus, there is a disincentive to taking this square.\n"
"But 12 is weighted -20 because it is a bad idea to take such a square when "
"the corner is empty-the opponent will then have a chance to capture the "
"corner, regaining the 12 square as well.\n"
"Thus, we want squares like 12 to have a negative score when the corner is "
"empty, but not when it is already occupied.\n"
"The `modified-weighted-squares` evaluation function does just that."
msgstr ""
"Здесь белые, используя стратегию взвешенных полей, предпочли сыграть 66.\n"
"Вероятно, это ошибка, поскольку 13 расширит доминирование белых на верхнем "
"краю и позволит белым играть снова (поскольку у черных не будет разрешенных "
"ходов).\n"
"К сожалению, белые отвергают этот ход, прежде всего потому, что поле 12 "
"имеет вес -20.\n"
"Таким образом, есть сдерживающий фактор для взятия этой клетки.\n"
"Но 12 имеет вес -20, потому что брать такое поле(клетку), когда угол пуст, - "
"плохая идея - тогда у оппонента будет шанс захватить угол, вернув себе также "
"клетку 12.\n"
"Таким образом, мы хотим, чтобы у клеток вроде 12 была отрицательная оценка, "
"когда угол пуст, но не тогда, когда он уже занят.\n"
"Функция оценки `modified-weighted-squares` делает именно это."

#: in/chapter18.md:960
msgid ""
"```lisp\n"
"(defun modified-weighted-squares (player board)\n"
"  \"Like WEIGHTED-SQUARES, but don't take off for moving\n"
"  near an occupied corner.\"\n"
"  (let ((w (weighted-squares player board)))\n"
"    (dolist (corner '(11 18 81 88))\n"
"      (when (not (eql (bref board corner) empty))\n"
"        (dolist (c (neighbors corner))\n"
"          (when (not (eql (bref board c) empty))\n"
"            (incf w (* (- 5 (aref *weights* c))\n"
"                       (if (eql (bref board c) player)\n"
"                           +1 -1)))))))\n"
"    w))"
msgstr ""

#: in/chapter18.md:968
msgid ""
"(let ((neighbor-table (make-array 100 :initial-element nil)))\n"
"  ;; Initialize the neighbor table\n"
"  (dolist (square all-squares)\n"
"    (dolist (dir all-directions)\n"
"      (if (valid-p (+ square dir))\n"
"          (push (+ square dir)\n"
"                (aref neighbor-table square)))))"
msgstr ""

#: in/chapter18.md:973
msgid ""
"  (defun neighbors (square)\n"
"    \"Return a list of all squares adjacent to a square.\"\n"
"    (aref neighbor-table square)))\n"
"```"
msgstr ""

#: in/chapter18.md:975
msgid "## 18.7 The Tournament Version of Othello"
msgstr "## 18.7 Турнирная версия Отелло"

#: in/chapter18.md:981
msgid ""
"While the `othello` function serves as a perfectly good moderator for casual "
"play, there are two points that need to be fixed for tournament-level play.\n"
"First, tournament games are played under a strict time limit: a player who "
"takes over 30 minutes total to make all the moves forfeits the game.\n"
"Second, the standard notation for Othello games uses square names in the "
"range al to h8, rather than in the 11 to 88 range that we have used so far.\n"
"a1 is the upper left corner, a8 is the lower left corner, and h8 is the "
"lower right corner.\n"
"We can write routines to translate between this notation and the one we were "
"using by creating a table of square names."
msgstr ""
"Хотя функция `othello` служит прекрасным модератором для случайной игры, "
"есть два момента, которые необходимо исправить для игры на уровне турнира.\n"
"Во-первых, турнирные игры проходят в строго ограниченное время: игрок, "
"которому требуется более 30 минут, чтобы сделать все ходы, выбывает из "
"игры.\n"
"Во-вторых, в стандартной нотации игр Отелло используются названия клеток в "
"диапазоне от a1 до h8, а не в диапазоне от 11 до 88, который мы использовали "
"до сих пор.\n"
"a1 - левый верхний угол, a8 - левый нижний угол, а h8 - правый нижний угол.\n"
"Мы можем написать процедуры для перевода между этой нотацией и той, которую "
"мы использовали, создав таблицу имен клеток."

#: in/chapter18.md:987
msgid ""
"```lisp\n"
"(let ((square-names\n"
"        (cross-product #'symbol\n"
"                       '(? a b c d e f g h ?)\n"
"                       '(? 1 2 3 4 5 6 7 8 ?))))"
msgstr ""

#: in/chapter18.md:992
msgid ""
"  (defun h8->88 (str)\n"
"    \"Convert from alphanumeric to numeric square notation.\"\n"
"    (or (position (string str) square-names :test #'string-equal)\n"
"        str))"
msgstr ""

#: in/chapter18.md:998
msgid ""
"  (defun 88->h8 (num)\n"
"    \"Convert from numeric to alphanumeric square notation.\"\n"
"    (if (valid-p num)\n"
"        (elt square-names num)\n"
"        num)))"
msgstr ""

#: in/chapter18.md:1006
msgid ""
"(defun cross-product (fn xlist ylist)\n"
"  \"Return a list of all (fn x y) values.\"\n"
"  (mappend #'(lambda (y)\n"
"               (mapcar #'(lambda (x) (funcall fn x y))\n"
"                       xlist))\n"
"           ylist))\n"
"```"
msgstr ""

#: in/chapter18.md:1010
msgid ""
"Note that these routines return their input unchanged when it is not one of "
"the expected values.\n"
"This is to allow commands other than moving to a particular square.\n"
"For example, we will add a feature that recognizes `resign` as a move."
msgstr ""
"Обратите внимание, что эти подпрограммы возвращают свой ввод без изменений, "
"если он не является одним из ожидаемых значений.\n"
"Это позволяет выполнять команды, отличные от перехода к определенной "
"клетке.\n"
"Например, мы добавим функцию, которая распознает `resign`(отставку) как ход."

#: in/chapter18.md:1013
msgid ""
"The `human` player needs to be changed slightly to read moves in this "
"format.\n"
"While we're at it, we'll also print the list of possible moves:"
msgstr ""
"Чтобы читать ходы в этом формате, нужно немного изменить игрока `human`-"
"человека.\n"
"Пока мы это сделаем, мы также распечатаем список возможных ходов:"

#: in/chapter18.md:1021
msgid ""
"```lisp\n"
"(defun human (player board)\n"
"  \"A human player for the game of Othello\"\n"
"  (format t \"~&~c to move ~a: \" (name-of player)\n"
"          (mapcar #'88->h8 (legal-moves player board)))\n"
"  (h8->88 (read)))\n"
"```"
msgstr ""

#: in/chapter18.md:1026
msgid ""
"| []()                                                        |\n"
"|-------------------------------------------------------------|\n"
"| ![f18-05](images/chapter18/f18-05.jpg)                      |\n"
"| Figure 18.5: Glossary for the Tournament Version of Othello |"
msgstr ""
"| []()                                                        |\n"
"|-------------------------------------------------------------|\n"
"| ![f18-05](images/chapter18/f18-05.jpg)                      |\n"
"| Рисунок 18.5: Глоссарий турнирной версии Отелло|"

#: in/chapter18.md:1028
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter18.md:1033
msgid ""
"The `othello` function needn't worry about notation, but it does need to "
"monitor the time.\n"
"We make up a new data structure, the clock, which is an array of integers "
"saying how much time (in internal units) each player has left.\n"
"For example, (`aref clock black`) is the amount of time black has left to "
"make all his moves.\n"
"In Pascal, we would declare the clock array as `array[black..white]`, but in "
"Common Lisp all arrays are zero-based, so we need an array of three elements "
"to allow the subscript `black`, which is 2."
msgstr ""
"Функция `othello` не должна беспокоиться об обозначениях, но она должна "
"отслеживать время.\n"
"Мы создаем новую структуру данных, `clock`(часы), которая представляет собой "
"массив целых чисел, показывающих, сколько времени (во внутренних единицах) "
"осталось у каждого игрока.\n"
"Например, (`aref clock black`) - это количество времени, которое осталось "
"черным, чтобы сделать все свои ходы.\n"
"В Паскале мы бы объявили массив часов как `array[black..white]`, но в Common "
"Lisp все массивы начинаются с нуля, поэтому нам нужен массив из трех "
"элементов, чтобы разрешить индекс `black`, который равен 2."

#: in/chapter18.md:1039
msgid ""
"The clock is passed to `get-move` and `print-board` but is otherwise "
"unused.\n"
"I could have complicated the main game loop by adding tests for forfeits "
"because of expired time and, as we shall see later, resignation by either "
"player.\n"
"However, I felt that would add a great deal of complexity for rarely used "
"options.\n"
"Instead, I wrap the whole game loop, along with the computation of the final "
"score, in a `catch` special form.\n"
"Then, if get-move encounters a forfeit or resignation, it can `throw` an "
"appropriate final score: 64 or -64, depending on which player forfeits."
msgstr ""
"clock(Часы) передаётся командам `get-move` и `print-board`, но в остальыми "
"не используются.\n"
"Я мог бы усложнить основной игровой цикл, добавив тесты для расплаты из-за "
"истекшего времени и, как мы увидим позже, отставки любого игрока.\n"
"Однако я чувствовал, что это значительно усложнит редко используемые опции.\n"
"Вместо этого я оборачиваю весь игровой цикл вместе с вычислением финального "
"счета в специальную форму `catch`.\n"
"Затем, если  get-move встречает forfeit(поражение/расплату) или отставку, "
"она может `throw`(выбросить) соответствующий окончательный счет: 64 или -64, "
"в зависимости от того, какой игрок потерпел поражение."

#: in/chapter18.md:1042
msgid ""
"```lisp\n"
"(defvar *move-number* 1 \"The number of the move to be played\")"
msgstr ""

#: in/chapter18.md:1065
msgid ""
"(defun othello (bl-strategy wh-strategy\n"
"                &optional (print t) (minutes 30))\n"
"  \"Play a game of othello.  Return the score, where a positive\n"
"  difference means black, the first player, wins.\"\n"
"  (let ((board (initial-board))\n"
"        (clock (make-array (+ 1 (max black white))\n"
"                           :initial-element\n"
"                           (* minutes 60\n"
"                              internal-time-units-per-second))))\n"
"    (catch 'game-over\n"
"      (loop for *move-number* from 1\n"
"            for player = black then (next-to-play board player print)\n"
"            for strategy = (if (eql player black)\n"
"                               bl-strategy\n"
"                               wh-strategy)\n"
"            until (null player)\n"
"            do (get-move strategy player board print clock))\n"
"      (when print\n"
"        (format t \"~&The game is over.  Final result:\")\n"
"        (print-board board clock))\n"
"      (count-difference black board))))\n"
"```"
msgstr ""

#: in/chapter18.md:1072
msgid ""
"Strategies now have to comply with the time-limit rule, so they may want to "
"look at the time remaining.\n"
"Rather than passing the clock in as an argument to the strategy, I decided "
"to store the clock in the special variable `*clock*`.\n"
"The new version of `othello` also keeps track of the `*move-number*`.\n"
"This also could have been passed to the strategy functions as a parameter.\n"
"But adding these extra arguments would require changes to all the strategies "
"we have developed so far.\n"
"By storing the information in special variables, strategies that want to can "
"look at the clock or the move number, but other strategies don't have to "
"know about them."
msgstr ""
"Теперь стратегии должны соответствовать правилу ограничения по времени, "
"поэтому они могут захотеть посмотреть на оставшееся время.\n"
"Вместо того, чтобы передавать clock(часы) в качестве аргумента стратегии, я "
"решил сохранить их в специальной переменной `*clock*`.\n"
"Новая версия `othello` также отслеживает `*move-number*`(номер хода).\n"
"Его также можно было передавать в функции стратегии в качестве параметра.\n"
"Но добавление этих дополнительных аргументов потребует внесения изменений во "
"все стратегии, которые мы разработали до сих пор.\n"
"Сохраняя информацию в специальных переменных, стратегии, которые хотят "
"видеть, могут смотреть на часы или число ходов, но другие стратегии не "
"должны знать о них."

#: in/chapter18.md:1076
msgid ""
"We still have the security problem-we don't want a strategy to be able to "
"set the opponent's remaining time to zero and thereby win the game.\n"
"Thus, we use `*clock*` only as a copy of the \"real\" game clock.\n"
"The function `replace` copies the real clock into `*clock*`, and also copies "
"the real board into `*board*`."
msgstr ""
"У нас все еще есть проблема безопасности - мы не хотим, чтобы стратегия "
"могла обнулять оставшееся время противника и, таким образом, выигрывала "
"игру.\n"
"Таким образом, мы используем `*clock*` только как копию \"настоящих\" "
"игровых часов.\n"
"Функция `replace` копирует реальные часы(clock) в *clock*, а также копирует "
"реальную доску в `*board*`."

#: in/chapter18.md:1080
msgid ""
"```lisp\n"
"(defvar *clock* (make-array 3) \"A copy of the game clock\")\n"
"(defvar *board* (initial-board) \"A copy of the game board\")"
msgstr ""

#: in/chapter18.md:1107
msgid ""
"(defun get-move (strategy player board print clock)\n"
"  \"Call the player's strategy function to get a move.\n"
"  Keep calling until a legal move is made.\"\n"
"  ;; Note we don't pass the strategy function the REAL board.\n"
"  ;; If we did, it could cheat by changing the pieces on the board.\n"
"  (when print (print-board board clock))\n"
"  (replace *clock* clock)\n"
"  (let* ((t0 (get-internal-real-time))\n"
"         (move (funcall strategy player (replace *board* board)))\n"
"         (t1 (get-internal-real-time)))\n"
"    (decf (elt clock player) (- t1 t0))\n"
"    (cond\n"
"      ((< (elt clock player) 0)\n"
"       (format t \"~&~c has no time left and forfeits.\"\n"
"               (name-of player))\n"
"       (THROW 'game-over (if (eql player black) -64 64)))\n"
"      ((eq move 'resign)\n"
"       (THROW 'game-over (if (eql player black) -64 64)))\n"
"      ((and (valid-p move) (legal-p move player board))\n"
"       (when print\n"
"         (format t \"~&~c moves to ~a.\"\n"
"                 (name-of player) (88->h8 move)))\n"
"       (make-move move player board))\n"
"      (t (warn \"Illegal move: ~a\" (88->h8 move))\n"
"         (get-move strategy player board print clock)))))\n"
"```"
msgstr ""

#: in/chapter18.md:1111
msgid ""
"Finally, the function `print-board` needs to print the time remaining for "
"each player; this requires an auxiliary function to get the number of "
"minutes and seconds from an internal-format time interval.\n"
"Note that we make the arguments optional, so that in debugging one can say "
"just (`print-board`) to see the current situation.\n"
"Also note the esoteric format option: `\"~2, '0d\"` prints a decimal number "
"using at least two places, padding on the left with zeros."
msgstr ""
"Наконец, функция `print-board` должна распечатать оставшееся время для "
"каждого игрока; для этого требуется вспомогательная функция для получения "
"количества минут и секунд из временного интервала внутреннего формата.\n"
"Обратите внимание, что мы делаем аргументы необязательными, чтобы при "
"отладке можно было просто сказать (`print-board`), чтобы увидеть текущую "
"ситуацию.\n"
"Также обратите внимание на опцию эзотерического формата: `\"~2, '0d\"` "
"печатает десятичное число, используя как минимум два разряда, с заполнением "
"слева нулями."

#: in/chapter18.md:1131
msgid ""
"```lisp\n"
"(defun print-board (&optional (board *board*) clock)\n"
"  \"Print a board, along with some statistics.\"\n"
"  ;; First print the header and the current score\n"
"  (format t \"~2&    a b c d e f g h   [~c=~2a ~c=~2a (~@d)]\"\n"
"          (name-of black) (count black board)\n"
"          (name-of white) (count white board)\n"
"          (count-difference black board))\n"
"  ;; Print the board itself\n"
"  (loop for row from 1 to 8 do\n"
"        (format t \"~&  ~d \" row)\n"
"        (loop for col from 1 to 8\n"
"              for piece = (bref board (+ col (* 10 row)))\n"
"              do (format t \"~c \" (name-of piece))))\n"
"  ;; Finally print the time remaining for each player\n"
"  (when clock\n"
"    (format t \"  [~c=~a ~c=~a]~2&\"\n"
"            (name-of black) (time-string (elt clock black))\n"
"            (name-of white) (time-string (elt clock white)))))"
msgstr ""

#: in/chapter18.md:1138
msgid ""
"(defun time-string (time)\n"
"  \"Return a string representing this internal time in min:secs.\"\n"
"  (multiple-value-bind (min sec)\n"
"      (floor (round time internal-time-units-per-second) 60)\n"
"    (format nil \"~2d:~2,'0d\" min sec)))\n"
"```"
msgstr ""

#: in/chapter18.md:1140
msgid "## 18.8 Playing a Series of Games"
msgstr "## 18.8 Игра в серию игр"

#: in/chapter18.md:1143
msgid ""
"A single game is not enough to establish that one strategy is better than "
"another.\n"
"The following function allows two strategies to compete in a series of games:"
msgstr ""
"Одной игры недостаточно, чтобы установить, что одна стратегия лучше другой.\n"
"Следующая функция позволяет двум стратегиям соревноваться в серии игр:"

#: in/chapter18.md:1161
msgctxt "in/chapter18.md:1161"
msgid ""
"```lisp\n"
"(defun othello-series (strategy1 strategy2 n-pairs)\n"
"  \"Play a series of 2*n-pairs games, swapping sides.\"\n"
"  (let ((scores\n"
"          (loop repeat n-pairs\n"
"             for random-state = (make-random-state)\n"
"             collect (othello strategy1 strategy2 nil)\n"
"             do (setf *random-state* random-state)\n"
"             collect (- (othello strategy2 strategy1 nil)))))\n"
"    ;; Return the number of wins (1/2 for a tie),\n"
"    ;; the total of the point differences, and the\n"
"    ;; scores themselves, all from strategy1's point of view.\n"
"    (values (+ (count-if #'plusp scores)\n"
"               (/ (count-if #'zerop scores) 2))\n"
"            (apply #'+ scores)\n"
"            scores)))\n"
"```"
msgstr ""

#: in/chapter18.md:1163
msgid ""
"Let's see what happens when we use it to pit the two weighted-squares "
"functions against each other in a series of ten games:"
msgstr ""
"Давайте посмотрим, что произойдет, когда мы используем её, чтобы сопоставить "
"две функции взвешивания клеток друг с другом в серии из десяти игр:"

#: in/chapter18.md:1172
msgid ""
"```lisp\n"
">(othello-series\n"
"        (alpha-beta-searcher 2 #'modified-weighted-squares)\n"
"        (alpha-beta-searcher 2 #'weighted-squares) 5)\n"
"0\n"
"60\n"
"(-28 40 -28 40 -28 40 -28 40 -28 40)\n"
"```"
msgstr ""

#: in/chapter18.md:1176
msgid ""
"Something is suspicious here-the same scores are being repeated.\n"
"A little thought reveals why: neither strategy has a random component, so "
"the exact same game was played five times with one strategy going first, and "
"another game was played five times when the other strategy goes first!\n"
"A more accurate appraisal of the two strategies' relative worth would be "
"gained by starting each game from some random position and playing from "
"there."
msgstr ""
"Что-то тут подозрительно - повторяются одни и те же оценки.\n"
"Небольшое раздумье показывает, почему: ни одна стратегия не имеет случайного "
"компонента, поэтому одна и та же игра была сыграна пять раз, причем одна "
"стратегия все время была первой, и игра была сыграна пять раз, когда другая "
"стратегия была первой!\n"
"Более точная оценка относительной ценности двух стратегий может быть "
"получена, если начинать каждую игру с некоторой случайной позиции и играть "
"оттуда."

#: in/chapter18.md:1182
msgid ""
"Think for a minute how you would design to run a series of games starting "
"from a random position.\n"
"One possibility would be to change the function `othello` to accept an "
"optional argument indicating the initial state of the board.\n"
"Then `othello-series` could be changed to somehow generate a random board "
"and pass it to `othello`.\n"
"While this approach is feasible, it means changing two existing working "
"functions, as well as writing another function, `generate-random-board`.\n"
"But we couldn't generate just any random board: it would have to be a legal "
"board, so it would have to call `othello` and somehow get it to stop before "
"the game was over."
msgstr ""
"Подумайте на минутку, как бы вы спроектировали запуск серии игр, начиная со "
"случайной позиции.\n"
"Одна из возможностей - изменить функцию `othello`, чтобы она принимала "
"необязательный аргумент, указывающий начальное состояние доски.\n"
"Затем можно изменить `othello-series`, чтобы каким-то образом генерировать "
"случайную доску и передавать ее в `othello`.\n"
"Хотя такой подход осуществим, он означает изменение двух существующих "
"рабочих функций, а также написание другой функции, `generate-random-board`.\n"
"Но мы не можем генерировать просто любую случайную доску: это должна быть "
"легальная доска, поэтому она должна будет вызвать `othello` и каким-то "
"образом заставить ее остановиться до завершения игры."

#: in/chapter18.md:1185
msgid ""
"An alternative is to leave both `othello` and `othello-series` alone and "
"build another function on top of it, one that works by passing in two new "
"strategies: strategies that make a random move for the first few moves and "
"then revert to the normal specified behavior.\n"
"This is a better solution because it uses existing functions rather than "
"modifying them, and because it requires no new functions besides `switch-"
"strategies`, which could prove useful for other purposes, and `random-"
"othello-series`, which does nothing more than call `othello-series` with the "
"proper arguments."
msgstr ""
"Альтернативный вариант - оставить в покое и `othello`, и `othello-series`, и "
"построить на их основе еще одну функцию, которая работает, передавая две "
"новые стратегии: стратегии, которые делают случайный ход в течение первых "
"нескольких ходов, а затем возвращаются в нормальное указанное поведение.\n"
"Это лучшее решение, потому что оно использует существующие функции, а не "
"модифицирует их, и потому что не требует новых функций, кроме `switch-"
"strategies`(переключения стратегий), которая может оказаться полезной для "
"других целей, и `random-othello-series`, которая больше ничего не делает. "
"кроме вызова `othello-series` с соответствующими аргументами."

#: in/chapter18.md:1194
msgid ""
"```lisp\n"
"(defun random-othello-series (strategy1 strategy2\n"
"                              n-pairs &optional (n-random 10))\n"
"  \"Play a series of 2*n games, starting from a random position.\"\n"
"  (othello-series\n"
"    (switch-strategies #'random-strategy n-random strategy1)\n"
"    (switch-strategies #'random-strategy n-random strategy2)\n"
"    n-pairs))"
msgstr ""

#: in/chapter18.md:1202
msgid ""
"(defun switch-strategies (strategy1 m strategy2)\n"
"  \"Make a new strategy that plays strategy1 for m moves,\n"
"  then plays according to strategy2.\"\n"
"  #'(lambda (player board)\n"
"      (funcall (if (<= *move-number* m) strategy1 strategy2)\n"
"               player board)))\n"
"```"
msgstr ""

#: in/chapter18.md:1207
msgid ""
"There is a problem with this kind of series: it may be that one of the "
"strategies just happens to get better random positions.\n"
"A fairer test would be to play two games from each random position, one with "
"the each strategy playing first.\n"
"One way to do that is to alter `othello-series` so that it saves the random "
"state before playing the first game of a pair, and then restores the saved "
"random state before playing the second game.\n"
"That way the same random position will be duplicated."
msgstr ""
"Есть проблема с такими сериями: может случиться так, что одна из стратегий "
"просто дает лучший результат в случайных позициях.\n"
"Более справедливым испытанием было бы сыграть по две игры в каждой случайной "
"позиции, по одной с каждой стратегией, играющей первой.\n"
"Один из способов сделать это - изменить `othello-series` так, чтобы она "
"сохраняла случайное состояние перед игрой в первую игру пары, а затем "
"восстанавливала сохраненное случайное состояние перед началом второй игры.\n"
"Таким образом, будет продублирована одна и та же случайная позиция."

#: in/chapter18.md:1225
msgctxt "in/chapter18.md:1225"
msgid ""
"```lisp\n"
"(defun othello-series (strategy1 strategy2 n-pairs)\n"
"  \"Play a series of 2*n-pairs games, swapping sides.\"\n"
"  (let ((scores\n"
"          (loop repeat n-pairs\n"
"             for random-state = (make-random-state)\n"
"             collect (othello strategy1 strategy2 nil)\n"
"             do (setf *random-state* random-state)\n"
"             collect (- (othello strategy2 strategy1 nil)))))\n"
"    ;; Return the number of wins (1/2 for a tie),\n"
"    ;; the total of the point differences, and the\n"
"    ;; scores themselves, all from strategy1's point of view.\n"
"    (values (+ (count-if #'plusp scores)\n"
"               (/ (count-if #'zerop scores) 2))\n"
"            (apply #'+ scores)\n"
"            scores)))\n"
"```"
msgstr ""

#: in/chapter18.md:1228
msgid ""
"Now we are in a position to do a more meaningful test.\n"
"In the following, the weighted-squares strategy wins 4 out of 10 games "
"against the modified strategy, losing by a total of 76 pieces, with the "
"actual scores indicated."
msgstr ""
"Теперь мы можем провести более значимый тест.\n"
"Далее стратегия взвешенных клеток выигрывает в 4 из 10 игр против "
"модифицированной стратегии, проигрывая в общей сложности 76 фишек, с "
"указанными фактическими очками."

#: in/chapter18.md:1236
msgid ""
"```lisp\n"
"> (random-othello-series\n"
"        (alpha-beta-searcher 2 #'weighted-squares)\n"
"        (alpha-beta-searcher 2#'modified-weighted-squares)\n"
"        5)\n"
"4\n"
"```"
msgstr ""

#: in/chapter18.md:1238
msgid "-  `76`"
msgstr ""

#: in/chapter18.md:1242
msgid ""
"```lisp\n"
"(-8 -40 22 -30 10 -10 12 -18 4 -18)\n"
"```"
msgstr ""

#: in/chapter18.md:1245
msgid ""
"The `random-othello-series` function is useful for comparing two "
"strategies.\n"
"When there are more than two strategies to be compared at the same time, the "
"following function can be useful:"
msgstr ""
"Функция `random-othello-series` полезна для сравнения двух стратегий.\n"
"Когда можно сравнить более двух стратегий одновременно, может быть полезна "
"следующая функция:"

#: in/chapter18.md:1276
msgid ""
"```lisp\n"
"(defun round-robin (strategies n-pairs &optional\n"
"                    (n-random 10) (names strategies))\n"
"  \"Play a tournament among the strategies.\n"
"  N-PAIRS = games each strategy plays as each color against\n"
"  each opponent.  So with N strategies, a total of\n"
"  N*(N-1)*N-PAIRS games are played.\"\n"
"  (let* ((N (length strategies))\n"
"         (totals (make-array N :initial-element 0))\n"
"         (scores (make-array (list N N)\n"
"                             :initial-element 0)))\n"
"    ;; Play the games\n"
"    (dotimes (i N)\n"
"      (loop for j from (+ i 1) to (- N 1) do\n"
"          (let* ((wins (random-othello-series\n"
"                         (elt strategies i)\n"
"                         (elt strategies j)\n"
"                         n-pairs n-random))\n"
"                 (losses (- (* 2 n-pairs) wins)))\n"
"            (incf (aref scores i j) wins)\n"
"            (incf (aref scores j i) losses)\n"
"            (incf (aref totals i) wins)\n"
"            (incf (aref totals j) losses))))\n"
"    ;; Print the results\n"
"    (dotimes (i N)\n"
"      (format t \"~&~a~20T ~4f: \" (elt names i) (elt totals i))\n"
"      (dotimes (j N)\n"
"        (format t \"~4f \" (if (= i j) '---\n"
"                             (aref scores i j)))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1278
msgid "Here is a comparison of five strategies that search only 1 ply:"
msgstr "Вот сравнение пяти стратегий, которые проводят поиск только 1-ом слое:"

#: in/chapter18.md:1283
msgid ""
"```lisp\n"
"(defun mobility (player board)\n"
"  \"The number of moves a player has.\"\n"
"  (length (legal-moves player board)))"
msgstr ""

#: in/chapter18.md:1298
msgid ""
"> (round-robin\n"
"    (list (maximizer #'count-difference)\n"
"                (maximizer #'mobility)\n"
"                (maximizer #'weighted-squares)\n"
"                (maximizer #'modified-weighted-squares)\n"
"                #'random-strategy)\n"
"    5 10\n"
"    '(count-difference mobility weighted modified-weighted random))\n"
"COUNT-DIFFERENCE      12.5:   --- 3.0 2.5 0.0 7.0\n"
"MOBILITY                      20.5:   7.0 --- 1.5 5.0 7.0\n"
"WEIGHTED                      28.0:   7.5 8.5 --- 3.0 9.0\n"
"MODIFIED-WEIGHTED    31.5: 10.0 5.0 7.0 --- 9.5\n"
"RANDOM                            7.5:   3.0 3.0 1.0 0.5 ---\n"
"```"
msgstr ""

#: in/chapter18.md:1303
msgid ""
"The parameter `n-pairs` is 5, meaning that each strategy plays five games as "
"black and five as white against each of the other four strategies, for a "
"total of 40 games for each strategy and 100 games overall.\n"
"The first line of output says that the count-difference strategy won 12.5 of "
"its 40 games, including 3 against the mobility strategy, 2.5 against the "
"weighted strategy, none against the modified weighted, and 7 against the "
"random strategy.\n"
"The fact that the random strategy manages to win 7.5 out of 40 games "
"indicates that the other strategies are not amazingly strong.\n"
"Now we see what happens when the search depth is increased to 4 ply (this "
"will take a while to run):"
msgstr ""
"Параметр `n-pairs` равен 5, что означает, что каждая стратегия играет пять "
"игр черными и пять белыми против каждой из четырех других стратегий, всего "
"40 игр для каждой стратегии и 100 игр в целом.\n"
"В первой строке выходных данных говорится, что стратегия count-"
"difference(подсчет различий) выиграла 12,5 из 40 игр, в том числе 3 - против "
"стратегии mobility(мобильности), 2,5 - против weighted(взвешенной) "
"стратегии, ни одной - против (modified weighted)модифицированной взвешенной "
"и 7 - против (random)случайной стратегии.\n"
"Тот факт, что случайная стратегия позволяет выиграть 7,5 из 40 игр, "
"указывает на то, что другие стратегии не слишком сильны.\n"
"Теперь мы Увидим, что происходит, когда глубина поиска увеличивается до 4 "
"слоев (это займет некоторое время):"

#: in/chapter18.md:1317
msgid ""
"```lisp\n"
"> (round-robin\n"
"    (list (alpha-beta-searcher 4 #'count-difference)\n"
"                (alpha-beta-searcher 4 #'weighted-squares)\n"
"                (alpha-beta-searcher 4 #'modified-weighted-squares)\n"
"                #'random-strategy)\n"
"    5 10\n"
"    '(count-difference weighted modified-weighted random))\n"
"COUNT-DIFFERENCE      12.0:   --- 2.0 0.0 10.0\n"
"WEIGHTED                      23.5:   8.0 --- 5.5 10.0\n"
"MODIFIED-WEIGHTED    24.5: 10.0 4.5 --- 10.0\n"
"RANDOM                            0.0:   0.0 0.0 0.0   ---\n"
"```"
msgstr ""

#: in/chapter18.md:1321
msgid ""
"Here the random strategy does not win any games-an indication that the other "
"strategies are doing something right.\n"
"Notice that the modified weighted-squares has only a slight advantage over "
"the weighted-squares, and in fact it lost their head-to-head series, four "
"games to five, with one draw.\n"
"So it is not clear which strategy is better."
msgstr ""
"Здесь случайная стратегия не выигрывает ни в одной игре - это признак того, "
"что другие стратегии что-то делают правильно.\n"
"Обратите внимание, что модифицированная стратегия взвешенных клеток  имеет "
"лишь небольшое преимущество перед стратегией взвешеных клеток, и на самом "
"деле они проиграла свою серию личных встреч, четыре игры против пяти, с "
"одной ничьей.\n"
"Так что не ясно, какая стратегия лучше."

#: in/chapter18.md:1328
msgid ""
"The output does not break down wins by black or white, nor does it report "
"the numerical scores.\n"
"I felt that that would clutter up the output too much, but you're welcome to "
"add this information.\n"
"It turns out that white wins 23 (and draws 1) of the 40 games played between "
"4-ply searching strategies.\n"
"Usually, Othello is a fairly balanced game, because black has the advantage "
"of moving first but white usually gets to play last.\n"
"It is clear that these strategies do not play well in the opening game, but "
"for the last four ply they play perfectly.\n"
"This may explain white's slight edge, or it may be a statistical aberration."
msgstr ""
"В выводе не разбиваются выигрыши по черным или белым, а также не указываются "
"значения набранных очков.\n"
"Я чувствовал, что это слишком загромождает вывод, но вы можете добавить эту "
"информацию.\n"
"Оказывается, белые выигрывают в 23 (и разыгрывают 1) из 40 партий, сыгранных "
"между 4-х слойными стратегиями поиска.\n"
"Обычно `Отелло` - довольно сбалансированная игра, потому что у черных есть "
"преимущество в том, что они ходят первыми, а белые обычно играют "
"последними.\n"
"Понятно, что эти стратегии плохо работают в дебютном матче, но последние "
"четыре слоя они играют отлично.\n"
"Это может объяснить небольшое преимущество белых или статистическую "
"аберрацию."

#: in/chapter18.md:1330
msgid "## 18.9 More Efficient Searching"
msgstr "## 18.9 Более эффективный поиск"

#: in/chapter18.md:1335
msgid ""
"The alpha-beta cutoffs work when we have established a good move and another "
"move proves to be not as good.\n"
"Thus, we will be able to make cutoffs earlier if we ensure that good moves "
"are considered first.\n"
"Our current algorithm loops through the list of `legal-moves`, but `legal-"
"moves` makes no attempt to order the moves in any way.\n"
"We will call this the *random-ordering* strategy (even though the ordering "
"is not random at all-square 11 is always considered first, then 12, etc.)."
msgstr ""
"Альфа-бета(alpha-beta) отсечки работают, когда мы сделали хороший ход, а "
"другой ход оказывается не таким хорошим.\n"
"Таким образом, мы сможем сделать отсечки раньше, если сначала рассмотрим "
"хорошие ходы.\n"
"Наш текущий алгоритм перебирает список `legal-moves`(разрешенных ходов), но "
"`legal-moves` не пытается каким-либо образом упорядочивать ходы.\n"
"Мы будем называть это стратегией  *random-ordering*(случайного упорядочения) "
"(даже если порядок не является случайным в целом, всегда сначала "
"рассматривается 11, затем 12 и т. Д.)."

#: in/chapter18.md:1338
msgid ""
"One way to try to generate good moves first is to search highly weighted "
"squares first.\n"
"Since `legal-moves` considers squares in the order defined by `all-squares`, "
"all we have to do is redefine the list `all-squares`[3](#fn0025):"
msgstr ""
"Один из способов сначала попытаться сделать хорошие ходы - это сначала "
"поискать в поле(клетку) с большим весом.\n"
"Так как `legal-moves` рассматривает квадраты в порядке, определенном `all-"
"squares`, все, что нам нужно сделать, это переопределить список `all-"
"squares` [3](#fn0025):"

#: in/chapter18.md:1345
msgid ""
"```lisp\n"
"(defconstant all-squares\n"
"    (sort (loop for i from 11 to 88\n"
"                  when (<= 1 (mod i 10) 8) collect i)\n"
"            #'> :key #'(lambda (sq) (elt *weights* sq))))\n"
"```"
msgstr ""

#: in/chapter18.md:1348
msgid ""
"Now the corner squares will automatically be considered first, followed by "
"the other highly weighted squares.\n"
"We call this the s*tatic-ordering* strategy, because the ordering is not "
"random, but it does not change depending on the situation."
msgstr ""
"Теперь угловые клетки автоматически будут рассматриваться первыми, а за ними "
"- другие клетки с большим весом.\n"
"Мы называем это стратегией *static-ordering*, потому что порядок не является "
"случайным, но он не меняется в зависимости от ситуации."

#: in/chapter18.md:1355
msgid ""
"A more informed way to try to generate good moves first is to sort the moves "
"according to the evaluation function.\n"
"This means making more evaluations.\n"
"Previously, only the boards at the leaves of the search tree were "
"evaluated.\n"
"Now we need to evaluate every board.\n"
"In order to avoid evaluating a board more than once, we make up a structure "
"called a `node`, which holds a board, the square that was taken to result in "
"that board, and the evaluation value of that board.\n"
"The search is the same except that nodes are passed around instead of "
"boards, and the nodes are sorted by their value."
msgstr ""
"Более осознанный способ попытаться вначале создать хорошие ходы - это "
"отсортировать ходы в соответствии с функцией оценки.\n"
"Это означает, что нужно делать больше оценок.\n"
"Ранее оценивались только доски на листьях дерева поиска.\n"
"Теперь нам нужно оценить каждую доску.\n"
"Чтобы избежать оценки доски более одного раза, мы составляем структуру, "
"называемую `node`(узлом), которая содержит доску, клетку, которая была взята "
"для получения этой доски, и оценочное значение этой доски.\n"
"Поиск такой же, за исключением того, что узлы передаются вместо досок, и "
"узлы сортируются по их значению."

#: in/chapter18.md:1358
msgid ""
"```lisp\n"
"(defstruct (node) square board value)"
msgstr ""

#: in/chapter18.md:1369
msgid ""
"(defun alpha-beta-searcher2 (depth eval-fn)\n"
"  \"Return a strategy that does A-B search with sorted moves.\"\n"
"  #'(lambda (player board)\n"
"      (multiple-value-bind (value node)\n"
"          (alpha-beta2\n"
"            player (make-node :board board\n"
"                              :value (funcall eval-fn player board))\n"
"            losing-value winning-value depth eval-fn)\n"
"        (declare (ignore value))\n"
"        (node-square node))))"
msgstr ""

#: in/chapter18.md:1397
msgid ""
"(defun alpha-beta2 (player node achievable cutoff ply eval-fn)\n"
"  \"A-B search, sorting moves by eval-fn\"\n"
"  ;; Returns two values: achievable-value and move-to-make\n"
"  (if (= ply 0)\n"
"      (values (node-value node) node)\n"
"      (let* ((board (node-board node))\n"
"             (nodes (legal-nodes player board eval-fn)))\n"
"        (if (null nodes)\n"
"            (if (any-legal-move? (opponent player) board)\n"
"                (values (- (alpha-beta2 (opponent player)\n"
"                                        (negate-value node)\n"
"                                        (- cutoff) (- achievable)\n"
"                                        (- ply 1) eval-fn))\n"
"                        nil)\n"
"                (values (final-value player board) nil))\n"
"            (let ((best-node (first nodes)))\n"
"              (loop for move in nodes\n"
"                    for val = (- (alpha-beta2\n"
"                                   (opponent player)\n"
"                                   (negate-value move)\n"
"                                   (- cutoff) (- achievable)\n"
"                                   (- ply 1) eval-fn))\n"
"                    do (when (> val achievable)\n"
"                         (setf achievable val)\n"
"                         (setf best-node move))\n"
"                    until (>= achievable cutoff))\n"
"              (values achievable best-node))))))"
msgstr ""

#: in/chapter18.md:1402
msgid ""
"(defun negate-value (node)\n"
"  \"Set the value of a node to its negative.\"\n"
"  (setf (node-value node) (- (node-value node)))\n"
"  node)"
msgstr ""

#: in/chapter18.md:1417
msgid ""
"(defun legal-nodes (player board eval-fn)\n"
"  \"Return a list of legal moves, each one packed into a node.\"\n"
"  (let ((moves (legal-moves player board)))\n"
"    (sort (map-into\n"
"            moves\n"
"            #'(lambda (move)\n"
"                (let ((new-board (make-move move player\n"
"                                            (copy-board board))))\n"
"                  (make-node\n"
"                    :square move :board new-board\n"
"                    :value (funcall eval-fn player new-board))))\n"
"            moves)\n"
"          #'> :key #'node-value)))\n"
"```"
msgstr ""

#: in/chapter18.md:1420
msgid ""
"(Note the use of the function `map-into`.\n"
"This is part of ANSI Common Lisp, but if it is not a part of your "
"implementation, a definition is provided on [page 857](B9780080571157500248."
"xhtml#p857).)"
msgstr ""
"(Обратите внимание на использование функции `map-into`.\n"
"Это часть ANSI Common Lisp, но если она не является частью вашей реализации, "
"определение приведено на [страница 857] (B9780080571157500248.xhtml#p857).)"

#: in/chapter18.md:1424
msgid ""
"The following table compares the performance of the random-ordering "
"strategy, the sorted-ordering strategy and the static-ordering strategy in "
"the course of a single game.\n"
"All strategies search 6 ply deep.\n"
"The table measures the number of boards investigated, the number of those "
"boards that were evaluated (in all cases the evaluation function was "
"`modified-weighted-squares`) and the time in seconds to compute a move."
msgstr ""
"В следующей таблице сравнивается производительность стратегии случайного "
"порядка, стратегии сортировки и стратегии статического порядка в ходе одной "
"игры.\n"
"Все стратегии ищут 6 слоев в глубину.\n"
"В таблице измеряется количество исследованных досок, количество тех досок, "
"которые были оценены (во всех случаях функция оценки была `modified-weighted-"
"squares`(модифицированных взвешенных клеток)) и время в секундах для "
"вычисления хода."

#: in/chapter18.md:1445
msgid ""
"| random | order |      | sorted | order |      | static | order |      |\n"
"| boards | evals | secs | boards | evals | secs | boards | evals | secs |\n"
"|--------|-------|------|--------|-------|------|--------|-------|------|\n"
"| 13912  | 10269 | 69   | 5556   | 5557  | 22   | 2365   | 1599  | 19   |\n"
"| 9015   | 6751  | 56   | 6571   | 6572  | 25   | 3081   | 2188  | 18   |\n"
"| 9820   | 7191  | 46   | 11556  | 11557 | 45   | 5797   | 3990  | 31   |\n"
"| 4195   | 3213  | 20   | 5302   | 5303  | 17   | 2708   | 2019  | 15   |\n"
"| 10890  | 7336  | 60   | 10709  | 10710 | 38   | 3743   | 2401  | 23   |\n"
"| 13325  | 9679  | 63   | 6431   | 6432  | 24   | 4222   | 2802  | 24   |\n"
"| 13163  | 9968  | 58   | 9014   | 9015  | 32   | 6657   | 4922  | 31   |\n"
"| 16642  | 12588 | 70   | 9742   | 9743  | 33   | 10421  | 7488  | 51   |\n"
"| 18016  | 13366 | 80   | 11002  | 11003 | 37   | 9508   | 7136  | 41   |\n"
"| 23295  | 17908 | 104  | 15290  | 15291 | 48   | 26435  | 20282 | 111  |\n"
"| 34120  | 25895 | 143  | 22994  | 22995 | 75   | 20775  | 16280 | 78   |\n"
"| 56117  | 43230 | 224  | 46883  | 46884 | 150  | 48415  | 36229 | 203  |\n"
"| 53573  | 41266 | 209  | 62252  | 62253 | 191  | 37803  | 28902 | 148  |\n"
"| 43943  | 33184 | 175  | 31039  | 31040 | 97   | 33180  | 24753 | 133  |\n"
"| 51124  | 39806 | 193  | 45709  | 45710 | 135  | 19297  | 15064 | 69   |\n"
"| 24743  | 18777 | 105  | 20003  | 20004 | 65   | 15627  | 11737 | 66   |\n"
"| 1.0    | 1.0   | 1.0  | .81    | 1.07  | .62  | .63    | .63   | .63  |"
msgstr ""

#: in/chapter18.md:1450
msgid ""
"The last two lines of the table give the averages and the averages "
"normalized to the random-ordering strategy's performance.\n"
"The sorted-ordering strategy takes only 62% of the time of the random-"
"ordering strategy, and the static-ordering takes 63%.\n"
"These times are not to be trusted too much, because a large-scale garbage "
"collection was taking place during the latter part of the game, and it may "
"have thrown off the times.\n"
"The board and evaluation count may be better indicators, and they both show "
"the static-ordering strategy doing the best."
msgstr ""
"В последних двух строках таблицы приведены средние и средние значения, "
"нормализованные к производительности стратегии случайного упорядочения.\n"
"Стратегия сортировки занимает только 62% времени стратегии случайного "
"порядка, а статическая сортировка занимает 63%.\n"
"Этим временам не следует слишком доверять, потому что крупномасштабная "
"сборка мусора происходила во второй части игры, и это могло отбросить "
"время.\n"
"Доска и количество оценок могут быть лучшими индикаторами, и они оба "
"показывают, что стратегия статического упорядочивания работает лучше всего."

#: in/chapter18.md:1456
msgid ""
"We have to be careful how we evaluate these results.\n"
"Earlier I said that alpha-beta search makes more cutoffs when it is "
"presented first with better moves.\n"
"The actual truth is that it makes more cutoffs when presented first with "
"moves that *the evaluation function thinks* are better.\n"
"In this case the evaluation function and the static-ordering strategy are in "
"strong agreement on what are the best moves, so it is not surprising that "
"static ordering does so well.\n"
"As we develop evaluation functions that vary from the weighted-squares "
"approach, we will have to run experiments again to see if the static-"
"ordering is still the best."
msgstr ""
"Ранее я сказал, что альфа-бета поиск делает больше отсечок, когда ему "
"вначале предоставляются лучшии ходы.\n"
"На самом деле правда в том, что он делает больше отсечок, когда ему сначала "
"предлагаются ходы, которые, по мнению оценочной функции, лучше.\n"
"В этом случае функция оценки и стратегия статического упорядочивания "
"полностью согласны с тем, какие ходы являются лучшими, поэтому "
"неудивительно, что статическое упорядочение так хорошо работает.\n"
"Поскольку мы разрабатываем функции оценки, которые отличаются от подхода "
"взвешенных клеток, нам придется снова проводить эксперименты, чтобы "
"убедиться, что статическое упорядочение по-прежнему является лучшим."

#: in/chapter18.md:1458
msgid "## 18.10 It Pays to Precycle"
msgstr "## 18.10 Предварительный цикл окупается"

#: in/chapter18.md:1461
msgid ""
"The progressive city of Berkeley, California, has a strong recycling program "
"to reclaim glass, paper, and aluminum that would otherwise be discarded as "
"garbage.\n"
"In 1989, Berkeley instituted a novel program of *precycling:* consumers are "
"encouraged to avoid buying products that come in environmentally wasteful "
"packages."
msgstr ""
"В прогрессивном городе Беркли, штат Калифорния, существует сильная программа "
"переработки стекла, бумаги и алюминия, которые в противном случае были бы "
"выброшены как мусор.\n"
"В 1989 году Беркли ввел новую программу предварительной переработки: "
"потребителей поощряют избегать покупки продуктов, которые поставляются в "
"экологически неэффективной упаковке."

#: in/chapter18.md:1466
msgid ""
"Your Lisp system also has a recycling program: the Lisp garbage collector "
"automatically recycles any unused storage.\n"
"However, there is a cost to this program, and you the consumer can get "
"better performance by precycling your data.\n"
"Don't buy wasteful data structures when simpler ones can be used or reused.\n"
"You, the Lisp programmer, may not be able to save the rain forests or the "
"ozone layer, but you can save valuable processor time."
msgstr ""
"В вашей системе Lisp также есть программа утилизации: сборщик мусора Lisp "
"автоматически перерабатывает любое неиспользуемое хранилище.\n"
"Однако эта программа требует определенных затрат, и вы, как потребитель, "
"можете повысить производительность за счет предварительной обработки своих "
"данных.\n"
"Не покупайте расточительные структуры данных, когда можно использовать более "
"простые или использовать повторно.\n"
"Вы, программист на Лиспе, возможно, не сможете спасти влажные леса или "
"озоновый слой, но вы сможете сэкономить драгоценное время процессора."

#: in/chapter18.md:1474
msgid ""
"We saw before that the search routines look at tens of thousands of boards "
"per move.\n"
"Currently, each board position is created anew by `copy-board` and discarded "
"soon thereaf ter.\n"
"We could avoid generating all this garbage by reusing the same board at each "
"ply.\n"
"We'd still need to keep the board from the previous ply for use when the "
"search backs up.\n"
"Thus, a vector of boards is needed.\n"
"In the following we assume that we will never search deeper than 40 ply.\n"
"This is a safe assumption, as even the fastest Othello programs can only "
"search about 15 ply before running out of time."
msgstr ""
"Ранее мы видели, что процедуры поиска просматривают десятки тысяч досок за "
"ход.\n"
"В настоящее время каждая позиция на доске создается заново с помощью `copy-"
"board` и вскоре после этого удаляется.\n"
"Мы могли бы избежать образования всего этого мусора, повторно используя одну "
"и ту же доску для каждого слоя.\n"
"Нам все равно нужно сохранить доску из предыдущего слоя, чтобы использовать "
"ее, когда поиск возобновится.\n"
"Таким образом, нужен вектор досок.\n"
"Далее мы предполагаем, что мы никогда не будем искать глубже 40 слоев.\n"
"Это безопасное предположение, так как даже самые быстрые программы Othello "
"могут выполнять поиск только около 15 слоев, прежде чем закончится время."

#: in/chapter18.md:1479
msgid ""
"```lisp\n"
"(defvar *ply-boards*\n"
"  (apply #'vector (loop repeat 40 collect (initial-board))))\n"
"```"
msgstr ""

#: in/chapter18.md:1484
msgid ""
"Now that we have sharply limited the number of boards needed, we may want to "
"reevaluate the implementation of boards.\n"
"Instead of having the board as a vector of pieces (to save space), we may "
"want to implement boards as vectors of bytes or full words.\n"
"In some implementations, accessing elements of such vectors is faster.\n"
"(In other implementations, there is no difference.)"
msgstr ""
"Теперь, когда мы резко ограничили количество необходимых досок, мы можем "
"пересмотреть реализацию досок.\n"
"Вместо того, чтобы иметь доску как вектор фишек(vector of pieces) (для "
"экономии места), мы можем захотеть реализовать доски как векторы байтов или "
"полных слов.\n"
"В некоторых реализациях доступ к элементам таких векторов осуществляется "
"быстрее.\n"
"(В других реализациях разницы нет.)"

#: in/chapter18.md:1489
msgid ""
"An implementation using the vector of boards will be done in the next "
"section.\n"
"Note that there is another alternative: use only one board, and update it by "
"making and retracting moves.\n"
"This is a good alternative in a game like chess, where a move only alters "
"two squares.\n"
"In Othello, many squares can be altered by a move, so copying the whole "
"board over and making the move is not so bad."
msgstr ""
"Реализация с использованием вектора досок будет выполнена в следующем "
"разделе.\n"
"Обратите внимание, что есть еще одна альтернатива: использовать только одну "
"доску и обновлять ее, делая и убирая ходы.\n"
"Это хорошая альтернатива в такой игре, как шахматы, где ход меняет только "
"два поля.\n"
"В Отелло многие клетки можно изменить ходом, поэтому скопировать всю доску и "
"сделать ход не так уж и плохо."

#: in/chapter18.md:1494
msgid ""
"It should be mentioned that it is worth looking into the problem of copying "
"a position from one board to another.\n"
"The function `replace` copies one sequence (or part of it) into another, but "
"it is a generic function that may be slow.\n"
"In particular, if each element of a board is only 2 bits, then it may be "
"much faster to use displaced arrays to copy 32 bits at a time.\n"
"The advisability of this approach depends on the implementation, and so it "
"is not explored further here."
msgstr ""
"Следует отметить, что стоит разобраться с проблемой копирования позиции с "
"одной доски на другую.\n"
"Функция `replace` копирует одну последовательность (или ее часть) в другую, "
"но это обобщенная функция, которая может работать медленно.\n"
"В частности, если каждый элемент платы имеет всего 2 бита, тогда может быть "
"намного быстрее использовать смещенные массивы(displaced arrays) для "
"копирования по 32 бита за раз.\n"
"Целесообразность этого подхода зависит от реализации, поэтому здесь он не "
"рассматривается."

#: in/chapter18.md:1496
msgid "## 18.11 Killer Moves"
msgstr "## 18.11 Убийственные перемещения(ходы)"

#: in/chapter18.md:1502
msgid ""
"In [section 18.9](#s0050), we considered the possibility of searching moves "
"in a different order, in an attempt to search the better moves first, "
"thereby getting more alpha-beta pruning.\n"
"In this section, we consider the *killer heuristic,* which states that a "
"move that has proven to be a good one in one line of play is also likely to "
"be a good one in another line of play.\n"
"To use chess as perhaps a more familiar example, suppose I consider one "
"move, and it leads to the opponent replying by capturing my queen.\n"
"This is a killer move, one that I would like to avoid.\n"
"Therefore, when I consider other possible moves, I want to immediately "
"consider the possibility of the opponent making that queen-capturing move."
msgstr ""
"В [разделе 18.9](#s0050) мы рассмотрели возможность поиска ходов в другом "
"порядке, пытаясь сначала найти лучшие ходы, тем самым получив больше альфа-"
"бета отсечений.\n"
"В этом разделе мы рассматриваем *эвристику убийцы*, которая гласит, что ход, "
"который оказался хорошим в одной линии игры, вероятно, также будет хорошим в "
"другой линии игры.\n"
"Если использовать шахматы как, возможно, более знакомый пример, предположим, "
"что я рассматриваю один ход, и он приводит к тому, что противник отвечает, "
"взяв моего ферзя.\n"
"Это убийственный ход, которого я бы хотел избежать.\n"
"Поэтому, когда я рассматриваю другие возможные ходы, я хочу сразу "
"рассмотреть возможность того, что оппонент сделает этот ход с захватом ферзя."

#: in/chapter18.md:1508
msgid ""
"The function `alpha-beta3` adds the parameter `killer`, which is the best "
"move found so far at the current level.\n"
"After we determine the `legal-moves`, we use `put-first` to put the killer "
"move first, if it is in fact a legal move.\n"
"When it comes time to search the next level, we keep track of the best move "
"in `killer2`.\n"
"This requires keeping track of the value of the best move in `killer2-val`.\n"
"Everything else is unchanged, except that we get a new board by recycling "
"the `*ply-boards*` vector rather than by allocating fresh ones."
msgstr ""
"Функция `alpha-beta3` добавляет параметр `killer`, который является лучшим "
"ходом, найденным до сих пор на текущем уровне.\n"
"После того, как мы определим `legal-moves`(допустимые ходы), мы используем "
"`put-first`, чтобы поставить убойный ход первым, если это действительно "
"допустимый ход.\n"
"Когда приходит время искать следующий уровень, мы отслеживаем лучший ход в "
"`killer2`.\n"
"Это требует отслеживания значения лучшего хода в `killer2-val`.\n"
"Все остальное не изменилось, за исключением того, что мы получаем новую "
"доску, повторно обрабатывая вектор `*ply-boards*`, а не выделяя новые."

#: in/chapter18.md:1543
msgid ""
"```lisp\n"
"(defun alpha-beta3 (player board achievable cutoff ply eval-fn\n"
"                    killer)\n"
"  \"A-B search, putting killer move first.\"\n"
"  (if (= ply 0)\n"
"      (funcall eval-fn player board)\n"
"      (let ((moves (put-first killer (legal-moves player board))))\n"
"        (if (null moves)\n"
"            (if (any-legal-move? (opponent player) board)\n"
"                (- (alpha-beta3 (opponent player) board\n"
"                                (- cutoff) (- achievable)\n"
"                                (- ply 1) eval-fn nil))\n"
"                (final-value player board))\n"
"            (let ((best-move (first moves))\n"
"                  (new-board (aref *ply-boards* ply))\n"
"                  (killer2 nil)\n"
"                  (killer2-val winning-value))\n"
"              (loop for move in moves\n"
"                    do (multiple-value-bind (val reply)\n"
"                           (alpha-beta3\n"
"                             (opponent player)\n"
"                             (make-move move player\n"
"                                        (replace new-board board))\n"
"                             (- cutoff) (- achievable)\n"
"                             (- ply 1) eval-fn killer2)\n"
"                         (setf val (- val))\n"
"                         (when (> val achievable)\n"
"                           (setf achievable val)\n"
"                           (setf best-move move))\n"
"                         (when (and reply (< val killer2-val))\n"
"                           (setf killer2 reply)\n"
"                           (setf killer2-val val)))\n"
"                    until (>= achievable cutoff))\n"
"              (values achievable best-move))))))"
msgstr ""

#: in/chapter18.md:1552
msgid ""
"(defun alpha-beta-searcher3 (depth eval-fn)\n"
"  \"Return a strategy that does A-B search with killer moves.\"\n"
"  #'(lambda (player board)\n"
"      (multiple-value-bind (value move)\n"
"          (alpha-beta3 player board losing-value winning-value\n"
"                       depth eval-fn nil)\n"
"        (declare (ignore value))\n"
"        move)))"
msgstr ""

#: in/chapter18.md:1560
msgid ""
"(defun put-first (killer moves)\n"
"  \"Move the killer move to the front of moves,\n"
"  if the killer move is in fact a legal move.\"\n"
"  (if (member killer moves)\n"
"      (cons killer (delete killer moves))\n"
"      moves))\n"
"```"
msgstr ""

#: in/chapter18.md:1569
msgid ""
"Another experiment on a single game reveals that adding the killer heuristic "
"to staticordering search (again at 6-ply) cuts the number of boards and "
"evaluations, and the total time, all by about 20%.\n"
"To summarize, alpha-beta search at 6 ply with random ordering takes 105 "
"seconds per move (in our experiment), adding static-ordering cuts it to 66 "
"seconds, and adding killer moves to that cuts it again to 52 seconds.\n"
"This doesn't include the savings that alpha-beta cutoffs give over full "
"minimax search.\n"
"At 6 ply with a branching factor of 7, full minimax would take about nine "
"times longer than static ordering with killers.\n"
"The savings increase with increased depth.\n"
"At 7 ply and a branching factor of 10, a small experiment shows that static-"
"ordering with killers looks at only 28,000 boards in about 150 seconds.\n"
"Full minimax would evaluate 10 million boards and take 350 times longer.\n"
"The times for full minimax are estimates based on the number of boards per "
"second, not on an actual experiment."
msgstr ""
"Другой эксперимент с одной игрой показывает, что добавление убойной "
"эвристики к поиску статического упорядочивания (снова с 6 слоями) сокращает "
"количество досок и оценок, а также общее время примерно на 20%.\n"
"Подводя итог, альфа-бета-поиск на 6 слоях со случайным порядком занимает 105 "
"секунд на ход (в нашем эксперименте), добавление статического упорядочения "
"сокращает его до 66 секунд, а добавление убойных ходов к этому снова "
"сокращает его до 52 секунд.\n"
"Это не включает экономию, которую дает отсечение альфа-бета по сравнению с "
"полным минимаксным поиском.\n"
"При 6 слоях с коэффициентом разветвления 7 полный минимакс займет примерно в "
"девять раз больше времени, чем статическое упорядочивание с убойными "
"ходами.\n"
"Экономия увеличивается с увеличением глубины.\n"
"При 7-и слоях и коэффициенте ветвления 10 небольшой эксперимент показывает, "
"что статическое упорядочение с помощью убийственных эвристик просматривает "
"только 28 000 досок примерно за 150 секунд.\n"
"Полный минимакс оценил бы 10 миллионов досок и занял бы в 350 раз больше "
"времени.\n"
"Время для полного минимакса-это оценки, основанные на количестве досок в "
"секунду, а не на реальном эксперименте."

#: in/chapter18.md:1574
msgid ""
"The algorithm in this section just keeps track of one killer move.\n"
"It is of course possible to keep track of more than one.\n"
"The Othello program Bill ([Lee and Mahajan 1990b](B9780080571157500285."
"xhtml#bb0715)) merges the idea of killer moves with legal move generation: "
"it keeps a list of possible moves at each level, sorted by their value.\n"
"The legal move generator then goes down this list in sorted order."
msgstr ""
"Алгоритм в этом разделе просто отслеживает один убийственный ход.\n"
"Конечно, можно отслеживать более одного.\n"
"Программа Отелло Билл ([Lee and Mahajan 1990b](B9780080571157500285."
"xhtml#bb0715)) объединяет идею убийственных ходов с генерацией легальных "
"ходов: она ведет список возможных ходов на каждом уровне, отсортированным по "
"их ценности.\n"
"Генератор разрешенных ходов затем просматривает этот список в "
"отсортированном порядке."

#: in/chapter18.md:1577
msgid ""
"It should be stressed once again that all this work on alpha-beta cutoffs, "
"ordering, and killer moves has not made any change at all in the moves that "
"are selected.\n"
"We still end up choosing the same move that would be made by a full minimax "
"search to the given depth, we are just doing it faster, without looking at "
"possibilities that we can prove are not as good."
msgstr ""
"Следует еще раз подчеркнуть, что вся эта работа над отсечками альфа-бета, "
"упорядочиванием и убийственными ходами не внесла никаких изменений в "
"выбранные ходы.\n"
"Мы по-прежнему выбираем тот же ход, который был бы сделан при полном "
"минимаксном поиске на заданную глубину, мы просто делаем это быстрее, не "
"глядя на возможности, которые мы можем доказать, не так хороши."

#: in/chapter18.md:1579
msgid "## 18.12 Championship Programs: Iago and Bill"
msgstr "## 18.12 Программы чемпионата: Яго и Билл"

#: in/chapter18.md:1583
msgid ""
"As mentioned in the introduction, the unpredictability of Othello makes it a "
"difficult game for humans to master, and thus programs that search deeply "
"can do comparatively well.\n"
"In fact, in 1981 the reigning champion, Jonathan Cerf, proclaimed \"In my "
"opinion the top programs ... are now equal (if not superior) to the best "
"human players.\" In discussing Rosenbloom's Iago program (1982), Cerf went "
"on to say \"I understand Paul Rosenbloom is interested in arranging a match "
"against me.\n"
"Unfortunately my schedule is very full, and I'm going to see that it remains "
"that way for the foreseeable future.\""
msgstr ""
"Как упоминалось во введении, непредсказуемость Отелло затрудняет освоение "
"людьми игры, и поэтому программы, которые ищут глубоко, могут работать "
"сравнительно хорошо.\n"
"Фактически, в 1981 году действующий чемпион Джонатан Серф заявил: \"По моему "
"мнению, лучшие программы ... теперь равны (если не превосходят) лучших "
"игроков-людей\". Обсуждая программу Яго Розенблума (1982), Серф сказал: \"Я "
"понимаю, что Пол Розенблум заинтересован в организации матча против меня.\n"
"К сожалению, у меня очень плотный график, и я собираюсь сделать так, чтобы "
"он оставался таким в обозримом будущем\"."

#: in/chapter18.md:1587
msgid ""
"In 1989, another program, Bill ([Lee and Mahajan 1990](B9780080571157500285."
"xhtml#bb0715)) beat the highest rated American Othello player, Brian Rose, "
"by a score of 56-8.\n"
"Bill's evaluation function is fast enough to search 6-8 ply under tournament "
"conditions, yet it is so accurate that it beats its creator, Kai-Fu Lee, "
"searching only 1 ply.\n"
"(However, Lee is only a novice Othello player; his real interest is in "
"speech recognition; see [Waibel and Lee 1991](B9780080571157500285."
"xhtml#bb1285).) There are other programs that also play at a high level, but "
"they have not been written up in the AI literature as Iago and Bill have."
msgstr ""
"В 1989 году другая программа, Билл ([Ли и Махаджан, 1990] "
"(B9780080571157500285.xhtml#bb0715)) победила самого лучшего американского "
"игрока \"Отелло\" Брайана Роуза со счетом 56-8.\n"
"Функция оценки Билла достаточно быстра для поиска 6-8 слоев в условиях "
"турнира, но при этом настолько точна, что превосходит своего создателя, Кай-"
"Фу Ли, при поиске только 1 слоя.\n"
"(Однако Ли - только начинающий игрок в Отелло; его настоящий интерес "
"вызывает распознавание речи; см. [Waibel and Lee 1991](B9780080571157500285."
"xhtml#bb1285).) Есть и другие программы, которые также играют на высоком "
"уровне, но они не были описаны в литературе по искусственному интеллекту, "
"как Яго и Билл."

#: in/chapter18.md:1590
msgid ""
"In this section we present an evaluation function based on Iago's, although "
"it also contains elements of Bill, and of an evaluation function written by "
"Eric Wefald in 1989.\n"
"The evaluation function makes use of two main features: *mobilityand edge "
"stability*."
msgstr ""
"В этом разделе мы представляем функцию оценки, основанную на функции Яго, "
"хотя она также содержит элементы Билла, и функции оценки, написанной Эриком "
"Вефальдом в 1989 году.\n"
"Функция оценки использует две основные особенности: *подвижность и "
"стабильность края*."

#: in/chapter18.md:1592
msgid "### Mobility"
msgstr "### Подвижность"

#: in/chapter18.md:1600
msgid ""
"Both Iago and Bill make heavy use of the concept of *mobility*.\n"
"Mobility is a measure of the ability to make moves; basically, the more "
"moves one can make, the better.\n"
"This is not quite true, because there is no advantage in being able to make "
"bad moves, but it is a useful heuristic.\n"
"We define *current mobility* as the number of legal moves available to a "
"player, and *potential mobility* as the number of blank squares that are "
"adjacent to opponent's pieces.\n"
"These include the legal moves.\n"
"A better measure of mobility would try to count only good moves.\n"
"The following function computes both current and potential mobility for a "
"player:"
msgstr ""
"И Яго, и Билл активно используют понятие *mobility*(подвижность).\n"
"Подвижность - это мера способности совершать движения; в основном, чем "
"больше ходов можно сделать, тем лучше.\n"
"Это не совсем так, потому что возможность делать плохие ходы не дает никаких "
"преимуществ, но это полезная эвристика.\n"
"Мы определяем *текущую подвижность* как количество допустимых ходов, "
"доступных игроку, и *потенциальную подвижность* как количество пустых "
"клеток, прилегающих к фигурам противника.\n"
"К ним относятся легальные ходы.\n"
"Лучшим средством измерения подвижности было бы подсчитывать только удачные "
"ходы.\n"
"Следующая функция вычисляет текущую и потенциальную подвижность игрока:"

#: in/chapter18.md:1619
msgid ""
"```lisp\n"
"(defun mobility (player board)\n"
"  \"Current Mobility is the number of legal moves.\n"
"  Potential mobility is the number of blank squares\n"
"  adjacent to an opponent that are not legal moves.\n"
"  Returns current and potential mobility for player.\"\n"
"  (let ((opp (opponent player))\n"
"        (current 0)    ; player's current mobility\n"
"        (potential 0)) ; player's potential mobility\n"
"    (dolist (square all-squares)\n"
"      (when (eql (bref board square) empty)\n"
"        (cond ((legal-p square player board)\n"
"               (incf current))\n"
"              ((some #'(lambda (sq) (eql (bref board sq) opp))\n"
"                     (neighbors square))\n"
"               (incf potential)))))\n"
"    (values current (+ current potential))))\n"
"```"
msgstr ""

#: in/chapter18.md:1621
msgid "### Edge Stability"
msgstr "### Стабильность края"

#: in/chapter18.md:1626
msgid ""
"Success at Othello often hinges around edge play, and both Iago and Bill "
"evaluate the edges carefully.\n"
"Edge analysis is made easier by the fact that the edges are fairly "
"independent of the interior of the board: once a piece is placed on the "
"edge, no interior moves can flip it.\n"
"This independence allows a simplifying assumption: to evaluate a position's "
"edge strength, evaluate each of the four edges independently, without "
"consideration of the interior of the board.\n"
"The evaluation can be made more accurate by considering the X-squares to be "
"part of the edge."
msgstr ""
"Успех в Отелло часто зависит от игры по краям, и Яго и Билл тщательно "
"оценивают края.\n"
"Анализ краев упрощается благодаря тому факту, что края практически не "
"зависят от внутренней части доски: как только фишка помещается на край, "
"никакие внутренние движения не могут её перевернуть.\n"
"Эта независимость позволяет сделать упрощающее предположение: оценить силу "
"края позиции, оценить каждое из четырех краев независимо, без учета "
"внутренней части доски.\n"
"Оценка может быть сделана более точной, если рассматривать X-клетки как "
"часть края."

#: in/chapter18.md:1630
msgid ""
"Even evaluating a single edge is a time-consuming task, so Bill and Iago "
"compile away the evaluation by building a table of all possible edge "
"positions.\n"
"An \"edge\" according to Bill is ten squares: the eight actual edge squares "
"and the two X-squares.\n"
"Since each square can be black, white, or empty, there are 310 or 59,049 "
"possible edge positions-a large but manageable number."
msgstr ""
"Даже оценка одного края - это трудоемкая задача, поэтому Билл и Яго "
"компилируют оценку, составляя таблицу всех возможных положений краев.\n"
"\"edge\"(край/ребро) согласно Биллу - это десять клеток: восемь фактических "
"клеток с краями и две X-клетки.\n"
"Поскольку каждая клетка может быть черной, белой или пустой, существует 310 "
"или 59,049 возможных положений краев - большое, но управляемое число."

#: in/chapter18.md:1635
msgid ""
"The value of each edge position is determined by a process of successive "
"approximation.\n"
"Just as in a minimax search, we will need a static edge evaluation function "
"to determine the value of a edge position without search.\n"
"This static edge evaluation function is applied to every possible edge "
"position, and the results are stored in a 59,049 element vector.\n"
"The static evaluation is just a weighted sum of the occupied squares, with "
"different weights given depending on if the piece is stable or unstable."
msgstr ""
"Значение каждой позиции края определяется путем последовательного "
"приближения.\n"
"Как и в случае минимаксного поиска, нам понадобится статическая функция "
"оценки края, чтобы определить значение позиции края без поиска.\n"
"Эта статическая функция оценки края применяется ко всем возможным позициям "
"края, а результаты сохраняются в векторе 59,049 элементов.\n"
"Статическая оценка - это просто взвешенная сумма занятых клеток с разными "
"весами, дающимися в зависимости от того, является ли фишка стабильной или "
"нестабильной."

#: in/chapter18.md:1645
msgid ""
"Each edge position's evaluation can be improved by a process of search.\n"
"Iago uses a single ply search: given a position, consider all moves that "
"could be made (including no move at all).\n"
"Some moves will be clearly legal, because they flip pieces on the edge, but "
"other moves will only be legal if there are pieces in the interior of the "
"board to flip.\n"
"Since we are only considering the edge, we don't know for sure if these "
"moves are legal.\n"
"They will be assigned probabilities of legality.\n"
"The updated evaluation of a position is determined by the values and "
"probabilities of each move.\n"
"This is done by sorting the moves by value and then summing the product of "
"the value times the probability that the move can be made.\n"
"This process of iterative approximation is repeated five times for each "
"position.\n"
"At that point, Rosenbloom reports, the values have nearly converged."
msgstr ""
"Оценка позиции каждого края может быть улучшена процессом поиска.\n"
"Яго использует однослойный поиск: учитывая позицию, учитывает все ходы, "
"которые могут быть сделаны (включая отсутствие хода вообще).\n"
"Некоторые ходы будут явно разрешены, потому что они переворачивают фигуры на "
"краю, но другие ходы будут разрешены только в том случае, если внутри доски "
"есть фигуры, которые нужно перевернуть.\n"
"Поскольку мы рассматриваем только преимущество, мы не знаем наверняка, "
"законны ли эти ходы.\n"
"Им будет присвоена вероятность законности.\n"
"Обновленная оценка позиции определяется значениями и вероятностями каждого "
"хода.\n"
"Это делается путем сортировки ходов по значению и последующего суммирования "
"произведения значения, умноженного на вероятность того, что ход может быть "
"сделан.\n"
"Этот процесс итеративного приближения повторяется пять раз для каждой "
"позиции.\n"
"К этому моменту, как сообщает Rosenbloom, значения почти сходятся."

#: in/chapter18.md:1648
msgid ""
"In effect, this extends the depth of the normal alpha-beta search by "
"including an edge-only search in the evaluation function.\n"
"Since each edge position with *n* pieces is evaluated as a function of the "
"positions with *n* + 1 pieces, the search is complete-it is an implicit 10-"
"ply search."
msgstr ""
"Фактически, это расширяет глубину обычного альфа-бета-поиска, включая поиск "
"только по краю в функцию оценки.\n"
"Поскольку каждая позиция края с *n* фишками оценивается как функция от "
"позиций с *n* + 1 фишкой, поиск завершен - это неявный 10-слойный поиск."

#: in/chapter18.md:1652
msgid ""
"Calculating edge stability is a bit more complicated than the other "
"features.\n"
"The first step is to define a variable, `*edge-table*`, which will hold the "
"evaluation of each edge position, and a constant, `edge-and-x-lists`, which "
"is a list of the squares on each of the four edges.\n"
"Each edge has ten squares because the X-squares are included."
msgstr ""
"Расчет стабильности края немного сложнее, чем другие функции.\n"
"Первым шагом является определение переменной `*edge-table*`, которая будет "
"содержать оценку каждой позиции края, и константы `edge-and-x-lists`, "
"которая представляет собой список клатов на каждом из четырех краев.\n"
"Каждый край состоит из десяти клеток, потому что X-клетки включены."

#: in/chapter18.md:1656
msgid ""
"```lisp\n"
"(defvar *edge-table* (make-array (expt 3 10))\n"
"  \"Array of values to player-to-move for edge positions.\")"
msgstr ""

#: in/chapter18.md:1664
msgid ""
"(defconstant edge-and-x-lists\n"
"  '((22 11 12 13 14 15 16 17 18 27)\n"
"    (72 81 82 83 84 85 86 87 88 77)\n"
"    (22 11 21 31 41 51 61 71 81 72)\n"
"    (27 18 28 38 48 58 68 78 88 77))\n"
"  \"The four edges (with their X-squares).\")\n"
"```"
msgstr ""

#: in/chapter18.md:1667
msgid ""
"Now for each edge we can compute an index into the edge table by building a "
"10-digit base-3 number, where each digit is 1 if the corresponding edge "
"square is occupied by the player, 2 if by the opponent, and 0 if empty.\n"
"The function `edge-index` computes this, and `edge-stability` sums the "
"values of the four edge indexes."
msgstr ""
"Теперь для каждого края мы можем вычислить индекс в таблице краев, построив "
"10-значное число с основанием 3, где каждая цифра равна 1, если "
"соответствующая клетка края занята игроком, 2, если противником, и 0, если "
"она пуста. .\n"
"Функция `edge-index` вычисляет это, а `edge-stability` суммирует значения "
"четырех индексов края."

#: in/chapter18.md:1679
msgid ""
"```lisp\n"
"(defun edge-index (player board squares)\n"
"  \"The index counts 1 for player; 2 for opponent,\n"
"  on each square---summed as a base 3 number.\"\n"
"  (let ((index 0))\n"
"    (dolist (sq squares)\n"
"      (setq index (+ (* index 3)\n"
"                     (cond ((eql (bref board sq) empty) 0)\n"
"                           ((eql (bref board sq) player) 1)\n"
"                           (t 2)))))\n"
"    index))"
msgstr ""

#: in/chapter18.md:1686
msgid ""
"(defun edge-stability (player board)\n"
"  \"Total edge evaluation for player to move on board.\"\n"
"  (loop for edge-list in edge-and-x-lists\n"
"        sum (aref *edge-table*\n"
"                  (edge-index player board edge-list))))\n"
"```"
msgstr ""

#: in/chapter18.md:1692
msgid ""
"The function `edge-stability` is all we will need in Iago's evaluation "
"function, but we still need to generate the edge table.\n"
"Since this needs to be done only once, we don't have to worry about "
"efficiency.\n"
"In particular, rather than invent a new data structure to represent edges, "
"we will continue to use complete boards, even though they will be mostly "
"empty.\n"
"The computations for the edge table will be made on the top edge, from the "
"point of view of black, with black to play.\n"
"But the same table can be used for white, or for one of the other edges, "
"because of the way the edge index is computed."
msgstr ""
"Функция `edge-stability` - это все, что нам понадобится в функции оценки "
"Яго, но нам все еще нужно сгенерировать таблицу границ(краев).\n"
"Поскольку это нужно сделать только один раз, нам не нужно беспокоиться об "
"эффективности.\n"
"В частности, вместо того, чтобы изобретать новую структуру данных для "
"представления краев, мы продолжим использовать полные доски, даже если они "
"будут в основном пустыми.\n"
"Вычисления для краевой таблицы будут производиться по верхнему краю, с точки "
"зрения черного, с черным для игры.\n"
"Но та же таблица может использоваться для белого цвета или для одного из "
"других краев из-за способа вычисления индекса края."

#: in/chapter18.md:1695
msgid ""
"Each position in the table is first initialized to a static value computed "
"by a kind of weighted-squares metric, but with different weights depending "
"on if a piece is in danger of being captured.\n"
"After that, each position is updated by considering the possible moves that "
"can be made from the position, and the values of each of these moves."
msgstr ""
"Каждая позиция в таблице сначала инициализируется статическим значением, "
"вычисленным с помощью метрики взвешенных клеток, но с разными весами в "
"зависимости от того, находится ли фигура в опасности быть захваченной.\n"
"После этого каждая позиция обновляется с учетом возможных ходов, которые "
"могут быть сделаны из этой позиции, и значений каждого из этих ходов."

#: in/chapter18.md:1698
msgid ""
"```lisp\n"
"(defconstant top-edge (first edge-and-x-lists))"
msgstr ""

#: in/chapter18.md:1719
msgid ""
"(defun init-edge-table ()\n"
"  \"Initialize *edge-table*, starting from the empty board.\"\n"
"  ;; Initialize the static values\n"
"  (loop for n-pieces from 0 to 10 do\n"
"        (map-edge-n-pieces\n"
"          #'(lambda (board index)\n"
"              (setf (aref *edge-table* index)\n"
"                    (static-edge-stability black board)))\n"
"          black (initial-board) n-pieces top-edge 0))\n"
"  ;; Now iterate five times trying to improve:\n"
"  (dotimes (i 5)\n"
"    ;; Do the indexes with most pieces first\n"
"    (loop for n-pieces from 9 downto 1 do\n"
"          (map-edge-n-pieces\n"
"            #'(lambda (board index)\n"
"                (setf (aref *edge-table* index)\n"
"                      (possible-edge-moves-value\n"
"                        black board index)))\n"
"            black (initial-board) n-pieces top-edge 0))))\n"
"```"
msgstr ""

#: in/chapter18.md:1727
msgid ""
"The function `map-edge-n-pieces` iterates through all edge positions with a "
"total of `n` pieces (of either color), applying a function to each such "
"position.\n"
"It also keeps a running count of the edge index as it goes.\n"
"The function should accept two arguments: the board and the index.\n"
"Note that a single board can be used for all the positions because squares "
"are reset after they are used.\n"
"The function has three cases: if the number of squares remaining is less "
"than `n`, then it will be impossible to place `n` pieces on those squares, "
"so we give up.\n"
"If there are no more squares then `n` must also be zero, so this is a valid "
"position, and the function `fn` is called.\n"
"Otherwise we first try leaving the current square blank, then try filling it "
"with player's piece, and then with the opponent's piece, in each case "
"calling `map-edge-n-pieces` recursively."
msgstr ""
"Функция `map-edge-n-sizes` перебирает все позиции краев с общим количеством "
"`n` фишек (любого цвета), применяя функцию к каждой такой позиции.\n"
"Она также ведет текущий счет индекса края по мере его продвижения.\n"
"Функция должна принимать два аргумента: доска и индекс.\n"
"Обратите внимание, что одну доску можно использовать для всех позиций, "
"потому что клетки сбрасываются после их использования.\n"
"Функция имеет три случая: если количество оставшихся клеток меньше, чем `n`, "
"тогда будет невозможно разместить `n` фишек на этих клетках, поэтому мы "
"сдаемся.\n"
"Если клеток больше нет, то `n` также должно быть равно нулю, так что это "
"допустимая позиция, и вызывается функция `fn`.\n"
"В противном случае мы сначала пытаемся оставить текущую клетку пустой, затем "
"пытаемся заполнить её фигурой игрока, а затем фигурой противника, в каждом "
"случае рекурсивно вызывая `map-edge-n-pieces`."

#: in/chapter18.md:1747
msgid ""
"```lisp\n"
"(defun map-edge-n-pieces (fn player board n squares index)\n"
"  \"Call fn on all edges with n pieces.\"\n"
"  ;; Index counts 1 for player; 2 for opponent\n"
"  (cond\n"
"    ((< (length squares) n) nil)\n"
"    ((null squares) (funcall fn board index))\n"
"    (t (let ((index3 (* 3 index))\n"
"             (sq (first squares)))\n"
"         (map-edge-n-pieces fn player board n (rest squares) index3)\n"
"         (when (and (> n 0) (eql (bref board sq) empty))\n"
"           (setf (bref board sq) player)\n"
"           (map-edge-n-pieces fn player board (- n 1) (rest squares)\n"
"                              (+ 1 index3))\n"
"           (setf (bref board sq) (opponent player))\n"
"           (map-edge-n-pieces fn player board (- n 1) (rest squares)\n"
"                              (+ 2 index3))\n"
"           (setf (bref board sq) empty))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1751
msgid ""
"The function `possible-edge-moves-value` searches through all possible moves "
"to determine an edge value that is more accurate than a static evaluation.\n"
"It loops through every empty square on the edge, calling `possible-edge-"
"move` to return a (*probability value*) pair.\n"
"Since it is also possible for a player not to make any move at all on an "
"edge, the pair (`1.0`*current-value*) is also included."
msgstr ""
"Функция `possible-edge-moves-value` просматривает все возможные ходы, чтобы "
"определить значение края, которое является более точным, чем статическая "
"оценка.\n"
"Она перебирает каждую пустую клетку на краю, вызывая `possible-edge-move`, "
"чтобы вернуть пару (*probability value*).\n"
"Так как игрок также может вообще не двигаться по краю, пара (`1.0`*current-"
"value*) также включается."

#: in/chapter18.md:1764
msgid ""
"```lisp\n"
"(defun possible-edge-moves-value (player board index)\n"
"  \"Consider all possible edge moves.\n"
"  Combine their values into a single number.\"\n"
"  (combine-edge-moves\n"
"    (cons\n"
"      (list 1.0 (aref *edge-table* index)) ;; no move\n"
"      (loop for sq in top-edge             ;; possible moves\n"
"            when (eql (bref board sq) empty)\n"
"            collect (possible-edge-move player board sq)))\n"
"    player))\n"
"```"
msgstr ""

#: in/chapter18.md:1766
msgid ""
"The value of each position is determined by making the move on the board, "
"then looking up in the table the value of the resulting position for the "
"opponent, and negating it (since we are interested in the value to us, not "
"to our opponent)."
msgstr ""
"Ценность каждой позиции определяется путем выполнения хода на доске, затем "
"поиска в таблице значения полученной позиции для оппонента и ее отрицания "
"(поскольку нас интересует ценность для нас, а не для нашего оппонента) ."

#: in/chapter18.md:1777
msgid ""
"```lisp\n"
"(defun possible-edge-move (player board sq)\n"
"  \"Return a (prob val) pair for a possible edge move.\"\n"
"  (let ((new-board (replace (aref *ply-boards* player) board)))\n"
"    (make-move sq player new-board)\n"
"    (list (edge-move-probability player board sq)\n"
"          (- (aref *edge-table*\n"
"                   (edge-index (opponent player)\n"
"                               new-board top-edge))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1782
msgid ""
"The possible moves are combined with `combine-edge-moves`, which sorts the "
"moves best-first.\n"
"(Since `init-edge-table` started from black's perspective, black tries to "
"maximize and white tries to minimize scores.) We then go down the moves, "
"increasing the total value by the value of each move times the probability "
"of the move, and decreasing the remaining probability by the probability of "
"the move.\n"
"Since there will always be a least one move (pass) with probability 1.0, "
"this is guaranteed to converge.\n"
"In the end we round off the total value, so that we can do the run-time "
"calculations with fixnums."
msgstr ""
"Возможные ходы комбинируются с `combine-edge-moves`, которые сортируют ходы "
"по принципу \"лучший в первую очередь\".\n"
"(Поскольку `init-edge-table` начался с точки зрения черных, черные стараются "
"максимизировать, а белые стараются минимизировать очки.) Затем мы спускаемся "
"по ходам, увеличивая общее значение на значение каждого хода, умноженное на "
"вероятность хода, и уменьшение оставшейся вероятности на вероятность хода.\n"
"Поскольку всегда будет хотя бы один ход (pass) с вероятностью 1.0, это "
"гарантированно сходится.\n"
"В конце мы округляем итоговое значение, чтобы мы могли выполнять вычисления "
"во время выполнения с фиксированными числами."

#: in/chapter18.md:1795
msgid ""
"```lisp\n"
"(defun combine-edge-moves (possibilities player)\n"
"  \"Combine the best moves.\"\n"
"  (let ((prob 1.0)\n"
"        (val 0.0)\n"
"        (fn (if (eql player black) #'> #'<)))\n"
"    (loop for pair in (sort possibilities fn :key #'second)\n"
"          while (>= prob 0.0)\n"
"          do (incf val (* prob (first pair) (second pair)))\n"
"             (decf prob (* prob (first pair))))\n"
"    (round val)))\n"
"```"
msgstr ""

#: in/chapter18.md:1799
msgid ""
"We still need to compute the probability that each possible edge move is "
"legal.\n"
"These probabilities should reflect things such as the fact that it is easy "
"to capture a corner if the opponent is in the adjacent X-square, and very "
"difficult otherwise.\n"
"First we define some functions to recognize corner and X-squares and relate "
"them to their neighbors:"
msgstr ""
"Нам все еще нужно вычислить вероятность того, что каждое возможное "
"перемещение ребра допустимо.\n"
"Эти вероятности должны отражать такие вещи, как тот факт, что легко "
"захватить край, если противник находится в соседней X-клетке, и очень сложно "
"в противном случае.\n"
"Сначала мы определяем некоторые функции для распознавания углов и X-клеток и "
"связываем их с их соседями:"

#: in/chapter18.md:1807
msgid ""
"```lisp\n"
"(let ((corner/xsqs '((11 . 22) (18 . 27) (81. 72) (88 . 77))))\n"
"  (defun corner-p (sq) (assoc sq corner/xsqs))\n"
"  (defun x-square-p (sq) (rassoc sq corner/xsqs))\n"
"  (defun x-square-for (corner) (cdr (assoc corner corner/xsqs)))\n"
"  (defun corner-for (xsq) (car (rassoc xsq corner/xsqs))))\n"
"```"
msgstr ""

#: in/chapter18.md:1815
msgid ""
"Now we consider the probabilities.\n"
"There are four cases.\n"
"First, since we don't know anything about the interior of the board, we "
"assume each player has a 50% chance of being able to play in an X-square.\n"
"Second, if we can show that a move is legal (because it flips opponent "
"pieces on the edge) then it has 100% probability.\n"
"Third, for the corner squares, we assign a 90% chance if the opponent "
"occupies the X-square, 10% if it is empty, and only .1 % if we occupy it.\n"
"Otherwise, the probability is determined by the two neighboring squares: if "
"a square is next to one or more opponents it is more likely we can move "
"there; if it is next to our pieces it is less likely.\n"
"If it is legal for the opponent to move into the square, then the chances "
"are cut in half (although we may still be able to move there, since we move "
"first)."
msgstr ""
"Теперь рассмотрим вероятности.\n"
"Всего четыре случая.\n"
"Во-первых, поскольку мы ничего не знаем о внутренней части доски, мы "
"предполагаем, что у каждого игрока есть 50% -процентный шанс играть в X-"
"клетке.\n"
"Во-вторых, если мы сможем показать, что ход допустим (потому что он "
"переворачивает фигуры противника), то он имеет 100% вероятность.\n"
"В-третьих, для угловых клеток мы присваиваем шанс 90%, если противник "
"занимает X-клетку, 10%, если она пуста, и только 0,1%, если мы её занимаем.\n"
"В противном случае вероятность определяется двумя соседними клетками: если "
"клетка находится рядом с одним или несколькими противниками, более вероятно, "
"что мы сможем туда переместиться; если она рядом с нашими фишками, то "
"маловероятно.\n"
"Если оппоненту разрешено выходить на поле, шансы уменьшаются вдвое (хотя мы "
"все еще можем двигаться туда, поскольку мы ходим первыми)."

#: in/chapter18.md:1835
msgid ""
"```lisp\n"
"(defun edge-move-probability (player board square)\n"
"  \"What's the probability that player can move to this square?\"\n"
"  (cond\n"
"    ((x-square-p square) .5) ;; X-squares\n"
"    ((legal-p square player board) 1.0) ;; immediate capture\n"
"    ((corner-p square) ;; move to corner depends on X-square\n"
"     (let ((x-sq (x-square-for square)))\n"
"       (cond\n"
"         ((eql (bref board x-sq) empty) .1)\n"
"         ((eql (bref board x-sq) player) 0.001)\n"
"         (t .9))))\n"
"    (t (/ (aref\n"
"            '#2A((.1  .4 .7)\n"
"                 (.05 .3  *)\n"
"                 (.01  *  *))\n"
"            (count-edge-neighbors player board square)\n"
"            (count-edge-neighbors (opponent player) board square))\n"
"          (if (legal-p square (opponent player) board) 2 1)))))"
msgstr ""

#: in/chapter18.md:1842
msgid ""
"(defun count-edge-neighbors (player board square)\n"
"  \"Count the neighbors of this square occupied by player.\"\n"
"  (count-if #'(lambda (inc)\n"
"                (eql (bref board (+ square inc)) player))\n"
"            '(+1 -1)))\n"
"```"
msgstr ""

#: in/chapter18.md:1848
msgid ""
"Now we return to the problem of determining the static value of an edge "
"position.\n"
"This is computed by a weighted-squares metric, but the weights depend on the "
"*stability* of each piece.\n"
"A piece is called stable if it cannot be captured, unstable if it is in "
"immediate danger of being captured, and semistable otherwise.\n"
"A table of weights follows for each edge square and stability.\n"
"Note that corner squares are always stable, and X-squares we will call "
"semistable if the adjacent corner is taken, and unstable otherwise."
msgstr ""
"Теперь вернемся к задаче определения статического значения положения края.\n"
"Оно вычисляется метрикой взвешенных клеток, но веса зависят от "
"*стабильности* каждой фишки.\n"
"Фигура называется стабильной, если она не может быть взята, нестабильной, "
"если она находится в непосредственной опасности захвата, и полустабильной в "
"противном случае.\n"
"Для каждого края и устойчивости следует таблица веса.\n"
"Обратите внимание, что угловые клетки всегда стабильны, и X-клетки мы будем "
"называть полустабильными, если соседний угол взят, и нестабильными в "
"противном случае."

#: in/chapter18.md:1864
msgid ""
"```lisp\n"
"(defparameter *static-edge-table*\n"
"  '#2A(;stab  semi    un\n"
"       (   *    0 -2000) ; X\n"
"       ( 700    *     *) ; corner\n"
"       (1200  200   -25) ; C\n"
"       (1000  200    75) ; A\n"
"       (1000  200    50) ; B\n"
"       (1000  200    50) ; B\n"
"       (1000  200    75) ; A\n"
"       (1200  200   -25) ; C\n"
"       ( 700    *     *) ; corner\n"
"       (   *    0 -2000) ; X\n"
"       ))\n"
"```"
msgstr ""

#: in/chapter18.md:1866
msgid ""
"The static evaluation then just sums each piece's value according to this "
"table:"
msgstr ""
"Затем статическая оценка просто суммирует стоимость каждой фишки в "
"соответствии с этой таблицей:"

#: in/chapter18.md:1880
msgid ""
"```lisp\n"
"(defun static-edge-stability (player board)\n"
"  \"Compute this edge's static stability\"\n"
"  (loop for sq in top-edge\n"
"        for i from 0\n"
"        sum (cond\n"
"              ((eql (bref board sq) empty) 0)\n"
"              ((eql (bref board sq) player)\n"
"               (aref *static-edge-table* i\n"
"                     (piece-stability board sq)))\n"
"              (t (- (aref *static-edge-table* i\n"
"                          (piece-stability board sq)))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1886
msgid ""
"The computation of stability is fairly complex.\n"
"It centers around finding the two \"pieces,\" `p1` and `p2`, which lay on "
"either side of the piece in question and which are not of the same color as "
"the piece.\n"
"These \"pieces\" may be empty, or they may be off the board.\n"
"A piece is unstable if one of the two is empty and the other is the "
"opponent; it is semistable if there are opponents on both sides and at least "
"one empty square to play on, or if it is surrounded by empty pieces.\n"
"Finally, if either `p1` or `p2` is nil then the piece is stable, since it "
"must be connected by a solid wall of pieces to the corner."
msgstr ""
"Расчет устойчивости довольно сложен.\n"
"Он сосредотачивается вокруг поиска двух \"pieces/фишек\" `p1` и `p2`, "
"которые лежат по обе стороны от рассматриваемой фишки и не того же цвета, "
"что и эта фишка.\n"
"Эти \"pieces\"(фишки) могут быть пустыми или отсутствовать на доске.\n"
"Фишка нестабильна, если одна из двух пуста, а другая - соперник; она "
"полустабильна, если есть противники с обеих сторон и есть хотя бы одно "
"пустое поле для игры, или если оно окружено пустыми фигурами.\n"
"Наконец, если либо `p1`, либо `p2` равно нулю, то фигура устойчива, "
"поскольку она должна быть соединена сплошной стенкой из фишек с углом."

#: in/chapter18.md:1889
msgid ""
"```lisp\n"
"(let ((stable 0) (semi-stable 1) (unstable 2))"
msgstr ""

#: in/chapter18.md:1918
msgid ""
"  (defun piece-stability (board sq)\n"
"    (cond\n"
"      ((corner-p sq) stable)\n"
"      ((x-square-p sq)\n"
"       (if (eql (bref board (corner-for sq)) empty)\n"
"           unstable semi-stable))\n"
"      (t (let* ((player (bref board sq))\n"
"                (opp (opponent player))\n"
"                (p1 (find player board :test-not #'eql\n"
"                          :start sq :end 19))\n"
"                (p2 (find player board :test-not #'eql\n"
"                          :start 11 :end sq\n"
"                          :from-end t)))\n"
"           (cond\n"
"             ;; unstable pieces can be captured immediately\n"
"             ;; by playing in the empty square\n"
"             ((or (and (eql p1 empty) (eql p2 opp))\n"
"                  (and (eql p2 empty) (eql p1 opp)))\n"
"              unstable)\n"
"             ;; Semi-stable pieces might be captured\n"
"             ((and (eql p1 opp) (eql p2 opp)\n"
"                   (find empty board :start 11 :end 19))\n"
"              semi-stable)\n"
"             ((and (eql p1 empty) (eql p2 empty))\n"
"              semi-stable)\n"
"             ;; Stable pieces can never be captured\n"
"             (t stable)))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1923
msgid ""
"The edge table can now be built by a call to `init-edge-lable`.\n"
"After the table is built once, it is a good idea to save it so that we won't "
"need to repeat the initialization.\n"
"We could write simple routines to dump the table into a file and read it "
"back in, but it is faster and easier to use existing tools that already do "
"this job quite well: `compile-file` and `load`.\n"
"All we have to do is create and compile a file containing the single line:"
msgstr ""
"Краевая таблица теперь может быть создана с помощью вызова `init-edge-"
"lable`.\n"
"После того, как таблица будет построена один раз, рекомендуется сохранить "
"ее, чтобы нам не пришлось повторять инициализацию.\n"
"Мы могли бы написать простые процедуры для сброса таблицы в файл и чтения её "
"обратно, но быстрее и проще использовать существующие инструменты, которые "
"уже достаточно хорошо справляются с этой задачей: `compile-file` и `load`.\n"
"Все, что нам нужно сделать, это создать и скомпилировать файл, содержащий "
"единственную строку:"

#: in/chapter18.md:1927
msgid ""
"```lisp\n"
"(setf *edge-table* '#.*edge-table*)\n"
"```"
msgstr ""

#: in/chapter18.md:1931
msgid ""
"The `#.` read macro evaluates the following expression at read time.\n"
"Thus, the compiler will see and compile the current edge table.\n"
"It will be able to store this more compactly and `load` it back in more "
"quickly than if we printed the contents of the vector in decimal (or any "
"other base)."
msgstr ""
"Макрос чтения `#.` вычисляет следующее выражение во время чтения.\n"
"Таким образом, компилятор увидит и скомпилирует текущую краевую таблицу.\n"
"Он сможет сохранить это более компактно и `load` загружает обратно быстрее, "
"чем если бы мы распечатали содержимое вектора в десятичном формате (или с "
"любой другой базой)."

#: in/chapter18.md:1933
msgid "### Combining the Factors"
msgstr "### Сочетание факторов"

#: in/chapter18.md:1941
msgid ""
"Now we have a measure of the three factors: current mobility, potential "
"mobility, and edge stability.\n"
"All that remains is to find a good way to combine them into a single "
"evaluation metric.\n"
"The combination function used by [Rosenbloom (1982)](B9780080571157500285."
"xhtml#bb1000) is a linear combination of the three factors, but each "
"factor's coefficient is dependent on the move number.\n"
"Rosenbloom's features are normalized to the range [-1000, 1000]; we "
"normalize to the range [-1, 1] by doing a division after multiplying by the "
"coefficient.\n"
"That allows us to use fixnuums for the coefficients.\n"
"Since our three factors are not calculated in quite the same way as "
"Rosenbloom's, it is not surprising that his coefficients are not the best "
"for our program.\n"
"The edge coefficient was doubled and the potential coefficient cut by a "
"factor of five."
msgstr ""
"Теперь у нас есть мера трех факторов: текущая подвижность, потенциальная "
"подвижность и стабильность края.\n"
"Остается только найти хороший способ объединить их в единую метрику оценки.\n"
"Комбинированная функция, используемая [Rosenbloom (1982)]"
"(B9780080571157500285.xhtml#bb1000), представляет собой линейную комбинацию "
"трех факторов, но коэффициент каждого фактора зависит от номера хода.\n"
"Характеристики Розенблума нормализованы к диапазону [-1000, 1000]; мы "
"нормализуем до диапазона [-1, 1], выполняя деление после умножения на "
"коэффициент.\n"
"Это позволяет нам использовать фиксированные числа для коэффициентов.\n"
"Поскольку наши три фактора рассчитываются не так, как у Розенблюма, "
"неудивительно, что его коэффициенты не самые лучшие для нашей программы.\n"
"Краевой коэффициент был удвоен, а потенциальный коэффициент уменьшен в пять "
"раз."

#: in/chapter18.md:1962
msgid ""
"```lisp\n"
"(defun Iago-eval (player board)\n"
"  \"Combine edge-stability, current mobility and\n"
"  potential mobility to arrive at an evaluation.\"\n"
"  ;; The three factors are multiplied by coefficients\n"
"  ;; that vary by move number:\n"
"  (let ((c-edg (+ 312000 (* 6240 *move-number*)))\n"
"        (c-cur (if (< *move-number* 25)\n"
"                   (+ 50000 (* 2000 *move-number*))\n"
"                   (+ 75000 (* 1000 *move-number*))))\n"
"        (c-pot 20000))\n"
"    (multiple-value-bind (p-cur p-pot)\n"
"        (mobility player board)\n"
"      (multiple-value-bind (o-cur o-pot)\n"
"          (mobility (opponent player) board)\n"
"        ;; Combine the three factors into one sum:\n"
"        (+ (round (* c-edg (edge-stability player board)) 32000)\n"
"           (round (* c-cur (- p-cur o-cur)) (+ p-cur o-cur 2))\n"
"           (round (* c-pot  (- p-pot o-pot)) (+ p-pot o-pot 2)))))))\n"
"```"
msgstr ""

#: in/chapter18.md:1970
msgid ""
"Finally, we are ready to code the `Iago` function.\n"
"Given a search depth, `Iago` returns a strategy that will do alpha-beta "
"search to that depth using the `Iago-eval` evaluation function.\n"
"This version of Iago was able to defeat the modified weighted-squares "
"strategy in 8 of 10 games at 3 ply, and 9 of 10 at 4 ply.\n"
"On an Explorer II, 4-ply search takes about 20 seconds per move.\n"
"At 5 ply, many moves take over a minute, so the program runs the risk of "
"forfeiting.\n"
"At 3 ply, the program takes only a few seconds per move, but it still was "
"able to defeat the author in five straight games, by scores of 50-14, 64-0, "
"51-13, 49-15 and 36-28.\n"
"Despite these successes, it is likely that the evaluation function could be "
"improved greatly with a little tuning of the parameters."
msgstr ""
"Наконец, мы готовы кодировать функцию `Iago`.\n"
"При заданной глубине поиска `Iago` возвращает стратегию, которая будет "
"выполнять альфа-бета-поиск на эту глубину с использованием оценочной функции "
"`Iago-eval`.\n"
"Эта версия Яго смогла победить модифицированную стратегию взвешенных клеток "
"в 8 из 10 игр в 3-х слойных и 9 из 10 в 4-х слойных.\n"
"На Explorer II поиск в 4 слоя занимает около 20 секунд на ход.\n"
"В 5-слойном упражнении многие движения занимают больше минуты, поэтому "
"программа рискует проиграть.\n"
"В трех слойной программе на ход требуется всего несколько секунд, но она все "
"же смогла победить автора в пяти партиях подряд со счетом 50-14, 64-0, "
"51-13, 49-15 и 36-28. .\n"
"Несмотря на эти успехи, вполне вероятно, что функция оценки может быть "
"значительно улучшена при небольшой настройке параметров."

#: in/chapter18.md:1976
msgid ""
"```lisp\n"
"(defun Iago (depth)\n"
"  \"Use an approximation of Iago's evaluation function.\"\n"
"  (alpha-beta-searcher3 depth #'iago-eval))\n"
"```"
msgstr ""

#: in/chapter18.md:1978
msgid "## 18.13 Other Techniques"
msgstr "## 18.13 Другие методы"

#: in/chapter18.md:1983
msgid ""
"There are many other variations that can be tried to speed up the search and "
"improve play.\n"
"Unfortunately, choosing among the techniques is a bit of a black art.\n"
"You will have to experiment to find the combination that is best for each "
"domain and each evaluation function.\n"
"Most of the following techniques were incorporated, or at least considered "
"and rejected, in Bill."
msgstr ""
"Есть много других вариантов, которые можно попробовать, чтобы ускорить поиск "
"и улучшить игру.\n"
"К сожалению, выбор техник - это своего рода черное искусство.\n"
"Вам придется поэкспериментировать, чтобы найти комбинацию, которая лучше "
"всего подходит для каждой области и каждой функции оценки.\n"
"Большинство из следующих техник были включены или, по крайней мере, "
"рассмотрены и отклонены в Билле."

#: in/chapter18.md:1985
msgid "### Iterative Deepening"
msgstr "### Итеративное углубление"

#: in/chapter18.md:1990
msgid ""
"We have seen that the average branching factor for Othello is about 10.\n"
"This means that searching to depth *n* + 1 takes roughly 10 times longer "
"than search to depth *n*.\n"
"Thus, we should be willing to go to a lot of overhead before we search one "
"level deeper, to assure two things: that search will be done efficiently, "
"and that we won't forfeit due to running out of time.\n"
"A by-now familiar technique, iterative deepening (see [chapters 6]"
"(B9780080571157500066.xhtml) and [14](B9780080571157500145.xhtml)), serves "
"both these goals."
msgstr ""
"Мы видели, что средний фактор ветвления для Отелло составляет около 10.\n"
"Это означает, что поиск на глубину *n* + 1 занимает примерно в 10 раз больше "
"времени, чем поиск на глубину *n*.\n"
"Таким образом, мы должны быть готовы пойти на большие накладные расходы, "
"прежде чем искать на один уровень глубже, чтобы гарантировать две вещи: что "
"поиск будет выполняться эффективно и что мы не потерпим неудачу из-за "
"нехватки времени.\n"
"Обеим целям служит уже знакомая техника - итеративное углубление (см. [Главы "
"6](B9780080571157500066.xhtml) и [14](B9780080571157500145.xhtml))."

#: in/chapter18.md:2000
msgid ""
"Iterative deepening is used as follows.\n"
"The strategy determines how much of the remaining time to allocate to each "
"move.\n"
"A simple strategy could allocate a constant amount of time for each move, "
"and a more sophisticated strategy could allocate more time for moves at "
"crucial points in the game.\n"
"Once the time allocation is determined for a move, the strategy starts an "
"iterative deepening alpha-beta search.\n"
"There are two complications: First, the search at *n* ply keeps track of the "
"best moves, so that the search at *n* + 1 ply will have better ordering "
"information.\n"
"In many cases it will be faster to do both the *n* and *n* + 1 ply searches "
"with the ordering information than to do only the *n* + 1 ply search without "
"it.\n"
"Second, we can monitor how much time has been taken searching each ply, and "
"cut off the search when searching one more ply would exceed the allocated "
"time limit.\n"
"Thus, iterative-deepening search degrades gracefully as time limits are "
"imposed.\n"
"It will give a reasonable answer even with a short time allotment, and it "
"will rarely exceed the allotted time."
msgstr ""
"Итеративное углубление используется следующим образом.\n"
"Стратегия определяет, сколько из оставшегося времени выделить на каждый "
"ход.\n"
"Простая стратегия могла бы выделить постоянное количество времени для "
"каждого хода, а более сложная стратегия могла бы выделить больше времени на "
"ходы в критические моменты игры.\n"
"После определения распределения времени для хода стратегия начинает "
"итеративный поиск с углублением альфа-бета.\n"
"Есть две сложности: во-первых, поиск по *n* слоям отслеживает лучшие ходы, "
"так что поиск по *n* + 1 слою будет иметь лучшую информацию для "
"упорядочивания.\n"
"Во многих случаях будет быстрее выполнить поиск по *n* и *n* + 1 слою с "
"информацией об упорядочивании, чем выполнять только поиск по *n* + 1 слою "
"без него.\n"
"Во-вторых, мы можем отслеживать, сколько времени было потрачено на поиск "
"каждого слоя, и отключать поиск, если поиск еще одного слоя превысит "
"выделенный лимит времени.\n"
"Таким образом, поиск с итеративным углублением постепенно ухудшается по мере "
"наложения ограничений по времени.\n"
"Он даст разумный ответ даже при небольшом отведенном времени, и он редко "
"будет превышать отведенное время."

#: in/chapter18.md:2002
msgid "### Forward Pruning"
msgstr "### Прямая обрезка"

#: in/chapter18.md:2008
msgid ""
"One way to cut the number of positions searched is to replace the legal move "
"generator with a *plausible* move generator: in other words, only consider "
"good moves, and never even look at moves that seem clearly bad.\n"
"This technique is called *forward pruning*.\n"
"It has fallen on disfavor because of the difficulty in determining which "
"moves are plausible.\n"
"For most games, the factors that would go into a plausible move generator "
"would be duplicated in the static evaluation function anyway, so forward "
"pruning would require more effort without much gain.\n"
"Worse, forward pruning could rule out a brilliant sacrifice-a move that "
"looks bad initially but eventually leads to a gain."
msgstr ""
"Один из способов сократить количество искомых позиций - заменить генератор "
"допустимых ходов генератором *правдоподобных/plausible* ходов: другими "
"словами, рассматривайте только хорошие ходы и никогда даже не смотрите на "
"ходы, которые кажутся явно плохими.\n"
"Этот метод называется *forward pruning*(прямой обрезкой).\n"
"Он попал в немилость из-за трудности определения того, какие ходы "
"правдоподобны.\n"
"Для большинства игр факторы, которые будут входить в генератор вероятных "
"ходов, в любом случае будут дублироваться в функции статической оценки, "
"поэтому прямое отсечение потребует больше усилий без особого выигрыша.\n"
"Что еще хуже, отсечение вперед может исключить блестящую жертву - ход, "
"который сначала выглядит плохо, но в конечном итоге приводит к выигрышу."

#: in/chapter18.md:2013
msgid ""
"For some games, forward pruning is a necessity.\n"
"The game of Go, for example, is played on a 19 by 19 board, so the first "
"player has 361 legal moves, and a 6-ply search would involve over 2 "
"quadrillion positions.\n"
"However, many good Go programs can be viewed as not doing forward pruning "
"but doing abstraction.\n"
"There might be 30 empty squares in one portion of the board, and the program "
"would treat a move to any of these squares equivalently."
msgstr ""
"Для некоторых игр прямая обрезка является необходимостью.\n"
"Например, в игру Go играют на доске 19 на 19, поэтому у первого игрока есть "
"361 разрешенный ход, а поиск в 6 слоев потребует более 2 квадриллионов "
"позиций.\n"
"Однако многие хорошие программы Go можно рассматривать как не выполняющие "
"прямую отсечку, а как абстракцию.\n"
"В одной части доски может быть 30 пустых клеток, и программа будет "
"рассматривать ход на любую из этих клеток эквивалентно."

#: in/chapter18.md:2017
msgid ""
"Bill uses forward pruning in a limited way to rule out certain moves "
"adjacent to the corners.\n"
"It does this not to save time but because the evaluation function might lead "
"to such a move being selected, even though it is in fact a poor move.\n"
"In other words, forward pruning is used to correct a bug in the evaluation "
"function cheaply."
msgstr ""
"Билл ограниченно использует прямую обрезку, чтобы исключить определенные "
"движения, прилегающие к углам.\n"
"Это делается не для экономии времени, а потому, что функция оценки может "
"привести к выбору такого хода, даже если на самом деле это плохой ход.\n"
"Другими словами, прямое отсечение используется для дешевого исправления "
"ошибки в функции оценки."

#: in/chapter18.md:2019
msgid "### Nonspeculative Forward Pruning"
msgstr "### Неспекулятивное прямое отсечение"

#: in/chapter18.md:2027
msgid ""
"This technique makes use of the observation that there are limits in the "
"amount the evaluation function can change from one position to the next.\n"
"For example, if we are using the count difference as the evaluation "
"function, then the most a move can change the evaluation is +37 (one for "
"placing a piece in the corner, and six captures in each of the three "
"directions).\n"
"The smallest change is 0 (if the player is forced to pass).\n"
"Thus, if there are 2 ply left in the search, and the backed-up value of "
"position *A* has been established as 38 points better than the static value "
"of position *B*, then it is useless to expand position *B*.\n"
"This assumes that we are evaluating every position, perhaps to do sorted "
"ordering or iterative deepening.\n"
"It also assumes that no position in the search tree is a final position, "
"because then the evaluation could change by more than 37 points.\n"
"In conclusion, it seems that nonspeculative forward pruning is not very "
"useful for Othello, although it may play a role in other games."
msgstr ""
"В этом методе используется наблюдение, что существуют ограничения на "
"количество изменений функции оценки от одного положения к другому.\n"
"Например, если мы используем разницу в счетах в качестве функции оценки, то "
"больше всего ход может изменить оценку +37 (один для размещения фигуры в "
"углу и шесть захватов в каждом из трех направлений).\n"
"Наименьшее изменение - 0 (если игрок вынужден пасовать).\n"
"Таким образом, если в поиске осталось 2 слоя и резервное значение позиции "
"*A* было установлено на 38 пунктов лучше, чем статическое значение позиции "
"*B*, то расширять позицию *B* бесполезно. .\n"
"Это предполагает, что мы оцениваем каждую позицию, возможно, для сортировки "
"или итеративного углубления.\n"
"Также предполагается, что никакая позиция в дереве поиска не является "
"конечной позицией, потому что тогда оценка может измениться более чем на 37 "
"пунктов.\n"
"В заключение, кажется, что неспекулятивное прямое отсечение не очень полезно "
"для Отелло, хотя оно может сыграть роль в других играх."

#: in/chapter18.md:2029
msgid "### Aspiration Search"
msgstr "### Поиск стремлений"

#: in/chapter18.md:2038
msgid ""
"Alpha-beta search is initated with the `achievable` and `cutoff` boundaries "
"set to `losing-value` and `winning-value`, respectively.\n"
"In other words, the search assumes nothing: the final position may be "
"anything from a loss to a win.\n"
"But suppose we are in a situation somewhere in the mid-game where we are "
"winning by a small margin (say the static evaluation for the current "
"position is 50).\n"
"In most cases, a single move will not change the evaluation by very much.\n"
"Therefore, if we invoked the alpha-beta search with a window defined by "
"boundaries of, say, 0 and 100, two things can happen: if the actual backed-"
"up evaluation for this position is in fact in the range 0 to 100, then the "
"search will find it, and it will be found quickly, because the reduced "
"window will cause more pruning.\n"
"If the actual value is not in the range, then the value returned will "
"reflect that, and we can search again using a larger window.\n"
"This is called aspiration search, because we aspire to find a value within a "
"given window.\n"
"If the window is chosen well, then often we will succeed and will have saved "
"some search time."
msgstr ""
"Альфа-бета-поиск начинается с `achievable`(достижимой) и `cutoff`(отсекаемой/"
"пороговой) границы, установленных на в `losing-value`(проигрышныое значени) "
"и `winning-value`(выигрышное значение), соответственно.\n"
"Другими словами, поиск ничего не предполагает: итоговая позиция может быть "
"любой, от проигрыша до победы.\n"
"Но предположим, что мы находимся в ситуации где-то в середине игры, когда мы "
"выигрываем с небольшим отрывом (скажем, статическая оценка для текущей "
"позиции равна 50).\n"
"В большинстве случаев один ход не сильно меняет оценку.\n"
"Следовательно, если мы вызвали альфа-бета-поиск с окном, определенным "
"границами, скажем, от 0 до 100, могут произойти две вещи: если фактическая "
"резервная оценка для этой позиции фактически находится в диапазоне от 0 до "
"100, тогда поиск найдет его, и он будет найден быстро, потому что "
"уменьшенное окно приведет к большему сокращению.\n"
"Если фактическое значение не входит в диапазон, то возвращаемое значение "
"будет отражать это, и мы можем снова выполнить поиск, используя большее "
"окно.\n"
"Это называется поиском стремления, потому что мы стремимся найти значение в "
"заданном окне.\n"
"Если окно выбрано правильно, то часто мы добиваемся успеха и экономим время "
"поиска."

#: in/chapter18.md:2047
msgid ""
"[Pearl (1984)](B9780080571157500285.xhtml#bb0930) suggests an alternative "
"called zero-window search.\n"
"At each level, the first possible move, which we'll call *m*, is searched "
"using a reasonably wide window to determine its exact value, which we'll "
"call *v*.\n"
"Then the remaining possible moves are searched using *v* as both the lower "
"and upper bounds of the window.\n"
"Thus, the result of the search will tell if each subsequent move is better "
"or worse than *m*, but won't tell how much better or worse.\n"
"There are three outcomes for zero-window search.\n"
"If no move turns out to be better than *m*, then stick with *m*.\n"
"If a single move is better, then use it.\n"
"If several moves are better than *m*, then they have to be searched again "
"using a wider window to determine which is best."
msgstr ""
"[Pearl (1984)](B9780080571157500285.xhtml#bb0930) предлагает альтернативу, "
"называемую поиском в нулевом окне(zero-window).\n"
"На каждом уровне первый возможный ход, который мы назовем *m*, ищется с "
"использованием достаточно широкого окна, чтобы определить его точное "
"значение, которое мы назовем *v*.\n"
"Затем ищутся оставшиеся возможные ходы, используя *v* как нижнюю и верхнюю "
"границы окна.\n"
"Таким образом, результат поиска покажет, лучше или хуже каждый последующий "
"ход, чем *m*, но не скажет, насколько лучше или хуже.\n"
"Есть три результата поиска с нулевым окном.\n"
"Если никакое движение не оказывается лучше, чем *m*, то придерживайтесь "
"*m*.\n"
"Если один ход лучше, используйте его.\n"
"Если несколько ходов лучше, чем *m*, то их нужно снова найти в более широком "
"окне, чтобы определить, какой из них лучше."

#: in/chapter18.md:2051
msgid ""
"There is always a trade-off between time spent searching and information "
"gained.\n"
"Zero-window search makes an attractive trade-off: we gain some search time "
"by losing information about the value of the best move.\n"
"We are still guaranteed of finding the best move, we just don't know its "
"exact value."
msgstr ""
"Всегда существует компромисс между временем, потраченным на поиск, и "
"полученной информацией.\n"
"Поиск с нулевым окном является привлекательным компромиссом: мы выигрываем "
"некоторое время поиска, теряя информацию о ценности лучшего хода.\n"
"Нам по-прежнему гарантировано нахождение лучшего хода, мы просто не знаем "
"его точной стоимости/значения."

#: in/chapter18.md:2055
msgid ""
"Bill's zero-window search takes only 63% of the time taken by full alpha-"
"beta search.\n"
"It is effective because Bill's move-ordering techniques ensure that the "
"first move is often best.\n"
"With random move ordering, zero-window search would not be effective."
msgstr ""
"Поиск Билла с нулевым окном занимает всего 63% времени, затрачиваемого на "
"поиск в режиме полного альфа-бета.\n"
"Это эффективно, потому что методы упорядочивания ходов Билла гарантируют, "
"что первый ход зачастую оказывается лучшим.\n"
"При случайном порядке ходов поиск без окна не будет эффективным."

#: in/chapter18.md:2057
msgid "### Think-Ahead"
msgstr "### Думать о будущем"

#: in/chapter18.md:2063
msgid ""
"A program that makes its move and then waits for the opponent's reply is "
"wasting half the time available to it.\n"
"A better use of time is to compute, or *think-ahead* while the opponent is "
"moving.\n"
"Think-ahead is one factor that helps Bill defeat Iago.\n"
"While many programs have done think-ahead by choosing the most likely move "
"by the opponent and then starting an iterative-deepening search assuming "
"that move, Bill's algorithm is somewhat more complex.\n"
"It can consider more than one move by the opponent, depending on how much "
"time is available."
msgstr ""
"Программа, которая делает свой ход, а затем ждет ответа противника, тратит "
"половину доступного ей времени.\n"
"Лучше использовать время для расчетов или *думать наперед*, пока противник "
"выбирает свой ход.\n"
"Прогнозирование - один из факторов, который помогает Биллу победить Яго.\n"
"Хотя многие программы заранее продумывают ход, выбирая наиболее вероятный "
"ход оппонента, а затем начиная итеративно-углубляющийся поиск, предполагая "
"этот ход. Алгоритм Билла несколько сложнее.\n"
"Он может учитывать более одного хода противника, в зависимости от того, "
"сколько времени доступно."

#: in/chapter18.md:2065
msgid "### Hashing and Opening Book Moves"
msgstr "### Хеширование и  книга ходов в дебюте "

#: in/chapter18.md:2074
msgid ""
"We have been treating the search space as a tree, but in general it is a "
"directed acyclic graph (dag): there may be more than one way to reach a "
"particular position, but there won't be any loops, because every move adds a "
"new piece.\n"
"This raises the question we explored briefly in [section 6.4]"
"(B9780080571157500066.xhtml#s0025): should we treat the search space as a "
"tree or a graph?\n"
"By treating it as a graph we eliminate duplicate evaluations, but we have "
"the overhead of storing all the previous positions, and of checking to see "
"if a new position has been seen before.\n"
"The decision must be based on the proportion of duplicate positions that are "
"actually encountered in play.\n"
"One compromise solution is to store in a hash table a partial encoding of "
"each position, encoded as, say, a single fixnum (one word) instead of the "
"seven or so words needed to represent a full board.\n"
"Along with the encoding of each position, store the move to try first.\n"
"Then, for each new position, look in the hash table, and if there is a hit, "
"try the corresponding move first.\n"
"The move may not even be legal, if there is an accidental hash collision, "
"but there is a good chance that the move will be the right one, and the "
"overhead is low."
msgstr ""
"Мы рассматривали пространство поиска как дерево, но в целом это "
"ориентированный ациклический граф (dag): может быть более одного способа "
"достичь определенной позиции, но не будет никаких циклов, потому что каждый "
"ход добавляет новый кусок.\n"
"Это поднимает вопрос, который мы кратко исследовали в [разделе 6.4]"
"(B9780080571157500066.xhtml#s0025): следует ли рассматривать пространство "
"поиска как дерево или граф?\n"
"Рассматривая его как график, мы устраняем повторяющиеся оценки, но у нас "
"есть накладные расходы на сохранение всех предыдущих позиций и на проверку "
"того, была ли ранее обнаружена новая позиция.\n"
"Решение должно основываться на пропорции повторяющихся позиций, которые "
"фактически встречаются в игре.\n"
"Одно из компромиссных решений - хранить в хеш-таблице частичное кодирование "
"каждой позиции, закодированное, скажем, как одно фиксированное число/fixnum "
"(одно слово) вместо семи или около того слов, необходимых для представления "
"всей доски.\n"
"Вместе с кодировкой каждой позиции сохраните ход, чтобы попробовать первым.\n"
"Затем для каждой новой позиции смотрите в хеш-таблицу, и если есть "
"совпадение, сначала попробуйте соответствующий ход.\n"
"Этот ход может быть даже незаконным, если происходит случайная коллизия "
"хешей, но есть большая вероятность, что ход будет правильным и накладные "
"расходы низкие."

#: in/chapter18.md:2080
msgid ""
"One place where it is clearly worthwhile to store information about previous "
"positions is in the opening game.\n"
"Since there are fewer choices in the opening, it is a good idea to compile "
"an opening \"book\" of moves and to play by it as long as possible, until "
"the opponent makes a move that departs from the book.\n"
"Book moves can be gleaned from the literature, although not very much has "
"been written about Othello (as compared to openings in chess).\n"
"However, there is a danger in following expert advice: the positions that an "
"expert thinks are advantageous may not be the same as the positions from "
"which our program can play well.\n"
"It may be better to compile the book by playing the program against itself "
"and determining which positions work out best."
msgstr ""
"Одно место, где явно стоит хранить информацию о предыдущих позициях, - это "
"начальная игра(дебют).\n"
"Так как в дебюте меньше вариантов, рекомендуется составить дебютную \"книгу"
"\" ходов и играть по ней как можно дольше, пока противник не сделает ход, "
"который отклоняется от книги.\n"
"Книжные ходы можно почерпнуть из литературы, хотя об Отелло написано не так "
"много (по сравнению с дебютами в шахматах).\n"
"Однако есть опасность следовать совету экспертов: позиции, которые эксперт "
"считает выгодными, могут не совпадать с позициями, с которых наша программа "
"может хорошо играть.\n"
"Может быть, лучше составить книгу, играя против самой программы и определяя, "
"какие позиции работают лучше всего."

#: in/chapter18.md:2082
msgid "### The End Game"
msgstr "### Конец игры"

#: in/chapter18.md:2086
msgid ""
"It is also a good idea to try to save up time in the midgame and then make "
"an all-out effort to search the complete game tree to completion as soon as "
"feasible.\n"
"Bill can search to completion from about 14 ply out.\n"
"Once the search is done, of course, the most promising lines of play should "
"be saved so that it won't be necessary to solve the game tree again."
msgstr ""
"Также неплохо попытаться сэкономить время в середине игры, а затем приложить "
"все усилия для поиска по всему дереву игры до завершения, как только это "
"будет возможно.\n"
"Билл может искать до завершения примерно из 14 слоев.\n"
"Разумеется, после завершения поиска наиболее многообещающие линии игры "
"должны быть сохранены, чтобы не приходилось снова решать дерево игры."

#: in/chapter18.md:2088
msgid "### Metareasoning"
msgstr "### Мета-рассуждение"

#: in/chapter18.md:2097
msgid ""
"If it weren't for the clock, Othello would be a trivial game: just search "
"the complete game tree all the way to the end, and then choose the best "
"move.\n"
"The clock imposes a complication: we have to make all our moves before we "
"run out of time.\n"
"The algorithms we have seen so far manage the clock by allocating a certain "
"amount of time to each move, such that the total time is guaranteed (or at "
"least very likely) to be less than the allotted time.\n"
"This is a very crude policy.\n"
"A finer-grained way of managing time is to consider computation itself as a "
"possible move.\n"
"That is, at every tick of the clock, we need to decide if it is better to "
"stop and play the best move we have computed so far or to continue and try "
"to compute a better move.\n"
"It will be better to compute more only in the case where we eventually "
"choose a better move; it will be better to stop and play only in the case "
"where we would otherwise forfeit due to time constraints, or be forced to "
"make poor choices later in the game.\n"
"An algorithm that includes computation as a possible move is called a "
"metareasoning system, because it reasons about how much to reason."
msgstr ""
"Если бы не часы, Отелло была бы тривиальной игрой: просто обыщите все дерево "
"игры до конца, а затем выберите лучший ход.\n"
"С часами возникает сложность: мы должны сделать все, чтобы время не "
"закончилось.\n"
"Алгоритмы, которые мы видели до сих пор, управляют часами, выделяя "
"определенное количество времени на каждый ход, так что общее время "
"гарантированно (или, по крайней мере, очень вероятно) будет меньше "
"отведенного времени.\n"
"Это очень грубая политика.\n"
"Более тонкий способ управления временем состоит в том, чтобы рассматривать "
"сами вычисления как возможный ход.\n"
"То есть, на каждом такте времени нам нужно решить, лучше ли остановиться и "
"сыграть лучший ход, который мы вычислили до сих пор, или продолжить и "
"попытаться вычислить лучший ход.\n"
"Будет лучше вычислять больше только в том случае, если мы в конечном итоге "
"выберем лучший ход; будет лучше остановиться и играть только в том случае, "
"если в противном случае мы проиграем из-за нехватки времени или будем "
"вынуждены сделать неправильный выбор позже в игре.\n"
"Алгоритм, который включает вычисление в качестве возможного хода, называется "
"системой мета-рассуждений, потому что он определяет, насколько нужно "
"рассуждать."

#: in/chapter18.md:2103
msgid ""
"[Russell and Wefald (1989)](B9780080571157500285.xhtml#bb1025) present an "
"approach based on this view.\n"
"In addition to an evaluation function, they assume a variance function, "
"which gives an estimate of how much a given position's true value is likely "
"to vary from its static value.\n"
"At each step, their algorithm compares the value and variance of the best "
"move computed so far and the second best move.\n"
"If the best move is clearly better than the second best (taking variance "
"into account), then there is no point computing any more.\n"
"Also, if the top two moves have similar values but both have very low "
"variance, then computing will not help much; we can just choose one of the "
"two at random."
msgstr ""
"[Russell and Wefald (1989)](B9780080571157500285.xhtml#bb1025) представляют "
"подход, основанный на этой точке зрения.\n"
"В дополнение к функции оценки они предполагают функцию дисперсии(variance), "
"которая дает оценку того, насколько истинное значение данной позиции может "
"отличаться от ее статического значения.\n"
"На каждом этапе их алгоритм сравнивает значение и дисперсию лучшего хода, "
"вычисленного на данный момент, и второго лучшего хода.\n"
"Если лучший ход явно лучше второго (с учетом дисперсии), то вычислять больше "
"нет смысла.\n"
"Кроме того, если два верхних хода имеют одинаковые значения, но оба имеют "
"очень низкую дисперсию, вычисления не сильно помогут; мы можем просто "
"выбрать одно из двух наугад."

#: in/chapter18.md:2108
msgid ""
"For example, if the board is in a symmetric position, then there may be two "
"symmetric moves that will have identical value.\n"
"By searching each move's subtree more carefully, we soon arrive at a low "
"variance for both moves, and then we can choose either one, without "
"searching further.\n"
"Of course, we could also add special-case code to check for symmetry, but "
"the metareasoning approach will work for nonsymmetric cases as well as "
"symmetric ones.\n"
"If there is a situation where two moves both lead to a clear win, it won't "
"waste time choosing between them."
msgstr ""
"Например, если доска находится в симметричном положении, то могут быть два "
"симметричных хода, которые будут иметь одинаковое значение.\n"
"Путем более тщательного поиска в поддереве каждого хода мы скоро приходим к "
"низкой дисперсии для обоих ходов, а затем можем выбрать любой из них без "
"дальнейшего поиска.\n"
"Конечно, мы могли бы также добавить код особого случая для проверки "
"симметрии, но подход мета-рассуждений будет работать как для несимметричных, "
"так и для симметричных случаев.\n"
"Если есть ситуация, когда два хода приводят к чистой победе, не нужно "
"тратить время на выбор между ними."

#: in/chapter18.md:2111
msgid ""
"The only situation where it makes sense to continue computing is when there "
"are two moves with high variance, so that it is uncertain if the true value "
"of one exceeds the other.\n"
"The metareasoning algorithm is predicated on devoting time to just this case."
msgstr ""
"Единственная ситуация, в которой имеет смысл продолжить вычисления, - это "
"когда есть два хода с большой дисперсией, поэтому неясно, превышает ли "
"истинное значение одно другое.\n"
"Алгоритм мета-рассуждений основан на уделении времени именно этому случаю."

#: in/chapter18.md:2113
msgid "### Learning"
msgstr "### Обучение"

#: in/chapter18.md:2118
msgid ""
"From the earliest days of computer game playing, it was realized that a "
"championship program would need to learn to improve itself.\n"
"[Samuel (1959)](B9780080571157500285.xhtml#bb1040) describes a program that "
"plays checkers and learns to improve its evaluation function.\n"
"The evaluation function is a linear combination of features, such as the "
"number of pieces for each player, the number of kings, the number of "
"possible forks, and so on.\n"
"Learning is done by a hill-climbing search procedure: change one of the "
"coefficients for one of the features at random, and then see if the changed "
"evaluation function is better than the original one."
msgstr ""
"С первых дней компьютерных игр было ясно, что программе чемпионата нужно "
"научиться совершенствоваться.\n"
"[Samuel (1959)](B9780080571157500285.xhtml#bb1040) описывает программу, "
"которая играет в шашки и учится улучшать свою функцию оценки.\n"
"Функция оценки представляет собой линейную комбинацию характеристик, таких "
"как количество фишек для каждого игрока, количество королей, количество "
"возможных вилок и так далее.\n"
"Обучение осуществляется с помощью процедуры поиска по восходящей: измените "
"один из коэффициентов для одной из характеристик наугад, а затем посмотрите, "
"лучше ли измененная функция оценки, чем исходная."

#: in/chapter18.md:2122
msgid ""
"Without some guidance, this hill-climbing search would be very slow.\n"
"First, the space is very large-Samuel used 38 different features, and "
"although he restricted the coefficients to be a power of two between 0 and "
"20, that still leaves 2138 possible evaluation functions.\n"
"Second, the obvious way of determining the relative worth of two evaluation "
"functions-playing a series of games between them and seeing which wins more "
"often-is quite time-consuming."
msgstr ""
"Без каких-либо указаний этот поиск по восхождению был бы очень медленным.\n"
"Во-первых, пространство очень велико - Сэмюэл использовал 38 различных "
"функций, и, хотя он ограничил коэффициенты степенью двойки от 0 до 20, по-"
"прежнему остается 2138 возможных функций оценки.\n"
"Во-вторых, очевидный способ определить относительную ценность двух оценочных "
"функций - сыграть между ними в серии игр и посмотреть, какая из них "
"выигрывает чаще, - требует довольно много времени."

#: in/chapter18.md:2128
msgid ""
"Fortunately, there is a faster way of evaluating an evaluation function.\n"
"We can apply the evaluation function to a position and compare this static "
"value with the backed-up value determined by an alpha-beta search.\n"
"If the evaluation function is accurate, the static value should correlate "
"well with the backed-up value.\n"
"If it does not correlate well, the evaluation function should be changed in "
"such a way that it does.\n"
"This approach still requires the trial-and-error of hill-climbing, but it "
"will converge much faster if we can gain information from every position, "
"rather than just from every game."
msgstr ""
"К счастью, есть более быстрый способ оценить функцию оценки.\n"
"Мы можем применить функцию оценки к позиции и сравнить это статическое "
"значение с резервным значением, определенным альфа-бета-поиском.\n"
"Если функция оценки точна, статическое значение должно хорошо коррелировать "
"с резервным значением.\n"
"Если оно не коррелирует хорошо, функцию оценки следует изменить таким "
"образом, чтобы это произошло.\n"
"Этот подход по-прежнему требует проб и ошибок восхождения на холм, но он "
"будет сходиться намного быстрее, если мы сможем получать информацию из "
"каждой позиции, а не только из каждой игры."

#: in/chapter18.md:2140
msgid ""
"In the past few years there has been increased interest in learning by a "
"process of guided search.\n"
"*Neural nets* are one example of this.\n"
"They have been discussed elsewhere.\n"
"Another example is *genetic learning* algorithms.\n"
"These algorithms start with several candidate solutions.\n"
"In our case, each candidate would consist of a set of coefficients for an "
"evaluation function.\n"
"On each generation, the genetic algorithm sees how well each candidate "
"does.\n"
"The worst candidates are eliminated, and the best ones \"mate\" and "
"\"reproduce\"-two candidates are combined in some way to yield a new one.\n"
"If the new offspring has inherited both its parents' good points, then it "
"will prosper; if it has inherited both its parents' bad points, then it will "
"quickly die out.\n"
"Either way, the idea is that natural selection will eventually yield a high-"
"quality solution.\n"
"To increase the chances of this, it is a good idea to allow for mutations: "
"random changes in the genetic makeup of one of the candidates."
msgstr ""
"В последние несколько лет возрос интерес к обучению с помощью управляемого "
"поиска.\n"
"*Нейронные сети* являются одним из примеров этого.\n"
"Они обсуждались в другом месте.\n"
"Другой пример - алгоритмы *генетического обучения*.\n"
"Эти алгоритмы начинаются с нескольких возможных решений.\n"
"В нашем случае каждый кандидат будет состоять из набора коэффициентов для "
"функции оценки.\n"
"В каждом поколении генетический алгоритм видит, насколько хорошо работает "
"каждый кандидат.\n"
"Худшие кандидаты исключаются, а лучшие «спариваются» и «воспроизводятся» - "
"два кандидата каким-то образом объединяются, чтобы получить нового.\n"
"Если новое потомство унаследовало хорошие качества обоих родителей, оно "
"будет процветать; если он унаследовал плохие стороны обоих родителей, то "
"быстро вымрет.\n"
"В любом случае идея состоит в том, что естественный отбор в конечном итоге "
"приведет к качественному решению.\n"
"Чтобы увеличить вероятность этого, рекомендуется учитывать мутации: "
"случайные изменения в генетическом составе одного из кандидатов."

#: in/chapter18.md:2142
msgid "## 18.14 History and References"
msgstr "## 18.14 История и ссылки"

#: in/chapter18.md:2148
msgid ""
"[Lee and Mahajan (1986,](B9780080571157500285.xhtml#bb0710)[1990)]"
"(B9780080571157500285.xhtml#bb0715)present the current top Othello program, "
"Bill.\n"
"Their description outlines all the techniques used but does not go into "
"enough detail to allow the reader to reconstruct the program.\n"
"Bill is based in large part on Rosenbloom's Iago program.\n"
"Rosenbloom's article (1982) is more thorough.\n"
"The presentation in this chapter is based largely on this article, although "
"it also contains some ideas from Bill and from other sources."
msgstr ""

#: in/chapter18.md:2150
msgid ""
"The journal *Othello Quarterly* is the definitive source for reports on both "
"human and computer Othello games and strategies."
msgstr ""

#: in/chapter18.md:2162
msgid ""
"The most popular game for computer implementation is chess.\n"
"[Shannon (1950a,](B9780080571157500285.xhtml#bb1070)[b)]"
"(B9780080571157500285.xhtml#bb1075) speculated that a computer might play "
"chess.\n"
"In a way, this was one of the boldest steps in the history of AI.\n"
"Today, writing a chess program is a challenging but feasible project for an "
"undergraduate.\n"
"But in 1950, even suggesting that such a program might be possible was a "
"revolutionary step that changed the way people viewed these arithmetic "
"calculating devices.\n"
"Shannon introduced the ideas of a game tree search, minimaxing, and "
"evaluation functions-ideas that remain intact to this day.\n"
"[Marsland (1990)](B9780080571157500285.xhtml#bb0770) provides a good short "
"introduction to computer chess, and David Levy has two books on the subject "
"(1976, 1988).\n"
"It was Levy, an international chess master, who in 1968 accepted a bet from "
"John McCarthy, Donald Michie, and others that a computer chess program would "
"not beat him in the next ten years.\n"
"Levy won the bet.\n"
"Levy's *Heuristic Programming* (1990) and *Computer Games* (1988) cover a "
"variety of computer game playing programs.\n"
"The studies by [DeGroot (1965,](B9780080571157500285.xhtml#bb0305)[1966)]"
"(B9780080571157500285.xhtml#bb0310) give a fascinating insight into the "
"psychology of chess masters."
msgstr ""

#: in/chapter18.md:2164
msgid ""
"[Knuth and Moore (1975)](B9780080571157500285.xhtml#bb0630) analyze the "
"alpha-beta algorithm, and Pearl's book *Heuristics* (1984) covers all kinds "
"of heuristic search, games included."
msgstr ""

#: in/chapter18.md:2170
msgid ""
"[Samuel (1959)](B9780080571157500285.xhtml#bb1040) is the classic work on "
"learning evaluation function parameters.\n"
"It is based on the game of checkers.\n"
"[Lee and Mahajan (1990)](B9780080571157500285.xhtml#bb0715) present an "
"alternative learning mechanism, using Bayesian classification to learn an "
"evaluation function that optimally distinguishes winning positions from "
"losing positions.\n"
"Genetic algorithms are discussed by L.\n"
"[Davis (1987,](B9780080571157500285.xhtml#bb0280)[1991)]"
"(B9780080571157500285.xhtml#bb0285) and [Goldberg (1989)]"
"(B9780080571157500285.xhtml#bb0480)."
msgstr ""

#: in/chapter18.md:2172
msgid "## 18.15 Exercises"
msgstr "## 18.15 Упражнения"

#: in/chapter18.md:2175
msgid ""
"**Exercise  18.3 [s]** How many different Othello positions are there?\n"
"Would it be feasible to store the complete game tree and thus have a perfect "
"player?"
msgstr ""

#: in/chapter18.md:2180
msgid ""
"**Exercise  18.4 [m]** At the beginning of this chapter, we implemented "
"pieces as an enumerated type.\n"
"There is no built-in facility in Common Lisp for doing this, so we had to "
"introduce a series of `defconstant` forms.\n"
"Define a macro for defining enumerated types.\n"
"What else should be provided besides the constants?"
msgstr ""

#: in/chapter18.md:2184
msgid ""
"**Exercise  18.5 [h]** Add fixnum and speed declarations to the Iago "
"evaluation function and the alpha-beta code.\n"
"How much does this speed up Iago?\n"
"What other efficiency measures can you take?"
msgstr ""

#: in/chapter18.md:2186
msgid ""
"**Exercise  18.6 [h]** Implement an iterative deepening search that "
"allocates time for each move and checks between each iteration if the time "
"is exceeded."
msgstr ""

#: in/chapter18.md:2188
msgid ""
"**Exercise  18.7 [h]** Implement zero-window search, as described in "
"[section 18.13](#s0085)."
msgstr ""

#: in/chapter18.md:2191
msgid ""
"**Exercise  18.8 [d]** Read the references on Bill ([Lee and Mahajan 1990]"
"(B9780080571157500285.xhtml#bb0715), and [1986](B9780080571157500285."
"xhtml#bb0710) if you can get it), and reimplement Bill's evaluation function "
"as best you can, using the table-based approach.\n"
"It will also be helpful to read [Rosenbloom 1982](B9780080571157500285."
"xhtml#bb1000)."
msgstr ""

#: in/chapter18.md:2193
msgid ""
"**Exercise  18.9 [d]** Improve the evaluation function by tuning the "
"parameters, using one of the techniques described in [section 18.13](#s0085)."
msgstr ""

#: in/chapter18.md:2195
msgid ""
"**Exercise  18.10 [h]** Write move-generation and evaluation functions for "
"another game, such as chess or checkers."
msgstr ""

#: in/chapter18.md:2197
msgid "## 18.16 Answers"
msgstr "## 18.16 Ответы"

#: in/chapter18.md:2200
msgid ""
"**Answer 18.2** The `weighted-squares` strategy wins the first game by 20 "
"pieces, but when `count-difference` plays first, it captures all the pieces "
"on its fifth move.\n"
"These two games alone are not enough to determine the best strategy; the "
"function `othello-series` on [page 626](#p626) shows a better comparison."
msgstr ""

#: in/chapter18.md:2203
msgid ""
"**Answer 18.3** 364  =  3, 433, 683, 820, 292, 512, 484, 657, 849, 089, "
"281.\n"
"No."
msgstr ""

#: in/chapter18.md:2205
msgid ""
"**Answer 18.4** Besides the constants, we provide a `deftype` for the type "
"itself, and conversion routines between integers and symbols:"
msgstr ""

#: in/chapter18.md:2219
msgid ""
"```lisp\n"
"(defmacro define-enumerated-type (type &rest elements)\n"
"    \"Represent an enumerated type with integers 0-n.\"\n"
"    '(progn\n"
"        (deftype ,type () '(integer 0 , (- (length elements) 1)))\n"
"        (defun ,(symbol type '->symbol) (,type)\n"
"            (elt ',elements ,type))\n"
"        (defun ,(symbol 'symbol-> type) (symbol)\n"
"            (position symbol ',elements))\n"
"        ,@(loop for element in elements\n"
"                for i from 0\n"
"                collect '(defconstant ,element ,i))))\n"
"```"
msgstr ""

#: in/chapter18.md:2221
msgid ""
"Here's how the macro would be used to define the piece data type, and the "
"code produced:"
msgstr ""

#: in/chapter18.md:2237
msgid ""
"```lisp\n"
"> (macroexpand\n"
"        '(define-enumerated-type piece\n"
"            empty black white outer))\n"
"(PROGN\n"
"    (DEFTYPE PIECE () '(INTEGER 0 3))\n"
"    (DEFUN PIECE->SYMBOL (PIECE)\n"
"        (ELT '(EMPTY BLACK WHITE OUTER) PIECE))\n"
"    (DEFUN SYMBOL->PIECE (SYMBOL)\n"
"        (POSITION SYMBOL '(EMPTY BLACK WHITE OUTER)))\n"
"    (DEFCONSTANT EMPTY 0)\n"
"    (DEFCONSTANT BLACK 1)\n"
"    (DEFCONSTANT WHITE 2)\n"
"    (DEFCONSTANT OUTER 3))\n"
"```"
msgstr ""

#: in/chapter18.md:2242
msgid ""
"A more general facility would, like `defstruct`, provide for several "
"options.\n"
"For example, it might allow for a documentation string for the type and each "
"constant, and for a : `conc-name`, so the constants could have names like "
"`piece-empty` instead of `empty`.\n"
"This would avoid conflicts with other types that wanted to use the same "
"names.\n"
"The user might also want the ability to start the values at some number "
"other than zero, or to assign specific values to some of the symbols."
msgstr ""

#: in/chapter18.md:2244
msgid "----------------------"
msgstr ""

#: in/chapter18.md:2248
msgid ""
"[1](#xfn0015) Othello is a registered trademark of CBS Inc.\n"
"Gameboard design @ 1974 CBS Inc.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter18.md:2253
msgid ""
"[2](#xfn0020)*Othello,* [I.\n"
"i.\n"
"117] William Shakespeare.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter18.md:2256
msgid ""
"[3](#xfn0025) Remember, when a constant is redefined, it may be necessary to "
"recompile any functions that use the constant.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
