#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter10.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-03-18 13:21+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter10.md:3
msgid ""
"# Chapter 10\n"
"## Low-Level Efficiency Issues"
msgstr ""
"# Глава 10\n"
"## Проблемы эффективности на низком уровне "

#: in/chapter10.md:5
msgid ""
"> There are only two qualities in the world: efficiency and inefficiency; "
"and only two sorts of people: the efficient and the inefficient"
msgstr ""
"> В мире всего два качества: эффективность и неэффективность; и только два "
"типа людей: эффективные и неэффективные"

#: in/chapter10.md:7
msgid "> -George Bernard Shaw"
msgstr ""

#: in/chapter10.md:9
msgid "> John Bull's Other Island (1904)"
msgstr ""

#: in/chapter10.md:16
msgid ""
"The efficiency techniques of the previous chapter all involved fairly "
"significant changes to an algorithm.\n"
"But what happens when you already are using the best imaginable algorithms, "
"and performance is still a problem?\n"
"One answer is to find what parts of the program are used most frequently and "
"make micro-optimizations to those parts.\n"
"This chapter covers the following six optimization techniques.\n"
"If your programs all run quickly enough, then feel free to skip this "
"chapter.\n"
"But if you would like your programs to run faster, the techniques described "
"here can lead to speed-ups of 40 times or more."
msgstr ""
"Все методы повышения эффективности из предыдущей главы включали в себя "
"довольно значительные изменения в алгоритме.\n"
"Но что происходит, когда вы уже используете лучшие алгоритмы, которые только "
"можно представить, а производительность по-прежнему остается проблемой?\n"
"Один из ответов - найти, какие части программы используются наиболее часто, "
"и провести микрооптимизацию этих частей.\n"
"В этой главе рассматриваются следующие шесть методов оптимизации.\n"
"Если все ваши программы работают достаточно быстро, можете пропустить эту "
"главу.\n"
"Но если вы хотите, чтобы ваши программы работали быстрее, описанные здесь "
"методы могут привести к ускорению в 40 или более раз."

#: in/chapter10.md:18
msgid "*   Use declarations."
msgstr "*   Используйте декларации."

#: in/chapter10.md:20
msgid "*   Avoid generic functions."
msgstr "*   Избегайте обобщенных функций."

#: in/chapter10.md:22
msgid "*   Avoid complex argument lists."
msgstr "*   Избегайте сложных списков аргументов."

#: in/chapter10.md:24
msgid "*   Provide compiler macros."
msgstr "*   Предоставить макросы компилятора."

#: in/chapter10.md:26
msgid "*   Avoid unnecessary consing."
msgstr "*   Избегайте ненужного consing-а(создания лишних списков)."

#: in/chapter10.md:28
msgid "*   Use the right data structure."
msgstr "*   Используйте правильные структуры данных."

#: in/chapter10.md:30
msgid "## 10.1 Use Declarations"
msgstr "## 10.1 Используйте декларации(объявления)"

#: in/chapter10.md:34
msgid ""
"On general-purpose computers running Lisp, much time is spent on type-"
"checking.\n"
"You can gain efficiency at the cost of robustness by declaring, or "
"promising, that certain variables will always be of a given type.\n"
"For example, consider the following function to compute the sum of the "
"squares of a sequence of numbers:"
msgstr ""
"На компьютерах общего назначения, на которых работает Lisp, много времени "
"тратится на проверку типов.\n"
"Вы можете повысить эффективность за счет надежности, объявив или пообещав, "
"что определенные переменные всегда будут определенного типа.\n"
"Например, рассмотрим следующую функцию для вычисления суммы квадратов "
"последовательности чисел:"

#: in/chapter10.md:43
msgid ""
"```lisp\n"
"(defun sum-squares (seq)\n"
"  (let ((sum 0))\n"
"    (dotimes (i (length seq))\n"
"      (incf sum (square (elt seq i))))\n"
"    sum))\n"
"(defun square (x) (* x x))\n"
"```"
msgstr ""

#: in/chapter10.md:45
msgid ""
"If this function will only be used to sum vectors of fixnums, we can make it "
"a lot faster by adding declarations:"
msgstr ""
"Если эта функция будет использоваться только для суммирования векторов "
"фиксированных чисел(fixnums), мы можем сделать её намного быстрее, добавив "
"объявления:"

#: in/chapter10.md:57
msgid ""
"```lisp\n"
"(defun sum-squares (vect)\n"
"  (declare (type (simple-array fixnum *) vect)\n"
"        (inline square) (optimize speed (safety 0)))\n"
"  (let ((sum 0))\n"
"    (declare (fixnum sum))\n"
"    (dotimes (i (length vect))\n"
"      (declare (fixnum i))\n"
"      (incf sum (the fixnum (square (svref vect i)))))))\n"
"    sum))\n"
"```"
msgstr ""

#: in/chapter10.md:63
msgid ""
"The fixnum declarations let the compiler use integer arithmetic directly, "
"rather than checking the type of each addend.\n"
"The (`the fixnum`... ) special form is a promise that the argument is a "
"fixnum.\n"
"The (`optimize speed (safety 0))` declaration tells the compiler to make the "
"function run as fast as possible, at the possible expense of making the code "
"less safe (by ignoring type checks and so on).\n"
"Other quantities that can be optimized are `compilation-speed, space` and in "
"ANSI Common Lisp only, `debug` (ease of debugging).\n"
"Quantities can be given a number from 0 to 3 indicating how important they "
"are; 3 is most important and is the default if the number is left out."
msgstr ""
"Объявление fixnum позволит компилятору напрямую использовать целочисленную "
"арифметику, а не проверять тип каждого слагаемого.\n"
"Специальная форма (`the fixnum` ...) - это обещание, что аргумент является "
"фиксированным числом(fixnum).\n"
"Объявление `(optimize speed (security 0))` сообщает компилятору, что функция "
"должна быть как можно быстрее, возможно, за счет снижения безопасности кода "
"(игнорируя типов и т. Д.).\n"
"Другими величинами, которые можно оптимизировать, являются `compilation-"
"speed, space`(скорость компиляции, пространство) и только в ANSI Common Lisp "
"`debug` (простота отладки).\n"
"Величинам может быть присвоено число от 0 до 3, определяющее, насколько они "
"важны; 3 является важным и используется по умолчанию, если номер не указан."

#: in/chapter10.md:67
msgid ""
"The (`inline square`) declaration allows the compiler to generate the "
"multiplication specified by `square` right in the loop, without explicitly "
"making a function call to square.\n"
"The compiler will create a local variable for (`svref vect i`) and will not "
"execute the reference twice-inline functions do not have any of the problems "
"associated with macros as discussed on [page 853](B9780080571157500248."
"xhtml#p853).\n"
"However, there is one drawback: when you redefine an inline function, you "
"may need to recompile all the functions that call it."
msgstr ""
"Объявление (`inline square`) позволяет компилятору сгенерировать умножение, "
"указанное в `square`, прямо в цикле, без явного вызова функции square.\n"
"Компилятор создаст локальную переменную для (`svref vect i`) и не будет "
"выполнять ссылочные дважды встроенные функции, не имея никаких проблем, "
"связанных с макросами, как описано на [страница 853] (B9780080571157500248."
"xhtml#p853).\n"
"Однако есть один недостаток: когда вы переопределяете встраиваемую функцию, "
"вам может потребоваться перекомпилировать все функции, которые ее вызывают."

#: in/chapter10.md:70
msgid ""
"You should declare a function `inline` when it is short and the function-"
"calling overhead will thus be a significant part of the total execution "
"time.\n"
"You should not declare a function `inline` when the function is recursive, "
"when its definition is likely to change, or when the function's definition "
"is long and it is called from many places."
msgstr ""
"Вы можете объявить функцию `inline`, когда она короткая, и поэтому накладные "
"расходы на вызов функции будут составлять значительную часть общего времени "
"выполнения.\n"
"Вы не должны объявлять функцию `inline`, когда функция является рекурсивной, "
"когда ее определение может измениться или когда определение функции длинное "
"и вызывается из многих мест."

#: in/chapter10.md:74
msgid ""
"In the example at hand, declaring the function inline saves the overhead of "
"a function call.\n"
"In some cases, further optimizations are possible.\n"
"Consider the predicate `starts-with`:"
msgstr ""
"В рассматриваемом примере объявление функции встраиваемой, экономит "
"накладные расходы на вызов функции.\n"
"В некоторых случаях возможна дальнейшая оптимизация.\n"
"Рассмотрим предикат `starts-with`:"

#: in/chapter10.md:81
msgid ""
"```lisp\n"
"  (defun starts-with (list x)\n"
"    \"Is x a list whose first element is x?\"\n"
"    (and (consp list) (eql (first list) x)))\n"
"  )\n"
"```"
msgstr ""

#: in/chapter10.md:83
msgid "Suppose we have a code fragment like the following:"
msgstr "Предположим, у нас есть такой фрагмент кода:"

#: in/chapter10.md:87
msgid ""
"```lisp\n"
"(if (consp list) (starts-with list x) ...)\n"
"```"
msgstr ""

#: in/chapter10.md:89
msgid "If `starts-with` is declared `inline` this will expand to:"
msgstr "Если `start-with` объявлен как `inline`, этот код расширится до:"

#: in/chapter10.md:93
msgid ""
"```lisp\n"
"(if (consp list) (and (consp list) (eql (first list) x)) ...)\n"
"```"
msgstr ""

#: in/chapter10.md:95
msgid "which many compilers will simplify to:"
msgstr "что многие компиляторы упростят до:"

#: in/chapter10.md:99
msgid ""
"```lisp\n"
"(if (consp list) (eql (first list) x) ...)\n"
"```"
msgstr ""

#: in/chapter10.md:101
msgid ""
"Very few compilers do this kind of simplification across functions without "
"the hint provided by `inline`."
msgstr ""
"Очень немногие компиляторы делают такое упрощение функций без подсказки, "
"предоставляемой `inline`."

#: in/chapter10.md:107
msgid ""
"Besides eliminating run-time type checks, declarations also allow the "
"compiler to choose the most efficient representation of data objects.\n"
"Many compilers support both *boxed* and *unboxed* representations of data "
"objects.\n"
"A boxed representation includes enough information to determine the type of "
"the object.\n"
"An unboxed representation is just the \"raw bits\" that the computer can "
"deal with directly.\n"
"Consider the following function, which is used to clear a 1024  x  1024 "
"array of floating point numbers, setting each one to zero:"
msgstr ""
"Помимо исключения проверки типов во время выполнения, объявления также "
"позволяют компилятору выбирать наиболее эффективное представление объектов "
"данных.\n"
"Многие компиляторы поддерживают как *упакованные*(boxed), так и "
"*распакованные*(unboxed) представления объектов данных.\n"
"Упакованное представление содержит достаточно информации, чтобы определить "
"тип объекта.\n"
"Распакованное представление - это просто \"сырые биты\", с которыми "
"компьютер может иметь дело напрямую.\n"
"Рассмотрим следующую функцию, которая используется для очистки массива 1024 "
"x 1024 чисел с плавающей запятой, устанавливая для каждого из них ноль:"

#: in/chapter10.md:116
msgid ""
"```lisp\n"
"(defun clear-m-array (array)\n"
"  (declare (optimize (speed 3) (safety 0)))\n"
"  (declare (type (simple-array single-float (1024 1024)) array))\n"
"  (dotimes (i 1024)\n"
"    (dotimes (j 1024)\n"
"      (setf (aref array i j) 0.0))))\n"
"```"
msgstr ""

#: in/chapter10.md:119
msgid ""
"In Allegro Common Lisp on a Sun SPARCstation, this compiles into quite good "
"code, comparable to that produced by the C compiler for an equivalent C "
"program.\n"
"If the declarations are omitted, however, the performance is about 40 times "
"worse."
msgstr ""
"В Allegro Common Lisp на Sun SPARCstation это компилируется в довольно "
"хороший код, сравнимый с кодом, созданным компилятором C для эквивалентной "
"программы C.\n"
"Однако, если объявления не указаны, производительность будет примерно в 40 "
"раз хуже."

#: in/chapter10.md:124
msgid ""
"The problem is that without the declarations, it is not safe to store the "
"raw floating point representation of `0.0` in each location of the array.\n"
"Instead, the program has to box the `0.0`, allocating storage for a typed "
"pointer to the raw bits.\n"
"This is done inside the nested loops, so the result is that each call to the "
"version of `clear-m-array` without declarations calls the floating-point-"
"boxing function 1048567 times, allocating a megaword of storage.\n"
"Needless to say, this is to be avoided."
msgstr ""
"Проблема в том, что без деклараций небезопасно хранить необработанное "
"представление `0.0` с плавающей запятой в каждом месте массива.\n"
"Вместо этого программа должна поместить в упаковку `0.0`, выделяя память для "
"типизированного указателя на необработанные биты.\n"
"Это делается внутри вложенных циклов, поэтому в результате каждый вызов "
"версии `clear-m-array` без объявлений вызывает функцию упаковки floating-"
"point-boxing 1048567 раз, выделяя миллион слов памяти.\n"
"Излишне говорить, что этого следует избегать."

#: in/chapter10.md:129
msgid ""
"Not all compilers heed all declarations; you should check before wasting "
"time with declarations your compiler may ignore.\n"
"The function `disassemble` can be used to show what a function compiles "
"into.\n"
"For example, consider the trivial function to add two numbers together.\n"
"Here it is with and without declarations:"
msgstr ""
"Не все компиляторы принимают во внимание все объявления; вы должны "
"проверить, прежде чем тратить время на объявления, которые ваш компилятор "
"может игнорировать.\n"
"Функцию `disassemble` можно использовать, чтобы показать, во что "
"компилируется функция.\n"
"Например, рассмотрим тривиальную функцию сложения двух чисел.\n"
"Вот с декларациями и без:"

#: in/chapter10.md:136
msgid ""
"```lisp\n"
"(defun f (x y)\n"
"  (declare (fixnum x y) (optimize (safety 0) (speed 3)))\n"
"  (the fixnum (+ x y)))\n"
"(defun g (x y) (+ x y))\n"
"```"
msgstr ""

#: in/chapter10.md:138
msgid ""
"Here is the disassembled code for f from Allegro Common Lisp for a Motorola "
"68000-series processor:"
msgstr ""
"Вот дизассемблированный код f из Allegro Common Lisp для процессора Motorola "
"серии 68000:"

#: in/chapter10.md:145
msgid ""
"```\n"
"> (disassemble 'f)\n"
";; disassembling #<Function f @ #x83ef79  >\n"
";; formals: x y\n"
";; code vector @ #x83ef44\n"
"```"
msgstr ""

#: in/chapter10.md:158
msgid ""
"| []()  |          |                 |\n"
"|-------|----------|-----------------|\n"
"| `0:`  | `link`   | `a6.#0`         |\n"
"| `4:`  | `move.l` | `a2,-(a7)`      |\n"
"| `6:`  | `move.l` | `a5,-(a7)`      |\n"
"| `8:`  | `move.l` | `7(a2),a5`      |\n"
"| `12:` | `move.l` | `8(a6).d4 ; y`  |\n"
"| `16:` | `add.l`  | `12(a6),d4 ; x` |\n"
"| `20:` | `move.l` | `#1,d1`         |\n"
"| `22:` | `move.l` | `-8(a6),a5`     |\n"
"| `26:` | `unlk`   | `a6`            |\n"
"| `28:` | `rtd`    | `#8`            |"
msgstr ""

#: in/chapter10.md:165
msgid ""
"This may look intimidating at first glance, but you don't have to be an "
"expert at 68000 assembler to gain some appreciation of what is going on "
"here.\n"
"The instructions labeled 0-8 (labels are in the leftmost column) comprise "
"the typical function preamble for the 68000.\n"
"They do subroutine linkage and store the new function object and constant "
"vector into registers.\n"
"Since f uses no constants, instructions 6, 8, and 22 are really unnecessary "
"and could be omitted.\n"
"Instructions 0,4, and 26 could also be omitted if you don't care about "
"seeing this function in a stack trace during debugging.\n"
"More recent versions of the compiler will omit these instructions."
msgstr ""
"На первый взгляд это может показаться устрашающим, но вам не нужно быть "
"экспертом в ассемблере 68000, чтобы получить некоторое представление о том, "
"что здесь происходит.\n"
"Инструкции, помеченные 0-8 (метки в крайнем левом столбце), составляют "
"типичную преамбулу функции для 68000.\n"
"Они связывают подпрограммы и сохраняют новый объект функции и вектор "
"констант в регистры.\n"
"Поскольку f не использует констант, инструкции 6, 8 и 22 действительно не "
"нужны и могут быть опущены.\n"
"Инструкции 0,4 и 26 также можно опустить, если вам не нужно видеть эту "
"функцию в трассировке стека во время отладки.\n"
"В более поздних версиях компилятора эти инструкции отсутствуют."

#: in/chapter10.md:169
msgid ""
"The heart of function `f` is the two-instruction sequence 12-16.\n"
"Instruction 12 retrieves `y`, and 16 adds `y` to `x`, leaving the result in "
"`d4`, which is the \"result\" register.\n"
"Instruction 20 sets `dl`, the \"number of values returned\" register, to 1."
msgstr ""
"В основе функции `f` лежит последовательность из двух инструкций 12-16.\n"
"Инструкция 12 извлекает `y`, а 16 добавляет `y` к `x`, оставляя результат в "
"`d4`, который является регистром `результата`.\n"
"Инструкция 20 устанавливает регистр `dl`, `количество возвращаемых "
"значений`, в 1."

#: in/chapter10.md:171
msgid ""
"Contrast this to the code for `g`, which has no declarations and is compiled "
"at default speed and safety settings:"
msgstr ""
"Сравните это с кодом для `g`, который не имеет деклараций и компилируется с "
"настройками скорости и безопасности по умолчанию:"

#: in/chapter10.md:178
msgid ""
"```\n"
"> (disassemble 'g)\n"
";; disassembling #<Function g @ #x83dbd1  >\n"
";; formals: x y\n"
";; code vector @ #x83db64\n"
"```"
msgstr ""

#: in/chapter10.md:210
msgid ""
"| []()  |          |                |                  |\n"
"|-------|----------|----------------|------------------|\n"
"| `0:`  | `add.l`  | `#8,31(a2)`    |                  |\n"
"| `4:`  | `sub.w`  | `#2,dl`        |                  |\n"
"| `6:`  | `beq.s`  | `12`           |                  |\n"
"| `8:`  | `jmp`    | `16(a4)`       | `; wnaerr`       |\n"
"| `12:` | `link`   | `a6,#0`        |                  |\n"
"| `16:` | `move.l` | `a2,-(a7)`     |                  |\n"
"| `18:` | `move.l` | `a5,-(a7)`     |                  |\n"
"| `20:` | `move.l` | `7(a2),a5`     |                  |\n"
"| `24:` | `tst.b`  | `-  208(a4)`   | `; signal-hit`   |\n"
"| `28`  | `beq.s`  | `34`           |                  |\n"
"| `30:` | `jsr`    | `872(a4)`      | `; process-sig`  |\n"
"| `34:` | `move.l` | `8(a6),d4`     | `; y`            |\n"
"| `38:` | `move.l` | `12(a6),d0`    | `; x`            |\n"
"| `42:` | `or.l`   | `d4,d0`        |                  |\n"
"| `44:` | `and.b`  | `#7,d0`        |                  |\n"
"| `48:` | `bne.s`  | `62`           |                  |\n"
"| `50:` | `add.l`  | `12(a6),d4 ;`  | `x`              |\n"
"| `54:` | `bvc.s`  | `76`           |                  |\n"
"| `56:` | `jsr`    | `696(a4)`      | `; add-overflow` |\n"
"| `60:` | `bra.s`  | `76`           |                  |\n"
"| `62:` | `move.l` | `12(a6),-(a7)` | `; x`            |\n"
"| `66:` | `move.l` | `d4,-(a7)`     |                  |\n"
"| `68:` | `move.l` | `#2,d1`        |                  |\n"
"| `70:` | `move.l` | `-304(a4),a0`  | `; +  _2op`      |\n"
"| `74:` | `jsr`    | `(a4)`         |                  |\n"
"| `76:` | `move.l` | `#1,d1`        |                  |\n"
"| `78:` | `move.l` | `-8(a6),a5`    |                  |\n"
"| `82:` | `unlk`   | `a6`           |                  |\n"
"| `84:` | `rtd`    | `#8`           |                  |"
msgstr ""

#: in/chapter10.md:222
msgid ""
"See how much more work is done.\n"
"The first four instructions ensure that the right number of arguments have "
"been passed to `g`.\n"
"If not, there is a jump to `wnaerr` (wrong-number-of-arguments-error).\n"
"Instructions 12-20 have the argument loading code that was at 0-8 in `f`.\n"
"At 24-30 there is a check for asynchronous signals, such as the user hitting "
"the abort key.\n"
"After `x` and `y` are loaded, there is a type check (42-48).\n"
"If the arguments are not both fixnums, then the code at instructions 62-74 "
"sets up a call to  `+  _2op`, which handles type coercion and non-fixnum "
"addition.\n"
"If all goes well, we don't have to call this routine, and do the addition at "
"instruction 50 instead.\n"
"But even then we are not done-just because the two arguments were fixnums "
"does not mean the result will be.\n"
"Instructions 54-56 check and branch to an overflow routine if needed.\n"
"Finally, instructions 76-84 return the final value, just as in `f`."
msgstr ""
"Посмотрите, сколько еще работы выполняется .\n"
"Первые четыре инструкции гарантируют, что правильное количество аргументов "
"было передано в `g`.\n"
"В противном случае происходит переход к `wnaerr` (ошибка неправильного числа "
"аргументов).\n"
"Инструкции 12-20 имеют код загрузки аргумента, который был в 0-8 в `f`.\n"
"На 24-30 выполняется проверка на наличие асинхронных сигналов, таких как "
"нажатие пользователем клавиши прерывания.\n"
"После загрузки `x` и `y` выполняется проверка типа (42-48).\n"
"Если оба аргумента не являются фиксированными числами, то код в инструкциях "
"62-74 устанавливает вызов `+ _2op`, который обрабатывает приведение типов и "
"сложение не фиксированных чисел.\n"
"Если все идет хорошо, нам не нужно вызывать эту процедуру, а вместо этого "
"выполнять сложение по инструкции 50.\n"
"Но даже в этом случае мы не закончили - просто потому, что два аргумента "
"были фиксированными числами, не означает, что результат будет.\n"
"Инструкции 54-56 проверяют и при необходимости переходят к процедуре "
"переполнения.\n"
"Наконец, инструкции 76-84 возвращают окончательное значение, как и в `f`."

#: in/chapter10.md:226
msgid ""
"Some low-quality compilers ignore declarations altogether.\n"
"Other compilers don't need certain declarations, because they can rely on "
"special instructions in the underlying architecture.\n"
"On a Lisp Machine, both `f` and `g` compile into the same code:"
msgstr ""
"Некоторые некачественные компиляторы вообще игнорируют объявления.\n"
"Другим компиляторам не нужны определенные объявления, потому что они могут "
"полагаться на специальные инструкции в базовой архитектуре.\n"
"На Lisp-машине и `f` и `g` компилируются в один и тот же код:\n"

#: in/chapter10.md:232
msgid ""
"| []()       |           |       |\n"
"|------------|-----------|-------|\n"
"| `6 PUSH`   | `ARG|0`   | `; X` |\n"
"| `7 +`      | `ARG|1`   | `; Y` |\n"
"| `8 RETURN` | `PDL-POP` |       |"
msgstr ""
"```\n"
"  6 PUSH    ARG|0`   ; X\n"
"  7 +       ARG|1`   ; Y\n"
"  8 RETURN  PDL-POP\n"
"```"

#: in/chapter10.md:238
msgid ""
"The Lisp Machine has a microcoded  +  instruction that simultaneously does a "
"fixnum add and checks for non-fixnum arguments, branching to a subroutine if "
"either argument is not a fixnum.\n"
"The hardware does the work that the compiler has to do on a conventional "
"processor.\n"
"This makes the Lisp Machine compiler simpler, so compiling a function is "
"faster.\n"
"However, on modern pipelined computers with instruction caches, there is "
"little or no advantage to microcoding.\n"
"The current trend is away from microcode toward reduced instruction set "
"computers (RISC)."
msgstr ""
"В Lisp Machine есть микрокодированная инструкция +, которая одновременно "
"выполняет добавление fixnum и проверяет аргументы, отличные от fixnum, "
"переходя к подпрограмме, если любой из аргументов не является fixnum.\n"
"Оборудование выполняет ту работу, которую компилятор должен делать на "
"обычном процессоре.\n"
"Это упрощает компилятор Lisp Machine, поэтому компиляция функции выполняется "
"быстрее.\n"
"Однако на современных конвейерных компьютерах с кэшем инструкций "
"микрокодирование практически не дает никаких преимуществ.\n"
"Текущая тенденция - от микрокода к компьютерам с сокращенным набором команд "
"(RISC)."

#: in/chapter10.md:240
msgid ""
"On most computers, the following declarations are most likely to be helpful:"
msgstr ""
"На большинстве компьютеров, скорее всего, будут полезны следующие объявления:"

#: in/chapter10.md:247
msgid ""
"*   `fixnum and float`.\n"
"Numbers declared as fixnums or floating-point numbers can be handled "
"directly by the host computer's arithmetic instructions.\n"
"On some systems, `float` by itself is not enough; you have to say `single-"
"float` or `double-float`.\n"
"Other numeric declarations will probably be ignored.\n"
"For example, declaring a variable as integer does not help the compiler "
"much, because bignums are integers.\n"
"The code to add bignums is too complex to put inline, so the compiler will "
"branch to a general-purpose routine (like  `+  _2op` in Allegro), the same "
"routine it would use if no declarations were given."
msgstr ""
"* `fixnum и float`.\n"
"Числа, объявленные как фиксированные числа или числа с плавающей запятой, "
"могут обрабатываться непосредственно арифметическими инструкциями хост "
"компьютера.\n"
"В некоторых системах одного `float` недостаточно; вы должны сказать `single-"
"float` или `double-float`.\n"
"Другие числовые объявления, вероятно, будут проигнорированы.\n"
"Например, объявление переменной как целого числа не сильно помогает "
"компилятору, потому что bignums тоже являются целыми числами.\n"
"Код для добавления bignums слишком сложен, чтобы вставлять его в строку, "
"поэтому компилятор будет переходить к подпрограмме общего назначения "
"(например, `+ _2op` в Allegro), той же подпрограмме, которую он использовал "
"бы, если бы не было задано никаких объявлений."

#: in/chapter10.md:253
msgid ""
"*   `list and array`.\n"
"Many Lisp systems provide separate functions for the list- and array- "
"versions of commonly used sequence functions.\n"
"For example, `(delete  x  (the list 1 ))` compiles into `(sys: delete-list-"
"eql x 1)` on a TI Explorer Lisp Machine.\n"
"Another function, `sys:delete-vector`, is used for arrays, and the generic "
"function `delete` is used only when the compiler can't tell what type the "
"sequence is.\n"
"So if you know that the argument to a generic function is either a `list` or "
"an `array`, then declare it as such."
msgstr ""
"*   `list и array`.\n"
"Многие системы Lisp предоставляют отдельные функции для версий списка и "
"массива часто используемых функций работы с последовательностями.\n"
"Например, `(delete x (the list 1))` компилируется в `(sys:delete-list-eql x "
"1)` на Lisp Machine TI Explorer.\n"
"Другая функция, `sys:delete-vector`, используется для массивов, а обобщенная "
"функция `delete` используется только тогда, когда компилятор не может "
"определить тип последовательности.\n"
"Поэтому, если вы знаете, что аргументом обобщенной функции является либо "
"`список`, либо `массив`, объявите его как таковой."

#: in/chapter10.md:259
msgid ""
"*   `simple-vector and simple-array`.\n"
"Simple vectors and arrays are those that do not share structure with other "
"arrays, do not have fill pointers, and are not adjustable.\n"
"In many implementations it is faster to aref a `simple-vector` than a "
"`vector`.\n"
"It is certainly much faster than taking an `elt` of a sequence of unknown "
"type.\n"
"Declare your arrays to be simple (if they in fact are)."
msgstr ""
"*   `simple-vector и simple-array`\n"
"Простые векторы и массивы - это те, которые не имеют общей структуры с "
"другими массивами, не имеют указателей заполнения и не регулируются(not "
"adjustable).\n"
"Во многих реализациях aref для `simple-vector` быстрее, чем для `vector`.\n"
"И он, безусловно, намного быстрее, чем взятие `elt` последовательности "
"неизвестного типа.\n"
"Объявите свои массивы простыми(simple) (если они действительно таковы)."

#: in/chapter10.md:267
msgid ""
"*   `(array *type*)`.\n"
"It is often important to specialize the type of array elements.\n"
"For example, an `(array short-float)` may take only half the storage of a "
"general array, and such a declaration will usually allow computations to be "
"done using the CPU's native floating-point instructions, rather than "
"converting into and out of Common Lisp's representation of floating points.\n"
"This is very important because the conversion normally requires allocating "
"storage, but the direct computation does not.\n"
"The specifiers `(simple-array *type*)` and `(vector *type*)` should be used "
"instead of `(array *type*)` when appropriate.\n"
"A very common mistake is to declare `(simple-vector *type*)`.\n"
"This is an error because Common Lisp expects `(simple-vector *size*)`-don't "
"ask me why."
msgstr ""
"*   `(array *type*)`.\n"
"Часто бывает важно определить тип элементов массива.\n"
"Например, `(array short-float)` может занимать только половину хранилища "
"общего массива, и такое объявление обычно позволяет выполнять вычисления с "
"использованием собственных инструкций ЦП с плавающей запятой вместо "
"преобразования `в` и `из` Представление чисел с плавающей запятой в Common "
"Lisp.\n"
"Это очень важно, потому что преобразование обычно требует выделения памяти, "
"а прямое вычисление - нет.\n"
"Спецификаторы `(simple-array *type*)` и `(vector *type*)` должны "
"использоваться вместо `(array *type*)`, когда это применимо.\n"
"Очень распространенной ошибкой является объявление `(simple-vector "
"*type*)`.\n"
"Это ошибка, потому что Common Lisp ожидает `(simple-vector *size*)` - не "
"спрашивайте меня, почему."

#: in/chapter10.md:273
msgid ""
"*   `(array **dimensions*)`.\n"
"The full form of an array or `simple-array` type specifier is `(array *type "
"dimensions*)`.\n"
"So, for example, `(array bit (* *))` is a two-dimensional bit array, and "
"`(array bit (1024 1024))` is a 1024  x  1024 bit array.\n"
"It is very important to specify the number of dimensions when known, and "
"less important to specify the exact size, although with multidimensional "
"arrays, declaring the size is more important.\n"
"The format for a vector type specifier is `(vector *type size*)`."
msgstr ""
"*   `(array **dimensions*)`.\n"
"Полная форма спецификатора типа массива или `simple-array` это `(array *type "
"dimensions*)`.\n"
"Так, например, `(array bit (* *))` представляет собой двумерный битовый "
"массив, а `(array bit (1024 1024))` представляет собой массив размером 1024 "
"x 1024 бит.\n"
"Очень важно указать количество измерений, когда оно известно, и менее важно "
"указать точный размер, хотя для многомерных массивов объявление размера "
"более важно.\n"
"Формат спецификатора векторного типа - `(vector *type size*)`."

#: in/chapter10.md:276
msgid ""
"Note that several of these declarations can apply all at once.\n"
"For example, in"
msgstr ""
"Обратите внимание, что некоторые из этих объявлений могут применяться "
"одновременно.\n"
"Например, в"

#: in/chapter10.md:280
msgid ""
"```lisp\n"
"(position # \\ . (the simple-string file-name))\n"
"```"
msgstr ""

#: in/chapter10.md:284
msgid ""
"the variable `filename` has been declared to be a vector, a simple array, "
"and a sequence of type `string-char`.\n"
"All three of these declarations are helpful.\n"
"The type `simple-string` is an abbreviation for `(simple-array string-char)`."
msgstr ""
"переменная `filename` была объявлена как вектор, простой массив и "
"последовательность типа `string-char`.\n"
"Все три обявления полезны.\n"
"Тип `simple-string` - это сокращение от `(simple-array string-char)`."

#: in/chapter10.md:286
msgid ""
"This guide applies to most Common Lisp systems, but you should look in the "
"implementation notes for your particular system for more advice on how to "
"fine-tune your code."
msgstr ""
"Это руководство применимо к большинству систем Common Lisp, но вам следует "
"заглянуть в примечания по реализации для вашей конкретной системы, чтобы "
"получить больше советов о том, как настроить ваш код."

#: in/chapter10.md:288
msgid "## 10.2 Avoid Generic Functions"
msgstr "## 10.2 Избегайте Обобщенных Функций"

#: in/chapter10.md:295
msgid ""
"Common Lisp provides functions with great generality, but someone must pay "
"the price for this generality.\n"
"For example, if you write `(elt x 0)`, different machine instruction will be "
"executed depending on if x is a list, string, or vector.\n"
"Without declarations, checks will have to be done at runtime.\n"
"You can either provide declarations, as in `(elt (the list x) 0)`, or use a "
"more specific function, such as `(first x)` in the case of lists, `(char x "
"0)` for strings, `(aref x0)` for vectors, and `(svref x 0)` for simple "
"vectors.\n"
"Of course, generic functions are useful-I wrote `random-elt` as shown "
"following to work on lists, when I could have written the more efficient "
"`random-mem` instead.\n"
"The choice paid off when `I` wanted a function to choose a random character "
"from a string-`random-elt` does the job unchanged, while `random-mem` does "
"not."
msgstr ""
"Common Lisp предоставляет функции с большой обобщенностью, но кто-то должен "
"заплатить за эту обобщенность.\n"
"Например, если вы напишете `(elt x 0)`, разные машинные инструкции будут "
"выполняться в зависимости от того, является ли x списком, строкой или "
"вектором.\n"
"Без деклараций, проверки придется проводить во время выполнения.\n"
"Вы можете либо предоставить объявления(декларации), как в `(elt (the list x) "
"0)`, либо использовать более конкретную(специализированную) функцию, такую "
"как `(first x)` в случае списков, `(char x 0)` для строк , `(aref x 0)` для "
"векторов и `(svref x 0)` для простых векторов.\n"
"Конечно, обобщенные функции полезны - я написал `random-elt`, как показано "
"ниже, для работы со списками, тогда как вместо этого я мог бы написать более "
"эффективный `random-mem`.\n"
"Выбор окупился, когда `Я` захотел, чтобы функция выбирала случайный символ "
"из строки - `random-elt` выполняет свою работу без изменений, а `random-mem` "
"- нет."

#: in/chapter10.md:300
msgid ""
"```lisp\n"
"(defun random-elt (s) (elt s (random (length s))))\n"
"(defun random-mem (l) (nth (random (length (the list l))) l))\n"
"```"
msgstr ""

#: in/chapter10.md:303
msgid ""
"This example was simple, but in more complicated cases you can make your "
"sequence functions more efficient by having them explicitly check if their "
"arguments are lists or vectors.\n"
"See the definition of `map-into` on [page 857](B9780080571157500248."
"xhtml#p857)."
msgstr ""
"Этот пример был простым, но в более сложных случаях вы можете сделать свои "
"функции работы с последовательностями более эффективными, если они будут "
"явно проверять, являются ли их аргументы списками или векторами.\n"
"См. Определение `map-into` на [страница 857](B9780080571157500248."
"xhtml#p857)."

#: in/chapter10.md:305
msgid "## 10.3 Avoid Complex Argument Lists"
msgstr "## 10.3 Избегайте сложных списков аргументов"

#: in/chapter10.md:309
msgid ""
"Functions with keyword arguments suffer a large degree of overhead.\n"
"This may also be true for optional and rest arguments, although usually to a "
"lesser degree.\n"
"Let's look at some simple examples:"
msgstr ""
"Функции с аргументами ключевыми словами несут большие накладные расходы.\n"
"Это также может быть верно для необязательных аргументов и аргументов "
"`rest`, хотя обычно в меньшей степени.\n"
"Давайте посмотрим на несколько простых примеров:"

#: in/chapter10.md:316
msgid ""
"```lisp\n"
"(defun reg (a b c d) (list a b c d))\n"
"(defun rst (abc &rest d) (list* a b c d))\n"
"(defun opt (&optional a b (c 1) (d (sqrt a))) (list a b c d))\n"
"(defun key (&key a b (c 1) (d (sqrt a))) (list a b c d))\n"
"```"
msgstr ""

#: in/chapter10.md:318
msgid ""
"We can see what these compile into for the TI Explorer, but remember that "
"your compiler may be quite different."
msgstr ""
"Мы можем видеть, во что они компилируются для TI Explorer, но помните, что "
"ваш компилятор может быть совершенно другим."

#: in/chapter10.md:320
msgid "`> (disassemble 'reg)`"
msgstr ""

#: in/chapter10.md:328
msgid ""
"| []()                     |        |     |             |\n"
"|--------------------------|--------|-----|-------------|\n"
"| `      8 PUSH`           | `ARG   | 0`  | `; A`       |\n"
"| `      9 PUSH`           | `ARG   | 1`  | `; B`       |\n"
"| `    10 PUSH`            | `ARG   | 2`  | `; C`       |\n"
"| `    11 PUSH`            | `ARG   | 3`  | `; D`       |\n"
"| `    12 TAIL-REC CALL-4` | `FEF   | 3`  | `; #'LIST`  |"
msgstr ""

#: in/chapter10.md:330
msgid "`> (disassemble 'rst)`"
msgstr ""

#: in/chapter10.md:338
msgid ""
"| []()                     |        |     |             |\n"
"|--------------------------|--------|-----|-------------|\n"
"| `      8 PUSH`           | `ARG   | 0`  | `; A`       |\n"
"| `      9 PUSH`           | `ARG   | 1`  | `; B`       |\n"
"| `    10 PUSH`            | `ARG   | 2`  | `; C`       |\n"
"| `    11 PUSH`            | `LOCAL | 0`  | `; D`       |\n"
"| `    12 RETURN CALL-4`   | `FEF   | 3`  | `; #'LIST*` |"
msgstr ""

#: in/chapter10.md:341
msgid ""
"With the regular argument list, we just push the four variables on the "
"argument stack and branch to the list function.\n"
"([Chapter 22](B9780080571157500224.xhtml) explains why a tail-recursive call "
"is just a branch statement.)"
msgstr ""
"При использовании обычного списка аргументов мы просто помещаем четыре "
"переменные в стек аргументов и переходим к вызову функции list.\n"
"([Глава 22](B9780080571157500224.xhtml) объясняет, почему хвосто-рекурсивный "
"вызов является просто оператором ветвления.)"

#: in/chapter10.md:345
msgid ""
"With a rest argument, things are almost as easy.\n"
"It turns out that on this machine, the microcode for the calling sequence "
"automatically handles rest arguments, storing them in local variable 0.\n"
"Let's compare with optional arguments:"
msgstr ""
"С аргументом rest все почти так же просто.\n"
"Оказывается, на этой машине микрокод для вызывающей последовательности "
"автоматически обрабатывает аргументы rest, сохраняя их в локальной "
"переменной 0.\n"
"Сравним с кодом использующим необязательные аргументамы:"

#: in/chapter10.md:350
msgid ""
"```\n"
"(defun opt (&optional a b (c 1) (d (sqrt a))) (list a b c d))\n"
"  > (disassemble 'opt)\n"
"```"
msgstr ""
"```\n"
"(defun opt (&optional a b (c 1) (d (sqrt a))) (list a b c d))\n"
"  > (disassemble 'opt)\n"
"```\n"

#: in/chapter10.md:364
msgid ""
"| []()                   |         "
"|                                                  |\n"
"|------------------------|---------|--------------------------------------------------|\n"
"| `  24 DISPATCH`        | `FEF|5` | `; [0`=>`25;1`=>`25;2`=>`25;3`=>`27;"
"ELSE`=>`30]` |\n"
"| `  25 PUSH-NUMBER`     | `1`     "
"|                                                  |\n"
"| `  26 POP`             | `ARG|2` | ; "
"`C`                                            |\n"
"| `  27 PUSH`            | `ARG|0` | ; "
"`A`                                            |\n"
"| `  28 PUSH CALL-1`     | `FEF|3` | ; "
"`#'SQRT`                                       |\n"
"| `  29 POP`             | `ARG|3` | ; "
"`D`                                            |\n"
"| `  30 PUSH`            | `ARG|0` | ; "
"`A`                                            |\n"
"| `  31 PUSH`            | `ARG|1` | ; "
"`B`                                            |\n"
"| `  32 PUSH`            | `ARG|2` | ; "
"`C`                                            |\n"
"| `  33 PUSH`            | `ARG|3` | ; "
"`D`                                            |\n"
"| `  34 TAIL-REC CALL-4` | `FEF|4` | ; "
"`#'LIST`                                       |"
msgstr ""
"```\n"
"  24 DISPATCH        FEF|5 ; [0=>25;1=>25;2=>25;3=>27;ELSE=>30]\n"
"  25 PUSH-NUMBER     1               \n"
"  26 POP             ARG|2 ; C     \n"
"  27 PUSH            ARG|0 ; A     \n"
"  28 PUSH CALL-1     FEF|3 ; #'SQRT\n"
"  29 POP             ARG|3 ; D     \n"
"  30 PUSH            ARG|0 ; A     \n"
"  31 PUSH            ARG|1 ; B     \n"
"  32 PUSH            ARG|2 ; C     \n"
"  33 PUSH            ARG|3 ; D     \n"
"  34 TAIL-REC CALL-4 FEF|4 ; #'LIST\n"
"```"

#: in/chapter10.md:370
msgid ""
"Although this assembly language may be harder to read, it turns out that "
"optional arguments are handled very efficiently.\n"
"The calling sequence stores the number of optional arguments on top of the "
"stack, and the `DISPATCH` instruction uses this to index into a table stored "
"at location `FEF|5` (an offset five words from the start of the function).\n"
"The result is that in one instruction the function branches to just the "
"right place to initialize any unspecified arguments.\n"
"Thus, a function with optional arguments that are all supplied takes only "
"one more instruction (the dispatch) than the \"regular\" case.\n"
"Unfortunately, keyword arguments don't fare as well:"
msgstr ""
"Хотя этот язык ассемблера может быть труднее читать, оказывается, что "
"необязательные аргументы обрабатываются очень эффективно.\n"
"Вызывающая последовательность хранит количество необязательных аргументов "
"наверху стека, а инструкция DISPATCH использует это для индексации в "
"таблице, хранящейся в ячейке `FEF|5` (смещение на пять слов от начала "
"функции).\n"
"В результате в одной инструкции функция переходит в нужное место для "
"инициализации любых неуказанных аргументов.\n"
"Таким образом, функция с предоставленными необязательными аргументами "
"принимает только на одну инструкцию (отправку/dispatch) больше, чем в "
"\"обычном\" случае.\n"
"К сожалению, аргументы ключевых слов так не работают:"

#: in/chapter10.md:375
msgid ""
"```\n"
"(defun key (&key a b` (`c 1`) `(d (sqrt a))) (list a b c d))\n"
"  > (disassemble 'key)\n"
"```"
msgstr ""

#: in/chapter10.md:400
msgid ""
"| []()                              |           |                           "
"|\n"
"|-----------------------------------|-----------|---------------------------|\n"
"| `  14 PUSH-NUMBER`                | `1`       |                           "
"|\n"
"| `  15 POP`                        | `LOCAL|3` | `; C`                     "
"|\n"
"| `  16 PUSH`                       | `FEF|3`   | `; SYS:-.KEYWORD-GARBAGE` "
"|\n"
"| `  17 POP`                        | `LOCAL|4` |                           "
"|\n"
"| `  18 TEST`                       | `LOCAL|0` |                           "
"|\n"
"| `  19 BR-NULL`                    | `24`      |                           "
"|\n"
"| `  20 PUSH`                       | `FEF|4`   | `; '(:A :B :C :D)`        "
"|\n"
"| `  21 SET-NIL`                    | `PDL-PUSH`|                           "
"|\n"
"| `  22 PUSH-LOC`                   | `LOCAL|1` | `; A`                     "
"|\n"
"| `  23 (AUX) %STORE-KEY-WORD-ARGS` |           |                           "
"|\n"
"| `  24 PUSH`                       | `LOCAL|1` | `; A`                     "
"|\n"
"| `  25 PUSH`                       | `LOCAL|2` | `; B`                     "
"|\n"
"| `  26 PUSH`                       | `LOCAL|3` | `; C`                     "
"|\n"
"| `  27 PUSH`                       | `|4`      |                           "
"|\n"
"| `  28 EQ`                         | `FEF|3`   | `; SYS::KEYWORD-GARBAGE`  "
"|\n"
"| `  29 BR-NULL`                    | `33`      |                           "
"|\n"
"| `  30 PUSH`                       | `LOCAL|1` | `; A`                     "
"|\n"
"| `  31 PUSH CALL-1`                | `FEF|5`   | `; #'SQRT`                "
"|\n"
"| `  32 RETURN CALL-4`              | `FEF|6`   | `; #'LIST`                "
"|\n"
"| `  33 PUSH`                       | `LOCAL|4` |                           "
"|\n"
"| `  34 RETURN CALL-4`              | `FEF|6`   | ;`#'LIST`                 |"
msgstr ""
"```\n"
"  14 PUSH-NUMBER                1                             \n"
"  15 POP                        LOCAL|3 ; C                  \n"
"  16 PUSH                       FEF|3   ; SYS:-.KEYWORD-GARBAGE\n"
"  17 POP                        LOCAL|4                        \n"
"  18 TEST                       LOCAL|0\n"
"  19 BR-NULL                    24\n"
"  20 PUSH                       FEF|4   ; '(:A :B :C :D)\n"
"  21 SET-NIL                    PDL-PUSH\n"
"  22 PUSH-LOC                   LOCAL|1 ; A\n"
"  23 (AUX) %STORE-KEY-WORD-ARGS             \n"
"  24 PUSH                       LOCAL|1 ; A\n"
"  25 PUSH                       LOCAL|2 ; B\n"
"  26 PUSH                       LOCAL|3 ; C\n"
"  27 PUSH                       |4         \n"
"  28 EQ                         FEF|3   ; SYS::KEYWORD-GARBAGE\n"
"  29 BR-NULL                    33                            \n"
"  30 PUSH                       LOCAL|1 ; A\n"
"  31 PUSH CALL-1                FEF|5   ; #'SQRT\n"
"  32 RETURN CALL-4              FEF|6   ; #'LIST\n"
"  33 PUSH                       LOCAL|4\n"
"  34 RETURN CALL-4              FEF|6   ; #'LIST\n"
"```"

#: in/chapter10.md:403
msgid ""
"It is not important to be able to read all this assembly language.\n"
"The point is that there is considerable overhead, even though this "
"architecture has a specific instruction `(%STORE-KEY-WORD-ARGS)` to help "
"deal with keyword arguments."
msgstr ""
"Не важно уметь читать весь этот ассемблер.\n"
"Дело в том, что существуют значительные накладные расходы, даже несмотря на "
"то, что в этой архитектуре есть специальная инструкция `(%STORE-KEY-WORD-"
"ARGS)` для помощи при работе с аргументами ключевыми словами."

#: in/chapter10.md:406
msgid ""
"Now let's look at the results on another system, the Allegro compiler for "
"the 68000.\n"
"First, here's the assembly code for reg, to give you an idea of the minimal "
"calling sequence:[1](#fn0015)"
msgstr ""
"Теперь давайте посмотрим на результаты на другой системе, компиляторе "
"Allegro для 68000.\n"
"Во-первых, вот ассемблерный код для reg, чтобы дать вам представление о "
"минимальной последовательности вызовов: [1](# fn0015)"

#: in/chapter10.md:413
msgid ""
"```\n"
"> (disassemble 'reg)\n"
";; disassembling #<Function reg @ #x83db59  >\n"
";; formals: a b c d\n"
";; code vector @ #x83dblc\n"
"```"
msgstr ""

#: in/chapter10.md:429
msgid ""
"| []()  |          |                |          |\n"
"|-------|----------|----------------|----------|\n"
"| `0:`  | `link`   | `a6,#0`        |          |\n"
"| `4:`  | `move.l` | `a2,-(a7)`     |          |\n"
"| `6:`  | `move.l` | `a5,-(a7)`     |          |\n"
"| `8:`  | `move.l` | `7(a2),a5`     |          |\n"
"| `12:` | `move.l` | `20(a6),-(a7)` | `; a`    |\n"
"| `16:` | `move.l` | `16(a6).-(a7)` | `; b`    |\n"
"| `20:` | `move.l` | `12(a6),-(a7)` | `; c`    |\n"
"| `24:` | `move.l` | `8(a6),-(a7)`  | `; d`    |\n"
"| `28:` | `move.l` | `#4,dl`        |          |\n"
"| `30:` | `jsr`    | `848(a4)`      | `; list` |\n"
"| `34:` | `move.l` | `-  8(a6),a5`  |          |\n"
"| `38:` | `unlk`   | `a6`           |          |\n"
"| `40:` | `rtd`    | `#10`          |          |"
msgstr ""

#: in/chapter10.md:431
msgid "Now we see that `&rest` arguments take a lot more code in this system:"
msgstr ""
"Теперь мы видим, что аргументы `&rest` занимают намного больше кода в этой "
"системе:"

#: in/chapter10.md:438
msgid ""
"```\n"
"> (disassemble 'rst)\n"
";; disassembling #<Function rst @ #x83de89  >\n"
";; formals: a b c &rest d\n"
"code vector @ #x83de34\n"
"```"
msgstr ""

#: in/chapter10.md:464
msgid ""
"| []()  |          |                 |                         |\n"
"|-------|----------|-----------------|-------------------------|\n"
"| `0:`  | `sub.w`  | `#3,dl`         |                         |\n"
"| `2:`  | `bge.s`  | `8`             |                         |\n"
"| `4:`  | `jmp`    | `16(a4)`        | `; wnaerr`              |\n"
"| `8:`  | `move.l` | `(a7)+,al`      |                         |\n"
"| `10`: | `move.l` | `d3,-(a7)`      | `; nil`                 |\n"
"| `12`: | `sub.w`  | `#l,dl`         |                         |\n"
"| `14:` | `bit.s`  | `38`            |                         |\n"
"| `16:` | `move.l` | `al, -  52(a4)` | `; c_protected-retaddr` |\n"
"| `20:` | `jsr`    | `40(a4)`        | `; cons`                |\n"
"| `24:` | `move.l` | `d4,-(a7)`      |                         |\n"
"| `26:` | `dbra`   | `dl,20`         |                         |\n"
"| `30:` | `move.l` | `-  52(a4),al`  | `; c_protected-retaddr` |\n"
"| `34:` | `clr.l`  | `-  52(a4)`     | `; c_protected-retaddr` |\n"
"| `38:` | `move.l` | `al,`           | `-(a7)`                 |\n"
"| `40:` | `link`   | `a6,#0`         |                         |\n"
"| `44:` | `move.l` | `a2,-(a7)`      |                         |\n"
"| `46:` | `move.l` | `a5,-(a7)`      |                         |\n"
"| `48:` | `move.l` | `7(a2),a5`      |                         |\n"
"| `52:` | `move.l` | `-  332(a4),a0` | `; list*`               |\n"
"| `56:` | `move.l` | `-  8(a6),a5`   |                         |\n"
"| `60:` | `unlk`   | `a6`            |                         |\n"
"| `62`: | `move.l` | `#4,dl`         |                         |\n"
"| `64`  | `jmp`    | `(a4)`          |                         |"
msgstr ""

#: in/chapter10.md:469
msgid ""
"The loop from 20-26 builds up the `&rest` list one cons at a time.\n"
"Part of the difficulty is that cons could initiate a garbage collection at "
"any time, so the list has to be built in a place that the garbage collector "
"will know about.\n"
"The function with optional arguments is even worse, taking 34 instructions "
"(104 bytes), and keywords are worst of all, weighing in at 71 instructions "
"(178 bytes), and including a loop.\n"
"The overhead for optional arguments is proportional to the number of "
"optional arguments, while for keywords it is proportional to the product of "
"the number of parameters allowed and the number of arguments actually "
"supplied."
msgstr ""
"Цикл от 20 до 26 строит список `&rest` по одному cons за раз.\n"
"Частично сложность состоит в том, что cons-ы могут инициировать сборку "
"мусора в любое время, поэтому список должен быть построен в месте, о котором "
"сборщик мусора будет знать.\n"
"Функция с необязательными аргументами еще хуже, она принимает 34 инструкции "
"(104 байта), а ключевые слова хуже всего, занимая 71 инструкцию (178 байтов) "
"и включает цикл.\n"
"Накладные расходы для необязательных аргументов пропорциональны количеству "
"необязательных аргументов, в то время как для ключевых слов они "
"пропорциональны произведению количества разрешенных параметров и количества "
"фактически предоставленных аргументов."

#: in/chapter10.md:472
msgid ""
"A good guideline to follow is to use keyword arguments primarily as an "
"interface to infrequently used functions, and to provide versions of these "
"functions without keywords that can be used in places where efficiency is "
"important.\n"
"Consider:"
msgstr ""
"Хорошим руководящим принципом для подражания является использование "
"аргументов ключевого слова в первую очередь как интерфейс для редко "
"используемых функций и предоставление версий этих функций без ключевых слов, "
"которые можно использовать в местах, где важна эффективность.\n"
"Рассмотрим:"

#: in/chapter10.md:478
msgid ""
"```lisp\n"
"(proclaim '(inline key))\n"
"(defun key (&key a b (c 1) (d (sqrt a))) (*no-key a b c d))\n"
"(defun *no-key (a b c d) (list a b c d))\n"
"```"
msgstr ""

#: in/chapter10.md:481
msgid ""
"Here the function `key` is used as an interface to the function `no-key`, "
"which does the real work.\n"
"The inline proclamation should allow the compiler to compile a call to key "
"as a call to `no-key` with the appropriate arguments:"
msgstr ""
"Здесь функция `key` используется как интерфейс к функции `no-key`, которая "
"выполняет реальную работу.\n"
"Объявление inline должно позволить компилятору скомпилировать вызов `key` "
"как вызов `no-key` с соответствующими аргументами:"

#: in/chapter10.md:485
msgctxt "in/chapter10.md:485"
msgid ""
"```\n"
"> (disassemble #'(lambda (x y) (key :b x :a y)))\n"
"```"
msgstr ""

#: in/chapter10.md:494
msgid ""
"| []()                   |         |              |\n"
"|------------------------|---------|--------------|\n"
"| `  10 PUSH`            | `ARG|1` | `; Y`        |\n"
"| `  11 PUSH`            | `ARG|0` | `; X`        |\n"
"| `  12 PUSH-NUMBER`     | `1`     |              |\n"
"| `  13 PUSH`            | `ARG|1` | `; Y`        |\n"
"| `  14 PUSH CALL-1`     | `FEF|3` | `; #'SORT`   |\n"
"| `  15 TAIL-REC CALL-4` | `FEF|4` | `; #'NO-KEY` |"
msgstr ""
"```\n"
"  10 PUSH            ARG|1 ; Y\n"
"  11 PUSH            ARG|0 ; X\n"
"  12 PUSH-NUMBER     1        \n"
"  13 PUSH            ARG|1 ; Y\n"
"  14 PUSH CALL-1     FEF|3 ; #'SORT\n"
"  15 TAIL-REC CALL-4 FEF|4 ; #'NO-KEY\n"
"```"

#: in/chapter10.md:497
msgid ""
"The overhead only comes into play when the keywords are not known at compile "
"time.\n"
"In the following example, the compiler is forced to call key, not `no-key`, "
"because it doesn't know what the keyword `k` will be at run time:"
msgstr ""
"Накладные расходы возникают только тогда, когда ключевые слова неизвестны во "
"время компиляции.\n"
"В следующем примере компилятор вынужден вызывать `key`, а не `no-key`, "
"потому что он не знает, каким будет ключевое слово `k` во время выполнения:"

#: in/chapter10.md:501
msgid ""
"```\n"
"> (disassemble #'(lambda (k x y) (key k x :a y)))\n"
"```"
msgstr ""

#: in/chapter10.md:509
msgid ""
"| []()                   |         |           |\n"
"|------------------------|---------|-----------|\n"
"| `  10 PUSH`            | `ARG|0` | ; `K`     |\n"
"| `  11 PUSH`            | `ARG|1` | ; `X`     |\n"
"| `  12 PUSH`            | `FEF|3` | `; ':A`   |\n"
"| `  13 PUSH`            | `ARG|2` | ; `Y`     |\n"
"| `  14 TAIL-REC CALL-4` | `FEF|4` | ; `#'KEY` |"
msgstr ""
"```\n"
"  10 PUSH             ARG|0  ; K     \n"
"  11 PUSH             ARG|1  ; X     \n"
"  12 PUSH             FEF|3  ; ':A   \n"
"  13 PUSH             ARG|2  ; Y     \n"
"  14 TAIL-REC CALL-4  FEF|4  ; #'KEY \n"
"```"

#: in/chapter10.md:512
msgid ""
"Of course, in this simple example I could have replaced `no-key` with "
"`list`, but in general there will be some more complex processing.\n"
"If I had proclaimed `no-key` inline as well, then I would get the following:"
msgstr ""
"Конечно, в этом простом примере я мог бы заменить `no-key` на `list`, но в "
"целом это будет более сложная обработка.\n"
"Если бы я также объявил `inline` `no-key`, то получил бы следующее:"

#: in/chapter10.md:516
msgctxt "in/chapter10.md:516"
msgid ""
"```\n"
"> (disassemble #'(lambda (x y) (key :b x :a y)))\n"
"```"
msgstr ""

#: in/chapter10.md:525
msgid ""
"| []()                   |         |            |\n"
"|------------------------|---------|------------|\n"
"| `  10 PUSH`            | `ARG|1` | `; Y`      |\n"
"| `  11 PUSH`            | `ARG|0` | `; X`      |\n"
"| `  12 PUSH-NUMBER`     | `1`     |            |\n"
"| `  13 PUSH`            | `ARG|1` | `; Y`      |\n"
"| `  14 PUSH CALL-1`     | `FEF|3` | `; #'SORT` |\n"
"| `  15 TAIL-REC CALL-4` | `FEF|4` | `; #'LIST` |"
msgstr ""
"```\n"
"  10 PUSH             ARG|1  ; Y\n"
"  11 PUSH             ARG|0  ; X\n"
"  12 PUSH-NUMBER      1         \n"
"  13 PUSH             ARG|1  ; Y\n"
"  14 PUSH CALL-1      FEF|3  ; #'SORT\n"
"  15 TAIL-REC CALL-4  FEF|4  ; #'LIST\n"
"```"

#: in/chapter10.md:527
msgid ""
"If you like, you can define a macro to automatically define the interface to "
"the keyword-less function:"
msgstr ""
"Если хотите, вы можете определить макрос для автоматического определения "
"интерфейса функции без ключевых слов:"

#: in/chapter10.md:531
msgid ""
"```lisp\n"
"(defmacro defun* (fn-name arg-list &rest body)\n"
"```"
msgstr ""

#: in/chapter10.md:534
msgid ""
"`  \"Define two functions.\n"
"one an interface to a &keyword-less`"
msgstr ""

#: in/chapter10.md:537
msgid ""
"`  version.\n"
"Proclaim the interface function inline.\"`"
msgstr ""

#: in/chapter10.md:563
msgid ""
"```lisp\n"
"  (if (and (member '&key arg-list)\n"
"        (not (member '&rest arg-list)))\n"
"      (let ((no-key-fn-name (symbol fn-name '*no-key))\n"
"        (args (mapcar #'first-or-self\n"
"              (set-difference\n"
"                arg-list\n"
"                lambda-list-keywords))))\n"
"      '(progn\n"
"        (proclaim '(inline ,fn-name))\n"
"        (defun ,no-key-fn-name ,args\n"
"          .,body)\n"
"        (defun ,fn-name ,arg-list\n"
"          (,no-key-fn-name .,args))))\n"
"    '(defun ,fn-name ,arg-list\n"
"      .,body)))\n"
">(macroexpand '(defun* key (&key a b (c 1) (d (sqrt a)))\n"
"            (list a b c d)))\n"
"(PROGN (PROCLAIM '(INLINE KEY))\n"
"    (DEFUN KEY*NO-KEY (A B C D) (LIST A B C D))\n"
"    (DEFUN KEY (&KEY A B (C 1) (D (SQRT A)))\n"
"      (KEY*NO-KEY A B C D)))\n"
">(macroexpand '(defun* reg (a b c d) (list a b c d)))\n"
"(DEFUN REG (A B C D) (LIST A B C D))\n"
"```"
msgstr ""

#: in/chapter10.md:566
msgid ""
"There is one disadvantage to this approach: a user who wants to declare key "
"inline or not inline does not get the expected result.\n"
"The user has to know that key is implemented with `key*no- key`, and declare "
"`key*no- key` inline."
msgstr ""
"У этого подхода есть один недостаток: пользователь, который хочет объявить "
"key встроенной или не встроенной, не получит ожидаемого результата.\n"
"Пользователь должен знать, что key реализован с помощью `key*no-key`, и "
"объявить `key*no-key` встроенной."

#: in/chapter10.md:570
msgid ""
"An alternative is just to proclaim the function that uses `&key` to be "
"inline.\n"
"Rob MacLachlan provides an example.\n"
"In CMU Lisp, the function `member` has the following definition, which is "
"proclaimed inline:"
msgstr ""
"Альтернативой является просто объявить функцию, использующую `&key`, "
"встроенной.\n"
"Роб Маклахлан приводит пример.\n"
"В CMU Lisp функция `member` имеет следующее определение, объявленное "
"встроенным:"

#: in/chapter10.md:590
msgid ""
"```lisp\n"
"(defun member (item list &key (key #'identity)\n"
"                (test #'eql testp)(test-not nil notp))\n"
"  (do ((list list (cdr list)))\n"
"      ((null list) nil)\n"
"    (let ((car (car list)))\n"
"      (if (cond\n"
"        (testp\n"
"          (funcall test item\n"
"                (funcall key car)))\n"
"        (notp\n"
"          (not\n"
"      (funcall test-not item\n"
"            (funcall key car))))\n"
"    (t\n"
"      (funcall test item\n"
"            (funcall key car))))\n"
"  (return list)))))\n"
"```"
msgstr ""

#: in/chapter10.md:593
msgid ""
"A call like `(member`[ch 1](B9780080571157500017.xhtml)`:key #'first-letter :"
"test #'char  =)` expands into the equivalent of the following code.\n"
"Unfortunately, not all compilers are this clever with inline declarations."
msgstr ""
"Вызов вида `(member` [ch 1](B9780080571157500017.xhtml)`:key #'first-letter :"
"test #'char =)` заменяется эквивалентом следующего кода.\n"
"К сожалению, не все компиляторы настолько умны с объявлениями inline."

#: in/chapter10.md:601
msgid ""
"```lisp\n"
"(do ((list list (cdr list)))\n"
"      ((null list) nil)\n"
"    (let ((car (car list)))\n"
"      (if (char  = ch (first-letter car))\n"
"        (return list))))\n"
"```"
msgstr ""

#: in/chapter10.md:605
msgid ""
"This chapter is concerned with efficiency and so has taken a stand against "
"the use of keyword parameter s in frequently used functions.\n"
"But when maintainability is considered, keyword parameters look much "
"better.\n"
"When a program is being developed, and it is not clear if a function will "
"eventually need additional arguments, keyword parameters may be the best "
"choice."
msgstr ""
"Эта глава посвящена эффективности и поэтому выступает против использования "
"параметра ключевого слова в часто используемых функциях.\n"
"Но если принять во внимание сопровождаемость, параметры ключевых слов "
"выглядят предпочтительнее.\n"
"Когда программа разрабатывается, и неясно, потребуются ли функции в конечном "
"итоге дополнительные аргументы, параметры ключевых слов могут быть лучшим "
"выбором."

#: in/chapter10.md:607
msgid "## 10.4 Avoid Unnecessary Consing"
msgstr "10.4 Избегайте ненужного Consing(а)/построения временных списков"

#: in/chapter10.md:616
msgid ""
"The `cons` function may appear to execute quite quickly, but like all "
"functions that allocate new storage, it has a hidden cost.\n"
"When large amounts of storage are used, eventually the system must spend "
"time garbage collecting.\n"
"We have not mentioned it earlier, but there are actually two relevant "
"measures of the amount of space consumed by a program: the amount of storage "
"allocated, and the amount of storage retained.\n"
"The difference is storage that is used temporarily but eventually freed.\n"
"Lisp guarantees that unused space will eventually be reclaimed by the "
"garbage collector.\n"
"This happens automatically-the programmer need not and indeed can not "
"explicitly free storage.\n"
"The problem is that the efficiency of garbage collection can vary widely.\n"
"Garbage collection is particularly worrisome for real-time systems, because "
"it can happen at any time."
msgstr ""
"Может показаться, что функция `cons` выполняется довольно быстро, но, как и "
"все функции, выделяющие новое хранилище, она имеет скрытую стоимость.\n"
"Когда используется большой объем хранилища, в конечном итоге системе "
"приходится тратить время на сборку мусора.\n"
"Мы не упоминали об этом ранее, но на самом деле есть два важных показателя "
"объема пространства, потребляемого программой: объем выделенного хранилища и "
"объем используемого хранилища.\n"
"Разница в том, что хранилище используется временно, но в конечном итоге "
"освобождается.\n"
"Lisp гарантирует, что неиспользуемое пространство в конечном итоге будет "
"возвращено сборщиком мусора.\n"
"Это происходит автоматически - программисту нет необходимости и он не может "
"явно освобождать память.\n"
"Проблема в том, что эффективность сборки мусора может сильно различаться.\n"
"Сборка мусора особенно тревожна для систем реального времени, потому что это "
"может произойти в любое время."

#: in/chapter10.md:624
msgid ""
"The antidote to garbage woes is to avoid unnecessary copying of objects in "
"often-used code.\n"
"Try using destructive operations, like `nreverse, delete`, and `nconc`, "
"rather than their nondestructive counterparts, (like reverse, remove, and "
"append) whenever it is safe to do so.\n"
"Or use vectors instead of lists, and reuse values rather than creating "
"copies.\n"
"As usual, this gain in efficiency may lead to errors that can be difficult "
"to debug.\n"
"However, the most common kind of unnecessary copying can be eliminated by "
"simple reorganization of your code.\n"
"Consider the following version of `flatten`, which returns a list of all the "
"atoms in its input, preserving order.\n"
"Unlike the version in [chapter 5](B9780080571157500054.xhtml), this version "
"returns a single list of atoms, with no embedded lists."
msgstr ""
"Противоядие от проблем с мусором - избегать ненужного копирования объектов в "
"часто используемом коде.\n"
"Попробуйте использовать деструктивные операции, такие как `nreverse, delete` "
"и `nconc`, а не их неразрушающие аналоги (например, reverse, remove и "
"append), когда это безопасно.\n"
"Или используйте векторы вместо списков и повторно используйте значения, а не "
"создавайте копии.\n"
"Как обычно, такое повышение эффективности может привести к ошибкам, которые "
"может быть трудно отладить.\n"
"Однако наиболее распространенный вид ненужного копирования можно устранить "
"простой реорганизацией вашего кода.\n"
"Рассмотрим следующую версию `flatten`, которая возвращает список всех атомов "
"во входных данных, сохраняя порядок.\n"
"В отличие от версии в [главе 5](B9780080571157500054.xhtml), эта версия "
"возвращает единственный список атомов без встроенных списков."

#: in/chapter10.md:634
msgid ""
"```lisp\n"
"(defun flatten (input)\n"
"  \"Return a flat list of the atoms in the input.\n"
"  Ex: (flatten '((a) (b (c) d))) => (a b c d).\"\n"
"  (cond ((null input) nil)\n"
"      ((atom input) (list input))\n"
"      (t (append (flatten (first input))\n"
"            (flatten (rest input))))))\n"
"```"
msgstr ""

#: in/chapter10.md:639
msgid ""
"This definition is quite simple, and it is easy to see that it is correct.\n"
"However, each call to `append` requires copying the first argument, so this "
"version can cons *O*(*n*2) cells on an input with *n* atoms.\n"
"The problem with this approach is that it computes the list of atoms in the "
"`first` and `rest` of each subcomponent of the input.\n"
"But the `first` sublist by itself is not part of the final answer-that's why "
"we have to call `append.` We could avoid generating garbage by replacing "
"`append` with `nconc,` but even then we would still be wasting time, because "
"`nconc` would have to scan through each sublist to find its end."
msgstr ""
"Это определение довольно простое, и нетрудно убедиться в его правильности.\n"
"Однако каждый вызов `append` требует копирования первого аргумента, поэтому "
"эта версия может cons(создавать) *O*(*n*2) ячеек при входе с *n* атомами.\n"
"Проблема с этим подходом заключается в том, что он вычисляет список атомов в "
"`first` и `rest` каждого подкомпонента ввода.\n"
"Но подсписок `first` сам по себе не является частью окончательного ответа, "
"поэтому мы должны вызвать `append`. Мы могли бы избежать генерации мусора, "
"заменив `append` на `nconc`, но даже тогда мы все равно будем терять "
"время. , потому что `nconc` придется сканировать каждый подсписок, чтобы "
"найти его конец."

#: in/chapter10.md:642
msgid ""
"The version below makes use of an *accumulator* to keep track of the atoms "
"that have been collected in the rest, and to add the atoms in the `first` "
"one at a time with cons, rather than building up unnecessary sublists and "
"appending them.\n"
"This way no garbage is generated, and no subcomponent is traversed more than "
"once."
msgstr ""
"В приведенной ниже версии используется *аккумулятор* для отслеживания "
"атомов, которые были собраны в rest, и для добавления атомов в `first` по "
"одному с помощью cons, вместо того, чтобы создавать ненужные подсписки и "
"добавлять их.\n"
"Таким образом, не создается мусор, и ни один из подкомпонентов не проходится "
"более одного раза."

#: in/chapter10.md:652
msgid ""
"```lisp\n"
"(defun flatten (input &optional accumulator)\n"
"  \"Return a flat list of the atoms in the input.\n"
"  Ex: (flatten '((a) (b (c) d))) => (a b c d).\"\n"
"  (cond ((null input) accumulator)\n"
"      ((atom input) (cons input accumulator))\n"
"      (t (flatten (first input)\n"
"            (flatten (rest input) accumulator)))))\n"
"```"
msgstr ""

#: in/chapter10.md:655
msgid ""
"The version with the accumulator may be a little harder to understand, but "
"it is far more efficient than the original version.\n"
"Experienced Lisp programmers become quite skilled at replacing calls to "
"`append` with accumulators."
msgstr ""
"Версия с аккумулятором может быть немного сложнее для понимания, но она "
"намного эффективнее оригинальной версии.\n"
"Опытные программисты на Лиспе достаточно хорошо умеют заменять вызовы "
"`append` на аккумуляторы."

#: in/chapter10.md:661
msgid ""
"Some of the early Lisp machines had unreliable garbage-collection, so users "
"just turned garbage collection off, used the machine for a few days, and "
"rebooted when they ran out of space.\n"
"With a large virtual memory system this is a feasible approach, because "
"virtual memory is a cheap resource.\n"
"The problem is that real memory is still an expensive resource.\n"
"When each page contains mostly garbage and only a little live data, the "
"system will spend a lot of time paging data in and out.\n"
"Compacting garbage-collection algorithms can relocate live data, packing it "
"into a minimum number of pages."
msgstr ""
"Некоторые из ранних машин Lisp имели ненадежную сборку мусора, поэтому "
"пользователи просто отключили сборку мусора, использовали машину в течение "
"нескольких дней и перезагружали, когда им не хватало места.\n"
"Для большой системы виртуальной памяти это осуществимый подход, потому что "
"виртуальная память - дешевый ресурс.\n"
"Проблема в том, что реальная память по-прежнему является дорогим ресурсом.\n"
"Когда каждая страница содержит в основном мусор и мало данных в реальном "
"времени, система будет тратить много времени на подкачку и выгрузку данных.\n"
"Алгоритмы сжатия мусора могут перемещать живые данные, упаковывая их на "
"минимальное количество страниц."

#: in/chapter10.md:668
msgid ""
"Some garbage-collection algorithms have been optimized to deal particularly "
"well with just this case.\n"
"If your system has an *ephemeral* or *generational* garbage collector, you "
"need not be so concerned with short-lived objects.\n"
"Instead, it will be the medium-aged objects that cause problems.\n"
"The other problem with such systems arises when an object in an old "
"generation is changed to point to an object in a newer generation.\n"
"This is to be avoided, and it may be that reverse is actually faster than "
"nreverse in such cases.\n"
"To decide what works best on your particular system, design some test cases "
"and time them."
msgstr ""
"Некоторые алгоритмы сборки мусора были оптимизированы, чтобы особенно хорошо "
"справляться именно с этим случаем.\n"
"Если в вашей системе есть *ephemeral* или *generational* сборщик мусора, вам "
"не нужно так беспокоиться о недолговечных объектах.\n"
"Вместо этого проблемы будут вызывать предметы среднего возраста.\n"
"Другая проблема с такими системами возникает, когда объект в старом "
"поколении изменяется, чтобы указывать на объект в новом поколении.\n"
"Этого следует избегать, и может оказаться, что в таких случаях reverse на "
"самом деле быстрее, чем nreverse.\n"
"Чтобы решить, что лучше всего работает в вашей конкретной системе, "
"разработайте несколько тестовых примеров и определите время их выполнения."

#: in/chapter10.md:674
msgid ""
"As an example of efficient use of storage, here is a version of `pat-match` "
"that eliminates (almost) all consing.\n"
"The original version of `pat-match,` as used in ELIZA ([page 180]"
"(B9780080571157500066.xhtml#p180)), used an association list of variable/"
"value pairs to represent the binding list.\n"
"This version uses two sequences: a sequence of variables and a sequence of "
"values.\n"
"The sequences are implemented as vectors instead of lists.\n"
"In general, vectors take half as much space as lists to store the same "
"information, since half of every list is just pointing to the next element."
msgstr ""
"В качестве примера эффективного использования хранилища приведем версию `pat-"
"match`, которая устраняет (почти) все consing.\n"
"В исходной версии `pat-match`, используемой в ELIZA ([страница 180]"
"(B9780080571157500066.xhtml#p180)), для представления списка привязки "
"использовался список ассоциаций пар переменная/значение.\n"
"В этой версии используются две последовательности: последовательность "
"переменных и последовательность значений.\n"
"Последовательности реализованы как векторы, а не списки.\n"
"Как правило, векторы занимают вдвое меньше места, чем списки, для хранения "
"той же информации, поскольку половина каждого списка просто указывает на "
"следующий элемент."

#: in/chapter10.md:681
msgid ""
"In this case, the savings are much more substantial than just half.\n"
"Instead of building up small binding lists for each partial match and adding "
"to them when the match is extended, we will allocate a sufficiently large "
"vector of variables and values just once, and use them over and over for "
"each partial match, and even for each invocation of `pat-match.` To do this, "
"we need to know how many variables we are currently using.\n"
"We could initialize a counter variable to zero and increment it each time we "
"found a new variable in the pattern.\n"
"The only difficulty would be when the counter variable exceeds the size of "
"the vector.\n"
"We could just give up and print an error message, but there are more user-"
"friendly alternatives.\n"
"For example, we could allocate a larger vector for the variables, copy over "
"the existing ones, and then add in the new one."
msgstr ""
"В этом случае экономия намного больше, чем половина.\n"
"Вместо того, чтобы создавать небольшие списки привязки для каждого "
"частичного совпадения и добавлять к ним, когда совпадение расширяется, мы "
"выделим достаточно большой вектор переменных и значений только один раз и "
"будем использовать их снова и снова для каждого частичного совпадения и даже "
"для каждого вызов `pat-match`. Для этого нам нужно знать, сколько переменных "
"мы в настоящее время используем.\n"
"Мы могли бы инициализировать счетчик переменных нулем и увеличивать его "
"каждый раз, когда мы находим новую переменную в образце.\n"
"Единственная трудность возникает, когда переменная счетчика превышает размер "
"вектора.\n"
"Мы могли бы просто отказаться и напечатать сообщение об ошибке, но есть "
"более удобные альтернативы.\n"
"Например, мы могли бы выделить больший вектор для переменных, скопировать "
"существующие, а затем добавить новый."

#: in/chapter10.md:690
msgid ""
"It turns out that Common Lisp has a built-in facility to do just this.\n"
"When a vector is created, it can be given a *fill pointer*.\n"
"This is a counter variable, but one that is conceptually stored inside the "
"vector.\n"
"Vectors with fill pointers act like a cross between a vector and a stack.\n"
"You can push new elements onto the stack with the functions `vector - push` "
"or `vector - push - extend`.\n"
"The latter will automatically allocate a larger vector and copy over "
"elements if necessary.\n"
"You can remove elements with `vector - pop`, or you can explicitly look at "
"the fill pointer with `fill - pointer`, or change it with a `setf`.\n"
"Here are some examples (with `*print-array*` set to t so we can see the "
"results):"
msgstr ""
"Когда вектор создан, ему может быть присвоен *указатель заполнения*/*fill "
"pointer*.\n"
"Это переменная счетчик, но она концептуально хранится внутри вектора.\n"
"Векторы с указателями заполнения действуют как нечто среднее между вектором "
"и стеком.\n"
"Вы можете помещать новые элементы в стек с помощью функций `vector-push` или "
"`vector-push-extend`.\n"
"Последний автоматически выделит больший вектор и при необходимости скопирует "
"элементы.\n"
"Вы можете удалить элементы с помощью `vector-pop`, или вы можете явно "
"посмотреть на указатель заполнения с помощью `fill-pointer`, или изменить "
"его с помощью `setf`.\n"
"Вот несколько примеров (с `*print-array*`, установленным в t, чтобы мы могли "
"видеть результаты):"

#: in/chapter10.md:692
msgid "`> (setf a (make-array 5 :fill-pointer 0))`=> `#()`"
msgstr ""

#: in/chapter10.md:694
msgid "`> (vector-push 1 a)`=> `0`"
msgstr ""

#: in/chapter10.md:696
msgid "`> (vector-push 2 a)`=> `1`"
msgstr ""

#: in/chapter10.md:698
msgid "`> a`=> `#(1 2)`"
msgstr ""

#: in/chapter10.md:700
msgid "`> (vector-pop a)`=> `2`"
msgstr ""

#: in/chapter10.md:702
msgctxt "in/chapter10.md:702"
msgid "`> a`=> `#(1)`"
msgstr ""

#: in/chapter10.md:704
msgid "`> (dotimes (i 10) (vector-push-extend 'x a))`=> `NIL`"
msgstr ""

#: in/chapter10.md:706
msgid "`> a`=> `#(1 XXXXXXXXXX)`"
msgstr ""

#: in/chapter10.md:708
msgid "`> (fill- pointer a)`=> `11`"
msgstr ""

#: in/chapter10.md:710
msgid "`> (setf (fill-pointer a) 1)`=> `1`"
msgstr ""

#: in/chapter10.md:712
msgctxt "in/chapter10.md:712"
msgid "`> a`=> `#(1)`"
msgstr ""

#: in/chapter10.md:714
msgid "`> (find 'x a)`=> `NIL NIL ;`*FIND can't find past the fill pointer*"
msgstr ""

#: in/chapter10.md:716
msgid "`> (aref a 2)`=> `X` ; *But AREF can see beyond the fill pointer*"
msgstr ""

#: in/chapter10.md:720
msgid ""
"Using vectors with fill pointers in `pat-match,` the total storage for "
"binding lists is just twice the number of variables in the largest pattern.\n"
"I have arbitrarily picked 10 as the maximum number of variables, but even "
"this is not a hard limit, because `vector-push-extend` can increase it.\n"
"In any case, the total storage is small, fixed in size, and amortized over "
"all calls to `pat-match.` These are just the features that indicate a "
"responsible use of storage."
msgstr ""
"При использовании векторов с указателями заполнения в `pat-match` общее "
"хранилище для списков привязки вдвое превышает количество переменных в самом "
"большом образце.\n"
"Я произвольно выбрал 10 в качестве максимального количества переменных, но "
"даже это не является жестким пределом, потому что `vector-push-extend` может "
"увеличить его.\n"
"В любом случае, общий объем хранилища невелик, фиксирован по размеру и "
"амортизируется по всем вызовам `pat-match`. Это только те функции, которые "
"указывают на ответственное использование хранилища."

#: in/chapter10.md:728
msgid ""
"However, there is a grave danger with this approach: the value returned must "
"be managed carefully.\n"
"The new `pat-match` returns the value of `success` when it matches.\n"
"`success` is bound to a cons of the variable and value vectors.\n"
"These can be freely manipulated by the calling routine, but only up until "
"the next call to `pat - match.` At that time, the contents of the two "
"vectors can change.\n"
"Therefore, if any calling function needs to hang on to the returned value "
"after another call to `pat-match,` it should make a copy of the returned "
"value.\n"
"So it is not quite right to say that this version of `pat-match` eliminates "
"all consing.\n"
"It will cons when `vector-push-extend` runs out of space, or when the user "
"needs to make a copy of a returned value."
msgstr ""
"Однако при таком подходе есть серьезная опасность: с возвращаемым значением "
"нужно обращаться осторожно.\n"
"Новый `pat-match` возвращает значение `success`, когда она находит "
"совпадение.\n"
"`success` связан с cons переменных и  векторов значений.\n"
"Вызывающая процедура может свободно ими манипулировать, но только до "
"следующего вызова `pat-match`. В это время содержимое двух векторов может "
"измениться.\n"
"Следовательно, если какой-либо вызывающей функции необходимо сохранить "
"возвращаемое значение после другого вызова `pat-match`, она должна сделать "
"копию возвращенного значения.\n"
"Так что было бы не совсем правильно говорить, что эта версия `pat-match` "
"устраняет все недоразумения.\n"
"Она будет работать, когда в `vector-push-extend` закончится место или когда "
"пользователю нужно сделать копию возвращенного значения."

#: in/chapter10.md:732
msgid ""
"Here is the new definition of `pat-match.` It is implemented by closing the "
"definition of `pat-match` and its two auxiliary functions inside a `let` "
"that establishes the bindings of `vars, vals`, and `success`, but that is "
"not crucial.\n"
"Those three variables could have been implemented as global variables "
"instead.\n"
"Note that it does not support segment variables, or any of the other options "
"implemented in the `pat-match` of [chapter 6](B9780080571157500066.xhtml)."
msgstr ""
"Вот новое определение `pat-match`. Оно реализовано путем закрытия "
"определения `pat-match` и двух его вспомогательных функций внутри `let`, "
"которое устанавливает привязки `vars, vals` и `success` , но это не "
"принципиально.\n"
"Вместо этого эти три переменные могли быть реализованы как глобальные "
"переменные.\n"
"Обратите внимание, что она не поддерживает сегментные переменные или какие-"
"либо другие опции, реализованные в `pat-match` [глава 6]"
"(B9780080571157500066.xhtml)."

#: in/chapter10.md:758
msgid ""
"```lisp\n"
"(let* ((vars (make-array 10 :fill-pointer 0 :adjustable t))\n"
"      (vals (make-array 10 :fill-pointer 0 :adjustable t))\n"
"      (success (cons vars vals)))\n"
"(defun efficient-pat-match (pattern input)\n"
"  \"Match pattern against input.\"\n"
"  (setf (fill-pointer vars) 0)\n"
"  (setf (fill-pointer vals) 0)\n"
"  (pat-match-1 pattern input))\n"
"(defun pat-match-1 (pattern input)\n"
"  (cond ((variable-p pattern) (match-var pattern input))\n"
"      ((eql pattern input) success)\n"
"      ((and (consp pattern) (consp input))\n"
"        (and (pat-match-1 (first pattern) (first input))\n"
"            (pat-match-1 (rest pattern) (rest input))))\n"
"      (t fail)))\n"
"(defun match-var (var input)\n"
"  \"Match a single variable against input.\"\n"
"  (let ((i (position var vars)))\n"
"    (cond ((null i)\n"
"          (vector-push-extend var vars)\n"
"          (vector-push-extend input vals) success)\n"
"      ((equal input (aref vals i)) success)\n"
"      (t fail)))))\n"
"```"
msgstr ""

#: in/chapter10.md:760
msgid "An example of its use:"
msgstr "Пример её использования:"

#: in/chapter10.md:766
msgid ""
"```lisp\n"
">(efficient-pat-match '(?x + ?x = ?y . ?z)\n"
"                '(2 + 2 = (3 + 1) is true))\n"
"(#(?X ?Y ?Z) . #(2 (3 + 1) (IS TRUE)))\n"
"```"
msgstr ""

#: in/chapter10.md:770
msgid ""
"Extensible vectors with fill pointers are convenient, and much more "
"efficient than consing up lists.\n"
"However, there is some overhead involved in using them, and for those "
"sections of code that must be most efficient, it is best to stick with "
"simple vectors.\n"
"The following version of `efficient-pat-match` explicitly manages the size "
"of the vectors and explicitly replaces them with new ones when the size is "
"exceeded:"
msgstr ""
"Расширяемые векторы с указателями заполнения удобны и намного более "
"эффективны, чем составление списков.\n"
"Однако их использование связано с некоторыми накладными расходами, и для тех "
"частей кода, которые должны быть наиболее эффективными, лучше всего "
"придерживаться простых векторов.\n"
"Следующая версия `effective-pat-match` явно управляет размером векторов и "
"явно заменяет их новыми, когда размер превышен:"

#: in/chapter10.md:799
msgid ""
"```lisp\n"
"(let* ((current-size 0)\n"
"      (max-size 1)\n"
"      (vars (make-array max-size))\n"
"      (vals (make-array max-size))\n"
"      (success (cons vars vals)))\n"
"  (declare (simple-vector vars vals)\n"
"          (fixnum current-size max-size))\n"
"(defun efficient-pat-match (pattern input)\n"
"  \"Match pattern against input.\"\n"
"  (setf current-size 0)\n"
"  (pat-match-1 pattern input))\n"
";; pat-match-1 is unchanged\n"
"(defun match-var (var input)\n"
"  \"Match a single variable against input.\"\n"
"  (let ((i (position var vars)))\n"
"    (cond\n"
"      ((null i)\n"
"        (when (= current-size max-size)\n"
"          ;; Make new vectors when we run out of space\n"
"          (setf max-size (* 2 max-size)\n"
"              vars (replace (make-array max-size) vars)\n"
"              vals (replace (make-array max-size) vals)\n"
"              success (cons vars vals)))\n"
"        ;; Store var and its value in vectors\n"
"        (setf (aref vars current-size) var)\n"
"        (setf (aref vals current-size) input)\n"
"```"
msgstr ""

#: in/chapter10.md:801
msgid "`        (incf current-size)``        success)`"
msgstr ""

#: in/chapter10.md:806
msgid ""
"```lisp\n"
"      ((equal input (aref vals i)) success)\n"
"      (t fail)))))\n"
"```"
msgstr ""

#: in/chapter10.md:810
msgid ""
"In conclusion, replacing lists with vectors can often save garbage.\n"
"But when you must use lists, it pays to use a version of cons that avoids "
"consing when possible.\n"
"The following is such a version:"
msgstr ""
"В заключение, замена списков векторами часто может сэкономить мусор.\n"
"Но когда вам необходимо использовать списки, стоит использовать такую версию "
"cons, которая по возможности избегает лишних конструирований.\n"
"Вот такая версия:"

#: in/chapter10.md:819
msgid ""
"```lisp\n"
"(proclaim '(inline reuse-cons))\n"
"(defun reuse-cons (x y x-y)\n"
"  \"Return (cons x y), or just x-y if it is equal to (cons x y).\"\n"
"  (if (and (eql x (car x-y)) (eql y (cdr x-y)))\n"
"      x-y\n"
"      (cons x y)))\n"
"```"
msgstr ""

#: in/chapter10.md:822
msgid ""
"The trick is based on the definition of subst in Steele's *Common Lisp the "
"Language*.\n"
"Here is a definition for a version of `remove` that uses `reuse-cons`:"
msgstr ""
"Уловка основана на определении subst в *Common Lisp the Language* Стила.\n"
"Вот определение версии `remove`, в которой используются `reuse-cons`:"

#: in/chapter10.md:832
msgid ""
"```lisp\n"
"(defun remq (item list)\n"
"  \"Like REMOVE, but uses EQ, and only works on lists.\"\n"
"  (cond ((null list) nil )\n"
"      ((eq item (first list)) (remq item (rest list)))\n"
"      (t (reuse-cons (first list)\n"
"                (remq item (rest list))\n"
"                list))))\n"
"```"
msgstr ""

#: in/chapter10.md:834
msgid "### Avoid Consing: Unique Lists"
msgstr "### Избегайте Consing(конструирования списков): уникальные списки"

#: in/chapter10.md:843
msgid ""
"Of course, `reuse-cons` only works when you have candidate cons cells "
"around.\n"
"That is, (`reuse-cons a b c`) only saves space when `c` is (or might be) "
"equal to (`cons a b`).\n"
"For some applications, it is useful to have a version of `cons` that returns "
"a unique cons cell without needing `c` as a hint.\n"
"We will call this version `ucons` for \"unique cons.\" `ucons` maintains a "
"double hash table: `*uniq - cons - table*` is a hash table whose keys are "
"the `cars` of cons cells.\n"
"The value for each `car` is another hash table whose keys are the `cdrs` of "
"cons cells.\n"
"The value of each `cdr` in this second table is the original cons cell.\n"
"So two different cons cells with the same `car` and `cdr` will retrieve the "
"same value.\n"
"Here is an implementation of `ucons`:"
msgstr ""
"Конечно, `reuse-cons` работает только тогда, когда у вас есть кандидаты на "
"cons-ячейки.\n"
"То есть (`reuse-cons a b c`) экономит место только тогда, когда `c` равно "
"(или может быть) равно (`cons a b`).\n"
"Для некоторых приложений полезно иметь версию `cons`, которая возвращает "
"уникальную cons-ячейку без необходимости использовать `c` в качестве "
"подсказки.\n"
"Мы будем называть эту версию `ucons` для `уникальных cons`. ucons "
"поддерживает двойную хеш-таблицу: `*uniq-cons-table*` - хеш-таблица, ключи "
"которой являются началом (`cars`) cons-ячеек.\n"
"Значение для каждого `car` - это другая хеш-таблица, ключи которой являются "
"концом(`cdrs`) cons-ячеек.\n"
"Значение каждого `cdr` во второй таблице - это исходная cons-ячейка.\n"
"Таким образом, две разные cons-ячейки с одинаковыми `car` и `cdr` получат "
"одно и то же значение.\n"
"Вот реализация `ucons`:"

#: in/chapter10.md:848
msgid ""
"```lisp\n"
"(defvar *uniq-cons-table* (make-hash-table :test #'eq))\n"
"(defun ucons (x y)\n"
"```"
msgstr ""

#: in/chapter10.md:851
msgid ""
"`  \"Return a cons s.t.\n"
"(eq (ucons x y) (ucons x y)) is true.\"`"
msgstr ""

#: in/chapter10.md:859
msgid ""
"```lisp\n"
"  (let ((car-table (or (gethash x *uniq-cons-table*)\n"
"                (setf (gethash x *uniq-cons-table*)\n"
"                    (make-hash-table :test #'eq)))))\n"
"    (or (gethash y car-table)\n"
"        (setf (gethash y car-table) (cons x y)))))\n"
"```"
msgstr ""

#: in/chapter10.md:867
msgid ""
"`ucons`, unlike `cons`, is a true function: it will always return the same "
"value, given the same arguments, where \"same\" is measured by eq.\n"
"However, if `ucons` is given arguments that are equal but not eq, it will "
"not return a unique result.\n"
"For that we need the function unique.\n"
"It has the property that `(unique x)` is eq to `(unique y)` whenever `x` and "
"`y` are equal.\n"
"`unique` uses a hash table for atoms in addition to the double hash table "
"for conses.\n"
"This is necessary because strings and arrays can be equal without being eq.\n"
"Besides `unique`, we also define `ulist` and uappend for convenience."
msgstr ""
"`ucons`, в отличие от `cons`, является истинной функцией: она всегда будет "
"возвращать одно и то же значение при тех же аргументах, где \"same/"
"тождественность\" измеряется с помощью eq.\n"
"Однако, если `ucons` заданы аргументы, которые равны, но не eq, она не "
"вернет уникальный результат.\n"
"Для этого нам понадобится функция unique.\n"
"Она обладает тем свойством, что `(unique x)` эквивалентен `(unique y)` "
"всякий раз, когда `x` и `y` равны(equal).\n"
"`unique` использует хеш-таблицу для атомов в дополнение к двойной хеш-"
"таблице для conses.\n"
"Это необходимо, потому что строки и массивы могут быть равны(equal), не "
"будучи eq.\n"
"Помимо `unique`, для удобства мы также определяем `ulist` и `uappend`."

#: in/chapter10.md:881
msgid ""
"```lisp\n"
"(defvar *uniq-atom-table* (make-hash-table :test #'equal))\n"
"  (defun unique (exp)\n"
"    \"Return a canonical representation that is EQUAL to exp,\n"
"    such that (equal x y) implies (eq (unique x) (unique y)).\"\n"
"    (typecase exp\n"
"      (symbol exp)\n"
"      (fixnum exp) ;; Remove if fixnums are not eq in your Lisp\n"
"      (atom (or (gethash exp *uniq-atom-table*)\n"
"                (setf (gethash exp *uniq-atom-table*) exp)))\n"
"      (cons (unique-cons (car exp) (cdr exp)))))\n"
"  (defun unique-cons (x y)\n"
"```"
msgstr ""

#: in/chapter10.md:884
msgid ""
"`    \"Return a cons s.t.\n"
"(eq (ucons x y) (ucons x2 y2)) is true`"
msgstr ""

#: in/chapter10.md:897
msgid ""
"```lisp\n"
"    whenever (equal x x2) and (equal y y2) are true.\"\n"
"    (ucons (unique x) (unique y)))\n"
"  (defun ulist (&rest args)\n"
"    \"A uni qui fied list.\"\n"
"    (unique args))\n"
"  (defun uappend (x y)\n"
"    \"A unique list equal to (append x y).\"\n"
"    (if (null x)\n"
"        (unique y)\n"
"        (ucons (first x) (uappend (rest x) y))))\n"
"```"
msgstr ""

#: in/chapter10.md:902
msgid ""
"The above code works, but it can be improved.\n"
"The problem is that when `unique` is applied to a tree, it always traverses "
"the tree all the way to the leaves.\n"
"The function `unique-cons` is like `ucons,` except that `unique-cons` "
"assumes its arguments are not yet unique.\n"
"We can modify `unique - cons` so that it first checks to see if its "
"arguments are unique, by looking in the appropriate hash tables:"
msgstr ""
"Приведенный выше код работает, но его можно улучшить.\n"
"Проблема в том, что когда к дереву применяется `unique`, она всегда проходит "
"по дереву вплоть до листьев.\n"
"Функция `unique-cons` похожа на `ucons`, за исключением того, что `unique-"
"cons` предполагает, что ее аргументы еще не уникальны.\n"
"Мы можем изменить `unique-cons`, чтобы она сначала проверяла, уникальны ли "
"её аргументы, просматривая соответствующие хэш-таблицы:"

#: in/chapter10.md:906
msgid ""
"```lisp\n"
"(defun unique-cons (x y)\n"
"```"
msgstr ""

#: in/chapter10.md:909
msgid ""
"`  \"Return a cons s.t.\n"
"(eq (ucons x y) (ucons x2 y2)) is true`"
msgstr ""

#: in/chapter10.md:923
msgid ""
"```lisp\n"
"  whenever (equal x x2) and (equal y y2) are true.\"\n"
"  (let ((ux) (uy)) ; unique x and y\n"
"    (let ((car-table\n"
"          (or (gethash x *uniq-cons-table*)\n"
"            (gethash (setf ux (unique x)) *uniq-cons-table*)\n"
"            (setf (gethash ux *uniq-cons-table*)\n"
"                (make-hash-table :test #'eq)))))\n"
"      (or (gethash y car-table)\n"
"        (gethash (setf uy (unique y)) car-table)\n"
"        (setf (gethash uy car-table)\n"
"            (cons ux uy))))))\n"
"```"
msgstr ""

#: in/chapter10.md:928
msgid ""
"Another advantage of `unique` is that it can help in indexing.\n"
"If lists are unique, then they can be stored in an `eq` hash table instead "
"of a equal hash table.\n"
"This can lead to significant savings when the list structures are large.\n"
"An `eq` hash table for lists is almost as good as a property list on symbols."
msgstr ""
"Еще одним преимуществом `unique` является то, что она помогает при "
"индексации.\n"
"Если списки уникальны, то они могут храниться в хэш-таблице `eq` вместо "
"`equal` хэш-таблице.\n"
"Это может привести к значительной экономии при больших размерах списков.\n"
"Хеш-таблица `eq` для списков почти так же хороша, как список свойств для "
"символов."

#: in/chapter10.md:930
msgid "### Avoid Consing: Multiple Values"
msgstr "### Избегайте Consing: Множественные Значения"

#: in/chapter10.md:933
msgid ""
"Parameters and multiple values can also be used to pass around values, "
"rather than building up lists.\n"
"For example, instead of :"
msgstr ""
"Параметры и несколько значений также можно использовать для передачи "
"значений, а не для создания списков.\n"
"Например, вместо:"

#: in/chapter10.md:942
msgid ""
"```lisp\n"
"(defstruct point \"A point in 3-D cartesian space.\" x y z)\n"
"(defun scale-point (k  pt)\n"
"  \"Multiply a point by a constant, K.\"\n"
"  (make-point :x (* k (point-x pt))\n"
"                  :y (* k (point-y pt))\n"
"                  :z (* k (point-z pt))))\n"
"```"
msgstr ""

#: in/chapter10.md:944
msgid ""
"one could use the following approach, which doesn't generate structures:"
msgstr "можно использовать следующий подход, который не генерирует структуры:"

#: in/chapter10.md:950
msgid ""
"```lisp\n"
"(defun scale-point (k x y z)\n"
"  \"Multiply the point (x,y,z) by a constant, K.\"\n"
"  (values (* k x) (* k y) (* k z)))\n"
"```"
msgstr ""

#: in/chapter10.md:952
msgid "### Avoid Consing: Resources"
msgstr "### Избегайте Consing: ресурсы"

#: in/chapter10.md:959
msgid ""
"Sometimes it pays to manage explicitly the storage of instances of some data "
"type.\n"
"A pool of these instances may be called a *resource*.\n"
"Explicit management of a resource is appropriate when: (1) instances are "
"frequently created, and are needed only temporarily; (2) it is easy/possible "
"to be sure when instances are no longer needed; and (3) instances are fairly "
"large structures or take a long time to initialize, so that it is worth "
"reusing them instead of creating new ones.\n"
"Condition (2) is the crucial one: If you deallocate an instance that is "
"still being used, that instance will mysteriously be altered when it is "
"reallocated.\n"
"Conversely, if you fail to deallocate unneeded instances, then you are "
"wasting valuable memory space.\n"
"(The memory management scheme is said to leak in this case.)"
msgstr ""
"Иногда имеет смысл явно управлять хранением экземпляров некоторого типа "
"данных.\n"
"Пул этих экземпляров можно назвать *resource*.\n"
"Явное управление ресурсом целесообразно, когда: (1) экземпляры создаются "
"часто и нужны только временно; (2) легко(или просто возможно) убедиться, "
"когда экземпляры больше не нужны; и (3) экземпляры представляют собой "
"довольно большие структуры или для их инициализации требуется много времени, "
"поэтому стоит использовать их повторно вместо создания новых.\n"
"Условие (2) является ключевым: если вы освободите экземпляр, который все еще "
"используется, этот экземпляр будет таинственным образом изменен, когда он "
"будет перераспределен.\n"
"И наоборот, если вам не удается освободить ненужные экземпляры, вы тратите "
"ценное пространство памяти.\n"
"(В этом случае считается, что схема управления памятью дает утечку.)"

#: in/chapter10.md:966
msgid ""
"The beauty of using Lisp's built-in memory management is that it is "
"guaranteed never to leak and never to deallocate structures that are in "
"use.\n"
"This eliminates two potential bug sources.\n"
"The penalty you pay for this guarantee is some inefficiency of the general-"
"purpose memory management as compared to a custom user-supplied management "
"scheme.\n"
"But beware: modern garbage-collection techniques are highly optimized.\n"
"In particular, the so-called *generation scavenging* or *ephemeral* garbage "
"collectors look more often at recently allocated storage, on the grounds "
"that recently made objects are more likely to become garbage.\n"
"If you hold on to garbage in your own data structures, you may end up with "
"worse performance."
msgstr ""
"Прелесть использования встроенного в Lisp управления памятью заключается в "
"том, что в нем никогда не будет утечки и никогда не освободит используемые "
"структуры.\n"
"Это устраняет два потенциальных источника ошибок.\n"
"Штраф, который вы платите за эту гарантию, заключается в некоторой "
"неэффективности общего управления памятью по сравнению с настраиваемой "
"схемой управления, предоставляемой пользователем.\n"
"Но будьте осторожны: современные методы сборки мусора сильно "
"оптимизированы.\n"
"В частности, так называемые *сборщики мусора* *generation scavenging* или "
"*ephemeral* чаще обращаются к недавно выделенному хранилищу на том "
"основании, что недавно созданные объекты с большей вероятностью станут "
"мусором.\n"
"Если вы храните мусор в своих собственных структурах данных, "
"производительность может снизиться."

#: in/chapter10.md:968
msgid "With all these warnings in mind, here is some code to manage resources:"
msgstr "Имея в виду все эти предупреждения, вот код для управления ресурсами:"

#: in/chapter10.md:990
msgid ""
"```lisp\n"
"(defmacro defresource (name &key constructor (initial-copies 0)\n"
"                       (size (max initial-copies 10)))\n"
"  (let ((resource (symbol '* (symbol name '-resource*)))\n"
"        (deallocate (symbol 'deallocate- name))\n"
"        (allocate (symbol 'allocate- name)))\n"
"    `(progn\n"
"       (defparameter ,resource (make-array ,size :fill-pointer 0))\n"
"       (defun ,allocate ()\n"
"         \"Get an element from the resource pool, or make one.\"\n"
"         (if (= (fill-pointer ,resource) 0)\n"
"             ,constructor\n"
"             (vector-pop ,resource)))\n"
"       (defun ,deallocate (,name)\n"
"         \"Place a no-longer-needed element back in the pool.\"\n"
"         (vector-push-extend ,name ,resource))\n"
"       ,(if (> initial-copies 0)\n"
"            `(mapc #',deallocate (loop repeat ,initial-copies\n"
"                                       collect (,allocate))))\n"
"       ',name)))\n"
"```"
msgstr ""

#: in/chapter10.md:994
msgid ""
"Let's say we had some structure called a buffer which we were constantly "
"making instances of and then discarding.\n"
"Furthermore, suppose that buffers are fairly complex objects to build, that "
"we know we'll need at least 10 of them at a time, and that we probably won't "
"ever need more than 100 at a time.\n"
"We might use the buffer resource as follows:"
msgstr ""
"Допустим, у нас есть некоторая структура, называемая буфером, которую мы "
"постоянно создавали, а затем отбрасывали.\n"
"Более того, предположим, что буферы - это довольно сложные объекты для "
"создания, что мы знаем, что нам понадобится по крайней мере 10 из них за "
"раз, и что нам, вероятно, никогда не понадобится больше 100 за раз.\n"
"Мы можем использовать буферный ресурс следующим образом:"

#: in/chapter10.md:999
msgid ""
"```lisp\n"
"(defresource buffer :constructor (make-buffer)\n"
"            :size 100 : initial-copies 10)\n"
"```"
msgstr ""

#: in/chapter10.md:1001
msgid "This expands into the following code:"
msgstr "Это расширяется до следующего кода:"

#: in/chapter10.md:1016
msgid ""
"```lisp\n"
"(let ((buffer-resource (make-array 100 :fill-pointer 0)))\n"
"  (defun allocate-buffer ()\n"
"    \"Get an element from the resource pool, or make one.\"\n"
"    (if (= (fill-pointer buffer-resource) 0)\n"
"      (make-buffer)\n"
"      (vector-pop buffer-resource)))\n"
"  (defun deallocate-buffer (buffer)\n"
"    \"Place a no-longer-needed element back in the pool.\"\n"
"    (vector-push-extend buffer buffer-resource))\n"
"  (mapc #'deallocate-buffer\n"
"        (loop repeat 10 collect (allocate-buffer)))\n"
"  'buffer)\n"
"```"
msgstr ""

#: in/chapter10.md:1018
msgid "We could then use:"
msgstr "Затем мы могли бы использовать:"

#: in/chapter10.md:1026
msgid ""
"```lisp\n"
"(let ((b (allocate-buffer)))\n"
"  ...\n"
"  (process b)\n"
"  ...\n"
"  (deallocate-buffer b)))\n"
"```"
msgstr ""

#: in/chapter10.md:1031
msgid ""
"The important thing to remember is that this works only if the buffer `b` "
"really can be deallocated.\n"
"If the function `process` stored away a pointer to `b` somewhere, then it "
"would be a mistake to deallocate `b,` because a subsequent allocation could "
"unpredictably alter the stored buffer.\n"
"Of course, if `process` stored a *copy* of `b,` then everything is alright.\n"
"This pattern of allocation and deallocation is so common that we can provide "
"a macro for it:"
msgstr ""
"Важно помнить, что это работает, только если буфер `b` действительно может "
"быть освобожден.\n"
"Если функция `process` где-то хранит указатель на `b`, то было бы ошибкой "
"освобождать `b`, потому что последующее выделение может непредсказуемо "
"изменить сохраненный буфер.\n"
"Конечно, если процесс сохранил *копию* `b`, то все в порядке.\n"
"Этот шаблон распределения и освобождения настолько распространен, что мы "
"можем предоставить для него макрос:"

#: in/chapter10.md:1045
msgid ""
"```lisp\n"
"defmacro with-resource ((var resource &optional protect) &rest body)\n"
"  \"Execute body with VAR bound to an instance of RESOURCE.\"\n"
"  (let ((allocate (symbol 'allocate- resource))\n"
"        (deallocate (symbol 'deallocate- resource)))\n"
"    (if protect\n"
"        `(let ((,var nil))\n"
"           (unwind-protect (progn (setf ,var (,allocate)) ,@body)\n"
"             (unless (null ,var) (,deallocate ,var))))\n"
"        `(let ((,var (,allocate)))\n"
"           ,@body\n"
"           (,deallocate var)))))\n"
"```"
msgstr ""

#: in/chapter10.md:1048
msgid ""
"The macro allows for an optional argument that sets up an `unwind` - protect "
"environment, so that the buffer gets deallocated even when the body is "
"abnormally exited.\n"
"The following expansions should make this clearer:"
msgstr ""
"Макрос позволяет использовать необязательный аргумент, который устанавливает "
"среду защиты `unwind`-protect, так что буфер освобождается даже при "
"аварийном выходе из тела.\n"
"Следующие расширения должны прояснить это:"

#: in/chapter10.md:1068
msgid ""
"```lisp\n"
">(macroexpand '(with-resource (b buffer)\n"
"                \"...\" (process b) \"...\"))\n"
"(let ((b (allocate-buffer)))\n"
"  \"...\"\n"
"  (process b)\n"
"  \"...\"\n"
"  (deallocate-buffer b))\n"
"> (macroexpand '(with-resource (b buffer t)\n"
"                \"...\" \"...\" (process b) \"...\"))\n"
"(let ((b nil))\n"
"  (unwind-protect\n"
"      (progn (setf b (allocate-buffer))\n"
"          \"...\"\n"
"                (process b)\n"
"                \"...\")\n"
"            (unless (null b)\n"
"            (deallocate-buffer b))))\n"
"```"
msgstr ""

#: in/chapter10.md:1071
msgid ""
"An alternative to full resources is to just save a single data object.\n"
"Such an approach is simpler because there is no need to index into a vector "
"of objects, but it is sufficient for some applications, such as a tail-"
"recursive function call that only uses one object at a time."
msgstr ""
"Альтернативой полным ресурсам является сохранение одного объекта данных.\n"
"Такой подход проще, потому что нет необходимости индексировать вектор "
"объектов, но его достаточно для некоторых приложений, таких как хвостовой "
"рекурсивный вызов функции, которая использует только один объект за раз."

#: in/chapter10.md:1073
msgid ""
"Another possibility is to make the system slower but safer by having the "
"`deallocate` function check that its argument is indeed an object of the "
"correct type."
msgstr ""
"Другая возможность - сделать систему медленнее, но безопаснее, заставив "
"функцию `deallocate` проверять, действительно ли ее аргумент является "
"объектом правильного типа."

#: in/chapter10.md:1078
msgid ""
"Keep in mind that using resources may put you at odds with the Lisp system's "
"own storage management scheme.\n"
"In particular, you should be concerned with paging performance on virtual "
"memory systems.\n"
"A common problem is to have only a few live objects on each page, thus "
"forcing the system to do a lot of paging to get any work done.\n"
"Compacting garbage collectors can collect live objects onto the same page, "
"but using resources may interfere with this."
msgstr ""
"Имейте в виду, что использование ресурсов может поставить вас в противоречие "
"со схемой управления хранилищем системы Lisp.\n"
"В частности, вы должны быть обеспокоены производительностью подкачки в "
"системах виртуальной памяти.\n"
"Распространенная проблема - иметь только несколько живых объектов на каждой "
"странице, что заставляет систему выполнять много страниц для выполнения "
"любой работы.\n"
"Компактные сборщики мусора могут собирать живые объекты на одной странице, "
"но использование ресурсов может этому помешать."

#: in/chapter10.md:1080
msgid "## 10.5 Use the Right Data Structures"
msgstr "## 10.5 Используйте правильные структуры данных"

#: in/chapter10.md:1084
msgid ""
"It is important to implement key data types with the most efficient "
"implementation.\n"
"This can vary from machine to machine, but there are a few techniques that "
"are universal.\n"
"Here we consider three case studies."
msgstr ""
"Важно реализовать ключевые типы данных с наиболее эффективной реализацией.\n"
"Это может варьироваться от машины к машине, но есть несколько универсальных "
"методов.\n"
"Здесь мы рассматриваем три тематических исследования."

#: in/chapter10.md:1086
msgid "### The Right Data Structure: Variables"
msgstr "### Правильная структура данных: переменные"

#: in/chapter10.md:1092
msgid ""
"As an example, consider the implementation of pattern-matching variables.\n"
"We saw from the instrumentation of `simplify` that `variable-p` was one of "
"the most frequently used functions.\n"
"In compiling the matching expressions, I did away with all calls to "
"`variable-p`, but let's suppose we had an application that required run-time "
"use of variables.\n"
"The specification of the data type `variable` will include two operators, "
"the recognizer `variable-p`, and the constructor `make-variable`, which "
"gives a new, previously unused variable.\n"
"(This was not needed in the pattern matchers shown so far, but will be "
"needed for unification with backward chaining.) One implementation of "
"variables is as symbols that begin with the character #\\?:"
msgstr ""
"В качестве примера рассмотрим реализацию переменных сопоставления с "
"образцом.\n"
"Мы видели из инструментария `simplify`, что `variable-p` была одной из "
"наиболее часто используемых функций.\n"
"При компиляции соответствующих выражений я отказался от всех вызовов "
"`variable-p`, но предположим, что у нас есть приложение, которое требует "
"использования переменных во время выполнения.\n"
"Спецификация типа данных `variable` будет включать два оператора, "
"распознаватель `variable-p` и конструктор `make-variable`, который дает "
"новую, ранее не использовавшуюся переменную.\n"
"(Это не было необходимо в схемах сопоставления, показанных до сих пор, но "
"потребуется для унификации(объединения) с обратной цепочкой.) Одна "
"реализация переменных - это символы, начинающиеся со знака #\\?:"

#: in/chapter10.md:1099
msgid ""
"```lisp\n"
"(defun variable-p (x)\n"
"  \"Is x a variable (a symbol beginning with '?')?\"\n"
"  (and (symbolp x) (equal (elt (symbol-name x) 0) #\\?)))\n"
"(defun make-variable O \"Generate a new variable\" (gentemp \"?\"))\n"
"```"
msgstr ""

#: in/chapter10.md:1101
msgid ""
"We could try to speed things up by changing the implementation of variables "
"to be keywords and making the functions inline:"
msgstr ""
"Мы могли бы попытаться ускорить процесс, изменив реализацию переменных как "
"ключевых слов и сделав функции встраиваемыми(inline):"

#: in/chapter10.md:1107
msgid ""
"```lisp\n"
"(proclaim '(inline variable-p make-variable))\n"
"(defun variable-p (x) \"Is x a variable?\" (keywordp x))\n"
"(defun make-variable O (gentemp \"X\" #.(find-package \"KEYWORD\")))\n"
"```"
msgstr ""

#: in/chapter10.md:1112
msgid ""
"(The reader character sequence #.\n"
"means to evaluate at read time, rather than at execution time.) On my "
"machine, this implementation is pretty fast, and I accepted it as a viable "
"compromise.\n"
"However, other implementations were also considered.\n"
"One was to have variables as structures, and provide a read macro and print "
"function:"
msgstr ""
"(Последовательность символьных знаков функции чтения ввода(reader) #.\n"
"означает вычислить во время чтения, а не во время выполнения.) На моей "
"машине эта реализация выполняется довольно быстро, и я принял ее как "
"жизнеспособный компромис.\n"
"Однако были рассмотрены и другие реализации.\n"
"Одна заключался в том, чтобы иметь переменные как структуры и предоставлять "
"макрос чтения и функцию печати:"

#: in/chapter10.md:1127
msgid ""
"```lisp\n"
"(defstruct (variable (:print-function print-variable)) name)\n"
"(defvar *vars* (make-hash-table))\n"
"(set-macro-character #\\?\n"
"  #'(lambda (stream char)\n"
"      ;; Find an old var, or make a new one with the given name\n"
"      (declare (ignore char))\n"
"      (let ((name (read stream t nil t)))\n"
"        (or (gethash name *vars*)\n"
"          (setf (gethash name *vars*) (make-variable :name name))))))\n"
"(defun print-variable (var stream depth)\n"
"  (declare (ignore depth))\n"
"  (format stream \"?~a\" (var-name var)))\n"
"```"
msgstr ""

#: in/chapter10.md:1134
msgid ""
"It turned out that, on all three Lisps tested, structures were slower than "
"keywords or symbols.\n"
"Another alternative is to have the ? read macro return a cons whose first "
"is, say, `:var`.\n"
"This requires a special output routine to translate back to the ? notation.\n"
"Yet another alternative, which turned out to be the fastest of all, was to "
"implement variables as negative integers.\n"
"Of course, this means that the user cannot use negative integers elsewhere "
"in patterns, but that turned out to be acceptable for the application at "
"hand.\n"
"The moral is to know which features are done well in your particular "
"implementation and to go out of your way to use them in critical situations, "
"but to stick with the most straightforward implementation in noncritical "
"sections."
msgstr ""
"Оказалось, что на всех трех протестированных Лиспах структуры были "
"медленнее, чем ключевые слова или символы.\n"
"Другая альтернатива - иметь ? макрос чтения возвращающий cons(пару), первым "
"элементом в которой является, скажем, `:var`.\n"
"Для этого требуется специальная процедура вывода, чтобы преобразовать "
"обратно в обозначение ? .\n"
"Еще одна альтернатива, которая оказалась самой быстрой из всех, заключалась "
"в реализации переменных как отрицательных целых чисел.\n"
"Конечно, это означает, что пользователь не может использовать отрицательные "
"целые числа где-либо еще в образцах, но это оказалось приемлемым для данного "
"приложения.\n"
"Мораль заключается в том, чтобы знать, какие функции хорошо реализованы в "
"вашей конкретной реализации, и стараться изо всех сил использовать их в "
"критических ситуациях, но придерживаться наиболее простой реализации в "
"некритических разделах."

#: in/chapter10.md:1140
msgid ""
"Lisp makes it easy to rely on lists, but one must avoid the temptation to "
"overuse lists; to use them where another data structure is more "
"appropriate.\n"
"For example, if you need to access elements of a sequence in arbitrary "
"order, then a vector is more appropriate than list.\n"
"If the sequence can grow, use an adjustable vector.\n"
"Consider the problem of maintaining information about a set of people, and "
"searching that set.\n"
"A naive implementation might look like this:"
msgstr ""
"Lisp позволяет легко полагаться на списки, но следует избегать соблазна "
"злоупотреблять списками; использовать их там, где более уместна другая "
"структура данных.\n"
"Например, если вам нужно получить доступ к элементам последовательности в "
"произвольном порядке, то вектор более уместен, чем список.\n"
"Если последовательность может расти, используйте регулируемый "
"вектор(adjustable vector).\n"
"Рассмотрим проблему сохранения информации о группе(множестве) людей и поиск "
"этой группы.\n"
"Наивная реализация может выглядеть так:"

#: in/chapter10.md:1147
msgid ""
"```lisp\n"
"(defvar *people* nil \"Will hold a list of people\")\n"
"(defstruct person name address id-number)\n"
"(defun person-with-id (id)\n"
"  (find id *people* :key #'person-id-number))\n"
"```"
msgstr ""

#: in/chapter10.md:1150
msgid ""
"In a traditional language like C, the natural solution is to include in the "
"person structure a pointer to the next person, and to write a loop to follow "
"these pointers.\n"
"Of course, we can do that in Lisp too:"
msgstr ""
"В традиционном языке, таком как C, естественным решением является включение "
"в структуру человека(person) указателя на следующего человека и создание "
"цикла для отслеживания этих указателей.\n"
"Конечно, мы можем сделать это и в Лиспе:"

#: in/chapter10.md:1159
msgid ""
"```lisp\n"
"(defstruct person name address id-number next)\n"
"(defun person-with-id (id)\n"
"  (loop for person = *people* then (person-next person)\n"
"      until (null person)\n"
"      do (when (eql id (person-id-number person))\n"
"          (RETURN person))))\n"
"```"
msgstr ""

#: in/chapter10.md:1163
msgid ""
"This solution takes less space and is probably faster, because it requires "
"less memory accesses: one for each person rather than one for each person "
"plus one for each cons cell.\n"
"So there is a small price to pay for using lists.\n"
"But Lisp programmers feel that price is worth it, because of the convenience "
"and ease of coding and debugging afforded by general-purpose functions like "
"`find`."
msgstr ""
"Это решение занимает меньше места и, вероятно, работает быстрее, поскольку "
"требует меньшего количества обращений к памяти: по одному для каждого "
"человека, а не по одному для каждого человека плюс один для каждой cons-"
"ячейки.\n"
"Так что за использование списков приходится платить небольшую цену.\n"
"Но программисты на Лиспе считают, что цена того стоит из-за удобства и "
"простоты кодирования и отладки, обеспечиваемых функциями общего назначения, "
"такими как `find`."

#: in/chapter10.md:1166
msgid ""
"In any case, if there are going to be a large number of people, the list is "
"definitely the wrong data structure.\n"
"Fortunately, Lisp makes it easy to switch to more efficient data structures, "
"for example:"
msgstr ""
"В любом случае, если будет много людей, список определенно неправильная "
"структура данных.\n"
"К счастью, Lisp позволяет легко переключиться на более эффективные структуры "
"данных, например:"

#: in/chapter10.md:1171
msgid ""
"```lisp\n"
"(defun person-with-id (id)\n"
"  (gethash id *people*))\n"
"```"
msgstr ""

#: in/chapter10.md:1173
msgid "### The Right Data Structure: Queues"
msgstr "### Правильная структура данных: очереди"

#: in/chapter10.md:1176
msgid ""
"A *queue* is a data structure where one can add elements at the rear and "
"remove them from the front.\n"
"This is almost like a stack, except that in a stack, elements are both added "
"and removed at the same end."
msgstr ""
"Очередь(*queue*) - это структура данных, в которую можно добавлять элементы "
"сзади и удалять их спереди.\n"
"Это почти как стек, за исключением того, что в стеке элементы добавляются и "
"удаляются с одного конца."

#: in/chapter10.md:1179
msgid ""
"Lists can be used to implement stacks, but there is a problem in using lists "
"to implement queues: adding an element to the rear requires traversing the "
"entire list.\n"
"So collecting *n* elements would be *O*(*n2*) instead of *O*(*n*)."
msgstr ""
"Списки можно использовать для реализации стеков, но существует проблема с "
"использованием списков для реализации очередей: добавление элемента в конец "
"требует обхода всего списка.\n"
"Таким образом, сбор *n* элементов будет *O*(*n2*) вместо *O*(*n*)."

#: in/chapter10.md:1183
msgid ""
"An alternative implementation of queues is as a cons of two pointers: one to "
"the list of elements of the queue (the contents), and one to the last cons "
"cell in the list.\n"
"Initially, both pointers would be nil.\n"
"This implementation in fact existed in BBN Lisp and UCI Lisp under the "
"function name `tconc`:"
msgstr ""
"Альтернативная реализация очередей - это cons(пара) двух указателей: один на "
"список элементов очереди (содержимое) и один на последнюю cons-ячейку в "
"списке.\n"
"Первоначально оба указателя были бы nil.\n"
"Эта реализация фактически существовала в BBN Lisp и UCI Lisp под именем "
"функции `tconc`:"

#: in/chapter10.md:1194
msgid ""
"```lisp\n"
";;; A queue is a (contents . last) pair\n"
"(defun tconc (item q)\n"
"  \"Insert item at the end of the queue.\"\n"
"  (setf (cdr q)\n"
"      (if (null (cdr q))\n"
"          (setf (car q) (cons item nil))\n"
"          (setf (rest (cdr q))\n"
"              (cons item nil)))))\n"
"```"
msgstr ""

#: in/chapter10.md:1201
msgid ""
"The `tconc` implementation has the disadvantage that adding the first "
"element to the contents is different from adding subsequent elements, so an "
"`if` statement is required to decide which action to take.\n"
"The definition of queues given below avoids this disadvantage with a clever "
"trick.\n"
"First, the order of the two fields is reversed.\n"
"The `car` of the cons cell is the last element, and the `cdr` is the "
"contents.\n"
"Second, the empty queue is a cons cell where the `cdr` (the contents field) "
"is nil, and the `car` (the last field) is the cons itself.\n"
"In the definitions below, we change the name `tconc` to the more standard "
"`enqueue`, and provide the other queue functions as well:"
msgstr ""
"Реализация `tconc` имеет тот недостаток, что добавление первого элемента к "
"содержимому отличается от добавления последующих элементов, поэтому для "
"решения, какое действие следует предпринять, требуется оператор `if`.\n"
"Приведенное ниже определение очередей позволяет избежать этого недостатка "
"хитрым приемом.\n"
"Во-первых, порядок двух полей меняется на обратный(reversed).\n"
"`car` cons-ячейки - это последний элемент, а `cdr` - это содержимое.\n"
"Во-вторых, пустая очередь - это cons-ячейка, где `cdr` (поле содержимого) "
"равно nil, а `car` (указывающий на последнее поле) - это сама cons-"
"ячейка(указывает на себя).\n"
"В определениях ниже мы меняем имя `tconc` на более стандартное `enqueue`, а "
"также предоставляем другие функции очереди:"

#: in/chapter10.md:1206
msgid ""
"```lisp\n"
";;; A queue is a (last . contents) pair\n"
"(proclaim '(inline queue-contents make-queue enqueue dequeue\n"
"                front empty-queue-p queue-nconc))"
msgstr ""

#: in/chapter10.md:1208
msgid "(defun queue-contents (q) (cdr q))"
msgstr ""

#: in/chapter10.md:1213
msgid ""
"(defun make-queue ()\n"
"  \"Build a new queue, with no elements.\"\n"
"  (let ((q (cons nil nil)))\n"
"    (setf (car q) q)))"
msgstr ""

#: in/chapter10.md:1220
msgid ""
"(defun enqueue (item q)\n"
"  \"Insert item at the end of the queue.\"\n"
"  (setf (car q)\n"
"        (setf (rest (car q))\n"
"              (cons item nil)))\n"
"  q)"
msgstr ""

#: in/chapter10.md:1226
msgid ""
"(defun dequeue (q)\n"
"  \"Remove an item from the front of the queue.\"\n"
"  (pop (cdr q))\n"
"  (if (null (cdr q)) (setf (car q) q))\n"
"  q)"
msgstr ""

#: in/chapter10.md:1228
msgid "(defun front (q) (first (queue-contents q)))"
msgstr ""

#: in/chapter10.md:1230
msgid "(defun empty-queue-p (q) (null (queue-contents q)))"
msgstr ""

#: in/chapter10.md:1236
msgid ""
"(defun queue-nconc (q list)\n"
"  \"Add the elements of LIST to the end of the queue.\"\n"
"  (setf (car q)\n"
"        (last (setf (rest (car q)) list))))\n"
"```"
msgstr ""

#: in/chapter10.md:1238
msgid "### The Right Data Structure: Tables"
msgstr "### Правильная структура данных: таблицы"

#: in/chapter10.md:1241
msgid ""
"A *table* is a data structure to which one can insert a key and associate it "
"with a value, and later use the key to look up the value.\n"
"Tables may have other operations, like counting the number of keys, clearing "
"out all keys, or mapping a function over each key/value pair."
msgstr ""
"*Таблица*(table) - это структура данных, в которую можно вставить ключ и "
"связать его со значением, а затем использовать ключ для поиска значения.\n"
"Таблицы могут выполнять другие операции, такие как подсчет количества "
"ключей, очистка всех ключей или отображение функции для каждой пары ключ/"
"значение."

#: in/chapter10.md:1248
msgid ""
"Lisp provides a wide variety of choices to implement tables.\n"
"An association list is perhaps the simplest: it is just a list of key/value "
"pairs.\n"
"It is appropriate for small tables, up to a few dozen pairs.\n"
"The hash table is designed to be efficient for large tables, but may have "
"significant overhead for small ones.\n"
"If the keys are symbols, property lists can be used.\n"
"If the keys are integers in a narrow range (or can be mapped into them), "
"then a vector may be the most efficient choice."
msgstr ""
"Lisp предоставляет широкий выбор вариантов реализации таблиц.\n"
"Список ассоциаций, пожалуй, самый простой: это просто список пар ключ/"
"значение(alists).\n"
"Подходит для небольших таблиц, до нескольких десятков пар.\n"
"Хеш-таблица разработана так, чтобы быть эффективной для больших таблиц, но "
"может иметь значительные накладные расходы для маленьких.\n"
"Если ключи являются символами, можно использовать списки свойств(plists).\n"
"Если ключи являются целыми числами в узком диапазоне (или могут быть "
"отображены в них), тогда вектор может быть наиболее эффективным выбором."

#: in/chapter10.md:1257
msgid ""
"Here we implement an alternative data structure, the *trie*.\n"
"A trie implements a table for keys that are composed of a finite sequence of "
"components.\n"
"For example, if we were implementing a dictionary as a trie, each key would "
"be a word, and each letter of the word would be a component.\n"
"The value of the key would be the word's definition.\n"
"At the top of the dictionary trie is a multiway branch, one for each "
"possible first letter.\n"
"Each second-level node has a branch for every possible second letter, and so "
"on.\n"
"To find an *n*-letter word requires *n* reads.\n"
"This kind of organization is especially good when the information is stored "
"on secondary storage, because a single read can bring in a node with all its "
"possible branches."
msgstr ""
"Здесь мы реализуем альтернативную структуру данных, *trie*.\n"
"trie реализует таблицу ключей, состоящую из конечной последовательности "
"компонентов.\n"
"Например, если бы мы реализовали словарь как trie, каждый ключ был бы "
"словом, а каждая буква слова была бы компонентом.\n"
"Значение ключа будет определением слова.\n"
"Вверху словаря trie находится сильноветвящаяся(multiway) ветвь, по одному "
"пути для каждой возможной первой буквы.\n"
"У каждого узла второго уровня есть ветвь для каждой возможной второй буквы и "
"так далее.\n"
"Чтобы найти *n* -буквенное слово, требуется *n* операций чтения.\n"
"Такая организация особенно хороша, когда информация хранится во вторичном "
"хранилище, потому что одно чтение может привести к узлу со всеми его "
"возможными ветвями."

#: in/chapter10.md:1261
msgid ""
"If the keys can be arbitrary list structures, rather than a simple sequence "
"of letters, we need to regularize the keys, transforming them into a simple "
"sequence.\n"
"One way to do that makes use of the fact that any tree can be written as a "
"linear sequence of atoms and cons operations, in prefix form.\n"
"Thus, we would make the following transformation:"
msgstr ""
"Если ключи могут быть произвольными списковыми структурами, а не простой "
"последовательностью букв, нам нужно упорядочить ключи, преобразовав их в "
"простую последовательность.\n"
"Один из способов сделать это использует тот факт, что любое дерево может "
"быть записано как линейная последовательность атомов и cons-операций в "
"префиксной форме.\n"
"Таким образом, мы бы сделали следующее преобразование:"

#: in/chapter10.md:1265
msgid ""
"```lisp\n"
"(a (b c) d) =\n"
"```"
msgstr ""

#: in/chapter10.md:1267
msgid "`(cons a (cons (cons b (cons c nil)) (cons d nil)))`="
msgstr ""

#: in/chapter10.md:1271
msgid ""
"```lisp\n"
"(cons a cons cons b cons c nil cons d nil)\n"
"```"
msgstr ""

#: in/chapter10.md:1273
msgid ""
"In the implementation of tries below, this transformation is done on the "
"fly: The four user-level functions are `make-trie` to create a new trie, "
"`put-trie` and `get-trie` to add and retrieve key/value pairs, and `delete-"
"trie` to remove them."
msgstr ""
"В приведенной ниже реализации tries это преобразование выполняется на лету: "
"четыре функции пользовательского уровня: `make-trie` для создания нового "
"дерева, `put-trie` и `get-trie` для добавления и извлечения пары ключ/"
"значение и `delete-trie` для их удаления."

#: in/chapter10.md:1277
msgid ""
"Notice that we use a distinguished value to mark deleted elements, and that "
"`get-trie` returns two values: the actual value found, and a flag saying if "
"anything was found or not.\n"
"This is consistent with the interface to `gethash` and `find`, and allows us "
"to store null values in the trie.\n"
"It is an inobtrusive choice, because the programmer who decides not to store "
"null values can just ignore the second value, and everything will work "
"properly."
msgstr ""
"Обратите внимание, что мы используем выделенное значение для пометки "
"удаленных элементов, и что `get-trie` возвращает два значения: фактическое "
"найденное значение и флаг, сообщающий, было что-то найдено или нет.\n"
"Это согласуется с интерфейсом `gethash` и `find` и позволяет нам сохранять "
"значения nil в trie.\n"
"Это ненавязчивый выбор, потому что программист, решивший не хранить значения "
"nil, может просто проигнорировать второе значение, и все будет работать "
"правильно."

#: in/chapter10.md:1295
msgid ""
"```lisp\n"
"(defstruct trie (value nil) (arcs nil))\n"
"(defconstant trie-deleted \"deleted\")\n"
"(defun put-trie (key trie value)\n"
"  \"Set the value of key in trie.\"\n"
"  (setf (trie-value (find-trie key t trie)) value))\n"
"(defun get-trie (key trie)\n"
"  \"Return the value for a key in a trie, and t/nil if found.\"\n"
"  (let* ((key-trie (find-trie key nil trie))\n"
"        (val (if key-trie (trie-value key-trie))))\n"
"    (if (or (null key-trie) (eq  val trie-deleted))\n"
"        (values nil nil )\n"
"        (values val t))))\n"
"(defun delete-trie (key trie)\n"
"  \"Remove a key from a trie.\"\n"
"  (put-trie key trie trie-deleted))\n"
"```"
msgstr ""

#: in/chapter10.md:1298
msgid ""
"`(defun find-trie (key extend?\n"
"trie)`"
msgstr ""

#: in/chapter10.md:1302
msgid ""
"```lisp\n"
"  \"Find the trie node for this key.\n"
"```"
msgstr ""

#: in/chapter10.md:1305
msgctxt "in/chapter10.md:1305"
msgid ""
"`  If EXTEND?\n"
"is true, make a new node if need be.\"`"
msgstr ""

#: in/chapter10.md:1310
msgid ""
"```lisp\n"
"  (cond ((null trie) nil )\n"
"        ((atom key)\n"
"```"
msgstr ""

#: in/chapter10.md:1313
msgid ""
"`          (follow-arc key extend?\n"
"trie))`"
msgstr ""

#: in/chapter10.md:1321
msgid ""
"```lisp\n"
"        (t (find-trie\n"
"              (cdr key) extend?\n"
"              (find-trie\n"
"                (car key) extend?\n"
"              (find-trie\n"
"```"
msgstr ""

#: in/chapter10.md:1324
msgid ""
"`                \".\" extend?\n"
"trie))))))`"
msgstr ""

#: in/chapter10.md:1327
msgid ""
"`(defun follow-arc (component extend?\n"
"trie)`"
msgstr ""

#: in/chapter10.md:1331
msgid ""
"```lisp\n"
"  \"Find the trie node for this component of the key.\n"
"```"
msgstr ""

#: in/chapter10.md:1334
msgctxt "in/chapter10.md:1334"
msgid ""
"`  If EXTEND?\n"
"is true, make a new node if need be.\"`"
msgstr ""

#: in/chapter10.md:1344
msgid ""
"```lisp\n"
"  (let ((arc (assoc component (trie-arcs trie))))\n"
"    (cond ((not (null arc)) (cdr arc))\n"
"          ((not extend?) nil)\n"
"          (t (let ((new-trie (make-trie)))\n"
"              (push (cons component new-trie)\n"
"                  (trie-arcs trie))\n"
"              new-trie)))))\n"
"```"
msgstr ""

#: in/chapter10.md:1353
msgid ""
"There are a few subtleties in the implementation.\n"
"First, we test for deleted entries with an `eq` comparison to a "
"distinguished marker, the string `trie-deleted`.\n"
"No other object will be `eq` to this string except `trie-deleted` itself, so "
"this is a good test.\n"
"We also use a distinguished marker, the string \".\" to mark cons cells.\n"
"Components are implicitly compared against this marker with an `eql` test by "
"the `associn follow - arc`.\n"
"Maintaining the identity of this string is crucial; if, for example, you "
"recompiled the definition of `find-trie` (without changing the definition at "
"all), then you could no longer find keys that were indexed in an existing "
"trie, because the \".\n"
"\" used by `find-trie` would be a different one from the \".\n"
"\" in the existing trie."
msgstr ""
"В реализации есть несколько тонкостей.\n"
"Сначала мы проверяем удаленные записи с помощью сравнения `eq` с выделенным "
"маркером, строкой `trie-deleted`.\n"
"Никакой другой объект не будет `eq` к этой строке, кроме самого `trie-"
"deleted`, так что это хороший тест.\n"
"Мы также используем особый маркер - строку \".\" чтобы отметить cons-"
"ячейки.\n"
"Компоненты неявно сравниваются с этим маркером с помощью теста `eql` с "
"помощью команды `associn follow-arc`.\n"
"Сохранение идентичности этой строки имеет решающее значение; если, например, "
"вы перекомпилировали определение `find-trie` (без изменения определения "
"вообще), то вы больше не могли бы найти ключи, которые были проиндексированы "
"в существующем дереве, потому что строка \".\" используемая `find-trie` "
"будет отличаться от \".\" в существующем дереве."

#: in/chapter10.md:1361
msgid ""
"*Artificial Intelligence Programming* ([Charniak et al.\n"
"1987](B9780080571157500285.xhtml#bb0180)) discusses variations on the trie, "
"particularly in the indexing scheme.\n"
"If we always use proper lists (no non-null `cdrs`), then a more efficient "
"encoding is possible.\n"
"As usual, the best type of indexing depends on the data to be indexed.\n"
"It should be noted that Charniak et al.\n"
"call the trie a *discrimination net*.\n"
"In general, that term refers to any tree with tests at the nodes."
msgstr ""
"В *Программирование искусственного интеллекта* ([Charniak et al.\n"
"1987](B9780080571157500285.xhtml#bb0180)) обсуждаются варианты trie, в "
"частности, в схеме индексирования.\n"
"Если мы всегда используем правильные списки (без не-null `cdrs`), тогда "
"возможно более эффективное кодирование.\n"
"Как обычно, лучший тип индексирования зависит от индексируемых данных.\n"
"Следует отметить, что Charniak et al. именует trie как *сетью "
"дискриминации(распознавания?)*(discrimination net).\n"
"В общем, этот термин относится к любому дереву с тестами в узлах."

#: in/chapter10.md:1370
msgid ""
"A trie is, of course, a kind of tree, but there are cases where it pays to "
"convert a trie into a *dag*-a directed acyclic graph.\n"
"A dag is a tree where some of the subtrees are shared.\n"
"Imagine you have a spelling corrector program with a list of some 50,000 or "
"so words.\n"
"You could put them into a trie, each word with the value t.\n"
"But there would be many subtrees repeated in this trie.\n"
"For example, given a word list containing *look*, *looks*, *looked*, and "
"*looking* as well as *show*, *shows*, *showed*, and *showing*, there would "
"be repetition of the subtree containing -s, -  *ed* and -*ing*.\n"
"After the trie is built, we could pass the whole trie to un i que, and it "
"would collapse the shared subtrees, saving storage.\n"
"Of course, you can no longer add or delete keys from the dag without risking "
"unintended side effects."
msgstr ""
"Trie - это, конечно, разновидность дерева, но в некоторых случаях полезно "
"преобразовать trie в ориентированный ациклический граф *dag*(directed "
"acyclic graph).\n"
"dag - это дерево, в котором некоторые поддеревья являются "
"общими(разделяемыми).\n"
"Представьте, что у вас есть программа коррекции орфографии со списком "
"примерно из 50 000 слов.\n"
"Вы можете поместить их в дерево, каждое слово со значением t.\n"
"Но в этом дереве будет повторяться много поддеревьев.\n"
"Например, для списка слов, содержащего *look*, *looks*, *looked* и "
"*looking*, а также *show*, *shows*, *showed* и *showing*, будет повторение "
"поддерева, содержащго -s, -*ed* и -*ing*.\n"
"После того, как дерево построено, мы могли бы передать все дерево в unique, "
"и она свернула бы общие поддеревья, сохранив память.\n"
"Конечно, вы больше не сможете добавлять или удалять ключи из dag без риска "
"непредвиденных побочных эффектов."

#: in/chapter10.md:1375
msgid ""
"This process was carried out for a 56,000 word list.\n"
"The trie took up 3.2Mbytes, while the dag was 1 .IMbytes.\n"
"This was still deemed unacceptable, so a more compact encoding of the dag "
"was created, using a .2Mbytes vector.\n"
"Encoding the same word list in a hash table took twice this space, even with "
"a special format for encoding suffixes."
msgstr ""
"Этот процесс проводился для списка из 56 000 слов.\n"
"Дерево занимало 3,2 Мбайта, а размер тега - 1.1 Mбайт.\n"
"Это все еще считалось неприемлемым, поэтому было создано более компактное "
"кодирование dag с использованием вектора размером 0,2 МБ.\n"
"Кодирование одного и того же списка слов в хеш-таблице занимало вдвое больше "
"места, даже при использовании специального формата для кодирования суффиксов."

#: in/chapter10.md:1384
msgid ""
"Tries work best when neither the indexing key nor the retrieval key contains "
"variables.\n"
"They work reasonably well when the variables are near the end of the "
"sequence.\n"
"Consider looking up the pattern `\"yello?\n"
"\"` in the dictionary, where the \" ? \" character indicates a match of any "
"letter.\n"
"Following the branches for `\"yello\"` leads quickly to the only possible "
"match, `\"yellow\"`.\n"
"In contrast, fetching with the pattern `\"??llow\"` is much less efficient.\n"
"The table lookup function would have to search all 26 top-level branches, "
"and for each of those consider all possible second letters, and for each of "
"those consider the path `\"llow\"`.\n"
"Quite a bit of searching is required before arriving at the complete set of "
"matches: bellow, billow, fallow, fellow, follow, hallow, hollow, mallow, "
"mellow, pillow, sallow, tallow, wallow, willow, and yellow."
msgstr ""
"Tries работают лучше всего, когда ни ключ индексации, ни ключ извлечения не "
"содержат переменных.\n"
"Они работают достаточно хорошо, когда переменные находятся ближе к концу "
"последовательности.\n"
"Попробуйте поискать образец `\"yello?\"` в словаре, где \"?\" символный знак "
"обозначающий совпадение любой буквы.\n"
"Следование веткам для `\"yello\"` быстро приводит к единственно возможному "
"совпадению `\"yellow\"`.\n"
"Напротив, выборка с образецом `\"??llow» намного менее эффективна.\n"
"Функция поиска в таблице должна будет искать во всех 26 ветвях верхнего "
"уровня, и для каждой из них рассматривать все возможные вторые буквы, а для "
"каждого из них рассмотреть путь `\"llow\"`.\n"
"Прежде чем прийти к полному набору совпадений, требуется немало поисков: "
"bellow, billow, fallow, fellow, follow, hallow, hollow, mallow, mellow, "
"pillow, sallow, tallow, wallow, willow и yellow"

#: in/chapter10.md:1386
msgid ""
"We will return to the problem of discrimination nets with variables in "
"[section 14.8](B9780080571157500145.xhtml#s0040), [page 472]"
"(B9780080571157500145.xhtml#p472)."
msgstr ""
"Мы вернемся к проблеме селективных сетей с переменными в [раздел 14.8]"
"(B9780080571157500145.xhtml#s0040), [страница 472](B9780080571157500145."
"xhtml#p472)."

#: in/chapter10.md:1388
msgid "## 10.6 Exercises"
msgstr "## 10.6 Упражнения"

#: in/chapter10.md:1394
msgid ""
"**Exercise  10.1 [h]** Define the macro `deftable,` such that `(deftable "
"person assoc`) will act much like a `defstruct-`it will define a set of "
"functions for manipulating a table of people: `get-person, put-person, clear-"
"person,` and `map-person.` The table should be implemented as an association "
"list.\n"
"Later on, you can change the representation of the table simply by changing "
"the form to (`deftable person hash` ), without having to change anything "
"else in your code.\n"
"Other implementation options include property lists and vectors.\n"
"`deftable` should also take three keyword arguments: `inline`, `size` and "
"`test`.\n"
"Here is a possible macroexpansion:"
msgstr ""

#: in/chapter10.md:1396
msgid "`>(macroexpand '(deftableperson hash :-inline t :size 100))`="
msgstr ""

#: in/chapter10.md:1411
msgid ""
"```lisp\n"
"  (progn\n"
"  (proclaim '(inline get-person put-person map-person))\n"
"  (defparameter *person-table*\n"
"    (make-hash-table :test #eql :size 100))\n"
"  (defun get-person (x &optional default)\n"
"    (gethash x *person-table* default))\n"
"  (defun put-person (x value)\n"
"    (setf (gethash x *person-table*) value))\n"
"  (defun clear-person () (clrhash *person-table*))\n"
"  (defun map-person (fn) (maphash fn *person-table*))\n"
"  (defsetf get-person put-person)\n"
"  'person)\n"
"```"
msgstr ""

#: in/chapter10.md:1415
msgid ""
"**Exercise  10.2 [m]** We can use the :`type` option to `defstruct` to "
"define structures implemented as lists.\n"
"However, often we have a two-field structure that we would like to implement "
"as a cons cell rather than a two-element list, thereby cutting storage in "
"half.\n"
"Since `defstruct` does not allow this, define a new macro that does."
msgstr ""

#: in/chapter10.md:1417
msgid ""
"**Exercise  10.3 [m]** Use `reuse - cons` to write a version of `flatten` "
"(see [page 329](B9780080571157500108.xhtml#p329)) that shares as much of its "
"input with its output as possible."
msgstr ""

#: in/chapter10.md:1422
msgid ""
"**Exercise  10.4 [h]** Consider the data type *set*.\n"
"A set has two main operations: adjoin an element and test for membership.\n"
"It is convenient to also add a map-over-elements operation.\n"
"With these primitive operations it is possible to build up more complex "
"operations like union and intersection."
msgstr ""

#: in/chapter10.md:1427
msgid ""
"As mentioned in [section 3.9](B9780080571157500030.xhtml#s0095), Common Lisp "
"provides several implementations of sets.\n"
"The simplest uses lists as the underlying representation, and provides the "
"functions `adjoin, member, union, intersection`, and `set-difference`.\n"
"Another uses bit vectors, and a similar one uses integers viewed as bit "
"sequences.\n"
"Analyze the time complexity of each implementation for each operation."
msgstr ""

#: in/chapter10.md:1429
msgid ""
"Next, show how *sorted lists* can be used to implement sets, and compare the "
"operations on sorted lists to their counterparts on unsorted lists."
msgstr ""

#: in/chapter10.md:1431
msgid "## 10.7 Answers"
msgstr "## 10.7 Ответы"

#: in/chapter10.md:1433
msgid "**Answer 10.2**"
msgstr ""

#: in/chapter10.md:1438
msgid ""
"```lisp\n"
"(defmacro def-cons-struct (cons car cdr &optional inline?)\n"
"  \"Define aliases for cons, car and cdr.\"\n"
"```"
msgstr ""

#: in/chapter10.md:1441
msgid ""
"`  '(progn (proclaim '(,(if inline?\n"
"'inline 'notinline)`"
msgstr ""

#: in/chapter10.md:1450
msgid ""
"```lisp\n"
"                  ,car ,cdr ,cons))\n"
"          (defun ,car (x) (car x))\n"
"          (defun ,cdr (x) (cdr x))\n"
"          (defsetf ,car (x) (val) '(setf (car ,x) ,val))\n"
"          (defsetf ,cdr (x) (val) '(setf (cdr ,x) ,val))\n"
"          (defun ,cons (x y) (cons x y))))\n"
"```"
msgstr ""

#: in/chapter10.md:1452
msgid "**Answer 10.3**"
msgstr ""

#: in/chapter10.md:1463
msgid ""
"```lisp\n"
"(defun flatten (exp &optional (so-far nil) last-cons)\n"
"  \"Return a flat list of the atoms in the input.\n"
"  Ex: (flatten '((a) (b (c) d))) => (a b c d).\"\n"
"  (cond ((null exp) so-far)\n"
"        ((atom exp) (reuse-cons exp so-far last-cons))\n"
"        (t (flatten (first exp)\n"
"                  (flatten (rest exp) so-far exp)\n"
"                  exp))))\n"
"```"
msgstr ""

#: in/chapter10.md:1465
msgid "----------------------"
msgstr ""

#: in/chapter10.md:1468
msgid ""
"[1](#xfn0015) These are all done with safety 0 and speed 3.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
