# Глава 5
## Элиза: Диалог с машиной

> *Говорят, что объяснять - значит оправдываться.*

> -Joseph Weizenbaum

> MIT computer scientist

В этой главе и в остатках части I рассмотриваются еще три хорошо известные программы искусственного интеллекта 1960-х годов.
ELIZA провела беседу с пользователем, в которой она имитировала психотерапевта.
STUDENT решал словесные задачи, подобные тем, что встречаются в школьных учебниках алгебры, а MACSYMA решала множество символических математических задач, включая дифференциальное и интегральное исчисление.
Мы разработаем версии первых двух программ, которые дублируют большинство основных функций, но для третьей мы будем реализовывать только крошечную часть возможностей исходной программы.

Все три программы интенсивно используют технику, называемую сопоставлением образцов.
Часть I служит для того, чтобы показать универсальность, а также ограничения - этой техники.

Из трех программ первые две обрабатывают входные данные на простом английском языке, и последние две решают нетривиальные задачи в математике, поэтому есть некоторые основания для описания их как "интеллектуальных"."
С другой стороны, мы увидим, что этот интеллект в значительной степени является иллюзией, и что Элиза, в частности, была на самом деле предназначена для демонстрации этой иллюзии, а не для того, чтобы быть "серьезной" программой ИИ.

ELIZA была одной из первых программ, в которой был возможен ввод и вывод на английском языке.
Программа была названа в честь героини *Пигмалиона*, которую научил говорить по-английски преданный своему делу учитель.
Главный разработчик ELIZA, профессор Массачусетского технологического института Джозеф Вайценбаум, опубликовал статью об ELIZA в январском выпуске журнала *Communications of the Association for Computing Machinery* за 1966 год.
Введение к этой статье полностью воспроизводится здесь:

> *Говорят, что объяснять - значит растолковывать начиная из далека.
Эта максима нигде не выполняется так хорошо, как в области компьютерного программирования, особенно в том, что называется эвристическим программированием и искусственным интеллектом.
Ибо в этих сферах машины заставляют вести себя чудесными способами, часто достаточными, чтобы ослепить даже самого опытного наблюдателя.
Но как только конкретная программа разоблачается, когда ее внутренняя работа объясняется на языке, достаточно ясном, чтобы вызвать понимание, ее магия рассыпается; он предстает как простой набор процедур, каждая из которых вполне понятна.
Наблюдатель говорит себе: «Я мог бы написать это». С этой мыслью он перемещает рассматриваемую программу с полки, помеченной как «интеллектуальная», на полку, предназначенную для антикварных вещей, подходящую для обсуждения только с людьми менее просвещенными, чем он*.

> *Цель этой статьи - вызвать именно такую переоценку программы, которая вот-вот будет "объяснена". Немногие программы когда-либо нуждались в этом больше. *

Позвольте мне мимоходом заметить, что главная цель этой книги-заставить читателя сказать себе: "я мог бы написать это". Есть надежда, что в некоторых случаях это произойдет потому, что читатель что-то приобрел, а не только потому, что программы, о которых идет речь, потеряли свою способность ослеплять.

Давайте начнем наше исследование ELIZA с примера диалога из статьи Вейценбаума.
ELIZA была создана для того, чтобы обучаться с помощью различных сценариев или моделей взаимодействия.
На самом деле там было несколько сценариев, в том числе на немецком и валлийском языках.
Но единственный сценарий, который в какой-то степени использовался, был на английском, и это заставило ELIZA подражать психоаналитику Роджера(какое то направление в психиатрии).
Роджерианцы "недирективны" -они пытаются позволить пациенту раскрыть себя.
Элизе легко следовать этому сценарию, потому что она предполагает пассивность и реакцию, а не добровольное предоставление новой информации.
В следующем списке ввод данных Пользователя осуществляется в смешанном регистре, а ответ Элизы-заглавными буквами:

```text
Men are all alike.
IN WHAT WAY
They're always bugging us about something or another.
CAN YOU BE MORE SPECIFIC
Well, my boyfriend made me come here.
YOUR BOYFRIEND MADE YOU COME HERE
He says I'm depressed much of the time.
I AM SORRY TO HEAR YOU ARE DEPRESSED
It's true. I am unhappy.
DO YOU THINK COMING HERE WILL HELP YOU NOT TO BE UNHAPPY
I need some help, that much seems certain.
WHAT WOULD IT MEAN TO YOU IF YOU GOT SOME HELP
Perhaps I could learn to get along with my mother.
TELL ME MORE ABOUT YOUR FAMILY
```

Это кажется весьма впечатляющим; программа разумно реагирует на различные входные данные и, похоже, демонстрирует истинное «понимание».
Но, как объясняет Вайценбаум, эта видимость является иллюзией, и программа решила сложную задачу понимания, тщательно распознавая, преобразовывая и повторяя части входных данных.
Процедура заключается в поиске определенных шаблонов(образцов) на основе ключевого слова или слов во входных данных.
Например, всякий раз, когда программа видит слова "alike"(похожий) или "same"(такой же), она печатает сообщение с вопросом о сходстве, в данном случае "`IN WHAT WAY.`"(каким образом). Другие шаблоны более сложны.
В предпоследнем обмене ELIZA сначала выбрасывает все, что стоит после запятой, а затем использует шаблон, который ищет ввод в форме "I need X"(Мне нужен X) и преобразует его в вывод "What would it mean to you if you got X"(Что бы это значило для вас, если бы вы получили X), где X - фраза "some help"(некоторая помощь), в данном случае.
Большое преимущество этого подхода заключается в том, что ответ будет иметь смысл для различных входов: "I need a vacation"(мне нужен отпуск) будет вызывать "What would it mean to you if you got a vacation."(что бы это значило для вас, если бы вы получили отпуск). Это будет работать автоматически, без необходимости сообщать программе разницу между "some help"(некоторой помощью) и "a vacation."(отпуском). Недостатком является то, что программа иногда будет делать глупые ответы: "I need this like a hole in the head"(мне это нужно, как дырка в голове), - вызовет ответ: "What would it mean to you if you got this like a hole in the head"(что бы это значило для вас, если бы вы получили это, как дырку в голове). На самом деле, программа имеет смысл только в том случае, если она получает информацию от кого-то, кто имеет смысл - и кто-то, кто благосклонно интерпретирует ее ответы.
Когда ей говорили: "I need gibble plix zzq"(мне нужен гиббл пликс ЗЗК), Элиза отвечала: "What would it mean to you if you got gibble plix zzq"(что бы это значило для тебя, если бы ты получил гиббл пликс ЗЗК), не подозревая, что что-то не так.
Другой пример оригинальной программы ELIZA состоит в том, что она взаимодействует с другой программой, PARRY, которая была написана доктором Кеннетом Колби для имитации параноидального поведения.
Далее следует часть разговора, с Элизой снова заглавными буквами и PARRY в смешанном регистре:

```text
I don't understand your motives.
WHY DON'T YOU UNDERSTAND MY MOTIVES?
Shouldn't I be?
WHY DO YOU SAY THAT JUST NOW?
That's just the way it is.
SUPPOSE THAT'S JUST THE WAY IT WERE NOT.
So?
I AM NOT SURE I UNDERSTAND YOU FULLY.
You harp on the same questions too much.
WHAT DOES THAT SIMILARITY SUGGEST TO YOU?
I don't get you.
DO YOU WISH THAT YOU DID GET I?
```

Это говорит о том, что ни ELIZA, ни PARRY не имели глубокого понимания диалога.
Когда человек берет на себя большую часть бремени ведения разговора, эти программы могут быть убедительными, но когда человека выводят из разговора, обнаруживаются слабые места программ.

## 5.1 Описание и Спецификация Элизы(ELIZA)
Теперь, когда у нас есть представление о том, на что похожа ELIZA, мы можем начать описание и спецификацию программы и, в конечном итоге, перейти к реализации и отладке.

Алгоритм ELIZA можно описать просто как: (1) прочитать ввод, (2) найти образец, который соответствует вводу, (3) преобразовать ввод в ответ и (4) распечатать ответ.
Эти четыре шага повторяются для каждого ввода.

Спецификация и реализация шагов (1) и (4) тривиальны: для (1) используйте встроенную функцию `read`, чтобы прочитать список слов, и для (4) используйте `print`, чтобы распечатать список слов в ответе.

Конечно, у этой спецификации есть некоторые недостатки.
Пользователь должен будет ввести реальный список, используя круглые скобки, и пользователь не может использовать символы, специальные для `read`, такие как кавычки, запятые и точки.
Так что наш ввод не будет таким неограниченным, как в примере диалога, но это небольшая плата за удобство аккуратного решения половины проблемы.

## 5.2 Сопоставление с образцом
Самая сложная часть состоит в шагах (2) и (3) - это идея сопоставления с образцом и преобразования.
Есть четыре вещи, о которых нужно позаботиться: общие образец и ответ, а также конкретные ввод и преобразование этого ввода.
Поскольку мы согласились представить входные данные в виде списка, имеет смысл, чтобы и другие компоненты тоже были списками.
Например, у нас может быть:

```text
Образец: (i need a X)
Ответ: (what would it mean to you if you got a X ?)

Ввод: (i need a vacation)
Преобразование: (what would it mean to you if you got a vacation ?)
```

Средство сопоставления с образцом должно сопоставить литералы `i` с `i`, `need` с `need` и `a` с `a`, а также сопоставить переменную `X` с `vacation`.
Это предполагает, что есть способ узнать, что `X` является переменной, а `need` - нет.
Затем мы должны заменить в ответе для `X` на `vacation`, чтобы получить окончательное преобразование.

Игнорируя на мгновение проблему преобразования шаблона в ответ, мы можем увидеть, что это понятие сопоставления с образцом является просто обобщением функции Лиспа `equal`.
Ниже мы показываем функцию `simple-equal`, которая похожа на встроенную функцию `equal`, <sup>[1] (#chapter5-fn1)</sup> и функцию `pat-match`, которая является её расширением для обработки переменных сопоставления с образцом:

```lisp
(defun simple-equal (x y)
   "Are x and y equal?  (Don't check inside strings.)"
   (if (or (atom x) (atom y))
       (eql x y)
       (and (simple-equal (first x) (first y))
	    (simple-equal (rest x) (rest y)))))

(defun pat-match (pattern input)
  "Does pattern match input? Any variable can match anything."
  (if (variable-p pattern)
      t
      (if (or (atom pattern) (atom input))
	  (eql pattern input)
          (and (pat-match (first pattern) (first input))
	       (pat-match (rest pattern) (rest input))))))
```

&#9635; **Exercise 5.1 [s]** Было бы неплохо заменить complex и form в `pat-match` на более простую `(every #'pat-match pattern input)?`

Прежде чем мы продолжим, нам нужно определиться с реализацией для переменных сопоставления с образцом.
Мы могли бы, например, сказать, что только определенный набор символов, таких как {X, Y, Z}, является переменными.
В качестве альтернативы мы могли бы определить структуру типа `variable`, но тогда нам пришлось бы вводить что-то подробное, например `(make-variable :name 'X )`, каждый раз, когда нам это нужно.
Другой вариант - использовать символы, но отличать переменные от констант по имени символа.
Например, в Прологе переменные начинаются с заглавных букв, а константы - со строчных.
Но Common Lisp нечувствителен к регистру, так что это не сработает.
Вместо этого в программах ИИ на основе Лиспа существует традиция, когда переменные представляют собой символы, начинающиеся с знака вопроса.

До сих пор мы рассматривали символы как атомы - т.е. объекты без внутренней структуры.
Но все всегда сложнее, чем кажется на первый взгляд, оказывается в Лиспе, как и в физике, даже атомы имеют компоненты.
В частности, символы имеют имена, которые являются строками и доступны через функцию `symbol-name`.
Строки, в свою очередь, имеют элементы, которые являются символьными знаками, доступными через функцию `char`.
Символьный знак '?' обозначается самовычисляемой escape-последовательностью  `#\?`.
Итак, предикат `variable-p` может быть определен следующим образом, и теперь у нас есть полный сопоставитель с образцом:

```lisp
(defun variable-p (x)
  "Is X a variable (a symbol beginning with '?')?"
  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))

> (pat-match '(I need a ?X) '(I need a vacation))
T

> (pat-match '(I need a ?X) ' (I really need a vacation))
NIL
```

В каждом случае мы получаем правильный ответ, но не получаем никаких указаний на то, что такое `?X`, поэтому мы не можем подставить его в ответ.
Нам нужно изменить `pat-match`, чтобы она возвращала какую-то таблицу переменных и соответствующих им значений.
Сделав этот выбор, опытный программист на Common Lisp может сэкономить время, проявив гибкость: он сразу распознает, когда существует функция, которая сможет выполнить большую часть поставленной задачи.
Мы хотим подставлять значения для переменных во всем ответе.
Предупрежденный программист может обратиться к указателю этой книги или справочному руководству Common Lisp и найти функции `substitute`, `subst` и `sublis`.
Все они заменяют старое выражение новым выражением внутри выражения.
Оказывается, что `sublis` является наиболее подходящим, потому что она единственная, которая позволяет нам делать несколько замен одновременно.
`sublis` принимает два аргумента, первый - это список пар старый-новый, а второй - выражение, в котором должны быть сделаны замены.
Для каждой из пар `car` заменяется на `cdr`.
Другими словами, мы должны сформировать каждую пару так: `(cons old new)`.
(Такой список пар известен как *список ассоциаций/ассоциативный список* или *a-list*, потому что он связывает ключи со значениями.
См. Раздел 3.6.)
В терминах приведенного выше примера мы бы использовали:

```lisp
> (sublis '((?X . vacation))
          '(what would it mean to you if you got a ?X ?))
(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)
```

Теперь нам нужно сделать так, чтобы `pat-match` возвращал a-list, а не просто T в случае успеха.
Вот первая попытка:

```lisp
(defun pat-match (pattern input)
   "Does pattern match input? WARNING: buggy version."
   (if (variable-p pattern)
       (list (cons pattern input))
       (if (or (atom pattern) (atom input))
	   (eql pattern input)
	   (append (pat-match (first pattern) (first input))
		   (pat-match (rest pattern) (rest input))))))
```

Эта реализация выглядит разумной: она возвращает a-list из одного элемента, если образец является переменной, и соединяет(append) ассоциативные списки, если образец и вход являются списками.
Однако есть несколько проблем.
Во-первых, тест `(eql pattern input)` может вернуть `T`, который не является списком, поэтому `append` будет жаловаться.
Во-вторых, тот же тест может вернуть nil, что должно указывать на сбой, но он будет рассматриваться просто как список и будет добавлен к остальной части ответа.
В-третьих, мы не различаем случай, когда совпадение не удается и возвращается nil, и случай, когда все совпадает, но нет переменных, поэтому он возвращается nil - нулевой a-list.
(Это проблема полупредиката, обсуждаемая на стр. 127.)
В-четвертых, мы хотим, чтобы привязки переменных согласовывались - если `?X` используется дважды в образце, мы не хотим, чтобы он совпадал с двумя разными значениями во входных данных.
Наконец, для `pat-match` неэффективно проверять и `first` и `rest` списков, даже если соответствующие части `first` не совпадают.
(Разве не удивительно, что в семистрочной функции может быть пять ошибок?)

Мы можем решить эти проблемы, договорившись о двух основных соглашениях.
Во-первых, очень удобно сделать `pat-match` истинным предикатом, поэтому мы согласимся, что он возвращает `nil` только для обозначения неудачи.
Это означает, что для представления пустого списка привязок нам понадобится значение, отличное от nil.
Во-вторых, если мы собираемся быть последовательными в отношении значений переменных, то первое(`first`) должно будет знать, что делают остальные(`rest`).
Мы можем добиться этого, передав список привязок в качестве третьего аргумента функции `pat-match`.
Мы сделаем его необязательным аргументом, потому что хотим иметь возможность просто сказать `(pat-match a b)`.

Чтобы абстрагироваться от этих решений реализации, мы определяем константы `fail` и `no-bindings` для представления двух проблемных возвращаемых значений.
Специальная форма defconstant используется для обозначения того, что эти значения не изменятся.
(Принято давать специальные имена переменных, начинающиеся и заканчивающиеся звездочками, но это соглашение обычно не соблюдается для констант.
Причина в том, что звездочки кричат: "Осторожно!
Я могу быть изменен чем-то за пределами этой лексической области." Константы, конечно, не будут изменены.)

```lisp
(defconstant fail nil "Indicates pat-match failure")

(defconstant no-bindings '((t . t))
  "Indicates pat-match success, with no variables.")
```

Затем мы абстрагируемся от `assoc`, введя следующие четыре функции:

```lisp
(defun get-binding (var bindings)
  "Find a (variable . value) pair in a binding list."
  (assoc var bindings))

(defun binding-val (binding)
  "Get the value part of a single binding."
  (cdr binding))

(defun lookup (var bindings)
  "Get the value part (for var) from a binding list."
  (binding-val (get-binding var bindings)))

(defun extend-bindings (var val bindings)
  "Add a (var . value) pair to a binding list."
  (cons (cons var val) bindings))
```

Теперь, когда определены переменные и привязки, реализация `pat-match` очень проста.
Она состоит из пяти случаев.
Во-первых, если список привязки - `fail`, то сопоставление не удачно (потому что какое-то предыдущее сопоставление должно было быть неудачным).
Если образец представляет собой единственную переменную, то совпадение возвращает все, что возвращает `match-variable`; либо существующий список привязки, либо расширенный, либо `fail`.
Затем, если и образец, и входные данные являются списками, мы сначала рекурсивно вызываем `pat-match` для первого элемента каждого списка.
Она возвращает список привязки (или `fail`), который мы используем для сопоставления с оставшимися списками.
Это единственный случай, когда вызывается нетривиальная функция, поэтому неплохо неформально доказать, что функция завершится: каждый из двух рекурсивных вызовов уменьшает размер как образца, так и ввода, а `pat-match` проверяет случай атомарных образцов и входных данных, поэтому функция в целом должна в конечном итоге вернуть ответ (если и образец, и входные данные не имеют бесконечного размера).
Если ни один из этих четырех случаев неуспешен, то совпадение считается неудачным.

```lisp
(defun pat-match (pattern input &optional (bindings no-bindings))
   "Match pattern against input in the context of the bindings"
   (cond ((eq bindings fail) fail)
	 ((variable-p pattern)
	  (match-variable pattern input bindings))
	 ((eql pattern input) bindings)
	 ((and (consp pattern) (consp input))
	  (pat-match (rest pattern) (rest input)
		     (pat-match (first pattern) (first input)
				bindings)))
	 (t fail)))

(defun match-variable (var input bindings)
  "Does VAR match input? Uses (or updates) and returns bindings."
  (let ((binding (get-binding var bindings)))
    (cond ((not binding) (extend-bindings var input bindings))
	  ((equal input (binding-val binding)) bindings)
	  (t fail))))
```

Теперь мы можем протестировать `pat-match` и посмотреть, как это работает:

```lisp
> (pat-match '(i need a ?X) '(i need a vacation))
((?X . VACATION) (T . T))
```

Ответ представляет собой список привязок переменных в виде точечных пар; каждый элемент списка представляет собой пару (`variable . value`).
`(T. T)` является признаком `no-bindings`.
Он не наносит реального вреда, но мы можем устранить это, немного усложнив `extend-bindings`:

```lisp
(defun extend-bindings (var val bindings)
   "Add a (var . value) pair to a binding list. "
   (cons (cons var val)
	 ;; Once we add a "real" binding,
	 ;; we can get rid of the dummy no-bindings
	 (if (eq bindings no-bindings)
	     nil
	     bindings)))

> (sublis (pat-match ' (i need a ?X) ' (i need a vacation))
          '(what would it mean to you if you got a ?X ?))
(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)

> (pat-match ' (i need a ?X) ' (i really need a vacation))
NIL

> (pat-match ' (this is easy) ' (this is easy))
((T . T))

> (pat-match ' (?X is ?X) ' ((2 + 2) is 4))
NIL

> (pat-match ' (?X is ?X) ' ((2 + 2) is (2 + 2)))
((?X 2 + 2))

> (pat-match ' (?P need . ?X) ' (i need a long vacation))
((?X A LONG VACATION) (?P . I ))
```

Важное замечание: точка в конце шаблона, говорит о том, что последняя переменная может соответствовать всей оставшейся части ввода.



Обратите внимание на различие между `NIL` и `((T . T))`.
Последнее означает, что совпадение прошло успешно, но привязок для возврата нет.
Также запомните, что `(?X 2 + 2)` означает то же самое, что `(?X . (2 + 2))`.

Более мощная реализация `pat-match` дается в главе 6.
Еще одна реализация приведена в разделе 10.4.
Она более эффективна, но более громоздка в использовании.

## 5.3 Сопоставление с сегментным образцом
В образце `(?P need . ?X)` переменная `?X` соответствует остальной части входного списка(остатку), независимо от его длины.
И в этом её отличие от `?P`, которая может соответствовать только одному элементу, а именно первому элементу ввода.
Для многих приложений сопоставление с образцом это обычное дело; мы хотим сопоставить только соответствующие элементы.
Однако ELIZA несколько отличается тем, что она учитывает переменные в любой позиции, которые могут соответствовать последовательности элементов во входных данных.
Мы будем называть такие переменные *сегментными переменными*.  Нам понадобится обозначение, чтобы отличать сегментные переменные от обычных переменных.
Возможны два класса обозначений: либо мы используем атомы для представления сегментных переменных и различаем их по определенному правилу написания (как мы это делали, чтобы отличать переменные от констант), либо мы используем неатомарную конструкцию.
Мы выберем последний вариант, используем список вида (`?*` *Variable*) для обозначения сегментных переменных.
Символ `?*` выбран потому, что он объединяет понятие переменной с обозначением Kleenestar.
Итак, поведение, которое мы хотим от `pat-match`, таково:

```lisp
> (pat-match '((?* ?p) need (?* ?x))
             '(Mr Hulot and I need a vacation))
((?P MR HULOT AND I) (?X A VACATION))
```

Другими словами, когда и образец, и ввод являются списками, а первый элемент образца является сегментной переменной, тогда переменная будет сопоставлена некоторой начальной части ввода, а остальная часть образца будет сопоставлена остатку ввода.
Мы можем обновить `pat-match`, чтобы учесть это, добавив единственное условие cond.
Также легко определить предикат для проверки сегментных переменных:

```lisp
 (defun pat-match (pattern input &optional (bindings no-bindings))
   "Match pattern against input in the context of the bindings"
   (cond ((eq bindings fail) fail)
	 ((variable-p pattern)
	  (match-variable pattern input bindings))
	 ((eql pattern input) bindings)
	 ((segment-pattern-p pattern)                ; ***
	  (segment-match pattern input bindings))    ; ***
	 ((and (consp pattern) (consp input))
	  (pat-match (rest pattern) (rest input)
		     (pat-match (first pattern) (first input)
				bindings)))
	 (t fail)))

(defun segment-pattern-p (pattern)
  "Is this a segment matching pattern: ((?* var) . pat)"
  (and (consp pattern)
       (starts-with (first pattern) '?*)))
```

При написании `segment-match` важный вопрос состоит в том, какой части ввода должна соответствовать сегментная переменная.
Один из ответов - посмотреть на следующий элемент образца (тот, который стоит после переменной сегмента) и посмотреть, в какой позиции он встречается во входных данных.
Если этого не происходит, весь образец никогда не может совпасть, и мы должны - потерпеть неудачу (`fail`).
Если это происходит, назовем его позицию(позицию совпадения) `pos`.
Тогда мы сопоставляем переменную с начальной частью ввода, вплоть до позиции `pos`.
Но сначала мы должны посмотреть, соответствует ли оставшаяся часть образца оставшейся части ввода.
Это делается рекурсивным вызовом `pat-match`.
Пусть результат этого рекурсивного вызова будет называться `b2`.
Если `b2` успешно, то мы идем дальше и сопоставляем сегментную переменную с начальной подпоследовательностью.

Возникает сложность - когда `b2` неудача.
Мы не хотим полностью сдаваться, потому что может случиться так, что если сегментная переменная соответствует более длинной подпоследовательности ввода, тогда остальная часть образца будет соответствовать оставшейся части ввода.
Итак, мы хотим снова попробовать `segment-match`, но заставить его учитывать более длительное совпадение для переменной.
Это делается путем введения необязательного параметра `start`, который изначально равен 0 и увеличивается с каждой ошибкой.
Обратите внимание, что это правило исключает возможность любой вид переменных после сегментной переменной.
(Позже мы снимем это ограничение.)

```lisp
(defun segment-match (pattern input bindings &optional (start 0))
   "Match the segment pattern ((?* var) . pat) against input."
   (let ((var (second (first pattern)))
	 (pat (rest pattern)))
     (if (null pat)
	 (match-variable var input bindings)
	 ;; We assume that pat starts with a constant
	 ;; In other words, a pattern can't have 2 consecutive vars
	 (let ((pos (position (first pat) input
			      :start start :test #'equal)))
	   (if (null pos)
	       fail
	       (let ((b2 (pat-match pat (subseq input pos) bindings)))
		 ;; If this match failed, try another longer one
		 ;; If it worked, check that the variables match
		 (if (eq b2 fail)
		     (segment-match pattern input bindings (+ pos 1))
		     (match-variable var (subseq input 0 pos) b2))))))))
```

Ниже приведены некоторые примеры сопоставления сегментов:

```lisp
> (pat-match '((?* ?p) need (?* ?x))
       '(Mr Hulot and I need a vacation))
((?P MR HULOT AND I) (?X A VACATION))

> (pat-match '((?* ?x) is a (?* ?y)) '(what he is is a fool))
((?X WHAT HE IS) (?Y FOOL))
```

Первый из этих примеров показывает довольно простой случай: `?p` соответствует всему, до need, а `?x` соответствует остальному.
В следующем примере рассматривается более сложный случай.
Первый `?x` соответствует всему, вплоть до первого `is` (это позиция 2, поскольку счет начинается с 0 в Common Lisp).
Но тогда образец a не соответствует `is` из входных данных, `segment-match` пытается начать снова с начальной позиции 3.
На этот раз все работает; `is` соответствует `is`, `a` соответствует `a` и `(?* ?y)` соответствует `fool`.

К сожалению, эта версия `segment-match` не находит многие соответствия, как это должно быть.
Рассмотрим следующий пример:

```lisp
> (pat-match '((?* ?x) a b (?* ?x)) '(1 2 a b a b 1 2 a b)) â NIL
```

Функция терпит неудачу, потому что `?x` сопоставляется с подпоследовательностью `(1 2)`, и тогда оставшийся образец успешно соответствует оставшемуся входу, но окончательный вызов `match-variable` завершается неудачей, потому что `?x` имеет два различных значения.
Исправление состоит в том, чтобы вызвать `match-variable` перед проверкой, не является ли `b2` неудачей, так что мы обязательно попробуем `segment-match` снова с более длинным соответствием независимо от причины сбоя.

```lisp
(defun segment-match (pattern input bindings &optional (start 0))
   "Match the segment pattern ((?* var) . pat) against input."
   (let ((var (second (first pattern)))
	 (pat (rest pattern)))
     (if (null pat)
	 (match-variable var input bindings)
	 ;; We assume that pat starts with a constant
	 ;; In other words, a pattern can't have 2 consecutive vars
	 (let ((pos (position (first pat) input
			      :start start :test #'equal)))
	   (if (null pos)
	       fail
	       (let ((b2 (pat-match
			  pat (subseq input pos)
			  (match-variable var (subseq input 0 pos)
					  bindings))))
		 ;; If this match failed, try another longer one
		 (if (eq b2 fail)
		     (segment-match pattern input bindings (+ pos 1))
		     b2)))))))
```

Теперь мы видим, что поиск соответствия идет до конца:

```lisp
> (pat-match '((?* ?x) a b (?* ?x)) '(1 2 a b a b 1 2 a b))
((?X 1 2 A B))
```

Обратите внимание, что эта версия `segment-match` сначала пытается найти самое короткое совпадение.
Также можно было бы сначала попробовать самое длинное соответствие.

## 5.4 Программа Элиза: Преобразователь на основе правил
Теперь, когда у нас есть работающий сопоставитель с образцом, нам нужно сопоставить несколько образцов.
Более того, мы хотим, чтобы образцы были связаны с ответами.
Мы можем сделать это, придумав структуру данных, называемую `rule`(правило), которая состоит из образца и одного или нескольких связанных ответов.
Это правила в том смысле, что они утверждают: "Если вы видите A, то ответьте B или C, выбранными наугад". Мы выберем простейшую возможную реализацию правил: в виде списков, где первый элемент - это образец, а остаток - список ответов:


```lisp
(defun rule-pattern (rule) (first rule))

(defun rule-responses (rule) (rest rule))
```

Вот пример правила:

```lisp
(((?* ?x) I want (?* ?y))
 (What would it mean if you got ?y)
 (Why do you want ?y)
 (Suppose you got ?y soon))
```

При применении к входным данным: `(I want to test this program)`, т.е. `(я хочу протестировать эту программу)` это правило (при интерпретации программой ELIZA) выбирает ответ случайным образом, подставляет в `?y` значение и отвечает, скажем: `(why do you want to test this program)`, т.е `(почему вы хотите протестировать эту программу)`.

Теперь, когда мы знаем, что будет делать отдельное правило, нам нужно решить, как обрабатывать набор правил.
Если мы хотим, чтобы ELIZA представляла интерес, у нее должно быть множество ответов.
Таким образом, к одному и тому же входу могут применяться несколько правил.
Одна из возможностей - выбрать случайным образом правило из набора правил, имеющих образцы, соответствующие входным данным.

Другой вариант - просто принять первое подходящее правило.
Это означает, что правила формируют упорядоченный список, а не неупорядоченное множество.
Умный составитель правил для ELIZA может воспользоваться этим упорядочиванием и сделать так, чтобы наиболее конкретные правила были на первом месте, в то время как более расплывчатые правила находились ближе к концу списка.


В исходной ELIZA была система, в которой каждому правилу был присвоен номер приоритета.
Выбралось правило сопоставления с наивысшим приоритетом.
Обратите внимание, что упорядочение правил дает тот же эффект, что и номер приоритета для каждого правила: первое правило неявно имеет наивысший приоритет, второе правило - следующее наивысшее и т. Д.


Вот краткий список правил, выбранных из исходной статьи Вайценбаума, но с обновленной формой правил до той формы, которую мы используем.
Ответ к упражнению 5.18 содержит более длинный список правил.

```lisp
(defparameter *eliza-rules*
  '((((?* ?x) hello (?* ?y))
     (How do you do.  Please state your problem.))
    (((?* ?x) I want (?* ?y))
     (What would i t mean if you got ?y)
     (Why do you want ?y) (Suppose you got ?y soon))
    (((?* ?x) if (?* ?y))
     (Do you really think i t s l i k e l y that ?y) (Do you wish that ?y)
     (What do you think about ?y) (Really-- if ?y))
    (((?* ?x) no (?* ?y))
     (Why not?) (You are being a bit negative)
     (Are you saying "NO" just to be negative?))
    (((?* ?x) I was (?* ?y))
     (Were you really ?) (Perhaps I already knew you were ?y)
     (Why do you t e l l me you were ?y now?))
    (((?* ?x) I feel (?* ?y))
     (Do you often feel ?y ?))
    (((?* ?x) I felt (?* ?y))
     (What other feelings do you have?))))
```

Наконец, мы готовы дать собственно определение ELIZA.
Как мы говорили ранее, основная программа должна быть циклом, который считывает ввод, преобразует его и печатает результат.
Преобразование выполняется в первую очередь путем нахождения некоторого правила, образец которого соответствует входу, а затем подстановки переменных в ответ правила.
Программа представлена на рисунке 5.1.

Рисунок 5.1: Глоссарий программы ELIZA

| Символ             | Использование                                                                |
| ------             | ---                                                                          |
|                    | **Функция верхнего уровня**                                                  |
| `eliza`            | Отвечает на ввод пользователя, используя правила сопоставления с образцом.   |
|                    | **Специальные переменные**                                                   |
| `*eliza-rules*`    | Список правил преобразования.                                                |
|                    | **Типы данных**                                                              |
| `rule`             | Связь образцов со списком ответов..                                          |
|                    | **Функции**                                                                  |
| `eliza`            | Отвечает на ввод пользователя, используя правила сопоставления с образцом.   |
| `use-eliza-rules`  | Ищет какое-либо правило, с помощью которого можно преобразовать ввод.        |
| `switch-viewpoint` | Меняет я(I) на ты(you) и наоборот, и т.д.                                    |
| `flatten`          | складывает элементы в список.                                                |
|                    | **Выбранные функции Common Lisp**                                            |
| `sublis`           | производит замену элементов в дереве.                                        |
|                    | **Ранее определенные функции**                                               |
| `random-elt`       | Выберает случайный элемент из списка. (p. 36)                                |
| `pat-match`        | Сопоставляет образец с вводом, (p. 160)                                      |
| `mappend`          | Складывает вместе результаты mapcar.                                         |

Есть несколько мелких осложнений.
Мы печатаем приглашение, чтобы сообщить пользователю что ждем ввода.
Мы используем функцию `flatten`, чтобы гарантировать, что на выходе не будет вложенных списков после подстановки переменных.
Важный трюк - изменить ввод, заменив "ты"(you) на "я"(i) и так далее, поскольку эти термины относятся к говорящему.
Вот полная программа:


```lisp
(defun eliza ()
  "Respond to user input using pattern matching rules."
  (loop
   (print 'eliza>)
   (write (flatten (use-eliza-rules (read))) :pretty t)))

 (defun use-eliza-rules (input)
   "Find some rule with which to transform the input."
   (some #'(lambda (rule)
	     (let ((result (pat-match (rule-pattern rule) input)))
	       (if (not (eq result fail))
		   (sublis (switch-viewpoint result)
			   (random-elt (rule-responses rule))))))
	 *eliza-rules*))

(defun switch-viewpoint (words)
  "Change I to you and vice versa, and so on."
  (sublis '((I . you) (you . I) (me . you) (am . are))
          words))
```

Обратите внимание на использование `write` с ключевым словом `:pretty` true.
В некоторых случаях это даст лучший формат вывода.
Программа использует ранее определенные `random-elt` и `flatten`, которые определены здесь с помощью `mappend` и `mklist`, функций, которые определены в диалекте InterLisp, но не в Common Lisp.

```lisp
(defun flatten (the-list)
  "Append together elements (or lists) in the list."
  (mappend #'mklist the-list))

(defun mklist (x)
  "Return x if it is a list, otherwise (x)."
  (if (listp x)
      x
    (list x)))

(defun mappend (fn the-list)
  "Apply fn to each element of list and append the result."
  (apply #'append (mapcar fn the-list)))

(defun random-elt (choices)
  "Choose an element from a list at random."
  (elt choices (random (length choices))))
```

В реальной программе ELIZA было несколько усложнений, которых нет в этой версии.
Во-первых, был метод псевдонима для связывания нескольких слов с одним и тем же образцо; и "mother"(мать), и "father"(отец) могут быть связаны с образцом "family"(семья).
Был также механизм синонимов, который относился к "don't"(не надо) и "do not" или "everybody"(всем) и "everyone".
В случае ввода нескольких фраз, разделенных запятыми, каждая фраза обрабатывалась отдельно и выбирался ответ с наивысшим приоритетом.
Кроме того, исходная ELIZA имела механизм "памяти".
Когда ни один образец не совпадал с вводом, он говорил что-то вроде "Tell me more about X"(Расскажите мне больше о X), где X - некоторый ввод, сделанный ранее.
Наконец, в нашей версии меньше правил.
Несмотря на недостатки нашей версии, она может иногда задерживать конец разговора, как показано ниже:

```text
> (eliza)
ELIZA> (hello there)
(HOW DO YOU DO. PLEASE STATE YOUR PROBLEM.)
ELIZA> (i want to test this program)
(WHAT WOULD IT MEAN IF YOU GOT TO TEST THIS PROGRAM)
ELIZA> (i could see if it works)
(DO YOU REALLY THINK ITS LIKELY THAT IT WORKS)
ELIZA> (no not really)
(ARE YOU SAYING "NO" JUST TO BE NEGATIVE?)
ELIZA> (no)
(ARE YOU SAYING "NO" JUST TO BE NEGATIVE?)
ELIZA> (forget it-- i was wondering how general the program i s)
(WHY DO YOU TELL ME YOU WERE WONDERING HOW GENERAL THE PROGRAM I S NOW?)
ELIZA> (i felt like it)
(WHAT OTHER FEELINGS DO YOU HAVE?)
ELIZA> (i feel this is enough)
(DO YOU OFTEN FEEL THIS IS ENOUGH ?)
ELIZA> [Abort]
```

В конце концов, это важна техника, а не программа.
ELIZA была "объяснена", и ее по праву следует переместить на полку с любопытными вещами.
Сопоставление с образцом в целом остается важной техникой, и мы еще не раз увидим ее в следующих главах.
Понятие преобразователя, основанного на правилах, также важно.
Проблема понимания английского (и других языков) остается важной частью ИИ.
Понятно, что проблема понимания английского не решается ELIZA.
В части V мы снова обратимся к этой проблеме, используя более сложные методы.

## 5.5 История и ссылки
Как упоминалось выше, исходная статья, описывающая ELIZA, описана в Weizenbaum 1966.
Другой диалоговой системой, использующей аналогичные методы сопоставления с образцом, является система PARRY Кеннета Колби (1975).
Эта программа достаточно хорошо смоделировала разговор параноика, чтобы обмануть нескольких профессиональных психологов.
Хотя методы сопоставления с образцом были простыми, модель убеждений, поддерживаемая системой, была намного сложнее, чем ELIZA.
Колби предположил, что диалоговые программы, такие как ELIZA, дополненные какой-то моделью убеждений, такой как PARRY, могут быть полезными инструментами при лечении психически больных людей.
По словам Колби, было бы недорого и эффективно заставить пациентов общаться с помощью специально разработанной программы, которая могла бы обрабатывать простые случаи и предупреждать врачей о пациентах, которым требуется дополнительная помощь.
В книге Вайценбаума «Компьютерная мощь и человеческий разум» (1976) обсуждаются ELIZA и PARRY и очень критически рассматривается предложение Колби.
О других интересных ранних работах по диалоговым системам, моделирующим убеждения, сообщили Аллан Коллинз (1978) и Джейми Карбонелл (1981).

## 5.6 Упражнения
&#9635; **Exercise 5.2 [m]** Поэкспериментируйте с этой версией ELIZA.
Покажите некоторые обмены сообщениями, где она работает хорошо, а где нет.
Попытайтесь охарактеризовать разницу.
Какие сбои можно исправить, изменив набор правил, какие - изменив функцию `pat-match` (и язык образцов, который она определяет), а какие требуют изменения самой программы `eliza`?

&#9635; **Exercise 5.3 [h]** Определите новый набор правил, которые заставят ELIZA давать стереотипные ответы на некоторые ситуации, отличные от отношений между врачом и пациентом.
Или напишите свод правил на другом языке, кроме английского.
Протестируйте и отладьте свой новый набор правил.

&#9635; **Exercise 5.4 [s]** Мы упоминали, что наша версия ELIZA не может обрабатывать запятые или двойные кавычки во входных данных.
Однако, похоже, она обрабатывает апостроф как во вводе, так и в шаблонах.
Объясните.

&#9635; **Exercise 5.5 [h]** Измените механизм ввода для обработки запятых и других знаков препинания.
Также сделайте так, чтобы пользователю не приходилось вводить круглые скобки вокруг всего входного выражения.
(Подсказка: это можно сделать только с помощью некоторых функций Lisp, которые мы еще не видели.
Посмотрите на `read-line` и `read-from-string`.)

&#9635; **Exercise 5.6 [m]** Измените ELIZA, чтобы иметь явный выход.
Также организуйте так, чтобы вывод не печатался в круглых скобках.

&#9635; **Exercise 5.7 [m]** Добавьте "механизм памяти", о котором говорилось ранее, в ELIZA.
Также добавьте способ определения синонимов, таких как "everyone" и "everybody".

&#9635; **Exercise 5.8 [h]** Оказывается, ни одно из правил в данном скрипте не использует переменную более одного раза - нет правила вида `(?X ... ?X)`.
Напишите средство сопоставления образцов, которое только добавляет привязки, но никогда не проверяет переменные на соответствие предыдущим привязкам.
Используйте специальную форму `time`, чтобы сравнить вашу функцию с текущей версией.

&#9635; **Exercise 5.9 [h]** Книга Уинстона и Хорна *Lisp* предоставляет хорошую программу сопоставления с образцом.
Сравните их реализацию с этой.
Одно отличие состоит в том, что они обрабатывают случай, когда первый элемент шаблона является сегментной переменной со следующим кодом (переведенным в нашу нотацию):

```lisp
(or (pat-match (rest pattern) (rest input) bindings)
  (pat-match pattern (rest input) bindings))
```

Это говорит о том, что сегментная переменная соответствует либо путем сопоставления первого элемента ввода, либо путем сопоставления более чем первого элемента.
Это намного проще, чем наш подход с использованием `position`, отчасти потому, что они не обновляют список привязок.
Можете ли вы изменить их код для обработки привязок и включить его в нашу версию `pat-match`?
Все еще проще?
Это более или менее эффективно?

&#9635; **Exercise 5.10** Что не так в следующем определении  `simple-equal`?

```lisp
(defun simple-equal (x y)
  "Test if two lists or atoms are equal."
  ;; Warning - incorrect
  (or (eql x y)
      (and (listp x) (listp y)
     (simple-equal (first x) (first y))
     (simple-equal (rest x) (rest y)))))
```

&#9635; **Exercise 5.11 [m]** Оцените преимущества замены `no-bindings` на `nil` и `fail` на что-то еще.

&#9635; **Exercise 5.12 [m]** Взвесьте преимущества того, что `pat-match` возвращает множественное значение: первое будет истинным для совпадения и ложным при неудаче, а второе будет списком привязок.

&#9635; **Exercise 5.13 [m]** Предположим, что есть вызов `segment-match`, где переменная уже имеет привязку.

Текущее определение будет продолжать делать рекурсивные вызовы `segment-match`, по одному для каждой возможной совпадающей позиции.
Но это глупо - если переменная уже связана, есть только одна последовательность, с которой её можно сопоставить.
Измените определение так, чтобы оно отображало только эту последовательность.

&#9635; **Exercise 5.14 [m]** Определите версию `mappend`, которая, как и `mapcar`, принимает любое количество аргументов списков.

&#9635; **Exercise 5.15 [m]** Приведите неформальное доказательство того, что `segment-match` всегда заканчивается.

&#9635; **Exercise 5.16 [s]** Вопрос с подвохом: в Лиспе есть объект, который при передаче в `variable-p` приводит к ошибке.
Что это за объект?

&#9635; **Exercise 5.17 [m]** Текущая версия ELIZA принимает входные данные, преобразует их в соответствии с первым применимым правилом и выводит результат.
Можно также представить себе систему, в которой ввод может быть преобразован несколько раз, прежде чем будет напечатан окончательный вывод.
Будет ли такая система более мощной?
Если да, то каким образом?


&#9635; **Exercise 5.18 [h]** Прочтите оригинальную статью Вайценбаума об ELIZA и перенесите его список правил в обозначения, используемые в этой главе.

## 5.7 Answers
### Answer 5.1
Нет.
Если либо образец, либо входные данные были короче, но соответствовали каждому существующему элементу,  выражение every неправильно вернуло бы true.

```lisp
(every #'pat-match '(a b c) '(a)) â T
```

Более того, если образец или входные данные были списком с точкой, то результат every был бы undefined - некоторые реализации могут сигнализировать об ошибке, а другие могут просто игнорировать выражение после точки.

```lisp
(every #'pat-match '(a b . c) '(a b . d)) â T, NIL, or error.
```

### Answer 5.4
Выражение `don't` может выглядеть как отдельное слово, но для читателя(read) Lisp оно состоит из двух элементов `don` и `'t` или `(quote t )`.
Если эти элементы используются последовательно, они будут сопоставляться правильно, но они не будут печататься правильно - перед кавычкой будет пробел.
Фактически, аргумент `: pretty t` для `write` определен в первую очередь для того, чтобы заставить `(quote t)` печатать как `'t`
(См. Стр. 559 книги Стила *Common Lisp the Language*, 2-е издание).

### Answer 5.5
OОдин из способов сделать это - прочитать всю строку текста с помощью `read-line`, а не `read`.
Затем замените любой символ пунктуации в этой строке пробелами.
Наконец, заключите строку в круглые скобки и прочтите ее как список:

```lisp
(defun read-line-no-punct ()
  "Read an input line, ignoring punctuation."
  (read-from-string
   (concatenate 'string "(" (substitute-if #\space #'punctuation-p
             (read-line))
    ")")))

(defun punctuation-p (char) (find char ".,;:'!?#-()\\\""))
```

Это также можно сделать, изменив таблицу для чтения, как в разделе 23.5, с. 821.

### Answer 5.6

```lisp
 (defun eliza ()
   "Respond to user input using pattern matching rules."
   (loop
      (print 'eliza>)
      (let* ((input (read-line-no-punct))
	      (response (flatten (use-eliza-rules input))))
	   (print-with-spaces response)
	   (if (equal response '(good bye)) (RETURN)))))

(defun print-with-spaces (list)
  (mapc #'(lambda (x) (prin1 x) (princ " ")) list))
```

***`or`***

```lisp
(defun print-with-spaces (list)
  (format t "~{~a ~}" list))
```

### Answer 5.10
Подсказка: подумайте `(simple-equal '() '(nil . nil))`.

### Answer 5.14

```lisp
(defun mappend (fn &rest list)
  "Apply fn to each element of lists and append the results."
  (apply #'append (apply #'mapcar fn lists)))
```

### Answer 5.16
Это должен быть символ, потому что для несимволов `variable-p` просто возвращает nil.
Получение `symbol-name` для символа - это просто доступ к слоту, поэтому она не может вызвать ошибку.
Остается только `elt`; если имя символа - пустая строка, то доступ к нулевому элементу пустой строки является ошибкой.
В самом деле, есть символ, имя которого - пустая строка: символ.

### Answer 5.17
Среди прочего, для обработки сокращений может использоваться система рекурсивного преобразования.
То есть такую форму, как "don't"(не делать), можно преобразовать в "do not", а затем снова обработать.
Таким образом, другие правила должны работать только с входными данными, совпадающими с "do not".

### Answer 5.18
Ниже приводится большая часть правил Вайценбаума:

```lisp
(defparameter *eliza-rules*
  '((((?* ?x) hello (?* ?y))
     (How do you do. Please state your problem.))
    (((?* ?x) computer (?* ?y))
     (Do computers worry you?) (What do you think about machines?)
     (Why do you mention computers?)
     (What do you think machines have to do with your problem?))
    (((?* ?x) name (?* ?y))
     (I am not interested in names))
    (((?* ?x) sorry (?* ?y))
     (Please don't apologize) (Apologies are not necessary)
     (What feelings do you have when you apologize))
    (((?* ?x) I remember (?* ?y))
     (Do you often think of ?y)
     (Does thinking of ?y bring anything else to mind?)
     (What else do you remember) (Why do you recall ?y right now?)
     (What in the present situation reminds you of ?y)
     (What i s the connection between me and ?y))
    (((?* ?x) do you remember (?* ?y))
     (Did you think I would forget ?y ?)
     (Why do you think I should recall ?y now)
     (What about ?y) (You mentioned ?y))
    (((?* ?x) if (?* ?y))
     (Do you really think its likely that ?y) (Do you wish that ?y)
     (What do you think about ?y) (Really-- if ?y))
    (((?* ?x) I dreamt (?* ?y))
     (Really-- ?y) (Have you ever fantasized ?y while you were awake?)
     (Have you dreamt ?y before?))
    (((?* ?x) dream about (?* ?y))
     (How do you feel about ?y in reality?))
    (((?* ?x) dream (?* ?y))
     (What does this dream suggest to you?) (Do you dream often?)
     (What persons appear in your dreams?)
     (Don't you believe that dream has to do with your problem?))
    (((?* ?x) my mother (?* ?y))
     (Who else in your family ?y) (Tell me more about your family))
    (((?* ?x) my father (?* ?y))
     (Your father) (Does he influence you strongly?)
     (What else comes to mind when you think of your father?))
    (((?* ?x) I want (?* ?y))
     (What would it mean if you got ?y)
     (Why do you want ?y) (Suppose you got ?y soon))
    (((?* ?x) I am glad (?* ?y))
     (How have I helped you to be ?y) (What makes you happy just now)
     (Can you explain why you are suddenly ?y))
    (((?* ?x) I am sad (?* ?y))
     (I am sorry to hear you are depressed)
     (I 'm sure i t ' s not pleasant to be sad))
    (((?* ?x) are like (?* ?y))
     (What resemblance do you see between ?x and ?y))
    (((?* ?x) i s like (?* ?y))
     (In what way is it that ?x is like ?y)
     (What resemblance do you see?)
     (Could there really be some connection?) (How?))
    (((?* ?x) alike (?* ?y))
     (In what way?) (What s i m i l a r i t i e s are there?))
    (((?* ?x) same (?* ?y))
     (What other connections do you see?))
    (((?* ?x) I was (?* ?y))
     (Were you really ?) (Perhaps I already knew you were ?y)
     (Why do you tell me you were ?y now?))
    (((?* ?x) was I (?* ?y))
     (What if you were ?y ?) (Do you think you were ?y)
     (What would it mean if you were ?y))
    (((?* ?x) I am (?* ?y))
     (In what way are you ?y) (Do you want to be ?y ?))
    (((?* ?x) am I (?* ?y))
     (Do you believe you are ?y) (Would you want to be ?y)
     (You wish I would tell you you are ?y)
     (What would it mean if you were ?y))
    (((?* ?x) am (?* ?y))
     (Why do you say "AM?") (I don't understand that))
    (((?* ?x) are you (?* ?y))
     (Why are you interested in whether I am ?y or not?)
     (Would you prefer if I weren't ?y)
     (Perhaps I am ?y in your fantasies))
    (((?* ?x) you are (?* ?y))
     (What makes you think I am ?y ?))
    (((?* ?x) because (?* ?y))
     (Is that the real reason?) (What other reasons might there be?)
     (Does that reason seem to explain anything else?))
    (((?* ?x) were you (?* ?y))
     (Perhaps I was ?y) (What do you think?) (What if I had been ?y))
    (((?* ?x) I can't (?* ?y))
     (Maybe you could ?y now) (What if you could ?y ?))
    (((?* ?x) I feel (?* ?y))
     (Do you often feel ?y ?))
    (((?* ?x) I felt (?* ?y))
     (What other feelings do you have?))
    (((?* ?x) I (?* ?y) you (?* ?z))
     (Perhaps in your fantasy we ?y each other))
    (((?* ?x) why don't you (?* ?y))
     (Should you ?y yourself?)
     (Do you believe I don't ?y) (Perhaps I will ?y in good time))
    (((?* ?x) yes (?* ?y))
     (You seem quite positive) (You are sure) (I understand))
    (((?* ?x) no (?* ?y))
     (Why not?) (You are being a bit negative)
     (Are you saying "NO" just to be negative?))
    (((?* ?x) someone (?* ?y))
     (Can you be more specific?))
    (((?* ?x) everyone (?* ?y))
     (surely not everyone) (Can you think of anyone in particular?)
     (Who for example?) (You are thinking of a special person))
    (((?* ?x) always (?* ?y))
     (Can you think of a specific example) (When?)
     (What incident are you thinking of?) (Really-- always))
    (((?* ?x) what (?* ?y))
     (Why do you ask?) (Does that question interest you?)
     (What is it you really want to know?) (What do you think?)
     (What comes to your mind when you ask that?))
    (((?* ?x) perhaps (?* ?y))
     (You do not seem quite certain))
    (((?* ?x) are (?* ?y))
     (Did you think they might not be ?y)
     (Possibly they are ?y))
    (((?* ?x))
     (Very interesting) (I am not sure I understand you fully)
     (What does that suggest to you?) (Please continue) (Go on)
     (Do you feel strongly about discussing such things?))))
```

----------------------

<a name="chapter5-fn1">1</a>: Разница в том, что `simple-equal` не обрабатывает строки.