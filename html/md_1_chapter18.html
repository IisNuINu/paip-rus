<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 18</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 18 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Поиски и игра Отелло</h2>
<blockquote class="doxtable">
<p>В сознании новичка есть бесконечные возможности; в экспертном мало. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Suzuki Roshi, Zen Master </p>
</blockquote>
<p>**Г**еймерские игры были целью многих ранних работ в области ИИ по трем причинам. Во-первых, правила большинства игр формализованы, и их довольно легко реализовать в компьютерной программе. Во-вторых, во многих играх требования к интерфейсу тривиальны. Компьютеру нужно только распечатать свои ходы и прочитать ходы противника. Это верно для таких игр, как шахматы и шашки, но не для пинг-понга и баскетбола, где решающее значение имеют зрение и моторика. В-третьих, хорошая игра в шахматы считается многими интеллектуальным достижением. Ньюэлл, Шоу и Саймон говорят: "Шахматы - интеллектуальная игра * par excellence *", а Дональд Мичи назвал шахматы "Дрозофила(мушка для испытаний)*Drosophila melanogaster* машинного интеллекта», имея в виду, что шахматы - относительно простая, но интересная область, которая может привести к достижениям в области искусственного интеллекта, точно так же, как изучение плодовой мухи способствовало развитию биологии.</p>
<p>Сегодня ИИ уделяет меньше внимания играм. Было понято, что методы, которые хорошо работают в ограниченной области настольной игры, не обязательно приводят к разумному поведению в других областях. Кроме того, как оказалось, методы, позволяющие компьютерам играть хорошо, отличаются от техник, которые используют хорошие игроки-люди. Люди способны распознавать абстрактные модели, извлеченные из предыдущих игр, и разрабатывать планы атаки и защиты.</p>
<p>В то время как большая часть предыдущей работы по игре была сосредоточена на шахматах и шашках, в этой главе демонстрируется программа для игры в Отелло. <a href="# fn0015">1</a> Отелло - это разновидность игры Реверси девятнадцатого века. Программировать эту игру легко, потому что правила проще, чем в шахматах. "Отелло" также полезно программировать, потому что простой метод поиска может дать отличного игрока. На это есть две причины. Во-первых, количество разрешенных ходов за ход невелико, поэтому поиск не слишком взрывной. Во-вторых, один ход Отелло может перевернуть дюжину или более фигур противника. Это мешает игрокам-людям визуализировать отдаленные последствия своего хода. Программы, основанные на поиске, это не сбивают с толку и, таким образом, хорошо работают по сравнению с людьми.</p>
<p>Само название "Отелло" происходит от того, что игра настолько непредсказуема, как венецианский мавр. Название также может быть намеком на фразу: "Ваша дочь и мавр теперь делают зверя с двумя спинами" <a href="#fn0020">2</a>, поскольку у игровых фишек действительно есть две спинки, одна белая и одна черная. В любом случае связь между игрой и спектаклем переносится на названия нескольких программ: Кассио, Яго и Билла. Последние два будут рассмотрены в этой главе. Они равны или даже лучше, чем игроки-чемпионы. Мы сможем разработать упрощенную версию, которая не будет чемпионом, но будет намного лучше, чем у начинающих игроков.</p>
<h2>18.1 Правила игры</h2>
<p>В Отелло играют на доске 8 на 8, которая изначально расставлена ​​с четырьмя фигурами в центре, как показано на <a href="#f0010">рис. 18.1</a>. Два игрока, черный и белый, по очереди ходят, причем черные играют первыми. На каждом ходу игрок кладет на доску фишку своего цвета. После размещения фишку нельзя переместить, но последующие ходы могут перевернуть фишку из одного цвета в другой. Каждая фишка должна быть размещена таким образом, чтобы <em>скреплять</em> одну или несколько фишек соперника. То есть, когда черные играют фигуру, должна быть линия (горизонтальная, вертикальная или диагональная), которая проходит через только что сыгранную фигуру, затем через одну или несколько белых фигур, а затем через другую черную фигуру. Промежуточные белые фигуры переворачиваются на черные. Если белые фигуры в квадратных скобках расположены более чем в одном направлении, они все переворачиваются. <a href="#f0015">Рисунок 18.2 (a)</a> указывает допустимые ходы черных маленькими точками. <a href="#f0015">Рисунок 18.2 (b)</a> показывает позицию после того, как черные перейдут на поле b4. Игроки ходят по очереди, за исключением того, что пасовать должен игрок, у которого нет разрешенных ходов. Когда ни один из игроков не имеет ходов, игра заканчивается, и побеждает игрок с наибольшим количеством фигур на доске. Обычно это происходит из-за того, что не осталось пустых квадратов, но иногда это случается в игре и раньше.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter18/f18-01.jpg" alt="f18-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 18.1: Доска Отелло </td></tr>
</table>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter18/f18-02.jpg" alt="f18-02"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 18.2: Законные перемещения в Отелло </td></tr>
</table>
<h2>18.2 Варианты представления</h2>
<p>При разработке программы "Отелло" мы захотим протестировать различные стратегии, используя стратегии играть друг против друга и против игроков-людей. Мы также можем захотеть, чтобы наша программа позволяла двум людям играть в игру. Следовательно, наша основная функция, <code>othello</code>, будет функцией мониторинга, которая принимает в качестве аргументов две стратегии. Она использует эти стратегии для получения ходов каждого игрока, а затем применяет эти ходы к представлению игрового поля, возможно, распечатывая доску по мере ее продвижения.</p>
<p>Первый выбор, который нужно сделать, - как представить доску и фигуры на ней. Доска представляет собой квадрат 8 на 8, и каждый квадрат может быть заполнен черной или белой фигурой или может быть пустым. Таким образом, очевидный выбор представления состоит в том, чтобы сделать доску массивом 8 на 8, где каждый элемент массива представляет собой символ <code>black/черный</code>, <code>white/белый</code> или <code>nil/ничего</code>.</p>
<p>Обратите внимание на то, что здесь происходит: мы следуем обычному соглашению Лиспа о реализации <em>перечислимого типа</em> (типа частей, которые могут заполнять квадрат) как набора символов. Это подходящее представление, поскольку оно поддерживает основную операцию над элементами перечислимого типа: проверка на равенство с помощью eq. Оно также легко поддерживает ввод и вывод.</p>
<p>Во многих других языках (например, C или Pascal) перечисляемые типы реализованы как целые числа. В Паскале можно было объявить:</p>
<div class="fragment"><div class="line">type piece = (black, white, empty);</div></div><!-- fragment --><p>чтобы определить <code>piece</code> как набор из трех элементов, который рассматривается как подтип целых чисел. Язык не допускает прямого ввода и вывода таких типов, но равенство можно проверить. Преимущество этого подхода в том, что элемент можно разместить в небольшом пространстве. В области Отелло мы ожидаем, что эффективность будет важна, потому что один из способов выбрать хороший ход - это посмотреть на большое количество возможных последовательностей ходов и выбрать последовательность, которая приводит к благоприятному результату. Таким образом, мы готовы внимательно изучить альтернативные представления, чтобы найти эффективное. Для представления одного из трех возможных типов требуется всего два бита, тогда как для представления символа требуется гораздо больше (возможно, 32). Таким образом, мы можем сэкономить место, представляя pieces(части) в виде небольших целых чисел(small integers), а не символов.</p>
<p>Далее рассматриваем доску. Двумерный массив кажется настолько очевидным выбором, что трудно представить лучшее представление. Мы могли бы рассмотреть 8-элементный список из 8-ми элементов, но это просто потеряло бы пространство (для cons-ячеек) и время (при доступе к более поздним элементам списков). Однако нам придется реализовать два других абстрактных типа данных, которые мы еще не рассматривали: square(клетка) и direction(направление). Нам понадобится, например, изобразить клетку, в который игрок выбирает двигаться. Это будет пара целых чисел, например 4,5. Мы могли бы представить его как список из двух элементов или, более компактно, как cons-ячейку, но это все равно означает, что нам, возможно, придется генерировать мусор (создавать cons-ячейку) каждый раз, когда мы хотим обратиться к новой клетке. Точно так же нам нужно иметь возможность сканировать в заданном направлении(direction) от клетки в поисках частей, которые нужно перевернуть. Направления(direction) будут представлены парой целых чисел, например + 1, -1. Одна из умных возможностей - использовать комплексные числа как для клеток, так и для направлений, при этом действительный компонент отображается на горизонтальной оси, а мнимый компонент - на вертикальную ось. Затем перемещение в заданном направлении от клетки выполняется простым добавлением направления к клетке. Но в большинстве реализаций создание новых комплексных чисел также генерирует мусор.</p>
<p>Другая возможность состоит в том, чтобы представить клетку (и направления) как два различных целых числа, а процедуры, которые ими управляют, принимают два аргумента вместо одного. Это было бы эффективно, но теряется важная абстракция: клетки (и направления) концептуально являются едиными объектами.</p>
<p>Выход из этой дилеммы - представление доски в виде одномерного вектора. Клетки представлены целыми числами в диапазоне от 0 до 63. В большинстве реализаций маленькие целые числа (fixnums) представлены как непосредственные данные, которыми можно манипулировать, не создавая мусора. Направления также могут быть реализованы как целые числа, представляющие числовую разницу между соседними квадратами вдоль этого направления. Чтобы почувствовать это, взгляните на доску:</p>
<div class="fragment"><div class="line"> 0  1  2  3  4  5  6  7</div><div class="line"> 8  9 10 11 12 13 14 15</div><div class="line">16 17 18 19 20 21 22 23</div><div class="line">24 25 26 27 28 29 30 31</div><div class="line">32 33 34 35 36 37 38 39</div><div class="line">40 41 42 43 44 45 46 47</div><div class="line">48 49 50 51 52 53 54 55</div><div class="line">56 57 58 59 60 61 62 63</div></div><!-- fragment --><p>Вы можете видеть, что направление +1 соответствует движению вправо, +7 соответствует диагональному движению вниз и влево, +8 - вниз, а +9 - по диагонали вниз и вправо. Отрицания этих чисел (-1, -7, -8, -9) представляют противоположные направления.</p>
<p>У этой схемы есть одна сложность: нам нужно знать, когда мы попадаем на край доски. Начиная с клетки 0, мы можем двигаться в направлении +1 семь раз, чтобы добраться до правого края доски, но нам не разрешено снова двигаться в этом направлении, чтобы добраться до клетки 8. Можно проверить край доски, рассматривая частные и остатки по модулю 8, но это довольно сложно и дорого.</p>
<p>Более простое решение - явно представить край доски с помощью вектора из 100 элементов вместо вектора из 64 элементов. Внешние элементы отмечены маркером, указывающим на то, что они находятся за пределами доски. Это представление занимает немного места, но значительно упрощает обнаружение границ. Оно также имеет небольшое преимущество в том, что допустимые клетки представлены числами в диапазоне 11-88, что упрощает их понимание во время отладки. Вот новая доска из 100 элементов:</p>
<div class="fragment"><div class="line"> 0  1  2  3  4  5  6  7  8  9</div><div class="line">10 11 12 13 14 15 16 17 18 19</div><div class="line">20 21 22 23 24 25 26 27 28 29</div><div class="line">30 31 32 33 34 35 36 37 38 39</div><div class="line">40 41 42 43 44 45 46 47 48 49</div><div class="line">50 51 52 53 54 55 56 57 58 59</div><div class="line">60 61 62 63 64 65 66 67 68 69</div><div class="line">70 71 72 73 74 75 76 77 78 79</div><div class="line">80 81 82 83 84 85 86 87 88 89</div><div class="line">90 91 92 93 94 95 96 97 98 99</div></div><!-- fragment --><p>Горизонтальное направление теперь &plusmn;1, вертикальное &plusmn;10, а диагонали &plusmn;9 и &plusmn;11. Мы предварительно примем это последнее представление, но оставим возможность перехода на другой формат. Приняв это решение, мы готовы начать. <a href="#f0020">Рисунок 18.3</a> - это глоссарий для полной программы. Глоссарий второй версии программы находится на <a href="#p623">стр. 623</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter18/f18-03.jpg" alt="f18-03"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 18.3: Глоссарий программы Отелло </td></tr>
</table>
<p>*(ed: this should be a markdown table)*</p>
<p>Далее следует код directions(направлений) и pieces(частей). Мы явно определяем тип <code>piece</code> как число от <code>empty</code> до <code>outer</code> (от 0 до 3), и определяем функцию <code>name-of</code> для сопоставления номера piece(части) с символом: точка для пустого, <code>@</code> для черного, 0 для белого и вопросительный знак (который никогда не следует печатать) для <code>outer</code>.</p>
<div class="fragment"><div class="line">(defconstant all-directions &#39;(-11 -10 -9 -1 1 9 10 11))</div><div class="line"></div><div class="line">(defconstant empty 0 &quot;An empty square&quot;)</div><div class="line">(defconstant black 1 &quot;A black piece&quot;)</div><div class="line">(defconstant white 2 &quot;A white piece&quot;)</div><div class="line">(defconstant outer 3 &quot;Marks squares outside the 8x8 board&quot;)</div><div class="line"></div><div class="line">(deftype piece () `(integer ,empty ,outer))</div><div class="line"></div><div class="line">(defun name-of (piece) (char &quot;.@O?&quot; piece))</div><div class="line"></div><div class="line">(defun opponent (player) (if (eql player black) white black))</div></div><!-- fragment --><p>А вот код board(доски). Обратите внимание, что мы вводим функцию <code>bref</code> для "ссылок на доске", а не используем встроенную функциюи<code>aref</code>. Это облегчает возможные изменения в представлении досок. Кроме того, даже несмотря на то, что не существует непрерывного диапазона чисел, который представляет допустимые квадраты, мы можем определить константу <code>all-squares</code> как список из 64 разрешенных клеток, вычисленных как числа от 11 до 88, значение которых по модулю 10 равно от 1 до 8.</p>
<div class="fragment"><div class="line">(deftype board () &#39;(simple-array piece (100)))</div><div class="line"></div><div class="line">(defun bref (board square) (aref board square))</div><div class="line">(defsetf bref (board square) (val)</div><div class="line">  `(setf (aref ,board ,square) ,val))</div><div class="line"></div><div class="line">(defun copy-board (board)</div><div class="line">  (copy-seq board))</div><div class="line"></div><div class="line">(defconstant all-squares</div><div class="line">  (loop for i from 11 to 88 when (&lt;= 1 (mod i 10) 8) collect i))</div><div class="line"></div><div class="line">(defun initial-board ()</div><div class="line">  &quot;Return a board, empty except for four pieces in the middle.&quot;</div><div class="line">  ;; Boards are 100-element vectors, with elements 11-88 used,</div><div class="line">  ;; and the others marked with the sentinel OUTER.  Initially</div><div class="line">  ;; the 4 center squares are taken, the others empty.</div><div class="line">  (let ((board (make-array 100 :element-type &#39;piece</div><div class="line">                           :initial-element outer)))</div><div class="line">    (dolist (square all-squares)</div><div class="line">      (setf (bref board square) empty))</div><div class="line">    (setf (bref board 44) white   (bref board 45) black</div><div class="line">          (bref board 54) black   (bref board 55) white)</div><div class="line">    board))</div><div class="line"></div><div class="line">(defun print-board (&amp;optional (board *board*) clock)</div><div class="line">  &quot;Print a board, along with some statistics.&quot;</div><div class="line">  ;; First print the header and the current score</div><div class="line">  (format t &quot;~2&amp;    a b c d e f g h   [~c=~2a ~c=~2a (~@d)]&quot;</div><div class="line">          (name-of black) (count black board)</div><div class="line">          (name-of white) (count white board)</div><div class="line">          (count-difference black board))</div><div class="line">  ;; Print the board itself</div><div class="line">  (loop for row from 1 to 8 do</div><div class="line">        (format t &quot;~&amp;  ~d &quot; row)</div><div class="line">        (loop for col from 1 to 8</div><div class="line">              for piece = (bref board (+ col (* 10 row)))</div><div class="line">              do (format t &quot;~c &quot; (name-of piece))))</div><div class="line">  ;; Finally print the time remaining for each player</div><div class="line">  (when clock</div><div class="line">    (format t &quot;  [~c=~a ~c=~a]~2&amp;&quot;</div><div class="line">            (name-of black) (time-string (elt clock black))</div><div class="line">            (name-of white) (time-string (elt clock white)))))</div><div class="line"></div><div class="line">(defun count-difference (player board)</div><div class="line">  &quot;Count player&#39;s pieces minus opponent&#39;s pieces.&quot;</div><div class="line">  (- (count player board)</div><div class="line">     (count (opponent player) board)))</div></div><!-- fragment --><p>Теперь давайте посмотрим на исходную доску, поскольку она печатается с помощью <code>print-board</code> и необработанной <code>write</code> (я добавил разрывы строк, чтобы было легче читать):</p>
<div class="fragment"><div class="line">&gt; (write (initial-board)   &gt; (print-board (initial-board))</div><div class="line">          :array t)</div><div class="line">#(3 3 3 3 3 3 3 3 3 3                  1 2 3 4 5 6 7 8[@=2 0=2 (+0)]</div><div class="line">    3 0 0 0 0 0 0 0 0 3            10 . . . . . . . .</div><div class="line">    3 0 0 0 0 0 0 0 0 3            20 . . . . . . . .</div><div class="line">    3 0 0 0 0 0 0 0 0 3            30 . . . . . . . .</div><div class="line">    3 0 0 0 2 1 0 0 0 3            40 . . . 0 @ . . .</div><div class="line">    3 0 0 0 1 2 0 0 0 3            50 . . . @ 0 . . .</div><div class="line">    3 0 0 0 0 0 0 0 0 3            60 . . . . . . . .</div><div class="line">    3 0 0 0 0 0 0 0 0 3            70 . . . . . . . .</div><div class="line">    3 0 0 0 0 0 0 0 0 3            80 . . . . . . . .</div><div class="line">    3 3 3 3 3 3 3 3 3 3)</div><div class="line">#&lt;ART-2B-100 -72570734&gt;    NIL</div></div><!-- fragment --><p>Обратите внимание, что <code>print-board</code> предоставляет некоторую дополнительную информацию: количество фигур, которыми владеет каждый игрок, и разницу между этими двумя значениями.</p>
<p>Следующим шагом является правильная обработка ходов: учитывая доску и клетку, на которые нужно перейти, обновите доску, чтобы отразить эффекты перемещения игрока на эту клетку. Это означает перебрасывание фигур противника. Одно из проектных решений состоит в том, будет ли процедура, выполняющая ходы, <code>make-move</code>, отвечать за проверку условий ошибки. Я решил, что <code>make-move</code> предполагает, что будет принят законный ход. Таким образом, стратегия может использовать эту функцию для исследования последовательности ходов, которые заведомо допустимы, без замедления <code>make-move</code>. Конечно, чтобы убедиться, что перемещение законно, потребуются отдельные процедуры. Здесь мы вводим два термина: <em>valid/действительный</em> ход - это тот, который синтаксически правильный: целое число от 11 до 88, которое не выходит за пределы доски. <em>legal/законный</em> ход - это допустимый ход в пустую клетку, который перевернет хотя бы одного противника. Вот код:</p>
<div class="fragment"><div class="line">(defun valid-p (move)</div><div class="line">  &quot;Valid moves are numbers in the range 11-88 that end in 1-8.&quot;</div><div class="line">  (and (integerp move) (&lt;= 11 move 88) (&lt;= 1 (mod move 10) 8)))</div><div class="line"></div><div class="line">(defun legal-p (move player board)</div><div class="line">  &quot;A Legal move must be into an empty square, and it must</div><div class="line">  flip at least one opponent piece.&quot;</div><div class="line">  (and (eql (bref board move) empty)</div><div class="line">       (some #&#39;(lambda (dir) (would-flip? move player board dir))</div><div class="line">             all-directions)))</div><div class="line"></div><div class="line">(defun make-move (move player board)</div><div class="line">  &quot;Update board to reflect move by player&quot;</div><div class="line">  ;; First make the move, then make any flips</div><div class="line">  (setf (bref board move) player)</div><div class="line">  (dolist (dir all-directions)</div><div class="line">    (make-flips move player board dir))</div><div class="line">  board)</div></div><!-- fragment --><p>Теперь все, что нам нужно, это <code>make-flips</code>. Для этого мы ищем во всех направлениях фишку <em>в скобках</em>: фигура, принадлежащая игроку, который делает ход, которая бутербродирует(находиться в рядах фигур противника) цепочку фигур противника Если в этом направлении нет фишек соперника или если перед фишкой игрока попадает пустая или внешняя фишка, то броски не производятся. Обратите внимание, что <code>would-flip?</code> - это полупредикат, который возвращает false, если никакие перевороты не будут выполнены в данном направлении, и возвращает клетку фигуры "в скобках", если таковая имеется.</p>
<div class="fragment"><div class="line">(defun make-flips (move player board dir)</div><div class="line">  &quot;Make any flips in the given direction.&quot;</div><div class="line">  (let ((bracketer (would-flip? move player board dir)))</div><div class="line">    (when bracketer</div><div class="line">      (loop for c from (+ move dir) by dir until (eql c bracketer)</div><div class="line">            do (setf (bref board c) player)))))</div><div class="line"></div><div class="line">(defun would-flip? (move player board dir)</div><div class="line">  &quot;Would this move result in any flips in this direction?</div><div class="line">  If so, return the square number of the bracketing piece.&quot;</div><div class="line">  ;; A flip occurs if, starting at the adjacent square, c, there</div><div class="line">  ;; is a string of at least one opponent pieces, bracketed by</div><div class="line">  ;; one of player&#39;s pieces</div><div class="line">  (let ((c (+ move dir)))</div><div class="line">    (and (eql (bref board c) (opponent player))</div><div class="line">         (find-bracketing-piece (+ c dir) player board dir))))</div><div class="line"></div><div class="line">(defun find-bracketing-piece (square player board dir)</div><div class="line">  &quot;Return the square number of the bracketing piece.&quot;</div><div class="line">  (cond ((eql (bref board square) player) square)</div><div class="line">        ((eql (bref board square) (opponent player))</div><div class="line">         (find-bracketing-piece (+ square dir) player board dir))</div><div class="line">        (t nil)))</div></div><!-- fragment --><p>Наконец, мы можем написать функцию, которая действительно отслеживает игру. Но сначала перед нами стоит еще один важный выбор: как мы будем представлять игрока? Мы уже различали фигуры черных и белых, но еще не решили, как запрашивать ходы черных или белых. Я предпочитаю представлять стратегии игрока как функции. Каждая функция принимает два аргумента: цвет для перемещения (черный или белый) и текущую доску. Функция должна возвращать допустимый номер хода.</p>
<div class="fragment"><div class="line">(defun othello (bl-strategy wh-strategy</div><div class="line">                &amp;optional (print t) (minutes 30))</div><div class="line">  &quot;Play a game of othello.  Return the score, where a positive</div><div class="line">  difference means black, the first player, wins.&quot;</div><div class="line">  (let ((board (initial-board))</div><div class="line">        (clock (make-array (+ 1 (max black white))</div><div class="line">                           :initial-element</div><div class="line">                           (* minutes 60</div><div class="line">                              internal-time-units-per-second))))</div><div class="line">    (catch &#39;game-over</div><div class="line">      (loop for *move-number* from 1</div><div class="line">            for player = black then (next-to-play board player print)</div><div class="line">            for strategy = (if (eql player black)</div><div class="line">                               bl-strategy</div><div class="line">                               wh-strategy)</div><div class="line">            until (null player)</div><div class="line">            do (get-move strategy player board print clock))</div><div class="line">      (when print</div><div class="line">        (format t &quot;~&amp;The game is over.  Final result:&quot;)</div><div class="line">        (print-board board clock))</div><div class="line">      (count-difference black board))))</div></div><!-- fragment --><p>Мы должны иметь возможность определять, кто будет играть следующим в любой момент. Правила гласят, что игроки ходят по очереди, но если у одного игрока нет разрешенных ходов, другой может двигаться снова. Когда ни один из них не имеет возможности сделать ход, игра окончена. Обычно это происходит из-за того, что не остается пустых квадратов, но иногда это происходит и раньше в игре. Побеждает игрок, у которого в конце игры будет больше фигур. Если ни у одного игрока нет преимущества, игра заканчивается вничью.</p>
<div class="fragment"><div class="line">(defun next-to-play (board previous-player print)</div><div class="line">  &quot;Compute the player to move next, or NIL if nobody can move.&quot;</div><div class="line">  (let ((opp (opponent previous-player)))</div><div class="line">    (cond ((any-legal-move? opp board) opp)</div><div class="line">          ((any-legal-move? previous-player board)</div><div class="line">           (when print</div><div class="line">             (format t &quot;~&amp;~c has no moves and must pass.&quot;</div><div class="line">                     (name-of opp)))</div><div class="line">           previous-player)</div><div class="line">          (t nil))))</div><div class="line"></div><div class="line">(defun any-legal-move? (player board)</div><div class="line">  &quot;Does player have any legal moves in this position?&quot;</div><div class="line">  (some #&#39;(lambda (move) (legal-p move player board))</div><div class="line">        all-squares))</div></div><!-- fragment --><p>Обратите внимание, что аргумент <code>print</code> (of <code>othello</code>, <code>next-to-play</code>, и ниже, <code>get-move</code>) определяет, будет ли напечатана информация о ходе игры. Для интерактивной игры <code>print</code> должен быть истинным, но также можно играть в "пакетную" игру с <code>print</code>, установленным в false.</p>
<p>В <code>get-move</code> ниже вызывается функция strategy(стратегии) игрока, чтобы определить его ход. Выявляются незаконные ходы, и правильные ходы сообщаются, когда <code>print</code> имеет значение true. В функцию strategy передается число, представляющее игрока, который должен ходить (черный или белый), и копия доски. Если бы мы прошли <em>настоящую</em> игровую доску, функция могла бы обмануть, меняя фигуры на доске!</p>
<div class="fragment"><div class="line">(defun get-move (strategy player board print)</div><div class="line">    &quot;Call the player&#39;s strategy function to get a move.</div><div class="line">    Keep calling until a legal move is made.&quot;</div><div class="line">    (when print (print-board board))</div><div class="line">    (let ((move (funcall strategy player (copy-board board))))</div><div class="line">        (cond</div><div class="line">            ((and (valid-p move) (legal-p move player board))</div><div class="line">              (when print</div><div class="line">                  (format t &quot;~&amp;~c moves to ~d.&quot; (name-of player) move))</div><div class="line">              (make-move move player board))</div><div class="line">            (t (warn &quot;Illegal move: ~d&quot; move)</div><div class="line">                (get-move strategy player board print)))))</div></div><!-- fragment --><p>Здесь мы определяем две простые стратегии:</p>
<div class="fragment"><div class="line">(defun human (player board)</div><div class="line">    &quot;A human player for the game of Othello&quot;</div><div class="line">    (declare (ignore board))</div><div class="line">    (format t &quot;~&amp;~c to move: &quot; (name-of player))</div><div class="line">    (read))</div><div class="line"></div><div class="line">(defun random-strategy (player board)</div><div class="line">    &quot;Make any legal move.&quot;</div><div class="line">    (random-elt (legal-moves player board)))</div><div class="line"></div><div class="line">(defun legal-moves (player board)</div><div class="line">    &quot;Returns a list of legal moves for player&quot;</div><div class="line">    (loop for move in all-squares</div><div class="line">        when (legal-p move player board) collect move))</div></div><!-- fragment --><p>Теперь мы можем играть в эту игру. Выражение</p>
<p><code>(othello #'human #'human)</code> позволит двум людям играть друг против друга. В качестве альтернативы <code>(othello #'random-strategy #'human)</code> позволит нам сопоставить наш ум с особенно плохой стратегией. Остальная часть этой главы показывает, как разработать лучшую стратегию.</p>
<h2>18.3 Оценка позиций</h2>
<p>Стратегия random-move(случайного хода), конечно, плохая. Мы хотели бы сделать хороший ход, а не случайный, но пока мы не знаем, что дает ход хорошим. Единственные позиции, которые мы можем точно оценить, - это финальные позиции: когда игра окончена, мы знаем, что побеждает игрок с наибольшим количеством фигур. Это предлагает стратегию: выберите ход, который максимизирует <code>count-difference</code>(количество различий), разность фигур. Именно этим и занимается функция <code>maximize-difference</code>. Он вызывает <code>maximizer</code>, функцию высшего порядка, которая выбирает лучший ход в соответствии с произвольной оценочной функцией.</p>
<div class="fragment"><div class="line">(defun maximize-difference (player board)</div><div class="line">  &quot;A strategy that maximizes the difference in pieces.&quot;</div><div class="line">  (funcall (maximizer #&#39;count-difference) player board))</div><div class="line"></div><div class="line">(defun maximizer (eval-fn)</div><div class="line">  &quot;Return a strategy that will consider every legal move,</div><div class="line">  apply EVAL-FN to each resulting board, and choose</div><div class="line">  the move for which EVAL-FN returns the best score.</div><div class="line">  FN takes two arguments: the player-to-move and board&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (let* ((moves (legal-moves player board))</div><div class="line">             (scores (mapcar #&#39;(lambda (move)</div><div class="line">         (funcall</div><div class="line">          eval-fn</div><div class="line">          player</div><div class="line">          (make-move move player</div><div class="line">               (copy-board board))))</div><div class="line">                             moves))</div><div class="line">             (best  (apply #&#39;max scores)))</div><div class="line">        (elt moves (position best scores)))))</div></div><!-- fragment --><p><b>Упражнение 18.1</b> Поиграйте в несколько игр с <code>maximize-difference</code> против <code>random-strategy</code> и <code>human</code>. Насколько хороша <code>maximize-difference</code>?</p>
<p>Те, кто завершит это упражнение, быстро увидят, что игрок <code>maximize-difference</code> лучше, чем случайный, и может даже победить игроков-людей в своей первой или второй игре. Но большинство людей способны совершенствоваться, научившись извлекать выгоду из чрезмерно жадной игры <code>maximize-difference</code>(максимизировать разницу). Люди узнают, что, например, крайние клетки ценны, потому что игрок, доминирующий на краях, может окружить противника, в то время как захватить край трудно. Особенно это касается угловых клеток, которые невозможно отбить.</p>
<p>Используя эти знания, умный игрок может временно пожертвовать фишками, чтобы получить крайние и угловые поля в краткосрочной перспективе и отыграть фишки в долгосрочной перспективе. Мы можем аппроксимировать некоторые из этих рассуждений с помощью оценочной функции <code>weighted-squares</code>(взвешенных клеток). Как и <code>count-difference</code>, она складывает все фишки игрока и вычитает противников, но каждая фишка взвешивается в соответствии с занимаемой ею клеткой. Квадраты с гранями имеют высокий вес, угловые квадраты еще выше, а квадраты, прилегающие к углам и краям, имеют отрицательный вес, потому что занятие этих квадратов часто дает противнику возможность захватить желаемый квадрат. <a href="#f0025">Рисунок 18.4</a> показывает стандартную номенклатуру краевых клеток: X, A, B и C. В общем, следует избегать клеток X и C, потому что их взятие дает противнику шанс занять угол. Функция оценки <code>weighted-squares</code>(взвешенных клеток) отражает это.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter18/f18-04.jpg" alt="f18-04"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 18.4: Названия краевых клеток </td></tr>
</table>
<div class="fragment"><div class="line">(defparameter *weights*</div><div class="line">  &#39;#(0   0   0  0  0  0  0   0   0 0</div><div class="line">     0 120 -20 20  5  5 20 -20 120 0</div><div class="line">     0 -20 -40 -5 -5 -5 -5 -40 -20 0</div><div class="line">     0  20  -5 15  3  3 15  -5  20 0</div><div class="line">     0   5  -5  3  3  3  3  -5   5 0</div><div class="line">     0   5  -5  3  3  3  3  -5   5 0</div><div class="line">     0  20  -5 15  3  3 15  -5  20 0</div><div class="line">     0 -20 -40 -5 -5 -5 -5 -40 -20 0</div><div class="line">     0 120 -20 20  5  5 20 -20 120 0</div><div class="line">     0   0   0  0  0  0  0   0   0 0))</div><div class="line"></div><div class="line">(defun weighted-squares (player board)</div><div class="line">  &quot;Sum of the weights of player&#39;s squares minus opponent&#39;s.&quot;</div><div class="line">  (let ((opp (opponent player)))</div><div class="line">    (loop for i in all-squares</div><div class="line">          when (eql (bref board i) player)</div><div class="line">          sum (aref *weights* i)</div><div class="line">          when (eql (bref board i) opp)</div><div class="line">          sum (- (aref *weights* i)))))</div></div><!-- fragment --><p><b>Упражнение 18.2</b> Сравните стратегии, вычислив две формы ниже. Что просходит? Это хороший тест, чтобы определить, какая стратегия лучше?</p>
<div class="fragment"><div class="line">(othello (maximizer #&#39;weighted-squares)</div><div class="line">                  (maximizer #&#39;count-difference) nil)</div><div class="line">(othello (maximizer #&#39;count-difference)</div><div class="line">                  (maximizer #&#39;weighted-squares) nil)</div></div><!-- fragment --><h2>18.4 Поиск Ahead(Заглядывая Вперед): Minimax</h2>
<p>Даже стратегия weighted-squares(взвешенных клеток) не подходит для опытного игрока. Есть два способа улучшить стратегию. Во-первых, мы могли бы изменить функцию оценки, чтобы учесть больше информации. Но даже не изменяя функцию оценки, мы можем улучшить стратегию, заглянув вперед. Вместо того чтобы выбирать ход, который сразу приводит к наивысшему количеству очков, мы также можем рассмотреть возможные ответы оппонента, наши ответы на эти ответы и так далее. Просматривая несколько уровней ходов, мы можем избежать потенциальной катастрофы и найти хорошие ходы, которые не были очевидны сразу.</p>
<p>Другой способ взглянуть на функцию <code>maximizer</code> - как на функцию поиска, которая ищет только один уровень или *ply/*слой, в глубину:</p>
<div class="image">
<img src="images/chapter18/u18-01.jpg" alt="u18-01"/>
</div>
<p>Верхняя часть дерева - это текущая позиция на доске, а квадраты ниже указывают на возможные ходы. Функция <code>maximizer</code> оценивает каждый из них и выбирает лучший ход, который подчеркнут на диаграмме.</p>
<p>Теперь посмотрим, как может пройти трехслойный поиск(3-ply). Первый шаг - применить <code>maximizer</code> к позициям чуть выше нижней части дерева. Предположим, мы получили следующие значения:</p>
<div class="image">
<img src="images/chapter18/u18-02.jpg" alt="u18-02"/>
</div>
<p>Каждая позиция показана как имеющая два возможных допустимых хода, что нереально, но позволяет разместить диаграмму на странице. В реальной игре обычно от пяти до десяти разрешенных ходов на позицию. Значения в листьях дерева были вычислены с применением функции оценки, в то время как значения на один уровень выше были вычислены с помощью <code>maximizer</code>. В результате мы знаем, какой наш лучший ход для любой из четырех позиций чуть выше нижней части дерева.</p>
<p>Поднимаясь на уровень выше, наступает очередь соперника двигаться. Мы можем предположить, что противник выберет ход, который принесет нам минимальную ценность, которая будет максимальной ценностью для оппонента. Таким образом, противник может выбрать 10- и 9-значные позиции, избегая 20- и 23-значных позиций.</p>
<div class="image">
<img src="images/chapter18/u18-03.jpg" alt="u18-03"/>
</div>
<p>Теперь наша очередь двигаться снова, поэтому мы снова применяем <code>maximizer</code>, чтобы получить окончательное значение позиции верхнего уровня:</p>
<div class="image">
<img src="images/chapter18/u18-04.jpg" alt="u18-04"/>
</div>
<p>Если оппонент играет так, как ожидалось, мы всегда будем следовать за левой ветвью дерева и окажемся на позиции со значением 10. Если противник будет играть иначе, мы окажемся в более выгодной позиции.</p>
<p>Этот вид поиска традиционно называется поиском <em>minimax</em>(минимакс) из-за альтернативного применения функции <code>maximizer</code> и гипотетической функции <code>minimizer</code>. Обратите внимание, что функция оценки просматривает только позиции листьев в дереве. Значение(ценность) всех остальных позиций определяется минимизацией и максимизацией.</p>
<p>Мы почти готовы написать алгоритм алгоритм minimax, но сначала нам нужно принять несколько конструктивных решений. Во-первых, мы могли бы написать две функции, <code>minimax</code> и <code>maximin</code>, которые соответствуют анализу двух игроков. Однако проще написать одну функцию, которая максимизирует ценность позиции для конкретного игрока. Другими словами, добавляя игрока в качестве параметра, мы избавляемся от необходимости писать две идентичные функции.</p>
<p>Во-вторых, мы должны решить, собираемся ли мы написать поисковую программу общего минимаксного или специфического для Отелло поисковика. Я выбрал второй вариант из соображений эффективности, а также потому, что есть некоторые специфические для Отелло осложнения, которые необходимо учитывать. Во-первых, возможно, что у игрока не будет разрешенных ходов. В этом случае мы хотим продолжить поиски движения противника. Если у соперника тоже нет ходов, то игра окончена, и значение(ценность) позиции можно окончательно определить путем подсчета фишек.</p>
<p>В-третьих, нам нужно определить взаимодействие между нормальной функцией оценки и этой окончательной оценкой, которая происходит по окончании игры. Мы могли бы настоять на том, чтобы каждая функция оценки определяла, когда игра окончена, и выполняла правильные вычисления. Но это перегружает оценочные функции и может привести к бесполезной проверке в конце игры. Вместо этого я реализовал отдельную функцию оценки <code>final-value</code>, которая возвращает 0 для ничьей, большое положительное число для выигрыша и большое отрицательное число для проигрыша. Поскольку арифметика фиксированных целых чисел(fixnum) наиболее эффективна, используются константы <code>most-positive-fixnum</code> и <code>most-negative-fixnum</code>. Функции оценки должны быть аккуратны, чтобы возвращать числа, которые находятся в этом диапазоне. Все оценочные функции в этой главе будут в пределах допустимого диапазона, если фиксированные числа(fixnums) составляют 20 или более бит.</p>
<p>В турнире важно не только, кто выиграет и проиграет, но и насколько. Если бы мы пытались максимизировать вероятность победы, тогда <code>final-value</code> было бы изменено, чтобы включить небольшой коэффициент для окончательной разницы.</p>
<div class="fragment"><div class="line">(defconstant winning-value most-positive-fixnum)</div><div class="line">(defconstant losing-value  most-negative-fixnum)</div><div class="line"></div><div class="line">(defun final-value (player board)</div><div class="line">  &quot;Is this a win, loss, or draw for player?&quot;</div><div class="line">  (case (signum (count-difference player board))</div><div class="line">    (-1 losing-value)</div><div class="line">    ( 0 0)</div><div class="line">    (+1 winning-value)))</div></div><!-- fragment --><p>И, наконец, в-четвертых, нам нужно определиться с параметрами функции minimax. Как и другие функции оценки, она требует, для перемещения(хода) - игрока и текущей доски, в качестве параметров. Также требуется указание количества слоев для поиска(ply) и функция статической оценки, применяемой к позициям листьев. Таким образом, minimax будет функцией четырех аргументов. Что она вернет? Она должна вернуть лучший ход, но она также должна вернуть ценность(значение) этого хода в соответствии со статической функцией оценки. Для этого мы используем несколько значений.</p>
<div class="fragment"><div class="line">(defun minimax (player board ply eval-fn)</div><div class="line">  &quot;Find the best move, for PLAYER, according to EVAL-FN,</div><div class="line">  searching PLY levels deep and backing up values.&quot;</div><div class="line">  (if (= ply 0)</div><div class="line">      (funcall eval-fn player board)</div><div class="line">      (let ((moves (legal-moves player board)))</div><div class="line">        (if (null moves)</div><div class="line">            (if (any-legal-move? (opponent player) board)</div><div class="line">                (- (minimax (opponent player) board</div><div class="line">                            (- ply 1) eval-fn))</div><div class="line">                (final-value player board))</div><div class="line">            (let ((best-move nil)</div><div class="line">                  (best-val nil))</div><div class="line">              (dolist (move moves)</div><div class="line">                (let* ((board2 (make-move move player</div><div class="line">                                          (copy-board board)))</div><div class="line">                       (val (- (minimax</div><div class="line">                                 (opponent player) board2</div><div class="line">                                 (- ply 1) eval-fn))))</div><div class="line">                  (when (or (null best-val)</div><div class="line">                            (&gt; val best-val))</div><div class="line">                    (setf best-val val)</div><div class="line">                    (setf best-move move))))</div><div class="line">              (values best-val best-move))))))</div></div><!-- fragment --><p>Функция <code>minimax</code> не может использоваться как функция стратегии как есть, потому что она принимает слишком много аргументов и возвращает слишком много значений. Функционал <code>minimax-searcher</code> возвращает подходящую стратегию. Помните, что стратегия - это функция двух аргументов: игрока и доски. <code>get-move</code> отвечает за передачу правильных аргументов функции, поэтому стратегии не нужно беспокоиться о том, откуда эти аргументы.</p>
<div class="fragment"><div class="line">(defun minimax-searcher (ply eval-fn)</div><div class="line">  &quot;A strategy that searches PLY levels and then uses EVAL-FN.&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (multiple-value-bind (value move)</div><div class="line">          (minimax player board ply eval-fn)</div><div class="line">        (declare (ignore value))</div><div class="line">        move)))</div></div><!-- fragment --><p>Мы можем протестировать минимаксную стратегию и увидеть, что поиск вперед на 3-и слоя действительно лучше, чем смотреть только на 1-й слой. Я показываю только окончательный результат, который демонстрирует, что иметь возможность смотреть вперед - действительно преимущество:</p>
<div class="fragment"><div class="line">&gt; (othello (minimax-searcher 3 #&#39;count-difference)</div><div class="line">                  (maximizer #&#39;count-difference))</div><div class="line">...</div></div><!-- fragment --><p><code>The game is over. Final result:</code></p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8      [@=53 0=0 (+53)]</div><div class="line">10 @ @ @ @ @ @ @ @</div><div class="line">20 @ @ @ @ @ @ @ @</div><div class="line">30 @ @ @ @ @ @ @ @</div><div class="line">40 @ @ @ @ @ @ @ @</div><div class="line">50 @ @ @ @ @ @ @ @</div><div class="line">60 . . @ @ @ @ @ @</div><div class="line">70 . . . @ @ @ @ @</div><div class="line">80 . . . . @ @ . .</div></div><!-- fragment --><h2>18.5 Интеллектуальный поиск: альфа-бета поиск</h2>
<p>Проблема с полным минимаксным(minimax) поиском в том, что он учитывает слишком много позиций. Он смотрит(проверяет) на каждую линию игры, в том числе и на множество невероятных. К счастью, есть способ найти оптимальную линию игры, не обращая внимания на все возможные позиции. Вернемся к нашему знакомому дереву поиска:</p>
<div class="image">
<img src="images/chapter18/u18-05.jpg" alt="u18-05"/>
</div>
<p>Здесь мы отметили определенные позиции вопросительными знаками. Идея состоит в том, что все дерево поиска оценивается как 10 независимо от значения позиций с меткой ?*i*. Рассмотрим позицию с меткой ?1. Не имеет значения, как оценивается эта позиция, потому что противник всегда будет выбирать игру в сторону 10-й позиции, чтобы избежать возможности 15-й позиции. Таким образом, мы можем прервать поиск на этом этапе и не рассматривать ?- позицию. Такой вид отсечки исторически назывался отсечкой <em>beta</em>(бета).</p>
<p>Теперь рассмотрим позицию ?4. Не имеет значения, как оценивается эта позиция, потому что мы всегда будем предпочитать выбирать позицию 10 на левой ветви, а не давать противнику возможность играть в позиции 9. Это отсечка <em>alpha</em>(альфа). Обратите внимание, что она отсекает целое поддерево позиций под ним (помеченных ?2 и ?3).</p>
<p>В общем, мы отслеживаем два параметра, которые ограничивают истинное значение текущей позиции. Нижняя граница - это значение, которое, как мы знаем, мы можем достичь, выбрав определенную линию игры. Идея состоит в том, что нам даже не нужно рассматривать ходы, которые приведут к более низкому значению, чем это. Нижнюю границу традиционно называют <em>альфа</em>, но мы будем называть ее <code>achievable</code>(достижимой). Верхняя граница представляет значение, которого может достичь противник, выбрав определенную линию игры. Оно было названо <em>beta</em>, но мы будем называть его <code>cutoff</code>(отсечением). Опять же, идея состоит в том, что нам не нужно рассматривать ходы с более высоким значением(оценкой), чем эта (потому что тогда противник избежит хода, который так хорош для нас). Алгоритм alpha-beta(альфа-бета) просто minimax(минимаксный), но без необходимости некоторых ненужных оценок, отсеченных этими двумя параметрами.</p>
<p>На более глубоких деревьях с более высокими коэффициентами ветвления можно обрезать гораздо больше оценок. В общем, дерево глубины <em>d</em> и коэффициента ветвления <em>b</em> требует <em>bd</em> оценок для полного minimax(минимакса) и всего лишь <em>b**d</em>/2 оценок с минимаксом альфа-бета.</p>
<p>Чтобы реализовать поиск по альфа-бета, мы добавляем еще два параметра к функции <code>minimax</code> и переименовываем ее в <code>alpha-beta</code>. <code>achievable</code>(достижимо) - это лучший результат, который может набрать игрок; это то, что мы хотим максимизировать. <code>cutoff</code>(обрезка) - это значение, при превышении которого противник выберет другую ветвь дерева, таким образом, оставшаяся часть текущего уровня дерева не будет иметь значения. Проверка <code>until (&gt;= achievable cutoff)</code> в предпоследней строке <code>minimax</code> выполняет отсечку; все остальные изменения просто включают правильную передачу параметров.</p>
<div class="fragment"><div class="line">(defun alpha-beta (player board achievable cutoff ply eval-fn)</div><div class="line">  &quot;Find the best move, for PLAYER, according to EVAL-FN,</div><div class="line">  searching PLY levels deep and backing up values,</div><div class="line">  using cutoffs whenever possible.&quot;</div><div class="line">  (if (= ply 0)</div><div class="line">      (funcall eval-fn player board)</div><div class="line">      (let ((moves (legal-moves player board)))</div><div class="line">        (if (null moves)</div><div class="line">            (if (any-legal-move? (opponent player) board)</div><div class="line">                (- (alpha-beta (opponent player) board</div><div class="line">                               (- cutoff) (- achievable)</div><div class="line">                               (- ply 1) eval-fn))</div><div class="line">                (final-value player board))</div><div class="line">            (let ((best-move (first moves)))</div><div class="line">              (loop for move in moves do</div><div class="line">                (let* ((board2 (make-move move player</div><div class="line">                                          (copy-board board)))</div><div class="line">                       (val (- (alpha-beta</div><div class="line">                                 (opponent player) board2</div><div class="line">                                 (- cutoff) (- achievable)</div><div class="line">                                 (- ply 1) eval-fn))))</div><div class="line">                  (when (&gt; val achievable)</div><div class="line">                    (setf achievable val)</div><div class="line">                    (setf best-move move)))</div><div class="line">                until (&gt;= achievable cutoff))</div><div class="line">              (values achievable best-move))))))</div><div class="line"></div><div class="line">(defun alpha-beta-searcher (depth eval-fn)</div><div class="line">  &quot;A strategy that searches to DEPTH and then uses EVAL-FN.&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (multiple-value-bind (value move)</div><div class="line">          (alpha-beta player board losing-value winning-value</div><div class="line">                      depth eval-fn)</div><div class="line">        (declare (ignore value))</div><div class="line">        move)))</div></div><!-- fragment --><p>Следует подчеркнуть, что <code>alpha-beta</code> вычисляет тот же результат, что и версия <code>minimax</code> с полным поиском. Единственное преимущество отсечки - ускорение поиска за счет меньшего количества позиций.</p>
<h2>18.6 Анализ некоторых игр</h2>
<p>Сейчас хорошее время, чтобы остановиться и проанализировать, куда мы ушли. Мы продемонстрировали программу, которая может играть в <em>legal</em>(легальную) игру Отелло, а также некоторые стратегии, которые могут сыграть или не сыграть в <em>хорошую</em> игру. Сначала мы рассмотрим некоторые отдельные игры, чтобы увидеть ошибки, допущенные некоторыми стратегиями, а затем сгенерируем некоторую статистику для серий игр.</p>
<p>Насколько хорошо взвешивание клеток? Мы можем сравнить его со стратегией максимального увеличения количества деталей. Такая стратегия, конечно, была бы идеальной, если бы она могла смотреть в будущее до конца игры, но скорость наших компьютеров ограничивает нас поиском только несколькими слоями, даже с отсечками. Рассмотрим следующую игру, в которой черные максимизируют разницу в количестве фигур, а белые максимизируют взвешенную сумму клеток. Оба ищут на глубину 4 слоя:</p>
<div class="fragment"><div class="line">&gt; (othello (alpha-beta-searcher 4 #&#39;count-difference)</div><div class="line">                      (alpha-beta-searcher 4 #&#39;weighted-squares))</div></div><!-- fragment --><p>Черные могут резко увеличить разницу в фигурах по ходу игры. После 17 ходов у белых остается только одна фигура:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=20 0=1 (+19)]</div><div class="line">10 0 @ . . . . . .</div><div class="line">20 . @ . . . @ @ .</div><div class="line">30 @ @ @ @ @ @ . .</div><div class="line">40 . @ . @ @ . . .</div><div class="line">50 @ @ @ @ @ @ . .</div><div class="line">60 . . @ . . . . .</div><div class="line">70 . . . . . . . .</div><div class="line">80 . . . . . . . .</div></div><!-- fragment --><p>Несмотря на отставание на 19 очков, белые на самом деле находятся в хорошей позиции, потому что фигура в углу безопасна и угрожает многим фигурам черных. Белые могут сохранять хорошую позицию, численно сильно отставая от черных, как показано в следующих позициях позже в партии:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=32 0=15 (+17)]</div><div class="line">10 0 0 0 0 @ @ 0 0</div><div class="line">20 @ @ 0 @ @ @ @ @</div><div class="line">30 @ @ 0 0 @ 0 @ @</div><div class="line">40 0 0 @ @ @ @ @ @</div><div class="line">50 @ 0 @ @ @ @ . .</div><div class="line">60 @ @ 0 @ @ 0 . .</div><div class="line">70 @ . . @ @ . . .</div><div class="line">80 . . . . . . . .</div><div class="line">      1 2 3 4 5 6 7 8    [@=34 0=19 (+15)]</div><div class="line">10 0 0 0 0 @ @ 0 0</div><div class="line">20 @ @ 0 @ @ @ @ @</div><div class="line">30 @ @ 0 0 @ 0 @ @</div><div class="line">40 0 @ 0 @ @ @ @ @</div><div class="line">50 0 @ 0 @ @ @ @ .</div><div class="line">60 0 @ 0 @ @ @ . .</div><div class="line">70 0 @ @ @ @ . . .</div><div class="line">80 0 @ 0 . . . . .</div></div><!-- fragment --><p>После некоторого компромисса белые навсегда получают преимущество, захватив восемь фигур на ходу на клетке 85 на предпоследнем ходу игры:</p>
<div class="fragment"><div class="line">          1 2 3 4 5 6 7 8    [@=31 0=30 (+1)]</div><div class="line">    10 0 0 0 0 @ @ 0 0</div><div class="line">    20 @ @ 0 0 @ @ @ 0</div><div class="line">    30 @ @ 0 0 0 @ @ 0</div><div class="line">    40 0 @ 0 0 0 @ @ 0</div><div class="line">    50 0 @ 0 @ 0 @ @ 0</div><div class="line">    60 0 @ 0 @ @ @ @ 0</div><div class="line">    70 0 @ @ @ @ @ 0 0</div><div class="line">    80 0 @ @ @ . . .0</div><div class="line">0 moves to 85.</div><div class="line">          1 2 3 4 5 6 7 8    [@=23 0=39 (-16)]</div><div class="line">    10 0 0 0 0 @ @ 0 0</div><div class="line">    20 @ @ 0 0 @ @ @ 0</div><div class="line">    30 @ @ 0 0 0 @ @ 0</div><div class="line">    40 0 @ 0 0 0 @ @ 0</div><div class="line">    50 0 @ 0 @ 0 @ @ 0</div><div class="line">    60 0 @ 0 @ 0 @ 0 0</div><div class="line">    70 0 @ @ 0 0 0 0 0</div><div class="line">    80 0 0 0 0 0 . . 0</div><div class="line">@ moves to 86.</div><div class="line">          1 2 3 4 5 6 7 8    [@=26 0=37 (-11)]</div><div class="line">    10 0 0 0 0 @ @ 0 0</div><div class="line">    20 @ @ 0 0 @ @ @ 0</div><div class="line">    30 @ @ 0 0 0 @ @ 0</div><div class="line">    40 0 @ 0 0 0 @ @ 0</div><div class="line">    50 0 @ 0 @ 0 @ @ 0</div><div class="line">    60 0 @ 0 @ 0 @ 0 0</div><div class="line">    70 0 @ @ 0 @ @ 0 0</div><div class="line">    80 0 0 0 0 0 @ . 0</div><div class="line">0 moves to 87.</div></div><!-- fragment --><p><code>The game is over. Final result:</code></p>
<div class="fragment"><div class="line">          1 2 3 4 5 6 7 8    [@=24 0=40 (-16)]</div><div class="line">    10 0 0 0 0 @ @ 0 0</div><div class="line">    20 @ @ 0 0 @ @ @ 0</div><div class="line">    30 @ @ 0 0 0 @ @ 0</div><div class="line">    40 0 @ 0 0 0 @ @ 0</div><div class="line">    50 0 @ 0 @ 0 @ @ 0</div><div class="line">    60 0 @ 0 @ 0 @ 0 0</div><div class="line">    70 0 @ @ 0 @ 0 0 0</div><div class="line">    80 0 0 0 0 0 0 0 0</div><div class="line">-16</div></div><!-- fragment --><p>Белые выигрывают 16 фигурами. Стратегия черных была слишком жадной: черные были готовы отказаться от позиции (все четыре угла и все поля, кроме четырех) ради временного материального выигрыша.</p>
<p>Увеличение глубины поиска не компенсирует ошибочную функцию оценки. В следующей игре глубина поиска черных увеличивается до 6 слоев, а у белых остается 4. Происходит то же самое, хотя судьба черных разворачивается немного дольше.</p>
<div class="fragment"><div class="line">&gt; (othello (alpha-beta-searcher 6 #&#39;count-difference)</div><div class="line">                      (alpha-beta-searcher 4 #&#39;weighted-squares))</div></div><!-- fragment --><p>Черные медленно наращивают перевес:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=21 0=8 (+13)]</div><div class="line">10 . . @ @ @ @ @ .</div><div class="line">20 . @ . @ 0 @ . .</div><div class="line">30 0 @ @ 0 @ 0 0 .</div><div class="line">40 . @ . @ 0 @ 0 .</div><div class="line">50 . @ @ @ @ @ . .</div><div class="line">60 . @ . @ . 0 . .</div><div class="line">70 . . . . . . . .</div><div class="line">80 . . . . . . . .</div></div><!-- fragment --><p>Но в этот момент белые имеют свободный доступ к верхнему левому углу и через этот угол угрожают захватить весь верхний край. Тем не менее, черные сохраняют материальное преимущество в ходе игры:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=34 0=11 (+23)]</div><div class="line">10 0 . @ @ @ @ @ .</div><div class="line">20 . 0 0 @ @ @ . .</div><div class="line">30 0 @ 0 0 @ @ @ @</div><div class="line">40 @ @ @ @ 0 @ @ .</div><div class="line">50 @ @ @ @ @ 0 @ .</div><div class="line">60 @ @ @ @ @ @ 0 0</div><div class="line">70 @ . . @ . . @ 0</div><div class="line">80 . . . . . . . .</div></div><!-- fragment --><p>Но в конечном итоге стратегия белых с взвешенными полями выходит вперед:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=23 0=27 (-4)]</div><div class="line">10 0 0 0 0 0 0 0 0</div><div class="line">20 @ @ 0 @ @ @ . .</div><div class="line">30 0 @ 0 0 @ @ @ @</div><div class="line">40 0 @ 0 @ 0 @ @ .</div><div class="line">50 0 @ 0 @ @ 0 @ .</div><div class="line">60 0 0 0 @ @ @ 0 0</div><div class="line">70 0 . 0 @ . . @ 0</div><div class="line">80 0 . . . . . . .</div></div><!-- fragment --><p>и умеет держаться за победу:</p>
<div class="fragment"><div class="line">          1 2 3 4 5 6 7 8    [@=24 0=40 (-16)]</div><div class="line">    10 0 0 0 0 0 0 0 0</div><div class="line">    20 @ @ 0 @ 0 0 @ @</div><div class="line">    30 0 @ 0 0 @ @ @ @</div><div class="line">    40 0 @ 0 0 @ @ @ 0</div><div class="line">    50 0 0 @ @ 0 @ 0 0</div><div class="line">    60 0 0 0 @ 0 @ @ 0</div><div class="line">    70 0 0 0 0 @ @ 0 0</div><div class="line">    80 0 0 0 0 0 @ @ 0</div><div class="line">-16</div></div><!-- fragment --><p>Это показывает, что перебор не панацея. Хотя полезно иметь возможность искать глубже, можно получить больше выгоды, сделав функцию оценки более точной. Есть много проблем с функцией вычисления взвешенных клеток. Снова рассмотрим эту позицию из первой игры выше:</p>
<div class="fragment"><div class="line">      1 2 3 4 5 6 7 8    [@=20 0=1 (+19)]</div><div class="line">10 0 @ . . . . . .</div><div class="line">20 . @ . . . @ @ .</div><div class="line">30 @ @ @ @ @ @ . .</div><div class="line">40 . @ . @ @ . . .</div><div class="line">50 @ @ @ @ @ @ . .</div><div class="line">60 . @ . . . . . .</div><div class="line">70 . . . . . . . .</div><div class="line">80 . . . . . . . .</div></div><!-- fragment --><p>Здесь белые, используя стратегию взвешенных полей, предпочли сыграть 66. Вероятно, это ошибка, поскольку 13 расширит доминирование белых на верхнем краю и позволит белым играть снова (поскольку у черных не будет разрешенных ходов). К сожалению, белые отвергают этот ход, прежде всего потому, что поле 12 имеет вес -20. Таким образом, есть сдерживающий фактор для взятия этой клетки. Но 12 имеет вес -20, потому что брать такое поле(клетку), когда угол пуст, - плохая идея - тогда у оппонента будет шанс захватить угол, вернув себе также клетку 12. Таким образом, мы хотим, чтобы у клеток вроде 12 была отрицательная оценка, когда угол пуст, но не тогда, когда он уже занят. Функция оценки <code>modified-weighted-squares</code> делает именно это.</p>
<div class="fragment"><div class="line">(defun modified-weighted-squares (player board)</div><div class="line">  &quot;Like WEIGHTED-SQUARES, but don&#39;t take off for moving</div><div class="line">  near an occupied corner.&quot;</div><div class="line">  (let ((w (weighted-squares player board)))</div><div class="line">    (dolist (corner &#39;(11 18 81 88))</div><div class="line">      (when (not (eql (bref board corner) empty))</div><div class="line">        (dolist (c (neighbors corner))</div><div class="line">          (when (not (eql (bref board c) empty))</div><div class="line">            (incf w (* (- 5 (aref *weights* c))</div><div class="line">                       (if (eql (bref board c) player)</div><div class="line">                           +1 -1)))))))</div><div class="line">    w))</div><div class="line"></div><div class="line">(let ((neighbor-table (make-array 100 :initial-element nil)))</div><div class="line">  ;; Initialize the neighbor table</div><div class="line">  (dolist (square all-squares)</div><div class="line">    (dolist (dir all-directions)</div><div class="line">      (if (valid-p (+ square dir))</div><div class="line">          (push (+ square dir)</div><div class="line">                (aref neighbor-table square)))))</div><div class="line"></div><div class="line">  (defun neighbors (square)</div><div class="line">    &quot;Return a list of all squares adjacent to a square.&quot;</div><div class="line">    (aref neighbor-table square)))</div></div><!-- fragment --><h2>18.7 Турнирная версия Отелло</h2>
<p>Хотя функция <code>othello</code> служит прекрасным модератором для случайной игры, есть два момента, которые необходимо исправить для игры на уровне турнира. Во-первых, турнирные игры проходят в строго ограниченное время: игрок, которому требуется более 30 минут, чтобы сделать все ходы, выбывает из игры. Во-вторых, в стандартной нотации игр Отелло используются названия клеток в диапазоне от a1 до h8, а не в диапазоне от 11 до 88, который мы использовали до сих пор. a1 - левый верхний угол, a8 - левый нижний угол, а h8 - правый нижний угол. Мы можем написать процедуры для перевода между этой нотацией и той, которую мы использовали, создав таблицу имен клеток.</p>
<div class="fragment"><div class="line">(let ((square-names</div><div class="line">        (cross-product #&#39;symbol</div><div class="line">                       &#39;(? a b c d e f g h ?)</div><div class="line">                       &#39;(? 1 2 3 4 5 6 7 8 ?))))</div><div class="line"></div><div class="line">  (defun h8-&gt;88 (str)</div><div class="line">    &quot;Convert from alphanumeric to numeric square notation.&quot;</div><div class="line">    (or (position (string str) square-names :test #&#39;string-equal)</div><div class="line">        str))</div><div class="line"></div><div class="line">  (defun 88-&gt;h8 (num)</div><div class="line">    &quot;Convert from numeric to alphanumeric square notation.&quot;</div><div class="line">    (if (valid-p num)</div><div class="line">        (elt square-names num)</div><div class="line">        num)))</div><div class="line"></div><div class="line">(defun cross-product (fn xlist ylist)</div><div class="line">  &quot;Return a list of all (fn x y) values.&quot;</div><div class="line">  (mappend #&#39;(lambda (y)</div><div class="line">               (mapcar #&#39;(lambda (x) (funcall fn x y))</div><div class="line">                       xlist))</div><div class="line">           ylist))</div></div><!-- fragment --><p>Обратите внимание, что эти подпрограммы возвращают свой ввод без изменений, если он не является одним из ожидаемых значений. Это позволяет выполнять команды, отличные от перехода к определенной клетке. Например, мы добавим функцию, которая распознает <code>resign</code>(отставку) как ход.</p>
<p>Чтобы читать ходы в этом формате, нужно немного изменить игрока <code>human</code>-человека. Пока мы это сделаем, мы также распечатаем список возможных ходов:</p>
<div class="fragment"><div class="line">(defun human (player board)</div><div class="line">  &quot;A human player for the game of Othello&quot;</div><div class="line">  (format t &quot;~&amp;~c to move ~a: &quot; (name-of player)</div><div class="line">          (mapcar #&#39;88-&gt;h8 (legal-moves player board)))</div><div class="line">  (h8-&gt;88 (read)))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter18/f18-05.jpg" alt="f18-05"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 18.5: Глоссарий турнирной версии Отелло </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<p>Функция <code>othello</code> не должна беспокоиться об обозначениях, но она должна отслеживать время. Мы создаем новую структуру данных, <code>clock</code>(часы), которая представляет собой массив целых чисел, показывающих, сколько времени (во внутренних единицах) осталось у каждого игрока. Например, (<code>aref clock black</code>) - это количество времени, которое осталось черным, чтобы сделать все свои ходы. В Паскале мы бы объявили массив часов как <code>array[black..white]</code>, но в Common Lisp все массивы начинаются с нуля, поэтому нам нужен массив из трех элементов, чтобы разрешить индекс <code>black</code>, который равен 2.</p>
<p>clock(Часы) передаётся командам <code>get-move</code> и <code>print-board</code>, но в остальыми не используются. Я мог бы усложнить основной игровой цикл, добавив тесты для расплаты из-за истекшего времени и, как мы увидим позже, отставки любого игрока. Однако я чувствовал, что это значительно усложнит редко используемые опции. Вместо этого я оборачиваю весь игровой цикл вместе с вычислением финального счета в специальную форму <code>catch</code>. Затем, если get-move встречает forfeit(поражение/расплату) или отставку, она может <code>throw</code>(выбросить) соответствующий окончательный счет: 64 или -64, в зависимости от того, какой игрок потерпел поражение.</p>
<div class="fragment"><div class="line">(defvar *move-number* 1 &quot;The number of the move to be played&quot;)</div><div class="line"></div><div class="line">(defun othello (bl-strategy wh-strategy</div><div class="line">                &amp;optional (print t) (minutes 30))</div><div class="line">  &quot;Play a game of othello.  Return the score, where a positive</div><div class="line">  difference means black, the first player, wins.&quot;</div><div class="line">  (let ((board (initial-board))</div><div class="line">        (clock (make-array (+ 1 (max black white))</div><div class="line">                           :initial-element</div><div class="line">                           (* minutes 60</div><div class="line">                              internal-time-units-per-second))))</div><div class="line">    (catch &#39;game-over</div><div class="line">      (loop for *move-number* from 1</div><div class="line">            for player = black then (next-to-play board player print)</div><div class="line">            for strategy = (if (eql player black)</div><div class="line">                               bl-strategy</div><div class="line">                               wh-strategy)</div><div class="line">            until (null player)</div><div class="line">            do (get-move strategy player board print clock))</div><div class="line">      (when print</div><div class="line">        (format t &quot;~&amp;The game is over.  Final result:&quot;)</div><div class="line">        (print-board board clock))</div><div class="line">      (count-difference black board))))</div></div><!-- fragment --><p>Теперь стратегии должны соответствовать правилу ограничения по времени, поэтому они могут захотеть посмотреть на оставшееся время. Вместо того, чтобы передавать clock(часы) в качестве аргумента стратегии, я решил сохранить их в специальной переменной <code>*clock*</code>. Новая версия <code>othello</code> также отслеживает <code>*move-number*</code>(номер хода). Его также можно было передавать в функции стратегии в качестве параметра. Но добавление этих дополнительных аргументов потребует внесения изменений во все стратегии, которые мы разработали до сих пор. Сохраняя информацию в специальных переменных, стратегии, которые хотят видеть, могут смотреть на часы или число ходов, но другие стратегии не должны знать о них.</p>
<p>У нас все еще есть проблема безопасности - мы не хотим, чтобы стратегия могла обнулять оставшееся время противника и, таким образом, выигрывала игру. Таким образом, мы используем <code>*clock*</code> только как копию "настоящих" игровых часов. Функция <code>replace</code> копирует реальные часы(clock) в <em>clock</em>, а также копирует реальную доску в <code>*board*</code>.</p>
<div class="fragment"><div class="line">(defvar *clock* (make-array 3) &quot;A copy of the game clock&quot;)</div><div class="line">(defvar *board* (initial-board) &quot;A copy of the game board&quot;)</div><div class="line"></div><div class="line">(defun get-move (strategy player board print clock)</div><div class="line">  &quot;Call the player&#39;s strategy function to get a move.</div><div class="line">  Keep calling until a legal move is made.&quot;</div><div class="line">  ;; Note we don&#39;t pass the strategy function the REAL board.</div><div class="line">  ;; If we did, it could cheat by changing the pieces on the board.</div><div class="line">  (when print (print-board board clock))</div><div class="line">  (replace *clock* clock)</div><div class="line">  (let* ((t0 (get-internal-real-time))</div><div class="line">         (move (funcall strategy player (replace *board* board)))</div><div class="line">         (t1 (get-internal-real-time)))</div><div class="line">    (decf (elt clock player) (- t1 t0))</div><div class="line">    (cond</div><div class="line">      ((&lt; (elt clock player) 0)</div><div class="line">       (format t &quot;~&amp;~c has no time left and forfeits.&quot;</div><div class="line">               (name-of player))</div><div class="line">       (THROW &#39;game-over (if (eql player black) -64 64)))</div><div class="line">      ((eq move &#39;resign)</div><div class="line">       (THROW &#39;game-over (if (eql player black) -64 64)))</div><div class="line">      ((and (valid-p move) (legal-p move player board))</div><div class="line">       (when print</div><div class="line">         (format t &quot;~&amp;~c moves to ~a.&quot;</div><div class="line">                 (name-of player) (88-&gt;h8 move)))</div><div class="line">       (make-move move player board))</div><div class="line">      (t (warn &quot;Illegal move: ~a&quot; (88-&gt;h8 move))</div><div class="line">         (get-move strategy player board print clock)))))</div></div><!-- fragment --><p>Наконец, функция <code>print-board</code> должна распечатать оставшееся время для каждого игрока; для этого требуется вспомогательная функция для получения количества минут и секунд из временного интервала внутреннего формата. Обратите внимание, что мы делаем аргументы необязательными, чтобы при отладке можно было просто сказать (<code>print-board</code>), чтобы увидеть текущую ситуацию. Также обратите внимание на опцию эзотерического формата: <code>"~2, '0d"</code> печатает десятичное число, используя как минимум два разряда, с заполнением слева нулями.</p>
<div class="fragment"><div class="line">(defun print-board (&amp;optional (board *board*) clock)</div><div class="line">  &quot;Print a board, along with some statistics.&quot;</div><div class="line">  ;; First print the header and the current score</div><div class="line">  (format t &quot;~2&amp;    a b c d e f g h   [~c=~2a ~c=~2a (~@d)]&quot;</div><div class="line">          (name-of black) (count black board)</div><div class="line">          (name-of white) (count white board)</div><div class="line">          (count-difference black board))</div><div class="line">  ;; Print the board itself</div><div class="line">  (loop for row from 1 to 8 do</div><div class="line">        (format t &quot;~&amp;  ~d &quot; row)</div><div class="line">        (loop for col from 1 to 8</div><div class="line">              for piece = (bref board (+ col (* 10 row)))</div><div class="line">              do (format t &quot;~c &quot; (name-of piece))))</div><div class="line">  ;; Finally print the time remaining for each player</div><div class="line">  (when clock</div><div class="line">    (format t &quot;  [~c=~a ~c=~a]~2&amp;&quot;</div><div class="line">            (name-of black) (time-string (elt clock black))</div><div class="line">            (name-of white) (time-string (elt clock white)))))</div><div class="line"></div><div class="line">(defun time-string (time)</div><div class="line">  &quot;Return a string representing this internal time in min:secs.&quot;</div><div class="line">  (multiple-value-bind (min sec)</div><div class="line">      (floor (round time internal-time-units-per-second) 60)</div><div class="line">    (format nil &quot;~2d:~2,&#39;0d&quot; min sec)))</div></div><!-- fragment --><h2>18.8 Игра в серию игр</h2>
<p>Одной игры недостаточно, чтобы установить, что одна стратегия лучше другой. Следующая функция позволяет двум стратегиям соревноваться в серии игр:</p>
<div class="fragment"><div class="line">(defun othello-series (strategy1 strategy2 n-pairs)</div><div class="line">  &quot;Play a series of 2*n-pairs games, swapping sides.&quot;</div><div class="line">  (let ((scores</div><div class="line">          (loop repeat n-pairs</div><div class="line">             for random-state = (make-random-state)</div><div class="line">             collect (othello strategy1 strategy2 nil)</div><div class="line">             do (setf *random-state* random-state)</div><div class="line">             collect (- (othello strategy2 strategy1 nil)))))</div><div class="line">    ;; Return the number of wins (1/2 for a tie),</div><div class="line">    ;; the total of the point differences, and the</div><div class="line">    ;; scores themselves, all from strategy1&#39;s point of view.</div><div class="line">    (values (+ (count-if #&#39;plusp scores)</div><div class="line">               (/ (count-if #&#39;zerop scores) 2))</div><div class="line">            (apply #&#39;+ scores)</div><div class="line">            scores)))</div></div><!-- fragment --><p>Давайте посмотрим, что произойдет, когда мы используем её, чтобы сопоставить две функции взвешивания клеток друг с другом в серии из десяти игр:</p>
<div class="fragment"><div class="line">&gt;(othello-series</div><div class="line">        (alpha-beta-searcher 2 #&#39;modified-weighted-squares)</div><div class="line">        (alpha-beta-searcher 2 #&#39;weighted-squares) 5)</div><div class="line">0</div><div class="line">60</div><div class="line">(-28 40 -28 40 -28 40 -28 40 -28 40)</div></div><!-- fragment --><p>Что-то тут подозрительно - повторяются одни и те же оценки. Небольшое раздумье показывает, почему: ни одна стратегия не имеет случайного компонента, поэтому одна и та же игра была сыграна пять раз, причем одна стратегия все время была первой, и игра была сыграна пять раз, когда другая стратегия была первой! Более точная оценка относительной ценности двух стратегий может быть получена, если начинать каждую игру с некоторой случайной позиции и играть оттуда.</p>
<p>Подумайте на минутку, как бы вы спроектировали запуск серии игр, начиная со случайной позиции. Одна из возможностей - изменить функцию <code>othello</code>, чтобы она принимала необязательный аргумент, указывающий начальное состояние доски. Затем можно изменить <code>othello-series</code>, чтобы каким-то образом генерировать случайную доску и передавать ее в <code>othello</code>. Хотя такой подход осуществим, он означает изменение двух существующих рабочих функций, а также написание другой функции, <code>generate-random-board</code>. Но мы не можем генерировать просто любую случайную доску: это должна быть легальная доска, поэтому она должна будет вызвать <code>othello</code> и каким-то образом заставить ее остановиться до завершения игры.</p>
<p>Альтернативный вариант - оставить в покое и <code>othello</code>, и <code>othello-series</code>, и построить на их основе еще одну функцию, которая работает, передавая две новые стратегии: стратегии, которые делают случайный ход в течение первых нескольких ходов, а затем возвращаются в нормальное указанное поведение. Это лучшее решение, потому что оно использует существующие функции, а не модифицирует их, и потому что не требует новых функций, кроме <code>switch-strategies</code>(переключения стратегий), которая может оказаться полезной для других целей, и <code>random-othello-series</code>, которая больше ничего не делает. кроме вызова <code>othello-series</code> с соответствующими аргументами.</p>
<div class="fragment"><div class="line">(defun random-othello-series (strategy1 strategy2</div><div class="line">                              n-pairs &amp;optional (n-random 10))</div><div class="line">  &quot;Play a series of 2*n games, starting from a random position.&quot;</div><div class="line">  (othello-series</div><div class="line">    (switch-strategies #&#39;random-strategy n-random strategy1)</div><div class="line">    (switch-strategies #&#39;random-strategy n-random strategy2)</div><div class="line">    n-pairs))</div><div class="line"></div><div class="line">(defun switch-strategies (strategy1 m strategy2)</div><div class="line">  &quot;Make a new strategy that plays strategy1 for m moves,</div><div class="line">  then plays according to strategy2.&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (funcall (if (&lt;= *move-number* m) strategy1 strategy2)</div><div class="line">               player board)))</div></div><!-- fragment --><p>Есть проблема с такими сериями: может случиться так, что одна из стратегий просто дает лучший результат в случайных позициях. Более справедливым испытанием было бы сыграть по две игры в каждой случайной позиции, по одной с каждой стратегией, играющей первой. Один из способов сделать это - изменить <code>othello-series</code> так, чтобы она сохраняла случайное состояние перед игрой в первую игру пары, а затем восстанавливала сохраненное случайное состояние перед началом второй игры. Таким образом, будет продублирована одна и та же случайная позиция.</p>
<div class="fragment"><div class="line">(defun othello-series (strategy1 strategy2 n-pairs)</div><div class="line">  &quot;Play a series of 2*n-pairs games, swapping sides.&quot;</div><div class="line">  (let ((scores</div><div class="line">          (loop repeat n-pairs</div><div class="line">             for random-state = (make-random-state)</div><div class="line">             collect (othello strategy1 strategy2 nil)</div><div class="line">             do (setf *random-state* random-state)</div><div class="line">             collect (- (othello strategy2 strategy1 nil)))))</div><div class="line">    ;; Return the number of wins (1/2 for a tie),</div><div class="line">    ;; the total of the point differences, and the</div><div class="line">    ;; scores themselves, all from strategy1&#39;s point of view.</div><div class="line">    (values (+ (count-if #&#39;plusp scores)</div><div class="line">               (/ (count-if #&#39;zerop scores) 2))</div><div class="line">            (apply #&#39;+ scores)</div><div class="line">            scores)))</div></div><!-- fragment --><p>Теперь мы можем провести более значимый тест. Далее стратегия взвешенных клеток выигрывает в 4 из 10 игр против модифицированной стратегии, проигрывая в общей сложности 76 фишек, с указанными фактическими очками.</p>
<div class="fragment"><div class="line">&gt; (random-othello-series</div><div class="line">        (alpha-beta-searcher 2 #&#39;weighted-squares)</div><div class="line">        (alpha-beta-searcher 2#&#39;modified-weighted-squares)</div><div class="line">        5)</div><div class="line">4</div></div><!-- fragment --><ul>
<li><code>76</code></li>
</ul>
<div class="fragment"><div class="line">(-8 -40 22 -30 10 -10 12 -18 4 -18)</div></div><!-- fragment --><p>Функция <code>random-othello-series</code> полезна для сравнения двух стратегий. Когда можно сравнить более двух стратегий одновременно, может быть полезна следующая функция:</p>
<div class="fragment"><div class="line">(defun round-robin (strategies n-pairs &amp;optional</div><div class="line">                    (n-random 10) (names strategies))</div><div class="line">  &quot;Play a tournament among the strategies.</div><div class="line">  N-PAIRS = games each strategy plays as each color against</div><div class="line">  each opponent.  So with N strategies, a total of</div><div class="line">  N*(N-1)*N-PAIRS games are played.&quot;</div><div class="line">  (let* ((N (length strategies))</div><div class="line">         (totals (make-array N :initial-element 0))</div><div class="line">         (scores (make-array (list N N)</div><div class="line">                             :initial-element 0)))</div><div class="line">    ;; Play the games</div><div class="line">    (dotimes (i N)</div><div class="line">      (loop for j from (+ i 1) to (- N 1) do</div><div class="line">          (let* ((wins (random-othello-series</div><div class="line">                         (elt strategies i)</div><div class="line">                         (elt strategies j)</div><div class="line">                         n-pairs n-random))</div><div class="line">                 (losses (- (* 2 n-pairs) wins)))</div><div class="line">            (incf (aref scores i j) wins)</div><div class="line">            (incf (aref scores j i) losses)</div><div class="line">            (incf (aref totals i) wins)</div><div class="line">            (incf (aref totals j) losses))))</div><div class="line">    ;; Print the results</div><div class="line">    (dotimes (i N)</div><div class="line">      (format t &quot;~&amp;~a~20T ~4f: &quot; (elt names i) (elt totals i))</div><div class="line">      (dotimes (j N)</div><div class="line">        (format t &quot;~4f &quot; (if (= i j) &#39;---</div><div class="line">                             (aref scores i j)))))))</div></div><!-- fragment --><p>Вот сравнение пяти стратегий, которые проводят поиск только 1-ом слое:</p>
<div class="fragment"><div class="line">(defun mobility (player board)</div><div class="line">  &quot;The number of moves a player has.&quot;</div><div class="line">  (length (legal-moves player board)))</div><div class="line"></div><div class="line">&gt; (round-robin</div><div class="line">    (list (maximizer #&#39;count-difference)</div><div class="line">                (maximizer #&#39;mobility)</div><div class="line">                (maximizer #&#39;weighted-squares)</div><div class="line">                (maximizer #&#39;modified-weighted-squares)</div><div class="line">                #&#39;random-strategy)</div><div class="line">    5 10</div><div class="line">    &#39;(count-difference mobility weighted modified-weighted random))</div><div class="line">COUNT-DIFFERENCE      12.5:   --- 3.0 2.5 0.0 7.0</div><div class="line">MOBILITY                      20.5:   7.0 --- 1.5 5.0 7.0</div><div class="line">WEIGHTED                      28.0:   7.5 8.5 --- 3.0 9.0</div><div class="line">MODIFIED-WEIGHTED    31.5: 10.0 5.0 7.0 --- 9.5</div><div class="line">RANDOM                            7.5:   3.0 3.0 1.0 0.5 ---</div></div><!-- fragment --><p>Параметр <code>n-pairs</code> равен 5, что означает, что каждая стратегия играет пять игр черными и пять белыми против каждой из четырех других стратегий, всего 40 игр для каждой стратегии и 100 игр в целом. В первой строке выходных данных говорится, что стратегия count-difference(подсчет различий) выиграла 12,5 из 40 игр, в том числе 3 - против стратегии mobility(мобильности), 2,5 - против weighted(взвешенной) стратегии, ни одной - против (modified weighted)модифицированной взвешенной и 7 - против (random)случайной стратегии. Тот факт, что случайная стратегия позволяет выиграть 7,5 из 40 игр, указывает на то, что другие стратегии не слишком сильны. Теперь мы Увидим, что происходит, когда глубина поиска увеличивается до 4 слоев (это займет некоторое время):</p>
<div class="fragment"><div class="line">&gt; (round-robin</div><div class="line">    (list (alpha-beta-searcher 4 #&#39;count-difference)</div><div class="line">                (alpha-beta-searcher 4 #&#39;weighted-squares)</div><div class="line">                (alpha-beta-searcher 4 #&#39;modified-weighted-squares)</div><div class="line">                #&#39;random-strategy)</div><div class="line">    5 10</div><div class="line">    &#39;(count-difference weighted modified-weighted random))</div><div class="line">COUNT-DIFFERENCE      12.0:   --- 2.0 0.0 10.0</div><div class="line">WEIGHTED                      23.5:   8.0 --- 5.5 10.0</div><div class="line">MODIFIED-WEIGHTED    24.5: 10.0 4.5 --- 10.0</div><div class="line">RANDOM                            0.0:   0.0 0.0 0.0   ---</div></div><!-- fragment --><p>Здесь случайная стратегия не выигрывает ни в одной игре - это признак того, что другие стратегии что-то делают правильно. Обратите внимание, что модифицированная стратегия взвешенных клеток имеет лишь небольшое преимущество перед стратегией взвешеных клеток, и на самом деле они проиграла свою серию личных встреч, четыре игры против пяти, с одной ничьей. Так что не ясно, какая стратегия лучше.</p>
<p>В выводе не разбиваются выигрыши по черным или белым, а также не указываются значения набранных очков. Я чувствовал, что это слишком загромождает вывод, но вы можете добавить эту информацию. Оказывается, белые выигрывают в 23 (и разыгрывают 1) из 40 партий, сыгранных между 4-х слойными стратегиями поиска. Обычно <code>Отелло</code> - довольно сбалансированная игра, потому что у черных есть преимущество в том, что они ходят первыми, а белые обычно играют последними. Понятно, что эти стратегии плохо работают в дебютном матче, но последние четыре слоя они играют отлично. Это может объяснить небольшое преимущество белых или статистическую аберрацию.</p>
<h2>18.9 Более эффективный поиск</h2>
<p>Альфа-бета(alpha-beta) отсечки работают, когда мы сделали хороший ход, а другой ход оказывается не таким хорошим. Таким образом, мы сможем сделать отсечки раньше, если сначала рассмотрим хорошие ходы. Наш текущий алгоритм перебирает список <code>legal-moves</code>(разрешенных ходов), но <code>legal-moves</code> не пытается каким-либо образом упорядочивать ходы. Мы будем называть это стратегией <em>random-ordering</em>(случайного упорядочения) (даже если порядок не является случайным в целом, всегда сначала рассматривается 11, затем 12 и т. Д.).</p>
<p>Один из способов сначала попытаться сделать хорошие ходы - это сначала поискать в поле(клетку) с большим весом. Так как <code>legal-moves</code> рассматривает квадраты в порядке, определенном <code>all-squares</code>, все, что нам нужно сделать, это переопределить список <code>all-squares</code> <a href="#fn0025">3</a>:</p>
<div class="fragment"><div class="line">(defconstant all-squares</div><div class="line">    (sort (loop for i from 11 to 88</div><div class="line">                  when (&lt;= 1 (mod i 10) 8) collect i)</div><div class="line">            #&#39;&gt; :key #&#39;(lambda (sq) (elt *weights* sq))))</div></div><!-- fragment --><p>Теперь угловые клетки автоматически будут рассматриваться первыми, а за ними - другие клетки с большим весом. Мы называем это стратегией <em>static-ordering</em>, потому что порядок не является случайным, но он не меняется в зависимости от ситуации.</p>
<p>Более осознанный способ попытаться вначале создать хорошие ходы - это отсортировать ходы в соответствии с функцией оценки. Это означает, что нужно делать больше оценок. Ранее оценивались только доски на листьях дерева поиска. Теперь нам нужно оценить каждую доску. Чтобы избежать оценки доски более одного раза, мы составляем структуру, называемую <code>node</code>(узлом), которая содержит доску, клетку, которая была взята для получения этой доски, и оценочное значение этой доски. Поиск такой же, за исключением того, что узлы передаются вместо досок, и узлы сортируются по их значению.</p>
<div class="fragment"><div class="line">(defstruct (node) square board value)</div><div class="line"></div><div class="line">(defun alpha-beta-searcher2 (depth eval-fn)</div><div class="line">  &quot;Return a strategy that does A-B search with sorted moves.&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (multiple-value-bind (value node)</div><div class="line">          (alpha-beta2</div><div class="line">            player (make-node :board board</div><div class="line">                              :value (funcall eval-fn player board))</div><div class="line">            losing-value winning-value depth eval-fn)</div><div class="line">        (declare (ignore value))</div><div class="line">        (node-square node))))</div><div class="line"></div><div class="line">(defun alpha-beta2 (player node achievable cutoff ply eval-fn)</div><div class="line">  &quot;A-B search, sorting moves by eval-fn&quot;</div><div class="line">  ;; Returns two values: achievable-value and move-to-make</div><div class="line">  (if (= ply 0)</div><div class="line">      (values (node-value node) node)</div><div class="line">      (let* ((board (node-board node))</div><div class="line">             (nodes (legal-nodes player board eval-fn)))</div><div class="line">        (if (null nodes)</div><div class="line">            (if (any-legal-move? (opponent player) board)</div><div class="line">                (values (- (alpha-beta2 (opponent player)</div><div class="line">                                        (negate-value node)</div><div class="line">                                        (- cutoff) (- achievable)</div><div class="line">                                        (- ply 1) eval-fn))</div><div class="line">                        nil)</div><div class="line">                (values (final-value player board) nil))</div><div class="line">            (let ((best-node (first nodes)))</div><div class="line">              (loop for move in nodes</div><div class="line">                    for val = (- (alpha-beta2</div><div class="line">                                   (opponent player)</div><div class="line">                                   (negate-value move)</div><div class="line">                                   (- cutoff) (- achievable)</div><div class="line">                                   (- ply 1) eval-fn))</div><div class="line">                    do (when (&gt; val achievable)</div><div class="line">                         (setf achievable val)</div><div class="line">                         (setf best-node move))</div><div class="line">                    until (&gt;= achievable cutoff))</div><div class="line">              (values achievable best-node))))))</div><div class="line"></div><div class="line">(defun negate-value (node)</div><div class="line">  &quot;Set the value of a node to its negative.&quot;</div><div class="line">  (setf (node-value node) (- (node-value node)))</div><div class="line">  node)</div><div class="line"></div><div class="line">(defun legal-nodes (player board eval-fn)</div><div class="line">  &quot;Return a list of legal moves, each one packed into a node.&quot;</div><div class="line">  (let ((moves (legal-moves player board)))</div><div class="line">    (sort (map-into</div><div class="line">            moves</div><div class="line">            #&#39;(lambda (move)</div><div class="line">                (let ((new-board (make-move move player</div><div class="line">                                            (copy-board board))))</div><div class="line">                  (make-node</div><div class="line">                    :square move :board new-board</div><div class="line">                    :value (funcall eval-fn player new-board))))</div><div class="line">            moves)</div><div class="line">          #&#39;&gt; :key #&#39;node-value)))</div></div><!-- fragment --><p>(Обратите внимание на использование функции <code>map-into</code>. Это часть ANSI Common Lisp, но если она не является частью вашей реализации, определение приведено на <a href="B9780080571157500248.xhtml#p857">страница 857</a>.)</p>
<p>В следующей таблице сравнивается производительность стратегии случайного порядка, стратегии сортировки и стратегии статического порядка в ходе одной игры. Все стратегии ищут 6 слоев в глубину. В таблице измеряется количество исследованных досок, количество тех досок, которые были оценены (во всех случаях функция оценки была <code>modified-weighted-squares</code>(модифицированных взвешенных клеток)) и время в секундах для вычисления хода.</p>
<p>| random | order | | sorted | order | | static | order | | </p><table class="doxtable">
<tr>
<th>boards </th><th>evals </th><th>secs </th><th>boards </th><th>evals </th><th>secs </th><th>boards </th><th>evals </th><th>secs  </th></tr>
<tr>
<td>13912 </td><td>10269 </td><td>69 </td><td>5556 </td><td>5557 </td><td>22 </td><td>2365 </td><td>1599 </td><td>19 </td></tr>
<tr>
<td>9015 </td><td>6751 </td><td>56 </td><td>6571 </td><td>6572 </td><td>25 </td><td>3081 </td><td>2188 </td><td>18 </td></tr>
<tr>
<td>9820 </td><td>7191 </td><td>46 </td><td>11556 </td><td>11557 </td><td>45 </td><td>5797 </td><td>3990 </td><td>31 </td></tr>
<tr>
<td>4195 </td><td>3213 </td><td>20 </td><td>5302 </td><td>5303 </td><td>17 </td><td>2708 </td><td>2019 </td><td>15 </td></tr>
<tr>
<td>10890 </td><td>7336 </td><td>60 </td><td>10709 </td><td>10710 </td><td>38 </td><td>3743 </td><td>2401 </td><td>23 </td></tr>
<tr>
<td>13325 </td><td>9679 </td><td>63 </td><td>6431 </td><td>6432 </td><td>24 </td><td>4222 </td><td>2802 </td><td>24 </td></tr>
<tr>
<td>13163 </td><td>9968 </td><td>58 </td><td>9014 </td><td>9015 </td><td>32 </td><td>6657 </td><td>4922 </td><td>31 </td></tr>
<tr>
<td>16642 </td><td>12588 </td><td>70 </td><td>9742 </td><td>9743 </td><td>33 </td><td>10421 </td><td>7488 </td><td>51 </td></tr>
<tr>
<td>18016 </td><td>13366 </td><td>80 </td><td>11002 </td><td>11003 </td><td>37 </td><td>9508 </td><td>7136 </td><td>41 </td></tr>
<tr>
<td>23295 </td><td>17908 </td><td>104 </td><td>15290 </td><td>15291 </td><td>48 </td><td>26435 </td><td>20282 </td><td>111 </td></tr>
<tr>
<td>34120 </td><td>25895 </td><td>143 </td><td>22994 </td><td>22995 </td><td>75 </td><td>20775 </td><td>16280 </td><td>78 </td></tr>
<tr>
<td>56117 </td><td>43230 </td><td>224 </td><td>46883 </td><td>46884 </td><td>150 </td><td>48415 </td><td>36229 </td><td>203 </td></tr>
<tr>
<td>53573 </td><td>41266 </td><td>209 </td><td>62252 </td><td>62253 </td><td>191 </td><td>37803 </td><td>28902 </td><td>148 </td></tr>
<tr>
<td>43943 </td><td>33184 </td><td>175 </td><td>31039 </td><td>31040 </td><td>97 </td><td>33180 </td><td>24753 </td><td>133 </td></tr>
<tr>
<td>51124 </td><td>39806 </td><td>193 </td><td>45709 </td><td>45710 </td><td>135 </td><td>19297 </td><td>15064 </td><td>69 </td></tr>
<tr>
<td>24743 </td><td>18777 </td><td>105 </td><td>20003 </td><td>20004 </td><td>65 </td><td>15627 </td><td>11737 </td><td>66 </td></tr>
<tr>
<td>1.0 </td><td>1.0 </td><td>1.0 </td><td>.81 </td><td>1.07 </td><td>.62 </td><td>.63 </td><td>.63 </td><td>.63 </td></tr>
</table>
<p>В последних двух строках таблицы приведены средние и средние значения, нормализованные к производительности стратегии случайного упорядочения. Стратегия сортировки занимает только 62% времени стратегии случайного порядка, а статическая сортировка занимает 63%. Этим временам не следует слишком доверять, потому что крупномасштабная сборка мусора происходила во второй части игры, и это могло отбросить время. Доска и количество оценок могут быть лучшими индикаторами, и они оба показывают, что стратегия статического упорядочивания работает лучше всего.</p>
<p>Ранее я сказал, что альфа-бета поиск делает больше отсечок, когда ему вначале предоставляются лучшии ходы. На самом деле правда в том, что он делает больше отсечок, когда ему сначала предлагаются ходы, которые, по мнению оценочной функции, лучше. В этом случае функция оценки и стратегия статического упорядочивания полностью согласны с тем, какие ходы являются лучшими, поэтому неудивительно, что статическое упорядочение так хорошо работает. Поскольку мы разрабатываем функции оценки, которые отличаются от подхода взвешенных клеток, нам придется снова проводить эксперименты, чтобы убедиться, что статическое упорядочение по-прежнему является лучшим.</p>
<h2>18.10 Предварительный цикл окупается</h2>
<p>В прогрессивном городе Беркли, штат Калифорния, существует сильная программа переработки стекла, бумаги и алюминия, которые в противном случае были бы выброшены как мусор. В 1989 году Беркли ввел новую программу предварительной переработки: потребителей поощряют избегать покупки продуктов, которые поставляются в экологически неэффективной упаковке.</p>
<p>В вашей системе Lisp также есть программа утилизации: сборщик мусора Lisp автоматически перерабатывает любое неиспользуемое хранилище. Однако эта программа требует определенных затрат, и вы, как потребитель, можете повысить производительность за счет предварительной обработки своих данных. Не покупайте расточительные структуры данных, когда можно использовать более простые или использовать повторно. Вы, программист на Лиспе, возможно, не сможете спасти влажные леса или озоновый слой, но вы сможете сэкономить драгоценное время процессора.</p>
<p>Ранее мы видели, что процедуры поиска просматривают десятки тысяч досок за ход. В настоящее время каждая позиция на доске создается заново с помощью <code>copy-board</code> и вскоре после этого удаляется. Мы могли бы избежать образования всего этого мусора, повторно используя одну и ту же доску для каждого слоя. Нам все равно нужно сохранить доску из предыдущего слоя, чтобы использовать ее, когда поиск возобновится. Таким образом, нужен вектор досок. Далее мы предполагаем, что мы никогда не будем искать глубже 40 слоев. Это безопасное предположение, так как даже самые быстрые программы Othello могут выполнять поиск только около 15 слоев, прежде чем закончится время.</p>
<div class="fragment"><div class="line">(defvar *ply-boards*</div><div class="line">  (apply #&#39;vector (loop repeat 40 collect (initial-board))))</div></div><!-- fragment --><p>Теперь, когда мы резко ограничили количество необходимых досок, мы можем пересмотреть реализацию досок. Вместо того, чтобы иметь доску как вектор фишек(vector of pieces) (для экономии места), мы можем захотеть реализовать доски как векторы байтов или полных слов. В некоторых реализациях доступ к элементам таких векторов осуществляется быстрее. (В других реализациях разницы нет.)</p>
<p>Реализация с использованием вектора досок будет выполнена в следующем разделе. Обратите внимание, что есть еще одна альтернатива: использовать только одну доску и обновлять ее, делая и убирая ходы. Это хорошая альтернатива в такой игре, как шахматы, где ход меняет только два поля. В Отелло многие клетки можно изменить ходом, поэтому скопировать всю доску и сделать ход не так уж и плохо.</p>
<p>Следует отметить, что стоит разобраться с проблемой копирования позиции с одной доски на другую. Функция <code>replace</code> копирует одну последовательность (или ее часть) в другую, но это обобщенная функция, которая может работать медленно. В частности, если каждый элемент платы имеет всего 2 бита, тогда может быть намного быстрее использовать смещенные массивы(displaced arrays) для копирования по 32 бита за раз. Целесообразность этого подхода зависит от реализации, поэтому здесь он не рассматривается.</p>
<h2>18.11 Убийственные перемещения(ходы)</h2>
<p>В <a href="#s0050">разделе 18.9</a> мы рассмотрели возможность поиска ходов в другом порядке, пытаясь сначала найти лучшие ходы, тем самым получив больше альфа-бета отсечений. В этом разделе мы рассматриваем <em>эвристику убийцы</em>, которая гласит, что ход, который оказался хорошим в одной линии игры, вероятно, также будет хорошим в другой линии игры. Если использовать шахматы как, возможно, более знакомый пример, предположим, что я рассматриваю один ход, и он приводит к тому, что противник отвечает, взяв моего ферзя. Это убийственный ход, которого я бы хотел избежать. Поэтому, когда я рассматриваю другие возможные ходы, я хочу сразу рассмотреть возможность того, что оппонент сделает этот ход с захватом ферзя.</p>
<p>Функция <code>alpha-beta3</code> добавляет параметр <code>killer</code>, который является лучшим ходом, найденным до сих пор на текущем уровне. После того, как мы определим <code>legal-moves</code>(допустимые ходы), мы используем <code>put-first</code>, чтобы поставить убойный ход первым, если это действительно допустимый ход. Когда приходит время искать следующий уровень, мы отслеживаем лучший ход в <code>killer2</code>. Это требует отслеживания значения лучшего хода в <code>killer2-val</code>. Все остальное не изменилось, за исключением того, что мы получаем новую доску, повторно обрабатывая вектор <code>*ply-boards*</code>, а не выделяя новые.</p>
<div class="fragment"><div class="line">(defun alpha-beta3 (player board achievable cutoff ply eval-fn</div><div class="line">                    killer)</div><div class="line">  &quot;A-B search, putting killer move first.&quot;</div><div class="line">  (if (= ply 0)</div><div class="line">      (funcall eval-fn player board)</div><div class="line">      (let ((moves (put-first killer (legal-moves player board))))</div><div class="line">        (if (null moves)</div><div class="line">            (if (any-legal-move? (opponent player) board)</div><div class="line">                (- (alpha-beta3 (opponent player) board</div><div class="line">                                (- cutoff) (- achievable)</div><div class="line">                                (- ply 1) eval-fn nil))</div><div class="line">                (final-value player board))</div><div class="line">            (let ((best-move (first moves))</div><div class="line">                  (new-board (aref *ply-boards* ply))</div><div class="line">                  (killer2 nil)</div><div class="line">                  (killer2-val winning-value))</div><div class="line">              (loop for move in moves</div><div class="line">                    do (multiple-value-bind (val reply)</div><div class="line">                           (alpha-beta3</div><div class="line">                             (opponent player)</div><div class="line">                             (make-move move player</div><div class="line">                                        (replace new-board board))</div><div class="line">                             (- cutoff) (- achievable)</div><div class="line">                             (- ply 1) eval-fn killer2)</div><div class="line">                         (setf val (- val))</div><div class="line">                         (when (&gt; val achievable)</div><div class="line">                           (setf achievable val)</div><div class="line">                           (setf best-move move))</div><div class="line">                         (when (and reply (&lt; val killer2-val))</div><div class="line">                           (setf killer2 reply)</div><div class="line">                           (setf killer2-val val)))</div><div class="line">                    until (&gt;= achievable cutoff))</div><div class="line">              (values achievable best-move))))))</div><div class="line"></div><div class="line">(defun alpha-beta-searcher3 (depth eval-fn)</div><div class="line">  &quot;Return a strategy that does A-B search with killer moves.&quot;</div><div class="line">  #&#39;(lambda (player board)</div><div class="line">      (multiple-value-bind (value move)</div><div class="line">          (alpha-beta3 player board losing-value winning-value</div><div class="line">                       depth eval-fn nil)</div><div class="line">        (declare (ignore value))</div><div class="line">        move)))</div><div class="line"></div><div class="line">(defun put-first (killer moves)</div><div class="line">  &quot;Move the killer move to the front of moves,</div><div class="line">  if the killer move is in fact a legal move.&quot;</div><div class="line">  (if (member killer moves)</div><div class="line">      (cons killer (delete killer moves))</div><div class="line">      moves))</div></div><!-- fragment --><p>Другой эксперимент с одной игрой показывает, что добавление убойной эвристики к поиску статического упорядочивания (снова с 6 слоями) сокращает количество досок и оценок, а также общее время примерно на 20%. Подводя итог, альфа-бета-поиск на 6 слоях со случайным порядком занимает 105 секунд на ход (в нашем эксперименте), добавление статического упорядочения сокращает его до 66 секунд, а добавление убойных ходов к этому снова сокращает его до 52 секунд. Это не включает экономию, которую дает отсечение альфа-бета по сравнению с полным минимаксным поиском. При 6 слоях с коэффициентом разветвления 7 полный минимакс займет примерно в девять раз больше времени, чем статическое упорядочивание с убойными ходами. Экономия увеличивается с увеличением глубины. При 7-и слоях и коэффициенте ветвления 10 небольшой эксперимент показывает, что статическое упорядочение с помощью убийственных эвристик просматривает только 28 000 досок примерно за 150 секунд. Полный минимакс оценил бы 10 миллионов досок и занял бы в 350 раз больше времени. Время для полного минимакса-это оценки, основанные на количестве досок в секунду, а не на реальном эксперименте.</p>
<p>Алгоритм в этом разделе просто отслеживает один убийственный ход. Конечно, можно отслеживать более одного. Программа Отелло Билл (<a href="B9780080571157500285.xhtml#bb0715">Lee and Mahajan 1990b</a>) объединяет идею убийственных ходов с генерацией легальных ходов: она ведет список возможных ходов на каждом уровне, отсортированным по их ценности. Генератор разрешенных ходов затем просматривает этот список в отсортированном порядке.</p>
<p>Следует еще раз подчеркнуть, что вся эта работа над отсечками альфа-бета, упорядочиванием и убийственными ходами не внесла никаких изменений в выбранные ходы. Мы по-прежнему выбираем тот же ход, который был бы сделан при полном минимаксном поиске на заданную глубину, мы просто делаем это быстрее, не глядя на возможности, которые мы можем доказать, не так хороши.</p>
<h2>18.12 Программы чемпионата: Яго и Билл</h2>
<p>Как упоминалось во введении, непредсказуемость Отелло затрудняет освоение людьми игры, и поэтому программы, которые ищут глубоко, могут работать сравнительно хорошо. Фактически, в 1981 году действующий чемпион Джонатан Серф заявил: "По моему мнению, лучшие программы ... теперь равны (если не превосходят) лучших игроков-людей". Обсуждая программу Яго Розенблума (1982), Серф сказал: "Я понимаю, что Пол Розенблум заинтересован в организации матча против меня.
К сожалению, у меня очень плотный график, и я собираюсь сделать так, чтобы он оставался таким в обозримом будущем".</p>
<p>В 1989 году другая программа, Билл (<a href="B9780080571157500285.xhtml#bb0715">Ли и Махаджан, 1990</a>) победила самого лучшего американского игрока "Отелло" Брайана Роуза со счетом 56-8. Функция оценки Билла достаточно быстра для поиска 6-8 слоев в условиях турнира, но при этом настолько точна, что превосходит своего создателя, Кай-Фу Ли, при поиске только 1 слоя. (Однако Ли - только начинающий игрок в Отелло; его настоящий интерес вызывает распознавание речи; см. <a href="B9780080571157500285.xhtml#bb1285">Waibel and Lee 1991</a>.) Есть и другие программы, которые также играют на высоком уровне, но они не были описаны в литературе по искусственному интеллекту, как Яго и Билл.</p>
<p>В этом разделе мы представляем функцию оценки, основанную на функции Яго, хотя она также содержит элементы Билла, и функции оценки, написанной Эриком Вефальдом в 1989 году. Функция оценки использует две основные особенности: <em>подвижность и стабильность края</em>.</p>
<h3>Подвижность</h3>
<p>И Яго, и Билл активно используют понятие <em>mobility</em>(подвижность). Подвижность - это мера способности совершать движения; в основном, чем больше ходов можно сделать, тем лучше. Это не совсем так, потому что возможность делать плохие ходы не дает никаких преимуществ, но это полезная эвристика. Мы определяем <em>текущую подвижность</em> как количество допустимых ходов, доступных игроку, и <em>потенциальную подвижность</em> как количество пустых клеток, прилегающих к фигурам противника. К ним относятся легальные ходы. Лучшим средством измерения подвижности было бы подсчитывать только удачные ходы. Следующая функция вычисляет текущую и потенциальную подвижность игрока:</p>
<div class="fragment"><div class="line">(defun mobility (player board)</div><div class="line">  &quot;Current Mobility is the number of legal moves.</div><div class="line">  Potential mobility is the number of blank squares</div><div class="line">  adjacent to an opponent that are not legal moves.</div><div class="line">  Returns current and potential mobility for player.&quot;</div><div class="line">  (let ((opp (opponent player))</div><div class="line">        (current 0)    ; player&#39;s current mobility</div><div class="line">        (potential 0)) ; player&#39;s potential mobility</div><div class="line">    (dolist (square all-squares)</div><div class="line">      (when (eql (bref board square) empty)</div><div class="line">        (cond ((legal-p square player board)</div><div class="line">               (incf current))</div><div class="line">              ((some #&#39;(lambda (sq) (eql (bref board sq) opp))</div><div class="line">                     (neighbors square))</div><div class="line">               (incf potential)))))</div><div class="line">    (values current (+ current potential))))</div></div><!-- fragment --><h3>Стабильность края</h3>
<p>Успех в Отелло часто зависит от игры по краям, и Яго и Билл тщательно оценивают края. Анализ краев упрощается благодаря тому факту, что края практически не зависят от внутренней части доски: как только фишка помещается на край, никакие внутренние движения не могут её перевернуть. Эта независимость позволяет сделать упрощающее предположение: оценить силу края позиции, оценить каждое из четырех краев независимо, без учета внутренней части доски. Оценка может быть сделана более точной, если рассматривать X-клетки как часть края.</p>
<p>Даже оценка одного края - это трудоемкая задача, поэтому Билл и Яго компилируют оценку, составляя таблицу всех возможных положений краев. "edge"(край/ребро) согласно Биллу - это десять клеток: восемь фактических клеток с краями и две X-клетки. Поскольку каждая клетка может быть черной, белой или пустой, существует 310 или 59,049 возможных положений краев - большое, но управляемое число.</p>
<p>Значение каждой позиции края определяется путем последовательного приближения. Как и в случае минимаксного поиска, нам понадобится статическая функция оценки края, чтобы определить значение позиции края без поиска. Эта статическая функция оценки края применяется ко всем возможным позициям края, а результаты сохраняются в векторе 59,049 элементов. Статическая оценка - это просто взвешенная сумма занятых клеток с разными весами, дающимися в зависимости от того, является ли фишка стабильной или нестабильной.</p>
<p>Оценка позиции каждого края может быть улучшена процессом поиска. Яго использует однослойный поиск: учитывая позицию, учитывает все ходы, которые могут быть сделаны (включая отсутствие хода вообще). Некоторые ходы будут явно разрешены, потому что они переворачивают фигуры на краю, но другие ходы будут разрешены только в том случае, если внутри доски есть фигуры, которые нужно перевернуть. Поскольку мы рассматриваем только преимущество, мы не знаем наверняка, законны ли эти ходы. Им будет присвоена вероятность законности. Обновленная оценка позиции определяется значениями и вероятностями каждого хода. Это делается путем сортировки ходов по значению и последующего суммирования произведения значения, умноженного на вероятность того, что ход может быть сделан. Этот процесс итеративного приближения повторяется пять раз для каждой позиции. К этому моменту, как сообщает Rosenbloom, значения почти сходятся.</p>
<p>Фактически, это расширяет глубину обычного альфа-бета-поиска, включая поиск только по краю в функцию оценки. Поскольку каждая позиция края с <em>n</em> фишками оценивается как функция от позиций с <em>n</em> + 1 фишкой, поиск завершен - это неявный 10-слойный поиск.</p>
<p>Расчет стабильности края немного сложнее, чем другие функции. Первым шагом является определение переменной <code>*edge-table*</code>, которая будет содержать оценку каждой позиции края, и константы <code>edge-and-x-lists</code>, которая представляет собой список клатов на каждом из четырех краев. Каждый край состоит из десяти клеток, потому что X-клетки включены.</p>
<div class="fragment"><div class="line">(defvar *edge-table* (make-array (expt 3 10))</div><div class="line">  &quot;Array of values to player-to-move for edge positions.&quot;)</div><div class="line"></div><div class="line">(defconstant edge-and-x-lists</div><div class="line">  &#39;((22 11 12 13 14 15 16 17 18 27)</div><div class="line">    (72 81 82 83 84 85 86 87 88 77)</div><div class="line">    (22 11 21 31 41 51 61 71 81 72)</div><div class="line">    (27 18 28 38 48 58 68 78 88 77))</div><div class="line">  &quot;The four edges (with their X-squares).&quot;)</div></div><!-- fragment --><p>Теперь для каждого края мы можем вычислить индекс в таблице краев, построив 10-значное число с основанием 3, где каждая цифра равна 1, если соответствующая клетка края занята игроком, 2, если противником, и 0, если она пуста. . Функция <code>edge-index</code> вычисляет это, а <code>edge-stability</code> суммирует значения четырех индексов края.</p>
<div class="fragment"><div class="line">(defun edge-index (player board squares)</div><div class="line">  &quot;The index counts 1 for player; 2 for opponent,</div><div class="line">  on each square---summed as a base 3 number.&quot;</div><div class="line">  (let ((index 0))</div><div class="line">    (dolist (sq squares)</div><div class="line">      (setq index (+ (* index 3)</div><div class="line">                     (cond ((eql (bref board sq) empty) 0)</div><div class="line">                           ((eql (bref board sq) player) 1)</div><div class="line">                           (t 2)))))</div><div class="line">    index))</div><div class="line"></div><div class="line">(defun edge-stability (player board)</div><div class="line">  &quot;Total edge evaluation for player to move on board.&quot;</div><div class="line">  (loop for edge-list in edge-and-x-lists</div><div class="line">        sum (aref *edge-table*</div><div class="line">                  (edge-index player board edge-list))))</div></div><!-- fragment --><p>Функция <code>edge-stability</code> - это все, что нам понадобится в функции оценки Яго, но нам все еще нужно сгенерировать таблицу границ(краев). Поскольку это нужно сделать только один раз, нам не нужно беспокоиться об эффективности. В частности, вместо того, чтобы изобретать новую структуру данных для представления краев, мы продолжим использовать полные доски, даже если они будут в основном пустыми. Вычисления для краевой таблицы будут производиться по верхнему краю, с точки зрения черного, с черным для игры. Но та же таблица может использоваться для белого цвета или для одного из других краев из-за способа вычисления индекса края.</p>
<p>Каждая позиция в таблице сначала инициализируется статическим значением, вычисленным с помощью метрики взвешенных клеток, но с разными весами в зависимости от того, находится ли фигура в опасности быть захваченной. После этого каждая позиция обновляется с учетом возможных ходов, которые могут быть сделаны из этой позиции, и значений каждого из этих ходов.</p>
<div class="fragment"><div class="line">(defconstant top-edge (first edge-and-x-lists))</div><div class="line"></div><div class="line">(defun init-edge-table ()</div><div class="line">  &quot;Initialize *edge-table*, starting from the empty board.&quot;</div><div class="line">  ;; Initialize the static values</div><div class="line">  (loop for n-pieces from 0 to 10 do</div><div class="line">        (map-edge-n-pieces</div><div class="line">          #&#39;(lambda (board index)</div><div class="line">              (setf (aref *edge-table* index)</div><div class="line">                    (static-edge-stability black board)))</div><div class="line">          black (initial-board) n-pieces top-edge 0))</div><div class="line">  ;; Now iterate five times trying to improve:</div><div class="line">  (dotimes (i 5)</div><div class="line">    ;; Do the indexes with most pieces first</div><div class="line">    (loop for n-pieces from 9 downto 1 do</div><div class="line">          (map-edge-n-pieces</div><div class="line">            #&#39;(lambda (board index)</div><div class="line">                (setf (aref *edge-table* index)</div><div class="line">                      (possible-edge-moves-value</div><div class="line">                        black board index)))</div><div class="line">            black (initial-board) n-pieces top-edge 0))))</div></div><!-- fragment --><p>Функция <code>map-edge-n-sizes</code> перебирает все позиции краев с общим количеством <code>n</code> фишек (любого цвета), применяя функцию к каждой такой позиции. Она также ведет текущий счет индекса края по мере его продвижения. Функция должна принимать два аргумента: доска и индекс. Обратите внимание, что одну доску можно использовать для всех позиций, потому что клетки сбрасываются после их использования. Функция имеет три случая: если количество оставшихся клеток меньше, чем <code>n</code>, тогда будет невозможно разместить <code>n</code> фишек на этих клетках, поэтому мы сдаемся. Если клеток больше нет, то <code>n</code> также должно быть равно нулю, так что это допустимая позиция, и вызывается функция <code>fn</code>. В противном случае мы сначала пытаемся оставить текущую клетку пустой, затем пытаемся заполнить её фигурой игрока, а затем фигурой противника, в каждом случае рекурсивно вызывая <code>map-edge-n-pieces</code>.</p>
<div class="fragment"><div class="line">(defun map-edge-n-pieces (fn player board n squares index)</div><div class="line">  &quot;Call fn on all edges with n pieces.&quot;</div><div class="line">  ;; Index counts 1 for player; 2 for opponent</div><div class="line">  (cond</div><div class="line">    ((&lt; (length squares) n) nil)</div><div class="line">    ((null squares) (funcall fn board index))</div><div class="line">    (t (let ((index3 (* 3 index))</div><div class="line">             (sq (first squares)))</div><div class="line">         (map-edge-n-pieces fn player board n (rest squares) index3)</div><div class="line">         (when (and (&gt; n 0) (eql (bref board sq) empty))</div><div class="line">           (setf (bref board sq) player)</div><div class="line">           (map-edge-n-pieces fn player board (- n 1) (rest squares)</div><div class="line">                              (+ 1 index3))</div><div class="line">           (setf (bref board sq) (opponent player))</div><div class="line">           (map-edge-n-pieces fn player board (- n 1) (rest squares)</div><div class="line">                              (+ 2 index3))</div><div class="line">           (setf (bref board sq) empty))))))</div></div><!-- fragment --><p>Функция <code>possible-edge-moves-value</code> просматривает все возможные ходы, чтобы определить значение края, которое является более точным, чем статическая оценка. Она перебирает каждую пустую клетку на краю, вызывая <code>possible-edge-move</code>, чтобы вернуть пару (<em>probability value</em>). Так как игрок также может вообще не двигаться по краю, пара (<code>1.0</code>*current-value*) также включается.</p>
<div class="fragment"><div class="line">(defun possible-edge-moves-value (player board index)</div><div class="line">  &quot;Consider all possible edge moves.</div><div class="line">  Combine their values into a single number.&quot;</div><div class="line">  (combine-edge-moves</div><div class="line">    (cons</div><div class="line">      (list 1.0 (aref *edge-table* index)) ;; no move</div><div class="line">      (loop for sq in top-edge             ;; possible moves</div><div class="line">            when (eql (bref board sq) empty)</div><div class="line">            collect (possible-edge-move player board sq)))</div><div class="line">    player))</div></div><!-- fragment --><p>Ценность каждой позиции определяется путем выполнения хода на доске, затем поиска в таблице значения полученной позиции для оппонента и ее отрицания (поскольку нас интересует ценность для нас, а не для нашего оппонента) .</p>
<div class="fragment"><div class="line">(defun possible-edge-move (player board sq)</div><div class="line">  &quot;Return a (prob val) pair for a possible edge move.&quot;</div><div class="line">  (let ((new-board (replace (aref *ply-boards* player) board)))</div><div class="line">    (make-move sq player new-board)</div><div class="line">    (list (edge-move-probability player board sq)</div><div class="line">          (- (aref *edge-table*</div><div class="line">                   (edge-index (opponent player)</div><div class="line">                               new-board top-edge))))))</div></div><!-- fragment --><p>Возможные ходы комбинируются с <code>combine-edge-moves</code>, которые сортируют ходы по принципу "лучший в первую очередь". (Поскольку <code>init-edge-table</code> начался с точки зрения черных, черные стараются максимизировать, а белые стараются минимизировать очки.) Затем мы спускаемся по ходам, увеличивая общее значение на значение каждого хода, умноженное на вероятность хода, и уменьшение оставшейся вероятности на вероятность хода. Поскольку всегда будет хотя бы один ход (pass) с вероятностью 1.0, это гарантированно сходится. В конце мы округляем итоговое значение, чтобы мы могли выполнять вычисления во время выполнения с фиксированными числами.</p>
<div class="fragment"><div class="line">(defun combine-edge-moves (possibilities player)</div><div class="line">  &quot;Combine the best moves.&quot;</div><div class="line">  (let ((prob 1.0)</div><div class="line">        (val 0.0)</div><div class="line">        (fn (if (eql player black) #&#39;&gt; #&#39;&lt;)))</div><div class="line">    (loop for pair in (sort possibilities fn :key #&#39;second)</div><div class="line">          while (&gt;= prob 0.0)</div><div class="line">          do (incf val (* prob (first pair) (second pair)))</div><div class="line">             (decf prob (* prob (first pair))))</div><div class="line">    (round val)))</div></div><!-- fragment --><p>Нам все еще нужно вычислить вероятность того, что каждое возможное перемещение ребра допустимо. Эти вероятности должны отражать такие вещи, как тот факт, что легко захватить край, если противник находится в соседней X-клетке, и очень сложно в противном случае. Сначала мы определяем некоторые функции для распознавания углов и X-клеток и связываем их с их соседями:</p>
<div class="fragment"><div class="line">(let ((corner/xsqs &#39;((11 . 22) (18 . 27) (81. 72) (88 . 77))))</div><div class="line">  (defun corner-p (sq) (assoc sq corner/xsqs))</div><div class="line">  (defun x-square-p (sq) (rassoc sq corner/xsqs))</div><div class="line">  (defun x-square-for (corner) (cdr (assoc corner corner/xsqs)))</div><div class="line">  (defun corner-for (xsq) (car (rassoc xsq corner/xsqs))))</div></div><!-- fragment --><p>Теперь рассмотрим вероятности. Всего четыре случая. Во-первых, поскольку мы ничего не знаем о внутренней части доски, мы предполагаем, что у каждого игрока есть 50% -процентный шанс играть в X-клетке. Во-вторых, если мы сможем показать, что ход допустим (потому что он переворачивает фигуры противника), то он имеет 100% вероятность. В-третьих, для угловых клеток мы присваиваем шанс 90%, если противник занимает X-клетку, 10%, если она пуста, и только 0,1%, если мы её занимаем. В противном случае вероятность определяется двумя соседними клетками: если клетка находится рядом с одним или несколькими противниками, более вероятно, что мы сможем туда переместиться; если она рядом с нашими фишками, то маловероятно. Если оппоненту разрешено выходить на поле, шансы уменьшаются вдвое (хотя мы все еще можем двигаться туда, поскольку мы ходим первыми).</p>
<div class="fragment"><div class="line">(defun edge-move-probability (player board square)</div><div class="line">  &quot;What&#39;s the probability that player can move to this square?&quot;</div><div class="line">  (cond</div><div class="line">    ((x-square-p square) .5) ;; X-squares</div><div class="line">    ((legal-p square player board) 1.0) ;; immediate capture</div><div class="line">    ((corner-p square) ;; move to corner depends on X-square</div><div class="line">     (let ((x-sq (x-square-for square)))</div><div class="line">       (cond</div><div class="line">         ((eql (bref board x-sq) empty) .1)</div><div class="line">         ((eql (bref board x-sq) player) 0.001)</div><div class="line">         (t .9))))</div><div class="line">    (t (/ (aref</div><div class="line">            &#39;#2A((.1  .4 .7)</div><div class="line">                 (.05 .3  *)</div><div class="line">                 (.01  *  *))</div><div class="line">            (count-edge-neighbors player board square)</div><div class="line">            (count-edge-neighbors (opponent player) board square))</div><div class="line">          (if (legal-p square (opponent player) board) 2 1)))))</div><div class="line"></div><div class="line">(defun count-edge-neighbors (player board square)</div><div class="line">  &quot;Count the neighbors of this square occupied by player.&quot;</div><div class="line">  (count-if #&#39;(lambda (inc)</div><div class="line">                (eql (bref board (+ square inc)) player))</div><div class="line">            &#39;(+1 -1)))</div></div><!-- fragment --><p>Теперь вернемся к задаче определения статического значения положения края. Оно вычисляется метрикой взвешенных клеток, но веса зависят от <em>стабильности</em> каждой фишки. Фигура называется стабильной, если она не может быть взята, нестабильной, если она находится в непосредственной опасности захвата, и полустабильной в противном случае. Для каждого края и устойчивости следует таблица веса. Обратите внимание, что угловые клетки всегда стабильны, и X-клетки мы будем называть полустабильными, если соседний угол взят, и нестабильными в противном случае.</p>
<div class="fragment"><div class="line">(defparameter *static-edge-table*</div><div class="line">  &#39;#2A(;stab  semi    un</div><div class="line">       (   *    0 -2000) ; X</div><div class="line">       ( 700    *     *) ; corner</div><div class="line">       (1200  200   -25) ; C</div><div class="line">       (1000  200    75) ; A</div><div class="line">       (1000  200    50) ; B</div><div class="line">       (1000  200    50) ; B</div><div class="line">       (1000  200    75) ; A</div><div class="line">       (1200  200   -25) ; C</div><div class="line">       ( 700    *     *) ; corner</div><div class="line">       (   *    0 -2000) ; X</div><div class="line">       ))</div></div><!-- fragment --><p>Затем статическая оценка просто суммирует стоимость каждой фишки в соответствии с этой таблицей:</p>
<div class="fragment"><div class="line">(defun static-edge-stability (player board)</div><div class="line">  &quot;Compute this edge&#39;s static stability&quot;</div><div class="line">  (loop for sq in top-edge</div><div class="line">        for i from 0</div><div class="line">        sum (cond</div><div class="line">              ((eql (bref board sq) empty) 0)</div><div class="line">              ((eql (bref board sq) player)</div><div class="line">               (aref *static-edge-table* i</div><div class="line">                     (piece-stability board sq)))</div><div class="line">              (t (- (aref *static-edge-table* i</div><div class="line">                          (piece-stability board sq)))))))</div></div><!-- fragment --><p>Расчет устойчивости довольно сложен. Он сосредотачивается вокруг поиска двух "pieces/фишек" <code>p1</code> и <code>p2</code>, которые лежат по обе стороны от рассматриваемой фишки и не того же цвета, что и эта фишка. Эти "pieces"(фишки) могут быть пустыми или отсутствовать на доске. Фишка нестабильна, если одна из двух пуста, а другая - соперник; она полустабильна, если есть противники с обеих сторон и есть хотя бы одно пустое поле для игры, или если оно окружено пустыми фигурами. Наконец, если либо <code>p1</code>, либо <code>p2</code> равно нулю, то фигура устойчива, поскольку она должна быть соединена сплошной стенкой из фишек с углом.</p>
<div class="fragment"><div class="line">(let ((stable 0) (semi-stable 1) (unstable 2))</div><div class="line"></div><div class="line">  (defun piece-stability (board sq)</div><div class="line">    (cond</div><div class="line">      ((corner-p sq) stable)</div><div class="line">      ((x-square-p sq)</div><div class="line">       (if (eql (bref board (corner-for sq)) empty)</div><div class="line">           unstable semi-stable))</div><div class="line">      (t (let* ((player (bref board sq))</div><div class="line">                (opp (opponent player))</div><div class="line">                (p1 (find player board :test-not #&#39;eql</div><div class="line">                          :start sq :end 19))</div><div class="line">                (p2 (find player board :test-not #&#39;eql</div><div class="line">                          :start 11 :end sq</div><div class="line">                          :from-end t)))</div><div class="line">           (cond</div><div class="line">             ;; unstable pieces can be captured immediately</div><div class="line">             ;; by playing in the empty square</div><div class="line">             ((or (and (eql p1 empty) (eql p2 opp))</div><div class="line">                  (and (eql p2 empty) (eql p1 opp)))</div><div class="line">              unstable)</div><div class="line">             ;; Semi-stable pieces might be captured</div><div class="line">             ((and (eql p1 opp) (eql p2 opp)</div><div class="line">                   (find empty board :start 11 :end 19))</div><div class="line">              semi-stable)</div><div class="line">             ((and (eql p1 empty) (eql p2 empty))</div><div class="line">              semi-stable)</div><div class="line">             ;; Stable pieces can never be captured</div><div class="line">             (t stable)))))))</div></div><!-- fragment --><p>Краевая таблица теперь может быть создана с помощью вызова <code>init-edge-lable</code>. После того, как таблица будет построена один раз, рекомендуется сохранить ее, чтобы нам не пришлось повторять инициализацию. Мы могли бы написать простые процедуры для сброса таблицы в файл и чтения её обратно, но быстрее и проще использовать существующие инструменты, которые уже достаточно хорошо справляются с этой задачей: <code>compile-file</code> и <code>load</code>. Все, что нам нужно сделать, это создать и скомпилировать файл, содержащий единственную строку:</p>
<div class="fragment"><div class="line">(setf *edge-table* &#39;#.*edge-table*)</div></div><!-- fragment --><p>Макрос чтения <code>#.</code> вычисляет следующее выражение во время чтения. Таким образом, компилятор увидит и скомпилирует текущую краевую таблицу. Он сможет сохранить это более компактно и <code>load</code> загружает обратно быстрее, чем если бы мы распечатали содержимое вектора в десятичном формате (или с любой другой базой).</p>
<h3>Сочетание факторов</h3>
<p>Теперь у нас есть мера трех факторов: текущая подвижность, потенциальная подвижность и стабильность края. Остается только найти хороший способ объединить их в единую метрику оценки. Комбинированная функция, используемая <a href="B9780080571157500285.xhtml#bb1000">Rosenbloom (1982)</a>, представляет собой линейную комбинацию трех факторов, но коэффициент каждого фактора зависит от номера хода. Характеристики Розенблума нормализованы к диапазону [-1000, 1000]; мы нормализуем до диапазона [-1, 1], выполняя деление после умножения на коэффициент. Это позволяет нам использовать фиксированные числа для коэффициентов. Поскольку наши три фактора рассчитываются не так, как у Розенблюма, неудивительно, что его коэффициенты не самые лучшие для нашей программы. Краевой коэффициент был удвоен, а потенциальный коэффициент уменьшен в пять раз.</p>
<div class="fragment"><div class="line">(defun Iago-eval (player board)</div><div class="line">  &quot;Combine edge-stability, current mobility and</div><div class="line">  potential mobility to arrive at an evaluation.&quot;</div><div class="line">  ;; The three factors are multiplied by coefficients</div><div class="line">  ;; that vary by move number:</div><div class="line">  (let ((c-edg (+ 312000 (* 6240 *move-number*)))</div><div class="line">        (c-cur (if (&lt; *move-number* 25)</div><div class="line">                   (+ 50000 (* 2000 *move-number*))</div><div class="line">                   (+ 75000 (* 1000 *move-number*))))</div><div class="line">        (c-pot 20000))</div><div class="line">    (multiple-value-bind (p-cur p-pot)</div><div class="line">        (mobility player board)</div><div class="line">      (multiple-value-bind (o-cur o-pot)</div><div class="line">          (mobility (opponent player) board)</div><div class="line">        ;; Combine the three factors into one sum:</div><div class="line">        (+ (round (* c-edg (edge-stability player board)) 32000)</div><div class="line">           (round (* c-cur (- p-cur o-cur)) (+ p-cur o-cur 2))</div><div class="line">           (round (* c-pot  (- p-pot o-pot)) (+ p-pot o-pot 2)))))))</div></div><!-- fragment --><p>Наконец, мы готовы кодировать функцию <code>Iago</code>. При заданной глубине поиска <code>Iago</code> возвращает стратегию, которая будет выполнять альфа-бета-поиск на эту глубину с использованием оценочной функции <code>Iago-eval</code>. Эта версия Яго смогла победить модифицированную стратегию взвешенных клеток в 8 из 10 игр в 3-х слойных и 9 из 10 в 4-х слойных. На Explorer II поиск в 4 слоя занимает около 20 секунд на ход. В 5-слойном упражнении многие движения занимают больше минуты, поэтому программа рискует проиграть. В трех слойной программе на ход требуется всего несколько секунд, но она все же смогла победить автора в пяти партиях подряд со счетом 50-14, 64-0, 51-13, 49-15 и 36-28. . Несмотря на эти успехи, вполне вероятно, что функция оценки может быть значительно улучшена при небольшой настройке параметров.</p>
<div class="fragment"><div class="line">(defun Iago (depth)</div><div class="line">  &quot;Use an approximation of Iago&#39;s evaluation function.&quot;</div><div class="line">  (alpha-beta-searcher3 depth #&#39;iago-eval))</div></div><!-- fragment --><h2>18.13 Другие методы</h2>
<p>Есть много других вариантов, которые можно попробовать, чтобы ускорить поиск и улучшить игру. К сожалению, выбор техник - это своего рода черное искусство. Вам придется поэкспериментировать, чтобы найти комбинацию, которая лучше всего подходит для каждой области и каждой функции оценки. Большинство из следующих техник были включены или, по крайней мере, рассмотрены и отклонены в Билле.</p>
<h3>Итеративное углубление</h3>
<p>Мы видели, что средний фактор ветвления для Отелло составляет около 10. Это означает, что поиск на глубину <em>n</em> + 1 занимает примерно в 10 раз больше времени, чем поиск на глубину <em>n</em>. Таким образом, мы должны быть готовы пойти на большие накладные расходы, прежде чем искать на один уровень глубже, чтобы гарантировать две вещи: что поиск будет выполняться эффективно и что мы не потерпим неудачу из-за нехватки времени. Обеим целям служит уже знакомая техника - итеративное углубление (см. <a href="B9780080571157500066.xhtml">Главы 6</a> и <a href="B9780080571157500145.xhtml">14</a>).</p>
<p>Итеративное углубление используется следующим образом. Стратегия определяет, сколько из оставшегося времени выделить на каждый ход. Простая стратегия могла бы выделить постоянное количество времени для каждого хода, а более сложная стратегия могла бы выделить больше времени на ходы в критические моменты игры. После определения распределения времени для хода стратегия начинает итеративный поиск с углублением альфа-бета. Есть две сложности: во-первых, поиск по <em>n</em> слоям отслеживает лучшие ходы, так что поиск по <em>n</em> + 1 слою будет иметь лучшую информацию для упорядочивания. Во многих случаях будет быстрее выполнить поиск по <em>n</em> и <em>n</em> + 1 слою с информацией об упорядочивании, чем выполнять только поиск по <em>n</em> + 1 слою без него. Во-вторых, мы можем отслеживать, сколько времени было потрачено на поиск каждого слоя, и отключать поиск, если поиск еще одного слоя превысит выделенный лимит времени. Таким образом, поиск с итеративным углублением постепенно ухудшается по мере наложения ограничений по времени. Он даст разумный ответ даже при небольшом отведенном времени, и он редко будет превышать отведенное время.</p>
<h3>Прямая обрезка</h3>
<p>Один из способов сократить количество искомых позиций - заменить генератор допустимых ходов генератором <em>правдоподобных/plausible</em> ходов: другими словами, рассматривайте только хорошие ходы и никогда даже не смотрите на ходы, которые кажутся явно плохими. Этот метод называется <em>forward pruning</em>(прямой обрезкой). Он попал в немилость из-за трудности определения того, какие ходы правдоподобны. Для большинства игр факторы, которые будут входить в генератор вероятных ходов, в любом случае будут дублироваться в функции статической оценки, поэтому прямое отсечение потребует больше усилий без особого выигрыша. Что еще хуже, отсечение вперед может исключить блестящую жертву - ход, который сначала выглядит плохо, но в конечном итоге приводит к выигрышу.</p>
<p>Для некоторых игр прямая обрезка является необходимостью. Например, в игру Go играют на доске 19 на 19, поэтому у первого игрока есть 361 разрешенный ход, а поиск в 6 слоев потребует более 2 квадриллионов позиций. Однако многие хорошие программы Go можно рассматривать как не выполняющие прямую отсечку, а как абстракцию. В одной части доски может быть 30 пустых клеток, и программа будет рассматривать ход на любую из этих клеток эквивалентно.</p>
<p>Билл ограниченно использует прямую обрезку, чтобы исключить определенные движения, прилегающие к углам. Это делается не для экономии времени, а потому, что функция оценки может привести к выбору такого хода, даже если на самом деле это плохой ход. Другими словами, прямое отсечение используется для дешевого исправления ошибки в функции оценки.</p>
<h3>Неспекулятивное прямое отсечение</h3>
<p>В этом методе используется наблюдение, что существуют ограничения на количество изменений функции оценки от одного положения к другому. Например, если мы используем разницу в счетах в качестве функции оценки, то больше всего ход может изменить оценку +37 (один для размещения фигуры в углу и шесть захватов в каждом из трех направлений). Наименьшее изменение - 0 (если игрок вынужден пасовать). Таким образом, если в поиске осталось 2 слоя и резервное значение позиции <em>A</em> было установлено на 38 пунктов лучше, чем статическое значение позиции <em>B</em>, то расширять позицию <em>B</em> бесполезно. . Это предполагает, что мы оцениваем каждую позицию, возможно, для сортировки или итеративного углубления. Также предполагается, что никакая позиция в дереве поиска не является конечной позицией, потому что тогда оценка может измениться более чем на 37 пунктов. В заключение, кажется, что неспекулятивное прямое отсечение не очень полезно для Отелло, хотя оно может сыграть роль в других играх.</p>
<h3>Поиск стремлений</h3>
<p>Альфа-бета-поиск начинается с <code>achievable</code>(достижимой) и <code>cutoff</code>(отсекаемой/пороговой) границы, установленных на в <code>losing-value</code>(проигрышныое значени) и <code>winning-value</code>(выигрышное значение), соответственно. Другими словами, поиск ничего не предполагает: итоговая позиция может быть любой, от проигрыша до победы. Но предположим, что мы находимся в ситуации где-то в середине игры, когда мы выигрываем с небольшим отрывом (скажем, статическая оценка для текущей позиции равна 50). В большинстве случаев один ход не сильно меняет оценку. Следовательно, если мы вызвали альфа-бета-поиск с окном, определенным границами, скажем, от 0 до 100, могут произойти две вещи: если фактическая резервная оценка для этой позиции фактически находится в диапазоне от 0 до 100, тогда поиск найдет его, и он будет найден быстро, потому что уменьшенное окно приведет к большему сокращению. Если фактическое значение не входит в диапазон, то возвращаемое значение будет отражать это, и мы можем снова выполнить поиск, используя большее окно. Это называется поиском стремления, потому что мы стремимся найти значение в заданном окне. Если окно выбрано правильно, то часто мы добиваемся успеха и экономим время поиска.</p>
<p><a href="B9780080571157500285.xhtml#bb0930">Pearl (1984)</a> предлагает альтернативу, называемую поиском в нулевом окне(zero-window). На каждом уровне первый возможный ход, который мы назовем <em>m</em>, ищется с использованием достаточно широкого окна, чтобы определить его точное значение, которое мы назовем <em>v</em>. Затем ищутся оставшиеся возможные ходы, используя <em>v</em> как нижнюю и верхнюю границы окна. Таким образом, результат поиска покажет, лучше или хуже каждый последующий ход, чем <em>m</em>, но не скажет, насколько лучше или хуже. Есть три результата поиска с нулевым окном. Если никакое движение не оказывается лучше, чем <em>m</em>, то придерживайтесь <em>m</em>. Если один ход лучше, используйте его. Если несколько ходов лучше, чем <em>m</em>, то их нужно снова найти в более широком окне, чтобы определить, какой из них лучше.</p>
<p>Всегда существует компромисс между временем, потраченным на поиск, и полученной информацией. Поиск с нулевым окном является привлекательным компромиссом: мы выигрываем некоторое время поиска, теряя информацию о ценности лучшего хода. Нам по-прежнему гарантировано нахождение лучшего хода, мы просто не знаем его точной стоимости/значения.</p>
<p>Поиск Билла с нулевым окном занимает всего 63% времени, затрачиваемого на поиск в режиме полного альфа-бета. Это эффективно, потому что методы упорядочивания ходов Билла гарантируют, что первый ход зачастую оказывается лучшим. При случайном порядке ходов поиск без окна не будет эффективным.</p>
<h3>Думать о будущем</h3>
<p>Программа, которая делает свой ход, а затем ждет ответа противника, тратит половину доступного ей времени. Лучше использовать время для расчетов или <em>думать наперед</em>, пока противник выбирает свой ход. Прогнозирование - один из факторов, который помогает Биллу победить Яго. Хотя многие программы заранее продумывают ход, выбирая наиболее вероятный ход оппонента, а затем начиная итеративно-углубляющийся поиск, предполагая этот ход. Алгоритм Билла несколько сложнее. Он может учитывать более одного хода противника, в зависимости от того, сколько времени доступно.</p>
<h3>Хеширование и книга ходов в дебюте</h3>
<p>Мы рассматривали пространство поиска как дерево, но в целом это ориентированный ациклический граф (dag): может быть более одного способа достичь определенной позиции, но не будет никаких циклов, потому что каждый ход добавляет новый кусок. Это поднимает вопрос, который мы кратко исследовали в <a href="B9780080571157500066.xhtml#s0025">разделе 6.4</a>: следует ли рассматривать пространство поиска как дерево или граф? Рассматривая его как график, мы устраняем повторяющиеся оценки, но у нас есть накладные расходы на сохранение всех предыдущих позиций и на проверку того, была ли ранее обнаружена новая позиция. Решение должно основываться на пропорции повторяющихся позиций, которые фактически встречаются в игре. Одно из компромиссных решений - хранить в хеш-таблице частичное кодирование каждой позиции, закодированное, скажем, как одно фиксированное число/fixnum (одно слово) вместо семи или около того слов, необходимых для представления всей доски. Вместе с кодировкой каждой позиции сохраните ход, чтобы попробовать первым. Затем для каждой новой позиции смотрите в хеш-таблицу, и если есть совпадение, сначала попробуйте соответствующий ход. Этот ход может быть даже незаконным, если происходит случайная коллизия хешей, но есть большая вероятность, что ход будет правильным и накладные расходы низкие.</p>
<p>Одно место, где явно стоит хранить информацию о предыдущих позициях, - это начальная игра(дебют). Так как в дебюте меньше вариантов, рекомендуется составить дебютную "книгу" ходов и играть по ней как можно дольше, пока противник не сделает ход, который отклоняется от книги. Книжные ходы можно почерпнуть из литературы, хотя об Отелло написано не так много (по сравнению с дебютами в шахматах). Однако есть опасность следовать совету экспертов: позиции, которые эксперт считает выгодными, могут не совпадать с позициями, с которых наша программа может хорошо играть. Может быть, лучше составить книгу, играя против самой программы и определяя, какие позиции работают лучше всего.</p>
<h3>Конец игры</h3>
<p>Также неплохо попытаться сэкономить время в середине игры, а затем приложить все усилия для поиска по всему дереву игры до завершения, как только это будет возможно. Билл может искать до завершения примерно из 14 слоев. Разумеется, после завершения поиска наиболее многообещающие линии игры должны быть сохранены, чтобы не приходилось снова решать дерево игры.</p>
<h3>Мета-рассуждение</h3>
<p>Если бы не часы, Отелло была бы тривиальной игрой: просто обыщите все дерево игры до конца, а затем выберите лучший ход. С часами возникает сложность: мы должны сделать все, чтобы время не закончилось. Алгоритмы, которые мы видели до сих пор, управляют часами, выделяя определенное количество времени на каждый ход, так что общее время гарантированно (или, по крайней мере, очень вероятно) будет меньше отведенного времени. Это очень грубая политика. Более тонкий способ управления временем состоит в том, чтобы рассматривать сами вычисления как возможный ход. То есть, на каждом такте времени нам нужно решить, лучше ли остановиться и сыграть лучший ход, который мы вычислили до сих пор, или продолжить и попытаться вычислить лучший ход. Будет лучше вычислять больше только в том случае, если мы в конечном итоге выберем лучший ход; будет лучше остановиться и играть только в том случае, если в противном случае мы проиграем из-за нехватки времени или будем вынуждены сделать неправильный выбор позже в игре. Алгоритм, который включает вычисление в качестве возможного хода, называется системой мета-рассуждений, потому что он определяет, насколько нужно рассуждать.</p>
<p><a href="B9780080571157500285.xhtml#bb1025">Russell and Wefald (1989)</a> представляют подход, основанный на этой точке зрения. В дополнение к функции оценки они предполагают функцию дисперсии(variance), которая дает оценку того, насколько истинное значение данной позиции может отличаться от ее статического значения. На каждом этапе их алгоритм сравнивает значение и дисперсию лучшего хода, вычисленного на данный момент, и второго лучшего хода. Если лучший ход явно лучше второго (с учетом дисперсии), то вычислять больше нет смысла. Кроме того, если два верхних хода имеют одинаковые значения, но оба имеют очень низкую дисперсию, вычисления не сильно помогут; мы можем просто выбрать одно из двух наугад.</p>
<p>Например, если доска находится в симметричном положении, то могут быть два симметричных хода, которые будут иметь одинаковое значение. Путем более тщательного поиска в поддереве каждого хода мы скоро приходим к низкой дисперсии для обоих ходов, а затем можем выбрать любой из них без дальнейшего поиска. Конечно, мы могли бы также добавить код особого случая для проверки симметрии, но подход мета-рассуждений будет работать как для несимметричных, так и для симметричных случаев. Если есть ситуация, когда два хода приводят к чистой победе, не нужно тратить время на выбор между ними.</p>
<p>Единственная ситуация, в которой имеет смысл продолжить вычисления, - это когда есть два хода с большой дисперсией, поэтому неясно, превышает ли истинное значение одно другое. Алгоритм мета-рассуждений основан на уделении времени именно этому случаю.</p>
<h3>Обучение</h3>
<p>С первых дней компьютерных игр было ясно, что программе чемпионата нужно научиться совершенствоваться. <a href="B9780080571157500285.xhtml#bb1040">Samuel (1959)</a> описывает программу, которая играет в шашки и учится улучшать свою функцию оценки. Функция оценки представляет собой линейную комбинацию характеристик, таких как количество фишек для каждого игрока, количество королей, количество возможных вилок и так далее. Обучение осуществляется с помощью процедуры поиска по восходящей: измените один из коэффициентов для одной из характеристик наугад, а затем посмотрите, лучше ли измененная функция оценки, чем исходная.</p>
<p>Без каких-либо указаний этот поиск по восхождению был бы очень медленным. Во-первых, пространство очень велико - Сэмюэл использовал 38 различных функций, и, хотя он ограничил коэффициенты степенью двойки от 0 до 20, по-прежнему остается 2138 возможных функций оценки. Во-вторых, очевидный способ определить относительную ценность двух оценочных функций - сыграть между ними в серии игр и посмотреть, какая из них выигрывает чаще, - требует довольно много времени.</p>
<p>К счастью, есть более быстрый способ оценить функцию оценки. Мы можем применить функцию оценки к позиции и сравнить это статическое значение с резервным значением, определенным альфа-бета-поиском. Если функция оценки точна, статическое значение должно хорошо коррелировать с резервным значением. Если оно не коррелирует хорошо, функцию оценки следует изменить таким образом, чтобы это произошло. Этот подход по-прежнему требует проб и ошибок восхождения на холм, но он будет сходиться намного быстрее, если мы сможем получать информацию из каждой позиции, а не только из каждой игры.</p>
<p>В последние несколько лет возрос интерес к обучению с помощью управляемого поиска. <em>Нейронные сети</em> являются одним из примеров этого. Они обсуждались в другом месте. Другой пример - алгоритмы <em>генетического обучения</em>. Эти алгоритмы начинаются с нескольких возможных решений. В нашем случае каждый кандидат будет состоять из набора коэффициентов для функции оценки. В каждом поколении генетический алгоритм видит, насколько хорошо работает каждый кандидат. Худшие кандидаты исключаются, а лучшие «спариваются» и «воспроизводятся» - два кандидата каким-то образом объединяются, чтобы получить нового. Если новое потомство унаследовало хорошие качества обоих родителей, оно будет процветать; если он унаследовал плохие стороны обоих родителей, то быстро вымрет. В любом случае идея состоит в том, что естественный отбор в конечном итоге приведет к качественному решению. Чтобы увеличить вероятность этого, рекомендуется учитывать мутации: случайные изменения в генетическом составе одного из кандидатов.</p>
<h2>18.14 История и ссылки</h2>
<p><a href="B9780080571157500285.xhtml#bb0710">Lee and Mahajan (1986,</a><a href="B9780080571157500285.xhtml#bb0715">1990)</a>present the current top Othello program, Bill. Their description outlines all the techniques used but does not go into enough detail to allow the reader to reconstruct the program. Bill is based in large part on Rosenbloom's Iago program. Rosenbloom's article (1982) is more thorough. The presentation in this chapter is based largely on this article, although it also contains some ideas from Bill and from other sources.</p>
<p>The journal <em>Othello Quarterly</em> is the definitive source for reports on both human and computer Othello games and strategies.</p>
<p>The most popular game for computer implementation is chess. <a href="B9780080571157500285.xhtml#bb1070">Shannon (1950a,</a><a href="B9780080571157500285.xhtml#bb1075">b)</a> speculated that a computer might play chess. In a way, this was one of the boldest steps in the history of AI. Today, writing a chess program is a challenging but feasible project for an undergraduate. But in 1950, even suggesting that such a program might be possible was a revolutionary step that changed the way people viewed these arithmetic calculating devices. Shannon introduced the ideas of a game tree search, minimaxing, and evaluation functions-ideas that remain intact to this day. <a href="B9780080571157500285.xhtml#bb0770">Marsland (1990)</a> provides a good short introduction to computer chess, and David Levy has two books on the subject (1976, 1988). It was Levy, an international chess master, who in 1968 accepted a bet from John McCarthy, Donald Michie, and others that a computer chess program would not beat him in the next ten years. Levy won the bet. Levy's <em>Heuristic Programming</em> (1990) and <em>Computer Games</em> (1988) cover a variety of computer game playing programs. The studies by <a href="B9780080571157500285.xhtml#bb0305">DeGroot (1965,</a><a href="B9780080571157500285.xhtml#bb0310">1966)</a> give a fascinating insight into the psychology of chess masters.</p>
<p><a href="B9780080571157500285.xhtml#bb0630">Knuth and Moore (1975)</a> analyze the alpha-beta algorithm, and Pearl's book <em>Heuristics</em> (1984) covers all kinds of heuristic search, games included.</p>
<p><a href="B9780080571157500285.xhtml#bb1040">Samuel (1959)</a> is the classic work on learning evaluation function parameters. It is based on the game of checkers. <a href="B9780080571157500285.xhtml#bb0715">Lee and Mahajan (1990)</a> present an alternative learning mechanism, using Bayesian classification to learn an evaluation function that optimally distinguishes winning positions from losing positions. Genetic algorithms are discussed by L. <a href="B9780080571157500285.xhtml#bb0280">Davis (1987,</a><a href="B9780080571157500285.xhtml#bb0285">1991)</a> and <a href="B9780080571157500285.xhtml#bb0480">Goldberg (1989)</a>.</p>
<h2>18.15 Упражнения</h2>
<p><b>Exercise 18.3 [s]</b> How many different Othello positions are there? Would it be feasible to store the complete game tree and thus have a perfect player?</p>
<p><b>Exercise 18.4 [m]</b> At the beginning of this chapter, we implemented pieces as an enumerated type. There is no built-in facility in Common Lisp for doing this, so we had to introduce a series of <code>defconstant</code> forms. Define a macro for defining enumerated types. What else should be provided besides the constants?</p>
<p><b>Exercise 18.5 [h]</b> Add fixnum and speed declarations to the Iago evaluation function and the alpha-beta code. How much does this speed up Iago? What other efficiency measures can you take?</p>
<p><b>Exercise 18.6 [h]</b> Implement an iterative deepening search that allocates time for each move and checks between each iteration if the time is exceeded.</p>
<p><b>Exercise 18.7 [h]</b> Implement zero-window search, as described in <a href="#s0085">section 18.13</a>.</p>
<p><b>Exercise 18.8 [d]</b> Read the references on Bill (<a href="B9780080571157500285.xhtml#bb0715">Lee and Mahajan 1990</a>, and <a href="B9780080571157500285.xhtml#bb0710">1986</a> if you can get it), and reimplement Bill's evaluation function as best you can, using the table-based approach. It will also be helpful to read <a href="B9780080571157500285.xhtml#bb1000">Rosenbloom 1982</a>.</p>
<p><b>Exercise 18.9 [d]</b> Improve the evaluation function by tuning the parameters, using one of the techniques described in <a href="#s0085">section 18.13</a>.</p>
<p><b>Exercise 18.10 [h]</b> Write move-generation and evaluation functions for another game, such as chess or checkers.</p>
<h2>18.16 Ответы</h2>
<p><b>Answer 18.2</b> The <code>weighted-squares</code> strategy wins the first game by 20 pieces, but when <code>count-difference</code> plays first, it captures all the pieces on its fifth move. These two games alone are not enough to determine the best strategy; the function <code>othello-series</code> on <a href="#p626">page 626</a> shows a better comparison.</p>
<p><b>Answer 18.3</b> 364 = 3, 433, 683, 820, 292, 512, 484, 657, 849, 089, 281. No.</p>
<p><b>Answer 18.4</b> Besides the constants, we provide a <code>deftype</code> for the type itself, and conversion routines between integers and symbols:</p>
<div class="fragment"><div class="line">(defmacro define-enumerated-type (type &amp;rest elements)</div><div class="line">    &quot;Represent an enumerated type with integers 0-n.&quot;</div><div class="line">    &#39;(progn</div><div class="line">        (deftype ,type () &#39;(integer 0 , (- (length elements) 1)))</div><div class="line">        (defun ,(symbol type &#39;-&gt;symbol) (,type)</div><div class="line">            (elt &#39;,elements ,type))</div><div class="line">        (defun ,(symbol &#39;symbol-&gt; type) (symbol)</div><div class="line">            (position symbol &#39;,elements))</div><div class="line">        ,@(loop for element in elements</div><div class="line">                for i from 0</div><div class="line">                collect &#39;(defconstant ,element ,i))))</div></div><!-- fragment --><p>Here's how the macro would be used to define the piece data type, and the code produced:</p>
<div class="fragment"><div class="line">&gt; (macroexpand</div><div class="line">        &#39;(define-enumerated-type piece</div><div class="line">            empty black white outer))</div><div class="line">(PROGN</div><div class="line">    (DEFTYPE PIECE () &#39;(INTEGER 0 3))</div><div class="line">    (DEFUN PIECE-&gt;SYMBOL (PIECE)</div><div class="line">        (ELT &#39;(EMPTY BLACK WHITE OUTER) PIECE))</div><div class="line">    (DEFUN SYMBOL-&gt;PIECE (SYMBOL)</div><div class="line">        (POSITION SYMBOL &#39;(EMPTY BLACK WHITE OUTER)))</div><div class="line">    (DEFCONSTANT EMPTY 0)</div><div class="line">    (DEFCONSTANT BLACK 1)</div><div class="line">    (DEFCONSTANT WHITE 2)</div><div class="line">    (DEFCONSTANT OUTER 3))</div></div><!-- fragment --><p>A more general facility would, like <code>defstruct</code>, provide for several options. For example, it might allow for a documentation string for the type and each constant, and for a : <code>conc-name</code>, so the constants could have names like <code>piece-empty</code> instead of <code>empty</code>. This would avoid conflicts with other types that wanted to use the same names. The user might also want the ability to start the values at some number other than zero, or to assign specific values to some of the symbols. </p><hr/>
<p><a href="#xfn0015">1</a> Othello is a registered trademark of CBS Inc. Gameboard design @ 1974 CBS Inc. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">2</a>*Othello,* [I. i. 117] William Shakespeare. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0025">3</a> Remember, when a constant is redefined, it may be necessary to recompile any functions that use the constant. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
