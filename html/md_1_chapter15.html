<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 15</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 15 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Символическая математика с каноническими формами</h2>
<blockquote class="doxtable">
<p>Меня всегда интересует все простое. </p>
</blockquote>
<blockquote class="doxtable">
<p>-David Hockney </p>
</blockquote>
<p><a href="B978008057115750008X.xhtml">Глава 8</a> началась с больших надежд: взять существующий сопоставитель с образцом, скопировать некоторые математические тождества из справочника и придумать пригодную для использования систему символьной алгебры. Получившаяся система <em>была</em> применима для некоторых целей, и она показала, что техника преобразования на основе правил является мощной. Однако проблемы <a href="B978008057115750008X.xhtml#s0030">раздел 8.5</a> показывают, что не все можно сделать легко и эффективно в рамках инструментария сопоставления с образцом на основе правил.</p>
<p>Существуют важные математические преобразования, которые трудно выразить с помощью подхода, основанного на правилах. Например, деление двух многочленов для получения частного и остатка - это задача, которую легче выразить в виде алгоритма или программы, чем правила или набора правил.</p>
<p>Кроме того, есть проблема с эффективностью. Части входных выражений снова и снова упрощаются, и много времени уходит на интерпретацию неприменимых правил. <a href="B9780080571157500091.xhtml#s0035">Раздел 9.6</a> показал некоторые методы ускорения программы в 100 раз при вводе примерно дюжины символов, но для выражений с примерно сотней символов такого ускорения недостаточно. Мы можем добиться большего, если спроектируем специализированное представление с нуля.</p>
<p>Программы серьезных алгебраических манипуляций обычно применяют понятие <em>канонического упрощения</em>. То есть выражения преобразуются в канонический внутренний формат, который может быть далек от формы ввода. Затем ими манипулируют и переводят обратно во внешнюю форму для вывода. Конечно, упрощатель, который у нас уже есть, в некоторой степени выполняет такой перевод. Он внутренне переводит <code>(3 + x + -3 + y)</code> в <code>(+ x y)</code>, а затем выводит его как <code>(x + y)</code>. Но <em>каноническое</em> представление должно обладать тем свойством, что любые два равных выражения имеют идентичные канонические формы. В нашей системе выражение <code>(5 + y + x + -5)</code> преобразуется во внутреннюю форму <code>(+ y x)</code>, которая не идентична <code>(+ x y)</code>, даже если эти два выражения равны. Таким образом, наша система не является канонической. Большинство проблем предыдущего раздела проистекают из отсутствия канонической формы.</p>
<p>Соблюдение канонической формы накладывает серьезные ограничения на представление. Например, <em>x2</em>- 1 и (<em>x</em> - 1) (<em>x</em> + 1) равны, поэтому они должны быть представлены одинаково. Один из способов гарантировать это - перемножить все факторы и собрать аналогичные термины. Итак, (<em>x</em>- 1)(<em>x</em> + 1) равно <em>x2</em> - <em>x</em> + <em>x</em> - 1, что упрощается до <em>x2</em> - 1 в любой канонической внутренней форме. Этот подход отлично работает для <em>x2</em> - 1, но для такого выражения, как (<em>x</em> - 1) 1000, умножение всех факторов потребует много времени (и места). Трудно найти каноническую форму, идеально подходящую для всех задач. Лучшее, что мы можем сделать, это выбрать ту, которая хорошо подходит для проблем, с которыми мы, скорее всего, столкнемся.</p>
<h2>15.1 Каноническая форма для многочленов(полиномов)</h2>
<p>В этом разделе мы сконцентрируемся на канонической форме для <em>многочленов</em> С математической точки зрения, многочлен - это функция (от одной или нескольких переменных), которую можно вычислить, используя только сложение и умножение. Мы будем говорить о <em>основной переменной многочлена(полинома), коэффициентах</em> и <em>степени</em>. В полиноме:</p>
<p>5xx3+bxx2+cxx+1</p>
<div class="image">
<img src="images/chapter15/si1_e.gif" alt="si1_e"/>
</div>
<p>основная переменная <em>x</em>, степень равна 3 (наивысшая степень <em>x</em>), а коэффициенты равны 5, <em>b, c</em> и 1. Мы можем определить входной формат для полиномов следующим образом:</p>
<ol type="1">
<li>Любое число Лиспа является многочленом. !!!(p) {:.numlist}</li>
<li>Любой символ Лиспа является многочленом. !!!(p) {:.numlist}</li>
<li>Если <em>p</em> и <em>q</em> - многочлены, то (<em>p + q</em>) и (<em>p * q</em>) - тоже. !!!(p) {:.numlist}</li>
<li>Если <em>p</em> - многочлен, а <em>n</em> - положительное целое число, то (<em>p</em> ^ <em>n</em>) - многочлен. !!!(p) {:.numlist}</li>
</ol>
<p>Однако формат ввода нельзя использовать в качестве канонической формы, потому что он допускает как <code>(x + y)</code>, так и <code>(y + x)</code>, а также <code>4</code> и <code>(2 + 2)</code>.</p>
<p>Прежде чем рассматривать каноническую форму для многочленов, давайте посмотрим, почему многочлены были выбраны в качестве целевой области. Во-первых, существенно возрастает объем программирования, необходимый для поддержки канонических форм для более широкого класса выражений. Чтобы упростить задачу, мы устранили такие сложности, как функции log(логарифмические) и trig(тригонометрические). Многочлены - хороший выбор, потому что они замкнуты относительно сложения и умножения: сумма или произведение любых двух многочленов является многочленом. Если бы мы разрешили деление, результат не был бы замкнут, потому что частное двух многочленов не обязательно должно быть многочленом. В качестве бонуса многочлены также замыкаются при дифференцировании и интегрировании, поэтому мы также можем включить эти операторы.</p>
<p>Во-вторых, для достаточно больших классов выражений становится не просто сложно, но и невозможно определить каноническую форму. Это может показаться удивительным, и у нас нет места, чтобы объяснить, почему это так, но вот аргумент: подумайте, что бы произошло, если бы мы добавили достаточно функциональности, чтобы дублировать весь Лисп. Тогда "преобразование в каноническую форму" будет таким же, как "запуск программы". Но элементарным результатом теории вычислимости является то, что в общем случае невозможно определить результат выполнения произвольной программы (это известно как проблема остановки). Таким образом, неудивительно, что невозможно канонизировать сложные выражения.</p>
<p>Наша задача - преобразовать ранее определенный многочлен в некоторую каноническую форму. <a href="#fn0015">1</a> Большая часть кода и некоторые комментарии к этому формату и процедурам для управления им были написаны Ричардом Фейтманом с некоторыми усовершенствованиями. пользователя Peter Klier.</p>
<p>Первое дизайнерское решение - предположить, что мы будем иметь дело в основном с <em>плотными</em> многочленами, а не с <em>разреженными</em>. То есть мы ожидаем, что большинство многочленов будут похожи на <em>ax * 3 * + bx * 2 * + cx * + * d,</em> не на <em>ax * 100 * + bx * 50 + * c.</em> Для плотных многочленов мы можем сэкономить место, представив основную переменную (<em>x</em> в этих примерах) и отдельные коэффициенты (<em>a</em>, <em>b</em>, <em>c</em> и <em>d</em> в этих примерах) явно, но представляя экспоненты только неявно , по позиции. Вместо списков будут использоваться векторы, чтобы сэкономить место и обеспечить быстрый доступ к любому элементу. Таким образом, представление 5 * x * 3 + 10 * x * 2 + 20 * x + * 30 будет вектором:</p>
<div class="fragment"><div class="line">#(x 30 20 10 5)</div></div><!-- fragment --><p>Основная переменная <em>x</em> находится в 0-м элементе вектора, а коэффициент при <em>i</em> -й степени <em>x</em> находится в элементе <em>i</em> + 1 вектора. Одиночная переменная представлена как вектор, первый коэффициент которого равен 1, а число представлено как само себя:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>#(x 30 20 10 5)</code> </td><td>represents 5*x*3 + 10*x*2 + 20*x* + 30 </td></tr>
<tr>
<td><code>#(x 0 1)</code> </td><td>represents <em>x</em> </td></tr>
<tr>
<td><code>5</code> </td><td>represents 5 </td></tr>
</table>
<p>Тот факт, что число представлено самим собой, может вызвать путаницу. Число 5, например, является многочленом согласно нашему математическому определению многочленов. Но он представлен как 5, а не как вектор, поэтому <code>(typep 5 'polynomial)</code> будет ложным. Слово "многочлен" используется неоднозначно для обозначения как математической концепции, так и типа Лисп, но из контекста должно быть ясно, что имеется в виду.</p>
<p>Глоссарий программы канонического упрощения приведен на <a href="#f0010">рисунок 15.1</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter15/f15-01.jpg" alt="f15-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 15.1: Глоссарий программы символьной манипуляции </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<p>Функции, определяющие тип <code>polynomial</code>-полинома, следуют ниже. Поскольку нас интересует эффективность, мы объявляем, что некоторые короткие функции компилируются inline-встроенно, используем конкретную функцию <code>svref</code> (simple-vector reference/ссылка на простой вектор), а не более общую aref, и предоставляем объявления для многочленов с использованием специальной формы the. Более подробная информация по вопросам эффективности приведена в <a href="B9780080571157500091.xhtml">Глава 9</a>.</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline main-var degree coef</div></div><!-- fragment --> <pre class="fragment">          `var= var&gt; poly make-poly))`
</pre><div class="fragment"><div class="line">(deftype polynomial () &#39;simple-vector)</div><div class="line">(defun main-var (p) (svref (the polynomial p) 0))</div><div class="line">(defun coef (p i)  (svref (the polynomial p) (+ i 1)))</div><div class="line">(defun degree (p)  (-(length (the polynomial p)) 2))</div></div><!-- fragment --><p>Нам пришлось принять еще одно дизайнерское решение при определении <code>coef</code>, функции для извлечения коэффициента из полинома. Как указано выше, <em>i</em> -ый коэффициент многочлена находится в элементе вектора <em>i</em> + 1. Если мы потребуем, чтобы вызывающий <code>coef</code> передал <em>i</em> + 1, чтобы получить <em>i</em>, мы могли бы сэкономить несколько операций сложения. Дизайнерское решение заключалось в том, что это будет слишком запутанным и подверженным ошибкам. Таким образом, coef ожидает передачи <em>i</em> и выполняет сложение самостоятельно.</p>
<p>В нашем формате мы будем настаивать на том, чтобы основные переменные были символами, а коэффициенты могли быть числами или другими многочленами. "Производственная" версия программы может учитывать основные переменные, такие как <code>(sin x)</code>, а также другие сложности, такие как + и * с более чем двумя аргументами и нецелочисленными степенями.</p>
<p>Теперь мы можем извлекать информацию из многочлена, но нам также необходимо создавать и изменять многочлены. Функция <code>poly</code> принимает переменную и некоторые коэффициенты и строит вектор, представляющий многочлен. <code>make-poly</code> принимает переменную и степень и производит/создает многочлен со всеми нулевыми коэффициентами.</p>
<div class="fragment"><div class="line">(defun poly (x &amp;rest coefs)</div><div class="line">  &quot;Make a polynomial with main variable x</div><div class="line">  and coefficients in increasing order.&quot;</div><div class="line">  (apply #&#39;vector x coefs))</div><div class="line"></div><div class="line">(defun make-poly (x degree)</div><div class="line">  &quot;Make the polynomial 0 + 0*x + 0*x^2 + ... 0*x^degree&quot;</div><div class="line">  (let ((p (make-array (+ degree 2) :initial-element 0)))</div><div class="line">    (setf (main-var p) x)</div><div class="line">    p))</div></div><!-- fragment --><p>Многочлен можно изменить, установив его основную переменную или любой из его коэффициентов, используя следующие формы <code>defsetf</code>.</p>
<div class="fragment"><div class="line">(defsetf main-var (p) (val)</div><div class="line">  `(setf (svref (the polynomial ,p) 0) ,val))</div><div class="line"></div><div class="line">(defsetf coef (p i) (val)</div><div class="line">  `(setf (svref (the polynomial ,p) (+ ,i 1)) ,val))</div></div><!-- fragment --><p>Функция <code>poly</code> конструирует многочлены аналогично <code>list</code> или <code>vector</code>: с явным списком содержимого, <code>make-poly</code>, с другой стороны, похожа на <code>make-array</code>: она создает многочлен заданного размера.</p>
<p>Мы предоставляем методы <code>setf</code> для изменения основной переменной и коэффициентов. Поскольку это первое использование <code>defsetf</code>, оно заслуживает некоторых пояснений. Форма <code>defsetf</code> принимает имя функции (или макроса), список аргументов и второй список аргументов, который должен состоять из одного аргумента, значения, которое должно быть присвоено. Тело формы - это выражение, в котором значение хранится в нужном месте. Таким образом, <code>defsetf</code> для <code>main-var</code> говорит, что <code>(setf (main-varp) val)</code> эквивалентно <code>(setf (svref (the polynomial p) 0) val)</code>. <code>defsetf</code> очень похож на <code>defmacro</code>, но на писателя <code>defsetf</code> ложится немного меньше бремени. Вместо передачи <code>p</code> и <code>val</code> непосредственно методу <code>setf</code>, Common Lisp связывает локальные переменные с этими выражениями и передает эти переменные методу <code>setf</code>. Таким образом, писателю не нужно беспокоиться об вычислении выражений в неправильном порядке или неправильном количестве раз. Также возможно получить более точный контроль над всем процессом с помощью <code>define-setf-method</code>, как описано на <a href="B978008057115750025X.xhtml#p884">стр. 884</a>.</p>
<p>Функции <code>poly+poly, poly*poly и poly^n</code> выполняют сложение, умножение и возведение в степень многочленов соответственно. Они определены с несколькими вспомогательными функциями. <code>k*poly</code> умножает многочлен на константу,<code>k</code>, которая может быть числом или другим многочленом, не содержащим главной переменной многочлена <code>p</code>. <code>poly*same</code> используется для умножения двух многочленов на одну и ту же главную переменную. Кроме того, аналогичным целям служат функции <code>k+poly</code> и <code>poly+same</code>. Имея это в виду, вот функция для преобразования префикса в каноническую форму:</p>
<div class="fragment"><div class="line">(defun prefix-&gt;canon (x)</div><div class="line">  &quot;Convert a prefix Lisp expression to canonical form.</div><div class="line">  Exs: (+ (^ x 2) (* 3 x)) =&gt; #(x 0 3 1)</div><div class="line">       (- (* (- x 1) (+ x 1)) (- (^ x 2) 1)) =&gt; 0&quot;</div><div class="line">  (cond ((numberp x) x)</div><div class="line">        ((symbolp x) (poly x 0 1))</div><div class="line">        ((and (exp-p x) (get (exp-op x) &#39;prefix-&gt;canon))</div><div class="line">         (apply (get (exp-op x) &#39;prefix-&gt;canon)</div><div class="line">                (mapcar #&#39;prefix-&gt;canon (exp-args x))))</div><div class="line">        (t (error &quot;Not a polynomial: ~a&quot; x))))</div></div><!-- fragment --><p>Она управляется данными и основана на свойстве <code>prefix-&gt;canon</code> каждого оператора. Далее мы устанавливаем соответствующие функции. Существующие функции <code>poly*poly</code> и <code>poly^n</code> можно использовать напрямую. Но другим операторам нужны интерфейсные функции. Операторам + и - нужны интерфейсные функции, которые обрабатывают как унарные, так и бинарные(двойные) данные.</p>
<div class="fragment"><div class="line">(dolist (item &#39;((+ poly+) (- poly-) (* poly*poly)</div><div class="line">                (^ poly^n) (D deriv-poly)))</div><div class="line">  (setf (get (first item) &#39;prefix-&gt;canon) (second item)))</div><div class="line"></div><div class="line">(defun poly+ (&amp;rest args)</div><div class="line">  &quot;Unary or binary polynomial addition.&quot;</div><div class="line">  (ecase (length args)</div><div class="line">    (1 (first args))</div><div class="line">    (2 (poly+poly (first args) (second args)))))</div><div class="line"></div><div class="line">(defun poly- (&amp;rest args)</div><div class="line">  &quot;Unary or binary polynomial subtraction.&quot;</div><div class="line">  (ecase (length args)</div><div class="line">    (0 0)</div><div class="line">    (1 (poly*poly -1 (first args)))</div><div class="line">    (2 (poly+poly (first args) (poly*poly -1 (second args))))))</div></div><!-- fragment --><p>Функция <code>prefix-&gt;canon</code> принимает входные данные, которые не были частью нашего определения многочленов: унарные операторы положительного и отрицательного значений, а также бинарные операторы вычитания и дифференцирования. Это допустимо, потому что все они могут быть сведены к элементарным операциям + и *.</p>
<p>Помните, что наши проблемы с канонической формой начались с неспособности решить, что проще: <code>(+ x y)</code> или <code>(+ y x)</code>. В этой системе мы определяем каноническую форму, налагая порядок на переменные (мы используем алфавитный порядок, как определено <code>string&gt;</code>). Правило состоит в том, что полином <code>p</code> может иметь коэффициенты, которые являются полиномами от переменной, расположенной позже в алфавите, чем основная переменная <code>p</code>, но не коэффициенты, которые являются полиномами от переменных, предшествующих основной переменной <code>p</code>. Вот как сравнивать переменные:</p>
<div class="fragment"><div class="line">(defun var= (x y) (eq x y))</div><div class="line">(defun var&gt; (x y) (string&gt; x y))</div></div><!-- fragment --><p>Каноническая форма переменной <code>x</code> будет <code>#(x 0 1)</code>, что равно 0 x *x*0 + 1 x *x*1. Каноническая форма <code>(+ x y)</code> это <code>#(x #(y 0 1) 1)</code>. Она не может быть <code>#(y #(x 0 1) 1)</code>, потому что тогда полученный многочлен будет иметь коэффициент с меньшей основной переменной. Политика упорядочивания переменных обеспечивает каноничность за счет правильного группирования одинаковых переменных вместе и наложения определенного порядка на выражения, которые в противном случае были бы коммутативными.</p>
<p>Итак, вот код для сложения двух многочленов:</p>
<div class="fragment"><div class="line">(defun poly+poly (p q)</div><div class="line">  &quot;Add two polynomials.&quot;</div><div class="line">  (normalize-poly</div><div class="line">    (cond</div><div class="line">      ((numberp p)                      (k+poly p q))</div><div class="line">      ((numberp q)                      (k+poly q p))</div><div class="line">      ((var= (main-var p) (main-var q)) (poly+same p q))</div><div class="line">      ((var&gt; (main-var q) (main-var p)) (k+poly q p))</div><div class="line">      (t                                (k+poly p q)))))</div><div class="line"></div><div class="line">(defun k+poly (k p)</div><div class="line">  &quot;Add a constant k to a polynomial p.&quot;</div><div class="line">  (cond ((eql k 0) p)                 ;; 0 + p = p</div><div class="line">        ((and (numberp k) (numberp p))</div><div class="line">         (+ k p))                     ;; Add numbers</div><div class="line">        (t (let ((r (copy-poly p)))   ;; Add k to x^0 term of p</div><div class="line">             (setf (coef r 0) (poly+poly (coef r 0) k))</div><div class="line">             r))))</div><div class="line"></div><div class="line">(defun poly+same (p q)</div><div class="line">  &quot;Add two polynomials with the same main variable.&quot;</div><div class="line">  ;; First assure that q is the higher degree polynomial</div><div class="line">  (if (&gt; (degree p) (degree q))</div><div class="line">      (poly+same q p)</div><div class="line">      ;; Add each element of p into r (which is a copy of q).</div><div class="line">      (let ((r (copy-poly q)))</div><div class="line">        (loop for i from 0 to (degree p) do</div><div class="line">              (setf (coef r i) (poly+poly (coef r i) (coef p i))))</div><div class="line">        r)))</div><div class="line"></div><div class="line">(defun copy-poly (p)</div><div class="line">  &quot;Make a copy a polynomial.&quot;</div><div class="line">  (copy-seq p))</div></div><!-- fragment --><p>и код для умножения многочленов:</p>
<div class="fragment"><div class="line">(defun poly*poly (p q)</div><div class="line">  &quot;Multiply two polynomials.&quot;</div><div class="line">  (normalize-poly</div><div class="line">    (cond</div><div class="line">      ((numberp p)                      (k*poly p q))</div><div class="line">      ((numberp q)                      (k*poly q p))</div><div class="line">      ((var= (main-var p) (main-var q)) (poly*same p q))</div><div class="line">      ((var&gt; (main-var q) (main-var p)) (k*poly q p))</div><div class="line">      (t                                (k*poly p q)))))</div><div class="line"></div><div class="line">(defun k*poly (k p)</div><div class="line">  &quot;Multiply a polynomial p by a constant factor k.&quot;</div><div class="line">  (cond</div><div class="line">    ((eql k 0)         0)       ;; 0 * p = 0</div><div class="line">    ((eql k 1)         p)       ;; 1 * p = p</div><div class="line">    ((and (numberp k)</div><div class="line">          (numberp p)) (* k p)) ;; Multiply numbers</div><div class="line">    (t ;; Multiply each coefficient</div><div class="line">     (let ((r (make-poly (main-var p) (degree p))))</div><div class="line">       ;; Accumulate result in r;  r[i] = k*p[i]</div><div class="line">       (loop for i from 0 to (degree p) do</div><div class="line">             (setf (coef r i) (poly*poly k (coef p i))))</div><div class="line">       r))))</div></div><!-- fragment --><p>Сложная часть - это умножение двух многочленов на одну и ту же главную переменную. Это делается путем создания нового полинома, <code>r</code>, степень которого является суммой двух входных полиномов <code>p</code> и <code>q</code>. Первоначально все коэффициенты <code>r</code> равны нулю. Дважды вложенный цикл умножает каждый коэффициент <code>p</code> и <code>q</code> и добавляет результат к соответствующему коэффициенту <code>r</code>.</p>
<div class="fragment"><div class="line">(defun poly*same (p q)</div><div class="line">  &quot;Multiply two polynomials with the same variable.&quot;</div><div class="line">  ;; r[i] = p[0]*q[i] + p[1]*q[i-1] + ...</div><div class="line">  (let* ((r-degree (+ (degree p) (degree q)))</div><div class="line">         (r (make-poly (main-var p) r-degree)))</div><div class="line">    (loop for i from 0 to (degree p) do</div><div class="line">          (unless (eql (coef p i) 0)</div><div class="line">            (loop for j from 0 to (degree q) do</div><div class="line">                  (setf (coef r (+ i j))</div><div class="line">                        (poly+poly (coef r (+ i j))</div><div class="line">                                   (poly*poly (coef p i)</div><div class="line">                                              (coef q j)))))))</div><div class="line">    r))</div></div><!-- fragment --><p>И <code>poly+poly</code>, и <code>poly*poly</code> используют функцию <code>normalize-poly</code> для "нормализации" результата. Идея состоит в том, что <code>(- (^ 5) (^ x 5))</code> должен возвращать 0, а не <code>#(x 0 0 0 0 0 0)</code>. Обратите внимание, что <code>normalize-poly</code> - это деструктивная операция: она вызывает <code>delete</code>, что может фактически изменить ее аргумент. Обычно это опасно, но поскольку <code>normalize-poly</code> заменяет что-то его концептуальным эквивалентом, никакого вреда не происходит.</p>
<div class="fragment"><div class="line">(defun normalize-poly (p)</div><div class="line">  &quot;Alter a polynomial by dropping trailing zeros.&quot;</div><div class="line">  (if (numberp p)</div><div class="line">      p</div><div class="line">      (let ((p-degree (- (position 0 p :test (complement #&#39;eql)</div><div class="line">                                       :from-end t)</div><div class="line">                         1)))</div><div class="line">        (cond ((&lt;= p-degree 0) (normalize-poly (coef p 0)))</div><div class="line">              ((&lt; p-degree (degree p))</div><div class="line">               (delete 0 p :start p-degree))</div><div class="line">              (t p)))))</div></div><!-- fragment --><p>Есть несколько незакрепленных концов, которые нужно исправить. Во-первых, функция возведения в степень:</p>
<div class="fragment"><div class="line">(defun poly^n (p n)</div></div><!-- fragment --><p><code>"Raise polynomial p to the nth power, n&gt;=0."</code></p>
<p><code>(check-type n (integer 0 *))</code></p>
<p><code>(cond ((= n 0) (assert (not (eql p 0))) 1)</code> </p><pre class="fragment">`((integerp p) (expt p n))`

`(t (poly*poly p (poly^n p (- n 1))))))`
</pre><h2>15.2 Дифференцирование Многочленов</h2>
<p>Процедура дифференцирования проста, в основном потому, что нужно иметь дело только с двумя операторами (+ и \ *):</p>
<div class="fragment"><div class="line">(defun deriv-poly (p x)</div><div class="line">  &quot;Return the derivative, dp/dx, of the polynomial p.&quot;</div><div class="line">  ;; If p is a number or a polynomial with main-var &gt; x,</div><div class="line">  ;; then p is free of x, and the derivative is zero;</div><div class="line">  ;; otherwise do real work.</div><div class="line">  ;; But first, make sure X is a simple variable,</div><div class="line">  ;; of the form #(X 0 1).</div><div class="line">  (assert (and (typep x &#39;polynomial) (= (degree x) 1)</div><div class="line">         (eql (coef x 0) 0) (eql (coef x 1) 1)))</div><div class="line">  (cond</div><div class="line">    ((numberp p) 0)</div><div class="line">    ((var&gt; (main-var p) (main-var x)) 0)</div><div class="line">    ((var= (main-var p) (main-var x))</div><div class="line">     ;; d(a + bx + cx^2 + dx^3)/dx = b + 2cx + 3dx^2</div><div class="line">     ;; So, shift the sequence p over by 1, then</div><div class="line">     ;; put x back in, and multiply by the exponents</div><div class="line">     (let ((r (subseq p 1)))</div><div class="line">       (setf (main-var r) (main-var x))</div><div class="line">       (loop for i from 1 to (degree r) do</div><div class="line">             (setf (coef r i) (poly*poly (+ i 1) (coef r i))))</div><div class="line">       (normalize-poly r)))</div><div class="line">    (t ;; Otherwise some coefficient may contain x.  Ex:</div><div class="line">     ;; d(z + 3x + 3zx^2 + z^2x^3)/dz</div><div class="line">     ;; = 1 +  0 +  3x^2 +  2zx^3</div><div class="line">     ;; So copy p, and differentiate the coefficients.</div><div class="line">     (let ((r (copy-poly p)))</div><div class="line">       (loop for i from 0 to (degree p) do</div><div class="line">             (setf (coef r i) (deriv-poly (coef r i) x)))</div><div class="line">       (normalize-poly r)))))</div></div><!-- fragment --><p><b>Упражнение 15.1 [h]</b> Интегрировать многочлены не намного сложнее, чем их дифференцировать. Например:</p>
<p>&int;ax2+bxdx=ax33+bx22+c.</p>
<div class="image">
<img src="images/chapter15/si2_e.gif" alt="si2_e"/>
</div>
<p>Напишите функцию для интеграции многочленов и установите ее в <code>prefix-&gt;canon</code>.</p>
<p><b>Упражнение 15.2 [m]</b> Добавьте поддержку <em>определенных</em> интегралов, таких как &int;abydx !!!(span) {:.hiddenClass} </p><div class="image">
<img src="images/chapter15/si3_e.gif" alt="si3_e"/>
</div>
<p>. Вам нужно будет составить подходящую нотацию и правильно установить ее как в <code>infix-&gt;prefix</code>, так и в <code>prefix-&gt;canon</code>. Полная реализация этой функции должна рассматривать бесконечность как границу, а также проблему интегрирования по сингулярностям. Вам не нужно заниматься этими проблемами.</p>
<h2>15.3 Преобразование между инфиксом и префиксом</h2>
<p>Остается только преобразовать каноническую форму обратно в префиксную, а оттуда обратно в инфиксную. Это хороший момент для расширения формы префикса, чтобы можно было использовать выражения с более чем двумя аргументами. Сначала мы показываем обновленную версию <code>prefix-&gt;infix</code>, которая обрабатывает несколько аргументов:</p>
<div class="fragment"><div class="line">(defun prefix-&gt;infix (exp)</div><div class="line">  &quot;Translate prefix to infix expressions.</div><div class="line">  Handles operators with any number of args.&quot;</div><div class="line">  (if (atom exp)</div><div class="line">      exp</div><div class="line">      (intersperse</div><div class="line">        (exp-op exp)</div><div class="line">        (mapcar #&#39;prefix-&gt;infix (exp-args exp)))))</div><div class="line"></div><div class="line">(defun intersperse (op args)</div><div class="line">  &quot;Place op between each element of args.</div><div class="line">  Ex: (intersperse &#39;+ &#39;(a b c)) =&gt; &#39;(a + b + c)&quot;</div><div class="line">  (if (length=1 args)</div><div class="line">      (first args)</div><div class="line">      (rest (loop for arg in args</div><div class="line">               collect op</div><div class="line">               collect arg))))</div></div><!-- fragment --><p>Теперь нам нужно только преобразовать из канонической формы в префикс:</p>
<div class="fragment"><div class="line">(defun canon-&gt;prefix (p)</div><div class="line">  &quot;Convert a canonical polynomial to a lisp expression.&quot;</div><div class="line">  (if (numberp p)</div><div class="line">      p</div><div class="line">      (args-&gt;prefix</div><div class="line">        &#39;+ 0</div><div class="line">        (loop for i from (degree p) downto 0</div><div class="line">              collect (args-&gt;prefix</div><div class="line">                        &#39;* 1</div><div class="line">                        (list (canon-&gt;prefix (coef p i))</div><div class="line">                              (exponent-&gt;prefix</div><div class="line">                                (main-var p) i)))))))</div><div class="line"></div><div class="line">(defun exponent-&gt;prefix (base exponent)</div><div class="line">  &quot;Convert canonical base^exponent to prefix form.&quot;</div><div class="line">  (case exponent</div><div class="line">    (0 1)</div><div class="line">    (1 base)</div><div class="line">    (t `(^ ,base ,exponent))))</div><div class="line"></div><div class="line">(defun args-&gt;prefix (op identity args)</div><div class="line">  &quot;Convert arg1 op arg2 op ... to prefix form.&quot;</div><div class="line">  (let ((useful-args (remove identity args)))</div><div class="line">    (cond ((null useful-args) identity)</div><div class="line">          ((and (eq op &#39;*) (member 0 args)) 0)</div><div class="line">          ((length=1 args) (first useful-args))</div><div class="line">          (t (cons op (mappend</div><div class="line">                        #&#39;(lambda (exp)</div><div class="line">                            (if (starts-with exp op)</div><div class="line">                                (exp-args exp)</div><div class="line">                                (list exp)))</div><div class="line">                        useful-args))))))</div></div><!-- fragment --><p>Наконец, вот верхний уровень, чтобы все это использовать:</p>
<div class="fragment"><div class="line">(defun canon (infix-exp)</div><div class="line">  &quot;Canonicalize argument and convert it back to infix&quot;</div><div class="line">  (prefix-&gt;infix (canon-&gt;prefix (prefix-&gt;canon (infix-&gt;prefix infix-exp)))))</div><div class="line"></div><div class="line">(defun canon-simplifier ()</div><div class="line">  &quot;Read an expression, canonicalize it, and print the result.&quot;</div><div class="line">  (loop</div><div class="line">    (print &#39;canon&gt;)</div><div class="line">    (print (canon (read)))))</div></div><!-- fragment --><p>и пример его использования:</p>
<div class="fragment"><div class="line">&gt; (canon-simplifier)</div><div class="line">CANON&gt; (3 + x + 4 - x)</div><div class="line">7</div><div class="line">CANON&gt; (x + y + y + x)</div><div class="line">((2 * X) + (2 * Y))</div><div class="line">CANON&gt; (3 * x + 4 * x)</div><div class="line">(7 * X)</div><div class="line">CANON&gt; (3 * x + y + x + 4 * x)</div><div class="line">((8 * X) + Y)</div><div class="line">CANON&gt; (3 * x + y + z + x + 4 * x)</div><div class="line">((8 * X) + (Y + Z))</div><div class="line">CANON&gt; ((x + 1) ^ 10)</div><div class="line">((X ^ 10) + (10 * (X ^ 9)) + (45 * (X ^ 8)) + (120 * (X ^ 7))</div></div><!-- fragment --><p><code>+ (210 * (X ^ 6)) + (252 * (X ^ 5)) + (210 * (X ^ 4))</code></p>
<p><code>+ (120 * (X ^ 3)) + (45 * (X ^ 2)) + (10 * X) + 1)</code></p>
<div class="fragment"><div class="line">CANON&gt; ((x + 1) ^ 10 + (x - 1) ^ 10)</div><div class="line">((2 * (X ^ 10)) + (90 * (X ^ 8)) + (420 * (X ^ 6))</div></div><!-- fragment --><p><code>+ (420 * (X ^ 4)) + (90 * (X ^ 2)) + 2)</code></p>
<div class="fragment"><div class="line">CANON&gt; ((x + 1) ^ 10 - (x - 1) ^ 10)</div><div class="line">((20 * (X ^ 8)) + (240 * (X ^ 7)) + (504 * (X ^ 5))</div></div><!-- fragment --><p><code>+ (240 * (X ^ 3)) + (20 * X))</code></p>
<div class="fragment"><div class="line">CANON&gt; (3 * x ^ 3 + 4 * x * y * (x - 1) + x ^ 2 * (x + y))</div><div class="line">((4 * (X ^ 3)) + ((5 * Y) * (X ^ 2)) + ((-4 * Y) * X))</div><div class="line">CANON&gt; (3 * x ^ 3 + 4 * x * w * (x - 1) + x ^ 2 * (x + w))</div><div class="line">((((5 * (X ^ 2)) + (-4 * X)) * W) + (4 * (X ^ 3)))</div><div class="line">CANON&gt; (d (3 * x ^ 2 + 2 * x + 1) / d x)</div><div class="line">((6 * X) + 2)</div><div class="line">CANON&gt; (d(z + 3 * x + 3 * z * x ^ 2 + z ^ 2 * x ^ 3) / d z)</div><div class="line">(((2 * Z) * (X ^ 3)) + (3 * (X ^ 2)) + 1)</div><div class="line">CANON&gt; [Abort]</div></div><!-- fragment --><h2>15.4 Сравнительный анализ упрощения многочленов/полиномов</h2>
<p>В отличие от программы, основанной на правилах, эта версия дает правильные ответы на все вопросы. Программа не только правильная (по крайней мере, в этих примерах), она еще и быстрая. Мы можем сравнить его с каноническим упрощением, первоначально написанным для MACSYMA Уильямом Мартином (около 1968 г.) и модифицированным Ричардом Фейтманом. Модифицированная версия была использована Ричардом Габриэлем в его наборе тестов Common Lisp (1985). Программа тестирования называется <code>frpoly</code>, потому что она имеет дело с полиномами и изначально была написана на диалекте Franz Lisp. Тест <code>frpoly</code> кодирует многочлены в виде списков, а не векторов, и делает все возможное, чтобы быть эффективной. В остальном она похожа на используемые здесь алгоритмы (хотя сам код совершенно другой, в нем используются progs и gos и другие функциональности, которые пришли в немилость за прошедшие десятилетия). Конкретный тест, который мы будем использовать здесь, возводит 1 ***+** x + y + z* в 15-ю степень:</p>
<div class="fragment"><div class="line">(defun r15-test ()</div></div><!-- fragment --><p>`(let ((r (prefix-&gt;canon'(+ 1 (+ x (+ y z))))))`</p>
<p><code>(time (poly^n r 15))</code></p>
<p><code>nil))</code></p>
<p>В нашей системе это занимает 0,97 секунды. Эквивалентный тест с исходным кодом <code>frpoly</code> занимает примерно такое же время: 0,98 секунды. Таким образом, наша программа работает так же быстро, как и код производственного качества. Что касается места для хранения, векторы используют примерно половину памяти, чем списки, потому что половина каждой cons-ячейки является указателем, а все векторы - это полезные данные. <a href="#fn0020">2</a></p>
<p>Насколько быстрее код на основе полиномов, чем версия на основе правил? К сожалению, мы не можем ответить на этот вопрос напрямую. Мы можем время `(simp ' ( (1 + x + y + z) ^ 15)))`. Это занимает всего десятую долю секунды, но это потому, что он не выполняет никакой работы - ответ такой же, как и ввод! В качестве альтернативы, мы можем взять выражение, вычисленное с помощью <code>(poly^n r 15)</code>, преобразовать его в префикс и передать это `для упрощения. Упрощение занимает 27,8 секунды, поэтому версия на основе правил работает намного медленнее. <a href="B9780080571157500091.xhtml#s0035">Раздел 9.6</a> описывает способы ускорения программы, основанной на правилах, а сравнение данных времени появляется на <a href="#p525">страница 525</a>.</p>
<p>Когда дело доходит до измерения временных данных, всегда есть сюрпризы. Например, читатель предупреждений мог заметить, что версия <code>poly^n</code>, определенная выше, требует умножений на <em>n</em>. Обычно возведение в степень выполняется возведением в квадрат значения, когда показатель степени четный. Такой алгоритм использует только log <em>n</em> умножений вместо <em>n.</em> Мы можем добавить строку к определению <code>poly^n</code>, чтобы получить алгоритм <em>O</em>(log <em>n</em>):</p>
<div class="fragment"><div class="line">(defun poly^n (p n)</div></div><!-- fragment --><p><code>"Raise polynomial p to the nth power, n&gt;=0."</code></p>
<p><code>(check-type n (integer 0 *))</code></p>
<p><code>(cond ((= n 0) (assert (not (eql p 0))) 1)</code> </p><pre class="fragment">`((integerp p) (expt p n))`

`((evenp n) (poly^2 (poly^n p (/ n 2)))) ;***`

`(t (poly*poly p (poly^n p (- n 1))))))`
</pre><div class="fragment"><div class="line">(defun poly^2 (p) (poly*poly p p))</div></div><!-- fragment --><p>Сюрприз в том, что возведение <code>*r*</code> в 15-ю степень занимает <em>больше</em> времени. Несмотря на то, что он выполняет меньше операций <code>poly*poly</code>, он выполняет их с более сложными аргументами, и в целом работы требуется больше. Если мы используем эту версию <code>poly^n</code>, то <code>r15-test</code> занимает 1,6 секунды вместо 0,98 секунды.</p>
<p>Кстати, это прекрасный пример концептуальной мощи рекурсивных функций. Мы взяли существующую функцию poly^n, добавили одно предложение cond и изменили алгоритм с <em>O</em>(<em>n</em>) на <em>O</em>(log <em>n</em>). (Это оказалось плохой идеей, но это не относится к делу. Было бы неплохо возводить целые числа в степени.) Рассуждения, позволяющие сделать это изменение, просты: во-первых, * pn * определенно равно (<em>p**n</em>/2)2, когда <em>n</em> четно, поэтому изменение не может привести к неправильным ответам. Во-вторых, изменение продолжает политику уменьшения <em>n</em> при каждом рекурсивном вызове, поэтому функция должна в конечном итоге завершиться (когда *n =* 0). Если она не дает неправильных ответов и завершается, значит, она должна дать правильный ответ.</p>
<p>Напротив, внести изменения в итерационный алгоритм более сложно. Первоначальный алгоритм прост:</p>
<div class="fragment"><div class="line">(defun poly^n (p n)</div></div><!-- fragment --><p><code>(let ((result 1))</code></p>
<p><code>(loop repeat n do (setf result (poly*poly p result)))</code></p>
<p><code>result))</code></p>
<p>Но чтобы изменить его, мы должны изменить цикл повторения на цикл <code>while</code>, явно указать декремент <em>n</em> и вставить тест для четного случая:</p>
<div class="fragment"><div class="line">(defun poly^n (p n)</div></div><!-- fragment --><p><code>(let ((result 1))</code></p>
<p><code>(loop while (&gt; n 0)</code></p>
<p><code>do (if (evenp n)</code> </p><pre class="fragment">`(setf p (poly^2 p)`

    `n (/ n 2))`

`(setf result (poly*poly p result)`

    `n (- n 1))))`
</pre><p><code>result))</code></p>
<p>Для этой проблемы ясно, что рекурсивное мышление приводит к более простой функции, которую легче изменить.</p>
<p>Оказывается, это не последнее слово. Возведение в степень многочленов может быть выполнено еще быстрее, с немного большей математической сложностью. <a href="B9780080571157500285.xhtml#bb0380">Ричард Фейтман, 1974</a> статья о полиномиальном умножении анализирует сложность множества алгоритмов возведения в степень. Вместо обычного асимптотического анализа (например, <em>O</em>(<em>n</em>) or <em>O</em>(<em>n*2)), он использует детальный анализ, который вычисляет постоянные коэффициенты (например, 1000 x *n</em> or 2 x <em>n*2). Такой анализ важен для малых значений *n</em>. Оказывается, что для множества многочленов лучше всего подходит алгоритм возведения в степень, основанный на биномиальной теореме. Биномиальная теорема утверждает, что</p>
<p>a+bn=&Sigma;i=0nn!i!n-i!aibn-i</p>
<div class="image">
<img src="images/chapter15/si4_e.gif" alt="si4_e"/>
</div>
<p>например,</p>
<p>a+b3=b3+3ab2+3a2b+a3</p>
<div class="image">
<img src="images/chapter15/si5_e.gif" alt="si5_e"/>
</div>
<p>Мы можем использовать эту теорему, чтобы вычислить степень многочлена сразу, вместо того, чтобы вычислять ее многократным умножением или возведением в квадрат. Конечно, многочлен, как правило, представляет собой сумму более чем двух компонентов, поэтому мы должны решить, как разбить его на части <em>a</em> и <em>b</em>. Есть два очевидных способа: либо разделить многочлен пополам, чтобы <em>a</em> и <em>b</em> были одинакового размера, либо разделить по одному компоненту за раз. Фейтман показывает, что последний метод в большинстве случаев более эффективен. Другими словами, полином k1xn+k2xn-1+k3xn-2+... !!!(span) {:.hiddenClass} </p><div class="image">
<img src="images/chapter15/si6_e.gif" alt="si6_e"/>
</div>
<p> будет рассматриваться как сумма <em>a</em>= <em>k*1*xn</em> и <em>b</em> - остальная часть многочлена.</p>
<p>Ниже приведен код для биномиального возведения в степень. Он несколько беспорядочен, потому что упор делается на эффективность. Это означает повторное использование некоторых данных и использование <code>p-add-into!</code> Вместо более общего <code>poly+poly</code>.</p>
<div class="fragment"><div class="line">(defun poly^n (p n)</div><div class="line">  &quot;Raise polynomial p to the nth power, n&gt;=0.&quot;</div><div class="line">  ;; Uses the binomial theorem</div><div class="line">  (check-type n (integer 0 *))</div><div class="line">  (cond</div><div class="line">    ((= n 0) 1)</div><div class="line">    ((integerp p) (expt p n))</div><div class="line">    (t ;; First: split the polynomial p = a + b, where</div><div class="line">     ;; a = k*x^d and b is the rest of p</div><div class="line">     (let ((a (make-poly (main-var p) (degree p)))</div><div class="line">           (b (normalize-poly (subseq p 0 (- (length p) 1))))</div><div class="line">           ;; Allocate arrays of powers of a and b:</div><div class="line">           (a^n (make-array (+ n 1)))</div><div class="line">           (b^n (make-array (+ n 1)))</div><div class="line">           ;; Initialize the result:</div><div class="line">           (result (make-poly (main-var p) (* (degree p) n))))</div><div class="line">       (setf (coef a (degree p)) (coef p (degree p)))</div><div class="line">       ;; Second: Compute powers of a^i and b^i for i up to n</div><div class="line">       (setf (aref a^n 0) 1)</div><div class="line">       (setf (aref b^n 0) 1)</div><div class="line">       (loop for i from 1 to n do</div><div class="line">             (setf (aref a^n i) (poly*poly a (aref a^n (- i 1))))</div><div class="line">             (setf (aref b^n i) (poly*poly b (aref b^n (- i 1)))))</div><div class="line">       ;; Third: add the products into the result,</div><div class="line">       ;; so that result[i] = (n choose i) * a^i * b^(n-i)</div><div class="line">       (let ((c 1)) ;; c helps compute (n choose i) incrementally</div><div class="line">         (loop for i from 0 to n do</div><div class="line">               (p-add-into! result c</div><div class="line">                            (poly*poly (aref a^n i)</div><div class="line">                                 (aref b^n (- n i))))</div><div class="line">               (setf c (/ (* c (- n i)) (+ i 1)))))</div><div class="line">       (normalize-poly result)))))</div><div class="line"></div><div class="line">(defun p-add-into! (result c p)</div><div class="line">  &quot;Destructively add c*p into result.&quot;</div><div class="line">  (if (or (numberp p)</div><div class="line">          (not (var= (main-var p) (main-var result))))</div><div class="line">      (setf (coef result 0)</div><div class="line">            (poly+poly (coef result 0) (poly*poly c p)))</div><div class="line">      (loop for i from 0 to (degree p) do</div><div class="line">            (setf (coef result i)</div><div class="line">                  (poly+poly (coef result i) (poly*poly c (coef p i))))))</div><div class="line">  result)</div></div><!-- fragment --><p>Использование этой версии <code>poly^n, r15-test</code> занимает всего 0,23 секунды, что в четыре раза быстрее, чем в предыдущей версии. В следующей таблице сравнивается время для <code>r15-test</code> с тремя версиями <code>poly^n</code>, а также время для применения <code>simply</code> к полиному <code>r15</code> для различных версий <code>simplify</code>:</p>
<table class="doxtable">
<tr>
<th></th><th>program </th><th>secs </th><th>speed-up  </th></tr>
<tr>
<td></td><td><b>rule-based versions</b> </td><td></td><td></td></tr>
<tr>
<td>1 </td><td>original </td><td>27.8 </td><td>- </td></tr>
<tr>
<td>2 </td><td>memoization </td><td>7.7 </td><td>4 </td></tr>
<tr>
<td>3 </td><td>memo+index </td><td>4.0 </td><td>7 </td></tr>
<tr>
<td>4 </td><td>compilation only </td><td>2.5 </td><td>11 </td></tr>
<tr>
<td>5 </td><td>memo+compilation </td><td>1.9 </td><td>15 </td></tr>
<tr>
<td></td><td><b>canonical versions</b> </td><td></td><td></td></tr>
<tr>
<td>6 </td><td>squaring <code>poly^n</code> </td><td>1.6 </td><td>17 </td></tr>
<tr>
<td>7 </td><td>iterative <code>poly^n</code> </td><td>.98 </td><td>28 </td></tr>
<tr>
<td>8 </td><td>binomial <code>poly^n</code> </td><td>.23 </td><td>120 </td></tr>
</table>
<p>Как мы уже отмечали ранее, общие методы (memoization)запоминания, индексации и компиляции значительно ускоряют работу. Однако в конечном итоге они не приводят к самой быстрой программе. Вместо этого самая быстрая версия была достигнута за счет отказа от исходной программы, основанной на правилах, замены ее программой, основанной на канонической форме, и тонкой настройки алгоритмов в этой программе с использованием математического анализа.</p>
<p>Теперь, когда мы создали достаточно быструю систему, в следующих двух разделах мы сосредоточимся на том, чтобы сделать ее более мощной.</p>
<h2>15.5 Каноническая форма рациональных выражений</h2>
<p><em>Рациональное</em> число определяется как дробь: частное двух целых чисел. <em>Рациональное выражение</em> определяется как отношение двух многочленов. В этом разделе представлена каноническая форма рациональных выражений.</p>
<p>Во-первых, число или многочлен будет по-прежнему представляться, как и раньше. Частное двух многочленов(полиномов) будет представлено как cons-ячейки пар - числитель и знаменатель. Однако так же, как Lisp автоматически приводит рациональные числа к простейшей форме (6/8 представлено как 3/4), мы должны сокращать рациональные выражения. Так, например, (<em>x*2- 1)/(*x</em>- 1) нужно сократить до <em>x</em> + 1, а не оставить как частное двух многочленов.</p>
<p>Следующие функции создают рациональные выражения и обращаются к ним, но не сводятся к простейшей форме, за исключением случая, когда знаменателем является число. Создание остальной функциональности для полноценного рационального выражения остается за серией упражнений:</p>
<div class="fragment"><div class="line">(defun make-rat (numerator denominator)</div><div class="line">  &quot;Build a rational: a quotient of two polynomials.&quot;</div><div class="line">  (if (numberp denominator)</div><div class="line">      (k*poly (/ 1 denominator) numerator)</div><div class="line">      (cons numerator denominator)))</div><div class="line"></div><div class="line">(defun rat-numerator (rat)</div><div class="line">  &quot;The numerator of a rational expression.&quot;</div><div class="line">  (typecase rat</div><div class="line">    (cons (car rat))</div><div class="line">    (number (numerator rat))</div><div class="line">    (t rat)))</div><div class="line"></div><div class="line">(defun rat-denominator (rat)</div><div class="line">  &quot;The denominator of a rational expression.&quot;</div><div class="line">  (typecase rat</div><div class="line">    (cons (cdr rat))</div><div class="line">    (number (denominator rat))</div><div class="line">    (t 1)))</div></div><!-- fragment --><p>**Упражнение 15.3 [s ** Измените <code>prefix-&gt; canon</code>, чтобы принимать входные данные в форме <code>x / y</code> и возвращать рациональные выражения вместо многочленов. Также разрешите ввод формы <code>x ^ - n</code>.</p>
<p><b>Exercise 15.4 [m]</b> Добавьте арифметические процедуры для умножения, сложения и деления рациональных выражений. Назовите их <code>rat*rat, rat+rat</code>, и <code>rat/rat</code> соответственно. Они будут вызывать <code>poly*poly. poly+poly</code> и новую функцию <code>poly/poly</code>, которая определена в следующем упражнении.</p>
<p><b>Упражнение 15.5 [h]</b> Определите <code>poly-gcd</code>, которая вычисляет наибольший общий делитель двух многочленов.</p>
<p><b>Упражнение 15.6 [h]</b> Используя <code>poly-gcd</code>, определите функцию <code>poly/poly</code>, которая будет реализовывать деление для многочленов. Многочлены замкныты для сложения и умножения, поэтому обе возвращают многочлены <code>poly+poly</code> и <code>poly*poly</code>. Многочлены не замкнуты для деления, поэтому <code>poly/poly</code> вернет рациональное выражение.</p>
<h2>15.6 Расширение рациональных выражений</h2>
<p>Теперь, когда мы можем делить многочлены, последний шаг - восстановить логарифмическую, экспоненциальную и тригонометрическую функции. Проблема в том, что если мы разрешим все эти функции, мы снова столкнемся с проблемами канонической формы. Например, следующие три выражения эквивалентны:</p>
<p>sinxcosx-&pi;2eix-e-ix2i</p>
<div class="image">
<img src="images/chapter15/si7_e.gif" alt="si7_e"/>
</div>
<p>Если нас интересует каноническая форма, безопаснее всего разрешить только <em>e**x*** и log(*x</em>). Все остальные функции могут быть определены в терминах этих двух. С помощью этого расширения набор выражений, которые мы можем формировать замыкание при дифференцировании, и можно канонизировать выражения. <code>result</code> - это математически обоснованная конструкция, известная как <em>дифференцируемое поле.</em> Это именно та конструкция, которую предполагает алгоритм интегрирования Риша (<a href="B9780080571157500285.xhtml#bb0985">Risch 1969</a>, <a href="B9780080571157500285.xhtml">1979</a>#bb0990)).</p>
<p>Недостатком этого минимального расширения является то, что ответы могут быть выражены незнакомыми терминами. Пользователь спрашивает <em>d</em> sin(<em>x2</em>)*/dx,* ожидая простого ответа в терминах cos, и с удивлением видит сложный ответ, включающий <em>eix</em>. Из-за этой проблемы большинство систем компьютерной алгебры сделали более радикальные расширения, допустив sin, cos и другие функции. Эти системы ступают по тонкому математическому льду. Алгоритмы, которые гарантированно работают с простым дифференцируемым полем, могут дать сбой при таком расширении области. В общем, результатом будет не неправильный ответ, а скорее невозможность найти ответ вообще.</p>
<h2>15.7 История и ссылки</h2>
<p>A brief history of symbolic algebra systems is given in <a href="B978008057115750008X.xhtml">chapter 8</a>. <a href="B9780080571157500285.xhtml#bb0385">Fateman (1979)</a>, <a href="B9780080571157500285.xhtml#bb0775">Martin and Fateman (1971)</a>, and <a href="B9780080571157500285.xhtml#bb0270">Davenport et al. (1988)</a> give more details on the MACSYMA system, on which this chapter is loosely based. <a href="B9780080571157500285.xhtml#bb0390">Fateman (1991)</a> discusses the <code>frpoly</code> benchmark and introduces the vector implementation used in this chapter.</p>
<h2>15.8 Exercises</h2>
<p><b>Exercise 15.7 [h]</b> Implement an extension of the rationals to include logarithmic, exponential, and trigonometrie functions.</p>
<p><b>Exercise 15.8 [m]</b> Modify <code>deriv</code> to handle the extended rational expressions.</p>
<p><b>Exercise 15.9 [d]</b> Adapt the integration routine from <a href="B9780080571157500078.xhtml#s0035">section 8.6</a> (<a href="B978008057115750008X.xhtml#p252">page 252</a>) to the rational expression representation. <a href="B9780080571157500285.xhtml#bb0270">Davenport et al. 1988</a> may be useful.</p>
<p><b>Exercise 15.10 [s]</b> Give several reasons why constant polynomials, like 3, are represented as integers rather than as vectors.</p>
<h2>15.9 Ответы</h2>
<p><b>Answer 15.4</b></p>
<div class="fragment"><div class="line">(defun rat*rat (x y)</div><div class="line">  &quot;Multiply rationals: a/b * c/d = a*c/b*d&quot;</div><div class="line">  (poly/poly (poly*poly (rat-numerator x)</div><div class="line">                        (rat-numerator y))</div><div class="line">             (poly*poly (rat-denominator x)</div><div class="line">                        (rat-denominator y))))</div><div class="line"></div><div class="line">(defun rat+rat (x y)</div><div class="line">  &quot;Add rationals: a/b + c/d = (a*d + c*b)/b*d&quot;</div><div class="line">  ;; Bug fix by dst 4/6/92; b and c were switched</div><div class="line">  (let ((a (rat-numerator x))</div><div class="line">        (b (rat-denominator x))</div><div class="line">        (c (rat-numerator y))</div><div class="line">        (d (rat-denominator y)))</div><div class="line">    (poly/poly (poly+poly (poly*poly a d) (poly*poly c b))</div><div class="line">               (poly*poly b d))))</div><div class="line"></div><div class="line">(defun rat/rat (x y)</div><div class="line">  &quot;Divide rationals: a/b / c/d = a*d/b*c&quot;</div><div class="line">  (rat*rat x (make-rat (rat-denominator y) (rat-numerator y))))</div></div><!-- fragment --><p><b>Answer 15.6</b></p>
<div class="fragment"><div class="line">(defun poly/poly (p q)</div></div><!-- fragment --><p><code>"Divide p by q: if d is the greatest common divisor of p and q</code></p>
<p>`then p/q = (p/d) / (q/d). Note if q-1. then p/q = p."`</p>
<p><code>(if (eql q 1)</code> </p><pre class="fragment">`p`

`(let ((d (poly-gcd p q)))`

  `(make-rat (poly/poly p d)`

          `(poly/poly q d)))))`
</pre><p><b>Answer 15.10</b> (1) An integer takes less time and space to process. (2) Representing numbers as a polynomial would cause an infinit<code>e</code> regress, because the coefficients would be numbers. (3) Unless a policy was decided upon, the representation would not be canonical, since <code>#(x 3)</code> and <code>#(y 3)</code> both represent 3. </p><hr/>
<p><a href="#xfn0015">1</a> In fact, the algebraic properties of polynomial arithmetic and its generalizations fit so well with ideas in data abstraction that an extended example (in Scheme) on this topic is provided in <em>Structure and Interpretation of Computer Programs</em> by Abelson and Sussman (see section 2.4.3, <a href="B9780080571157500054.xhtml#p153">pages 153</a>-<a href="B9780080571157500054.xhtml#p166">166</a>). We'll pursue a slightly different approach here. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">2</a> Note: systems that use <code>"&lt;/tt&gt;cdr-coding&lt;tt&gt;"</code> take about the same space for lists that are allocated all at once as for vectors. But cdr-coding is losing favor as RISC chips replace microcoded processors. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
