<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 22</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 22 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Scheme: Необычный Лисп</h2>
<blockquote class="doxtable">
<p>Лучшие продуманные схемы мышей и людей </p>
</blockquote>
<blockquote class="doxtable">
<p>-Robert Burns (1759-1796) </p>
</blockquote>
<p>В этой главе представлен диалект Лиспа - Scheme и его интерпретатор. Хотя маловероятно, что вы будете использовать этот интерпретатор для серьезного программирования, понимание того, как работает интерпретатор, может дать вам лучшее представление о том, как работает Lisp, и, таким образом, сделать вас лучшим программистом. Интерпретатор Scheme используется вместо Common Lisp, потому что Scheme проще, а также потому, что Scheme - важный язык, о котором стоит знать.</p>
<p>Scheme - единственный диалект Lisp, помимо Common Lisp, который в настоящее время процветает. В то время как Common Lisp пытается стандартизировать все важные функции, которые в настоящее время используются программистами Lisp, Scheme пытается предоставить минимальный набор очень мощных функций, которые можно использовать для реализации других. Интересно, что среди всех языков программирования в мире Scheme - один из самых маленьких, а Common Lisp - один из самых больших. Руководство по Scheme занимает всего 45 страниц (только 38, если вы опустите пример, библиографию и указатель), а <em>Common Lisp the Language</em>, 2-е издание, составляет 1029 страниц. Вот неполный список способов, которые делают Scheme проще, чем Common Lisp:</p>
<ol type="1">
<li>Scheme имеет меньше встроенных функций и специальных форм. !!!(p) {:.numlist}</li>
<li>В Scheme нет специальных переменных, только лексические переменные. !!!(p) {:.numlist}</li>
<li>Scheme использует одно и то же пространство имен для функций и переменных (и всего остального). !!!(p) {:.numlist}</li>
<li>Scheme вычисляет(оценивает) функциональную часть вызова функции точно так же, как аргументы. !!!(p) {:.numlist}</li>
<li>Функции Scheme не могут иметь дополнительных(опциональных) параметров и параметров ключевых слов. Однако они могут иметь эквивалент параметра <code>&amp;rest</code>. !!!(p) {:.numlist}</li>
<li>В Scheme нет <code>block, return, go, orthrow</code>; есть одна функция <code>(call / cc)</code>, которая заменяет их все (и делает гораздо больше). !!!(p) {:.numlist}</li>
<li>В Scheme нет пакетов. Лексические переменные могут использоваться для реализации структур, подобных пакетам. !!!(p) {:.numlist}</li>
<li>Scheme, как стандарт, не имеет макросов, хотя большинство реализаций предоставляют макросы в качестве расширения. !!!(p) {:.numlist}</li>
<li>Scheme не имеет специальных форм для зацикливания; вместо этого он просит пользователя использовать рекурсию и обещает эффективно реализовать рекурсию. !!!(p) {:.numlist}</li>
</ol>
<p>Пять основных специальных форм в Scheme - это <code>quote</code> и <code>if</code>, которые такие же, как в Common Lisp; <code>begin</code> и <code>set!</code>, которые просто разные варианты написания <code>progn</code> и <code>setq</code>; и <code>lambda</code>, что и в Common Lisp, за исключением того, что перед ним не требуется #. Кроме того, Scheme позволяет использовать переменные, константы (числа, строки и символы) и вызовы функций. Вызов функции отличается, потому что сама функция вычисляется(оценивается) так же, как и аргументы. В Common Lisp (<code>f x</code>) означает поиск привязки функции <code>f</code> и применение ее к значению <code>x</code>. На Scheme <code>(f x)</code> означает вычисление <code>f</code> (в данном случае путем поиска значения переменной <code>f</code>), вычисление <code>x</code> (путем поиска значения переменной точно таким же образом), а затем применение функцию к аргументу. В позиции функции может быть любое выражение, и оно вычисляется так же, как аргументы. Другое отличие состоит в том, что Scheme использует <code># t</code> и <code>#f</code> для значений true и false вместо <code>t</code> и <code>nil</code>. Пустой список обозначается <code>()</code>, и он отличается от ложного значения #f. Есть также незначительные лексические различия в соглашениях для комплексных чисел и чисел в разных основаниях, но их можно игнорировать для всех программ в этой книге. Кроме того, в схеме один макрос, <code>define</code>, служит для определения как переменных, так и функций.</p>
<table class="doxtable">
<tr>
<th>Scheme </th><th>Common Lisp  </th></tr>
<tr>
<td><em>var</em> </td><td><em>var</em> </td></tr>
<tr>
<td><em>constant</em> </td><td><em>constant</em> </td></tr>
<tr>
<td>(<code>quote</code>*x*) or '<em>x</em> </td><td>(<code>quote</code>*x*) or '<em>x</em> </td></tr>
<tr>
<td>(<code>begin</code>*x*...) </td><td>(<code>progn</code>*x*...) </td></tr>
<tr>
<td>(<code>set!</code>*var x*) </td><td>(<code>setq</code>*var x*) </td></tr>
<tr>
<td>(<code>if</code>*pab*) </td><td>(<code>if</code>*pab*) </td></tr>
<tr>
<td>(<code>lambda</code>*parms x*...) </td><td><code>#'</code> (<code>lambda</code>*parms x*...) </td></tr>
<tr>
<td>(<em>fn arg</em>...) </td><td>(<em>fn arg</em>...) or (<code>funcall</code>*fn arg*...) </td></tr>
<tr>
<td><code>#t</code> </td><td><code>t</code> </td></tr>
<tr>
<td><code>#f</code> </td><td><code>nil</code> </td></tr>
<tr>
<td><code>( )</code> </td><td><code>nil</code> </td></tr>
<tr>
<td>(<code>define</code>*varexp*) </td><td>(<code>defparameter</code>*var exp*) </td></tr>
<tr>
<td>(<code>define</code> (<em>fnparm</em>...) <em>body</em>) </td><td>(<code>defun</code>*fn* (<em>parm</em>...) <em>body</em>) </td></tr>
</table>
<p><b>Exercise 22</b>.**1** [<b>s</b>] Что вычислит следующее выражение на Scheme? Сколько ошибок оно имеет в качестве выражения Common Lisp?</p>
<div class="fragment"><div class="line">((if (= (+  2 2) 4)</div><div class="line">      (lambda (x y) (+ (* x y) 12))</div><div class="line">      cons)</div><div class="line">  5</div><div class="line">  6)</div></div><!-- fragment --><p>Множество функций, таких как <code>car</code>, <code>cdr</code>, <code>cons</code>, <code>append</code>, +, <code>*</code> и <code>list</code>, одинаковы (или почти одинаковы) в обоих диалектах. Однако в Scheme есть некоторые правила написания, которые отличаются от Common Lisp. Большинство мутаторов(деструктивных функций) Scheme, таких как <code>set!</code>, оканчиваются на '<code>!</code>'. В Common Lisp нет общепринятого соглашения для этого; некоторые мутаторы начинаются с <code>n</code> (<code>nreverse, nsubst, nintersection</code>), в то время как другие имеют своеобразные имена (<code>delete versus remove</code>). Scheme будет использовать согласованные имена - <code>reverse</code>! и <code>remove</code>! - если эти функции были вообще определены(в стандарте они не определены). Большинство предикатов Scheme оканчиваются на '<code>?</code>', а не на '<code>p</code>'. Это делает предикаты более очевидными и устраняет сложные соглашения о добавлении дефиса перед <code>p</code>. <a href="#fn0010">1</a> Единственная проблема с этим соглашением заключается в разговорной речи: <code>equal?</code> Произносится как "равно-знак-вопроса" или "равный-q" или, возможно равно, с возрастающей интонацией? Это сделало бы Scheme языком тонов, как китайский.</p>
<p>В Scheme применение <code>car</code> или <code>cdr</code> к пустому списку является ошибкой. Несмотря на то, что Scheme имеет <code>cons</code>, результат называется <code>pair</code>(<code>парой</code>), а не cons-ячейкой, поэтому предикатом будет <code>pair?</code>, а не <code>consp</code>.</p>
<p>Scheme распознает, что не все лямбда-выражения будут "функциями" в соответствии с математическим определением функции, и поэтому вместо этого использует термин "процедура". Вот неполный список соответствий между двумя диалектами:</p>
<table class="doxtable">
<tr>
<th>Scheme Procedure </th><th>Common Lisp Function  </th></tr>
<tr>
<td><code>char-ready?</code> </td><td><code>listen</code> </td></tr>
<tr>
<td><code>char?</code> </td><td><code>characterp</code> </td></tr>
<tr>
<td><code>eq?</code> </td><td><code>eq</code> </td></tr>
<tr>
<td><code>equal?</code> </td><td><code>equal</code> </td></tr>
<tr>
<td><code>eqv?</code> </td><td><code>eql</code> </td></tr>
<tr>
<td><code>even?</code> </td><td><code>evenp</code> </td></tr>
<tr>
<td><code>for-each</code> </td><td><code>mapc</code> </td></tr>
<tr>
<td><code>integer?</code> </td><td><code>integerp</code> </td></tr>
<tr>
<td><code>list-&gt;string</code> </td><td><code>coerce</code> </td></tr>
<tr>
<td><code>list-&gt;vector</code> </td><td><code>coerce</code> </td></tr>
<tr>
<td><code>list-ref</code> </td><td><code>nth</code> </td></tr>
<tr>
<td><code>list-tail</code> </td><td><code>nthcdr</code> </td></tr>
<tr>
<td><code>map</code> </td><td><code>mapcar</code> </td></tr>
<tr>
<td><code>negative?</code> </td><td><code>minusp</code> </td></tr>
<tr>
<td><code>pair?</code> </td><td><code>consp</code> </td></tr>
<tr>
<td><code>procedure?</code> </td><td><code>functionp</code> </td></tr>
<tr>
<td><code>set!</code> </td><td><code>setq</code> </td></tr>
<tr>
<td><code>set-car!</code> </td><td><code>replaca</code> </td></tr>
<tr>
<td><code>vector-set!</code> </td><td><code>setf</code> </td></tr>
<tr>
<td><code>string-set!</code> </td><td><code>setf</code> </td></tr>
</table>
<h2>22.1 Интерпретатор Scheme</h2>
<p>Как мы видели, интерпретатор принимает программу(или выражение) в качестве входных данных и возвращает значение, вычисленное этой программой. Таким образом, Lisp функция <code>eval</code> является интерпретатором, и это, по сути, функция которую мы пытаемся написать в этом разделе. Однако мы должны быть осторожны, так как можно спутать понятия интерпретатора и компилятора. Компилятор принимает программу в качестве входных данных и производит в качестве выходных данных перевод этой программы на какой-либо другой язык - обычно это язык, который можно напрямую(или с большей легкостью) выполнить на некоторой машине. Таким образом, также можно написать <code>eval</code>, скомпилировав аргумент и затем интерпретировать полученную программу на машинном уровне. Большинство современных систем Lisp поддерживают обе возможности, хотя некоторые некоторые только интерпретируют код на прямую, а другие компилируют весь код перед его выполнением. Чтобы прояснить различие, мы не будем писать функцию с именем <code>eval</code>. Вместо этого, мы напишем версии двух функций: <code>interp</code>, интерпретатор Scheme, и в следующей главе, <code>comp</code>, компилятор Scheme.</p>
<p>Интерпретор обрабатывающий примитивы Scheme, легко написать. В интерпретаторе <code>interp</code>, главное условие имеет восемь случаев, соответствующих пяти специальным формам, символам, другим атомам и применению процедур (также известным как вызовы функций). На данный момент мы будем придерживаться <code>t</code> и <code>nil</code> вместо <code>#t</code> и <code>#f</code>. После разработки простого интерпретатора мы добавим поддержку макросов, затем разработаем интерпретатор с хвостовой рекурсией и, наконец, интерпретатор с передачей продолжения(continuation-passing). (Эти термины будут определены, когда придет время.). Глоссарий(словарь) для <code>interp</code> приведен на <a href="#f0010">рисунке 22.1</a>.</p>
<table class="doxtable">
<tr>
<th></th><th><b>Функции верхнего уровня</b>  </th></tr>
<tr>
<td><code>scheme</code> </td><td>Scheme цикл чтения-интерпретации-печати/REPL(read-interp-print) </td></tr>
<tr>
<td><code>interp</code> </td><td>Интерпретирует/вычисляет (оценивает) выражение в сред окружения. </td></tr>
<tr>
<td><code>def-scheme-macro</code> </td><td>Определяет макрос Scheme. </td></tr>
<tr>
<td></td><td><b>Специальные переменные</b> </td></tr>
<tr>
<td><code>*scheme-procs*</code> </td><td>Некоторые процедуры сохраняемые в глобальной среде окружения. </td></tr>
<tr>
<td></td><td><b>Вспомогательные функции</b> </td></tr>
<tr>
<td><code>set-var!</code> </td><td>Установить значение для переменной </td></tr>
<tr>
<td><code>get-var</code> </td><td>Получить значение для переменной в окружающей среде. </td></tr>
<tr>
<td><code>set-global-var!</code> </td><td>Установить значение для глобальной переменной. </td></tr>
<tr>
<td><code>get-global-var</code> </td><td>Получить значение переменной из глобальной окружающей среды. </td></tr>
<tr>
<td><code>extend-env</code> </td><td>Добавить в окружающую среду несколько переменных и значений. </td></tr>
<tr>
<td><code>init-scheme-iterp</code> </td><td>Инициализирует некоторые глобальные переменные. </td></tr>
<tr>
<td><code>init-scheme-proc</code> </td><td>Определяет простую(примитивную) процедуру Scheme. </td></tr>
<tr>
<td><code>scheme-macro</code> </td><td>Получает макрос Scheme для символа. </td></tr>
<tr>
<td><code>scheme-macro-expand</code> </td><td>Макрорасширение выражения Scheme. </td></tr>
<tr>
<td><code>maybe-add</code> </td><td>Добаить элемент в начало не одноэлементного списка. </td></tr>
<tr>
<td><code>print-proc</code> </td><td>Распечатать процедуру. </td></tr>
<tr>
<td></td><td><b>Типы Данных (только для версии с хвостовой рекурсией)</b> </td></tr>
<tr>
<td><code>proc</code> </td><td>Процедура Scheme. </td></tr>
<tr>
<td></td><td><b>Функции (только в версии с продолжениями)</b> </td></tr>
<tr>
<td><code>interp-begin</code> </td><td>Интерпретирует выражение <code>begin</code>. </td></tr>
<tr>
<td><code>interp-call</code> </td><td>Интерпретирует применение функции. </td></tr>
<tr>
<td><code>map-interp</code> </td><td>Сопоставляет <code>interp</code> со списком. </td></tr>
<tr>
<td><code>call/cc</code> </td><td>вызызов с текущим продолжением. </td></tr>
<tr>
<td></td><td><b>Ранее определенные функции</b> </td></tr>
<tr>
<td><code>lastl</code> </td><td>Выбирает последний элемент из списка. </td></tr>
<tr>
<td><code>length=1</code> </td><td>Проверяет что список имеет длину 1? </td></tr>
</table>
<p>| Таблица 22.1: Словарь для интерпретатора Scheme |</p>
<p>У простого интерпретатора есть восем случаев, о которых нужно беспокоиться: (1) Если выражение является символом, найдите его значение в окружающей среде. (2) Если это атом, который не является символом(такой как число), просто верните его. В противном случае выражение должно быть списком. (3) Если оно начинается с <code>quote</code>, вернуть выражение в кавычках. (4) Если оно начинается с <code>begin</code>, интерпретировать каждое подвыражение, и вернуть значение последнего. (5) Если оно начинается с <code>set!</code>, интерпретируйте значение, а затем установите для переменной это значение. (6) Если оно начинается с <code>if</code>, интерпретируйте условное выражение, и в зависимости от того истинно оно или нет интерпретируйте then-часть или else-часть. (7) Если оно начинается с <code>lambda</code>, создайте новую процедуру - замыкание для текущей окружающей среды. (8) В противном случае, это должно быть применение процедуры. Интерпретируйте процедуру и все аргументы и примените значение процедуры к значениям аргументов.</p>
<div class="fragment"><div class="line">(defun interp (x &amp;optional env)</div><div class="line">  &quot;Interpret (evaluate) the expression x in the environment env.&quot;</div><div class="line">  (cond</div><div class="line">    ((symbolp x) (get-var x env))</div><div class="line">    ((atom x) x)</div><div class="line">    ((case (first x)</div><div class="line">       (QUOTE  (second x))</div><div class="line">       (BEGIN  (last1 (mapcar #&#39;(lambda (y) (interp y env))</div><div class="line">                              (rest x))))</div><div class="line">       (SET!   (set-var! (second x) (interp (third x) env) env))</div><div class="line">       (IF     (if (interp (second x) env)</div><div class="line">                   (interp (third x) env)</div><div class="line">                   (interp (fourth x) env)))</div><div class="line">       (LAMBDA (let ((parms (second x))</div><div class="line">                     (code (maybe-add &#39;begin (rest2 x))))</div><div class="line">                 #&#39;(lambda (&amp;rest args)</div><div class="line">                     (interp code (extend-env parms args env)))))</div><div class="line">       (t      ;; a procedure application</div><div class="line">               (apply (interp (first x) env)</div><div class="line">                      (mapcar #&#39;(lambda (v) (interp v env))</div><div class="line">                              (rest x))))))))</div></div><!-- fragment --><p>Окружающая среда(environment/окружение/среда/среда окружения) представлена в виде ассоциативного списка парами переменная/значение(variable/value), за исключением глобальной окружающей среды, которая представлена значениями в свойстве <code>global-val</code> для символов. Было бы проще представить глобальное окружение так же, как локальную среду, но более эффективно использовать списки свойств, чем большой глобальный ассоциативный список(a-list). Более того, глобальная среда отличается тем, что каждый символ определяется неявно в глобальном оружении, в то время как локальная окружающая среда содержит только переменные, которые явно упомянуты (в <code>lambda</code> выражении).</p>
<p>В качестве примера предположим, что мы интерпретируем вызов функции <code>(f 1 2 3)</code>, и что функция <code>f</code> была определена следующим выражением Scheme:</p>
<p><code>(set! f (lambda (a b c) (+ a (g b c))))</code></p>
<p>Затем мы интерпретируем <code>( f 1 2 3 )</code> интерпретируя тело <code>f</code> с окружающей средой:</p>
<div class="fragment"><div class="line">((a 1) (b 2) (c 3))</div></div><!-- fragment --><p>Процедуры Scheme реализованы как функции Common Lisp, и фактически все типы данных Scheme реализованы соответствующими типами Common Lisp. Я включил функцию <code>init-scheme-interp</code> для инициализации нескольких глобальных значений и повторяю определения <code>last1</code> и <code>length=1</code>:</p>
<div class="fragment"><div class="line">(defun set-var! (var val env)</div><div class="line">  &quot;Set a variable to a value, in the given or global environment.&quot;</div><div class="line">  (if (assoc var env)</div><div class="line">      (setf (second (assoc var env)) val)</div><div class="line">      (set-global-var! var val))</div><div class="line">  val)</div><div class="line"></div><div class="line">(defun get-var (var env)</div><div class="line">  &quot;Get the value of a variable, from the given or global environment.&quot;</div><div class="line">    (if (assoc var env)</div><div class="line">        (second (assoc var env))</div><div class="line">        (get-global-var var)))</div><div class="line"></div><div class="line">(defun set-global-var! (var val)</div><div class="line">  (setf (get var &#39;global-val) val))</div><div class="line"></div><div class="line">(defun get-global-var (var)</div><div class="line">  (let* ((default &quot;unbound&quot;)</div><div class="line">         (val (get var &#39;global-val default)))</div><div class="line">    (if (eq val default)</div><div class="line">        (error &quot;Unbound scheme variable: ~a&quot; var)</div><div class="line">        val)))</div><div class="line"></div><div class="line">(defun extend-env (vars vals env)</div><div class="line">  &quot;Add some variables and values to an environment.&quot;</div><div class="line">  (nconc (mapcar #&#39;list vars vals) env))</div><div class="line"></div><div class="line">(defparameter *scheme-procs*</div><div class="line">  &#39;(+ - * / = &lt; &gt; &lt;= &gt;= cons car cdr not append list read member</div><div class="line">    (null? null) (eq? eq) (equal? equal) (eqv? eql)</div><div class="line">    (write prin1) (display princ) (newline terpri)))</div><div class="line"></div><div class="line">(defun init-scheme-interp ()</div><div class="line">  &quot;Initialize the scheme interpreter with some global variables.&quot;</div><div class="line">  ;; Define Scheme procedures as CL functions:</div><div class="line">  (mapc #&#39;init-scheme-proc *scheme-procs*)</div><div class="line">  ;; Define the boolean `constants&#39;. Unfortunately, this won&#39;t</div><div class="line">  ;; stop someone from saying: (set! t nil)</div><div class="line">  (set-global-var! t t)</div><div class="line">  (set-global-var! nil nil))</div><div class="line"></div><div class="line">(defun init-scheme-proc (f)</div><div class="line">  &quot;Define a Scheme procedure as a corresponding CL function.&quot;</div><div class="line">  (if (listp f)</div><div class="line">      (set-global-var! (first f) (symbol-function (second f)))</div><div class="line">      (set-global-var! f (symbol-function f))))</div></div><!-- fragment --><div class="fragment"><div class="line">(defun maybe-add (op exps &amp;optional if-nil)</div><div class="line">  &quot;For example, (maybe-add &#39;and exps t) returns</div><div class="line">  t if exps is nil, exps if there is only one,</div><div class="line">  and (and exp1 exp2...) if there are several exps.&quot;</div><div class="line">  (cond ((null exps) if-nil)</div><div class="line">              ((length=1 exps) (first exps))</div><div class="line">              (t (cons op exps))))</div><div class="line">(defun length=1 (x)</div><div class="line">  &quot;Is x a list of length 1?&quot;</div><div class="line">  (and (consp x) (null (cdr x))))</div><div class="line">(defun lastl (list)</div><div class="line">  &quot;Return the last element (not last cons cell) of list&quot;</div><div class="line">  (first (last list)))</div></div><!-- fragment --><p>Чтобы протестировать интерпретатор, мы добавляем простой цикл чтения-выполнения-печати(REPL- read-eval-print loop):</p>
<div class="fragment"><div class="line">(defun scheme ()</div><div class="line">  &quot;A Scheme read-eval-print loop (using interp)&quot;</div><div class="line">  (init-scheme-interp)</div><div class="line">  (loop (format t &quot;~&amp;==&gt; &quot;)</div><div class="line">        (print (interp (read) nil))))</div></div><!-- fragment --><p>А теперь мы готовы опробовать интерпретатор. Обратите внимание, что приглашение Common Lisp это "&gt;," а приглашение Scheme это "==&gt;."</p>
<div class="fragment"><div class="line">&gt; (scheme)</div><div class="line">==&gt; (+  2 2)</div><div class="line">4</div><div class="line">==&gt; ((if (=  1 2) * +) 3 4)</div><div class="line">7</div><div class="line">==&gt; ((if (=  1 1) * +) 3 4)</div><div class="line">12</div></div><!-- fragment --><p><code>==&gt; (set! fact (lambda (n)</code></p>
<div class="fragment"><div class="line">                (if (= n 0) 1</div><div class="line">                    (* n (fact (- n 1))))))</div><div class="line">#&lt;DTP-LEXICAL-CLOSURE 36722615  &gt;</div><div class="line">==&gt; (fact 5)</div><div class="line">120</div></div><!-- fragment --><p><code>==&gt; (set! table (lambda (f start end)</code></p>
<div class="fragment"><div class="line">                    (if (&lt;= start end)</div><div class="line">                        (begin</div><div class="line">                          (write (list start (f start)))</div><div class="line">                          (newline)</div><div class="line">                          (table f (+ start 1) end)))))</div><div class="line">#&lt;DTP-LEXICAL-CLOSURE 41072172  &gt;</div><div class="line">==&gt; (table fact 1 10)</div><div class="line">(1 1)</div><div class="line">(2 2)</div><div class="line">(3 6)</div><div class="line">(4 24)</div><div class="line">(5 120)</div><div class="line">(6 720)</div><div class="line">(7 5040)</div><div class="line">(8 40320)</div><div class="line">(9 362880)</div><div class="line">(10 3628800)</div><div class="line">NIL</div><div class="line">==&gt; (table (lambda (x) (* x x x)) 5 10)</div><div class="line">(5 125)</div><div class="line">(6 216)</div><div class="line">(7 343)</div><div class="line">(8 512)</div><div class="line">(9 729)</div><div class="line">(10 1000)</div><div class="line">NIL</div><div class="line">==&gt; [ABORT]</div></div><!-- fragment --><h2>22.2 Синтаксическое расширение с помощью Макросов</h2>
<p>Scheme имеет ряд специальных форм, не перечисленных выше. Фактически, Scheme использует термин "синтаксис" там, где мы используем "специальная форма." Остальной синтаксис можно определить как "производные выражения" в терминах пяти примитивов. Стандарт Scheme не признает концепцию макросов, но ясно, что "производное выражение" похоже на макрос, и мы будем реализовывать их с помощью макросов. Следующие формы используются (почти) одинаково в Scheme и Common Lisp:</p>
<div class="fragment"><div class="line">let let* and or do cond case</div></div><!-- fragment --><p>Одно отличие состоит в том, что Scheme менее снисходительно относится к тому, что считается связыванием в <code>let</code>, <code>let*</code> и <code>do</code>. Каждая привязка должна быть <code>(</code>*var init*<code>)</code>; просто <code>(</code>*var*<code>)</code> или <em>var</em> не допустимы. В do, привязка может быть либо (<em>var init step</em>), либо (<em>var init</em>). Обратите внимание, что <code>do*</code> отсутствует. Другое отличие заключается в <code>case</code> и <code>cond</code>. Где Common Lisp использует символ <code>t</code> или <code>otherwise</code> для обозначения последнего случая, Scheme использует <code>else</code>. Последние три синтаксических расширения уникальны для Scheme:</p>
<div class="fragment"><div class="line">(define *var val*)      *or*          (define (*proc*-*name arg*...) *body*...)</div><div class="line">(delay *expression*)</div><div class="line">(letrec ((*var init*)...) *body*...)</div></div><!-- fragment --><p><code>define</code> это комбинация <code>defun</code> и <code>defparameter</code>. В своей первой форме он присваивает значение переменной. Поскольку в Scheme нет специальных переменных, она ничем не отличается от <code>set!</code>. (Есть разница, когда определение вложено в другое определение, но это еще не рассматривается.) Во второй форме оно определяет функцию. <code>delay</code> используется для задержки вычислений, как описано в <a href="B9780080571157500091.xhtml#s0020">разделе 9.3</a>, стр. 281. <code>letrec</code> аналогичен <code>let</code>. Разница в том, что все формы <em>init</em> вычисляются в окружающей среде, которая включает все <em>vars</em>(переменные*). Таким образом, <code>letrec</code> можно использовать для определения локальных рекурсивных функций, как это делает <code>labels</code> в Common Lisp.</p>
<p>Первым шагом в реализации этих синтаксических расширений является изменение <code>interp</code>, позволяющее использовать макросы. Нужно добавить одно предложение, но мы повторим все определение:</p>
<div class="fragment"><div class="line">(defun interp (x &amp;optional env)</div><div class="line">  &quot;Interpret (evaluate) the expression x in the environment env.&quot;</div><div class="line">  (cond</div><div class="line">    ((symbolp x) (get-var x env))</div><div class="line">    ((atom x) x)</div><div class="line">    ((case (first x)</div><div class="line">       (QUOTE  (second x))</div><div class="line">       (BEGIN  (last1 (mapcar #&#39;(lambda (y) (interp y env))</div><div class="line">                              (rest x))))</div><div class="line">       (SET!   (set-var! (second x) (interp (third x) env) env))</div><div class="line">       (IF     (if (interp (second x) env)</div><div class="line">                   (interp (third x) env)</div><div class="line">                   (interp (fourth x) env)))</div><div class="line">       (LAMBDA (let ((parms (second x))</div><div class="line">                     (code (maybe-add &#39;begin (rest2 x))))</div><div class="line">                 #&#39;(lambda (&amp;rest args)</div><div class="line">                     (interp code (extend-env parms args env)))))</div><div class="line">       (t      ;; a procedure application</div><div class="line">               (apply (interp (first x) env)</div><div class="line">                      (mapcar #&#39;(lambda (v) (interp v env))</div><div class="line">                              (rest x))))))))</div></div><!-- fragment --><p>Теперь мы предоставим механизм для определения макросов. Определения макросов могут быть на любом языке; самый простой выбор - это сама Scheme или Common Lisp. Я выбрал второе. Это дает понять, что макросы не являются частью самой Scheme, а используются для реализации Scheme. Если бы мы хотели пердложить программисту Scheme возможность/функциональность создания мароса, мы бы сделали другой выбор. (Но тогда мы обязательно добавим обозначение/запись обратных кавычек, которая очень полезна при написании макросов.) <code>def-scheme-macro</code> (который сам по себе является макросом) предоставляет способ добавления новых макросов Scheme. Он делает это, сохраняя функцию Common Lisp в свойстве символа <code>scheme-macro</code>. Эта функция, получив список аргументов, возвращает код, в который должен быть расширен вызов макроса. Функция <code>scheme-macro</code> проверяет, имеет ли символ прикрепленный к нему макрос, а <code>scheme-macro-expand</code> выполняет фактическое расширение макроса:</p>
<div class="fragment"><div class="line">(defun scheme-macro (symbol)</div><div class="line">  (and (symbolp symbol) (get symbol &#39;scheme-macro)))</div><div class="line">(defmacro def-scheme-macro (name parmiist &amp;body body)</div><div class="line">  &quot;Define a Scheme macro.&quot;</div><div class="line">  &#39;(setf (get &#39;,name &#39;scheme-macro)</div><div class="line">        #&#39;(lambda .parmlist ..body)))</div><div class="line">(defun scheme-macro-expand (x)</div><div class="line">  &quot;Macro-expand this Scheme expression.&quot;</div><div class="line">  (if (and (listp x) (scheme-macro (first x)))</div><div class="line">              (scheme-macro-expand</div><div class="line">                (apply (scheme-macro (first x)) (rest x)))</div><div class="line">              x))</div></div><!-- fragment --><p>Вот определение девяти важных в Scheme макросов:</p>
<div class="fragment"><div class="line">(def-scheme-macro let (bindings &amp;rest body)</div><div class="line">  &#39;((lambda .(mapcar #&#39;first bindings) . ,body)</div><div class="line">    .,(mapcar #&#39;second bindings)))</div><div class="line">(def-scheme-macro let* (bindings &amp;rest body)</div><div class="line">  (if (null bindings)</div><div class="line">              &#39;(begin .,body)</div><div class="line">              &#39;(let (,(first bindings))</div><div class="line">          (let* ,(rest bindings) . ,body))))</div><div class="line">(def-scheme-macro and (&amp;rest args)</div><div class="line">  (cond ((null args) &#39;T)</div><div class="line">          ((length=1 args) (first args))</div><div class="line">          (t &#39;(if ,(first args)</div><div class="line">                    (and . ,(rest args))))))</div><div class="line">(def-scheme-macro or (&amp;rest args)</div><div class="line">  (cond ((null args) &#39;nil)</div><div class="line">        ((length=1 args) (first args))</div><div class="line">        (t (let ((var (gensym)))</div><div class="line">                &#39;(let ((,var ,(first args)))</div><div class="line">                  (if ,var ,var (or . ,(rest args))))))))</div><div class="line">(def-scheme-macro cond (&amp;rest clauses)</div><div class="line">  (cond ((null clauses) nil)</div><div class="line">          ((length=1 (first clauses))</div><div class="line">            &#39;(or ,(first clauses) (cond .,(rest clauses))))</div><div class="line">          ((starts-with (first clauses) &#39;else)</div><div class="line">            &#39;(begin .,(rest (first clauses))))</div><div class="line">          (t &#39;(if ,(first (first clauses))</div><div class="line">                    (begin .,(rest (first clauses)))</div><div class="line">                    (cond .,(rest clauses))))))</div><div class="line">(def-scheme-macro case (key &amp;rest clauses)</div><div class="line">  (let ((key-val (gensym &quot;KEY&quot;)))</div><div class="line">    &#39;(let ((,key-val ,key))</div><div class="line">      (cond ,@(mapcar</div><div class="line">                #&#39;(lambda (clause)</div><div class="line">                    (if (starts-with clause &#39;else)</div><div class="line">                        clause</div><div class="line">                        &#39;((member ,key-val &#39;,(first clause))</div><div class="line">                                .,(rest clause))))</div><div class="line">                clauses)))))</div><div class="line">(def-scheme-macro define (name &amp;rest body)</div><div class="line">  (if (atom name)</div></div><!-- fragment --><p>` '(begin (set! ,name . ,body) ',name)`</p>
<div class="fragment"><div class="line">              &#39;(define ,(first name)</div><div class="line">          (lambda ,(rest name) . ,body))))</div><div class="line">(def-scheme-macro delay (computation)</div><div class="line">  &#39;(lambda () ,computation))</div><div class="line">(def-scheme-macro letrec (bindings &amp;rest body)</div><div class="line">  &#39;(let ,(mapcar #&#39;(lambda (v) (list (first v) nil)) bindings)</div></div><!-- fragment --><p>` ,@(mapcar #'(lambda (v) '(set! . ,v)) bindings)`</p>
<div class="fragment"><div class="line">.,body))</div></div><!-- fragment --><p>Мы можем протестировать возможность использовать макросов:</p>
<div class="fragment"><div class="line">&gt; (scheme-macro-expand &#39;(and p q)) =&gt; (IF P (AND Q))</div><div class="line">&gt; (scheme-macro-expand &#39;(and q)) Q</div></div><!-- fragment --><p>`&gt; (scheme-macro-expand '(let ((x 1) (y 2)) (+ x y)))`=&gt;</p>
<div class="fragment"><div class="line">((LAMBDA (X Y) (+ X Y)) 1 2)</div><div class="line">&gt; (scheme-macro-expand</div><div class="line">    &#39;(letrec</div></div><!-- fragment --><p>` ((even? (lambda (x) (or (= x 0) (odd? (- x 1)))))`</p>
<p>` (odd? (lambda (x) (even? (- x 1)))))`</p>
<p><code>(even? z)))</code>=&gt;</p>
<p><code>(LET ((EVEN? NIL)</code></p>
<p><code>(ODD? NIL))</code></p>
<p>` (SET! EVEN? (LAMBDA (X) (OR (= X 0) (ODD? (- X 1)))))`</p>
<p>` (SET! ODD? (LAMBDA (X) (EVEN? (- X 1))))`</p>
<p><code>(EVEN? Z))</code></p>
<div class="fragment"><div class="line">&gt; (scheme)</div><div class="line">==&gt; (define (reverse 1)</div></div><!-- fragment --><p><code>(if (null? 1) nil</code></p>
<div class="fragment"><div class="line">            (append (reverse (cdr 1)) (list (car 1)))))</div><div class="line">REVERSE</div><div class="line">==&gt; (reverse &#39;(a b c d))</div><div class="line">(D C B A)</div><div class="line">==&gt; (let* ((x 5) (y (+ x x)))</div><div class="line">      (if (or (= x 0) (and (&lt;  0 y) (&lt; y 20)))</div><div class="line">            (list x y)</div><div class="line">            (+ y x)))</div><div class="line">(5 10)</div></div><!-- fragment --><p>Макрос <code>define</code> похож на <code>set!</code>, за исключением того, что он возвращает символ, а не значение, присвоенное символу. Кроме того, <code>define</code> предоставляет необязательный синтаксис для определения функций - он служит целям как <code>defun</code>, так и <code>defvar</code>. Синтаксис (<code>define</code> (<em>fn</em> . <em>args</em>) .*body*) является сокращением (<code>define</code>*fn* (<code>lambda</code>*args* . <em>body</em>)).</p>
<p>Кроме того, Scheme предоставляет нотацию, в которой <code>define</code> можно использовать внутри определения функции таким образом, чтобы оно работало как <code>let</code>, а не как <code>set!.</code></p>
<p>Преимущетсво подхода базирующегося на макросах к специальным формам состоит в том, что нам не нужно изменять интерпретатор для добавления новых специальных форм. Интерпретатор остается простым, даже когда язык растет. Это также относится к компилятору, как мы увидим в следующем разделе.</p>
<h2>22.3 Правильный Интерпретатор Хвостовой Рекурсии</h2>
<p>К сожалению, представленный выше интерпретатор не может претендовать на гордое имя Scheme, потому что настоящая Scheme должна правильно обрабатывать хвостовую рекурсию. Наш интерпретатор обрабатывает хвостовую рекурсию только при запуске в Common Lisp, который сам является обрабатывающим хвостовую рекурсию. Чтобы увидеть проблему, рассмотрим следующую процедуру Scheme:</p>
<div class="fragment"><div class="line">(define (traverse lyst)</div><div class="line">  (if lyst (traverse (cdr lyst))))</div></div><!-- fragment --><p>Трассируйте функцию <code>interp</code> и выполните `(interp '(traverse '(a b c d)))<code>. Вложенные вызовы функции</code>interp` проходят на 16 уровней в глубину. Как правило, уровень вложенности в 4 плюс 3 раза больше длины списка. Каждый вызов <code>interp</code> требует Common Lisp выделил часть памяти в стеке, поэтому для очень длинных списков у нас в конечном итоге закончится память. Чтобы получить звание Scheme, язык должен гарантировать, что у такой программы не закончится память.</p>
<p>Проблема в этом примере заключается в двух местах. Каждый раз, когда мы интерпретируем форму <code>if</code> или вызов процедуры, мы спускаемся с другого рекурсивного уровня в <code>interp</code>. Но этот дополнительный уровень не нужен. Рассмотрим форму <code>if</code>. Разумеется, необходимо рекурсивно вызвать <code>interp</code> , чтобы решить верен ли тест или нет. Ради аргумента, предположим, что тест верен. Затем мы снова вызываем <code>interp</code> для части <em>then</em>. Этот рекурсивный вызов вернет значение, которое затем будет немедленно возвращено как значение исходного вызова.</p>
<p>Альтернативой является замена рекурсивного вызова <code>interp</code> на переименование переменных с последующим выполнением оператора <code>goto</code>. То есть, вместо вызова <code>interp</code> и, таким образом, привязки нового экземпляра переменной <code>x</code> к части <em>then</em>, мы просто присваиваем часть <em>then</em> переменной <code>x</code>, и переходим к началу подпрограммы <code>interp</code>. Это работает, потому что мы знаем, что нам больше не нужно использовать старое значение <code>x</code>. Аналогичный прием используется для устранения рекурсивного вызова для последнего выражения в форме <code>begin</code>. (Многие программисты были обучены "структурным программированием", что операторы <code>goto</code> вредны. В этом случае <code>goto</code> необходим для эффективной реализации низкоуровневой функции.)</p>
<p>Последнее, что нам нужно сделать, это явно управлять процедурами Scheme. Вместо реализации процедур Scheme как замыканий Common Lisp мы определим структуру, <code>proc</code>, которая будет содержать код, окружающую среду, список параметров и, возможно, имя процедуры. Затем, когда мы вычисляем вызов процедуры, мы можем присвоить тело процедуры <code>x</code>, а не рекурсивно вызывать <code>interp</code>.</p>
<div class="fragment"><div class="line">(defstruct (proc (:print-function print-proc))</div><div class="line">  &quot;Represent a Scheme procedure&quot;</div><div class="line">  code (env nil)(name nil) (parms nil))</div></div><!-- fragment --><p>Ниже приведен интерпретатор с правильной хвостовой рекурсией. Макрос <code>prog</code> устанавливает <code>tagbody</code>, внутри которого мы можем использовать операторы <code>go</code> для перехода к меткам, а также он устанавливает <code>block</code>, из которого мы можем возвращать значение. Он также может связывать переменные, подобно <code>let</code>, хотя в этом случае список переменных пуст. Любой символ в теле <code>prog</code> считается меткой. В этом случае метка :<code>INTERP</code> является целью операторов ветвления <code>(GO: INTERP)</code>. Я использую прописные буквы, чтобы указать, что используются операторы перехода, но это соглашение не получило широкого распространения.</p>
<div class="fragment"><div class="line">(defun interp (x &amp;optional env)</div><div class="line">  &quot;Evaluate the expression x in the environment env.</div><div class="line">  This version is properly tail-recursive.&quot;</div><div class="line">  (prog ()</div><div class="line">    :INTERP</div><div class="line">    (return</div><div class="line">      (cond</div><div class="line">        ((symbolp x) (get-var x env))</div><div class="line">        ((atom x) x)</div><div class="line">        ((scheme-macro (first x))</div><div class="line">          (setf x (scheme-macro-expand x)) (go :INTERP))</div><div class="line">        ((case (first x)</div><div class="line">            (QUOTE (second x))</div><div class="line">            (BEGIN (pop x) ; pop off the BEGIN to get at the args</div><div class="line">                      ;; Now interpret all but the last expression</div><div class="line">                      (loop while (rest x) do (interp (pop x) env))</div><div class="line">                      ;; Finally, rename the last expression as x</div><div class="line">                      (setf x (first x))</div><div class="line">                      (GO :INTERP))</div></div><!-- fragment --><p><code>(SET! (set-var! (second x) (interp (third x) env) env))</code></p>
<div class="fragment"><div class="line">            (IF              (setf x (if (interp (second x) env)</div><div class="line">                                (third x)</div><div class="line">                                (fourth x)))</div><div class="line">                      ;; That is, rename the right expression as x</div><div class="line">                      (GO :INTERP))</div><div class="line">            (LAMBDA (make-proc :env env :parms (second x)</div><div class="line">                                :code (maybe-add &#39;begin (rest2 x))))</div><div class="line">            (t      ;; a procedure application</div><div class="line">                    (let ((proc (interp (first x) env))</div><div class="line">                          (args (mapcar #&#39;(lambda (v) (interp v env))</div><div class="line">                                                      (rest x))))</div><div class="line">                      (if (proc-p proc)</div><div class="line">                            ;; Execute procedure with rename+goto</div><div class="line">                            (progn</div><div class="line">                              (setf x (proc-code proc))</div><div class="line">                              (setf env (extend-env (proc-parms proc) args</div><div class="line">                                                                          (proc-env proc)))</div><div class="line">                              (GO :INTERP))</div><div class="line">                            ;; else apply primitive procedure</div><div class="line">                            (apply proc args))))))))))</div><div class="line">(defun print-proc (proc &amp;optional (stream *standard-output*) depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;{~a}&quot; (or (proc-name proc) &#39;??)))</div></div><!-- fragment --><p>Трассируя хвосто-рекурсивную версию <code>interp</code>, вы можете видеть, что вызовы <code>traverse</code> спускаются только на три рекурсивных уровня <code>interp</code>, независимо от длины пройденного списка.</p>
<p>Обратите внимание, что мы не утверждаем, что этот интерпретатор не выделяет памяти при выполнении хвостовых рекурсивных вызовов. Действительно, он тратит довольно много памяти на вычисление аргументов и построение окружающей среды. Утверждается, что поскольку хранилище выделяется в куче, а не в стеке, его может вернуть сборщик мусора. Таким образом, даже если <code>traverse</code> применяется к бесконечно длинному списку (т. е. круговому списку), интерпретатор никогда не исчерпает пространство - он всегда сможет собрать мусор и продолжить работу.</p>
<p>В этот интерпретатор можно внести много улучшений, но лучше потратить усилия на улучшение компилятора, а не интерпретатора. Следующая глава посвящена именно этому.</p>
<h2>22.4 Throw, Catch и Call/cc</h2>
<p>Хвостовая рекурсия имеет решающее значение для Scheme. Идея состоит в том, что когда язык гарантированно оптимизирует хвостовые рекурсивные вызовы, тогда нет необходимости в специальных формах для выполнения итераций. Все циклы можно писать с помощью рекурсии, не беспокоясь о переполнении стека выполнения. Она помогает сохранить простоту языка и исключает использование оператора <code>goto</code>, признанного бедствием в движении за структурное программирование. Однако бывают случаи, когда какой-то нелокальный выход - лучшая альтернатива. Предположим, что в вашей программе происходит какое-то неожиданное событие. Лучшее действие - распечатать сообщение об ошибке и вернуться на верхний уровень вашей программы. Это можно сделать тривиально с помощью оператора goto. Без него каждую функцию на пути вызова пришлось бы изменить, чтобы принимать либо действительный результат, либо указание на исключительное условие, которое просто передается на следующий уровень.</p>
<p>В Common Lisp для такого нелокального выхода предусмотрены функции <code>throw</code> и <code>catch</code>. Скотт Циммерман, бессменный чемпион мира по фрисби, также работает программистом в южнокалифорнийской фирме. Однажды он сказал мне: "Я начинаю изучать Лисп, и это должен быть хороший язык, потому что в нем есть <code>throw</code> и <code>catch</code>. К сожалению для Скотта, слова <code>throw</code> и <code>catch</code> относятся не к фрисби, а к передаче управления. Это обе специальные формы со следующим синтаксисом:</p>
<div class="fragment"><div class="line">(catch tag body...)</div><div class="line">(throw tag value)</div></div><!-- fragment --><p>Первый аргумент <code>catch</code> - это тег или метка. Остальные аргументы вычисляются по одному, и возвращается значение последнего из них. Таким образом, <code>catch</code> очень похож на <code>progn</code>. Разница в том, что если какой-либо код в динамическом экстенте(внутри) тела <code>catch</code> вычисляет специальную форму <code>throw</code>, то управление немедленно передается за охватывающий <code>catch</code> с тем же тегом.</p>
<p>Например, форма</p>
<div class="fragment"><div class="line">(catch &#39;tag</div><div class="line">  (print 1) (throw &#39;tag 2) (print 3))</div></div><!-- fragment --><p>печатает <code>1</code> и возвращает <code>2</code>, не выводя на печать <code>3</code>. Более представительный пример:</p>
<div class="fragment"><div class="line">(defun print-table (l)</div><div class="line">  (catch &#39;not-a-number (mapcar #&#39;print-sqrt-abs l)))</div><div class="line">(defun print-sqrt-abs (x)</div><div class="line">  (print (sqrt (abs (must-be-number x)))))</div><div class="line">(defun must-be-number (x)</div><div class="line">  (if (numberp x) x</div><div class="line">      (throw &#39;not-a-number &quot;huh?&quot;)))</div><div class="line">&gt; (print-table &#39;(1 4 -9 x 10 20))</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">&quot;huh?&quot;</div></div><!-- fragment --><p>Здесь <code>print-table</code> вызывает <code>print-sqrt-abs</code>, который вызывает <code>must-be-number</code>. Первые три раза все в порядке, и печатаются значения 1,2,3. В следующий раз <code>x</code> не будет числом, поэтому значение <code>"huh?"</code> будет выброшено(throw) в тег <code>not-a-number</code>, установленный <code>catch</code> в <code>f</code>. Этот throw(Бросок) обходит ожидающие вызовы к <code>abs</code>, <code>sqrt</code> и <code>print</code>, а также остаток вызова <code>mapcar</code>.</p>
<p>Этот вид управления предоставляется в Scheme с помощью очень общей и мощной процедуры, <code>call-with-current-continue</code>, которая часто сокращается до <code>call/cc</code>. <code>call/cc</code> - это обычная процедура (не особая форма, такая как <code>throw</code> и <code>catch</code>), которая принимает единственный аргумент. Давайте назовем аргумент <code>computation</code>(вычислением). <code>computation</code> должна быть процедурой с одним аргументом. Когда вызывается <code>call/cc</code>, он вызывает <code>computation</code>, и все, что возвращает <code>computation</code>, является значением вызова <code>call/cc</code>. Уловка заключается в том, что процедура <code>computation</code> также принимает аргумент (который мы назовем <code>cc</code>), который является другой процедурой, представляющей текущую точку продолжения. Если <code>cc</code> применяется к какому-либо значению, это значение возвращается как значение вызова <code>call/cc</code>. Вот некоторые примеры:</p>
<div class="fragment"><div class="line">&gt; (scheme)</div><div class="line">=&gt; (+  1 (call/cc (lambda (cc) (+  20 300))))</div><div class="line">321</div></div><!-- fragment --><p>В этом примере игнорируется <code>cc</code> и вычисляется просто <code>(+ 1 (+ 20 300))</code>. Точнее, это эквивалент:</p>
<div class="fragment"><div class="line">((lambda (val) (+  1  val))</div><div class="line">  (+  20 300))</div></div><!-- fragment --><p>В следующем примере действительно используется <code>cc</code>:</p>
<div class="fragment"><div class="line">=&gt; (+  1 (call/cc (lambda (cc) (+  20 (cc 300)))))</div><div class="line">301</div></div><!-- fragment --><p>Он передает <code>300</code> в <code>cc</code>, минуя добавление <code>20</code>. Он фактически выбрасывает <code>300</code> из вычислений в точку перехвата, установленную <code>call/cc</code>. Это эквивалентно:</p>
<div class="fragment"><div class="line">((lambda (val) (+  1  val))</div><div class="line">  300)</div></div><!-- fragment --><p>или в:</p>
<div class="fragment"><div class="line">((lambda (val) (+  1  val))</div><div class="line">  (catch &#39;cc</div><div class="line">    ((lambda (v) (+  20 v))</div><div class="line">      (throw &#39;cc 300))))</div></div><!-- fragment --><p>Вот как будет выглядеть механизм <code>throw/catch</code> на Scheme:</p>
<div class="fragment"><div class="line">(define (print-table l )</div><div class="line">  (call/cc</div><div class="line">    (lambda (escape)</div></div><!-- fragment --><p><code>(set! not-a-number escape)</code></p>
<div class="fragment"><div class="line">      (map print-sqrt-abs l))))</div><div class="line">(define (print-sqrt-abs x)</div><div class="line">  (write (sqrt (abs (must-be-number x)))))</div><div class="line">(define (must-be-number x)</div><div class="line">  (if (numberp x) x</div><div class="line">      (not-a-number &quot;huh?&quot;)))</div><div class="line">(define (map fn l)</div></div><!-- fragment --><p><code>(if (null? l)</code></p>
<div class="fragment"><div class="line">&#39;()</div><div class="line">(cons (fn (first l))</div><div class="line">        (map fn (rest 1)))))</div></div><!-- fragment --><p>Возможность вернуться к ожидающей точке вычисления полезна для обработки ошибок и прерываний такого рода. Однако поистине удивительная, замечательная особенность <code>call/cc</code> - это возможность возвращаться к точке продолжения более одного раза. Рассмотрим небольшое изменение:</p>
<div class="fragment"><div class="line">=&gt; (+  1 (call/cc (lambda (cc)</div></div><!-- fragment --><p><code>(set! old-cc cc)</code></p>
<div class="fragment"><div class="line">                      (+  20 (cc 300)))))</div><div class="line">301</div><div class="line">=&gt; (old-cc 500)</div><div class="line">501</div></div><!-- fragment --><p>Здесь мы сначала вычислили 301, как и раньше, но попутно сохранили <code>cc</code> в глобальной переменной <code>old-cc</code>. После этого вызов <code>(old-cc 500)</code> возвращает (во второй раз) к точке в вычислении, где добавляется 1, на этот раз возвращая <code>501</code>. Эквивалентный код Common Lisp приводит к ошибке:</p>
<div class="fragment"><div class="line">&gt; (+  1 (catch &#39;tag (+  20 (throw &#39;tag 300))))</div><div class="line">301</div><div class="line">&gt; (throw &#39;tag 500)</div><div class="line">*Error*: *there was no pending CATCH for the tag TAG*</div></div><!-- fragment --><p>Другими словами, продолжения <code>call/cc</code> имеют неограниченную протяженность(extent), в то время как теги throw/catch имеют только динамическую протяженность(extent).</p>
<p>Мы можем использовать <code>call/cc</code> для реализации автоматического поиска с возвратом(backtracking) (среди прочего). Предположим, у нас есть специальная форма, <code>amb</code>, "неоднозначный" оператор, который возвращает один из своих аргументов, выбранных случайным образом. Мы могли бы написать:</p>
<div class="fragment"><div class="line">(define (integer) (amb 1 (+  1 (integer))))</div></div><!-- fragment --><p>а вызов <code>integer</code> вернет некоторое случайное положительное целое число. Вдобавок предположим, что у нас есть функция <code>fail</code>, которая вообще не возвращается, а вместо этого заставляет выполняться продолжение с предыдущей точки <code>amb</code> с другим выбором. Тогда мы могли бы написать краткий <a href="#fn0015">2</a> код отслеживания с возвратом, как показано ниже:</p>
<div class="fragment"><div class="line">(define (prime)</div><div class="line">  (let ((n (integer)))</div></div><!-- fragment --><p><code>(if (prime? n) n (fail))))</code></p>
<p>Если <code>prime?</code> - это предикат, который возвращает истину только тогда, когда его аргумент - простое(prime) число, то prime всегда будет возвращать некоторое <code>простое(prime)</code>число, определенное путем генерации случайных целых чисел. Хотя это выглядит как серьезное изменение языка - добавление обратного отслеживания и недетерминизма - оказывается, что <code>amb</code> и <code>fail</code> могут быть довольно легко реализованы с помощью <code>cal1/cc</code>. Во-первых, нам нужно сделать <code>amb</code> макросом:</p>
<div class="fragment"><div class="line">(def-scheme-macro amb (x y)</div><div class="line">  &#39;(random-choice (lambda () ,x) (lambda () ,y))))</div></div><!-- fragment --><p>В остальном это чистая Scheme. Мы ведем список <code>backtrack-points</code>(точек возврата), которые реализованы как функции без аргументов. Чтобы вернуться назад, мы просто вызываем одну из этих функций. Вот что делает <code>fail</code>. Функция <code>choose-first</code> принимает две функции и подталкивает вторую вместе с надлежащим продолжением к <code>backtrack-points</code>, а затем вызывает первую, возвращая это значение. Функция <code>random-choice</code> - это то, во что расширяется <code>amb</code>: она решает, какой выбор будет первым, а какой - вторым. (Обратите внимание, что в Scheme принято записывать глобальные переменные, такие как <code>backtrack-points</code>, без звездочек.)</p>
<div class="fragment"><div class="line">(define backtrack-points nil)</div><div class="line">(define (fail)</div><div class="line">  (let ((last-choice (car backtrack-points)))</div></div><!-- fragment --><p><code>(set! backtrack-points (cdr backtrack-points))</code></p>
<div class="fragment"><div class="line">    (last-choice)))</div><div class="line">(define (random-choice f g)</div><div class="line">  (if (=  1 (random 2))</div><div class="line">      (choose-first f g)</div><div class="line">      (choose-first g f)))</div><div class="line">(define (choose-first f g)</div><div class="line">  (call/cc</div><div class="line">    (lambda (k)</div></div><!-- fragment --><p><code>(set! backtrack-points</code></p>
<div class="fragment"><div class="line">      (cons (lambda () (k (g))) backtrack-points))</div><div class="line">(f))))</div></div><!-- fragment --><p>Это реализует хронологическое обратное отслеживание(backtracking), как в Prolog. Однако на самом деле у нас есть свобода делать и другие виды обратного отслеживания. Вместо того, чтобы <code>fail</code> брал первый элемент из <code>backtrack-points</code>, мы могли бы выбрать случайный элемент. Или мы могли бы провести более сложный анализ, чтобы выбрать хорошую точку возврата.</p>
<p><code>call/cc</code> может использоваться для реализации различных структур управления. В качестве другого примера, многие реализации Lisp предоставляют функцию <code>reset</code>, которая прерывает текущее вычисление и возвращает управление циклу чтения-оценки-печати верхнего уровня. reset можно довольно легко определить с помощью <code>call/cc</code>. Хитрость заключается в том, чтобы захватить продолжение, которое находится на верхнем уровне, и сохранить его для использования в будущем. Следующее выражение, вычисленное на верхнем уровне, сохраняет соответствующее продолжение в значении reset:</p>
<p><code>(call/cc (lambda (cc) (set! reset (lambda ()</code></p>
<div class="fragment"><div class="line">(cc &quot;Back to top level&quot;)))))</div></div><!-- fragment --><p><b>Exercise 22.2 [m]</b> Можете ли вы реализовать <code>call/cc</code> в Common Lisp?</p>
<p><b>Exercise 22.3 [s]</b> Can you implement <code>amb</code> and <code>fail</code> in Common Lisp?</p>
<p><b>Exercise 22.4 [m]</b><code>fail</code> could be written</p>
<p><code>(define (fail) ((pop backtrack-points)))</code> if we had the pop macro in Scheme.</p>
<p>Write <code>pop.</code></p>
<h2>22.5 Интерпретатор с поддержкой Call/cc</h2>
<p>Интересно, что чем больше может предложить хост-язык, тем проще написать интерпретатор. Возможно, самая сложная часть написания интерпретатора (или компилятора) Лиспа - это сборка мусора. Написав наш интерпретатор на Лиспе, мы полностью обошли эту проблему - основной язык автоматически собирает мусор. Точно так же, если мы используем Common Lisp, который имеет хвостовую рекурсию, то наш интерпретатор тоже будет использовать её, без каких-либо специальных действий. Если нет, то интерпретатор должен быть переписан, чтобы позаботиться о хвостовой рекурсии, как мы видели выше.</p>
<p>То же самое и с <code>call/cc</code>. Если наш основной язык обеспечивает предоставляет продолжения с неограниченным экстентом(временем существования), то реализовать <code>call/cc</code> тривиально. Если нет, мы должны переписать весь интерпретатор, чтобы он явно обрабатывал продолжения. Лучший способ сделать это - сделать <code>interp</code> функцией трех аргументов: выражения, окружения и продолжения. Значит, придется изменить и верхний уровень. Вместо того, чтобы заставлять <code>interp</code> возвращать значение, которое распечатывается, мы просто передаем ему функцию <code>print</code> как продолжение:</p>
<div class="fragment"><div class="line">(defun scheme ()</div><div class="line">    &quot;A Scheme read-eval-print loop (using interp).</div><div class="line">    Handles call/cc by explicitly passing continuations.&quot;</div><div class="line">    (init-scheme-interp)</div><div class="line">    (loop (format t &quot;~&amp;==&gt; &quot;)</div><div class="line">              (interp (read) nil #&#39;print)))</div></div><!-- fragment --><p>Теперь мы готовы заняться <code>interp</code>. Для ясности мы возьмём за базу его на не хвостово-рекурсивную версию. Случаи символов, атомов, макросов и <code>quote</code>(цитаты) почти такие же, как и раньше. Разница в том, что результат каждого вычисления передается продолжению <code>cc</code>, а не просто возвращается.</p>
<p>Остальные случаи более сложные, потому что все они требуют явного представления продолжений. Это означает, что вызовы <code>interp</code> не могут быть вложенными. Вместо этого мы вызываем <code>interp</code> с продолжением, которое включает еще один вызов <code>interp</code>. Например, чтобы интерпретировать (<code>if p x y</code>), мы сначала вызываем <code>interp</code> для второго элемента формы, предиката <code>p</code>. Продолжением этого вызова является функция, которая проверяет значение <code>p</code> и интерпретирует соответственно <code>x</code> или <code>y</code>, используя исходное продолжение для рекурсивного вызова <code>interp</code>. Остальные случаи аналогичны. Одним из важных изменений является то, что процедуры Scheme реализованы как функции Lisp, где первым аргументом является продолжение:</p>
<div class="fragment"><div class="line">(defun interp (x env cc)</div><div class="line">  &quot;Evaluate the expression x in the environment env,</div><div class="line">  and pass the result to the continuation cc.&quot;</div><div class="line">  (cond</div><div class="line">    ((symbolp x) (funcall cc (get-var x env)))</div><div class="line">    ((atom x) (funcall cc x))</div><div class="line">    ((scheme-macro (first x))</div><div class="line">      (interp (scheme-macro-expand x) env cc))</div><div class="line">    ((case (first x)</div><div class="line">          (QUOTE (funcall cc (second x)))</div><div class="line">          (BEGIN (interp-begin (rest x) env cc))</div><div class="line">(SET!    (interp (third x) env</div><div class="line">                    #&#39;(lambda (val)</div></div><!-- fragment --><p><code>(funcall cc (set-var! (second x)</code></p>
<div class="fragment"><div class="line">                                                                        val env)))))</div><div class="line">(IF      (interp (second x) env</div><div class="line">                    #&#39;(lambda (pred)</div><div class="line">                          (interp (if pred (third x) (fourth x))</div><div class="line">                                env cc))))</div><div class="line">(LAMBDA (let ((parms (second x))</div><div class="line">                  (code (maybe-add &#39;begin (rest2 x))))</div><div class="line">              (funcall</div><div class="line">                cc</div><div class="line">                #&#39;(lambda (cont &amp;rest args)</div><div class="line">                    (interp code</div><div class="line">                              (extend-env parms args env)</div><div class="line">                              cont)))))</div><div class="line">(t      (interp-call x env cc))))))</div></div><!-- fragment --><p>Определены несколько вспомогательных функций в том же стиле передачи продолжения:</p>
<div class="fragment"><div class="line">(defun interp-begin (body env cc)</div><div class="line">  &quot;Interpret each element of BODY, passing the last to CC.&quot;</div><div class="line">  (interp (first body) env</div><div class="line">          #&#39;(lambda (val)</div><div class="line">              (if (null (rest body))</div><div class="line">                      (funcall cc val)</div><div class="line">                      (interp-begin (rest body) env cc)))))</div><div class="line">(defun interp-call (call env cc)</div><div class="line">  &quot;Interpret the call (f x...) and pass the result to CC.&quot;</div><div class="line">  (map-interp call env</div><div class="line">                  #&#39;(lambda (fn-and-args)</div><div class="line">                      (apply (first fn-and-args)</div><div class="line">                                cc</div><div class="line">                                (rest fn-and-args)))))</div><div class="line">(defun map-interp (list env cc)</div><div class="line">  &quot;Interpret each element of LIST, and pass the list to CC.&quot;</div><div class="line">  (if (null list)</div><div class="line">        (funcall cc nil)</div><div class="line">        (interp (first list) env</div><div class="line">                  #&#39;(lambda (x)</div><div class="line">                      (map-interp (rest list) env</div><div class="line">                                #&#39;(lambda (y)</div><div class="line">                                (funcall cc (cons x y))))))))</div></div><!-- fragment --><p>Поскольку процедуры Scheme ожидают продолжения в качестве первого аргумента, нам нужно переопределить <code>init-scheme-proc</code> для установки процедур, которые принимают и применяют продолжение:</p>
<div class="fragment"><div class="line">(defun init-scheme-proc (f)</div><div class="line">  &quot;Define a Scheme procedure as a corresponding CL function.&quot;</div><div class="line">  (if (listp f)</div><div class="line">      (set-global-var! (first f) (symbol-function (second f)))</div><div class="line">      (set-global-var! f (symbol-function f))))</div></div><!-- fragment --><p>Нам также нужно определить <code>call/cc</code>. Подумайте на мгновение о том, что должен делать <code>call/cc</code>. Как и все процедуры Scheme, он принимает текущее продолжение в качестве первого аргумента. Второй аргумент - это процедура - вычисление, которое нужно выполнить. <code>call/cc</code> выполняет вычисление, вызывая процедуру. Это обычный вызов, поэтому он использует текущее продолжение. Сложность состоит в том, что <code>call/cc</code> передает вычисление в качестве аргумента. Он передает процедуру выхода, которая может быть вызвана для возврата в ту же точку, в которую был бы возвращен исходный вызов <code>call/cc</code>. Как только работа <code>call/cc</code> будет понятна, реализация станет очевидной:</p>
<div class="fragment"><div class="line">(defun call/cc (cc computation)</div><div class="line">  &quot;Make the continuation accessible to a Scheme procedure.&quot;</div><div class="line">  (funcall computation cc</div><div class="line">           ;; Package up CC into a Scheme function:</div><div class="line">           #&#39;(lambda (cont val)</div><div class="line">               (declare (ignore cont))</div><div class="line">               (funcall cc val))))</div><div class="line"></div><div class="line">;; Now install call/cc in the global environment</div><div class="line">(set-global-var! &#39;call/cc #&#39;call/cc)</div><div class="line">(set-global-var! &#39;call-with-current-continuation #&#39;call/cc)</div></div><!-- fragment --><h2>22.6 История и Ссылки</h2>
<p>Lisp interpreters and AI have a long history together. MIT AI Lab Memo No. 1 (<a href="B9780080571157500285.xhtml#bb0790">McCarthy 1958</a>) was the first paper on Lisp. McCarthy's students were working on a Lisp compiler, had written certain routines-<code>read</code>, <code>print</code>, etc.-<code>in</code> assembly language, and were trying to develop a full Lisp interpreter in assembler. Sometime around the end of 1958, McCarthy wrote a theoretical paper showing that Lisp was powerful enough to write the universal function, <code>eval</code>. A programmer on the project, Steve Russell, saw the paper, and, according to McCarthy:</p>
<blockquote class="doxtable">
<p>Steve Russell said, look, why don't I program this <code>eval</code> and-you remember the interpreter-and I said to him, ho, ho, you're confusing theory with practice, this <code>eval</code> is intended for reading not for computing. </p>
</blockquote>
<p>But he went ahead and did it. That is, he compiled the <code>eval</code> in my paper into 704 machine code fixing bugs and then advertised this as a Lisp interpreter, which it certainly was.<a href="#fn0020">3</a></p>
<p>So the first Lisp interpreter was the result of a programmer ignoring his boss's advice. The first compiler was for the Lisp 1.5 system (<a href="B9780080571157500285.xhtml#bb0815">McCarthy et al. 1962</a>). The compiler was written in Lisp; it was probably the first compiler written in its own language.</p>
<p>Allen's <em>Anatomy of lisp</em> (1978) was one of the first overviews of Lisp implementation techniques, and it remains one of the best. However, it concentrates on the dynamic-scoping Lisp dialects that were in use at the time. The more modern view of a lexically scoped Lisp was documented in an influential pair of papers by Guy Steele (<a href="B9780080571157500285.xhtml#bb1130">1976a</a>,<a href="B9780080571157500285.xhtml#bb1135">b</a>). His papers "Lambda: the ultimate goto" and "Compiler optimization based on viewing lambda as rename plus goto" describe properly tail-recursive interpreters and compilers.</p>
<p>The Scheme dialect was invented by Gerald Sussman and Guy Steele around 1975 (see their MIT AI Memo 349). The <em>Revised*4*Report on the Algorithmic Language Scheme</em> (<a href="B9780080571157500285.xhtml#bb0205">Clinger et al. 1991</a>) is the definitive reference manual for the current version of Scheme.</p>
<p><a href="B9780080571157500285.xhtml#bb0010">Abelson and Sussman (1985)</a> is probably the best introduction to computer science ever written. It may or may not be a coincidence that it uses Scheme as the programming language. It includes a Scheme interpreter. Winston and Horn's <em>Lisp</em> (1989) also develops a Lisp interpreter.</p>
<p>The <code>amb</code> operator for nondeterministic choice was proposed by <a href="B9780080571157500285.xhtml#bb0800">John McCarthy (1963)</a> and used in SCHEMER (<a href="B9780080571157500285.xhtml#bb1440">Zabih et al. 1987</a>), a nondeterministic Lisp. <a href="B9780080571157500285.xhtml#bb1015">Ruf and Weise (1990)</a> present another implementation of backtracking in Scheme that incorporates all of logic programming.</p>
<h2>22.7 Упражнения</h2>
<p><b>Exercise 22.5 [m]</b> Хотя Scheme не обеспечивает полноценной поддержки необязательных аргументов и аргументов ключевых слов, он поддерживает параметры rest. Измените интерпретатор для поддержки синтаксиса Scheme для параметров rest:</p>
<table class="doxtable">
<tr>
<th>Scheme </th><th>Common Lisp  </th></tr>
<tr>
<td>(<code>lambda x</code>*body*) </td><td>(<code>lambda</code> (<code>&amp;rest x</code>) <em>body</em>) </td></tr>
<tr>
<td>(<code>lambda (x y . z)</code>*body*) </td><td>(<code>lambda</code> (<code>x y &amp;rest z</code>) <em>body</em>) </td></tr>
</table>
<p><b>Exercise 22.6 [h]</b> The representation of environments is somewhat wasteful. Currently it takes 3*n* cons cells to represent an environment with <em>n</em> variables. Change the representation to take less space.</p>
<p><b>Exercise 22.7 [m]</b> As we've implemented macros, they need to be expanded each time they are encountered. This is not so bad for the compiler-you expand the source code and compile it, and then never refer to the source code again. But for the interpreter, this treatment of macros is most unsatisfactory: the work of macroexpansion must be done again and again. How can you eliminate this duplicated effort?</p>
<p><b>Exercise 22.8 [m]</b> It turns out Scheme allows some additional syntax in <code>let</code> and <code>cond</code>. First, there is the "named-let" expression, which binds initial values for variables but also defines a local function that can be called within the body of the <code>let</code>. Second, <code>cond</code> recognizes the symbol =&gt; when it is the second element of a cond clause, and treats it as a directive to pass the value of the test (when it is not false) to the third element of the clause, which must be a function of one argument. Here are two examples:</p>
<div class="fragment"><div class="line">(define (fact n)</div><div class="line">  ;; Iterative factorial; does not grow the stack</div><div class="line">  (let loop ((result 1) (i n))</div><div class="line">    (if (= i 0) result (loop (* result i) (- i 1)))))</div><div class="line">(define (lookup key alist)</div><div class="line">  ;; Find key&#39;s value in alist</div><div class="line">  (cond ((assoc key alist) =&gt; cdr)</div><div class="line">          (else #f)))</div></div><!-- fragment --><p>These are equivalent to:</p>
<div class="fragment"><div class="line">(define (fact n)</div><div class="line">  (letrec</div><div class="line">    ((loop (lambda (result i)</div><div class="line">                (if (= i 0)</div><div class="line">                    result</div><div class="line">                    (loop (* result i) (- i 1))))))</div><div class="line">    (loop 1 n)))</div><div class="line">(define (lookup key alist)</div><div class="line">  (let ((g0030 (assoc key alist)))</div><div class="line">    (if g0030</div><div class="line">        (cdr g0030)</div><div class="line">        #f)))</div></div><!-- fragment --><p>Write macro definitions for <code>let</code> and <code>cond</code> allowing these variations.</p>
<p><b>Exercise 22.9 [h]</b> Some Scheme implementations permit <code>define</code> statements inside the body of a <code>lambda</code> (and thus of a <code>define</code>, <code>let</code>, <code>let*</code>, or <code>letrec</code> as well). Here is an example:</p>
<div class="fragment"><div class="line">(define (length l)</div><div class="line">  (define (len l n)</div></div><!-- fragment --><p><code>(if (null? l) n (len (cdr l) (+ n 1))))</code></p>
<div class="fragment"><div class="line">(len l 0))</div></div><!-- fragment --><p>The internal definition of len is interpreted not as defining a global name but rather as defining a local name as if with <code>letrec</code>. The above definition is equivalent to:</p>
<div class="fragment"><div class="line">(define (length l)</div><div class="line">  (letrec ((len (lambda (l n)</div></div><!-- fragment --><p><code>(if (null? l) n (len (cdr l) (+ n 1))))))</code></p>
<div class="fragment"><div class="line">(len l 0)))</div></div><!-- fragment --><p>Make changes to the interpreter to allow this kind of internal definition.</p>
<p><b>Exercise 22.10</b> Scheme programmers are often disdainful of the <code>function</code> or <code>#</code>' notation in Common Lisp. Is it possible (without changing the compiler) to make Common Lisp accept <code>(lambda ( ) ... )</code> instead of <code>#</code> ' <code>(lambda ( ) ... )</code> and <code>fn</code> instead of <code>#</code>'<code>fn?</code></p>
<p><b>Exercise 22.11 [m]</b> The top level of the continuation-passing version of <code>scheme</code> includes the call: <code>(interp (read)</code><code>nil</code> #'<code>print)</code>. Will this always result in some value being printed? Or is it possible that the expression read might call some escape function that ignores the value without printing anything?</p>
<p><b>Exercise 22.12 [h]</b> What would have to be added or changed to turn the Scheme interpreter into a Common Lisp interpreter?</p>
<p><b>Exercise 22.13 [h]</b> How would you change the interpreter to allow for multiple values? Explain how this would be done both for the first version of the interpreter and for the continuation-passing version.</p>
<h2>22.8 Ответы</h2>
<p><b>Answer 22.2</b> Невозможно реализовать полный <code>call/cc</code> для Common Lisp, но следующее работает для случаев, когда продолжение используется только с динамическим экстентом:</p>
<div class="fragment"><div class="line">(defun call/cc (cc computation)</div><div class="line">  &quot;Make the continuation accessible to a Scheme procedure.&quot;</div><div class="line">  (funcall computation cc</div><div class="line">           ;; Package up CC into a Scheme function:</div><div class="line">           #&#39;(lambda (cont val)</div><div class="line">               (declare (ignore cont))</div><div class="line">               (funcall cc val))))</div></div><!-- fragment --><p><b>Answer 22.3</b> No. <code>fail</code> requires continuations with dynamic extent.</p>
<p><b>Answer 22.5</b> We need only modify <code>extend</code> - <code>env</code> to know about an atomic <code>vars</code> list. While we're at it, we might as well add some error checking:</p>
<div class="fragment"><div class="line">(defun extend-env (vars vals env)</div><div class="line">  &quot;Add some variables and values to an environment.&quot;</div><div class="line">  (cond ((null vars)</div><div class="line">          (assert (null vals) ( ) &quot;Too many arguments supplied&quot;)</div><div class="line">          env)</div><div class="line">          ((atom vars)</div><div class="line">            (cons (list vars vals) env))</div><div class="line">          (t (assert (rest vals) ( ) &quot;Too few arguments supplied&quot;)</div><div class="line">              (cons (list (first vars) (first vals))</div><div class="line">                      (extend-env (rest vars) (rest vals) env)))))</div></div><!-- fragment --><p><b>Answer 22.6</b> Storing the environment as an association list, <code>((*var val*)...)</code>, makes it easy to look up variables with <code>assoc</code>. We could save one cons cell per variable just by changing to <code>((*var* . *val*)...)</code>. But even better is to switch to a different representation, one presented by Steele and Sussman in <em>The Art of the Interpreter</em> (1978). In this representation we switch from a single list of var/val pairs to a list of frames, where each frame is a var-list/val-list pair. It looks like this:</p>
<div class="fragment"><div class="line">(((*var*...) . (*val*...))</div><div class="line">  ((*var*...) . (*val*...))</div><div class="line">...)</div></div><!-- fragment --><p>Now <code>extend-env</code> is trivial:</p>
<div class="fragment"><div class="line">(defun extend-env (vars vals env)</div><div class="line">  &quot;Add some variables and values to an environment.&quot;</div><div class="line">  (nconc (mapcar #&#39;list vars vals) env))</div></div><!-- fragment --><p>The advantage of this approach is that in most cases we already have a list of variables (the procedure's parameter list) and values (from the <code>mapcar</code> of <code>interp</code> over the arguments). So it is cheaper to just cons these two lists together, rather than arranging them into pairs. Of course, <code>get-var</code> and <code>set-var</code>! become more complex.</p>
<p><b>Answer 22.7</b> One answer is to destructively alter the source code as it is macro-expanded, so that the next time the source code is interpreted, it will already be expanded. The following code takes care of that:</p>
<div class="fragment"><div class="line">(defun scheme-macro-expand (x)</div><div class="line">  (displace x (apply (scheme-macro (first x)) (rest x))))</div><div class="line">(defun displace (old new)</div><div class="line">  &quot;Destructively change old cons-cell to new value.&quot;</div><div class="line">  (if (consp new)</div><div class="line">        (progn (setf (car old) (car new))</div><div class="line">                      (setf (cdr old) (cdr new))</div><div class="line">                      old)</div><div class="line">        (displace old &#39;(begin ,new))))</div></div><!-- fragment --><p>One drawback to this approach is that the user's source code is actually changed, which may make debugging confusing. An alternative is to expand into something that keeps both the original and macro-expanded code around:</p>
<div class="fragment"><div class="line">(defun displace (old new)</div><div class="line">  &quot;Destructively change old to a DISPLACED structure.&quot;</div><div class="line">  (setf (car old) &#39;DISPLACED)</div><div class="line">  (setf (cdr old) (list new old))</div><div class="line">  old)</div></div><!-- fragment --><p>This means that <code>DISPLACED</code> is a new special form, and we need a clause for it in the interpreter. It would look something like this:</p>
<div class="fragment"><div class="line">(case (first x)</div><div class="line">  ...</div><div class="line">  (DISPLACED (interp (second x) env))</div><div class="line">  ...</div></div><!-- fragment --><p>We'd also need to modify the printing routines to print just <code>old</code> whenever they see <code>(displaced old new)</code>.</p>
<p><b>Answer 22.8</b></p>
<div class="fragment"><div class="line">(def-scheme-macro let (vars &amp;rest body)</div><div class="line">  (if (symbolp vars)</div><div class="line">        ;; named let</div><div class="line">        (let ((f vars) (vars (first body)) (body (rest body)))</div><div class="line">          &#39;(letrec ((,f (lambda ,(mapcar #&#39;first vars) .,body)))</div><div class="line">                (,f .,(mapcar #&#39;second vars))))</div><div class="line">        ;; &quot;regular&quot; let</div><div class="line">        &#39;((lambda ,(mapcar #&#39;first vars) . ,body)</div></div><!-- fragment --><p><code>. ,(mapcar #'second vars)))))</code></p>
<div class="fragment"><div class="line">(def-scheme-macro cond (&amp;rest clauses)</div><div class="line">  (cond ((null clauses) nil)</div><div class="line">        ((length=1 (first clauses))</div><div class="line">         `(or ,(first clauses) (cond .,(rest clauses))))</div><div class="line">        ((starts-with (first clauses) &#39;else)</div><div class="line">         `(begin .,(rest (first clauses))))</div><div class="line">        ((eq (second (first clauses)) &#39;=&gt;)</div><div class="line">            (assert (= (length (first clauses)) 3))</div><div class="line">            (let ((var (gensym)))</div><div class="line">            &#39;(let ((,var ,(first (first clauses))))</div><div class="line">                (if ,var (,(third (first clauses)) ,var)</div><div class="line">                          (cond .,(rest clauses))))))</div><div class="line">        (t `(if ,(first (first clauses))</div><div class="line">                (begin .,(rest (first clauses)))</div><div class="line">                (cond .,(rest clauses))))))</div></div><!-- fragment --><p><b>Answer 22.10</b> It is easy to define <code>lambda</code> as a macro, eliminating the need for `#'(lambda ...)`:</p>
<div class="fragment"><div class="line">(defmacro lambda (args &amp;rest body)</div><div class="line">  &#39;(function (lambda .args .@body)))</div></div><!-- fragment --><p>If this were part of the Common Lisp standard, I would gladly use it. But because it is not, I have avoided it, on the grounds that it can be confusing.</p>
<p>It is also possible to write a new function-defining macro that would do the following type of expansion:</p>
<div class="fragment"><div class="line">(defn double (x) (* 2 x)) =&gt;</div><div class="line">(defparameter double (defun double (x) (* 2 x)))</div></div><!-- fragment --><p>This makes <code>double</code> a special variable, so we can write <code>double</code> instead of <code>#'double</code>. But this approach is not recommended-it is dangerous to define special variables that violate the asterisk convention, and the Common Lisp compiler may not be able to optimize special variable references the way it can <code>function</code> special forms. Also, this approach would not interact properly with <code>flet</code> and <code>labels</code>. </p><hr/>
<p><a href="#xfn0010">1</a> One writes <code>numberp</code> because there is no hyphen in <code>number</code> but <code>random-state-p</code> because there is a hyphen in <code>random-state</code>. However, <code>defstruct</code> concatenates <code>-p</code> in all its predicates, regardless of the presence of a hyphen in the structure's name. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0015">2</a> although inefficient !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">3</a> McCarthy's words from a talk on the history of Lisp, 1974, recorded by <a href="B9780080571157500285.xhtml#bb1205">Stoyan (1984)</a>. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
