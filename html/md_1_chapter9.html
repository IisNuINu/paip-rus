<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 9</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 9 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Вопросы эффективности</h2>
<blockquote class="doxtable">
<p>Программист на Лиспе знает значение всего, но не знает цены ничему. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Alan J. </p>
</blockquote>
<p>Perlis</p>
<blockquote class="doxtable">
<p>Lisp по своей сути не менее эффективен, чем другие языки высокого уровня </p>
</blockquote>
<blockquote class="doxtable">
<p>-Richard J. </p>
</blockquote>
<p>Fateman</p>
<p>Одна из причин, по которой Lisp имеет долгую историю, заключается в том, что это идеальный язык для того, что сейчас называется <em>быстрое прототипирование</em> - быстрая разработка программы, не обращающая внимание на детали. Именно этим мы и занимались до сих пор в этой книге: концентрировались на получении работающего алгоритма. К сожалению, когда прототип должен быть превращен в программу производственного качества, детали уже нельзя игнорировать. Большинство "настоящих" программ ИИ работают с большими объемами данных и с большими пространствами поиска. Таким образом, соображения эффективности становятся очень важными.</p>
<p>Однако это не означает, что написание эффективной программы в корне отличается от написания рабочей программы. В идеале разработка эффективной программы должна состоять из трех этапов. Во-первых, разработайте рабочую программу, используя надлежащие абстракции, чтобы при необходимости ее можно было легко изменить. Во-вторых, <em>проанализируйте</em> программу, чтобы определить, где она проводит большую часть времени. В-третьих, замените медленные части более быстрыми версиями, сохранив при этом корректность программы.</p>
<p>Термин <em>эффективность</em> будет использоваться в основном для обозначения <em>скорости</em> или времени выполнения программы. В меньшей степени <em>эффективность</em> также используется для обозначения <em>пространства</em> или объема памяти, потребляемого программой. Также поговорим о стоимости программы. Отчасти это связано с использованием метафоры "время - деньги", а отчасти связано с реальными денежными затратами: если критически важная программа работает неприемлемо медленно, возможно, вам придется купить более дорогой компьютер.</p>
<p>Lisp получил репутацию "неэффективного языка". Строго говоря, нет смысла называть <em>язык</em> эффективным или неэффективным. Скорее, только конкретная <em>реализация</em> языка, выполняющего конкретную программу, может быть измерена на эффективность. Утверждение о неэффективности Lisp отчасти является историческим утверждением: некоторые прошлые реализации <em>были</em> неэффективными. Это также отчасти прогноз: есть несколько причин, по которым будущие реализации, как ожидается, будут иметь неэффективность. Эти причины в основном проистекают из гибкости Lisp. Lisp позволяет отложить принятие многих решений до времени выполнения, и это может увеличить время выполнения. За последнее десятилетие "разрыв в эффективности" между Lisp и "традиционными языками", такими как FORTRAN или C, сократился. Вот причины - некоторые заслуженные, а некоторые нет - создающие Лиспу репутацию неэффективного языка:</p>
<ul>
<li>Ранние реализации скорее интерпретировались, чем компилировались, что делало их по сути неэффективными. Реализации Common Lisp имеют компиляторы, так что это больше не проблема. Хотя Lisp (в первую очередь) больше не является интерпретируемым языком, он по-прежнему является <em>интерактивным</em> языком, поэтому он сохраняет свою гибкость.</li>
<li>Лисп часто использовался для написания интерпретаторов для встроенных языков, что усугубляло проблему. Рассмотрим эту цитату из книги <a href="B9780080571157500285.xhtml#bb0260">Cooper and Wogrin's (1988)</a> о языке программирования на основе правил OPS5:</li>
</ul>
<blockquote class="doxtable">
<p>Эффективность реализаций, компилирующих правила в исполняемый код, выгодно отличается от эффективности программ, написанных на большинстве последовательных языков, таких как FORTRAN или Pascal. Реализации, которые компилируют правила в структуры данных для интерпретации, как и многие из основанных на Lisp, могут быть заметно медленнее. </p>
</blockquote>
<p>Здесь Лисп виноват по ассоциации. Ошибочная цепочка рассуждений такова: Лисп использовался для написания интерпретаторов; интерпретаторы медлительны; поэтому Лисп медленный. Хотя это правда, что Lisp очень упрощает написание интерпретаторов, он также упрощает написание компиляторов. Эта книга - первая книга, в которой основное внимание уделяется использованию Lisp в качестве языка реализации и целевого языка для компиляторов.</p>
<ul>
<li>Lisp поощряет стиль с множеством вызовов функций, особенно рекурсивных вызовов. В некоторых старых системах вызовы функций были дорогими. Но теперь понятно, что вызов функции может быть скомпилирован в простую инструкцию ветвления, и что многие рекурсивные вызовы могут выполняться не дороже, чем эквивалентный итерационный цикл (см. <a href="B9780080571157500224.xhtml">Глава 22</a>). Также можно дать указание компилятору Common Lisp скомпилировать определенные функции во встроенном режиме(inline), чтобы не было дополнительных затрат на вызовы. С другой стороны, многие системы Lisp требуют двух выборок вместо одной, чтобы найти код функции, и, следовательно, будут медленнее. Этот дополнительный уровень косвенности - это плата за свободу переопределения функций без перезагрузки всей программы.</li>
<li>Проверка типов во время выполнения выполняется медленно. Lisp предоставляет набор обобщенных функций. Например, мы можем написать <code>(+ x y)</code>, не беспокоясь о том, являются ли <code>x</code> и <code>y</code> целыми числами, числами с плавающей запятой, большими числами, комплексными числами, рациональными числами или какой-либо комбинацией вышеперечисленного. Это очень удобно, но это означает, что проверки типов должны выполняться во время выполнения, поэтому обобщенный + будет медленнее, чем, скажем, сложение 16-битных целых чисел без проверки переполнения. Если важна эффективность, Common Lisp позволяет программисту включать объявления, которые могут исключить проверки во время выполнения. Фактически, после добавления правильных объявлений Lisp может работать так же быстро или быстрее, как и обычные языки. <a href="B9780080571157500285.xhtml#bb0375">Fateman (1973)</a> сравнил процедуру кубичесого корня FORTRAN на PDP-10 с транслитерацией MacLisp. Версия MacLisp выдавала практически идентичный числовой код, но в целом была на 18% быстрее из-за превосходной последовательности вызова функций. <a href="#fn0010">1</a> Эпиграф в начале этой главы взят из этой статьи. <a href="B9780080571157500285.xhtml#bb0085">Berlin and Weise (1990)</a> в которой показывают, что с помощью специальной техники компиляции, называемой <em>частичным вычислением</em>, можно достичь скорости от 7 до 90 раз быстрее, чем код, скомпилированный традиционным способом. Конечно, частичное вычисление можно использовать на любом языке, но в Лиспе это очень легко сделать. Факт остается фактом: объекты Lisp должны каким-то образом представлять свой тип, и даже с объявлениями не все эти накладные расходы можно устранить. Большинство реализаций Lisp оптимизируют доступ к спискам и фиксированным числам, но расплачиваются за другие, менее часто используемые типы данных.</li>
<li>Lisp автоматически управляет хранилищем, поэтому он должен переодически останавливаться и собирать неиспользуемое хранилище, или <em>мусор/garbage</em>. В ранних системах это делалось путем периодической очистки всей памяти, что приводило к заметной паузе. Современные системы, как правило, используют методы инкрементной(постепенной) сборки мусора, поэтому паузы короче и обычно незаметны(хотя паузы могут быть слишком длинными для приложений реального времени, таких как управление лабораторным прибором). Проблема с автоматической сборкой мусора в наши дни не в том, что она медленная - на самом деле, автоматические системы делают примерно так же, как и ручное выделение. Проблема в том, что они в первую очередь позволяют программисту создавать МНОГО мусора. Программисты использующие традиционные языки, которым приходится убирать свой собственный мусор, как правило, более осторожны и чаще используют статическое, а не динамическое хранилище. Если мусор становится проблемой, программист на Лиспе может просто использовать эти статические техники.</li>
<li>Lisp системы велики и оставляют мало места для других программ. Большинство Lisp систем спроектированы как законченные среды, в которых программист выполняет всю разработку и выполнение программ. Для такого рода операций имеет смысл иметь большой язык, такой как Common Lisp, с огромным набором инструментов. Однако становится все более распространенным использование Лиспа как одного компонента в вычислительной среде, которая может включать UNIX, X Windows, emacs, и другие взаимодействующие программы. В такой гетерогенной среде было бы полезно иметь возможность определять и запускать небольшие Lisp процессы, которые не включают мегабайты неиспользуемых инструментов. Некоторые последние компиляторы поддерживают эту опцию, но пока она не распространена.</li>
<li>Lisp - сложный язык высокого уровня, и программисту может быть сложно предвидеть затраты на различные операции. В общем, проблема не в том, что эффективное кодирование невозможно, а втом, что трудно достичь этого эффективного кодирования. На таком языке как Си, опытный программист имеет довольно хорошее представление о том, как каждый оператор будет компилироваться в инструкции на языке ассемблера. Но в Лиспе очень похожие операторы могут компилироваться в очень разные инструкции ассемблерного уровня, в зависимости от тонкого взаимодействия между данными объявлениями(declarations) и возможностями компилятора. <a href="B9780080571157500108.xhtml#p318">На Стр. 318</a> приведен пример, в котором добавление объявления ускоряет выполнение тривиальной функци в 40 раз. Не эксперты не понимают, когда такие деклараци необходимы, и расстраиваются из-за их кажущихся несоответствий. Опытный программист на Лиспе со временем вырабатывает хорошую "модель эфффективности" и необходимость таких деклараций становится очевидной. Последние компиляторы, такие как CMU's Python, обеспечивают обратную связь, которая облегчает процесс обучения этому.</li>
</ul>
<p>Таким образом, Lisp позволяет писать программы в самых разнообразных стилях, некоторые эффективные, некоторые не очень. Программист, который пишет Лисп-программы в том же стиле, что и программы на Си, вероятно обнаружит, что Лисп имеет сопоставимую скорость, возможно немного чуть медленне. Программист, который использует некоторые из наиболее динамичных функций Лисп, обычно находит, что гораздо проще разработать работающую программу. Затем, если результирующая программа недостаточно эффективна у вас будет больше времени, чтобы вернуться назад и улучшить критические разделы. Решение о том, какие части программы используют больше всего ресурсов, принимается вызвав <em>инструментарий</em>. Безрассудно пытаться повысить эффективность программы, предварительно не проверив, действительно ли улучшение будет иметь значение.</p>
<p>Одним из путей повышения эффективности является использование прототипов на Лиспе в качестве спецификации и повторная реализация этой спецификации на языке более низкого уровня, таком как Си или Си++. Некоторые коммерческие поставщики ИИ идут по этому пути. Альтернативой является использование Лиспа в качестве языка как для прототипа, так и для окончательной реализации. Добавляя объявления и внося незначительные изменения в исходную программу, можно получить Лисп программу, аналогичную по эффективности программе на языке Си.</p>
<p>Существует четыре общих и независимых от языка метода ускорения работы алгоритма:</p>
<ul>
<li><em>Кеширование</em> результатов вычислений для повторного использования.</li>
<li><em>Компиляция</em>, чтобы во время выполнения выполнялось меньше работы.</li>
<li><em>Отсрочка/delaying</em> вычисления части результатов, которые могут никогда не понадобиться.</li>
<li><em>Индексирование</em> структуры данных для более быстрого поиска.</li>
</ul>
<p>В этой главе по порядку рассматривается каждый из четырех методов Затем мы вернемся к важной проблеме <em>инструментария</em>. Глава завершается обучающим случаем программы упрощения. Описанные здесь методы позволяют ускорить выполнение этой программы в 130-раз.</p>
<p><a href="B9780080571157500108.xhtml">Глава 10</a> концентрируется на "уловках/tricks" для дальнейшего повышения эффективности.</p>
<h2>9.1 Кеширование результатов предыдущих вычислений: Memoization(запоминание)</h2>
<p>Начнем с простой математической функции, чтобы продемонстрировать преимущества методов кэширования. Позже мы продемонстрируем более сложные примеры.</p>
<p>Последовательность Фибоначи определяется как числа 1,1,2,3,5,8,... где каждое число - это сумма двух предыдущих чисел. Самая простая функция для вычисления n-го числа в этой последовательности выглядит следующим образом:</p>
<div class="fragment"><div class="line">(defun fib (n)</div></div><!-- fragment --> <pre class="fragment">`"Compute the nth number in the Fibonacci sequence."`
</pre><p><code>(if (&lt;= n 1) 1</code> </p><pre class="fragment">`(+ (fib (- n 1)) (fib (- n 2)))))`
</pre><p>Проблема этой функции в том, что она вычисляет одно и то же снова и снова. Вычисление (<code>fib 5</code>) означает вычисление (<code>fib 4</code>) и (<code>fib 3</code>), но (<code>fib 4</code>) также требует (<code>fib 3</code>), и они оба требуют (<code>fib 2</code>), и т.д. Есть способы переписать функцию, чтобы она делала меньше вычислений, но было бы не плохо написать функцию как есть, но чтобы она автоматически избегала избыточных вычислений? Удивительно, но есть способ сделать именно это. Идея состоит в том, чтобы использовать функцию <code>fib</code> для создания новой функции, которая запоминает ранее вычисленные результаты и использует их, а не пересчитывает заново. Этот процесс называется <em>memoization</em>(придание функции памяти). Функция <code>memo</code> это функция высшего порядка, которая принимает функцию в качестве входных данных и возвращает новую функцию, которая будет вычислять те же результаты, но не выполнять одно и тоже вычисление дважды.</p>
<div class="fragment"><div class="line">(defun memo (fn &amp;key (key #&#39;first) (test #&#39;eql) name)</div><div class="line">  &quot;Return a memo-function of fn.&quot;</div><div class="line">  (let ((table (make-hash-table :test test)))</div><div class="line">    (setf (get name &#39;memo) table)</div><div class="line">    #&#39;(lambda (&amp;rest args)</div><div class="line">        (let ((k (funcall key args)))</div><div class="line">          (multiple-value-bind (val found-p)</div><div class="line">              (gethash k table)</div><div class="line">            (if found-p val</div><div class="line">                (setf (gethash k table) (apply fn args))))))))</div></div><!-- fragment --><p>Выражение (<code>memo #'fib</code>) создает функцию, которая запоминает свои результаты между вызовами, так что, например, если мы дважды применим её к 3, первый вызов выполнит вычисление (<code>fib 3</code>), но второй будет просто будет искать результат в хеш-таблице. После трассировки <code>fib</code>, это будет выглядеть так:</p>
<div class="fragment"><div class="line">&gt; (setf memo-fib (memo #&#39;fib)) =&gt; #  &lt;  CLOSURE -  67300731  &gt;</div><div class="line">&gt; (funcall memo-fib 3) =&gt;</div><div class="line">(1 ENTER FIB: 3)</div></div><!-- fragment --> <pre class="fragment">`(2 ENTER FIB: 2)`

      `(3 ENTER FIB: 1)`

      `(3 EXIT FIB: 1)`

      `(3 ENTER FIB: 0)`

      `(3 EXIT FIB: 1)`

`(2 EXIT FIB: 2)`

`(2 ENTER FIB: 1)`

`(2 EXIT FIB: 1)`
</pre><div class="fragment"><div class="line">(1 EXIT FIB: 3)</div><div class="line">3</div><div class="line">&gt; (funcall memo-fib 3) =  &gt;  3</div></div><!-- fragment --><p>Во второй раз, когда мы вызываем <code>memo-fib</code> с аргументом 3, ответ просто извлекается, а не вычислялется заново. Но проблема в том, что во время вычисления (<code>fib 3</code>), мы по прежнему вычисляем (<code>fib 2</code>) несколько раз. Было бы лучше, если бы даже внутренние рекурсивные вызовы были запомнены(memoized), но это были вызовы неизменённого fib,а не <code>memo-fib</code>. Эту проблему легко решить с помощью функции <code>memoize</code>:</p>
<div class="fragment"><div class="line">(defun memoize (fn-name &amp;key (key #&#39;first) (test #&#39;eql))</div><div class="line">  &quot;Replace fn-name&#39;s global definition with a memoized version.&quot;</div><div class="line">  (clear-memoize fn-name)</div></div><!-- fragment --><p>При передаче символа, который именует функцию, <code>memoize</code> изменяет глобальное определение функции на memo-функцию. Таким образом, любые рекурсивные вызовы сначала будут обращаться к memo-функции, а не к исходной функции. Это как раз то, что мы хотим. Далее мы сопоставим запоминающие(memoized) и не запоминающие(unmemoized) версии <code>fib</code>. Первый вызов (<code>fib 5</code>) с трассировкой <code>fib</code>:</p>
<div class="fragment"><div class="line">&gt; (fib 5) =&gt;</div><div class="line">(1 ENTER FIB: 5)</div></div><!-- fragment --> <pre class="fragment">  `(2 ENTER FIB: 4)`

        `(3 ENTER FIB: 3)`

              `(4 ENTER FIB: 2)`

                      `(5 ENTER FIB: 1)`

                      `(5 EXIT FIB: 1)`

                      `(5 ENTER FIB: 0)`

                      `(5 EXIT FIB: 1)`

              `(4 EXIT FIB: 2)`

              `(4 ENTER FIB: 1)`

              `(4 EXIT FIB: 1)`

        `(3 EXIT FIB: 3)`

        `(3 ENTER FIB: 2)`

              `(4 ENTER FIB: 1)`

              `(4 EXIT FIB: 1)`

              `(4 ENTER FIB: 0)`

              `(4 EXIT FIB: 1)`

        `(3 EXIT FIB: 2)`

  `(2 EXIT FIB: 5)`

  `(2 ENTER FIB: 3)`

        `(3 ENTER FIB: 2)`

              `(4 ENTER FIB: 1)`

              `(4 EXIT FIB: 1)`

              `(4 ENTER FIB: 0)`

              `(4 EXIT FIB: 1)`

        `(3 EXIT FIB: 2)`

        `(3 ENTER FIB: 1)`

        `(3 EXIT FIB: 1)`

  `(2 EXIT FIB: 3)`
</pre><div class="fragment"><div class="line">(1 EXIT FIB: 8)</div><div class="line">8</div></div><!-- fragment --><p>Мы видим, что (<code>fib 5</code>) и (<code>fib 4</code>) вычисляются один раз, но (<code>fib 3</code>) вычисляется дважды, (<code>fib 2</code>) трижды, а (<code>fib 1</code>) пять раз. Ниже мы вызываем (<code>memoize 'fib</code>) и повторяем вычисление. На этот раз, каждое вычисление выполняется только один раз. Кроме того, когда вычисление (<code>fib 5</code>) повторяется, ответ возвращается немедленно без промежуточных вычислений, и при следующем вызове (<code>fib 6</code>) может быть использовано значение (<code>fib 5</code>).</p>
<div class="fragment"><div class="line">&gt; (memoize &#39;fib) =&gt; #  &lt;  CLOSURE 76626607  &gt;</div><div class="line">&gt; (fib 5) =&gt;</div><div class="line">(1 ENTER FIB: 5)</div></div><!-- fragment --> <pre class="fragment">`(2 ENTER FIB: 4)`

      `(3 ENTER FIB: 3)`

            `(4 ENTER FIB: 2)`

                  `(5 ENTER FIB: 1)`

                  `(5 EXIT FIB: 1)`

                  `(5 ENTER FIB: 0)`

                  `(5 EXIT FIB: 1)`

            `(4 EXIT FIB: 2)`

      `(3 EXIT FIB: 3)`

`(2 EXIT FIB: 5)`
</pre><div class="fragment"><div class="line">(1 EXIT FIB: 8)</div><div class="line">8</div><div class="line">&gt; (fib 5)   =&gt;  8</div><div class="line">&gt; (fib 6) =&gt;</div><div class="line">(1 ENTER FIB: 6)</div><div class="line">(1 EXIT FIB: 13)</div><div class="line">13</div></div><!-- fragment --><p>Понимание того, почему это работает, требует четкого понимания различий между функциями и именами функций. Исходная форма (<code>defun fib ...</code>) выполняет две задачи: создает функцию и и сохраняет ее как значение (<code>symbol-function</code>) символа-функции <code>fib</code>. Внутри этой функции есть две ссылки на <code>fib</code>; они компилируются (или интерпретируются) как инструкции для получения <code>symbol-function</code> для <code>fib</code> и применения её к аргументу.</p>
<p><code>memoize</code> извлекает исходную функцию и преобразует её с помощью <code>memo</code> в функцию, которая при вызове, сначала просматривает таблицу, чтобы узнать, известен ли уже ответ. Если нет, вызывается исходная функция, и в таблицу помещается новое значение. Хитрость в том, что <code>memoize</code> берет эту новую функцию и делает её значением символа-фукнции(<code>symbol-function</code>) имени функции. Это означает, что все ссылки в исходной функции теперь перейдут на новую функцию, и таблица будет правильно проверяться при каждом рекурсивном вызове. Еще одна сложность для <code>memo:</code> функция <code>gethash</code> возвращает два значения, найденное в таблице и индикатор того, присутствует ключ или нет. Мы используем <code>multiple-value-bind</code> для захвата обоих значений, чтобы мы могли отличить случай, когда <code>nil</code> является значением функции сохраненным в таблице, от случая, когда сохраненного значения нет.</p>
<p>Если вы вносите изменения в функцию преобразованную memoize, вам необходимо перекомпилировать исходное определение, а затем повторить вызов memoize. При разработке вашей программы, вместо того, чтобы сказать <code>(memoize 'f)</code>, было бы проще заключить соответствующее определение в форму <code>memoize</code> следующим образом:</p>
<div class="fragment"><div class="line">(memoize</div></div><!-- fragment --> <pre class="fragment">`(defun f (x) ...)`

`)`
</pre><p>Или определить макрос, который объединяет <code>defun</code> и <code>memoize</code>:</p>
<div class="fragment"><div class="line">(defmacro defun-memo (fn args &amp;body body)</div><div class="line">  &quot;Define a memoized function.&quot;</div><div class="line">  `(memoize (defun ,fn ,args . ,body)))</div><div class="line"></div><div class="line">(defun-memo f (x) ...)</div></div><!-- fragment --><p>Оба этих подхода основаны на том факте, что <code>defun</code> возвращает имя определенной функции.</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th></tr>
<tr>
<td><em>n</em> </td><td><code>(fib *n*)</code> </td><td>unmemoized </td><td>memoized </td><td>memoized up to </td></tr>
<tr>
<td>25 </td><td>121393 </td><td>1.1 </td><td>.010 </td><td>0 </td></tr>
<tr>
<td>26 </td><td>196418 </td><td>1.8 </td><td>.001 </td><td>25 </td></tr>
<tr>
<td>27 </td><td>317811 </td><td>2.9 </td><td>.001 </td><td>26 </td></tr>
<tr>
<td>28 </td><td>514229 </td><td>4.7 </td><td>.001 </td><td>27 </td></tr>
<tr>
<td>29 </td><td>832040 </td><td>8.2 </td><td>.001 </td><td>28 </td></tr>
<tr>
<td>30 </td><td>1346269 </td><td>12.4 </td><td>.001 </td><td>29 </td></tr>
<tr>
<td>31 </td><td>2178309 </td><td>20.1 </td><td>.001 </td><td>30 </td></tr>
<tr>
<td>32 </td><td>3524578 </td><td>32.4 </td><td>.001 </td><td>31 </td></tr>
<tr>
<td>33 </td><td>5702887 </td><td>52.5 </td><td>.001 </td><td>32 </td></tr>
<tr>
<td>34 </td><td>9227465 </td><td>81.5 </td><td>.001 </td><td>33 </td></tr>
<tr>
<td>50 </td><td>2.0e10 </td><td>- </td><td>.014 </td><td>34 </td></tr>
<tr>
<td>100 </td><td>5.7e20 </td><td>- </td><td>.031 </td><td>50 </td></tr>
<tr>
<td>200 </td><td>4.5e41 </td><td>- </td><td>.096 </td><td>100 </td></tr>
<tr>
<td>500 </td><td>2.2e104 </td><td>- </td><td>.270 </td><td>200 </td></tr>
<tr>
<td>1000 </td><td>7.0e208 </td><td>- </td><td>.596 </td><td>500 </td></tr>
<tr>
<td>1000 </td><td>7.0e208 </td><td>- </td><td>.001 </td><td>1000 </td></tr>
<tr>
<td>1000 </td><td>7.0e208 </td><td>- </td><td>.876 </td><td>0 </td></tr>
</table>
<p>Теперь мы показываем таблицу, в которой указаны значения <code>(fib *n*)</code> для определенного <em>n</em>, и время в секундах для вычисления значения, до и после выполнения <code>(memoize 'fib)</code>. Для дальнейших значений <em>n</em>, показаны приближенные значения в таблице, хотя на самом деле <code>fib</code> возвращает точное целое число. Для незапоминающей(unmemoized) версии, я остановился на <em>n</em> = 34, потому что время выполнения становилось слишком длинным. Для замоминающей(memoized) версии, даже <em>n</em> = 1000 заняло меньше секунды.</p>
<p>Обратите внимание, что есть три записи для (<code>fib 1000</code>). Первая запись представляет собой инкрементное вычисление, когда таблица содержит запомненные(memoized) значения до 500, вторая запись показывает время поиска в таблице, когда (<code>fib 1000</code>) уже вычислено, а третья - время для полного вычисления, начиная с пустой таблицы.</p>
<p>Следует отметить, что есть два общих подхода к обсуждению эффективности алгоритма. Один из них - сопоставить алгоритм с репрезентативными входными данными, как мы сделали в этой таблице. Другой - анализировать <em>асимптотическую сложность</em> алгоритма. Для задачи <code>fib</code> асимптотический анализ рассматривает, сколько времени требуется для вычисления <code>(fib *n*)</code> когда <em>n</em> приближается к бесконечности. Обозначение <em>O</em>(<em>f</em>(<em>n</em>)) используется для описания сложности. Например, запоминающая версия <code>fib</code> является алгоритмом <em>O</em>(<em>n</em>), потому что время вычислений ограничено некоторым постоянным временем <em>n</em>, для любого значения <em>n</em>. Незапоминающая версия, оно оказывается, is <em>O</em>(1.7*n*), что означает, что вычисление <code>fib</code> для n + 1 может занимать в 1.7 раза больше времени, чем вычисление <code>fib</code> для <em>n</em>. Проще говоря, запоминающая версия имеет <em>линейную</em> сложность, в то время как не запоминающая версия имеет <em>экспотенциальную</em> сложность. <a href="B9780080571157500091.xhtml#p4655">В упражнении 9.4</a> (<a href="B9780080571157500091.xhtml#p308">Page 308</a>) объясняется откуда взялось 1.7, и дается более жесткая оценка сложности.</p>
<p>Представленная выше версия <code>memo</code> негибка по нескольким причинам. Во-первых, она работает только с функцией с одним аргументом. Во-вторых, она возвращает сохраненное значение только для аргументов, которые являются <code>eql</code>, потому что именно так работают хеш-таблицы по умолчанию. Для некоторых приложений мы хотим получить сохраненное значение для аргументов, которые являются <code>equal</code>. В-третьих, нет возможности удалять записи в хеш-таблице. Во многих приложениях бывают случаи, когда было бы хорошо очистить хеш-таблицу либо потому, что она стала слишком большой, либо потому, что мы закончили некий набор связаных проблем и переходим к новой проблеме.</p>
<p>Приведенные ниже версии <code>memo</code> и <code>memoize</code> решают эти три проблемы. Они совместимы с предыдущей версией, но добавляют три новых ключевых слова для расширений. Ключевое слово <code>name</code> сохраняет хеш-таблицу в списке свойств этого имени, поэтому к ней можно получить доступ с помощью <code>clear-memoize</code>. Ключевое слово <code>test</code> сообщает какую хэш-таблицу создавать: <code>eq, eql или equal</code>. Наконец, ключевое слово <code>key</code> сообщает, какие аргументы функции нужно индексировать. По умолчанию, используется первый аргумент (для совместимости с предыдущей версией), но можно использовать любую комбинацию аргументов. Если вы хотите использовать все аргументы, укажите в качестве ключа <code>identity</code>. Обратите внимание: если key(ключ) представляет собой список аргументов, вам придется использовать хэш-таблицы сравнивающие через <code>equal</code>.</p>
<div class="fragment"><div class="line">(defun memo (fn &amp;key (key #&#39;first) (test #&#39;eql) name)</div><div class="line">  &quot;Return a memo-function of fn.&quot;</div><div class="line">  (let ((table (make-hash-table :test test)))</div><div class="line">    (setf (get name &#39;memo) table)</div><div class="line">    #&#39;(lambda (&amp;rest args)</div><div class="line">        (let ((k (funcall key args)))</div><div class="line">          (multiple-value-bind (val found-p)</div><div class="line">              (gethash k table)</div><div class="line">            (if found-p val</div><div class="line">                (setf (gethash k table) (apply fn args))))))))</div></div><!-- fragment --><div class="fragment"><div class="line">(defun memoize (fn-name &amp;key (key #&#39;first) (test #&#39;eql))</div><div class="line">  &quot;Replace fn-name&#39;s global definition with a memoized version.&quot;</div><div class="line">  (clear-memoize fn-name)</div><div class="line">  (setf (symbol-function fn-name)</div><div class="line">        (memo (symbol-function fn-name)</div><div class="line">              :name fn-name :key key :test test)))</div></div><!-- fragment --><div class="fragment"><div class="line">(defun clear-memoize (fn-name)</div><div class="line">  &quot;Clear the hash table from a memo function.&quot;</div><div class="line">  (let ((table (get fn-name &#39;memo)))</div><div class="line">    (when table (clrhash table))))</div></div><!-- fragment --><h2>9.2 Компиляция одного языка в другой</h2>
<p>В <a href="B9780080571157500029.xhtml">Главе 2</a> мы определили новый язык - язык граматических правил,- который обрабатывался интерпретатором, разработанным специально для этого языка. <em>Интепретатор/interpreter</em> это программа, котора смотрит на некоторую структуру данных, представляющую "программу" или последовательность правил определенного типа, и интерпретирует или вычисляет(оценивает) эти правила. В этом отличие от <em>компилятора/compiler</em>, который переводит некоторый набор правил на одном языке в программу на другом языке.</p>
<p>Функция <code>generate</code> была интерпретатором для языка "language" определенного набором граматических правил. Интерпретация этих правил проста, но процесс несколько неэффективен, так как generate должен постоянно искать в граматике <code>*grammar*</code> подходящее правило, затем подсчитывать длину правой части и так далее.</p>
<p>Компилятор для этого языка правил принимает каждое правило и переводит его в функцию. Эти функции могут затем вызывать друг друга без необходимости поиска в граматике <code>*grammar*</code>. Мы реализуем этот подход с помощью функции <code>compile-rule</code>. Она использует вспомогательные функции <code>one-of</code> и <code>rule-lhs</code> и <code>rule-rhs</code> со <a href="B9780080571157500029.xhtml#p40">Страницы 40</a>, повторенные здесь:</p>
<div class="fragment"><div class="line">(defun rule-lhs (rule)</div></div><!-- fragment --><p><code>"The left-hand side of a rule."</code></p>
<p><code>(first rule))</code></p>
<div class="fragment"><div class="line">(defun rule-rhs (rule)</div></div><!-- fragment --><p><code>"The right-hand side of a rule."</code></p>
<p><code>(rest (rest rule)))</code></p>
<div class="fragment"><div class="line">(defun one-of (set)</div></div><!-- fragment --><p><code>"Pick one element of set, and make a list of it."</code></p>
<p><code>(list (random-elt set)))</code></p>
<div class="fragment"><div class="line">(defun random-elt (seq)</div><div class="line">  &quot;Pick a random element out of a sequence.&quot;</div><div class="line">  (elt seq (random (length seq))))</div></div><!-- fragment --><p>Функция <code>compile-rule</code> превращает правило в определение функции, создавая код на Лиспе, который реализует все действия, которые будут выполняться при интерпретации правила. Есть три случая. Если каждый элемент правой части является атомом, то правило является лексическим правилом, которое компилируется в вызов <code>one-of</code> для случайного выбора слова. Если есть только один элемент с правой стороны, то вызывается <code>build-code</code> для генерации кода для него. Обычно это будет вызов (append)добавления для создания списка. Наконец, если в правой части есть несколько элементов, каждый из них превращается в код с помощью <code>build-code</code>; присваиваются числовые значения(номера) с помощью <code>build-case</code>; а затем строится оператор <code>case</code> для выбора одного из случаев.</p>
<div class="fragment"><div class="line">(defun compile-rule (rule)</div></div><!-- fragment --><p><code>"Translate a grammar rule into a LISP function definition."</code></p>
<p><code>(let ((rhs (rule-rhs rule)))</code> </p><pre class="fragment">`'(defun ,(rule-lhs rule) ()`
</pre><div class="fragment"><div class="line">,(cond ((every #&#39;atom rhs) &#39;(one-of &#39;,rhs))</div></div><!-- fragment --> <pre class="fragment">          `((length  =l rhs) (build-code (first rhs)))`

          `(t '(case (random .(length rhs))`

              `,@(build-cases 0 rhs)))))))`
</pre><div class="fragment"><div class="line">(defun build-cases (number choices)</div></div><!-- fragment --><p><code>"Return a list of case-clauses"</code></p>
<p><code>(when choices</code> </p><pre class="fragment">`(cons (list number (build-code (first choices)))`

        `(build-cases (+ number 1) (rest choices)))))`
</pre><div class="fragment"><div class="line">(defun build-code (choice)</div></div><!-- fragment --><p><code>"Append together multiple constituents"</code></p>
<p><code>(cond ((null choice) nil)</code> </p><pre class="fragment">        `((atom choice) (list choice))`

        `((length=1 choice) choice)`

        `(t '(append ,@(mapcar #'build-code choice)))))`
</pre><div class="fragment"><div class="line">(defun length=1 (x)</div><div class="line">  &quot;Is x a list of length 1?&quot;</div><div class="line">  (and (consp x) (null (cdr x))))</div></div><!-- fragment --><p>Код Лиспа, созданный с помощью <code>compile-rule</code>(компиляции правил), должен быть скомпилирован или интерпретирован, чтобы сделать его доступным для системы Лисп. Мы можем сделать это с помощью одной из следующих форм. Обычно мы хотели бы вызвать <code>compile</code>, но во время отладки может быть проще этого не делать.</p>
<div class="fragment"><div class="line">(dolist (rule *grammar*) (eval (compile-rule rule)))</div><div class="line">(dolist (rule *grammar*) (compile (eval (compile-rule rule))))</div></div><!-- fragment --><p>Одним из частых способов использования компиляции является определение макроса, который расширяется в код, созданный компилятором. Таким образом, мы просто вводим вызовы макроса и не должны беспокоиться о том, чтобы убедиться, что все последние правила скомпилированы. Мы можем реализовать это следующим образом:</p>
<div class="fragment"><div class="line">(defmacro defrule (&amp;rest rule)</div></div><!-- fragment --> <pre class="fragment">`"Define a grammar rule"`

`(compile-rule rule))`
</pre><div class="fragment"><div class="line">(defrule Sentence -&gt; (NP VP))</div><div class="line">(defrule NP -&gt; (Art Noun))</div><div class="line">(defrule VP -&gt; (Verb NP))</div><div class="line">(defrule Art -&gt; the a)</div><div class="line">(defrule Noun -&gt; man bail woman table)</div><div class="line">(defrule Verb -&gt; hit took saw liked)</div></div><!-- fragment --><p>Фактически, выбор использования одного большого списка правил (например, <code>*grammar*</code>) по сравнению с использованием отдельных макросов для определения правил не зависит от выбора: компилятор или интерпретатор. Мы могли бы так же легко определить defrule, просто поместив правило в граматику - <code>*grammar*</code>. Такие макросы, как defrule, полезны, когда вы хотите определить правила в разных местах, возможно, в нескольких отдельных файлах. Метод <code>defparameter</code> подходит, когда все правила могут быть определены в одном месте.</p>
<p>Мы можем увидеть код Лисп, сгенерированный <code>compile-rule</code> двумя способами: передав ему правило напрямую:</p>
<div class="fragment"><div class="line">&gt; (compile-rule &#39;(Sentence -&gt; (NP VP)))</div><div class="line">(DEFUN SENTENCE ()</div></div><!-- fragment --> <pre class="fragment">  `(APPEND (NP) (VP)))`
</pre><div class="fragment"><div class="line">&gt; (compile-rule &#39;(Noun -&gt; man bail woman table))</div><div class="line">(DEFUN NOUN ()</div></div><!-- fragment --> <pre class="fragment">  `(ONE-OF '(MAN BALL WOMAN TABLE)))`
</pre><p>или макрорасширением выражения defrule. Компилятор был разработан для создания того же кода, который мы писали при первом подходе к проблеме генерации (см. <a href="B9780080571157500029.xhtml#p35">Страница 35</a>).</p>
<div class="fragment"><div class="line">&gt; (macroexpand &#39;(defrule Adj* -&gt; () Adj (Adj Adj*)))</div><div class="line">(DEFUN ADJ* ()</div></div><!-- fragment --><p><code>(CASE (RANDOM 3)</code> </p><pre class="fragment">`(0 NIL)`

`(1 (ADJ))`

`(2 (APPEND (ADJ) (ADJ*)))))`
</pre><p>Интерпретаторы обычно легче писать, чем компиляторы, хотя в этом случае даже компилятор не будет слишком сложным. Интерпретаторы также по своей сути более гибкие, чем компиляторы, потому что они откладывают принятие решений до последнего возможного момента. Например, наш компилятор считает правую часть правила списком слов, даже если каждый элемент является атомом. Во всех остальных случаях элементы рассматриваются как нетерминальные. Это могло вызвать проблемы, если бы мы расширили определение <code>Noun</code>(Существительного), включив в него составное существительное(noun) "chow chow":</p>
<div class="fragment"><div class="line">(defrule Noun -&gt; man ball woman table (chow chow))</div></div><!-- fragment --><p>Правило расширилось бы до следующего кода:</p>
<div class="fragment"><div class="line">(DEFUN NOUN ()</div><div class="line">  (CASE (RANDOM 5)</div></div><!-- fragment --> <pre class="fragment">  `(0 (MAN))`

  `(1 (BALL))`

  `(2 (WOMAN))`

  `(3 (TABLE))`

  `(4 (APPEND (CHOW) (CHOW)))))`
</pre><p>Проблема в том, что <code>man</code>, <code>ball</code> и все остальные неожиданно стали рассматриваться как функции, а не как буквальные слова. Таким образом, мы получим ошибку времени выполнения, сообщающую нам о неопределенных функциях. Эквивалентное правило не вызовет проблем для интерпретатора, который ждет, пока ему действительно не понадобиться сгенерировать символ, чтобы решить, является ли он словом или нетерминальным символом. Таким образом, семантика правил различна для интерпретатора и компилятора, и мы, разработчики программ, должны быть очень осторожны с тем, как мы указываем фактическое значение правила. Фактически, это, вероятно, было ошибкой в ​​версии интерпретатора, поскольку он эффективно запрещает таким словам, как "noun" и "sentence" встречаться в виде слов, если они также являются названиями категорий. Одно из возможных решений конфликта - сказать, что элемент правой части представляет слово, если это атом, и список категорий, если это список. Если бы мы действительно остановились на этом соглашении, то мы могли бы модифицировать и интерпретатор, и компилятор, чтобы соответствовать этому соглашению. Другая возможность - представить слова в виде строк, а категории в виде символов.</p>
<p>Обратной стороной потери гибкости во время выполнения является получение диагностики во время компиляции. Например, оказывается, что в системе Common Lisp, которую я использую сейчас, я получаю несколько полезных сообщений об ошибках, когда пытаюсь скомпилировать ошибочную версию <code>Noun</code>:</p>
<div class="fragment"><div class="line">&gt; (defrule Noun -&gt; man bail woman table (chow chow))</div><div class="line">The following functions were referenced but don&#39;t seem defined:</div></div><!-- fragment --><p><code>CHOW referenced by NOUN</code></p>
<p><code>TABLE referenced by NOUN</code></p>
<p><code>WOMAN referenced by NOUN</code></p>
<p><code>BALL referenced by NOUN</code></p>
<p><code>MAN referenced by NOUN</code></p>
<div class="fragment"><div class="line">NOUN</div></div><!-- fragment --><p>Еще одна проблема с описанной здесь схемой компиляции - это возможность <em>конфликтов имен</em>. В схеме интерпретации использовались только имена функции generate и переменной <code>*grammar*</code>. При компиляции каждая левая часть правила становится именем функции. Автор грамматики должен убедиться, что он или она не использует имя существующей функции Лиспа, и, следовательно, не переопределяет ее. Хуже того, если одновременно разрабатывается более одной грамматики, у них не должно быть общих функций. Если это произойдет, пользователю придется выполнять перекомпиляцию при каждом переключении с одной грамматики на другую. Это может затруднить сравнение грамматик. Лучшее решение этой проблемы - использовать идею <em>пакетов</em> в Common Lisp, но для небольших упражнений конфликта имен можно избежать достаточно легко, поэтому мы не будем исследовать пакеты до <a href="B9780080571157500248.xhtml#s0010">раздела 24.1</a>.</p>
<p>Главное преимущество компилятора - это скорость выполнения, когда это имеет значение. Для идентичных грамматик, выполняемых в одной конкретной реализации Common Lisp на одной машине, наш интерпретатор генерирует около 75 предложений в секунду, в то время как компилируемый подход дает около 200. Таким образом, это более чем в два раза быстрее, но разница незначительна, если нам не нужно генерировать многие тысячи предложений. В <a href="# s0035">разделе 9.6</a> мы увидим другой компилятор с еще большим ускорением.</p>
<p>Необходимость оптимизации кода, создаваемого вашими макросами и компиляторами, в конечном итоге зависит от качества базового Лисп компилятора. Например, рассмотрим следующий код:</p>
<div class="fragment"><div class="line">(defun f1 (n l)</div><div class="line">      (let ((l1 (first l))</div><div class="line">                  (l2 (second l)))</div></div><!-- fragment --> <pre class="fragment">            `(expt (* 1 (+ n 0))`

          `(- 4 (length (list l1 l2))))))`
</pre><div class="fragment"><div class="line">F1</div><div class="line">&gt; (defun f2 (n l) (* n n)) =&gt;F2</div><div class="line">&gt; (disassemble &#39;fl)</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>6 PUSH</code> </td><td><code>ARGIO ; N</code> </td></tr>
<tr>
<td><code>7 MOVEM</code> </td><td><code>PDL-PUSH</code> </td></tr>
<tr>
<td><code>8 *</code> </td><td><code>PDL-POP</code> </td></tr>
<tr>
<td><code>9 RETURN</code> </td><td><code>PDL-POP</code> </td></tr>
</table>
<div class="fragment"><div class="line">Fl</div><div class="line">&gt; (disassemble &#39;f2)</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>6 PUSH</code> </td><td><code>ARGO ; N</code> </td></tr>
<tr>
<td><code>7 MOVEM</code> </td><td><code>PDL-PUSH</code> </td></tr>
<tr>
<td><code>8 *</code> </td><td><code>PDL-POP</code> </td></tr>
<tr>
<td><code>9 RETURN</code> </td><td><code>PDL-POP</code> </td></tr>
</table>
<div class="fragment"><div class="line">F2</div></div><!-- fragment --><p>Этот Лисп компилятор генерирует точно такой же код для <code>f1</code> и <code>f2</code>. Обе функции возводят аргумент <code>n</code> в квадрат, и четыре машинные инструкции говорят: "Возьмите 0-й аргумент, сделайте его копию, умножьте эти два числа и верните результат". Понятно, что компилятор имеет некоторые знания об основных функциях Лиспа. В случае с <code>f1</code> он был достаточно умен, чтобы избавиться от локальных переменных <code>l1</code> и <code>l2</code> (и их инициализации), а также от вызовов <code>first, second, length</code> и <code>list</code> и большей части арифметики. Компилятор может сделать это, потому что он знает о функциях <code>length</code> и <code>list</code> и арифметических функциях. Некоторые из этих знаний могут быть в форме правил упрощения.</p>
<p>Как пользователю этого компилятора, мне нет необходимости писать умные макросы или компиляторы, которые генерируют упрощенный код, как показано в <code>f2</code>; Я могу слепо сгенерировать код с возможной неэффективностью, как в <code>f1</code>, и предполагать, что Лисп компилятор скроет мою лень. С другим компилятором, который не знает о таких оптимизациях, мне пришлось бы быть более осторожным с генерируемым мной кодом.</p>
<h2>9.3 Отложенные Вычисления</h2>
<p>Вернувшись на <a href="B9780080571157500029.xhtml#p45">Страницу 45</a>, мы увидим программу для генерации всех строк, полученных из грамматики. Одним из недостатков этой программы было то, что некоторые грамматики производили бесконечное количество строк, поэтому программа не завершалась при использовании этих грамматик.</p>
<p>Оказывается, мы часто хотим иметь дело с бесконечными множествами. Конечно, мы не можем перечислить все элементы бесконечного множества, но мы должны иметь возможность представлять множество и выбирать элементы по одному. Другими словами, мы хотим иметь возможность указывать, как создается множество(набор) (или другой объект), но задерживать фактическое построение, возможно, делая это постепенно с течением времени. Это звучит как работа для замыканий: мы можем указать конструктор множества как функцию, а затем вызвать функцию через некоторое время. Мы реализуем этот подход с синтаксисом, используемым в Scheme - макрос <code>delay</code> создает замыкание, которое будет вычислено позже, а функция <code>force</code> вызывает эту функцию и кэширует значение. Для этого мы используем структуры типа <code>delay</code>. В структуре задержки(delay) есть два поля: value(значение) и function(функция). Первоначально поле value не определено, а поле function(функции) содержит замыкание, которое будет вычислять значение. Вначале delay применяется в force, где вызывается function, и ее результат сохраняется в поле значения. Затем поле function устанавливается в nil, чтобы указать, что нет необходимости вызывать функцию снова. Функция <code>force</code> проверяет, нужно ли вызывать функцию, и возвращает значение. Если <code>force</code> передается аргумент, который не является delay, она просто возвращает аргумент.</p>
<div class="fragment"><div class="line">(defstruct delay value (computed? nil))</div><div class="line"></div><div class="line">(defmacro delay (&amp;rest body)</div><div class="line">  &quot;A computation that can be executed later by FORCE.&quot;</div><div class="line">  `(make-delay :value #&#39;(lambda () . ,body)))</div></div><!-- fragment --><div class="fragment"><div class="line">(defun force (x)</div></div><!-- fragment --><p><code>"Find the value of x, by computing if it is a delay."</code></p>
<p><code>(if (not (delay-p x))</code> </p><pre class="fragment">      `x`

      `(progn`

      `(when (delay-function x)`

            `(setf (delay-value x)`

                    `(funcall (delay-function x)))`

            `(setf (delay-function x) nil))`

      `(delay-value x))))`
</pre> <div class="fragment"><div class="line">Вот пример использования `delay`.</div><div class="line">Список `x` строится с использованием комбинации нормального вычисления и отложенного вычисления.</div><div class="line">Таким образом, `1` печатается при создании `x`, а `2` - нет:</div><div class="line"></div><div class="line">```lisp</div><div class="line">(setf x (list (print 1) (delay (print 2)))) =&gt;</div><div class="line">1</div><div class="line">(1 #S(DELAY .-FUNCTION (LAMBDA () (PRINT 2))))</div></div><!-- fragment --><p>Второй элемент вычисляется (и печатается), когда он вызывается force. Но затем повторение force просто извлекает кешированное значение, а не вызывает функцию снова:</p>
<div class="fragment"><div class="line">&gt; (force (second x)) =&gt;</div><div class="line">2</div><div class="line">2</div><div class="line">&gt; x =&gt; (1 #S(DELAY : VALUE 2))</div><div class="line">&gt; (force (second x)) =&gt; 2</div></div><!-- fragment --><p>Теперь посмотрим, как можно использовать delay(задержки) для построения бесконечных множеств. Бесконечное множество будет считаться частным случаем того, что мы будем называть <em>pipe</em>: список с вычисленным компонентом <code>first</code> и компонентом <code>rest</code>, который является либо обычным списком, либо отложенным(delayed) значением. Каналы(pipes) также называются отложенными списками, генерированными списками и (чаще всего) потоками. Мы будем использовать термин <em>pipe</em>, потому что <em>stream</em> уже имеет значение в Common Lisp. В книге <em>Программирование искусственного интеллекта</em> (<a href="B9780080571157500285.xhtml#bb0180">Чарняк и др. 1987</a>) также называет эти структуры pipes, резервируя streams(потоки) для отложенных структур, которые не кэшируют вычисленные результаты.</p>
<p>Чтобы отличать pipes(каналы) от списков, мы будем использовать функции доступа(аксессоры) <code>head</code> и <code>tail</code> вместо <code>first</code> и <code>rest</code>. Мы также будем использовать <code>empty-pipe</code> вместо <code>nil</code>, <code>make-pipe</code> вместо <code>cons</code> и <code>pipe-elt</code> вместо <code>elt</code>. Обратите внимание, что <code>make-pipe</code> - это макрос, который задерживает вычисление хвоста(tail).</p>
<div class="fragment"><div class="line">(defmacro make-pipe (head tail)</div></div><!-- fragment --><p><code>"Create a pipe by evaluating head and delaying tail."</code></p>
<p>`'(cons ,head (delay ,tail)))`</p>
<div class="fragment"><div class="line">(defconstant empty-pipe nil)</div><div class="line">(defun head (pipe) (first pipe))</div><div class="line">(defun tail (pipe)(force (rest pipe)))</div><div class="line">(defun pipe-elt (pipe i)</div></div><!-- fragment --><p><code>"The i-th element of a pipe, 0-based"</code></p>
<p><code>(if (= i 0)</code> </p><pre class="fragment">`(head pipe)`

`(pipe-elt (tail pipe) (- i 1))))`
</pre><p>Вот функция, которую можно использовать для создания большой или бесконечной последовательности целых чисел с отложенным вычислением:</p>
<div class="fragment"><div class="line">(defun integers (&amp;optional (start 0) end)</div></div><!-- fragment --><p><code>"A pipe of integers from START to END.</code></p>
<p><code>If END is nil, this is an infinite pipe."</code></p>
<p><code>(if (or (null end) (&lt;= start end))</code> </p><pre class="fragment">`(make-pipe start (integers (+ start 1) end))`

`nil))`
</pre><p>А вот и пример её использования. pipe <code>c</code> представляет числа от 0 до бесконечности. При его создании вычисляется только нулевой элемент, 0. Вычисление других элементов задерживается(delayed).</p>
<div class="fragment"><div class="line">&gt; (setf c (integers 0)) =&gt; (0 . #S(DELAY :FUNCTION #  &lt;  CLOSURE -  77435477  &gt;))</div><div class="line">&gt;  (pipe-elt c 0) =&gt;    0</div></div><!-- fragment --><p>Вызов <code>pipe-elt</code> для просмотра третьего элемента приводит к вычислению элементов с первого по третий. Числа от 0 до 3 кэшируются в правильных позициях, а другие элементы остаются невычисленными. Другой вызов <code>pipe-elt</code> с большим индексом заставит их вычислить отложенную функцию.</p>
<div class="fragment"><div class="line">&gt; (pipe-elt c 3) =&gt; 3</div><div class="line">c =&gt;</div><div class="line">(0 . #S(DELAY</div></div><!-- fragment --> <pre class="fragment">            `: VALUE`

            `(1 . #S(DELAY`

                                `: VALUE`

                                `(2 . #S(DELAY`

                                                `: VALUE`

                                                `(3 . #S(DELAY`

                                                                  `:FUNCTION`

                                                                  `#  &lt;  CLOSURE -  77432724  &gt;))))))))`
</pre><p>Хотя это, кажется, работает нормально, но придется заплатить высокую цену. Каждое отложенное значение должно храниться в двухэлементной структуре, где одним из элементов является замыкание. Таким образом, часть памяти теряется. Так же некоторое время теряется, так как <code>tail</code> или <code>pipe-elt</code> должны проходить по структуре.</p>
<p>Альтернативное представление для pipe - это пары (<em>value . closure</em>), где значения замыкания сохраняются в фактических cons-ячейках по мере их вычисления. Раньше нам требовались структуры типа delay, чтобы отличать отложенный(задержанный) от неотложенного объекта, но в pipe, как мы знаем, rest может быть только одним из трех: nil, список или отложенное значение. Таким образом, мы можем использовать замыкания напрямую вместо использования структур <code>delay</code>, если у нас есть способ отличить замыкания от списков. Скомпилированные замыкания - это атомы, поэтому их всегда можно отличить от списков. Но иногда замыкания реализуются в виде списков, начинающихся с <code>lambda</code> или какого-либо другого символа, зависящего от реализации. <a href="#fn0015">2</a> Встроенная функция <code>functionp</code> определена как истинная для таких списков, а также для всех символов и всех объектов, возвращаемых <code>compile</code>. Но использование <code>functionp</code> означает, что у нас не может быть pipe, который включает в себя символ <code>lambda</code> как элемент, потому что его можно спутать с замыканием:</p>
<div class="fragment"><div class="line">&gt; (functionp (last &#39;(theta iota kappa lambda))) =&gt; T</div></div><!-- fragment --><p>Если мы будем последовательно использовать скомпилированные функции, то мы сможем устранить проблему с тестированием используя встроенный предикат <code>compiled-function-p</code>. Следующие определения не делают этого предположения:</p>
<div class="fragment"><div class="line">(defmacro make-pipe (head tail)</div></div><!-- fragment --><p><code>"Create a pipe by evaluating head and delaying tail."</code></p>
<p>`'(cons ,head #'(lambda () ,tail)))`</p>
<div class="fragment"><div class="line">(defun tail (pipe)</div></div><!-- fragment --><p><code>"Return tail of pipe or list, and destructively update</code></p>
<p><code>the tail if it is a function."</code></p>
<p><code>(if (functionp (rest pipe))</code> </p><pre class="fragment">`(setf (rest pipe) (funcall (rest pipe)))`

`(rest pipe)))`
</pre><p>Все остальное остается прежним. Если мы перекомпилируем <code>integers</code> (потому что она использует макрос <code>make-pipe</code>), мы увидим следующее поведение. Во-первых, создание бесконечного pipe <code>c</code> аналогично:</p>
<div class="fragment"><div class="line">&gt; (setf c (integers 0)) =&gt; (0 . #  &lt;  CLOSURE 77350123  &gt;)</div><div class="line">&gt; (pipe-elt c 0) =&gt; 0</div></div><!-- fragment --><p>Доступ к принудительному вычислению элемента pipe для всех промежуточных элементов, и, как и прежде, оставляет без вычисления последующие элементы:</p>
<div class="fragment"><div class="line">&gt; (pipe-elt c 5) =&gt; 5</div><div class="line">&gt; c =&gt; (0 1 2 3 4 5 . #  &lt;  CLOSURE 77351636  &gt;)</div></div><!-- fragment --><p>Pipes также могут использоваться для конечных списков. Здесь мы видим pipe длиной 11:</p>
<div class="fragment"><div class="line">&gt; (setf i (integers 0 10)) =&gt; (0 . #  &lt;  CLOSURE 77375357  &gt;)</div><div class="line">&gt; (pipe-elt i 10) =&gt; 10</div><div class="line">&gt; (pipe-elt i 11) =&gt; NIL</div><div class="line">&gt; i =&gt; (0 1 2 3 4 5 6 7 8 9 10)</div></div><!-- fragment --><p>Понятно, что эта версия тратит меньше места и гораздо аккуратнее убирает после себя. Фактически, полностью вычисленный pipe превращается в список! Эта эффективность была достигнута за счет общего принципа разработки программ. Обычно мы стремимся построить более сложные абстракции, например каналы(pipes), из более простых, например задержек/отложенных вычислений(delays). Но в этом случае часть функциональных возможностей, которые обеспечивали отложенные вычисления, была дублирована cons-ячейками, составляющими каналы(pipes), поэтому более эффективная реализация каналов вообще не использует задержки.</p>
<p>Вот еще несколько служебных функций для каналов(pipes):</p>
<div class="fragment"><div class="line">(defun enumerate (pipe &amp;key count key (result pipe))</div></div><!-- fragment --><p><code>"Go through all (or count) elements of pipe,</code></p>
<p><code>possibly applying the KEY function. (Try PRINT.)"</code></p>
<p><code>;; Returns RESULT, which defaults to the pipe itself.</code></p>
<p><code>(if (or (eq pipe empty-pipe) (eql count 0))</code> </p><pre class="fragment">        `result`

        `(progn`

        `(unless (null key) (funcall key (head pipe)))`

        `(enumerate (tail pipe) :count (if count (- count 1))`

                                          `: key key : result result))))`
</pre><div class="fragment"><div class="line">(defun filter (pred pipe)</div></div><!-- fragment --><p><code>"Keep only items in pipe satisfying pred."</code></p>
<p><code>(if (funcall pred (head pipe))</code> </p><pre class="fragment">`(make-pipe (head pipe)`

                                    `(filter pred (tail pipe)))`

`(filter pred (tail pipe))))`
</pre><p>А вот и применение pipes: генерация простых чисел с использованием алгоритма решета Эратосфена:</p>
<div class="fragment"><div class="line">(defun sieve (pipe)</div></div><!-- fragment --><p><code>(make-pipe (head pipe)</code> </p><pre class="fragment">        `(filter #'(lambda (x) (/= (mod x (head pipe)) 0))`

                          `(sieve (tail pipe)))))`
</pre><div class="fragment"><div class="line">(defvar *primes* (sieve (integers 2)))</div><div class="line">&gt; *primes* =&gt; (2 . #  &lt;  CLOSURE 3075345  &gt;)</div><div class="line">&gt; (enumerate *primes* :count 10) =&gt;</div><div class="line">(2 3 5 7 11 13 17 19 23 29 31 . #  &lt;  CLOSURE 5224472  &gt;)</div></div><!-- fragment --><p>Наконец, вернемся к проблеме генерации всех строк в грамматике. Для начала нам понадобятся еще несколько служебных функций:</p>
<div class="fragment"><div class="line">(defun map-pipe (fn pipe)</div></div><!-- fragment --><p><code>"Map fn over pipe, delaying all but the first fn call."</code></p>
<p><code>(if (eq pipe empty-pipe)</code> </p><pre class="fragment">      `empty-pipe`

      `(make-pipe (funcall fn (head pipe))`

                      `(map-pipe fn (tail pipe)))))`
</pre><div class="fragment"><div class="line">(defun append-pipes (x y)</div></div><!-- fragment --><p><code>"Return a pipe that appends the elements of x and y."</code></p>
<p><code>(if (eq x empty-pipe)</code> </p><pre class="fragment">        `y`

        `(make-pipe (head x)`

                              `(append-pipes (tail x) y))))`
</pre><div class="fragment"><div class="line">(defun mappend-pipe (fn pipe)</div></div><!-- fragment --><p><code>"Lazily map fn over pipe, appending results."</code></p>
<p><code>(if (eq pipe empty-pipe)</code> </p><pre class="fragment">              `empty-pipe`

              `(let ((x (funcall fn (head pipe))))`

                  `(make-pipe (head x)`

                                  `(append-pipes (tail x)`

                                                          `(mappend-pipe`

                                                                                  `fn (tail pipe)))))))`
</pre><p>Теперь мы можем переписать <code>generate-all</code> и <code>combine-all</code>, чтобы использовать каналы(pipes) вместо списков.</p>
<p>Все остальное такое же, как на <a href="B9780080571157500029.xhtml#p45">Странице 45</a>.</p>
<div class="fragment"><div class="line">(defun generate-all (phrase)</div></div><!-- fragment --><p><code>"Generate a random sentence or phrase"</code></p>
<p><code>(if (listp phrase)</code> </p><pre class="fragment">`(if (null phrase)`

        `(list nil)`

        `(combine-all-pipes`

              `(generate-all (first phrase))`

              `(generate-all (rest phrase))))`

`(let ((choices (rule-rhs (assoc phrase *grammar*))))`

  `(if choices`

              `(mappend-pipe #'generate-all choices)`

              `(list (list phrase))))))`
</pre><div class="fragment"><div class="line">(defun combine-all-pipes (xpipe ypipe)</div></div><!-- fragment --><p><code>"Return a pipe of pipes formed by appending a y to an x"</code></p>
<p><code>;; In other words, form the cartesian product.</code></p>
<p><code>(mappend-pipe</code> </p><pre class="fragment">`#'(lambda (y)`

            `(map-pipe #'(lambda (x) (append-pipes x y))`

                                              `xpipe))`

`ypipe))`
</pre><p>С этими определениями, вот pipe всех предложений из <code>*grammar2*</code> (из <a href="B9780080571157500029.xhtml#p43">Страница 43</a>):</p>
<div class="fragment"><div class="line">&gt; (setf ss (generate-all &#39;sentence)) =&gt;</div><div class="line">((THE . #  &lt;  CLOSURE 27265720  &gt;) . #  &lt;  CLOSURE 27266035&gt;)</div><div class="line">&gt; (enumerate ss :count 5) =&gt;</div><div class="line">((THE . #  &lt;  CLOSURE 27265720  &gt;)</div><div class="line">(A . #  &lt;  CLOSURE 27273143  &gt;)</div><div class="line">(THE . #  &lt;  CLOSURE 27402545  &gt;)</div><div class="line">(A . #  &lt;  CLOSURE 27404344  &gt;)</div><div class="line">(THE . #  &lt;  CLOSURE 27404527  &gt;)</div><div class="line">(A . #  &lt;  CLOSURE 27405473  &gt;) . #  &lt;  CLOSURE 27405600  &gt;)</div><div class="line">&gt; (enumerate ss .-count 5 :key #&#39;enumerate) =&gt;</div><div class="line">((THE MAN HIT THE MAN)</div><div class="line">(A MAN HIT THE MAN)</div><div class="line">(THE BIG MAN HIT THE MAN)</div><div class="line">(A BIG MAN HIT THE MAN)</div><div class="line">(THE LITTLE MAN HIT THE MAN)</div><div class="line">(THE . #  &lt;  CLOSURE 27423236  &gt;) . #  &lt;  CLOSURE 27423343  &gt;)</div><div class="line">&gt; (enumerate (pipe-elt ss 200)) =&gt;</div><div class="line">(THE ADIABATIC GREEN BLUE MAN HIT THE MAN)</div></div><!-- fragment --><p>Хотя мы смогли представить бесконечный набор предложений и перечислить их экземпляры, мы все еще не решили все проблемы. Во-первых, это перечисление никогда не дойдет до предложения, в котором нет глагольной фразы "hit the man"(ударить человека). Мы будем видеть все более длинные списки прилагательных, но никаких других изменений. Другая проблема заключается в том, что леворекурсивные правила по-прежнему будут вызывать бесконечные циклы. Например, если расширение для <code>Adj*</code> было <code>(Adj* -&gt; (Adj* Adj) ())</code> вместо <code>(Adj* -&gt; () (Adj Adj*))</code>, то перечисление никогда не будет завершаться, потому что pipes должны генерировать первый элемент.</p>
<p>Мы использовали задержки(delays) и каналы(pipes) для двух основных целей: чтобы отложить на потом вычисления, которые могут вообще не понадобиться, и для получения явного представления больших или бесконечных множеств. Следует отметить, что язык Prolog имеет иное решение первой проблемы (но не второй). Как мы увидим в <a href="B978008057115750011X.xhtml">главе 11</a>, Prolog генерирует решения по одному, автоматически отслеживая возможные точки возврата. Там, где pipes позволяют нам представлять бесконечное количество альтернатив в данных, Prolog позволяет нам представлять эти альтернативы в самой программе.</p>
<p><b>Exercise 9.1 [h]</b> Когда дана функция <code>f</code> и канал <code>p</code>, <code>mappend-pipe</code> возвращает новый канал, который в конечном итоге перечислит все <code>(f (first p))</code>, затем все <code>(f (second p))</code> и так далее. Это считается "неправильным", если <code>(f (first p))</code> имеет бесконечное количество элементов. Определите функцию, которая будет правильно чередовать элементы, чтобы все они в конечном итоге были перечислены. Покажите, что функция работает, изменив <code>generate-all</code> для работы с ней.</p>
<h2>9.4 Индексирование данных</h2>
<p>Lisp упрощает использование списков в качестве универсальной структуры данных. Список может представлять множество или упорядоченную последовательность, а список с подсписками может представлять дерево или граф. Для быстрого прототипирования зачастую проще всего представить данные в виде списков, но для эффективности это не всегда лучшая идея. Чтобы найти элемент в списке длиной <em>n</em>, потребуется в среднем <em>n</em>/2 шагов. Это верно для простого списка, списка ассоциаций(alist) или списка свойств(plist). Если <em>n</em> может быть большим, стоит рассмотреть другие структуры данных, такие как хеш-таблицы, векторы, списки свойств и деревья.</p>
<p>Выбор правильной структуры данных и алгоритма так же важен в Лиспе, как и в любом другом языке программирования. Несмотря на то, что Lisp предлагает широкий спектр структур данных, часто стоит потратить некоторые усилия на построение правильной структуры данных для часто используемых данных. Например, хеш-таблицы Lisp слишком обобщены и поэтому могут быть неэффективными. Вы можете создавать свои собственные хеш-таблицы, если, например, вам никогда не нужно удалять элементы, что делает открытое хеширование привлекательной возможностью. Мы увидим пример эффективного индексирования в <a href="#s0035">раздел 9.6</a>(<a href="B9780080571157500091.xhtml#p297">Страница 297</a>).</p>
<h2>9.5 Инструментарий: Позволяющий решить, что оптимизировать</h2>
<p>Поскольку Lisp - очень хороший язык для быстрого создания прототипов, мы можем рассчитывать быстро получить работающую реализацию. Прежде чем мы приступим к попыткам повысить эффективность реализации, неплохо посмотреть, какие части используются чаще всего. Улучшение малоиспользуемых функций - пустая трата времени.</p>
<p>Минимальная поддержка, которая нам нужна, - это подсчет количества вызовов выбранных функций, а затем распечатка итогов. Это называется <em>профилированием</em> функций. <a href="# fn0020">3</a> Для каждой функции, подлежащей профилированию, мы меняем определение так, чтобы оно увеличивало счетчик, а затем вызывала исходную функцию.</p>
<p>Большинство систем на Лиспе имеют встроенный механизм профилирования. Если в вашей системе он есть, обязательно используйте его. Код в этом разделе предназначен для тех, у кого нет такой возможности, и является примером того, как можно управлять функциями. Ниже приводится простое средство профилирования. Для каждой профилируемой функции он ведет подсчет количества ее вызовов в свойстве <code>profile-count</code> имени функции.</p>
<div class="fragment"><div class="line">(defun profile1 (fn-name)</div></div><!-- fragment --><p><code>"Make the function count how often it is called"</code></p>
<p><code>;; First save away the old, unprofiled function</code></p>
<p><code>;; Then make the name be a new function that increments</code></p>
<p><code>;; a counter and then calls the original function</code></p>
<p><code>(let ((fn (symbol-function fn-name)))</code> </p><pre class="fragment">  `(setf (get fn-name 'unprofiled-fn) fn)`
</pre><p><code>(setf (get fn-name 'profile-count) 0)</code></p>
<p><code>(setf (symbol-function fn-name)</code> </p><pre class="fragment">      `(profiled-fn fn-name fn))`
</pre><p><code>fn-name))</code></p>
<div class="fragment"><div class="line">(defun unprofile1 (fn-name)</div></div><!-- fragment --><p><code>"Make the function stop counting how often it is called."</code></p>
<p><code>(setf (symbol-function fn-name) (get fn-name 'unprofiled-fn))</code></p>
<p><code>fn-name)</code></p>
<div class="fragment"><div class="line">(defun profiled-fn (fn-name fn)</div></div><!-- fragment --><p><code>"Return a function that increments the count."</code></p>
<p>`#'(lambda (&amp;rest args)` </p><pre class="fragment">`(incf (get fn-name 'profile-count))`

`(apply fn args)))`
</pre><div class="fragment"><div class="line">(defun profile-count (fn-name) (get fn-name &#39;profile-count))</div></div><!-- fragment --><p><code>(defun profile-report (fn-names &amp;optional (key #'profile-count))</code></p>
<p><code>"Report profiling statistics on given functions."</code> </p><pre class="fragment">        `(loop for name in (sort fn-names #'&gt; :key key) do`
</pre><div class="fragment"><div class="line">(format t &quot;~&amp;  ~  7D  ~  A&quot; (profile-count name) name)))</div></div><!-- fragment --><p>Это все, что нам нужно для базовой функциональности. Однако есть несколько способов улучшить это. Во-первых, было бы неплохо иметь макросы, такие как <code>trace</code> и <code>untrace</code>, которые позволяют пользователю одновременно профилировать несколько функций и отслеживать то, что было профилировано. Во-вторых, может быть полезно видеть время, затраченное на каждую функцию, а также количество вызовов.</p>
<p>Кроме того, важно избегать двойного профилирования функции, поскольку это удвоит количество зарегистрированных вызовов, не предупреждая пользователя о каких-либо проблемах. Допустим, мы ввели следующую последовательность команд:</p>
<div class="fragment"><div class="line">(defun f (x) (g x))</div><div class="line">(profile1 &#39;f)</div><div class="line">(profile1 &#39;f)</div></div><!-- fragment --><p>Тогда определение <code>f</code> будет примерно таким:</p>
<div class="fragment"><div class="line">(lambda (&amp;rest args)</div></div><!-- fragment --> <pre class="fragment">  `(incf (get 'f 'profile-count))`

  `(apply #'(lambda (&amp;rest args)`

        `(incf (get 'f 'profile-count))`

        `(apply #'(lambda (x) (g x))`

                    `args))`

            `args))`
</pre><p>В результате любой вызов <code>f</code> в конечном итоге вызовет исходный <code>f</code>, но только после двукратного увеличения счетчика.</p>
<p>Еще одно соображение: что происходит, когда профилируемая функция переопределяется пользователем. Единственный способ гарантировать, что переопределенная функция продолжит профилирование, - это изменить определение макроса defun для поиска функций, которые следует профилировать. Изменение системных функций, таких как defun, - рискованная перспектива, и в <em>Common Lisp the Language</em>, 2-е издание, это явно запрещено. Вместо этого мы сделаем следующее: убедимся, что следующий вызов <code>profile</code> повторно профилирует любые функции, которые были переопределены. Мы делаем это, отслеживая как исходную непрофилированную функцию, так и профилированную функцию. Мы также храним список всех профилируемых функций.</p>
<p>Кроме того, мы посчитаем время, потраченное на каждую функцию. Однако пользователя предупреждают, что нельзя слишком доверять цифрам времени. Во-первых, они включают накладные расходы на средство профилирования. Это может быть значительным, особенно потому, что средство conses(конструирует списки) и, таким образом, может вызвать сборку мусора, которая в противном случае не была бы выполнена. Во-вторых, разрешения системных часов может быть недостаточно для точного отсчета времени. Для функций, которые занимают около 1/10 секунды или более, цифры будут надежными, но для быстрых функций это не так.</p>
<p>Вот основной код для <code>profile</code> и <code>unprofile:</code></p>
<div class="fragment"><div class="line">(defvar *profiled-functions* nil</div></div><!-- fragment --><p><code>"Function names that are currently profiled")</code></p>
<div class="fragment"><div class="line">(defmacro profile (&amp;rest fn-names)</div></div><!-- fragment --><p><code>"Profile fn-names.
With no args, list profiled functions."</code></p>
<p>`'(mapcar #'profile1` </p><pre class="fragment">        `(setf *profiled-functions*`

      `(union *profiled-functions* fn-names))))`
</pre><div class="fragment"><div class="line">(defmacro unprofile (&amp;rest fn-names)</div></div><!-- fragment --><p><code>"Stop profiling fn-names.
With no args, stop all profiling."</code></p>
<p>`'(progn` </p><pre class="fragment">`(mapcar #'unprofile1`

            `,(if fn-names fn-names '*profiled-functions*))`

`(setf *profiled-functions*`

            `,(if (null fn-names)`

      `nil`

            `'(set-difference *profiled-functions*`

                  `',fn-names)))))`
</pre><p>Идиома ' ',<code>fn-names</code> заслуживает комментария, так как она обычна, но поначалу может сбивать с толку. Её может быть легче понять, если написать в эквивалентной форме '<code>(quote ,fn-names)</code>. Как всегда, обратная кавычка создает структуру как с постоянными, так и с вычисляемыми компонентами. В этом случае <code>quote</code> постоянна, а переменная <code>fn-names</code> вычисляется. В MacLisp для этой цели была определена функция <code>kwote</code>:</p>
<div class="fragment"><div class="line">(defun kwote (x) (list &#39;quote x))</div></div><!-- fragment --><p>Теперь нам нужно изменить <code>profile1</code> и <code>unprofile1</code>, чтобы выполнить дополнительный учет: Для <code>profile1</code> есть два случая. Если пользователь дважды подряд выполняет <code>profile1</code> для одного и того же имени функции, то во второй раз мы заметим, что текущая функция совпадает с функцией, хранящейся в свойстве <code>profiled-fn</code>, поэтому больше ничего не нужно должно быть сделано. В противном случае мы создаем профилированную функцию, сохраняем ее как текущее определение имени в свойстве <code>profiled-fn</code>, сохраняем непрофилированную функцию и инициализируем счетчики.</p>
<div class="fragment"><div class="line">(defun profile1 (fn-name)</div></div><!-- fragment --><p><code>"Make the function count how often it is called"</code></p>
<p><code>;; First save away the old, unprofiled function</code></p>
<p><code>;; Then make the name be a new function that increments</code></p>
<p><code>;; a counter and then calls the original function</code></p>
<p><code>(let ((fn (symbol-function fn-name)))</code> </p><pre class="fragment">`(unless (eq fn (get fn-name 'profiled-fn))`

        `(let ((new-fn (profiled-fn fn-name fn)))`

            `(setf (symbol-function fn-name) new-fn`

                        `(get fn-name 'profiled-fn) new-fn`

                        `(get fn-name 'unprofiled-fn) fn`

                        `(get fn-name 'profile-time) 0`

                        `(get fn-name 'profile-count) 0))))`

  `fn-name)`
</pre><div class="fragment"><div class="line">(defun unprofile1 (fn-name)</div></div><!-- fragment --><p><code>"Make the function stop counting how often it is called."</code></p>
<p><code>(setf (get fn-name 'profile-time) 0)</code></p>
<p><code>(setf (get fn-name 'profile-count) 0)</code></p>
<p><code>(when (eq (symbol-function fn-name) (get fn-name 'profiled-fn))</code> </p><pre class="fragment">`;; normal case: restore unprofiled version`

`(setf (symbol-function fn-name)`

          `(get fn-name 'unprofiled-fn)))`
</pre><p><code>fn-name)</code></p>
<p>Теперь рассмотрим вопрос о времени. Существует встроенная функция Common Lisp, <code>get-internal-real-time</code>, которая возвращает время, прошедшее с начала сеанса Lisp. Поскольку оно может быстро стать большим числом, некоторые реализации предоставляют другую функцию подсчета времени, которая идет по кругу, а не увеличивается постоянно, но которая может иметь более высокое разрешение, чем <code>get-internal-real-time</code>. Например, на машинах TI Explorer Lisp, <code>get-internal-real-time</code> измеряет интервалы в 1/60 секунды, а <code>time:microsecond-time</code> измеряет интервалы в 1/1000000 секунд, но возвращаемое значение возвращается к нулю. каждый час или около того. Функция <code>time:microsecond-time-difference</code> используется для сравнения двух из этих чисел с компенсацией зацикливания, если произошло не более одного зацикливания.</p>
<p>В приведенном ниже коде я использую условные символы макроса чтения <code>#+</code> и <code>#-</code>, чтобы определить правильное поведение как на машинах Explorer, так и на других машинах. Мы видели, что <code>#</code> - это специальный символьный знак для reader, который выполняет разные действия в зависимости от последующего символьного знака. Например, <code>#'fn</code> читается как <code>(function fn)</code>. Последовательность знаков <code>#+</code> определена так, что <code>#+</code>*feature expression* читается как <em>expression</em>, если <em>feature</em>(функциональность) определена в текущей реализации, и как ничто, если это не так. Последовательность <code>#-</code> действует прямо противоположно. Например, в TI Explorer мы получим следующее:</p>
<div class="fragment"><div class="line">&gt;&#39;(hi #+TI t #+Symbolics s #-Explorer e #-Mac m) =&gt; (HI T M)</div></div><!-- fragment --><p>Условные знаки макроса чтения используются в следующих определениях:</p>
<div class="fragment"><div class="line">(defun get-fast-time ()</div></div><!-- fragment --><p><code>"Return the elapsed time. This may wrap around;</code></p>
<p><code>use FAST-TIME-DIFFERENCE to compare."</code></p>
<p><code>#+Explorer (time:microsecond-time) ; do this on an Explorer</code></p>
<p><code>#-Explorer (get-internal-real-time)) ; do this on a non-Explorer</code></p>
<div class="fragment"><div class="line">(defun fast-time-difference (end start)</div></div><!-- fragment --><p><code>"Subtract two time points."</code></p>
<p><code>#+Explorer (time:microsecond-time-difference end start)</code></p>
<p><code>#-Explorer (- end start))</code></p>
<div class="fragment"><div class="line">(defun fast-time-&gt;seconds (time)</div></div><!-- fragment --><p><code>"Convert a fast-time interval into seconds."</code></p>
<p><code>#+Explorer (/ time 1000000.0)</code></p>
<p><code>#-Explorer (/ time internal-time-units-per-second))</code></p>
<p>Следующим шагом является обновление <code>profiled-fn</code> для отслеживания данных о времени. Самый простой способ сделать это - установить для переменной, скажем, <code>start</code>, время, когда происходит вход в функцию, запустить функцию и затем увеличить время выполнения функции на разницу между текущим временем и <code>start</code>. Проблема с этим подходом состоит в том, что каждая функция в стеке вызовов получает значение для времени каждой вызываемой функции. Предположим, что функция <code>f</code> рекурсивно вызывает себя пять раз, причем каждый вызов и возврат происходят с интервалом в секунду, так что все вычисления занимают девять секунд. Тогда с <code>f</code> будет начислено девять секунд за внешний вызов, семь секунд за следующий и так далее, всего 25 секунд, хотя на самом деле на все они вместе потребовалось всего девять секунд.</p>
<p>Лучшим алгоритмом было бы заряжать каждую функцию только на время, прошедшее с момента последнего вызова или возврата. Тогда <code>f</code> будет заряжаться только девять секунд. Переменная <code>*profile-call-stack*</code> используется для хранения стека пар: имя функции/время входа. Этот стек управляется <code>profile-enter</code> и <code>profile-exit</code>, чтобы получить правильные тайминги.</p>
<p>Функции, которые используются при каждом вызове профилируемой функции, объявляются <code>inline</code>. В большинстве случаев вызов функции компилируется в машинные инструкции, которые устанавливают список аргументов и переходят к местоположению определения функции. При использовании встроенной функции тело функции компилируется в строке в месте вызова функции. Таким образом, нет дополнительных затрат на настройку списка аргументов и переход к определению. Объявление <code>inline</code> может появляться везде, где может появиться любое другое объявление. В этом случае функция <code>proclaim</code> используется для регистрации глобального объявления. Inline объявления более подробно обсуждаются на <a href="B9780080571157500108.xhtml#p317">Страница 317</a>.</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline profile-enter profile-exit inc-profile-time))</div><div class="line">(defun profiled-fn (fn-name fn)</div></div><!-- fragment --><p><code>"Return a function that increments the count, and times."</code></p>
<p>`#'(lambda (&amp;rest args)` </p><pre class="fragment">    `(profile-enter fn-name)`

    `(multiple-value-progl`

          `(apply fn args)`

          `(profile-exit fn-name))))`
</pre><div class="fragment"><div class="line">(defvar *profile-call-stack* nil)</div><div class="line">(defun profile-enter (fn-name)</div></div><!-- fragment --><p><code>(incf (get fn-name 'profile-count))</code></p>
<p><code>(unless (null *profile-call-stack*)</code> </p><pre class="fragment">`;; Time charged against the calling function:`

`(inc-profile-time (first *profile-call-stack*)`

                        `(car (first *profile-call-stack*))))`
</pre><p><code>;; Put a new entry on the stack</code></p>
<p><code>(push (cons fn-name (get-fast-time))</code> </p><pre class="fragment">        `*profile-call-stack*))`
</pre><div class="fragment"><div class="line">(defun profile-exit (fn-name)</div></div><!-- fragment --><p><code>;; Time charged against the current function:</code></p>
<p><code>(inc-profile-time (pop *profile-call-stack*)</code> </p><pre class="fragment">                                    `fn-name)`
</pre><p><code>;; Change the top entry to reflect current time</code></p>
<p><code>(unless (null *profile-call-stack*)</code> </p><pre class="fragment">`(setf (cdr (first *profile-call-stack*))`

        `(get-fast-time))))`
</pre><div class="fragment"><div class="line">(defun inc-profile-time (entry fn-name)</div></div><!-- fragment --><p><code>(incf (get fn-name 'profile-time)</code> </p><pre class="fragment">                  `(fast-time-difference (get-fast-time) (cdr entry))))`
</pre><p>Наконец, нам нужно обновить <code>profile-report</code>, чтобы печатать временные данные, а также счетчики. Обратите внимание, что по умолчанию <code>fn-names</code> является копией глобального списка. Это потому, что мы передаем <code>fn-names</code> в <code>sort</code>, которая является разрушающей функцией. Мы не хотим, чтобы глобальный список изменялся в результате этой сортировки.</p>
<div class="fragment"><div class="line">(defun profile-report (&amp;optional</div><div class="line">                                            (fn-names (copy-list *profiled-functions*))</div><div class="line">                                            (key #&#39;profile-count))</div><div class="line">    &quot;Report profiling statistics on given functions.&quot;</div><div class="line">    (let ((total-time (reduce #&#39;  +  (mapcar #&#39;profile-time fn-names))))</div><div class="line">        (unless (null key)</div><div class="line">            (setf fn-names (sort fn-names #&#39;&gt; :key key)))</div><div class="line">        (format t &quot;~&amp;Total elapsed time: ~d seconds.&quot;</div><div class="line">                        (fast-time-&gt; seconds total-time))</div><div class="line">        (format t Count Secs Time% Name&quot;)</div><div class="line">        (loop for name in fn-names do</div><div class="line">                  (format t &quot;~&amp;~7D ~6,2F ~3d% ~A&quot;</div><div class="line">                                (profile-count name)</div><div class="line">                                (fast-time-&gt; seconds (profile-time name))</div><div class="line">                                (round (/ (profile-time name) total-time) .01)</div><div class="line">                                name))))</div><div class="line">(defun profile-time (fn-name) (get fn-name &#39;profile-time))</div></div><!-- fragment --><p>Эти функции можно использовать, вызвав <code>profile</code>, затем выполнив некоторые типичные вычисления, затем вызвав <code>profile-report</code> и, наконец, <code>unprofile</code>. Может быть удобно предоставить один макрос для выполнения всех этих действий одновременно:</p>
<div class="fragment"><div class="line">(defmacro with-profiling (fn-names &amp;rest body)</div><div class="line">  &#39;(progn</div><div class="line">        (unprofile . ,fn-names)</div><div class="line">        (profile . ,fn-names)</div><div class="line">        (setf *profile-call-stack* nil)</div><div class="line">        (unwind-protect</div><div class="line">                (progn . ,body)</div><div class="line">            (profile-report &#39;,fn-names)</div><div class="line">            (unprofile . ,fn-names))))</div></div><!-- fragment --><p>Обратите внимание на использование функции <code>unwind-protect</code> для создания отчета и вызова <code>unprofile</code>, даже если вычисление было прервано. <code>unwind-protect</code> - это особая форма, которая принимает любое количество аргументов. Она вычисляет первый аргумент и, если все идет хорошо, вычисляет остальные аргументы и возвращает результат первого, как и <code>progl</code>. Но если во время вычисления первого аргумента возникает ошибка и вычисление прерывается, то последующие аргументы (называемые формами очистки) все равно вычисляются.</p>
<h2>9.6 Пример исследования эффективности: программа SIMPLIFY</h2>
<p>Предположим, мы хотим ускорить выполнение программы <code>simplify</code> из <a href="B978008057115750008X.xhtml">главы 8</a>. В этом разделе показано, как сочетание общих методов - запоминания(memoizing), индексации и компиляции - может использоваться для ускорения программы в 130 раз. <a href="B9780080571157500157.xhtml">Глава 15</a> покажет другой подход: заменить алгоритм совершенно другим.</p>
<p>Первым шагом к более быстрой программе является определение <em>эталонного теста</em>(benchmark), набора тестов, представляющего типичную рабочую нагрузку. Ниже приводится краткий список тестовых задач (и их ответов), которые типичны для задачи <code>simplify</code>.</p>
<div class="fragment"><div class="line">(defvar *test-data* (mapcar #&#39;infix-&gt; prefix</div><div class="line">  &#39;((d (a * x ^ 2  +  b * x  +  c) / d x)</div><div class="line">      (d ((a * x ^ 2  +  b * x  +  c) / x) / d x)</div><div class="line">      (d((a*x ^ 3  +  b * x ^ 2  +  c * x  +  d)/x ^ 5)/dx)</div><div class="line">      ((sin (x  +  x)) * (sin (2 * x))  +  (cos (d (x ^ 2) / d x)) ^ 1)</div><div class="line">      (d (3 * x  +  (cos x) / x) / d x))))</div><div class="line">(defvar *answers* (mapcar #&#39;simplify *test-data*))</div></div><!-- fragment --><p>Функция <code>test-it</code> просматривает тестовые данные, проверяя правильность каждого ответа и при необходимости распечатывая данные профилирования.</p>
<div class="fragment"><div class="line">(defun test-it (&amp;optional (with-profiling t))</div></div><!-- fragment --><p><code>"Time a test run.
and make sure the answers are correct."</code></p>
<div class="fragment"><div class="line">    (let ((answers</div><div class="line">                  (if with-profiling</div><div class="line">                          (with-profiling (simplify simplify-exp pat-match</div><div class="line">                                                            match-variable variable-p)</div><div class="line">                              (mapcar #&#39;simplify *test-data*))</div><div class="line">                          (time (mapcar #&#39;simplify *test-data*)))))</div><div class="line">        (mapc #&#39;assert-equal answers *answers*)</div><div class="line">        t))</div><div class="line">(defun assert-equal (x y)</div><div class="line">    &quot;If x is not equal to y, complain.&quot;</div><div class="line">    (assert (equal x y) (x y)</div><div class="line">                    &quot;Expected ~a to be equal to ~a&quot; x y))</div></div><!-- fragment --><p>Вот результаты (<code>test-it</code>) с профилированием и без него:</p>
<div class="fragment"><div class="line">&gt; (test-it nil)</div><div class="line">Evaluation of (MAPCAR #&#39;SIMPLIFY *TEST-DATA*) took 6.612  seconds.</div><div class="line">&gt; (test-it t)</div><div class="line">Total elapsed time: 22.819614  seconds</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>Count</code> </td><td><code>Secs</code> </td><td><code>Time%</code> </td><td><code>Name</code> </td></tr>
<tr>
<td><code>51690</code> </td><td><code>11.57</code> </td><td><code>51%</code> </td><td><code>PAT-MATCH</code> </td></tr>
<tr>
<td><code>37908</code> </td><td><code>8.75</code> </td><td><code>38%</code> </td><td><code>VARIABLE-P</code> </td></tr>
<tr>
<td><code>1393</code> </td><td><code>0.32</code> </td><td><code>1%</code> </td><td><code>MATCH-VARIABLE</code> </td></tr>
<tr>
<td><code>906</code> </td><td><code>0.20</code> </td><td><code>1%</code> </td><td><code>SIMPLIFY</code> </td></tr>
<tr>
<td><code>274</code> </td><td><code>1.98</code> </td><td><code>9%</code> </td><td><code>SIMPLIFY-EXP</code> </td></tr>
</table>
<p>Обычно выполнение теста занимает 6,6 секунды, хотя время увеличивается втрое при добавлении дополнительных затрат на профилирование. Должно быть ясно, что для ускорения работы мы должны либо ускорить, либо сократить количество обращений к <code>pat-match</code> или <code>variable-p</code>, поскольку вместе они составляют 89% вызовов (и 89% времени тоже). Мы рассмотрим три метода достижения обеих этих целей.</p>
<h4>Memoization(Запоминание вычисленных результатов)</h4>
<p>Рассмотрим правило, которое преобразует (<code>x + x</code>) в (<code>2 * x</code>). Как только это будет сделано, мы должны упростить результат, что предполагает повторное упрощение компонентов. Если бы <code>x</code> был некоторым сложным выражением, это могло бы занять много времени и, безусловно, будет расточительным, потому что <code>x</code> уже упрощен и не может измениться. Мы уже сталкивались с подобными проблемами раньше, и решением является мемоизация: заставьте <code>simplify</code> запоминать проделанную работу, а не повторять ее. Можно просто сказать:</p>
<div class="fragment"><div class="line">(memoize &#39;simplify :test #&#39;equal)</div></div><!-- fragment --><p>Неясны два вопроса: какую хеш-таблицу использовать и нужно ли очищать хеш-таблицу между проблемами. Упрощение рассчитывалось для всех четырех комбинаций хэш-таблиц <code>eq</code> или <code>equal</code> и сброса или отсутствия сброса между задачами. Самым быстрым результатом было <code>equal</code> хеширование без сброса(очистки). Обратите внимание, что с хешированием <code>eq</code> версия с сбросом была быстрее, предположительно потому, что она не могла использовать преимущества общих подвыражений между примерами (поскольку они не являются <code>eq</code>).</p>
<table class="doxtable">
<tr>
<th>hashing </th><th>resetting </th><th>time  </th></tr>
<tr>
<td>none </td><td>- </td><td>6.6 </td></tr>
<tr>
<td>equal </td><td>yes </td><td>3.8 </td></tr>
<tr>
<td>equal </td><td>no </td><td>3.0 </td></tr>
<tr>
<td>eq </td><td>yes </td><td>7.0 </td></tr>
<tr>
<td>eq </td><td>no </td><td>10.2 </td></tr>
</table>
<p>Такой подход заставляет функцию <code>simplify</code> запоминать выполненную работу в хэш-таблице. Если накладные расходы на обслуживание хеш-таблицы становятся слишком большими, есть альтернатива: заставить данные помнить, что было сделано упрощением. Этот подход был использован в MACSYMA: она представляет операторы в виде списков, а не атомов. Таким образом, вместо <code>(* 2 x)</code> MACSYMA будет использовать <code>((*) 2 x)</code>. Функция упрощения будет разрушающим образом вставлять маркер в список операторов. Таким образом, результатом упрощения 2 <em>x</em> будет <code>((* simp) 2 x)</code>. Затем, когда упрощатель будет вызваться рекурсивно для этого выражения, он заметит маркер <code>simp</code> и вернет выражение как есть.</p>
<p>Идея связать мемоизационную информацию с данными, а не с функцией будет более эффективной, если не будет много функций, которые все захотят поставить свои отметки на одни и те же данные. Подход, ориентированный на данные, имеет два недостатка: он не идентифицирует структуры, которые <code>equal</code>, но не <code>eq</code>, и, поскольку он требует явного изменения данных, он требует, чтобы каждая другая операция, которая манипулирует данными, знала о маркере. Прелесть подхода с использованием хеш-таблицы в том, что он прозрачен; никакой код не должен знать, что происходит мемоизация.</p>
<h4>Индексация</h4>
<p>В настоящее время мы просматриваем весь список правил по одному, проверяя каждое правило. Это неэффективно, потому что большинство правил можно тривиально исключить, если только они были правильно проиндексированы. Самая простая схема индексации - это иметь отдельный список правил, индексируемых под каждым оператором. Вместо того, чтобы проверять <code>simplify-exp</code> каждый член <code>*simplification-rules*</code> с помощью <code>simpleify-exp</code>, он может просматривать только меньший список правил для соответствующего оператора. Вот как:</p>
<div class="fragment"><div class="line">(defun simplify-exp (exp)</div></div><!-- fragment --><p><code>"Simplify using a rule. or by doing arithmetic.</code></p>
<div class="fragment"><div class="line">    or by using the simp function supplied for this operator.</div><div class="line">    This version indexes simplification rules under the operator.&quot;</div><div class="line">    (cond ((simplify-by-fn exp))</div><div class="line">                ((rule-based-translator exp (rules-for (exp-op exp)) ;***</div><div class="line">                      :rule-if #&#39;exp-lhs :rule-then #&#39;exp-rhs</div><div class="line">                      :action #&#39;(lambda (bindings response)</div><div class="line">                                            (simplify (sublis bindings response)))))</div><div class="line">                ((evaluable exp) (eval exp))</div><div class="line">                (t exp)))</div><div class="line">(defvar *rules-for* (make-hash-table :test #&#39;eq))</div><div class="line">(defun main-op (rule) (exp-op (exp-lhs rule)))</div><div class="line">(defun index-rules (rules)</div><div class="line">    &quot;Index all the rules under the main op.&quot;</div><div class="line">    (clrhash *rules-for*)</div><div class="line">    (dolist (rule rules)</div><div class="line">        ;; nconc instead of push to preserve the order of rules</div><div class="line">        (setf (gethash (main-op rule) *rules-for*)</div><div class="line">                    (nconc (gethash (main-op rule) *rules-for*)</div><div class="line">                                  (list rule)))))</div><div class="line">(defun rules-for (op) (gethash op *rules-for*))</div><div class="line">(index-rules *simplification-rules*)</div></div><!-- fragment --><p>Время для мемоизированной(memoized) и индексированной(indexed) версии дает нам 0,98 секунды, по сравнению с 6,6 секунды для исходного кода и 3 секунд для мемоизированного(memoized) кода. Если бы это не помогло, мы могли бы рассмотреть более сложные схемы индексации. Вместо этого мы переходим к рассмотрению других средств повышения эффективности.</p>
<p><b>Exercise 9.2 [m]</b> Список правил для каждого оператора хранится в хеш-таблице с оператором в качестве ключа. Альтернативой могло бы быть хранение правил в списке свойств каждого оператора, предполагая, что операторы должны быть символами. Реализуйте эту альтернативу и сопоставьте ее с подходом с хэш-таблицей. Помните, что вам нужен какой-то способ очистки старых правил - тривиальный с помощью хеш-таблицы, но не автоматический со списками свойств.</p>
<h4>Компиляция</h4>
<p>Вы можете посмотреть на <code>simpleify-exp</code> как на интерпретатор языка правил упрощения. Один из проверенных методов повышения эффективности - замена интерпретатора компилятором. Например, правило <code>(x + x = 2 * x)</code> может быть скомпилировано во что-то вроде:</p>
<div class="fragment"><div class="line">(lambda (exp)</div><div class="line">    (if (and (eq (exp-op exp) &#39;+) (equal (exp-lhs exp) (exp-rhs exp)))</div><div class="line">            (make-exp :op &#39;* :lhs 2 :rhs (exp-rhs exp))))</div></div><!-- fragment --><p>Это устраняет необходимость в использовании конструирования списков(консинга/consing) и передаче привязок переменных и должно быть быстрее, чем обычная процедура сопоставления. При использовании вместе с индексированием отдельные правила могут быть проще, потому что мы уже знаем, что у нас есть правильный оператор. Например, с указанным выше правилом, обозначенным знаком "+", теперь его можно скомпилировать как:</p>
<div class="fragment"><div class="line">(lambda (exp)</div><div class="line">    (if (equal (exp-lhs exp) (exp-rhs exp))</div><div class="line">            (make-exp :op &#39;* :lhs 2 :rhs (exp-lhs exp))))</div></div><!-- fragment --><p>Важно отметить, что когда эти функции возвращают nil, это означает, что они не смогли упростить выражение, и мы должны рассмотреть другие способы упрощения.</p>
<p>Другая возможность состоит в том, чтобы скомпилировать набор правил одновременно, чтобы индексирование фактически было частью скомпилированного кода. В качестве примера я показываю здесь небольшой набор правил и возможную компиляцию набора правил. Созданная функция предполагает, что <code>x</code> не является атомом. Это уместно, потому что мы заменяем <code>simpleify-exp</code>, а не <code>simplify</code>. Кроме того, мы вернем nil, чтобы указать, что <code>x</code> уже упрощен. Я выбрал немного другой формат кода; основное отличие - это возможность вводить имена переменных для подвыражений. Это особенно полезно для глубоко вложенных шаблонов(образцов). Другое отличие состоит в том, что я явно создаю ответ с помощью вызова <code>list</code>, а не <code>make-exp</code>. Обычно это считается плохим стилем, но, поскольку это код, созданный компилятором, я хотел, чтобы он был максимально эффективным. Если бы представление типа данных exp изменилось, мы могли бы просто изменить компилятор; задача гораздо проще, чем поиск всех ссылок, разбросанных по программе, написанной человеком. Следующие комментарии не были созданы компилятором.</p>
<div class="fragment"><div class="line">(x * 1  =  x)</div><div class="line">(1 * x  =  x)</div><div class="line">(x * 0  =  0)</div><div class="line">(0 * x  =  0)</div><div class="line">(x * x  =  x ^ 2)</div><div class="line">(lambda (x)</div><div class="line">    (let ((xl (exp-lhs x))</div><div class="line">                (xr (exp-rhs x)))</div><div class="line">        (or (if (eql xr &#39;1)        ; (x*1  =  X)</div><div class="line">                        xl)</div><div class="line">                (if (eql xl &#39;1)        ; (1*x  =  X)</div><div class="line">                        xr)</div><div class="line">                (if (eql xr &#39;0)        ; (x*0  =  0)</div><div class="line">                        &#39;0)</div><div class="line">                (if (eql xl &#39;0)        ; (0*x  =  0)</div><div class="line">                        &#39;0)</div><div class="line">                (if (equal xr xl)    ; (x*x  =  x  ^  2)</div><div class="line">                        (list &#39;^ xl &#39;2)))))</div></div><!-- fragment --><p>Я выбрал этот формат для кода, потому что я представлял (и позже <em>show</em>), что для него будет довольно легко написать компилятор.</p>
<h4>Компилятор с одним правилом</h4>
<p>Здесь я показываю полный компилятор c одним правилом, за которым следует компилятор индексированного набора правил. Компилятор с одним правилом работает так:</p>
<div class="fragment"><div class="line">&gt; (compile-rule &#39;(= (+ x x) (* 2 x)))</div><div class="line">(LAMBDA (X)</div></div><!-- fragment --><p>` (IF (OP? X '+)`</p>
<div class="fragment"><div class="line">(LET ((XL (EXP-LHS X))</div><div class="line">            (XR (EXP-RHS X)))</div><div class="line">  (IF (EQUAL XR XL)</div><div class="line">          (SIMPLIFY-EXP (LIST &#39;* &#39;2 XL))))))</div></div><!-- fragment --><p>Получая правило, он генерирует код, который сначала проверяет образец, а затем строит правую часть правила, если образец совпадает. По мере того, как код генерируется, соответствия устанавливаются между переменными в образце, такими как <code>x</code>, и переменными в сгенерированном коде, например, <code>xl</code>. Они хранятся в списке ассоциаций <code>*bindings*</code>. Сопоставление можно разбить на четыре случая: переменные, которые НЕ были замечены ранее, переменные, которые наблюдались раньше, атомы и списки. Например, в первый раз, когда мы сталкиваемся с <code>x</code> в приведенном выше правиле, тест не генерируется, поскольку все что угодно может соответствовать <code>x</code>. Но запись <code>(x . xl)</code> добавляется в список <code>*bindings*</code>, чтобы отметить эквивалентность. Когда встречается второй <code>x</code>, генерируется проверка/тест <code>(equal xr xl)</code>.</p>
<p>Организовать компилятор немного сложнее, потому что мы должны делать сразу три вещи: возвращать сгенерированный код, отслеживать <code>*привязки*</code> и отслеживать, что делать "дальше", то есть когда тест успешен, нам нужно сгенерировать больше кода либо для дальнейшего тестирования, либо для построения результата. Этот код должен знать о привязках, поэтому он не может быть выполнен <em>до</em> первой части теста, но он также должен знать, где он должен быть размещен в общем коде, поэтому это было бы грязно сделать это <em>после</em> первой части теста. Ответ - передать функцию, которая сообщит нам, какой код сгенерировать позже. Таким образом, это делается в нужное время и тоже оказывается в нужном месте. Такую функцию часто называют <em>продолжением</em>(<em>continuation</em>), потому что она сообщает нам, где продолжить вычисления. В нашем компиляторе переменная <code>consquent</code> является функцией продолжения.</p>
<p>Компилятор называется <code>compile-rule</code>. Он принимает правило в качестве аргумента и возвращает лямбда-выражение, реализующее правило.</p>
<div class="fragment"><div class="line">(defvar *bindings* nil</div><div class="line">    &quot;A list of bindings used by the rule compiler.&quot;)</div><div class="line">(defun compile-rule (rule)</div><div class="line">    &quot;Compile a single rule.&quot;</div><div class="line">    (let ((*bindings* nil))</div><div class="line">        &#39;(lambda (x)</div><div class="line">            ,(compile-exp &#39;x (exp-lhs rule) ; x is the lambda parameter</div><div class="line">                                        (delay (build-exp (exp-rhs rule)</div><div class="line">                                                                                              *bindings*))))))</div></div><!-- fragment --><p>Вся работа выполняется с помощью <code>compile-exp</code>, который принимает три аргумента: переменную, которая будет представлять входные данные в сгенерированном коде, образец, которому входные данные должны быть сопоставлены, и продолжение для генерации кода, если тест пройден. Есть пять случаев: (1) Если образец переменной в списке привязок, мы генерируем тест на равенство. (2) Если образец представляет собой переменную, которую мы раньше не видели, то мы добавляем ее в список привязок, не генерируем никакого теста (потому что что-либо соответствует переменной), а затем генерируем соответствующий код. (3) Если образец представляет собой атом, то совпадение будет успешным, только если ввод эквивалентен <code>eql</code> атому. (4) Если образец является условным, например <code>(?is n numberp)</code>, мы генерируем тест <code>(numberp n)</code>. Другие подобные образцы могут быть включены сюда, но не были включены, поскольку они не использовались. Наконец, (5) если образец является списком, мы проверяем, что он имеет правильный оператор и аргументы.</p>
<div class="fragment"><div class="line">(defun compile-exp (var pattern consequent)</div><div class="line">    &quot;Compile code that tests the expression, and does consequent</div></div><!-- fragment --><p><code>если он совпадает. Предполагает привязки в *bindings*</code></p>
<div class="fragment"><div class="line">(cond ((get-binding pattern *bindings*)</div><div class="line">              ;; Test a previously bound variable</div><div class="line">              &#39;(if (equal .var .(lookup pattern *bindings*))</div></div><!-- fragment --><p><code>,(force consequent)))</code></p>
<div class="fragment"><div class="line">((variable-p pattern)</div><div class="line">  ;; Add a new bindings; do type checking if needed.</div><div class="line">  (push (cons pattern var) *bindings*)</div><div class="line">  (force consequent))</div><div class="line">((atom pattern)</div><div class="line">  ;; Match a literal atom</div><div class="line">  &#39;(if (eql ,var &#39;.pattern)</div><div class="line">            ,(force consequent)))</div><div class="line">((starts-with pattern &#39;?is)</div><div class="line">  (push (cons (second pattern) var) *bindings*)</div><div class="line">  &#39;(if (,(third pattern) ,var)</div><div class="line">            ,(force consequent)))</div></div><!-- fragment --><p><code>;; Так. потому что, пока что покрывается только образец ?is</code></p>
<div class="fragment"><div class="line">;; it is the only one used in simplification rules.</div><div class="line">;; Other patterns could be compiled by adding code here.</div><div class="line">;; Or we could switch to a data-driven approach.</div><div class="line">(t ;; Check the operator and arguments</div></div><!-- fragment --><p>` '(if (op? ,var ',(exp-op pattern))`</p>
<div class="fragment"><div class="line">,(compile-args var pattern consequent)))))</div></div><!-- fragment --><p>Функция <code>compile-args</code> используется для проверки аргументов образца. Она генерирует форму <code>let</code>, связывающую одну или две новые переменные (для унарного или бинарного выражения), а затем вызывает <code>compile-exp</code> для генерации кода, который фактически выполняет тесты. Она просто передает продолжение, <code>consquent</code>, в <code>compile-exp</code>.</p>
<div class="fragment"><div class="line">(defun compile-args (var pattern consequent)</div><div class="line">    &quot;Compile code that checks the arg or args, and does consequent</div><div class="line">    if the arg(s) match.&quot;</div><div class="line">    ;; First make up variable names for the arg(s).</div><div class="line">    (let ((L (symbol var &#39;L))</div><div class="line">                (R (symbol var &#39;R)))</div><div class="line">        (if (exp-rhs pattern)</div><div class="line">                ;; two arg case</div><div class="line">                &#39;(let ((,L (exp-lhs ,var))</div><div class="line">                              (,R (exp-rhs ,var)))</div><div class="line">                      ,(compile-exp L (exp-lhs pattern)</div><div class="line">                                                  (delay</div><div class="line">                                                      (compile-exp R (exp-rhs pattern)</div><div class="line">                                                                                consequent))))</div><div class="line">                ;; one arg case</div><div class="line">                &#39;(let ((,L (exp-lhs ,var)))</div><div class="line">                      ,(compile-exp L (exp-lhs pattern) consequent)))))</div></div><!-- fragment --><p>Остальные функции попроще. <code>build-exp</code> генерирует код для построения правой части <code>rule, op?</code>, проверяющий, является ли его первый аргумент выражением с заданным оператором, а <code>symbol</code> создает новый символ. Также указан <code>new-symbol</code>, хотя он не используется в этой программе.</p>
<div class="fragment"><div class="line">(defun build-exp (exp bindings)</div><div class="line">    &quot;Compile code that will build the exp, given the bindings.&quot;</div><div class="line">    (cond ((assoc exp bindings) (rest (assoc exp bindings)))</div><div class="line">                ((variable-p exp)</div><div class="line">                  (error &quot;Variable  ~  a occurred on right-hand side,~</div><div class="line">                                but not left.&quot; exp))</div><div class="line">                ((atom exp) &quot;,exp)</div><div class="line">                (t (let ((new-exp (mapcar #&#39;(lambda (x)</div><div class="line">                                                                          (build-exp x bindings))</div><div class="line">                                                                      exp)))</div><div class="line">                          &#39;(simplify-exp (list .,new-exp))))))</div></div><!-- fragment --><p><code>(defun op? (exp op)</code></p>
<div class="fragment"><div class="line">    &quot;Does the exp have the given op as its operator?&quot;</div><div class="line">    (and (exp-p exp) (eq (exp-op exp) op)))</div><div class="line">(defun symbol (&amp;rest args)</div><div class="line">    &quot;Concatenate symbols or strings to form an interned symbol&quot;</div><div class="line">    (intern (format nil &quot;~{~a~}&quot; args)))</div><div class="line">(defun new-symbol (&amp;rest args)</div><div class="line">    &quot;Concatenate symbols or strings to form an uninterned symbol&quot;</div><div class="line">    (make-symbol (format nil &quot;~{~a~}&quot; args)))</div></div><!-- fragment --><p>Вот несколько примеров работы компилятора:</p>
<div class="fragment"><div class="line">&gt; (compile-rule &#39;(= (log (^ e x)) x))</div><div class="line">(LAMBDA (X)</div></div><!-- fragment --><p><code>(IF (OP? X 'LOG)</code></p>
<div class="fragment"><div class="line">(LET ((XL (EXP-LHS X)))</div></div><!-- fragment --><p>` (IF (OP? XL '^`</p>
<div class="fragment"><div class="line">                    (LET ((XLL (EXP-LHS XL))</div><div class="line">                                (XLR (EXP-RHS XL)))</div><div class="line">                      (IF (EQL XLL &#39;E)</div><div class="line">                                XLR))))))</div><div class="line">&gt; (compile-rule (simp-rule &#39;(n * (m * x)  =  (n * m) * x)))</div><div class="line">(LAMBDA (X)</div></div><!-- fragment --><p>` (IF (OP? X '*)`</p>
<div class="fragment"><div class="line">(LET ((XL (EXP-LHS X))</div><div class="line">            (XR (EXP-RHS X)))</div><div class="line">    (IF (NUMBERP XL)</div></div><!-- fragment --><p>` (IF (OP? XR '*)`</p>
<div class="fragment"><div class="line">(LET ((XRL (EXP-LHS XR))</div><div class="line">            (XRR (EXP-RHS XR)))</div><div class="line">    (IF (NUMBERP XRL)</div><div class="line">        (SIMPLIFY-EXP</div><div class="line">            (LIST &#39;*</div><div class="line">                        (SIMPLIFY-EXP (LIST &#39;* XL XRL))</div><div class="line">                        XRR)))))))))</div></div><!-- fragment --><h4>Компилятор с набором правил</h4>
<p>Следующим шагом является объединение кода, сгенерированного этим компилятором одного правила, для создания более компактного кода для наборов правил. Мы разделим полный набор правил на подмножества на основе главного оператора (как мы это делали с функцией <code>rules-for</code>) и сгенерируем по одной большой функции для каждого оператора. Нам нужно сохранить порядок правил, поэтому возможны только определенные оптимизации, но если мы сделаем предположение, что ни одна функция не имеет побочных эффектов (безопасное предположение в этом приложении), мы все равно можем работать довольно хорошо. Мы будем использовать средство <code>simp-fn</code>, чтобы установить одну большую функцию для каждого оператора.</p>
<p>Функция <code>compile-rule-set</code> принимает оператор, находит все правила для этого оператора и компилирует каждое правило индивидуально. (Она использует <code>compile-indexed-rule</code>, а не <code>compile-rule</code>, поскольку предполагает, что мы уже выполнили индексацию для основного оператора.) После того, как каждое правило было скомпилировано, они объединяются с помощью <code>comb-rules</code>, который объединяет похожие части правил и объединяет разные части. Результат оборачивается <code>лямбда</code>-выражением и компилируется как последняя функция упрощения для оператора.</p>
<div class="fragment"><div class="line">(defun compile-rule-set (op)</div><div class="line">    &quot;Compile all rules indexed under a given main op,</div><div class="line">    and make them into the simp-fn for that op.&quot;</div><div class="line">    (set-simp-fn op</div><div class="line">        (compile nil</div><div class="line">            &#39;(lambda (x)</div><div class="line">                ,(reduce #&#39;combine-rules</div><div class="line">                                  (mapcar #&#39;compile-indexed-rule</div><div class="line">                                                (rules-for op)))))))</div><div class="line">(defun compile-indexed-rule (rule) .</div><div class="line">    &quot;Compile one rule into lambda-less code,</div><div class="line">    assuming indexing of main op.&quot;</div><div class="line">    (let ((*bindings* nil))</div><div class="line">        (compile-args</div><div class="line">            &#39;x (exp-lhs rule)</div><div class="line">            (delay (build-exp (exp-rhs rule) *bindings*)))))</div></div><!-- fragment --><p>Вот два примера того, что генерирует правило <code>compile-indexed-rule</code>:</p>
<div class="fragment"><div class="line">&gt; (compile-indexed-rule &#39;(= (log 1) 0))</div><div class="line">  (LET ((XL (EXP-LHS X)))</div><div class="line">    (IF (EQL XL &#39;1)</div><div class="line">            &#39;0))</div><div class="line">&gt; (compile-indexed-rule &#39;(= (log (^ e x)) x))</div><div class="line">  (LET ((XL (EXP-LHS X)))</div></div><!-- fragment --><p>` (IF (OP? XL '^)`</p>
<div class="fragment"><div class="line">(LET ((XLL (EXP-LHS XL))</div><div class="line">            (XLR (EXP-RHS XL)))</div><div class="line">    (IF (EQL XLL &#39;E)</div><div class="line">              XLR))))</div></div><!-- fragment --><p>Следующий шаг - объединить несколько этих правил в одно. Функция <code>comb-rules</code> берет два правила и объединяет их в максимально возможной степени.</p>
<div class="fragment"><div class="line">(defun combine-rules (a b)</div><div class="line">    &quot;Combine the code for two rules into one, maintaining order.&quot;</div><div class="line">    ;; In the default case, we generate the code (or a b),</div><div class="line">    ;; but we try to be cleverer and share common code,</div><div class="line">    ;; on the assumption that there are no side-effects.</div><div class="line">    (cond ((and (listp a) (listp b)</div><div class="line">                            (= (length a) (length b) 3)</div><div class="line">                            (equal (first a) (first b))</div><div class="line">                            (equal (second a) (second b)))</div><div class="line">                ;; a  =  (f x y), b  =  (f x z) =&gt;  (f x (combine-rules y z))</div><div class="line">                ;; This can apply when f=IF or f=LET</div><div class="line">                (list (first a) (second a)</div><div class="line">                            (combine-rules (third a) (third b))))</div><div class="line">              ((matching-ifs a b)</div><div class="line">                (if ,(second a)</div><div class="line">                        ,(combine-rules (third a) (third b))</div><div class="line">                        ,(combine-rules (fourth a) (fourth b))))</div><div class="line">              ((starts-with a &#39;or)</div><div class="line">                ;;    a  =  (or ... (if p y)), b  =  (if p z) =&gt;</div><div class="line">                ;;              (or ... (if p (combine-rules y z)))</div><div class="line">                ;; else</div><div class="line">                ;;    a  =  (or ...) b =  &gt;  (or ... b)</div><div class="line">                (if (matching-ifs (lastl a) b)</div><div class="line">                        (append (butlast a)</div><div class="line">                                        (list (combine-rules (lastl a) b)))</div><div class="line">                        (append a (list b))))</div></div><!-- fragment --><p><code>(t ; ; a. b = &gt; (or a b)</code></p>
<div class="fragment"><div class="line">                    &#39;(or ,a ,b))))</div><div class="line">(defun matching-ifs (a b)</div><div class="line">    &quot;Are a and b if statements with the same predicate?&quot;</div><div class="line">    (and (starts-with a &#39;if) (starts-with b &#39;if)</div><div class="line">              (equal (second a) (second b))))</div><div class="line">(defun lastl (list)</div><div class="line">    &quot;Return the last element (not last cons cell) of list&quot;</div><div class="line">    (first (last list)))</div></div><!-- fragment --><p>Вот что делает <code>comb-rules</code> с двумя сгенерированными выше правилами:</p>
<div class="fragment"><div class="line">&gt; (combine-rules</div><div class="line">        &#39;(let ((xl (exp-lhs x))) (if (eql xl &#39;1) &#39;0))</div><div class="line">        &#39;(let ((xl (exp-lhs x)))</div></div><!-- fragment --><p>` (if (op? xl '^)`</p>
<div class="fragment"><div class="line">                      (let ((xl1 (exp-lhs xl))</div><div class="line">                                (xlr (exp-rhs xl)))</div><div class="line">                          (if (eql xll &#39;e) xlr)))))</div><div class="line">(LET ((XL (EXP-LHS X)))</div><div class="line">    (OR (IF (EQL XL &#39;1) &#39;0)</div></div><!-- fragment --><p>` (IF (OP? XL '^)`</p>
<div class="fragment"><div class="line">(LET ((XLL (EXP-LHS XL))</div><div class="line">            (XLR (EXP-RHS XL)))</div><div class="line">    (IF (EQL XLL &#39;E) XLR)))))</div></div><!-- fragment --><p>Теперь мы запускаем компилятор, вызывая <code>compile-all-rules-indexed</code> и показываем комбинированную скомпилированную функцию упрощения для журнала. Комментарии были введены вручную, чтобы показать, какие правила упрощения где скомпилированы.</p>
<div class="fragment"><div class="line">(defun compile-all-rules-indexed (rules)</div><div class="line">    &quot;Compile a separate fn for each operator, and store it</div><div class="line">    as the simp-fn of the operator.&quot;</div><div class="line">    (index-rules rules)</div><div class="line">    (let ((all-ops (delete-duplicates (mapcar #&#39;main-op rules))))</div><div class="line">        (mapc #&#39;compile-rule-set ail-ops)))</div><div class="line">&gt; (compile-all-rules-indexed *simplification-rules*)</div><div class="line">(SIN COS LOG  ^  * / -  +  D)</div><div class="line">&gt; (simp-fn &#39;log)</div><div class="line">(LAMBDA (X)</div><div class="line">    (LET ((XL (EXP-LHS X)))</div><div class="line">        (OR (IF (EQL XL &#39;1)</div><div class="line">                        &#39;0)                                        ;*log 1  =  0*</div><div class="line">                (IF (EQL XL &#39;0)</div><div class="line">                        &#39;UNDEFINED)                        ;*log 0  =  undefined*</div><div class="line">                (IF (EQL XL &#39;E)</div><div class="line">                        &#39;1)                                        ;*log e  =  1*</div></div><!-- fragment --><p>` (IF (OP? XL '^)`</p>
<div class="fragment"><div class="line">(LET ((XLL (EXP-LHS XL))</div><div class="line">            (XLR (EXP-RHS XL)))</div><div class="line">  (IF (EQL XLL &#39;E)</div><div class="line">            XLR))))))              ;*log ex  =  x*</div></div><!-- fragment --><p>Если мы хотим полностью обойти упрощение, основанное на правилах, мы можем еще раз изменить <code>simpleify-exp</code>, чтобы исключить проверку правил:</p>
<div class="fragment"><div class="line">(defun simplify-exp (exp)</div><div class="line">    &quot;Simplify by doing arithmetic, or by using the simp function</div></div><!-- fragment --><p><code>supplied for this operator. Do not use rules of any kind."</code></p>
<div class="fragment"><div class="line">(cond ((simplify-by-fn exp))</div><div class="line">            ((evaluable exp) (eval exp))</div><div class="line">            (t exp)))</div></div><!-- fragment --><p>Наконец, мы можем провести тест производительности на новом скомпилированном коде; функция <code>test-it</code> выполняется примерно за 0,15 секунды с запоминанием(memoization) и 0,05 без. Почему мемоизация, которая помогала раньше, теперь вредит нам? Вероятно, потому, что при доступе к хеш-таблице возникают большие накладные расходы, и эти накладные расходы окупаются только тогда, когда есть много других вычислений.</p>
<p>По сравнению с исходным кодом мы увидели значительное улучшение, как показано в следующей таблице. В целом, различные улучшения эффективности привели к увеличению скорости в 130 раз - теперь мы можем сделать за минуту то, что раньше занимало два часа. Конечно, нужно иметь в виду, что статистика хороша только для этого конкретного набора тестовых данных на этой единственной машине. Это открытый вопрос, какую производительность вы получите на других задачах и на других машинах.</p>
<p>В следующей таблице приведены время выполнения и количество вызовов функций для тестовых данных:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td></td><td>original </td><td>memo </td><td>memo + index </td><td>memo + comp </td><td>comp </td></tr>
<tr>
<td>run time (secs) </td><td>6.6 </td><td>3.0 </td><td>.98 </td><td>.15 </td><td>.05 </td></tr>
<tr>
<td>speed-up </td><td>- </td><td>2 </td><td>7 </td><td>44 </td><td>130 </td></tr>
</table>
<p>| calls | | pat-match | 51690 | 20003 | 5159 | 0 | 0 | | variable-p | 37908 | 14694 | 4798 | 0 | 0 | | match-variable | 1393 | 551 | 551 | 0 | 0 | | simplify | 906 | 408 | 408 | 545 | 906 | | simplify-exp | 274 | 118 | 118 | 118 | 274 |</p>
<h2>9.7 История и ссылки</h2>
<p>The idea of memoization was introduced by Donald Michie 1968. He proposed using a list of values rather than a hash table, so the savings was not as great. In mathematics, the field of dynamic programming is really just the study of how to compute values in the proper order so that partial results will already be cached away when needed.</p>
<p>A large part of academic computer science covers compilation; <a href="B9780080571157500285.xhtml#bb0015">Aho and Ullman 1972</a> is just one example. The technique of compiling embedded languages (such as the language of pattern-matching rules) is one that has achieved much more attention in the Lisp community than in the rest of computer science. See <a href="B9780080571157500285.xhtml#bb0365">Emanuelson and Haraldsson 1980</a>, for an example.</p>
<p>Choosing the right data structure, indexing it properly, and defining algorithms to operate on it is another important branch of computer science; <a href="B9780080571157500285.xhtml#bb1065">Sedgewick 1988</a> is one example, but there are many worthy texts.</p>
<p>Delaying computation by packaging it up in a <code>lambda</code> expression is an idea that goes back to Algol's use of <em>thunks</em>-a mechanism to implement call-by-name parameters, essentially by passing functions of no arguments. The name <em>thunk</em> comes from the fact that these functions can be compiled: the system does not have to think about them at run time, because the compiler has already thunk about them. Peter <a href="B9780080571157500285.xhtml#bb0570">Ingerman 1961</a> describes thunks in detail. <a href="B9780080571157500285.xhtml#bb0010">Abelson and Sussman 1985</a> cover delays nicely. The idea of eliminating unneeded computation is so attractive that entire languages have built around the concept of <em>lazy evaluation</em>-don't evaluate an expression until its value is needed. See <a href="B9780080571157500285.xhtml#bb0565">Hughes 1985</a> or <a href="B9780080571157500285.xhtml#bb0400">Field and Harrison 1988</a>.</p>
<h2>9.8 Упражнения</h2>
<p><b>Упражнение 9.3 [d]</b> В этой главе мы представили компилятор для <code>simplify</code>. Не намного сложнее расширить этот компилятор, чтобы он мог использовать все возможности <code>pat-match</code>. Вместо того, чтобы смотреть только на выражения, разрешите деревья с переменными в любой позиции. Расширить и обобщить определения compile-rule и compile-rule-set, чтобы их можно было использовать в качестве общего инструмента для любой прикладной программы, которая использует pat-match и/или rule-based-translator. . Убедитесь, что компилятор управляется данными, чтобы программист, добавляющий новый тип шаблона в <code>pat-match</code>, также мог указать компилятору, как с ним работать. Одна сложная часть будет учитывать сегментные переменные. Стоит потратить немало усилий во время компиляции, чтобы сделать это эффективным во время выполнения.</p>
<p><b>Упражнение 9.4 [m]</b> Определите время вычисления (fib n) без мемоизации как <em>Tn</em>. Напишите формулу для выражения <em>Tn</em>. Учитывая, что *T*25 &amp; asymp; 1,1 секунды, предсказать *T*100.</p>
<p><b>Упражнение 9.5 [m]</b> Рассмотрим версию игры Ним, в которую играют следующим образом: есть стопка из <em>n</em> жетонов. Два игрока по очереди убирают жетоны из стопки; на каждом ходу игрок должен взять один, два или три жетона. Выигрывает тот, кто берет последний жетон. Напишите программу, которая при заданном <em>n</em> возвращает количество жетонов, которые нужно взять для обеспечения выигрыша, если это возможно. Анализируйте время выполнения вашей программы с мемоизацией и без нее.</p>
<p><b>Упражнение 9.6 [m]</b> Более сложная игра в стиле Нима известна как игра Гранди. Игра начинается с одной стопки из * n * жетонов. Каждый игрок должен выбрать одну стопку и разделить ее на две неравные стопки. Первый игрок, который не может двигаться, проигрывает. Напишите программу, чтобы играть в игру Гранди, и посмотрите, как помогает запоминание.</p>
<p><b>Упражнение 9.7 [h]</b> Это упражнение описывает более сложную игру одного человека. В этой игре игрок восемь раз бросает шестигранный кубик. Игрок формирует четыре двузначных десятичных числа так, чтобы сумма четырех чисел была как можно больше, но не превышала 170. Всего 171 или более баллов оцениваются как ноль.</p>
<p>Игра была бы детерминированной и совершенно скучной, если бы не требование, согласно которому после каждого броска игрок должен немедленно помещать цифру в столбец единиц или десятков одного из четырех чисел.</p>
<p>Вот образец игры. Игрок сначала выбрасывает 3 и помещает его в столбец единиц первого числа, затем бросает 4 и помещает его в столбец десятков и так далее. В последнем броске игрок выбрасывает 6 и в итоге получает 180. Поскольку это значение превышает предел 170, окончательный счет игрока равен 0.</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>roll </td><td>3 </td><td>4 </td><td>6 </td><td>6 </td><td>3 </td><td>5 </td><td>3 </td><td>6 </td></tr>
<tr>
<td>lst num. </td><td>-3 </td><td>43 </td><td>43 </td><td>43 </td><td>43 </td><td>43 </td><td>43 </td><td>43 </td></tr>
<tr>
<td>2nd num. </td><td>- </td><td>- </td><td>-6 </td><td>-6 </td><td>36 </td><td>36 </td><td>36 </td><td>36 </td></tr>
<tr>
<td>3rd num. </td><td>- </td><td>- </td><td>- </td><td>-6 </td><td>-6 </td><td>-6 </td><td>36 </td><td>36 </td></tr>
<tr>
<td>4th num. </td><td>- </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-5 </td><td>-5 </td><td>65 </td></tr>
<tr>
<td>total </td><td>03 </td><td>43 </td><td>49 </td><td>55 </td><td>85 </td><td>90 </td><td>120 </td><td>0 </td></tr>
</table>
<p>Напишите функцию, которая позволит вам играть в игру или серию игр. Функция должна принимать в качестве аргумента функцию, представляющую стратегию игры.</p>
<p><b>Упражнение 9.8 [h]</b> Определите хорошую стратегию игры в кости, описанной выше. (Подсказка: моя стратегия получила в среднем 143,7 балла.)</p>
<p><b>Упражнение 9.9 [m]</b> Одной из проблем, возникающих при игре в игры со случайными числами, является вероятность того, что игрок может обмануть, выяснив, что <code>random</code> будет делать дальше. Прочтите определение функции random и опишите, как игрок может обмануть. Затем опишите контрмеру.</p>
<p><b>Упражнение 9.10 [м]</b> На <a href="B9780080571157500091.xhtml#p292">стр. 292</a> мы видели использование условных выражений времени чтения, #+ и #-, где #+ - время чтения, эквивалентное when, и #- это время чтения, эквивалентное unless. К сожалению, не существует времени чтения эквивалентное case. Реализуйте один.</p>
<p><b>Упражнение 9.11 [h]</b> Напишите компилятор для ELIZA, который объединяет все правила сразу в одну функцию. Насколько эффективнее скомпилированная версия?</p>
<p><b>Упражнение 9.12 [d]</b> Напишите несколько правил для упрощения кода Lisp. Некоторые из правил алгебраического упрощения будут по-прежнему действовать, но потребуются новые правила для упрощения неалгебраических функций и специальных форм. (Поскольку <code>nil</code> является допустимым выражением в этом домене, вам придется иметь дело с проблемой полупредиката.) Вот несколько примеров правил (с использованием префиксной записи):</p>
<div class="fragment"><div class="line">(= (+ x 0) x)</div><div class="line">(= &#39;nil nil) (</div><div class="line">(= (car (cons x y)) x)</div><div class="line">(= (cdr (cons x y)) y)</div><div class="line">(= (if t x y) x)</div><div class="line">(= (if nil x y) y)</div><div class="line">(= (length nil) 0)</div><div class="line">(= (expt y (?if x numberp)) (expt (expt y (/ x 2)) 2))</div></div><!-- fragment --><p><b>Упражнение 9.13 [m]</b> Рассмотрим следующие две версии алгоритма решета Эратосфена. Второй явно связывает локальную переменную. Это того стоит?</p>
<div class="fragment"><div class="line">(defun sieve (pipe)</div><div class="line">    (make-pipe (head pipe)</div><div class="line">                          (filter #&#39;(lambda (x)(/= (mod x (headpipe)) 0))</div><div class="line">                                        (sieve (tail pipe)))))</div><div class="line">(defun sieve (pipe)</div><div class="line">    (let ((first-num (head pipe)))</div><div class="line">        (make-pipe first-num</div><div class="line">                              (filter #&#39;(lambda (x) (/= (mod x first-num) 0))</div><div class="line">                                            (sieve (tail pipe))))))</div></div><!-- fragment --><h2>9.9 Ответы</h2>
<p><b>Ответ 9.4</b> Пусть <em>Fn</em> обозначает (<code>fib n</code>). Тогда время для вычисления <em>Fn</em>, <em>Tn</em> будет небольшой константой для <em>n</em> &le; 1 и примерно равен <em>Tn-1</em> плюс <em>Tn-2</em> для большего <em>n</em>. Таким образом, <em>Tn</em> примерно пропорционально <em>Fn</em>:</p>
<p>Tn=FnTiFi</p>
<div class="image">
<img src="images/chapter9/si1_e.gif" alt="si1_e"/>
</div>
<p>Мы могли бы использовать небольшое значение <em>Ti</em> для вычисления *T*100, если бы знали *F*100. К счастью, мы можем использовать уравнение:</p>
<p>Fn&alpha;&Phi;n</p>
<div class="image">
<img src="images/chapter9/si2_e.gif" alt="si2_e"/>
</div>
<p>Где &phi; = (1 + &radic;(5))/2 &asymp; 1.618. Это уравнение было выведено де Муавром в 1718 году (см. Knuth, Donald E. <em>Фундаментальные алгоритмы</em>, стр. 78-83), но число <em>&phi;</em> имеет долгую интересную историю. Евклид назвал это "крайним и средним соотношением", потому что отношение <em>A</em> к <em>B</em> - это отношение <em>A</em> + <em>B</em> к <em>A</em>, если <em>A</em>/*B* равно <em>&phi;</em> . В эпоху Возрождения это называлось "божественной пропорцией", а в прошлом веке оно было известно как "золотое сечение", потому что прямоугольник со сторонами в этом соотношении можно разделить на два меньших прямоугольника, которые имеют одинаковое соотношение между стороны. Говорят, что это приятная пропорция, когда используется в живописи и архитектуре. Отложив историю в сторону, учитывая <em>T*25 &asymp; 1.1 *сек</em> теперь мы можем вычислить:</p>
<p>T100&asymp;&Phi;1001.1sec&Phi;25&asymp;5x1015sec</p>
<div class="image">
<img src="images/chapter9/si3_e.gif" alt="si3_e"/>
</div>
<p>что примерно 150 миллионов лет. Мы также можем видеть, что временные данные в таблице довольно хорошо соответствуют уравнению. Однако можно ожидать дополнительного времени для больших чисел, потому что для добавления и сбора мусора требуется больше времени, чем для фиксированных чисел.</p>
<p><b>Ответ 9.5</b> Сначала определим понятие принудительной победы. Это происходит, когда остается три или меньше жетонов, или когда вы можете сделать ход, который принесет вашему противнику возможную потерю. Возможная потеря - это любая позиция, не являющаяся принудительным выигрышем. Если вы играете идеально, то возможное поражение оппонента фактически будет для вас победой, так как ничей нет. См. Функции <code>win</code> и <code>loss</code> ниже. Теперь ваша стратегия должна заключаться в том, чтобы выиграть игру сразу, если есть три или меньше жетонов, или иным образом выбрать наибольшее число, которое приведет к возможному проигрышу для вашего оппонента. Если вам недоступен такой ход, возьмите только один, на том основании, что ваш противник с большей вероятностью допустит ошибку с большей стопкой, с которой нужно бороться. Эта стратегия воплощена в функции <code>nim</code> ниже.</p>
<div class="fragment"><div class="line">(defun win (n)</div><div class="line">    &quot;Is a pile of n tokens a win for the player to move?&quot;</div><div class="line">    (or (&lt;= n 3)</div><div class="line">            (loss (- n 1))</div><div class="line">            (loss (- n 2))</div><div class="line">            (loss (- n 3))))</div><div class="line">(defun loss (n) (not (win n)))</div><div class="line">(defun nim (n)</div><div class="line">    &quot;Play Nim: a player must take 1-3; taking the last one wins.</div><div class="line">    (con ((&lt;= n 3) n); an immediate win</div><div class="line">            ((loss (- n 3)) 3); an eventual win</div><div class="line">            ((loss (- n 2)) 2); an eventual win</div><div class="line">            ((loss (- n 1)) 1); an eventual win</div><div class="line">            (t 1))); a loss; the 1 is arbitrary</div><div class="line">(memoize &#39;loss)</div></div><!-- fragment --><p>Из этого мы можем составить таблицу времени выполнения (в секундах) с мемоизацией и без нее. Запоминать нужно только <code>loss</code>. (Почему?) У вас есть хорошее объяснение времени для немомизированной версии? Что произойдет, если вы измените порядок предложений loss(потерь/проигрышей) в win и/или nim?</p>
<p><b>Answer 9.6</b> We start by defining a function, <code>moves</code>, which generates all possible moves from a given position. This is done by considering each pile of <em>n</em> tokens within a set of piles <em>s</em>. Any pile bigger than two tokens can be split. We take care to elimina te duplicate positions by sorting each set of piles, and then removing the duplicates.</p>
<div class="fragment"><div class="line">(defun moves (s)</div><div class="line">    &quot;Return a list of all possible moves in Grundy&#39;s game&quot;</div><div class="line">    ;; S is a list of integers giving the sizes of the piles</div><div class="line">    (remove-duplicates</div><div class="line">        (loop for n in s append (make-moves n s))</div><div class="line">        :test #&#39;equal))</div><div class="line">(defun make-moves (n s)</div><div class="line">    (when (&gt;  =  n 2)</div><div class="line">        (let ((s/n (remove n s :count 1)))</div><div class="line">            (loop for i from 1 to (- (ceiling n 2) 1)</div><div class="line">                        collect (sort* (list* i (-  ni) s/n)</div><div class="line">                                                      #&#39;&gt;&gt;))))</div><div class="line">(defun sort* (seq pred &amp;key key)</div><div class="line">  &quot;Sort without altering the sequence&quot;</div><div class="line">  (sort (copy-seq seq) pred :key key))</div></div><!-- fragment --><p>This time a loss is defined as a position from which you have no moves, or one from which your opponent can force a win no matter what you do. A winning position is one that is not a loss, and the strategy is to pick a move that is a loss for your opponent, or if you can't, just to play anything (here we arbitrarily pick the first move generated).</p>
<div class="fragment"><div class="line">(defun loss (s)</div><div class="line">    (let ((choices (moves s)))</div><div class="line">        (or (null choices)</div><div class="line">                (every #&#39;win choices))))</div><div class="line">(defun win (s) (not (loss s)))</div><div class="line">(defun grundy (s)</div><div class="line">    (let ((choices (moves s)))</div><div class="line">        (or (find-if #&#39;loss choices)</div><div class="line">                (first choices))))</div></div><!-- fragment --><p><b>Answer 9.7</b> The answer assumes that a strategy function takes four arguments: the current die roll, the score so far, the number of remaining positions in the tens column, and the number of remaining positions in the ones column. The strategy function should return 1 or 10.</p>
<div class="fragment"><div class="line">(defun play-games (&amp;optional (n-games 10) (player &#39;make-move))</div></div><!-- fragment --><p><code>"A driver for a simple dice game. In this game the player</code></p>
<p><code>rolls a six-sided die eight times. The player forms four</code></p>
<div class="fragment"><div class="line">two-digit decimal numbers such that the total of the four</div><div class="line">numbers is as high as possible, but not higher than 170.</div></div><!-- fragment --><p><code>A total of 171 or more gets scored as zero. After each die</code></p>
<div class="fragment"><div class="line">    is rolled, the player must decide where to put it.</div><div class="line">    This function returns the player&#39;s average score.&quot;</div><div class="line">    (/ (loop repeat n-games summing (play-game player 0 4 4))</div><div class="line">          (float n-games)))</div><div class="line">(defun play-game (player &amp;optional (total 0) (tens 4) (ones 4))</div><div class="line">    (cond ((or (&gt; total 170) (&lt; tens 0) (&lt; ones 0)) 0)</div><div class="line">                ((and (= tens 0) (= ones 0)) total)</div><div class="line">                (t (let ((die (roll-die)))</div><div class="line">                        (case (funcall player die total tens ones)</div><div class="line">                          (1 (play-game player (+ total die)</div><div class="line">                                                      tens (- ones 1)))</div><div class="line">                          (10 (play-game player (+ total (* 10 die))</div><div class="line">                                                      (- tens 1) ones))</div><div class="line">                          (t 0))))))</div><div class="line">(defun roll-die () (+  1 (random 6)))</div></div><!-- fragment --><p>So, the expression <code>(play-games 5 #'make-move)</code> would play five games with a strategy called <code>make-move</code>. This returns only the average score of the games; if you want to see each move as it is played, use this function:</p>
<div class="fragment"><div class="line">(defun show (player)</div><div class="line">    &quot;Return a player that prints out each move it makes.&quot;</div><div class="line">    #&#39;(lambda (die total tens ones)</div><div class="line">            (when (= total 0) (fresh-line))</div><div class="line">            (let ((move (funcall player die total tens ones)))</div><div class="line">                (incf total (* die move))</div><div class="line">                (format t &quot;~2d-&gt; ~  3d |  ~  @[*~]&quot; (* move die) total (&gt; total 170))</div><div class="line">                  move)))</div></div><!-- fragment --><p>and call <code>(play-games 5 (show #'make-moves))</code>.</p>
<p><b>Answer 9.9</b> The expression <code>(random 6 (make-random-state))</code> returns the next number that <code>roll-die</code> will return. To guard against this, we can make <code>roll-die</code> use a random state that is not accessible through a global variable:</p>
<div class="fragment"><div class="line">(let ((state (make-random-state t)))</div><div class="line">    (defun roll-die () (+  1 (random 6 state))))</div></div><!-- fragment --><p><b>Answer 9.10</b> Because this has to do with read-time evaluation, it must be implemented as a macro or read macro. Here's one way to do it:</p>
<div class="fragment"><div class="line">(defmacro read-time-case (first-case &amp;rest other-cases)</div><div class="line">  &quot;Do the first case, where normally cases are</div><div class="line">  specified with #+ or possibly #- marks.&quot;</div><div class="line">  (declare (ignore other-cases))</div><div class="line">  first-case)</div></div><!-- fragment --><p>A fanciful example, resurrecting a number of obsolete Lisps, follows:</p>
<div class="fragment"><div class="line">(defun get-fast-time ()</div><div class="line">    (read-time-case</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>#+Explorer</code> </td><td><code>(time :microsecond-time)</code> </td></tr>
<tr>
<td><code>#+Franz</code> </td><td><code>(sys:time)</code> </td></tr>
<tr>
<td><code>#+(or PSL UCI)</code> </td><td><code>(time)</code> </td></tr>
<tr>
<td><code>#+YKT</code> </td><td><code>(currenttime)</code> </td></tr>
<tr>
<td><code>#+MTS</code> </td><td><code>(status 39)</code> </td></tr>
<tr>
<td><code>#+Interlisp</code> </td><td><code>(clock 1)</code> </td></tr>
<tr>
<td><code>#+Lispl.5</code> </td><td><code>(tempus-fugit)</code> </td></tr>
<tr>
<td><code>;; otherwise</code> </td><td></td></tr>
<tr>
<td></td><td><code>(get-internal-real-time)))</code> </td></tr>
</table>
<p><b>Answer 9.13</b> Yes. Computing (<code>head pipe</code>) may be a trivial computation, but it will be done many times. Binding the local variable makes sure that it is only done once. In general, things that you expect to be done multiple times should be moved out of delayed functions, while things that may not be done at all should be moved inside a delay. </p><hr/>
<p><a href="#xfn0010">1</a> One could say that the FORTRAN compiler was "broken." This underscores the problem of defining the efficiency of a language-do we judge by the most popular compiler, by the best compiler available, or by the best compiler imaginable? !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0015">2</a> In KCL, the symbol <code>lambda-closure</code> is used, and in Allegro, it is <code>excl:. lexical-closure</code> !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">3</a> The terms <em>metering</em> and <em>monitoring</em> are sometimes used instead of profiling. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
