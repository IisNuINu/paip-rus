<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 21</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 21 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Грамматика английского языка</h2>
<blockquote class="doxtable">
<p>Предпочитаю сердечность грамматике. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Henry Watson Fowler </p>
</blockquote>
<blockquote class="doxtable">
<p><em>The King's English</em> (1906) </p>
</blockquote>
<p>В предыдущих двух главах описываются методы написания грамматик и синтаксических анализаторов на основе этих грамматик. Эти методы довольно просто применить к приложениям, таким как проблема с проигрывателем компакт-дисков, где ввод ограничен простыми предложениями, такими как "Play 1 to 8 without 3"(Воспроизвести с 1 по 8 без 3). Но написать грамматику для неограниченного ввода английского языка - серьезная задача. В этой главе разрабатывается грамматика, охватывающая все основные синтаксические конструкции английского языка. Она обрабатывает предложения гораздо большей сложности, такие как "Kim would not have been persuaded by Lee to look after the dog"(Ли не убедил Ким присматривать за собакой). Грамматика не является достаточно всеобъемлющей, чтобы обрабатывать предложения, случайно выбранные из книги, но когда она дополняется подходящей лексикой, она подходит для самых разных применений.</p>
<p>Эта глава организована как экскурсия по английскому языку. Сначала мы охватываем фразы существительных, затем глагольные фразы, предложения(clauses) и утверждения/изречения(sentences). Для каждой категории мы вводим примеры, анализируем их лингвистически и, наконец, показываем правила грамматики определенных предложений, которые соответствуют анализу.</p>
<p>Как должно было быть ясно из предыдущей главы, анализ чаще приводит к усложнению, чем к упрощению. Например, начиная с простого правила, такого как <code>(S --&gt; NP VP)</code>, мы вскоре обнаруживаем, что должны добавлять аргументы для обработки согласования, семантики и информации о пропусках(разрывах). <a href="#f0010">Рисунок 21.1</a> перечисляет грамматические категории и их аргументы. Обратите внимание, что семантический аргумент, <code>sem</code>, всегда является последним, а аккумуляторы разрывов, <code>gap1</code> и <code>gap2</code>, являются предпоследними, когда они встречаются. Все однобуквенные аргументы обозначают метапеременные; например, каждая фраза существительного (категория NP) будет иметь семантическую интерпретацию, <code>sem</code>, то есть конъюнкцию отношений, включающих переменную <code>x</code>. Точно так же модификаторы hin(<code>hin modifiers</code>) - это переменная, которая ссылается на заголовок, то есть к изменяемой вещи. Другие аргументы и категории будут объяснены по очереди, но полезно иметь эту картинку, чтобы вернуться к ней.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter21/f21-01.jpg" alt="f21-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 21.1: Грамматические категории и их аргументы </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<h2>21.1 Фразы существительных(Noun Phrases)</h2>
<p>Самыми простыми фразами существительных являются имена(names) и местоимения(pronouns), например "Kim"(Ким) и "them."(они). Правила для этих случаев просты: мы создаем семантическое выражение из имени или местоимения, и, поскольку разрывов быть не может, два аргумента аккумулятора разрывов являются одинаковыми <code>(?g1)</code>. Согласование лица и числа передается в переменной <code>?agr</code>, и мы также отслеживаем <em>падеж</em> фразы существительного. В английском есть три падежа, которые отражены в определенных местоимениях. В первом лице единственного числа, "I"(я) - это <em>именительный</em> или <em>субъективный</em> падеж, "me"(мне) - <em>винительный</em> или <em>объективный</em> падеж и "my"(мой) - <em>родительный</em> падеж. Чтобы отличить их от родительного падежа, мы называем именительный и объективный падежи <em>общими</em> падежами. Соответственно, эти три случая будут отмечены выражениями <code>(common nom), (common obj),</code> и <code>gen</code> соответственно. Во многих языках мира есть суффиксы(suffixes), обозначающие существительные в том или ином падеже, но в английском нет. Таким образом, мы используем выражение <code>(common ?)</code> Для обозначения существительных.</p>
<p>Мы также различаем фразы существительных, которые можно использовать в вопросах, например "who"(кто), и те, которые нельзя использовать. Переменная <code>?wh</code> имеет значение <code>+wh</code> для таких фраз существительных, как "who" или "which one", и <code>-wh</code> для фраз без вопросов. Итак, вот правила для имен и местоимений. Предикаты <code>name</code> и <code>pronoun</code> используются для поиска слов в лексиконе.</p>
<div class="fragment"><div class="line">(rule (NP ?agr (common ?) -wh ?x ?g1 ?g1 (the ?x (name ?name ?x))) ==&gt;</div><div class="line">  (name ?agr ?name))</div><div class="line"></div><div class="line">(rule (NP ?agr ?case ?wh ?x ?g1 ?g1 ?sem) ==&gt;</div><div class="line">  (pronoun ?agr ?case ?wh ?x ?sem))</div></div><!-- fragment --><p>Существительные во множественном числе могут стоять отдельно в составе фраз существительных, например, "dogs"(собаки), но существительные в единственном числе нуждаются в определителе, например, "the dog"(собака) или "Kim's friend's biggest dog."(самая большая собака друга Кима). Существительные множественного числа также могут иметь определитель, например, "the dogs"(собаки). Категория Det используется для определителей, а NP2 используется для части фразы существительного после определителя:</p>
<div class="fragment"><div class="line">(rule (NP (- - - +) ?case -wh ?x ?g1 ?g2 (group ?x ?sem)) ==&gt;</div><div class="line">  (:ex &quot;dogs&quot;) ; Plural nouns don&#39;t need a determiner</div><div class="line">  (NP2 (- - - +) ?case ?x ?g1 ?g2 ?sem))</div><div class="line"></div><div class="line">(rule (NP ?agr (common ?) ?wh ?x ?g1 ?g2 ?sem) ==&gt;</div><div class="line">  (:ex &quot;Every man&quot; &quot;The dogs on the beach&quot;)</div><div class="line">  (Det ?agr ?wh ?x ?restriction ?sem)</div><div class="line">  (NP2 ?agr (common ?) ?x ?g1 ?g2 ?restriction))</div></div><!-- fragment --><p>Наконец, фраза существительного может появляться снаружи конструкции, и в этом случае будет использована фраза существительного, переданная первым аргументом разрыва, но не слова из входных данных. Примером может служить  в "Whom does Kim like &amp;blank;?"(Кому нравится Ким ?)</p>
<div class="fragment"><div class="line">(rule (NP ?agr ?case ?wh ?x (gap (NP ?agr ?case ?x)) (gap nil) t)</div><div class="line">  ==&gt; ;; Gapped NP</div><div class="line">  )</div></div><!-- fragment --><p>Теперь обратимся к сути фразы существительного - категории <code>NP2</code>. Единственное правило для <code>NP2</code> гласит, что оно состоит из существительного, которому могут предшествовать модификаторы и следовать за ним:</p>
<div class="fragment"><div class="line">(rule (NP2 ?agr (common ?) ?x ?g1 ?g2 :sem) ==&gt;</div><div class="line">  (modifiers pre noun ?agr () ?x (gap nil) (gap nil) ?pre)</div><div class="line">  (noun ?agr ?slots ?x ?noun)</div><div class="line">  (modifiers post noun ?agr ?slots ?x ?g1 ?g2 ?post))</div></div><!-- fragment --><h2>21.2 Модификаторы(Modifiers)</h2>
<p>Модификаторы делятся на типы: <em>Дополнения</em>(<em>Complements</em>) - это модификаторы, ожидаемые изменяемой категорией заголовка; они не могут оставаться в одиночестве. <em>Адъюнкты/Добавка</em>(Adjuncts) - это модификаторы, которые не требуются, но несут дополнительную информацию. Различие наиболее очевидно с модификаторами глаголов. В "Kim visited Lee yesterday"(Ким посетил Ли вчера), "visited"(посетил) - это заглавный глагол, "Lee"(Ли) - дополнение(complement), а "yesterday"(вчера) - добавочное(adjunct). Возвращаясь к существительным, в "the former mayor of Boston"(бывший мэр Бостона) "mayor"(мэр) является заглавным существительным, "of Boston"(Бостона) - дополнением (хотя и необязательным), а "former"(бывший) - добвкой(adjunct).</p>
<p>Предикат <code>modifiers</code> принимает восемь аргументов, поэтому понять их все может быть сложно. Первые два аргумента говорят, находимся ли мы до или после головы (<code>pre</code> или <code>post</code>) и какой тип головы мы изменяем (<code>noun</code>(существительное), <code>verb</code>(глагол) или что-то еще). Далее идет аргумент, который передает всю необходимую информацию - в случае с существительными это признак согласования(agreement). Четвертый аргумент - это список ожидаемых дополнений(complements), здесь называемых <code>?slots</code>. Далее следует метапеременная, используемая для обозначения головы. Последние три аргумента - это два аккумулятора разрывов и семантика, которые здесь работают так же, как мы видели ранее. Обратите внимание, что в лексиконе для каждого <code>Noun</code>(Существительного) может быть список дополнений(complements), которые рассматриваются как модификаторы пост-существительного(postnoun), но в качестве модификаторов перед существительным могут быть только добления(adjuncts). Также обратите внимание, что разрывы могут появляться в постмодификаторах, но не в предмодификаторах. Например, у нас может быть "What is Kevin the former mayor of &amp;blank;?"(Кто такой Кевин, бывший мэр ?), где ответ может быть "Boston"(Бостон). Но даже несмотря на то, что мы можем построить фразу существительного, например "the education president"(президент образования), где "education"(образование) является пред-существительным модификатором "president"(президент), мы не можем построить "* What is George the &amp;blank; president?,"(Что такое Джордж, президент?), имея в виду, что ответом будет "education"(образование).</p>
<p>Возможны четыре варианта модификации. Во-первых, дополнение(complement) - это своего рода модификатор. Во-вторых, если дополнение помечено как необязательное, его можно пропустить. В-третьих, на входе может появиться адъюнкт/добавка(adjunct). В-четвертых, если не ожидается никаких дополнений, то никаких модификаторов быть не должно. Следующие правила реализуют эти четыре случая:</p>
<div class="fragment"><div class="line">(rule (modifiers ?pre/post ?cat ?info (?slot . ?slots) ?h</div><div class="line">                 ?g1 ?g3 :sem) ==&gt;</div><div class="line">  (complement ?cat ?info ?slot ?h ?g1 ?g2 ?mod)</div><div class="line">  (modifiers ?pre/post ?cat ?info ?slots ?h ?g2 ?g3 ?mods))</div><div class="line"></div><div class="line">(rule (modifiers ?pre/post ?cat ?info ((? (?) ?) . ?slots) ?h</div><div class="line">                 ?g1 ?g2 ?mods) ==&gt;</div><div class="line">  (modifiers ?pre/post ?cat ?info ?slots ?h ?g1 ?g2 ?mods))</div><div class="line"></div><div class="line">(rule (modifiers ?pre/post ?cat ?info ?slots ?h ?g1 ?g3 :sem) ==&gt;</div><div class="line">  (adjunct ?pre/post ?cat ?info ?h ?g1 ?g2 ?adjunct)</div><div class="line">  (modifiers ?pre/post ?cat ?info ?slots ?h ?g2 ?g3 ?mods))</div><div class="line"></div><div class="line">(rule (modifiers ? ? ? () ? ?g1 ?g1 t) ==&gt; )</div></div><!-- fragment --><p>Нам нужно сказать больше о списке дополнений или слотов, которые могут быть связаны со словами в лексиконе(lexcion). Каждый слот представляет собой список формы (<em>role number form)</em>/(роль номер форма), где роль относится к некоторому семантическому отношению, число указывает порядок дополнений, а форма - это тип ожидаемого составляющего: фраза существительного, глагольная фраза, или что угодно. Подробности будут рассмотрены в следующем разделе о глагольных фразах, а <code>complement</code>/дополнение будет рассмотрено в разделе о XP. А пока приведем единственный пример. Список дополнений для одного смысла глагола "visit"(посетить):</p>
<div class="fragment"><div class="line">((agt 1 (NP ?)) (obj 2 (NP ?)))</div></div><!-- fragment --><p>Это означает, что первое дополнение, субъект(подлежащее), является фразой существительного, которая выполняет роль агента, а второе дополнение также является фразой существительного, которая выполняет роль объекта.</p>
<h2>21.3 Модификаторы существительных(Noun Modifiers)</h2>
<p>Есть два основных типа добавок/добавлений(adjuncts) пред существительных. Чаще всего используются прилагательные(adjectives), например, "big slobbery dogs"(большие слюнявые собаки). Существительные также могут быть добавлениями(adjuncts), как в "water meter"(водомер) или "desk lamp"(настольная лампа). Здесь ясно, что второе существительное - голова(главное), а первое - модификатор: desk lamp(настольная лампа) - это лампа, а не стол. Они известны как соединения существительного и существительного. В следующих правилах обратите внимание, что нам не нужно говорить, что допускается более одного прилагательного(adjective); это обрабатывается правилами для <code>modifiers</code>.</p>
<div class="fragment"><div class="line">(rule (adjunct pre noun ?info ?x ?gap ?gap ?sem) ==&gt;</div><div class="line">  (adj ?x ?sem))</div><div class="line"></div><div class="line">(rule (adjunct pre noun ?info ?h ?gap ?gap :sem) ==&gt;</div><div class="line">  (:sem (noun-noun ?h ?x))</div><div class="line">  (noun ?agr () ?x ?sem))</div></div><!-- fragment --><p>После существительного существует более широкий набор модификаторов. У некоторых существительных есть дополнения(complements), которые в основном являются предложными фразами(prepositional phrases), например, "mayor of Boston"(мэр Бостона). Они будут рассмотрены, когда мы перейдем к лексическим статьям для существительных. Предложные фразы могут быть добавлениями(adjuncts) к существительным или глаголам, например, "man in the middle"(человек посередине) и "slept for an hour"(поспал часок). Мы можем написать одно правило для обоих случаев:</p>
<div class="fragment"><div class="line">(rule (adjunct post ?cat ?info ?x ?g1 ?g2 ?sem) ==&gt;</div><div class="line">  (PP ?prep ?prep ?wh ?np ?x ?g1 ?g2 ?sem))</div></div><!-- fragment --><p>Вот правила для предложных фраз, которые могут быть либо предлогом(preposition), за которым следует фраза существительного, либо могут быть разрывом, например, "to whom are you speaking &amp;blank;?"(с кем вы говорите &amp; blank;?) Предлог всегда находится в объективном падеже: "with him"(с ним), а не "*with he"(с ним???с него).</p>
<div class="fragment"><div class="line">(rule (PP ?prep ?role ?wh ?np ?x ?g1 ?g2 :sem) ==&gt;</div><div class="line">  (prep ?prep t)</div><div class="line">  (:sem (?role ?x ?np))</div><div class="line">  (NP ?agr (common obj) ?wh ?np ?g1 ?g2 ?np-sem))</div><div class="line"></div><div class="line">(rule (PP ?prep ?role ?wh ?np ?x</div><div class="line">          (gap (PP ?prep ?role ?np ?x)) (gap nil) t) ==&gt; )</div></div><!-- fragment --><p>Существительные могут быть изменены причастиями(participles) настоящего времени, причастиями прошедшего времени и относительными придаточными предложениями. Примерами являются "the man eating the snack"(мужчина, который ест закуску), "the snack eaten by the man"(закуска, которую съел мужчина) и "the man that ate the snack"(мужчина, который ел закуску) соответственно. Мы увидим, что каждый глагол в лексиконе помечен перегибом(inflection), и что маркер <code>-ing</code> используется для причастий настоящего времени, а <code>-en</code> - для причастий прошедшего времени. Детали <code>clause</code> будут рассмотрены позже.</p>
<div class="fragment"><div class="line">(rule (adjunct post noun ?agr ?x ?gap ?gap ?sem) ==&gt;</div><div class="line">  (:ex (the man) &quot;visiting me&quot; (the man) &quot;visited by me&quot;)</div><div class="line">  (:test (member ?infl (-ing passive)))</div><div class="line">  (clause ?infl ?x ? ?v (gap (NP ?agr ? ?x)) (gap nil) ?sem))</div><div class="line"></div><div class="line">(rule (adjunct post noun ?agr ?x ?gap ?gap ?sem) ==&gt;</div><div class="line">  (rel-clause ?agr ?x ?sem))</div></div><!-- fragment --><p>Возможно иметь относительное предложение, в котором речь идет об объекте, а не о субъекте: "the snack that the man ate"(закуска, которую съел человек). В таком относительном предложении относительное местоимение необязательно: "The snack the man ate was delicious"(Закуска, которую ел человек, была восхитительна). Следующие правила гласят, что если относительное местоимение опущено, то изменяемое существительное должно быть объектом, а относительное предложение должно включать подлежащее внутри. На это указывает константа <code>int-subj</code>.</p>
<div class="fragment"><div class="line">(rule (rel-clause ?agr ?x :sem) ==&gt;</div><div class="line">  (:ex (the man) &quot;that she liked&quot; &quot;that liked her&quot;</div><div class="line">       &quot;that I know Lee liked&quot;)</div><div class="line">  (opt-rel-pronoun ?case ?x ?int-subj ?rel-sem)</div><div class="line">  (clause (finite ? ?) ? ?int-subj ?v</div><div class="line">          (gap (NP ?agr ?case ?x)) (gap nil) ?clause-sem))</div><div class="line"></div><div class="line">(rule (opt-rel-pronoun ?case ?x ?int-subj (?type ?x)) ==&gt;</div><div class="line">  (:word ?rel-pro)</div><div class="line">  (:test (word ?rel-pro rel-pro ?case ?type)))</div><div class="line"></div><div class="line">(rule (opt-rel-pronoun (common obj) ?x int-subj t) ==&gt; )</div></div><!-- fragment --><p>Следует отметить, что редко, но возможно, встречаются имена и местоимения с модификаторами: "John the Baptist"(Иоанн Креститель), «прекрасная Рита, метровая горничная», «Люси в небе с бриллиантами», «Сильвия в бухгалтерии на 42 этаже. , "" та, которой нужно повиноваться ". Здесь и в этой главе мы будем поднимать вероятность таких редких случаев, оставляя их в качестве упражнений для читателя.</p>
<h2>21.4 Определители(Determiners)</h2>
<p>Мы рассмотрим три типа определителей. Самым простым является артикль: «собака» или «собаки». Также разрешены местоимения в родительном падеже, например «ее собака», и числа, например, «три собаки». Семантическая интерпретация определителя-фразы имеет форму (* ограничение переменной квантификатора *). Например, <code>(a? X (dog? X))</code> или <code>((number 3)? X (dog? X))</code>.</p>
<div class="fragment"><div class="line">(rule (Det ?agr ?wh ?x ?restriction (?art ?x ?restriction)) ==&gt;</div><div class="line">  (:ex &quot;the&quot; &quot;every&quot;)</div><div class="line">  (art ?agr ?art)</div><div class="line">  (:test (if (= ?art wh) (= ?wh +wh) (= ?wh -wh))))</div><div class="line"></div><div class="line">(rule (Det ?agr ?wh ?x ?r (the ?x ?restriction)) ==&gt;</div><div class="line">  (:ex &quot;his&quot; &quot;her&quot;)</div><div class="line">  (pronoun ?agr gen ?wh ?y ?sem)</div><div class="line">  (:test (and* ((genitive ?y ?x) ?sem ?r) ?restriction)))</div><div class="line"></div><div class="line">(rule (Det ?agr -wh ?x ?r ((number ?n) ?x ?r)) ==&gt;</div><div class="line">  (:ex &quot;three&quot;)</div><div class="line">  (cardinal ?n ?agr))</div></div><!-- fragment --><p>Это наиболее важные типы детерминаторов, но есть и другие, и есть пре- и постдетерминаторы, которые объединяются в ограниченные комбинации. Предопределители включают все, оба, половину, двойную, двойную и тому подобное. Постдетерминаторы включают каждый, многие, несколько и несколько. Таким образом, мы можем сказать «все ее многочисленные хорошие идеи» или «все люди короля». Но мы не можем сказать «* все много идей» или «* наши дети». Детали сложны и опускаются в этой грамматике.</p>
<h2>21.5 Глагольные фразы(Verb Phrases)</h2>
<p>Теперь, когда мы определили <code>модификаторы</code>, глагольные фразы сделать проще. На самом деле нам нужно всего два правила. Первая гласит, что глагольная фраза состоит из глагола, которому необязательно предшествуют модификаторы, и что значение глагольной фразы включает тот факт, что подлежащее выполняет некоторую роль:</p>
<div class="fragment"><div class="line">(rule (VP ?infl ?x ?subject-slot ?v ?g1 ?g2 :sem) ==&gt;</div><div class="line">  (:ex &quot;sleeps&quot; &quot;quickly give the dog a bone&quot;)</div><div class="line">  (modifiers pre verb ? () ?v (gap nil) (gap nil) ?pre-sem)</div><div class="line">  (:sem (?role ?x ?v)) (:test (= ?subject-slot (?role 1 ?)))</div><div class="line">  (verb ?verb ?infl (?subject-slot . ?slots) ?v ?v-sem)</div><div class="line">  (modifiers post verb ? ?slots ?v ?g1 ?g2 ?mod-sem))</div></div><!-- fragment --><p>Категория VP принимает семь аргументов. Первый - это склонение/изменение(inflection), которое представляет собой время глагола. Чтобы описать возможности этого аргумента, нам нужен быстрый обзор некоторых основ лингвистики. В предложении должен быть <em>конечный</em> глагол(<em>finite</em> verb), означающий глагол в настоящем или прошедшем времени. Таким образом, мы говорим: "Kim likes Lee,"(Ким нравится Ли), а не "*Kim liking Lee". Согласование подлежащего(субьекта) и сказуемого(предиката) действует для конечных глаголов, но не для любого другого времени. Другие времена появляются как дополнения к другим глаголам. Например, дополнение к "want" - это инфинитив: "Kim wants *to like* Lee"(Kim хочет <em>нравиться</em> Lee), а дополнение к модальному вспомогательному глаголу "would" - это не бесконечный глагол: "Kim would *like* Lee.". Если бы это было в настоящем времени, это было бы "likes", а не "like". Аргумент склонения/изменения принимает одну из форм в таблице:</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Type </th><th>Example  </th></tr>
<tr>
<td><code>(finite ?agr present)</code> </td><td>present tense </td><td>eat, eats </td></tr>
<tr>
<td><code>(finite ?agr past)</code> </td><td>past tense </td><td>ate </td></tr>
<tr>
<td><code>nonfinite</code> </td><td>nonfinite </td><td>eat </td></tr>
<tr>
<td><code>infinitive</code> </td><td>infinitive </td><td>to eat </td></tr>
<tr>
<td><code>-en</code> </td><td>past participle </td><td>eaten </td></tr>
<tr>
<td><code>-ing</code> </td><td>present participle </td><td>eating </td></tr>
</table>
<p>Второй аргумент - это метапеременная, которая относится к субъекту, а третий - слот дополнения субъекта. Мы принимаем соглашение, согласно которому слот подлежащего всегда должен быть первым среди дополнений глагола. Остальные слоты обрабатываются модификаторами postverb. Четвертый аргумент - это метапеременная, указывающая саму глагольную фразу. Последние три - знакомые аргументы разрыв и семантика(и третий???). Например, если глагольная фраза представляет собой единственное слово "slept"спал), то семантика глагольной фразы будет <code>(and (past ?v) (sleep ?v))</code>. Конечно, по этому правилу также будут обрабатываться наречия(adverbs), дополнения(complements) и добавления(adjuncts).</p>
<p>Второе правило для глагольных фраз касается вспомогательных глаголов(auxiliary verbs), таких как "have"(иметь), "is"(есть) и "would"(будет). Каждый вспомогательный глагол (или <code>aux</code>) производит глагольную фразу с определенным изменением/склонением, когда за ней следует глагольная фраза с требуемым изменением. Чтобы повторить пример, "would"(будет) дает конечную фразу, за которой следует бесконечный(nonfinite) глагол. "Have" дает неопределенное значение, если за ним следует причастие прошедшего времени. Таким образом, "would have liked" - это конечная глагольная фраза.</p>
<p>Мы также должны учитывать отрицание. Слово "not"(не) может изменять основной глагол, но может следовать за вспомогательным глаголом. То есть мы не можем сказать "*Kim not like Lee"(Ким не любит Ли), но мы можем добавить вспомогательный элемент, чтобы получить "Kim does not like Lee.".</p>
<div class="fragment"><div class="line">(rule (VP ?infl ?x ?subject-slot ?v ?g1 ?g2 :sem) ==&gt;</div><div class="line">  (:ex &quot;is sleeping&quot; &quot;would have given a bone to the dog.&quot;</div><div class="line">       &quot;did not sleep&quot; &quot;was given a bone by this old man&quot;)</div><div class="line">  ;; An aux verb, followed by a VP</div><div class="line">  (aux ?infl ?needs-infl ?v ?aux)</div><div class="line">  (modifiers post aux ? () ?v (gap nil) (gap nil) ?mod)</div><div class="line">  (VP ?needs-infl ?x ?subject-slot ?v ?g1 ?g2 ?vp))</div><div class="line"></div><div class="line">(rule (adjunct post aux ? ?v ?gap ?gap (not ?v)) ==&gt;</div><div class="line">  (:word not))</div></div><!-- fragment --><h2>21.6 Наречия(Adverbs)</h2>
<p>Наречия могут служить дополнением до или после глагола: "to boldly go"(смело идти), "to go boldly". Существуют некоторые ограничения относительно того, где они могут возникать, но трудно придумать твердые правила; здесь мы разрешаем любое наречие где угодно. Мы определяем категорию <code>advp</code> для фразы наречия, но в настоящее время ограничиваем ее одним наречием.</p>
<div class="fragment"><div class="line">(rule (adjunct ?pre/post verb ?info ?v ?g1 ?g2 ?sem) ==&gt;</div><div class="line">  (advp ?wh ?v ?g1 ?g2 ?sem))</div><div class="line"></div><div class="line">(rule (advp ?wh ?v ?gap ?gap ?sem) ==&gt;</div><div class="line">  (adverb ?wh ?v ?sem))</div><div class="line"></div><div class="line">(rule (advp ?wh ?v (gap (advp ?v)) (gap nil) t) ==&gt; )</div></div><!-- fragment --><h2>21.7 Предложения(Clauses)</h2>
<p>Предложение состоит из подлежащего/субъекта(subject ), за которым следует предикат/сказуемое(predicate). Однако субъект не обязательно должен быть реализован непосредственно перед сказуемым. Например, в фразе "Alice promised Bob to lend him her car"(Алиса обещала Бобу одолжить ему свою машину) есть инфинитивное предложение, которое состоит из предиката "to lend him her car"(одолжить ему свою машину) и подлежащего "Alice"(Алиса). Высказывание(sentence) в целом - это еще одно предложение. Таким образом, в нашем анализе предложение - это подлежащее, за которым следует глагольная фраза, с возможностью того, что субъект будет конкретизирован каким-то из аргументов разрыва:</p>
<div class="fragment"><div class="line">(rule (clause ?infl ?x ?int-subj ?v ?gap1 ?gap3 :sem) ==&gt;</div><div class="line">  (subject ?agr ?x ?subj-slot ?int-subj ?gap1 ?gap2 ?subj-sem)</div><div class="line">  (VP ?infl ?x ?subj-slot ?v ?gap2 ?gap3 ?pred-sem)</div><div class="line">  (:test (subj-pred-agree ?agr ?infl)))</div></div><!-- fragment --><p>Теперь есть две возможности для <code>subject</code>. В первом случае он уже проанализирован, и мы берем его из списка gap(разрыва). Если это так, то нам также необходимо найти признак согласования субьекта. Если субьектом была фраза существительного, соглашение будет присутствовать в списке разрывов. Если его не было, то согласование от третьего лица единственного числа. Примером этого является " *That the Red Sox won* surprises me"(Что Red Sox выиграл меня удивляет), где выделенная курсивом фраза субьект не-NP. Тот факт, что нам нужно использовать "surprises"(сюрпризы), а не "surprise"(удивление), указывает на то, что это слово от третьего лица единственного числа. Мы увидим, что для этого используется код <code>(- - + -)</code>.</p>
<div class="fragment"><div class="line">(rule (subject ?agree ?x ?subj-slot ext-subj</div><div class="line">               (gap ?subj) (gap nil) t) ==&gt;</div><div class="line">  ;; Externally realized subject (the normal case for S)</div><div class="line">  (:test (slot-constituent ?subj-slot ?subj ?x ?)</div><div class="line">         (if (= ?subj (NP ?agr ?case ?x))</div><div class="line">             (= ?agree ?agr)</div><div class="line">             (= ?agree (- - + -))))) ;Non-NP subjects are 3sing</div></div><!-- fragment --><p>Во втором случае мы просто разбираем именную фразу как подлежащее. Обратите внимание, что четвертый аргумент для <code>subject</code> - это <code>ext-subj</code> или <code>int-subj</code> в зависимости от того, реализуется ли субъект внутренне или внешне. Это будет важно, когда мы рассмотрим предложения в следующем разделе. Если это еще не было ясно, второй аргумент для <code>clause</code> и <code>subject</code> - это метапеременная, представляющая тему.</p>
<div class="fragment"><div class="line">(rule (subject ?agr ?x (?role 1 (NP ?x)) int-subj ?gap ?gap ?sem)</div><div class="line">  ==&gt;</div><div class="line">  (NP ?agr (common nom) ?wh ?x (gap nil) (gap nil) ?sem))</div></div><!-- fragment --><p>Наконец, правила согласования субъект-предикат говорят, что только конечные предикаты должны согласовываться со своим субъектом:</p>
<div class="fragment"><div class="line">(&lt;- (subj-pred-agree ?agr (finite ?agr ?)))</div><div class="line">(&lt;- (subj-pred-agree ? ?infl) (atom ?infl))</div></div><!-- fragment --><h2>21.8 Изречения/Утверждения/Высказывания(Sentences)</h2>
<p>В предыдущей главе мы разрешили использовать только простые повествовательные предложения. Текущая грамматика поддерживает команды и четыре типа вопросов в дополнение к декларативным предложениям. Она также поддерживает <em>тематическое оформление:</em> размещение не субъекта(nonsubject) в начале предложения, чтобы подчеркнуть его важность, например, в словах "*Smith* he says his name is"(Смит он говорит, что его зовут) или *"Murder,* she wrote"(Убийство, написала она) или *"In God* we trust"(В Бога мы верим). В последнем примере первой встречается предложная(prepositional phrase), а не фраза существительного. Также возможно иметь субъект, который не является фразой существительного: *"That the dog didn't bark* puzzled Holmes."(То, что собака не лаяла, озадачило Холмса). Для поддержки всех этих возможностей мы вводим новую категорию <code>XP</code>, которая обозначает любые фразы. Тогда декларативное предложение - это просто XP, за которым следует предложение, где предметом предложения может оказаться, а может и не оказаться XP:</p>
<div class="fragment"><div class="line">(rule (S ?s :sem) ==&gt;</div><div class="line">  (:ex &quot;Kim likes Lee&quot; &quot;Lee, I like _&quot; &quot;In god, we trust _&quot;</div><div class="line">       &quot;Who likes Lee?&quot; &quot;Kim likes who?&quot;)</div><div class="line">  (XP ?kind ?constituent ?wh ?x (gap nil) (gap nil) ?topic-sem)</div><div class="line">  (clause (finite ? ?) ?x ? ?s (gap ?constituent) (gap nil) ?sem))</div></div><!-- fragment --><p>Как оказалось, это правило также служит для двух типов вопросов. В самом простом вопросе предметом является вопросительная фраза существителього: "Who likes Lee?"(Кому нравится Ли?) или "What man likes Lee?"(Какой мужчина любит Ли?). Другой вид - это так называемый <em>вопрос-эхо *, который может использоваться только как ответ на другое утверждение: если я скажу вам, что Ким нравится Джерри Льюис, вы можете разумно ответить: "Kim likes *who&lt;/em&gt;?"(Ким нравится <em>кто</em>?). Оба эти типа вопросов имеют ту же структуру, что и повествовательные предложения, и поэтому обрабатываются одним и тем же правилом.</em></p>
<p><em>В следующей таблице перечислены некоторые изречения, которые могут быть проанализированы с помощью этого правила, с указанием опыта и темы каждого из них.</em></p>
<p><em></p><table class="doxtable">
<tr>
<th>Sentence </th><th>XP </th><th>Subject  </th></tr>
<tr>
<td>Kim likes Lee </td><td>Kim </td><td>Kim </td></tr>
<tr>
<td>Lee, Kim likes </td><td>Lee </td><td>Kim </td></tr>
<tr>
<td>In god, we trust </td><td>In god </td><td>we </td></tr>
<tr>
<td>That Kim likes Lee amazes </td><td>That Kim likes Lee </td><td>That Kim likes Lee </td></tr>
<tr>
<td>Who likes Lee? </td><td>Who </td><td>Who </td></tr>
</table>
<p>Самый распространенный тип команды вообще не имеет темы: "Be quiet"(Тихо) или "Go to your room"(Иди в свою комнату). Если тема отсутствует, это означает, что команда относится к <em>вам</em>, адресату команды. Субъект также может быть упомянута явно, и это может быть "you"(ты), например "You be quiet"(ты - молчи), но это не обязательно: "Somebody shut the door"(Кто-нибудь, закройте дверь) или "Everybody sing along"(Все подпевают). Мы предоставляем правило только для команд с опущенным субъектом, так как бывает сложно отличить команду с субъектом от декларативного предложения. Обратите внимание, что команды всегда не бесконечны(nonfinite).</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (S ?s :sem) ==&gt;</div><div class="line">  ;; Commands have implied second-person subject</div><div class="line">  (:ex &quot;Give the dog a bone.&quot;)</div><div class="line">  (:sem (command ?s))</div><div class="line">  (:sem (listener ?x))</div><div class="line">  (clause nonfinite ?x ext-subj ?s</div><div class="line">          (gap (NP ? ? ?x)) (gap nil) ?sem))</div></div><!-- fragment --><p></em></p>
<p><em>Другая форма команды начинается с "let"(давай), например, "Let me see what I can do"(дай мне посмотреть, что я могу сделать) и "Let us all pray"(давайте все помолимся). Второе слово лучше рассматривать как объект "let", а не как подлежащее в предложении, так как подлежащим должно быть "I"(я) или "we"(мы). Этот вид команд может обрабатываться с помощью лексической записи для "let", а не с помощью дополнительного правила.</em></p>
<p><em>Теперь рассмотрим вопросы(questions). В вопросах, на которые можно ответить положительно или отрицательно, подлежащее и вспомогательный глагол меняются местами: "Did you see him?"(Вы его видели?). или "Should I have been doing this?"(Я должен был это делать?) Последний пример показывает, что перед подлежащим(субъектом) стоит только первый вспомогательный глагол. Категория <code>aux-inv-S</code> используется для обработки этого случая:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (S ?s (yes-no ?s ?sem)) ==&gt;</div><div class="line">  (:ex &quot;Does Kim like Lee?&quot; &quot;Is he a doctor?&quot;)</div><div class="line">  (aux-inv-S nil ?s ?sem))</div></div><!-- fragment --><p></em></p>
<p><em>Вопросы, начинающиеся с wh-фразы, также имеют перед подлежащим вспомогательный глагол, например, "Who did you see?"(Кого вы видели?) или "Why should I have been doing this?"(Почему я должен был это делать?) Первая составляющая также может быть предложной фразой: "For whom am I doing this?"(Для кого я это делаю?) Следующее правило анализирует XP, которая должна иметь функцию <code>+wh</code>, а затем анализирует <code>aux-inv-S</code>, чтобы прийти к вопросу:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (S ?s :sem) ==&gt;</div><div class="line">  (:ex &quot;Who does Kim like _?&quot; &quot;To whom did he give it _?&quot;</div><div class="line">       &quot;What dog does Kim like _?&quot;)</div><div class="line">  (XP ?slot ?constituent +wh ?x (gap nil) (gap nil) ?subj-sem)</div><div class="line">  (aux-inv-S ?constituent ?s ?sem))</div></div><!-- fragment --><p></em></p>
<p><em>Вопрос также может быть обозначен возрастающей интонацией в том, что в противном случае было бы декларативным заявлением: "You want some?"(Вы хотите немного?) Поскольку у нас нет информации об интонации, мы не будем включать такие вопросы.</em></p>
<p><em>Реализация для <code>aux-inv-S</code> проста: проанализируйте вспомогательное, а затем предложение, сделав паузу для поиска модификаторов между ними. (Пока что в этой позиции разрешен только модификатор "not"(не).)</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (aux-inv-S ?constituent ?v :sem) ==&gt;</div><div class="line">  (:ex &quot;Does Kim like Lee?&quot; (who) &quot;would Kim have liked&quot;)</div><div class="line">  (aux (finite ?agr ?tense) ?needs-infl ?v ?aux-sem)</div><div class="line">  (modifiers post aux ? () ?v (gap nil) (gap nil) ?mod)</div><div class="line">  (clause ?needs-infl ?x int-subj ?v (gap ?constituent) (gap nil)</div><div class="line">          ?clause-sem))</div></div><!-- fragment --><p></em></p>
<p><em>Следует рассмотреть еще один случай. Глагол "to be"(быть) - самый идиосинкразический в английском языке. Это единственный глагол, у которого есть отличия от всего, кроме третьего лица единственного числа. И это также единственный глагол, который может использоваться в <code>aux-inv-S</code> без главного глагола. Примером этого является "Is he a doctor?,"(Он врач?), Где "is" явно не вспомогательный, потому что нет главного глагола, к которому он мог бы быть вспомогательным. Другой глагол нельзя использовать таким образом: "*Seems he happy?"(Кажется, он счастлив?) и "* Did they it?"(Они это сделали?) вне грамматики. Единственная возможность - это "have"(иметь), как в "Have you any wool?"(У тебя есть шерсть?), Но такое использование редко.</em></p>
<p><em>Следующее правило анализирует глагол, проверяет, является ли он версией "be"(быть), а затем анализирует подлежащее и модификаторы глагола.</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (aux-inv-S ?ext ?v :sem) ==&gt;</div><div class="line">  (:ex &quot;Is he a doctor?&quot;)</div><div class="line">  (verb ?be (finite ?agr ?) ((?role ?n ?xp) . ?slots) ?v ?sem)</div><div class="line">  (:test (word ?be be))</div><div class="line">  (subject ?agr ?x (?role ?n ?xp) int-subj</div><div class="line">           (gap nil) (gap nil) ?subj-sem)</div><div class="line">  (:sem (?role ?v ?x))</div><div class="line">  (modifiers post verb ? ?slots ?v (gap ?ext) (gap nil) ?mod-sem))</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.9 XPs</h2>
<p></em></p>
<p><em></em></p>
<p><em>Все, что осталось в нашей грамматике, - это категория XP. XP используются двумя способами: во-первых, фраза может быть экстраполирована, например, "*In god* we trust", где "in god"(в Бога) будет анализироваться как XP, а затем помещаться в список gap(разрыва) до тех пор, пока его нельзя будет убрать. как добавка(adjunct) к "trust"(верим). Во-вторых, фраза может быть дополнением(complement), например, "He wants *to be a fireman"*(Он хочет быть пожарным), где инфинитивная фраза является дополнением "wants"(хочет).</em></p>
<p><em>Как оказалось, количество информации, которая должна появиться в списке gap(разрывов), немного отличается от информации, которая появляется в слоте дополнения(complement). Например, одно из значений глагола "want"(хочу) имеет следующий список дополнений:</em></p>
<p><em></p><div class="fragment"><div class="line">((agt 1 (NP ?x)) (con 3 (VP infinitive ?x)))</div></div><!-- fragment --><p></em></p>
<p><em>Это говорит о том, что первое дополнение (подлежащее/субъект) - это фраза существительного, которая служит агентом желания, а вторая - инфинитивная глагольная фраза, которая является концепцией желания. Субъект этой глагольной фразы совпадает с субъектом желания, поэтому в "She wants to go home"(Она хочет пойти домой) именно она и хочет, и идет. (Сравните это с фразой "He persuaded her to go home"(Он убедил ее пойти домой), где именно он убеждает, а она идет.)</em></p>
<p><em>Но когда мы помещаем фразу сущетствительного в список gap(разрывов), нам нужно указать ее номер и регистр, а также тот факт, что это NP и ее метапеременная, но нам не нужно включать тот факт, что это агент. Это различие означает, что у нас есть два варианта: либо мы можем объединить понятия слотов и списков разрывов, чтобы они использовали общую нотацию, содержащую всю информацию, которую можно использовать, либо нам нужен какой-то способ сопоставления между ними. Я сделал второй выбор на том основании, что каждое обозначение было достаточно сложным, без дополнительной информации.</em></p>
<p><em>Отношение <code>slot-constituent</code> выполняет отображение между используемым обозначением слота, используемым для дополнений, и составляющим обозначением, используемым в списках разрывов(gap). Существует восемь типов дополнений, пять из которых могут появляться в списках разрывов: фразы существительных, предложения, предложные фразы, слово "it"(оно) (например, "it is raining"(идет дождь)) и наречные фразы(adverbial phrases). Три фразы, которые разрешены только в качестве дополнения, - это глагольные фразы, частицы (например, "up"(вверх) в "look up the number"(поиске числа)) и прилагательные(adjectives). Вот соответствие между двумя обозначениями. *** означает отсутствие сопоставления:</em></p>
<p><em></p><div class="fragment"><div class="line">(&lt;- (slot-constituent (?role ?n (NP ?x))</div><div class="line">                      (NP ?agr ?case ?x) ?x ?h))</div><div class="line">(&lt;- (slot-constituent (?role ?n (clause ?word ?infl))</div><div class="line">                      (clause ?word ?infl ?v) ?v ?h))</div><div class="line">(&lt;- (slot-constituent (?role ?n (PP ?prep ?np))</div><div class="line">                      (PP ?prep ?role ?np ?h) ?np ?h))</div><div class="line">(&lt;- (slot-constituent (?role ?n it)            (it ? ? ?x) ?x ?))</div><div class="line">(&lt;- (slot-constituent (manner 3 (advp ?x))     (advp ?v) ? ?v))</div><div class="line">(&lt;- (slot-constituent (?role ?n (VP ?infl ?x)) *** ? ?))</div><div class="line">(&lt;- (slot-constituent (?role ?n (Adj ?x))      *** ?x ?))</div><div class="line">(&lt;- (slot-constituent (?role ?n (P ?particle)) *** ? ?))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы готовы определить дополнение(complement). Она берет описание слота, сопоставляет его с составной частью, а затем вызывает <code>XP</code> для анализа этой составляющей:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (complement ?cat ?info (?role ?n ?xp) ?h ?gap1 ?gap2 :sem)</div><div class="line">  ==&gt;</div><div class="line">  ;; A complement is anything expected by a slot</div><div class="line">  (:sem (?role ?h ?x))</div><div class="line">  (:test (slot-constituent (?role ?n ?xp) ?constituent ?x ?h))</div><div class="line">  (XP ?xp ?constituent ?wh ?x ?gap1 ?gap2 ?sem))</div></div><!-- fragment --><p></em></p>
<p><em>Категория <code>XP</code> принимает семь аргументов. Первые два - это слот, который мы пытаемся заполнить, и компонент, который нам нужен для его заполнения. Третья используется для любой дополнительной информации, а четвертая - метапеременная для фразы. Последние три предоставляют разрыв(gap) и смысловую информацию.</em></p>
<p><em>Вот первые пять категорий XP:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (XP (PP ?prep ?np) (PP ?prep ?role ?np ?h) ?wh ?np</div><div class="line">          ?gap1 ?gap2 ?sem) ==&gt;</div><div class="line">  (PP ?prep ?role ?wh ?np ?h ?gap1 ?gap2 ?sem))</div><div class="line"></div><div class="line">(rule (XP (NP ?x) (NP ?agr ?case ?x) ?wh ?x ?gap1 ?gap2 ?sem) ==&gt;</div><div class="line">  (NP ?agr ?case ?wh ?x ?gap1 ?gap2 ?sem))</div><div class="line"></div><div class="line">(rule (XP it (it ? ? ?x) -wh ?x ?gap ?gap t) ==&gt;</div><div class="line">  (:word it))</div><div class="line"></div><div class="line">(rule (XP (clause ?word ?infl) (clause ?word ?infl ?v) -wh ?v</div><div class="line">          ?gap1 ?gap2 ?sem) ==&gt;</div><div class="line">  (:ex (he thinks) &quot;that she is tall&quot;)</div><div class="line">  (opt-word ?word)</div><div class="line">  (clause ?infl ?x int-subj ?v ?gap1 ?gap2 ?sem))</div><div class="line"></div><div class="line">(rule (XP (?role ?n (advp ?v)) (advp ?v) ?wh ?v ?gap1 ?gap2 ?sem)</div><div class="line">  ==&gt;</div><div class="line">  (advp ?wh ?v ?gap1 ?gap2 ?sem))</div></div><!-- fragment --><p></em></p>
<p><em>Категория <code>opt-word</code> анализирует слово, что может быть необязательным. Например, одно значение "know"(знать) подкатегории для предложения с необязательным "that"(что): мы можем сказать либо "I know that he's here"(Я знаю, что он здесь), либо "I know he's here"(Я знаю, что он здесь). Таким образом, список дополнений для "know"(знать) содержит слот <code>(con 2 (clause (that) (finite ? ?)))</code>. Если бы "that"(это) было обязательным, вокруг него не было бы скобок.</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (opt-word ?word) ==&gt; (:word ?word))</div><div class="line">(rule (opt-word (?word)) ==&gt; (:word ?word))</div><div class="line">(rule (opt-word (?word)) ==&gt;)</div></div><!-- fragment --><p></em></p>
<p><em>Наконец, вот три XP, которые нельзя экстраполировать:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (XP (VP ?infl ?x) *** -wh ?v ?gap1 ?gap2 ?sem) ==&gt;</div><div class="line">  (:ex (he promised her) &quot;to sleep&quot;)</div><div class="line">  (VP ?infl ?x ?subj-slot ?v ?gap1 ?gap2 ?sem))</div><div class="line"></div><div class="line">(rule (XP (Adj ?x) *** -wh ?x ?gap ?gap ?sem) ==&gt;</div><div class="line">  (Adj ?x ?sem))</div><div class="line"></div><div class="line">(rule (XP (P ?particle) *** -wh ?x ?gap ?gap t) ==&gt;</div><div class="line">  (prep ?particle t))</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.10 Категории слов(Word Categories)</h2>
<p></em></p>
<p><em></em></p>
<p><em>Каждая категория слов имеет правило, которое ищет слова в лексиконе и присваивает им нужные характеристики. Отношение <code>word</code>(слово) используется для доступа к лексикону. Мы опишем самый сложный класс слов, <code>verb</code>(глагол), и просто перечислим остальные.</em></p>
<p><em>Глаголы сложны, потому что они часто <em>многозначны</em> - имеют много значений. Кроме того, каждое значение может иметь несколько различных списков дополнений(complement). Таким образом, запись для глагола в лексиконе будет состоять из формы глагола, его изменения(inflection) и списка значений, где каждое значение представляет собой семантику, за которой следует список возможных списков дополнений. Вот запись для глагола "sees"(видит), указывающая на то, что это глагол в настоящем времени с тремя смыслами. Смысл понимания имеет два дополнительных списка, которые соответствуют "He sees"(Он видит) и "He sees that you are right"(Он видит, что вы правы»). Смысл <code>look</code>(взгляд) имеет один дополнительный список, соответствующий "He sees the picture"(Он видит картинку), а смысл <code>dating</code>(свидание), соответствующее "He sees her (only on Friday nights)"(Он увидит ее (только в пятницу вечером)), имеет тот же дополнительный список.</em></p>
<p><em></p><div class="fragment"><div class="line">(?- (word sees verb ?infl ?senses))</div><div class="line">?INFL = (FINITE (--+-) PRESENT)</div><div class="line">?SENSES = ((UNDERSTAND ((AGT 1 (NP ?3)))</div><div class="line">                ((EXP 1 (NP ?4))</div><div class="line">                  (CON 2 (CLAUSE (THAT) (FINITE ?5 ?6)))))</div><div class="line">          (LOOK ((AGT 1 (NP ?7)) (OBJ 2 (NP ?8))))</div><div class="line">          (DATING ((AGT 1 (NP ?9)) (OBJ 2 (NP ?10)))))</div></div><!-- fragment --><p></em></p>
<p><em>Категория <code>verb</code>(глагол) принимает пять аргументов: сам глагол, его изменения, его список дополнений, его метапеременных и его семантику. Отношения <code>member</code> используются для выбора смысла из списка смыслов и дополнительного списка из списка списков, а семантика строится из семантического предиката для выбранного смысла и метапеременной для глагола:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (verb ?verb ?infl ?slots ?v :sem) ==&gt;</div><div class="line">  (:word ?verb)</div><div class="line">  (:test (word ?verb verb ?infl ?senses)</div><div class="line">         (member (?sem . ?subcats) ?senses)</div><div class="line">         (member ?slots ?subcats)</div><div class="line">         (tense-sem ?infl ?v ?tense-sem))</div><div class="line">  (:sem ?tense-sem)</div><div class="line">  (:sem (?sem ?v)))</div></div><!-- fragment --><p></em></p>
<p><em>Трудно уметь(знать как) перевести временную(tense) информацию в смысловую интерпретацию. Разные приложения будут иметь разные модели времени и, следовательно, будут нуждаться в разных интерпретациях. Отношение <code>tense-sem</code> дает семантику для каждого времени. Вот очень простое определение <code>tense-sem</code>:</em></p>
<p><em></p><div class="fragment"><div class="line">(&lt;- (tense-sem (finite ? ?tense) ?v (?tense ?v)))</div><div class="line">(&lt;- (tense-sem -ing ?v (progressive ?v)))</div><div class="line">(&lt;- (tense-sem -en  ?v (past-participle ?v)))</div><div class="line">(&lt;- (tense-sem infinitive ?v t))</div><div class="line">(&lt;- (tense-sem nonfinite ?v t))</div><div class="line">(&lt;- (tense-sem passive ?v (passive ?v)))</div></div><!-- fragment --><p></em></p>
<p><em>Вспомогательные глаголы и модальные глаголы указаны отдельно:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (aux ?infl ?needs-infl ?v ?tense-sem) ==&gt;</div><div class="line">  (:word ?aux)</div><div class="line">  (:test (word ?aux aux ?infl ?needs-infl)</div><div class="line">         (tense-sem ?infl ?v ?tense-sem)))</div><div class="line"></div><div class="line">(rule (aux (finite ?agr ?tense) nonfinite ?v (?sem ?v)) ==&gt;</div><div class="line">  (:word ?modal)</div><div class="line">  (:test (word ?modal modal ?sem ?tense)))</div></div><!-- fragment --><p></em></p>
<p><em>Существительные, местоимения и имена также указаны отдельно, хотя у них много общего. Для местоимений мы используем квантификатор <code>wh</code> или <code>pro</code>, в зависимости от того, является это местоимением wh-pronoun или нет.</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (noun ?agr ?slots ?x (?sem ?x)) ==&gt;</div><div class="line">  (:word ?noun)</div><div class="line">  (:test (word ?noun noun ?agr ?slots ?sem)))</div><div class="line"></div><div class="line">(rule (pronoun ?agr ?case ?wh ?x (?quant ?x (?sem ?x))) ==&gt;</div><div class="line">  (:word ?pro)</div><div class="line">  (:test (word ?pro pronoun ?agr ?case ?wh ?sem)</div><div class="line">         (if (= ?wh +wh) (= ?quant wh) (= ?quant pro))))</div><div class="line"></div><div class="line">(rule (name ?agr ?name) ==&gt;</div><div class="line">  (:word ?name)</div><div class="line">  (:test (word ?name name ?agr)))</div></div><!-- fragment --><p></em></p>
<p><em>Вот правила для остальных классов слов:</em></p>
<p><em></p><div class="fragment"><div class="line">(rule (adj ?x (?sem ?x)) ==&gt;</div><div class="line">  (:word ?adj)</div><div class="line">  (:test (word ?adj adj ?sem)))</div><div class="line"></div><div class="line">(rule (adj ?x ((nth ?n) ?x)) ==&gt; (ordinal ?n))</div><div class="line"></div><div class="line">(rule (art ?agr ?quant) ==&gt;</div><div class="line">  (:word ?art)</div><div class="line">  (:test (word ?art art ?agr ?quant)))</div><div class="line"></div><div class="line">(rule (prep ?prep t) ==&gt;</div><div class="line">  (:word ?prep)</div><div class="line">  (:test (word ?prep prep)))</div><div class="line"></div><div class="line">(rule (adverb ?wh ?x ?sem) ==&gt;</div><div class="line">  (:word ?adv)</div><div class="line">  (:test (word ?adv adv ?wh ?pred)</div><div class="line">         (if (= ?wh +wh)</div><div class="line">             (= ?sem (wh ?y (?pred ?x ?y)))</div><div class="line">             (= ?sem (?pred ?x)))))</div><div class="line"></div><div class="line">(rule (cardinal ?n ?agr) ==&gt;</div><div class="line">  (:ex &quot;five&quot;)</div><div class="line">  (:word ?num)</div><div class="line">  (:test (word ?num cardinal ?n ?agr)))</div><div class="line"></div><div class="line">(rule (cardinal ?n ?agr) ==&gt;</div><div class="line">  (:ex &quot;5&quot;)</div><div class="line">  (:word ?n)</div><div class="line">  (:test (numberp ?n)</div><div class="line">         (if (= ?n 1)</div><div class="line">             (= ?agr (- - + -))    ;3sing</div><div class="line">             (= ?agr (- - - +))))) ;3plur</div><div class="line"></div><div class="line">(rule (ordinal ?n) ==&gt;</div><div class="line">  (:ex &quot;fifth&quot;)</div><div class="line">  (:word ?num)</div><div class="line">  (:test (word ?num ordinal ?n)))</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.11 Лексикон(Lexicon)</h2>
<p></em></p>
<p><em></em></p>
<p><em>Сам лексикон состоит из большого количества записей в отношении <code>word</code>(слово), и, безусловно, можно было бы попросить составителя словаря составить длинный список фактов <code>word</code>. Но чтобы облегчить чтение и запись лексики, мы используем три полезных инструмента. Во-первых, введем систему сокращений(abbreviations). Общие выражения могут быть сокращены с помощью символа, который будет расширен <code>word.</code>. Во-вторых, мы предоставляем макрос <code>verb</code> и <code>noun</code> для охвата двух наиболее сложных классов слов. В-третьих, мы предоставляем макрос <code>word</code>, который делает записи в хеш-таблице. Это более эффективно, чем составление отношения слова, состоящего из сотен предложений Пролога.</em></p>
<p><em>Реализация этих инструментов оставлена для следующего раздела; здесь мы показываем фактическую лексику, начиная со списка сокращений.</em></p>
<p><em>Первый набор сокращений определяет особенности соглашения. Очевидный способ добиться согласия - использовать две функции: одну для лица(person), а другую - для числа. Таким образом, можно представить единственное число от первого лица (1 <code>sing</code>). Проблема возникает, когда мы хотим описать глаголы. Каждый глагол, кроме "be"(быть), делает различие только между третьим лицом единственного числа и всеми остальными. Мы не хотим делать в лексиконе пять отдельных записей, чтобы представить все остальные. Одна альтернатива - использовать функцию согласования в виде набора возможных значений, чтобы все остальные были единым набором из пяти значений, а не из пяти отдельных значений. Это имеет большое значение для сокращения количества откатов. Проблема с этим подходом состоит в том, чтобы отслеживать, когда пересекать множества. Другой подход состоит в том, чтобы сделать функциональность согласования списком из четырех двоичных функциональностей, по одной для единственного числа от первого лица, от первого лица во множественном числе, от третьего лица в единственном числе и от третьего лица во множественном числе. Тогда "все остальные" могут быть представлены списком, который отрицателен для третьего признака и неизвестен для всех остальных. В этой схеме нет способа отличить второе лицо единственного числа от множественного числа, но в английском языке такое различие не проводится. Вот необходимые сокращения:</em></p>
<p><em></p><div class="fragment"><div class="line">(abbrev 1sing       (+ - - -))</div><div class="line">(abbrev 1plur       (- + - -))</div><div class="line">(abbrev 3sing       (- - + -))</div><div class="line">(abbrev 3plur       (- - - +))</div><div class="line">(abbrev 2pers       (- - - -))</div><div class="line">(abbrev ~3sing      (? ? - ?))</div></div><!-- fragment --><p></em></p>
<p><em>Следующий шаг - предоставить сокращения для некоторых распространенных списков дополнений глаголов:</em></p>
<p><em>``lisp (abbrev v/intrans ((agt 1 (NP ?)))) (abbrev v/trans ((agt 1 (NP ?)) (obj 2 (NP ?)))) (abbrev v/ditrans ((agt 1 (NP ?)) (goal 2 (NP ?)) (obj 3 (NP ?)))) (abbrev v/trans2 ((agt 1 (NP ?)) (obj 2 (NP ?)) (goal 2 (PP to ?)))) (abbrev v/trans4 ((agt 1 (NP ?)) (obj 2 (NP ?)) (ben 2 (PP for ?)))) (abbrev v/it-null ((nil 1 it))) (abbrev v/opt-that ((exp 1 (NP ?)) (con 2 (clause (that) (finite ? ?))))) (abbrev v/subj-that ((con 1 (clause that (finite ? ?))) (exp 2 (NP ?)))) (abbrev v/it-that ((nil 1 it) (exp 2 (NP ?)) (con 3 (clause that (finite ? ?))))) (abbrev v/inf ((agt 1 (NP ?x)) (con 3 (VP infinitive ?x)))) (abbrev v/promise ((agt 1 (NP ?x)) (goal (2) (NP ?y)) (con 3 (VP infinitive ?x)))) (abbrev v/persuade ((agt 1 (NP ?x)) (goal 2 (NP ?y)) (con 3 (VP infinitive ?y)))) (abbrev v/want ((agt 1 (NP ?x)) (con 3 (VP infinitive ?x)))) (abbrev v/p-up ((agt 1 (NP ?)) (pat 2 (NP ?)) (nil 3 (P up)))) (abbrev v/pp-for ((agt 1 (NP ?)) (pat 2 (PP for ?)))) (abbrev v/pp-after ((agt 1 (NP ?)) (pat 2 (PP after ?)))) </p><div class="fragment"><div class="line">### Глаголы(Verbs)</div><div class="line"></div><div class="line">Макрос `verb` позволяет нам перечислять глаголы в форме ниже, где написание каждого времени может быть опущено, если глагол правильный:</div><div class="line"></div><div class="line">(`verb` (*base past-tense past-participle present-participle present-plural* ) (*semantics complement-list*...) ...)</div><div class="line"></div><div class="line">Например, в следующем списке слово &quot;ask&quot;(спросить) является обычным, поэтому необходимо только его написание в основной форме.</div><div class="line">&quot;Do,&quot; с другой стороны, является неправильным, поэтому каждая форма прописана.</div><div class="line">В случайный список входят глаголы, которые либо полезны в качестве примеров, либо иллюстрируют какой-то необычный список дополнений.</div><div class="line"></div><div class="line">```lisp</div><div class="line">(verb (ask) (query v/ditrans))</div><div class="line">(verb (delete) (delete v/trans))</div><div class="line">(verb (do did done doing does) (perform v/trans))</div><div class="line">(verb (eat ate eaten) (eat v/trans))</div><div class="line">(verb (give gave given giving) (give-1 v/trans2 v/ditrans)</div><div class="line">      (donate v/trans v/intrans))</div><div class="line">(verb (go went gone going goes))</div><div class="line">(verb (have had had having has) (possess v/trans))</div><div class="line">(verb (know knew known) (know-that v/opt-that) (know-of v/trans))</div><div class="line">(verb (like) (like-1 v/trans))</div><div class="line">(verb (look) (look-up v/p-up) (search v/pp-for)</div><div class="line">      (take-care v/pp-after) (look v/intrans))</div><div class="line">(verb (move moved moved moving moves)</div><div class="line">      (self-propel v/intrans) (transfer v/trans2))</div><div class="line">(verb (persuade) (persuade v/persuade))</div><div class="line">(verb (promise) (promise v/promise))</div><div class="line">(verb (put put put putting))</div><div class="line">(verb (rain) (rain v/it-null))</div><div class="line">(verb (saw) (cut-with-saw v/trans v/intrans))</div><div class="line">(verb (see saw seen seeing) (understand v/intrans v/opt-that)</div><div class="line">      (look v/trans) (dating v/trans))</div><div class="line">(verb (sleep slept) (sleep v/intrans))</div><div class="line">(verb (surprise) (surprise v/subj-that v/it-that))</div><div class="line">(verb (tell told) (tell v/persuade))</div><div class="line">(verb (trust) (trust v/trans ((agt 1 (NP ?)) (obj 2 (PP in ?)))))</div><div class="line">(verb (try tried tried trying tries) (attempt v/inf))</div><div class="line">(verb (visit) (visit v/trans))</div><div class="line">(verb (want) (desire v/want v/persuade))</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Вспомогательные глаголы(Auxiliary Verbs)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Вспомогательные глаголы достаточно просты, чтобы их можно было описать непосредственно словом макрос. Каждая запись перечисляет само вспомогательное средство, время, которое оно используется для построения, и время, за которым оно должно следовать. Вспомогательные элементы "have" и "do" перечислены вместе с "to", которое используется для создания инфинитивных предложений и, таким образом, может рассматриваться как вспомогательное.</em></p>
<p><em></p><div class="fragment"><div class="line">(word have    aux nonfinite -en)</div><div class="line">(word have    aux (finite ~3sing present) -en)</div><div class="line">(word has     aux (finite 3sing present) -en)</div><div class="line">(word had     aux (finite ? past) -en)</div><div class="line">(word having  aux -ing -en)</div><div class="line"></div><div class="line">(word do      aux (finite ~3sing present) nonfinite)</div><div class="line">(word does    aux (finite  3sing present) nonfinite)</div><div class="line">(word did     aux (finite  ?     past)    nonfinite)</div><div class="line"></div><div class="line">(word to      aux infinitive nonfinite)</div></div><!-- fragment --><p></em></p>
<p><em>Вспомогательное "be" является особенным: помимо использования в качестве вспомогательного и основного глагола, оно также используется в пассивных формах и в качестве основного глагола в предложениях с инвертированными вспомогательными словами. Функция <code>copula</code> используется для отслеживания всех этих случаев использования. Она будет определена в следующем разделе, но вы можете видеть, что она принимает два аргумента, список значений для основного глагола и список записей для вспомогательного глагола. Эти три смысла соответствуют примерам "He is a fool"(Он дурак), "He is a Republican"(Он республиканец) и "He is in Indiana"(Он в Индиане) соответственно.</em></p>
<p><em></p><div class="fragment"><div class="line">(copula</div><div class="line">  &#39;((nil      ((nil 1 (NP ?x)) (nil 2 (Adj ?x))))</div><div class="line">    (is-a     ((exp 1 (NP ?x)) (arg2 2 (NP ?y))))</div><div class="line">    (is-loc   ((exp 1 (NP ?x)) (?prep 2 (PP ?prep ?)))))</div><div class="line">  &#39;((be       nonfinite -ing)</div><div class="line">    (been     -en -ing)</div><div class="line">    (being    -ing -en)</div><div class="line">    (am       (finite 1sing present) -ing)</div><div class="line">    (is       (finite 3sing present) -ing)</div><div class="line">    (are      (finite 2pers present) -ing)</div><div class="line">    (were     (finite (- - ? ?) past) -ing)   ; 2nd sing or pl</div><div class="line">    (was      (finite (? - ? -) past) -ing))) ; 1st or 3rd sing</div></div><!-- fragment --><p></em></p>
<p><em>Ниже приведены модальные вспомогательные глаголы. Опять же, для них сложно указать семантику. Слово "not"(не) также указано здесь; это не вспомогательное средство, но оно их модифицирует.</em></p>
<p><em></p><div class="fragment"><div class="line">(word can    modal able      past)</div><div class="line">(word could  modal able      present)</div><div class="line">(word may    modal possible  past)</div><div class="line">(word might  modal possible  present)</div><div class="line">(word shall  modal mandatory past)</div><div class="line">(word should modal mandatory present)</div><div class="line">(word will   modal expected  past)</div><div class="line">(word would  modal expected  present)</div><div class="line">(word must   modal necessary present)</div><div class="line"></div><div class="line">(word not not)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Существительные(Nouns)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Не было сделано никаких попыток серьезно относиться к существительным. Мы перечисляем здесь достаточное количество существительных, чтобы некоторые примеры работали. Первое существительное показывает список дополнений, достаточный, чтобы разобрать "the destruction of the city by the enemy"(разрушение города противником).</em></p>
<p><em></p><div class="fragment"><div class="line">(noun destruction * destruction</div><div class="line">      (pat (2) (PP of ?)) (agt (2) (PP by ?)))</div><div class="line">(noun beach)</div><div class="line">(noun bone)</div><div class="line">(noun box boxes)</div><div class="line">(noun city cities)</div><div class="line">(noun color)</div><div class="line">(noun cube)</div><div class="line">(noun doctor)</div><div class="line">(noun dog dogs)</div><div class="line">(noun enemy enemies)</div><div class="line">(noun file)</div><div class="line">(noun friend friends friend (friend-of (2) (PP of ?)))</div><div class="line">(noun furniture *)</div><div class="line">(noun hat)</div><div class="line">(noun man men)</div><div class="line">(noun saw)</div><div class="line">(noun woman women)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Местоимения(Names)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Здесь мы перечисляем именительные, объективные и родительные местоимения, за которыми следуют вопросительные и относительные местоимения. Не хватает только возвратных местоимений, таких как "myself"(я).</em></p>
<p><em></p><div class="fragment"><div class="line">(word I     pronoun 1sing (common nom) -wh speaker)</div><div class="line">(word we    pronoun 1plur (common nom) -wh speaker+other)</div><div class="line">(word you   pronoun 2pers (common   ?) -wh listener)</div><div class="line">(word he    pronoun 3sing (common nom) -wh male)</div><div class="line">(word she   pronoun 3sing (common nom) -wh female)</div><div class="line">(word it    pronoun 3sing (common   ?) -wh anything)</div><div class="line">(word they  pronoun 3plur (common nom) -wh anything)</div><div class="line"></div><div class="line">(word me    pronoun 1sing (common obj) -wh speaker)</div><div class="line">(word us    pronoun 1plur (common obj) -wh speaker+other)</div><div class="line">(word him   pronoun 3sing (common obj) -wh male)</div><div class="line">(word her   pronoun 3sing (common obj) -wh female)</div><div class="line">(word them  pronoun 3plur (common obj) -wh anything)</div><div class="line"></div><div class="line">(word my    pronoun 1sing gen -wh speaker)</div><div class="line">(word our   pronoun 1plur gen -wh speaker+other)</div><div class="line">(word your  pronoun 2pers gen -wh listener)</div><div class="line">(word his   pronoun 3sing gen -wh male)</div><div class="line">(word her   pronoun 3sing gen -wh female)</div><div class="line">(word its   pronoun 3sing gen -wh anything)</div><div class="line">(word their pronoun 3plur gen -wh anything)</div><div class="line">(word whose pronoun 3sing gen +wh anything)</div><div class="line"></div><div class="line">(word who   pronoun ? (common ?) +wh person)</div><div class="line">(word whom  pronoun ? (common obj) +wh person)</div><div class="line">(word what  pronoun ? (common ?) +wh thing)</div><div class="line">(word which pronoun ? (common ?) +wh thing)</div><div class="line"></div><div class="line">(word who   rel-pro ? person)</div><div class="line">(word which rel-pro ? thing)</div><div class="line">(word that  rel-pro ? thing)</div><div class="line">(word whom  rel-pro (common obj) person)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Имена(Names)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Для того или иного примера удобны следующие имена:</em></p>
<p><em></p><div class="fragment"><div class="line">(word God   name 3sing)  (word Lynn  name 3sing)</div><div class="line">(word Jan   name 3sing)  (word Mary  name 3sing)</div><div class="line">(word John  name 3sing)  (word NY    name 3sing)</div><div class="line">(word Kim   name 3sing)  (word LA    name 3sing)</div><div class="line">(word Lee   name 3sing)  (word SF    name 3sing)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Прилагательные(Adjectives)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Вот несколько прилагательных:</em></p>
<p><em></p><div class="fragment"><div class="line">(word big   adj big)    (word bad   adj bad)</div><div class="line">(word old   adj old)    (word smart adj smart)</div><div class="line">(word green adj green)  (word red   adj red)</div><div class="line">(word tall  adj tall)   (word fun   adj fun)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Наречия(Adverbs)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Приведенные здесь наречия включают вопросительные:</em></p>
<p><em></p><div class="fragment"><div class="line">(word quickly adv -wh quickly)</div><div class="line">(word slowly  adv -wh slowly)</div><div class="line"></div><div class="line">(word where   adv +wh loc)</div><div class="line">(word when    adv +wh time)</div><div class="line">(word why     adv +wh reason)</div><div class="line">(word how     adv +wh manner)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Артикли(Articles)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Общие артикли перечислены здесь:</em></p>
<p><em></p><div class="fragment"><div class="line">(word the   art 3sing the)</div><div class="line">(word the   art 3plur group)</div><div class="line">(word a     art 3sing a)</div><div class="line">(word an    art 3sing a)</div><div class="line">(word every art 3sing every)</div><div class="line">(word each  art 3sing each)</div><div class="line">(word all   art 3sing all)</div><div class="line">(word some  art ?     some)</div><div class="line"></div><div class="line">(word this  art 3sing this)</div><div class="line">(word that  art 3sing that)</div><div class="line">(word these art 3plur this)</div><div class="line">(word those art 3plur that)</div><div class="line"></div><div class="line">(word what  art ?     wh)</div><div class="line">(word which art ?     wh)</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Кардинальные(Cardinal) и порядковые(Ordinal) числа</h3>
<p></em></p>
<p><em></em></p>
<p><em>Мы можем воспользоваться возможностями <code>format</code>, чтобы пополнить лексикон. Чтобы выйти за пределы 20, нам понадобится подграмматика чисел.</em></p>
<p><em></p><div class="fragment"><div class="line">;; This puts in numbers up to twenty, as if by</div><div class="line">;; (word five cardinal 5 3plur)</div><div class="line">;; (word fifth ordinal 5)</div><div class="line"></div><div class="line">(dotimes (i 21)</div><div class="line">  (add-word (read-from-string (format nil &quot;~r&quot; i))</div><div class="line">            &#39;cardinal i (if (= i 1) &#39;3sing &#39;3plur))</div><div class="line">  (add-word (read-from-string (format nil &quot;~:r&quot; i)) &#39;ordinal i))</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Предлоги(Prepositions)</h3>
<p></em></p>
<p><em></em></p>
<p><em>Вот довольно полный список предлогов:</em></p>
<p><em></p><div class="fragment"><div class="line">(word above prep)  (word about prep)  (word around prep)</div><div class="line">(word across prep) (word after prep)  (word against prep)</div><div class="line">(word along prep)  (word at prep)     (word away prep)</div><div class="line">(word before prep) (word behind prep) (word below prep)</div><div class="line">(word beyond prep) (word by prep)     (word down prep)</div><div class="line">(word for prep)    (word from prep)   (word in prep)</div><div class="line">(word of prep)     (word off prep)    (word on prep)</div><div class="line">(word out prep)    (word over prep)   (word past prep)</div><div class="line">(word since prep)  (word through prep)(word throughout prep)</div><div class="line">(word till prep)   (word to prep)     (word under prep)</div><div class="line">(word until prep)  (word up prep)     (word with prep)</div><div class="line">(word without prep)</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.12 Поддержка лексикона</h2>
<p></em></p>
<p><em></em></p>
<p><em>В этом разделе описывается реализация макросов <code>word</code>, <code>verb, noun</code> и <code>abbrev.</code> Сокращения(Abbreviations) хранятся в хеш-таблице. Макрос <code>abbrev</code> и функции <code>get-abbrev</code> и <code>clear-abbrevs</code> определяют интерфейс. Мы увидим, как расширять аббревиатуры позже.</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *abbrevs* (make-hash-table))</div><div class="line"></div><div class="line">(defmacro abbrev (symbol definition)</div><div class="line">  &quot;Make symbol be an abbreviation for definition.&quot;</div><div class="line">  `(setf (gethash &#39;,symbol *abbrevs*) &#39;,definition))</div><div class="line"></div><div class="line">(defun clear-abbrevs () (clrhash *abbrevs*))</div><div class="line">(defun get-abbrev (symbol) (gethash symbol *abbrevs*))</div></div><!-- fragment --><p></em></p>
<p><em>Слова(words) также хранятся в хеш-таблице. В настоящее время слова являются символами, но, возможно, было бы лучше использовать для слов строки, поскольку тогда мы могли бы поддерживать информацию о заглавных буквах. Макрос <code>word</code> или функция <code>add-word</code> добавляет слово в лексикон. При использовании в качестве индекса в хэш-таблице каждое слово возвращает список записей, где первый элемент каждой записи является категорией слова, а остальные элементы зависят от категории.</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *words* (make-hash-table :size 500))</div><div class="line"></div><div class="line">(defmacro word (word cat &amp;rest info)</div><div class="line">  &quot;Put word, with category and subcat info, into lexicon.&quot;</div><div class="line">  `(add-word &#39;,word &#39;,cat .,(mapcar #&#39;kwote info)))</div><div class="line"></div><div class="line">(defun add-word (word cat &amp;rest info)</div><div class="line">  &quot;Put word, with category and other info, into lexicon.&quot;</div><div class="line">  (push (cons cat (mapcar #&#39;expand-abbrevs-and-variables info))</div><div class="line">        (gethash word *words*))</div><div class="line">  word)</div><div class="line"></div><div class="line">(defun kwote (x) (list &#39;quote x))</div></div><!-- fragment --><p></em></p>
<p><em>Функция <code>expand-abbrevs-and-variables</code> раскрывает сокращения и заменяет структуры переменных для символов начинающиеся с ?. Это упрощает изготовление копии структуры, которая понадобится позже.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun expand-abbrevs-and-variables (exp)</div><div class="line">  &quot;Replace all variables in exp with vars, and expand abbrevs.&quot;</div><div class="line">  (let ((bindings nil))</div><div class="line">    (labels</div><div class="line">      ((expand (exp)</div><div class="line">         (cond</div><div class="line">           ((lookup exp bindings))</div><div class="line">           ((eq exp &#39;?) (?))</div><div class="line">           ((variable-p exp)</div><div class="line">            (let ((var (?)))</div><div class="line">              (push (cons exp var) bindings)</div><div class="line">              var))</div><div class="line">           ((consp exp)</div><div class="line">            (reuse-cons (expand (first exp))</div><div class="line">                        (expand (rest exp))</div><div class="line">                        exp))</div><div class="line">           (t (multiple-value-bind (expansion found?)</div><div class="line">                  (get-abbrev exp)</div><div class="line">                (if found?</div><div class="line">                    (expand-abbrevs-and-variables expansion)</div><div class="line">                    exp))))))</div><div class="line">      (expand exp))))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы можем хранить слова в лексиконе, но нам нужен какой-то способ их извлечения. Функция <code>word/n</code> принимает слово (которое должно быть преобразовано в символ), категорию и необязательную дополнительную информацию и находит записи в лексиконе для этого слова, которые объединяются с категорией и дополнительной информацией. Для каждого совпадения она вызывает предоставленное продолжение. Это означает, что <code>word/n</code> заменяет длинный список словесных фактов. Есть три отличия:<code>word/n</code> хеширует, поэтому она будет быстрее; она инкрементна (вы можете добавлять слово за раз без необходимости перекомпилировать); и её нельзя использовать, когда слово не связано. (Нетрудно изменить её для обработки несвязанного слова с помощью <code>maphash</code>, но есть более эффективные способы решения этой проблемы.)</em></p>
<p><em></p><div class="fragment"><div class="line">(defun word/n (word cat cont &amp;rest info)</div><div class="line">  &quot;Retrieve a word from the lexicon.&quot;</div><div class="line">  (unless (unbound-var-p (deref word))</div><div class="line">    (let ((old-trail (fill-pointer *trail*)))</div><div class="line">      (dolist (old-entry (gethash word *words*))</div><div class="line">        (let ((entry (deref-copy old-entry)))</div><div class="line">          (when (and (consp entry)</div><div class="line">                     (unify! cat (first entry))</div><div class="line">                     (unify! info (rest entry)))</div><div class="line">            (funcall cont)))</div><div class="line">        (undo-bindings! old-trail)))))</div></div><!-- fragment --><p></em></p>
<p><em>Обратите внимание, что <code>word/n</code>` не следует нашему соглашению помещать продолжение последним. Поэтому нам потребуются следующие дополнительные функции:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun word/2 (w cat cont) (word/n w cat cont))</div><div class="line">(defun word/3 (w cat a cont) (word/n w cat cont a))</div><div class="line">(defun word/4 (w cat a b cont) (word/n w cat cont a b))</div><div class="line">(defun word/5 (w cat a b c cont) (word/n w cat cont a b c))</div><div class="line">(defun word/6 (w cat a b c d cont) (word/n w cat cont a b c d))</div></div><!-- fragment --><p></em></p>
<p><em>Мы могли бы создать целый лексикон с помощью макроса <code>word</code>, но для некоторых классов удобно создавать определенные макросы. Макрос <code>noun</code>(существительное) используется для создания двух записей, одна для единственного числа, а вторая - для множественного. Аргументы - это существительное с основанием, за которым может следовать множественное число (по умолчанию - основание плюс "s"), семантика (по умолчанию - основание) и список дополнений. Массовые существительные, такие как "furniture"(мебель), имеют только одну запись и помечены звездочкой вместо множественного числа.</em></p>
<p><em></p><div class="fragment"><div class="line">(defmacro noun (base &amp;rest args)</div><div class="line">  &quot;Add a noun and its plural to the lexicon.&quot;</div><div class="line">  `(add-noun-form &#39;,base ,@(mapcar #&#39;kwote args)))</div><div class="line"></div><div class="line">(defun add-noun-form (base &amp;optional (plural (symbol base &#39;s))</div><div class="line">                      (sem base) &amp;rest slots)</div><div class="line">  (if (eq plural &#39;*)</div><div class="line">      (add-word base &#39;noun &#39;? slots sem)</div><div class="line">      (progn</div><div class="line">        (add-word base &#39;noun &#39;3sing slots sem)</div><div class="line">        (add-word plural &#39;noun &#39;3plur slots sem))))</div></div><!-- fragment --><p></em></p>
<p><em>Глаголы более сложные. Каждый глагол состоит из семи элементов: основного или нефинитного, настоящего времени единственного и множественного числа, прошедшего времени, причастия прошедшего времени, причастия настоящего и пассивного. Макрос <code>verb</code> автоматически генерирует все семь записей. Глаголы, у которых нет всех из них, могут обрабатываться отдельными вызовами <code>word</code>. Мы автоматически обрабатываем орфографию для простых случаев добавления "s," "ing" и "ed," и, возможно, удаления конечной гласной. Необходимо явно указать более неправильное написание. Вот три примера использования <code>verb</code>:</em></p>
<p><em></p><div class="fragment"><div class="line">(verb (do did done doing does) (perform v/trans))</div><div class="line">(verb (eat ate eaten) (eat v/trans))</div><div class="line">(verb (trust) (trust v/trans ((agt 1 (NP ?)) (obj 2 (PP in ?)))))</div></div><!-- fragment --><p></em></p>
<p><em>А вот определение макроса:</em></p>
<p><em></p><div class="fragment"><div class="line">(defmacro verb ((base &amp;rest forms) &amp;body senses)</div><div class="line">  &quot;Enter a verb into the lexicon.&quot;</div><div class="line">  `(add-verb &#39;,senses &#39;,base ,@(mapcar #&#39;kwote (mklist forms))))</div><div class="line"></div><div class="line">(defun add-verb (senses base &amp;optional</div><div class="line">                 (past (symbol (strip-vowel base) &#39;ed))</div><div class="line">                 (past-part past)</div><div class="line">                 (pres-part (symbol (strip-vowel base) &#39;ing))</div><div class="line">                 (plural (symbol base &#39;s)))</div><div class="line">  &quot;Enter a verb into the lexicon.&quot;</div><div class="line">  (add-word base &#39;verb &#39;nonfinite senses)</div><div class="line">  (add-word base &#39;verb &#39;(finite ~3sing present) senses)</div><div class="line">  (add-word past &#39;verb &#39;(finite ? past) senses)</div><div class="line">  (add-word past-part &#39;verb &#39;-en senses)</div><div class="line">  (add-word pres-part &#39;verb &#39;-ing senses)</div><div class="line">  (add-word plural &#39;verb &#39;(finite 3sing present) senses)</div><div class="line">  (add-word past-part &#39;verb &#39;passive</div><div class="line">            (mapcar #&#39;passivize-sense</div><div class="line">                    (expand-abbrevs-and-variables senses))))</div></div><!-- fragment --><p></em></p>
<p><em>При этом используются несколько вспомогательных функций. Во-первых, <code>strip-vowel</code> удаляет гласную, если это последний символ данного аргумента. Идея состоит в том, что для глагола, такого как "fire"(гореть), удаление гласного дает "fir", из которого мы можем автоматически получить "fired" и "firing".</em></p>
<p><em></p><div class="fragment"><div class="line">(defun strip-vowel (word)</div><div class="line">  &quot;Strip off a trailing vowel from a string.&quot;</div><div class="line">  (let* ((str (string word))</div><div class="line">         (end (- (length str) 1)))</div><div class="line">    (if (vowel-p (char str end))</div><div class="line">        (subseq str 0 end)</div><div class="line">        str)))</div><div class="line"></div><div class="line">(defun vowel-p (char) (find char &quot;aeiou&quot; :test #&#39;char-equal))</div></div><!-- fragment --><p></em></p>
<p><em>Мы также предоставляем функцию для автоматической генерации пассивного смысла с соответствующими списками дополнений. Идея состоит в том, что слот подлежащего активного глагола становится необязательным слотом, отмеченным предлогом "by", и любой слот, отмеченный цифрой 2, может быть повышен до подлежащего(subject):</em></p>
<p><em></p><div class="fragment"><div class="line">(defun passivize-sense (sense)</div><div class="line">  ;; The first element of sense is the semantics; rest are slots</div><div class="line">  (cons (first sense) (mapcan #&#39;passivize-subcat (rest sense))))</div><div class="line"></div><div class="line">(defun passivize-subcat (slots)</div><div class="line">  &quot;Return a list of passivizations of this subcat frame.&quot;</div><div class="line">  ;; Whenever the 1 slot is of the form (?any 1 (NP ?)),</div><div class="line">  ;; demote the 1 to a (3), and promote any 2 to a 1.</div><div class="line">  (when (and (eql (slot-number (first slots)) 1)</div><div class="line">             (starts-with (third (first slots)) &#39;NP))</div><div class="line">    (let ((old-1 `(,(first (first slots)) (3) (PP by ?))))</div><div class="line">      (loop for slot in slots</div><div class="line">            when (eql (slot-number slot) 2)</div><div class="line">            collect `((,(first slot) 1 ,(third slot))</div><div class="line">                      ,@(remove slot (rest slots))</div><div class="line">                      ,old-1)))))</div><div class="line"></div><div class="line">(defun slot-number (slot) (first-or-self (second slot)))</div></div><!-- fragment --><p></em></p>
<p><em>Наконец, мы предоставляем специальную функцию только для определения связки "be"(быть).</em></p>
<p><em></p><div class="fragment"><div class="line">(defun copula (senses entries)</div><div class="line">  &quot;Copula entries are both aux and main verb.&quot;</div><div class="line">  ;; They also are used in passive verb phrases and aux-inv-S</div><div class="line">  (dolist (entry entries)</div><div class="line">    (add-word (first entry) &#39;aux (second entry) (third entry))</div><div class="line">    (add-word (first entry) &#39;verb (second entry) senses)</div><div class="line">    (add-word (first entry) &#39;aux (second entry) &#39;passive)</div><div class="line">    (add-word (first entry) &#39;be)))</div></div><!-- fragment --><p></em></p>
<p><em>Остальные функции используются для тестирования, отладки и расширения грамматики. Во-первых, нам нужны функции, чтобы очистить все, чтобы мы могли начать заново. Эти функции можно разместить в верхней части файлов лексики и грамматики соответственно:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun clear-lexicon ()</div><div class="line">  (clrhash *words*)</div><div class="line">  (clear-abbrevs))</div><div class="line"></div><div class="line">(defun clear-grammar ()</div><div class="line">  (clear-examples)</div><div class="line">  (clear-db))</div></div><!-- fragment --><p></em></p>
<p><em>Тестирование может быть выполнено с помощью <code>run-examples</code>, но удобно предоставить другой интерфейс, макрос <code>try</code> (и соответствующую ему функцию <code>try-dcg</code>). И макрос, и функцию можно вызывать тремя способами. Без аргументов запускаются все примеры, хранящиеся в: ex. Когда указано имя категории, запускаются все примеры только для этой категории. Наконец, пользователь может указать как название категории, так и список слов, чтобы проверить, могут ли эти слова быть проанализированы как эта категория. Эта опция доступна только для категорий, перечисленных в определении:</em></p>
<p><em></p><div class="fragment"><div class="line">(defmacro try (&amp;optional cat &amp;rest words)</div><div class="line">  &quot;Tries to parse WORDS as a constituent of category CAT.</div><div class="line">  With no words, runs all the :ex examples for category.</div><div class="line">  With no cat, runs all the examples.&quot;</div><div class="line">  `(try-dcg &#39;,cat &#39;,words))</div><div class="line"></div><div class="line">(defun try-dcg (&amp;optional cat words)</div><div class="line">  &quot;Tries to parse WORDS as a constituent of category CAT.</div><div class="line">  With no words, runs all the :ex examples for category.</div><div class="line">  With no cat, runs all the examples.&quot;</div><div class="line">  (if (null words)</div><div class="line">      (run-examples cat)</div><div class="line">      (let ((args `((gap nil) (gap nil) ?sem ,words ())))</div><div class="line">        (mapc #&#39;test-unknown-word words)</div><div class="line">        (top-level-prove</div><div class="line">          (ecase cat</div><div class="line">            (np `((np ? ? ?wh ?x ,@args)))</div><div class="line">            (vp `((vp ?infl ?x ?sl ?v ,@args)))</div><div class="line">            (pp `((pp ?prep ?role ?wh ?x ,@args)))</div><div class="line">            (xp `((xp ?slot ?constituent ?wh ?x ,@args)))</div><div class="line">            (s  `((s ? ?sem ,words ())))</div><div class="line">            (rel-clause `((rel-clause ? ?x ?sem ,words ())))</div><div class="line">            (clause `((clause ?infl ?x ?int-subj ?v ?g1 ?g2</div><div class="line">                              ?sem ,words ()))))))))</div><div class="line"></div><div class="line">(defun test-unknown-word (word)</div><div class="line">  &quot;Print a warning message if this is an unknown word.&quot;</div><div class="line">  (unless (or (gethash word *words*) (numberp word))</div><div class="line">    (warn &quot;~&amp;Unknown word: ~a&quot; word)))</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.13 Другие примитивы</h2>
<p></em></p>
<p><em></em></p>
<p><em>Для поддержки предикатов: <code>test</code>, созданных в различных правилах грамматики, нам нужны определения предикатов Пролога <code>if, member, =, numberp</code> и <code>atom</code>. Они повторяются здесь:</em></p>
<p><em></p><div class="fragment"><div class="line">(&lt;- (if ?test ?then) (if ?then ?else (fail)))</div><div class="line">(&lt;- (if ?test ?then ?else) (call ?test) ! (call ?then))</div><div class="line">(&lt;- (if ?test ?then ?else) (call ?else))</div><div class="line">(&lt;- (member ?item (?item . ?rest)))</div><div class="line">(&lt;- (member ?item (?x . ?rest)) (member ?item ?rest))</div><div class="line">(&lt;- (= ?x ?x))</div><div class="line">(defun numberp/1 (x cont)</div><div class="line">    (when (numberp (deref x))</div><div class="line">      (funcall cont)))</div><div class="line">(defun atom/1 (x cont)</div><div class="line">    (when (atom (deref x))</div><div class="line">      (funcall cont)))</div><div class="line">(defun call/1 (goal cont)</div><div class="line">    &quot;Try to prove goal by calling it.&quot;</div><div class="line">    (deref goal)</div><div class="line">    (apply (make-predicate (first goal)</div><div class="line">                    (length (args goal)))</div><div class="line">            (append (args goal) (list cont))))</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.14 Примеры</h2>
<p></em></p>
<p><em></em></p>
<p><em>Вот несколько примеров того, что может обрабатывать парсер. Я отредактировал вывод, изменив имена переменных, такие как <code>?168</code>, на более читаемые имена, такие как <code>?J</code>. Первые два примера показывают, что поддерживаются вложенные предложения и что мы можем извлечь составляющую из вложенного предложения:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (try S John promised Kim to persuade Lee to sleep)</div><div class="line">?SEM = (AND (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)</div><div class="line">            (PAST ?P) (PROMISE ?P)</div><div class="line">            (GOAL ?P ?K) (THE ?K (NAME KIM ?K))</div><div class="line">            (CON ?P ?PER) (PERSUADE ?PER) (GOAL ?PER ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)) (CON ?PER ?S) (SLEEP ?S));</div><div class="line">&gt; (try S Who did John promise Kim to persuade to sleep)</div><div class="line">?SEM = (AND (WH ?W (PERSON ?W)) (PAST ?P)</div><div class="line">            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)</div><div class="line">            (PROMISE ?P) (GOAL ?P ?K)</div><div class="line">            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)</div><div class="line">            (PERSUADE ?PER) (GOAL ?PER ?W)</div><div class="line">            (CON ?PER ?S) (SLEEP ?S));</div></div><!-- fragment --><p></em></p>
<p><em>В следующем примере "when"(когда) можно интерпретировать как вопрос о времени любого из трех событий: обещания, убеждения или сна. Грамматика находит все три.</em></p>
<p><em></p><div class="fragment"><div class="line">&gt;(try S When did John promise Kim to persuade Lee to sleep)</div><div class="line">?SEM = (AND (WH ?W (TIME ?S ?W)) (PAST ?P)</div><div class="line">            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)</div><div class="line">            (PROMISE ?P) (GOAL ?P ?K)</div><div class="line">            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)</div><div class="line">            (PERSUADE ?PER) (GOAL ?PER ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)</div><div class="line">            (SLEEP ?S));</div><div class="line">?SEM = (AND (WH ?W (TIME ?PER ?W)) (PAST ?P)</div><div class="line">            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)</div><div class="line">            (PROMISE ?P) (GOAL ?P ?K)</div><div class="line">            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)</div><div class="line">            (PERSUADE ?PER) (GOAL ?PER ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)</div><div class="line">            (SLEEP ?S));</div><div class="line">?SEM = (AND (WH ?W (TIME ?P ?W)) (PAST ?P)</div><div class="line">            (THE ?J (NAME JOHN ?J)) (AGT ?P ?J)</div><div class="line">            (PROMISE ?P) (GOAL ?P ?K)</div><div class="line">            (THE ?K (NAME KIM ?K)) (CON ?P ?PER)</div><div class="line">            (PERSUADE ?PER) (GOAL ?PER ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)) (CON ?PER ?S)</div><div class="line">            (SLEEP ?S)).</div></div><!-- fragment --><p></em></p>
<p><em>В следующем примере показаны вспомогательные глаголы и отрицание. Это неоднозначно между интерпретацией, в которой Ким ищет Ли, и интерпретацией, в которой Ким смотрит на что-то неопределенное от имени Ли.</em></p>
<p><em></p><div class="fragment"><div class="line">&gt;(try S Kim would not have been looking for Lee)</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?S ?K)</div><div class="line">            (EXPECTED ?S) (NOT ?S) (PAST-PARTICIPLE ?S)</div><div class="line">            (PROGRESSIVE ?S) (SEARCH ?S) (PAT ?S ?L)</div><div class="line">            (PAT ?S ?L) (THE ?L (NAME LEE ?L)));</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?2 ?K)</div><div class="line">            (EXPECTED ?2) (NOT ?2) (PAST-PARTICIPLE ?LOOK)</div><div class="line">            (PROGRESSIVE ?LOOK) (LOOK ?LOOK) (FOR ?LOOOK ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)));</div></div><!-- fragment --><p></em></p>
<p><em>Следующие два примера однозначны:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt;(try s It should not surprise you that Kim does not like Lee)</div><div class="line">?SEM = (AND (MANDATORY ?2) (NOT ?2) (SURPRISE ?2) (EXP ?2 ?Y0U)</div><div class="line">            (PRO ?YOU (LISTENER ?YOU)) (CON ?2 ?LIKE)</div><div class="line">            (THE ?K (NAME KIM ?K)) (AGT ?LIKE ?K)</div><div class="line">            (PRESENT ?LIKE) (NOT ?LIKE) (LIKE-1 ?LIKE)</div><div class="line">            (OBJ ?LIKE ?L) (THE ?L (NAME LEE ?L)));</div><div class="line">&gt;(try s Kim did not want Lee to know that the man knew her)</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?W ?K) (PAST ?W)</div><div class="line">            (NOT ?W) (DESIRE ?W) (GOAL ?W ?L)</div><div class="line">            (THE ?L (NAME LEE ?L)) (CON ?W ?KN)</div><div class="line">            (KNOW-THAT ?KN) (CON ?KN ?KN2)</div><div class="line">            (THE ?M (MAN ?M)) (AGT ?KN2 ?M) (PAST ?KN2)</div><div class="line">            (KNOW-OF ?KN2) (OBJ ?KN2 ?HER)</div><div class="line">            (PRO ?HER (FEMALE ?HER))).</div></div><!-- fragment --><p></em></p>
<p><em>Последний пример кажется недвусмысленным, но синтаксический анализатор находит четыре отдельных анализа. Первая - это очевидная интерпретация, когда поиск выполняется быстро, а вторая - быстро изменяет удивление. Последние две интерпретации такие же, как и первые две; они являются артефактами поискового процесса. Должна быть оборудована процедура устранения неоднозначности, чтобы отсеять такие дубликаты.</em></p>
<p><em></p><div class="fragment"><div class="line">&gt;(try s That Kim looked her up quickly surprised me)</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU1 ?K) (PAST ?LU1)</div><div class="line">            (LOOK-UP ?LU1) (PAT ?LU1 ?H) (PRO ?H (FEMALE ?H))</div><div class="line">            (QUICKLY ?LU1) (CON ?S ?LU1) (PAST ?S) (SURPRISE ?S)</div><div class="line">            (EXP ?S ?ME1) (PRO ?ME1 (SPEAKER ?ME1)));</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU2 ?K) (PAST ?LU2)</div><div class="line">            (LOOK-UP ?LU2) (PAT ?LU2 ?H) (PRO ?H (FEMALE ?H))</div><div class="line">            (CON ?S ?LU2) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)</div><div class="line">            (EXP ?S ?ME2) (PRO ?ME2 (SPEAKER ?ME2)));</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU3 ?K) (PAST ?LU3)</div><div class="line">            (LOOK-UP ?LU3) (PAT ?LU3 ?H) (PRO ?H (FEMALE ?H))</div><div class="line">            (QUICKLY ?LU3) (CON ?S ?LU3) (PAST ?S) (SURPRISE ?S)</div><div class="line">            (EXP ?S ?ME3) (PRO ?ME3 (SPEAKER ?ME3)));</div><div class="line">?SEM = (AND (THE ?K (NAME KIM ?K)) (AGT ?LU4 ?K) (PAST ?LU4)</div><div class="line">            (LOOK-UP ?LU4) (PAT ?LU4 ?H) (PRO ?H (FEMALE ?H))</div><div class="line">            (CON ?S ?LU4) (QUICKLY ?S) (PAST ?S) (SURPRISE ?S)</div><div class="line">            (EXP ?S ?ME4) (PRO ?ME4 (SPEAKER ?ME4)));</div></div><!-- fragment --><p></em></p>
<p><em></p><h2>21.15 История и ссылки</h2>
<p></em></p>
<p><em></em></p>
<p><em><a href="B9780080571157500200.xhtml">Chapter 20</a> provides some basic references on natural language. Here we will concentrate on references that provide:</em></p>
<p><em></p><ol type="1">
<li>A comprehensive grammar of English. !!!(p) {:.numlist}</li>
<li>A complete implementation. !!!(p) {:.numlist}</li>
</ol>
<p></em></p>
<p><em>There are a few good textbooks that partially address both issues. Both <a href="B9780080571157500285.xhtml#bb1395">Winograd (1983)</a> and <a href="B9780080571157500285.xhtml#bb0030">Allen (1987)</a> do a good job of presenting the major grammatical features of English and discuss implementation techniques, but they do not provide actual code.</em></p>
<p><em>There are also a few textbooks that concentrate on the second issue. <a href="B9780080571157500285.xhtml#bb0975">Ramsey and Barrett (1987)</a> and <a href="B9780080571157500285.xhtml#bb1295">Walker et al. (1990)</a> provide chapter-length implementations at about the same level of detail as this chapter. Both are recommended. <a href="B9780080571157500285.xhtml#bb0945">Pereira and Shieber 1987</a> and <a href="B9780080571157500285.xhtml#bb0445">Gazdar and Mellish 1989</a> are book-length treatments, but because they cover a variety of parsing techniques rather than concentrating on one in depth, they are actually less comprehensive.</em></p>
<p><em>Several linguists have made serious attempts at addressing the first issue. The largest is the aptly named A <em>Comprehensive Grammar of Contemporary English</em> by Quirk, Greenbaum, Leech and Svartik (1985). More manageable (although hardly concise) is their abridged edition, <em>A Concise Grammar of Contemporary English.</em> Both editions contain a gold mine of examples and facts about the English langauge, but the authors do not attempt to write rigorous rules. <a href="B9780080571157500285.xhtml#bb0510">Harris (1982)</a> and <a href="B9780080571157500285.xhtml#bb0555">Huddleston (1984)</a> offer less complete grammars with greater linguistic rigor.</em></p>
<p><em>Naomi <a href="B9780080571157500285.xhtml#bb1035">Sager (1981)</a> presents the most complete computerized grammar ever published. The grammar is separated into a simple, neat, context-free component and a rather baroque augmentation that manipulates features.</em></p>
<p><em></p><h2>21.16 Упражнения</h2>
<p></em></p>
<p><em></em></p>
<p><em><b>Exercise 21.1 [m]</b> Change the grammar to account better for <em>mass nouns.</em> The current grammar treats mass nouns by making them vague between singular and plural, which is incorrect. They should be treated separately, since there are determiners such as "much" that work only with mass nouns, and other determiners such as "these" that work only with plural count nouns.</em></p>
<p><em><b>Exercise 21.2 [m]</b> Change the grammar to make a distinction between <em>attributive</em> and <em>predicative</em> adjectives. Most adjectives fail into both classes, but some can be used only attributively, as in "an *utter* fool" but not " * the fool is *utter."* Other adjectives can only be used predicatively, as in "the woman was *loath* to admit it" but not "*a *loath* (to admit it) woman."</em></p>
<p><em><b>Exercise 21.3 [h]</b> Implement complement lists for adjectives, so that "loath" would take an obligatory infinitive complement, and "proud" would take an optional (PP of) complement. In connection to the previous exercise, note that it is rare if not impossible for attributive adjectives to take complements: "he is proud," "he is proud of his country" and "a proud citizen" are all acceptable, but "*a proud of his country citizen" is not.</em></p>
<p><em><b>Exercise 21.4 [m]</b> Add rules to advp to allow for adverbs to modify other adverbs, as in "extremely likely" or "very strongly."</em></p>
<p><em><b>Exercise 21.5 [h]</b> Allow adverbs to modify adjectives, as in "very good" or "really delicious." The syntax will be easy, but it is harder to get a reasonable semantics. While you're at it, make sure that you can handle adjectives with so-called <em>noninter- sective</em> semantics. Some adjectives can be handled by intersective semantics: a red circle is something that is red and is a circle. But for other adjectives, this model does not work: a former senator is not something that is former and is a senator-a former senator is not a senator at all. Similarly, a toy elephant is not an elephant.</em></p>
<p><em>The semantics should be represented by something doser to <code>((toy elephant) ?x)</code> rather than <code>(and (toy ?x) (elephant ?x))</code>.</em></p>
<p><em><b>Exercise 21.6 [m]</b> Write a function that notices punctuation instead of ignoring it. It should work something like this:</em></p>
<p><em></p><div class="fragment"><div class="line">(string-&gt;words &quot;Who asked Lee, Kim and John?&quot;)</div><div class="line">(WHO ASKED LEE |,| KIM AND JOHN |?|)</div></div><!-- fragment --><p></em></p>
<p><em><b>Exercise 21.7 [m]</b> Change the grammar to allow optional punctuation marks at the end of sentences and before relative clauses.</em></p>
<p><em><b>Exercise 21.8 [m]</b> Change the grammar to allow conjunction with more than two elements, using commas. Can these rules be generated automatically by <code>conj-rule?</code></em></p>
<p><em><b>Exercise 21.9 [h]</b> Make a distinction between <em>restrictive</em> and <em>nonrestrictive</em> relative clauses. In "The truck *that has 4-wheel drive* costs $5000," the italicized relative clause is restrictive. It serves to identify the truck and thus would be part of the quantifier's restriction. The complete sentence might be interpreted as:</em></p>
<p><em></p><div class="fragment"><div class="line">(and (the ?x (and (truck ?x) (4-wheel-drive ?x)))</div><div class="line">        (costs ?x $5000))</div></div><!-- fragment --><p></em></p>
<p><em>Contrast this to "The truck, which has 4-wheel drive, costs $5000." Here the relative clause is nonrestrictive and thus belongs outside the quantifier's restriction:</em></p>
<p><em></p><div class="fragment"><div class="line">(and (the ?x (truck ?x))</div><div class="line">      (4-wheel-drive ?x) (costs ?x $5000))</div></div><!-- fragment --><p></em></p>
<p><em>Part V The Rest of Lisp !!!(p) {:.parttitle} </em></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
