<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 19</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 19 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Введение в естественный язык</h2>
<blockquote class="doxtable">
<p>Язык везде. </p>
</blockquote>
<p>Он проникает в наши мысли, опосредует наши отношения с другими людьми и даже проникает в наши мечты. Подавляющая часть человеческих знаний хранится и передается на языке. Язык настолько распространен, что мы принимаем его как должное, но без него общество, которое мы знаем, было бы невозможно.</p>
<blockquote class="doxtable">
<p>-Ronand Langacker </p>
</blockquote>
<blockquote class="doxtable">
<p>Language and its Structure(Язык и его структура) (1967) </p>
</blockquote>
<p>Естественный язык - это язык, на котором говорят люди, например английский, немецкий или тагальский. Они противопоставляются искусственным языкам, таким как Lisp, FORTRAN или код Морзе. Обработка естественного языка - важная часть ИИ, потому что язык тесно связан с мыслью. Одним из показателей этого является количество важных книг, в названии которых упоминаются язык и мысль: в ИИ - <em>Компьютерные модели мысли и языка</em> Шэнка и Колби; в лингвистике - <em>Язык, мышление и реальность</em> Уорфа (и Хомского <em>Язык и разум;)</em> в философии - <em>Язык мышления</em> Фодора; в психологии - <em>Мысль и язык</em> Выготского и <em>Язык, память и мысль</em> Джона Андерсона. Действительно, язык - это черта, которую многие считают наиболее характерный для людей. Много споров вызвал вопрос о том, могут ли животные, особенно приматы и дельфины, использовать и "понимать" язык. Подобный спор связан с тем же вопросом, который задают о компьютерах.</p>
<p>Изучение языка традиционно делится на два широких класса: синтаксис, или грамматика, и семантика, или значение. Исторически синтаксис привлекал к себе наибольшее внимание, в основном потому, что на первый взгляд он более податлив для формальных и полуформальных методов. Хотя есть свидетельства того, что граница между ними в лучшем случае нечеткая, мы по-прежнему сохраняем различие для целей этих заметок. Сначала мы рассмотрим "более простую" часть, синтаксис, а затем перейдем к семантике.</p>
<p>Хороший искусственный язык, такой как Лисп или Си, однозначен. Есть только одна интерпретация действительного выражения Лиспа. Конечно, интерпретация может зависеть от текущего состояния мира Лиспа, такого как значение глобальных переменных. Но эти зависимости можно перечислить явно, и как только они будут прописаны, выражение может иметь только одно значение. <a href="#fn0015">1</a></p>
<p>Естественный язык так не работает. Естественные выражения по своей природе неоднозначны, в зависимости от множества факторов, которые невозможно описать полностью. Совершенно разумно, чтобы два человека не пришли к согласию относительно того, что другой человек имел в виду под выражением естественного языка. (Адвокаты и судьи зарабатывают себе на жизнь в основном интерпретацией выражений на естественном языке - законов, которые должны быть недвусмысленными, но это не так.)</p>
<p>Эта глава представляет собой краткое введение в обработку естественного языка. В следующей главе дается более подробное рассмотрение с точки зрения логических грамматик, а в следующей главе все это сведено воедино в полноценную систему.</p>
<h2>19.1 Разбор с помощью грамматики фразовой структуры</h2>
<p>Анализировать предложение означает восстанавливать составную структуру предложения - выяснять, какая последовательность правил генерации могла быть применена, чтобы составить предложение. В общем, может быть несколько возможных путях вывода(производных), и в этом случае мы говорим, что предложение грамматически неоднозначно. В определенных кругах термин "parse/синтаксический анализ" означает достижение понимания значения предложения, а не только его грамматической формы. Позже мы ответим на этот более сложный вопрос.</p>
<p>Начнем с грамматики, определенной на <a href="B9780080571157500029.xhtml#p39">стр. 39</a> для программы generate(создания):</p>
<div class="fragment"><div class="line">(defvar *grammar* nil &quot;The grammar used by GENERATE.&quot;)</div><div class="line"></div><div class="line">(defparameter *grammarl*</div><div class="line">      &#39;((Sentence -&gt; (NP VP))</div><div class="line">          (NP -&gt; (Art Noun))</div><div class="line">          (VP -&gt; (Verb NP))</div><div class="line">          (Art -&gt; the a)</div><div class="line">          (Noun -&gt; man ball woman table)</div><div class="line">          (Verb -&gt; hit took saw liked)))</div></div><!-- fragment --><p>Наш синтаксический анализатор принимает на вход список слов и возвращает структуру, содержащую дерево синтаксического анализа и непроанализированные слова, если таковые имеются. Таким образом, мы можем проанализировать оставшиеся слова в следующей категории, чтобы получить составные правила. Например, при синтаксическом анализе "the man saw the table"(человек увидел таблицу/стол) мы сначала проанализируем "the man"(мужчина/человек), вернув стрктуру, представляющую именную фразу(noun phrase), с оставшимися словами "saw the table.(увидел стол). Этот остаток затем будет проанализирован как глагольная фраза(verb phrase), не возвращая остатка, и две фразы затем могут быть объединены в форму синтаксического анализа, который является полным предложением без остатка.</p>
<p>Прежде чем продолжить, я хочу изменить представление правил грамматики. В настоящее время правила имеют левую часть и список альтернативных правых частей. Но каждая из этих альтернатив - это действительно отдельное правило, поэтому было бы более модульным писать их отдельно. Для программы <code>generate</code> было нормально иметь их все вместе, потому что это облегчало выбор обработки, но теперь мне нужно более гибкое представление. Позже мы захотим добавить дополнительную информацию к каждому правилу, такую ​​как семантика собранной левой части и ограничения между составляющими в правой части, так что правила действительно стали бы довольно большими, если бы мы не разделились. альтернативы. Я также пользуюсь этой возможностью, чтобы прояснить путаницу между словами и символами категорий. По соглашению правая часть может быть либо атомом, и в этом случае это слово, либо списком символов, которые затем все интерпретируются как категории. Чтобы подчеркнуть это, я включил "noun"(существительное) и "verb"(глагол) как существительные в грамматику <code>*grammar3*</code>, которая в остальном эквивалентна предыдущей <code>*grammarl*</code>.</p>
<div class="fragment"><div class="line">(defparameter *grammar3*</div><div class="line">  &#39;((Sentence -&gt; (NP VP))</div><div class="line">    (NP -&gt; (Art Noun))</div><div class="line">    (VP -&gt; (Verb NP))</div><div class="line">    (Art -&gt; the) (Art -&gt; a)</div><div class="line">    (Noun -&gt; man) (Noun -&gt; ball) (Noun -&gt; woman) (Noun -&gt; table)</div><div class="line">    (Noun -&gt; noun) (Noun -&gt; verb)</div><div class="line">    (Verb -&gt; hit) (Verb -&gt; took) (Verb -&gt; saw) (Verb -&gt; liked)))</div><div class="line"></div><div class="line">(setf *grammar* *grammar3*)</div></div><!-- fragment --><p>Я также определяю типы данных <code>rule, parse</code> и <code>tree</code>, а также некоторые функции для доступа к правилам. Rule(Правила) определены как структуры типа list(списка) с тремя слотами: левая сторона, стрелка (которая всегда должна быть представлена как литерал -&gt;) и правая сторона. Сравните это с трактовкой на <a href="B9780080571157500029.xhtml#p40">стр. 40</a>.</p>
<div class="fragment"><div class="line">(defstruct (rule (:type list)) lhs -&gt; rhs sem)</div><div class="line"></div><div class="line">(defstruct (parse) &quot;A parse tree and a remainder.&quot; tree rem)</div><div class="line"></div><div class="line">;; Trees are of the form: (lhs . rhs)</div><div class="line">(defun new-tree (cat rhs) (cons cat rhs))</div><div class="line">(defun tree-lhs (tree) (first tree))</div><div class="line">(defun tree-rhs (tree) (rest tree))</div><div class="line"></div><div class="line">(defun parse-lhs (parse) (tree-lhs (parse-tree parse)))</div><div class="line"></div><div class="line">(defun lexical-rules (word)</div><div class="line">  &quot;Return a list of rules with word on the right hand side.&quot;</div><div class="line">  (or (find-all word *grammar* :key #&#39;rule-rhs :test #&#39;equal)</div><div class="line">      (mapcar #&#39;(lambda (cat) `(,cat -&gt; ,word)) *open-categories*)))</div><div class="line"></div><div class="line">(defun rules-starting-with (cat)</div><div class="line">  &quot;Return a list of rules where cat starts the rhs.&quot;</div><div class="line">  (find-all cat *grammar*</div><div class="line">            :key #&#39;(lambda (rule) (first-or-nil (rule-rhs rule)))))</div><div class="line"></div><div class="line">(defun first-or-nil (x)</div><div class="line">  &quot;The first element of x if it is a list; else nil.&quot;</div><div class="line">  (if (consp x) (first x) nil))</div></div><!-- fragment --><p>Теперь мы готовы определить парсер. Синтаксический анализатор(parser) основной функции принимает список слов для анализа. Она вызывает синтаксический анализ(parse), которая возвращает список всех синтаксических анализов, которые анализируют некоторую подпоследовательность слов, начиная с начала. parser сохраняет только синтаксический анализ без остатка, то есть синтаксический анализ, охватывающий все слова.</p>
<div class="fragment"><div class="line">(defun parser (words)</div><div class="line">  &quot;Return all complete parses of a list of words.&quot;</div><div class="line">  (mapcar #&#39;parse-tree (complete-parses (parse words))))</div><div class="line"></div><div class="line">(defun complete-parses (parses)</div><div class="line">  &quot;Those parses that are complete (have no remainder).&quot;</div><div class="line">  (find-all-if #&#39;null parses :key #&#39;parse-rem))</div></div><!-- fragment --><p>Функция parse смотрит на первое слово и рассматривает каждую категорию, в которую оно может входить. Она выполняет синтаксический анализ первого слова в каждой категории и вызывает <code>extend-parse</code>, чтобы попытаться продолжить полный синтаксический анализ. parse использует <code>mapcan</code> для объединения всех результатов синтаксического анализа. В качестве примера предположим, что мы пытаемся разобрать "the man took the ball."(мужчина взял мяч). parse найдет единственное лексическое правило для "the" и вызовет extend-parse с синтаксическим анализом с tree (Art the) и остатком "man took the ball" без дополнительных категорий.</p>
<p>У <code>extend-parse</code> есть два случая. Если для частичного синтаксического анализа не требуется больше категорий, он возвращает сам синтаксический анализ вместе с любыми анализами, которые могут быть сформированы путем расширения синтаксических анализов, начиная с частичного анализа. В нашем примере есть одно правило, начинающееся с <code>Art</code>, а именно <code>(NP -&gt; (Art Noun))</code>, поэтому функция будет пытаться расширить дерево синтаксического анализа (<code>NP (Art the))</code> с остатком "man took the ball" с категорией существительного(<code>Noun</code>). Вызов метода <code>extension-parse</code> представляет собой второй случай. Сначала мы анализируем "man took the ball,", и для каждого синтаксического анализа, относящегося к категории <code>Noun</code>(Существительное) (будет только один), мы объединяем его с частичным синтаксическим анализом. В этом случае мы получаем <code>(NP (Art the) (Noun man))</code>. Это расширяется как предложение с необходимым VP, и в конечном итоге мы получаем синтаксический анализ полного списка слов.</p>
<div class="fragment"><div class="line">(defun parse (words)</div><div class="line">  &quot;Bottom-up parse, returning all parses of any prefix of words.&quot;</div><div class="line">  (unless (null words)</div><div class="line">    (mapcan #&#39;(lambda (rule)</div><div class="line">                (extend-parse (rule-lhs rule) (list (first words))</div><div class="line">                              (rest words) nil))</div><div class="line">            (lexical-rules (first words)))))</div><div class="line"></div><div class="line">(defun extend-parse (lhs rhs rem needed)</div><div class="line">  &quot;Look for the categories needed to complete the parse.&quot;</div><div class="line">  (if (null needed)</div><div class="line">      ;; If nothing needed, return parse and upward extensions</div><div class="line">      (let ((parse (make-parse :tree (new-tree lhs rhs) :rem rem)))</div><div class="line">        (cons parse</div><div class="line">              (mapcan</div><div class="line">                #&#39;(lambda (rule)</div><div class="line">                    (extend-parse (rule-lhs rule)</div><div class="line">                                  (list (parse-tree parse))</div><div class="line">                                  rem (rest (rule-rhs rule))))</div><div class="line">                (rules-starting-with lhs))))</div><div class="line">      ;; otherwise try to extend rightward</div><div class="line">      (mapcan</div><div class="line">        #&#39;(lambda (p)</div><div class="line">            (if (eq (parse-lhs p) (first needed))</div><div class="line">                (extend-parse lhs (append1 rhs (parse-tree p))</div><div class="line">                              (parse-rem p) (rest needed))))</div><div class="line">        (parse rem))))</div></div><!-- fragment --><p>Это использует вспомогательную функцию append1:</p>
<div class="fragment"><div class="line">(defun append1 (items item)</div><div class="line">  &quot;Add item to end of list of items.&quot;</div><div class="line">  (append items (list item)))</div></div><!-- fragment --><p>Здесь показаны некоторые примеры работы парсера:</p>
<div class="fragment"><div class="line">&gt; (parser &#39;(the table))</div><div class="line">((NP (ART THE) (NOUN TABLE)))</div><div class="line">&gt; (parser &#39;(the ball hit the table))</div><div class="line">((SENTENCE (NP (ART THE) (NOUN BALL))</div><div class="line">                            (VP (VERB HIT)</div><div class="line">                                      (NP (ARTTHE) (NOUN TABLE)))))</div><div class="line">&gt; (parser &#39;(the noun took the verb))</div><div class="line">((SENTENCE (NP (ART THE) (NOUN NOUN))</div><div class="line">                            (VP (VERB TOOK)</div><div class="line">                                      (NP (ARTTHE) (NOUN VERB)))))</div></div><!-- fragment --><h2>19.2 Расширение грамматики и распознавание двусмысленности</h2>
<p>В целом, парсер, похоже, работает нормально, но диапазон предложений, которые мы можем разобрать, весьма ограничен текущей грамматикой. Следующая грамматика включает более широкий спектр языковых фонем: прилагательные(adjectives), предложные(prepositional) фразы - Устойчивые выражения с предлогами, местоимения(pronouns) и имена собственные(proper names). Она также использует обычные лингвистические соглашения для названий категорий, кратко изложенные в таблице ниже:</p>
<table class="doxtable">
<tr>
<th></th><th>Category </th><th>Examples  </th></tr>
<tr>
<td>S </td><td>Sentence </td><td><em>John likes Mary</em> </td></tr>
<tr>
<td>NP </td><td>Noun Phrase </td><td><em>John; a blue table</em> </td></tr>
<tr>
<td>VP </td><td>Verb Phrase </td><td><em>likes Mary; hit the ball</em> </td></tr>
<tr>
<td>PP </td><td>Prepositional Phrase </td><td><em>to Mary; with the man</em> </td></tr>
<tr>
<td>A </td><td>Adjective </td><td><em>little; blue</em> </td></tr>
<tr>
<td>A + </td><td>A list of one or more adjectives </td><td><em>little blue</em> </td></tr>
<tr>
<td>D </td><td>Determiner </td><td><em>the; a</em> </td></tr>
<tr>
<td>N </td><td>Noun </td><td><em>ball; table</em> </td></tr>
<tr>
<td>Name </td><td>Proper Name </td><td><em>John; Mary</em> </td></tr>
<tr>
<td>P </td><td>Preposition </td><td><em>to; with</em> </td></tr>
<tr>
<td>Pro </td><td>Pronoun </td><td><em>you; me</em> </td></tr>
<tr>
<td>V </td><td>Verb </td><td><em>liked; hit</em> </td></tr>
</table>
<p>Вот грамматика:</p>
<div class="fragment"><div class="line">(defparameter *grammar4*</div><div class="line">  &#39;((S -&gt; (NP VP))</div><div class="line">    (NP -&gt; (D N))</div><div class="line">    (NP -&gt; (D A+ N))</div><div class="line">    (NP -&gt; (NP PP))</div><div class="line">    (NP -&gt; (Pro))</div><div class="line">    (NP -&gt; (Name))</div><div class="line">    (VP -&gt; (V NP))</div><div class="line">    (VP -&gt; (V))</div><div class="line">    (VP -&gt; (VP PP))</div><div class="line">    (PP -&gt; (P NP))</div><div class="line">    (A+ -&gt; (A))</div><div class="line">    (A+ -&gt; (A A+))</div><div class="line">    (Pro -&gt; I) (Pro -&gt; you) (Pro -&gt; he) (Pro -&gt; she)</div><div class="line">    (Pro -&gt; it) (Pro -&gt; me) (Pro -&gt; him) (Pro -&gt; her)</div><div class="line">    (Name -&gt; John) (Name -&gt; Mary)</div><div class="line">    (A -&gt; big) (A -&gt; little) (A -&gt; old) (A -&gt; young)</div><div class="line">    (A -&gt; blue) (A -&gt; green) (A -&gt; orange) (A -&gt; perspicuous)</div><div class="line">    (D -&gt; the) (D -&gt; a) (D -&gt; an)</div><div class="line">    (N -&gt; man) (N -&gt; ball) (N -&gt; woman) (N -&gt; table) (N -&gt; orange)</div><div class="line">    (N -&gt; saw) (N -&gt; saws) (N -&gt; noun) (N -&gt; verb)</div><div class="line">    (P -&gt; with) (P -&gt; for) (P -&gt; at) (P -&gt; on) (P -&gt; by) (P -&gt; of) (P -&gt; in)</div><div class="line">    (V -&gt; hit) (V -&gt; took) (V -&gt; saw) (V -&gt; liked) (V -&gt; saws)))</div><div class="line"></div><div class="line">(setf *grammar* *grammar4*)</div></div><!-- fragment --><p>Теперь мы можем разбирать более интересные предложения и можем увидеть явление, которого не было в предыдущих примерах: неоднозначные предложения. Предложение "The man hit the table with the ball"("Человек ударил мячом по столу") имеет два анализа, в одном из где мяч(ball) - это предмет, который попадает в стол(table), а в другом - когда мяч находится на столе или рядом с ним, синтаксический анализатор находит оба этих анализа (хотя конечно, он не придает никакого значения/смысла ни одному синтаксическому анализу):</p>
<div class="fragment"><div class="line">&gt; (parser &#39;(The man hit the table with the ball))</div><div class="line">((S (NP (D THE) (N MAN))</div><div class="line">      (VP (VP (V HIT) (NP (D THE) (N TABLE)))</div><div class="line">          (PP (P WITH) (NP (DTHE) (N BALL)))))</div><div class="line">(S (NP (D THE) (N MAN))</div><div class="line">      (VP (V HIT)</div><div class="line">          (NP (NP (D THE) (N TABLE))</div><div class="line">                        (PP (P WITH) (NP (DTHE) (N BALL)))))))</div></div><!-- fragment --><p>Предложения(Sentences) - не единственная категория, которая может быть неоднозначной, и не все неоднозначности должны быть между синтаксическими анализами в одной и той же категории. Здесь мы видим двусмысленную фразу между предложением и фразой существительного(noun phrase):</p>
<div class="fragment"><div class="line">&gt; (parser &#39;(the orange saw))</div><div class="line">((S (NP (D THE) (N ORANGE)) (VP (V SAW)))</div><div class="line">  (NP (D THE) (A  + (A ORANGE)) (N SAW)))</div></div><!-- fragment --><h2>19.3 Более эффективный анализ</h2>
<p>При использовании более сложных грамматик и более длинных предложений синтаксический анализатор начинает замедляться. Основная проблема в том, что он постоянно повторяет работу. Например, при синтаксическом анализе "The man hit the table with the ball,"(Человек ударил мячом по столу) он должен повторить анализ "with the ball" для обоих результирующих синтаксических анализов, даже если в обоих случаях он получает один и тот же анализ, PP. Мы видели эту проблему раньше и уже получили ответ: мемоизация (см. <a href="#s0035">Раздел 9.6</a>). Чтобы увидеть, насколько поможет мемоизация, нам нужен тест:</p>
<div class="fragment"><div class="line">&gt; (setf s (generate &#39;s))</div><div class="line">(THE PERSPICUOUS BIG GREEN BALL BY A BLUE WOMAN WITH A BIG MAN</div><div class="line">    HIT A TABLE BY THE SAW BY THE GREEN ORANGE)</div><div class="line">&gt; (time (length (parser s)))</div><div class="line">Evaluation of (LENGTH (PARSER S)) took 33.11 Seconds of elapsed time.</div><div class="line">10</div></div><!-- fragment --><p>Предложение S имеет 10 синтаксических разборов, поскольку есть два способа синтаксического анализа подлежащего NP и пять способов синтаксического анализа VP. На обнаружение этих 10 синтаксических анализов с помощью функции синтаксического анализа в том виде, в котором она была написана, потребовалось 33 секунды.</p>
<p>Мы можем значительно улучшить это, запомнив синтаксический анализ (вместе с функциями поиска по таблице). Помимо мемоизации, единственное изменение - очистить таблицу мемоизации в парсере.</p>
<div class="fragment"><div class="line">(memoize &#39;lexical-rules)</div><div class="line">(memoize &#39;rules-starting-with)</div><div class="line">(memoize &#39;parse :test #&#39;eq)</div><div class="line"></div><div class="line">(defun parser (words)</div><div class="line">  &quot;Return all complete parses of a list of words.&quot;</div><div class="line">  (clear-memoize &#39;parse) ;***</div><div class="line">  (mapcar #&#39;parse-tree (complete-parses (parse words))))</div></div><!-- fragment --><p>При обычном использовании человеческого языка мемоизация не будет работать очень хорошо, поскольку интерпретация фразы зависит от контекста, в котором она была произнесена. Но с контекстно-свободными грамматиками у нас есть гарантия, что контекст не может повлиять на интерпретацию. Вызов <code>(parse words)</code> должен возвращать все возможные синтаксические разборы слов. Мы свободны выбирать между возможностями, основанными на контекстной информации, но контекст никогда не может предоставить новую интерпретацию, которая не входит в контекстно-свободный список синтаксических анализов.</p>
<p>Функция <code>use</code> вводиться, чтобы сообщить функциям поиска в таблице, что они устарели при изменении грамматики:</p>
<div class="fragment"><div class="line">(defun use (grammar)</div><div class="line">  &quot;Switch to a new grammar.&quot;</div><div class="line">  (clear-memoize &#39;rules-starting-with)</div><div class="line">  (clear-memoize &#39;lexical-rules)</div><div class="line">  (length (setf *grammar* grammar)))</div></div><!-- fragment --><p>Теперь мы снова запускаем тест с мемоизированной версией синтаксического анализа:</p>
<div class="fragment"><div class="line">&gt; (time (length (parser s)))</div><div class="line">Evaluation of (LENGTH (PARSER S &#39;s)) took .13 Seconds of elapsed time.</div><div class="line">10</div></div><!-- fragment --><p>Мемоизируя <code>parse</code>, мы сокращаем время синтаксического анализа с 33 до 13 секунд, ускорение 250 процентов. Мы можем получить более систематическое сравнение, посмотрев на ряд примеров. Например, рассмотрите предложения формы "The man hit the table [with the ball]*"(Человек ударил по столу [мячом]) для нуля или более повторений PP "with the ball"(с мячом). В следующей таблице мы записываем N, количество повторений PP, вместе с количеством результирующих синтаксических анализов, <a href="# fn0020">2</a> и для мемоизированных и немомизированных версий синтаксического анализа, количество секунд для выполнения синтаксического анализа, количество парсингов в секунду (PPS) и количество рекурсивных вызовов parse. Производительность мемоизированной версии вполне приемлема; для N = 5 предложение из 20 слов разбирается на 132 варианта за 0,68 секунды, в отличие от 20 секунд, которые требуются в незапоминающей версии.</p>
<p>| | | Memoized | | | Unmemoized | | | </p><table class="doxtable">
<tr>
<th>N </th><th>Parses </th><th>Secs </th><th>PPS </th><th>Calls </th><th>Secs </th><th>PPS </th><th>Calls  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>0.02 </td><td>60 </td><td>4 </td><td>0.02 </td><td>60 </td><td>17 </td></tr>
<tr>
<td>1 </td><td>2 </td><td>0.02 </td><td>120 </td><td>11 </td><td>0.07 </td><td>30 </td><td>96 </td></tr>
<tr>
<td>2 </td><td>5 </td><td>0.05 </td><td>100 </td><td>21 </td><td>0.23 </td><td>21 </td><td>381 </td></tr>
<tr>
<td>3 </td><td>14 </td><td>0.10 </td><td>140 </td><td>34 </td><td>0.85 </td><td>16 </td><td>1388 </td></tr>
<tr>
<td>4 </td><td>42 </td><td>0.23 </td><td>180 </td><td>50 </td><td>3.17 </td><td>13 </td><td>4999 </td></tr>
<tr>
<td>5 </td><td>132 </td><td>0.68 </td><td>193 </td><td>69 </td><td>20.77 </td><td>6 </td><td>18174 </td></tr>
<tr>
<td>6 </td><td>429 </td><td>1.92 </td><td>224 </td><td>91 </td><td>- </td><td></td><td></td></tr>
<tr>
<td>7 </td><td>1430 </td><td>5.80 </td><td>247 </td><td>116 </td><td>- </td><td></td><td></td></tr>
<tr>
<td>8 </td><td>4862 </td><td>20.47 </td><td>238 </td><td>144 </td><td>- </td><td></td><td></td></tr>
</table>
<p><b>Упражнение 19.1 [h]</b> Кажется, что мы могли бы быть более эффективными, если бы запомнили таблицу, состоящую из вектора, длина которого равна количеству слов во входных данных (плюс один). Реализуйте этот подход и посмотрите, повлечет ли он меньше накладных расходов, чем более общий подход с хэш-таблицей.</p>
<h2>19.4 Проблема с неизвестным словом</h2>
<p>В его нынешнем виде парсер не может работать с неизвестными словами. Любое предложение, содержащее слово, которого нет в грамматике, будет отклонено, даже если программа сможет идеально проанализировать все остальные слова. Один из способов обращения с неизвестными словами - позволить им быть любой из категорий "open-class"(открытого класса) - существительными, глаголами, прилагательными и именами в нашей грамматике. Неизвестное слово не будет рассматриваться как одна из категорий "closed-class"(закрытого класса) - предлогов, определителей или местоимений. Это можно очень просто запрограммировать, заставив <code>lexical-rules</code> возвращать список этих правил открытого класса для каждого слова, которое еще не известно.</p>
<div class="fragment"><div class="line">(defparameter *open-categories* &#39;(N V A Name)</div><div class="line">  &quot;Categories to consider for unknown words&quot;)</div><div class="line"></div><div class="line">(defun lexical-rules (word)</div><div class="line">  &quot;Return a list of rules with word on the right hand side.&quot;</div><div class="line">  (or (find-all word *grammar* :key #&#39;rule-rhs :test #&#39;equal)</div><div class="line">      (mapcar #&#39;(lambda (cat) `(,cat -&gt; ,word)) *open-categories*)))</div></div><!-- fragment --><p>При запоминании лексических правил это означает, что лексикон расширяется каждый раз, когда встречается неизвестное слово. Давайте попробуем это:</p>
<div class="fragment"><div class="line">&gt; (parser &#39;(John liked Mary))</div><div class="line">((S (NP (NAME JOHN))</div><div class="line">            (VP (V LIKED) (NP (NAME MARY)))))</div><div class="line">&gt; (parser &#39;(Dana liked Dale))</div><div class="line">((S (NP (NAME DANA))</div><div class="line">            (VP (V LIKED) (NP (NAME DALE)))))</div><div class="line">&gt; (parser &#39;(the rab zaggled the woogly quax))</div><div class="line">((S (NP (D THE) (N RAB))</div><div class="line">            (VP (V ZAGGLED) (NP (D THE) (A  + (A WOOGLY)) (N QUAX)))))</div></div><!-- fragment --><p>Мы видим, что синтаксический анализатор также работает со словами, которые он знает (Джон и Мэри), так и с новыми словами (Дана и Дейл), которые он может распознавать как имена из-за их положения в предложении. В последнем предложении в примере он однозначно распознает каждое неизвестное слово. К сожалению, не всегда все так просто, как показывают следующие примеры:</p>
<div class="fragment"><div class="line">&gt; (parser &#39;(the slithy toves gymbled))</div><div class="line">((S (NP (D THE) (N SLITHY)) (VP (V TOVES) (NP (NAME GYMBLED))))</div><div class="line">  (S (NP (D THE) (A  + (A SLITHY)) (N TOVES)) (VP (V GYMBLED)))</div><div class="line">  (NP (D THE) (A  + (A SLITHY) (A  + (A TOVES))) (N GYMBLED)))</div><div class="line">&gt; (parser &#39;(the slithy toves gymbled on the wabe))</div><div class="line">((S (NP (D THE) (N SLITHY))</div><div class="line">      (VP (VP (V TOVES) (NP (NAME GYMBLED)))</div><div class="line">            PP (P ON) (NP (D THE) (N WABE)))))</div><div class="line">(S (NP (D THE) (N SLITHY))</div><div class="line">      (VP (V TOVES) (NP (NP (NAME GYMBLED))</div><div class="line">            (PP (P ON) (NP (D THE) (N WABE))))))</div><div class="line">(S (NP (D THE) (A  + (A SLITHY)) (N TOVES))</div><div class="line">        (VP (VP (V GYMBLED)) (PP (P ON) (NP (D THE) (N WABE)))))</div><div class="line">(NP (NP (D THE) (A  + (A SLITHY) (A  + (A TOVES))) (N GYMBLED))</div><div class="line">        (PP (P ON) (NP (D THE) (N WABE)))))</div></div><!-- fragment --><p>Если бы программа знала морфологию - что <em>y</em> в конце слова часто означает прилагательное(adjective), <em>s</em> - существительное во множественном числе, а <em>ed</em> - глагол в прошедшем времени, - тогда он мог бы добиться большего.</p>
<h2>19.5 Анализ семантического представления</h2>
<p>Синтаксические деревья синтаксического разбора предложения могут быть интересными, но сами по себе они не очень полезны. Мы используем предложения для передачи идей, а не для отображения грамматических структур. Чтобы исследовать идею семантики или значения фразы, нам нужна область для обсуждения. Представьте себе сценарий проигрывателя компакт-дисков, способного воспроизводить выбранные песни на основе их номеров треков. Далее представьте, что на передней панели этой машины есть кнопки, обозначающие числа, а также такие слова, как "play"(играть), "to"(до), "and"(и) и "without"(без). Если затем вы нажмете последовательность кнопок "play 1 to 5 without 3"(воспроизвести с 1 по 5 без 3), можно было бы разумно ожидать, что машина отреагирует воспроизведением треков 1, 2, 4 и 5. После нескольких таких успешных взаимодействий можно сказать, что машина "понимает" ограниченный язык. Важным моментом является то, что полезность этой машины не сильно улучшилась бы, если бы она отображала дерево синтаксического анализа входных данных. С другой стороны, вы были бы оправданно раздражены, если бы она отреагировала на "play 1 to 5 without 3", сыграв 3 или пропустив 4.</p>
<p>Теперь давайте расширим воображение еще раз, предположив, что этот проигрыватель компакт-дисков оснащен полным компилятором Common Lisp, и что теперь мы отвечаем за написание синтаксического анализатора для его языка ввода. Давайте сначала рассмотрим соответствующие структуры данных. Нам нужно добавить компонент семантики как в структуру правил, так и в древовидную структуру. Как только мы это сделаем, станет ясно, что деревья - это не что иное, как экземпляры правил, поэтому их определения должны это отражать. Таким образом, я использую команду: include defstruct для определения деревьев, и я не указываю функцию копирования, потому что copy-tree уже является функцией Common Lisp, и я не хочу ее переопределять. Чтобы поддерживать согласованность со старой функцией new-tree (и чтобы не вводить все эти ключевые слова), я определяю конструктор <code>new-tree</code>. Эта опция <code>defstruct makes (new-tree a b c)</code> эквивалентна <code>(make-tree :lhs a :sem b :rhs c)</code>.</p>
<div class="fragment"><div class="line">(defstruct (rule (:type list)) lhs -&gt; rhs sem)</div><div class="line"></div><div class="line">(defstruct (tree (:type list) (:include rule) (:copier nil)</div><div class="line">                 (:constructor new-tree (lhs sem rhs))))</div></div><!-- fragment --><p>Мы примем соглашение, согласно которому семантика слова может быть любым объектом Lisp. Например, семантика слова "1" может быть объектом 1, а семантика "without"(без) может быть функцией <code>set-difference</code>. Семантика дерева формируется путем взятия семантики правила, которое сгенерировало дерево, и ее применения (как функции) к семантике составляющих дерева. Таким образом, автор грамматики должен убедиться, что семантический компонент правил - это функции, которые ожидают правильное количество аргументов. Например, учитывая правило</p>
<div class="fragment"><div class="line">(NP -&gt; (NP CONJ NP) infix-funcall)</div></div><!-- fragment --><p>тогда семантика фразы "1 to 5 without 3" может быть определена путем определения сначала семантикой "1 to 5"(от 1 до 5) как (1 2 3 4 5), "without" как <code>set-difference</code> и 3 как (3). После того, как эти подкомпоненты определены, правило применяется путем вызова функции <code>infix-funcall</code> с тремя аргументами (1 2 3 4 5), <code>set-difference</code> и (3). Предполагая, что <code>infix-funcall</code> определен для применения своего второго аргумента к двум другим аргументам, результат будет (1 2 4 5).</p>
<p>Это может иметь больше смысла, если мы посмотрим на полную грамматику проблемы с проигрывателем компакт-дисков:</p>
<div class="fragment"><div class="line">(use</div><div class="line">  &#39;((NP -&gt; (NP CONJ NP) infix-funcall)</div><div class="line">    (NP -&gt; (N)          list)</div><div class="line">    (NP -&gt; (N P N)      infix-funcall)</div><div class="line">    (N -&gt;  (DIGIT)      identity)</div><div class="line">    (P -&gt;  to           integers)</div><div class="line">    (CONJ -&gt; and        ordered-union)</div><div class="line">    (CONJ -&gt; without    ordered-set-difference)</div><div class="line">    (N -&gt; 1 1) (N -&gt; 2 2) (N -&gt; 3 3) (N -&gt; 4 4) (N -&gt; 5 5)</div><div class="line">    (N -&gt; 6 6) (N -&gt; 7 7) (N -&gt; 8 8) (N -&gt; 9 9) (N -&gt; 0 0)))</div><div class="line"></div><div class="line">(defun integers (start end)</div><div class="line">  &quot;A list of all the integers in the range [start...end] inclusive.&quot;</div><div class="line">  (if (&gt; start end) nil</div><div class="line">      (cons start (integers (+ start 1) end))))</div><div class="line"></div><div class="line">(defun infix-funcall (arg1 function arg2)</div><div class="line">  &quot;Apply the function to the two arguments&quot;</div><div class="line">  (funcall function arg1 arg2))</div></div><!-- fragment --><p>Рассмотрим первые три грамматических правила, которые являются единственными нелексическими правилами. Первое говорит, что когда два NP соединяются conjunction(соединением), мы предполагаем, что перевод соединения будет функцией, а перевод фразы в целом получается путем вызова этой функции с переводами двух NP в качестве аргументов. Второе правило гласит, что одно существительное (перевод которого должен быть числом) переводится в одноэлементный список, состоящий из этого числа. Третье правило похоже на первое, но касается joining(присоединения) Ns, а не NP. Общая цель состоит в том, чтобы перевод NP всегда был списком целых чисел, представляющих песни для воспроизведения.</p>
<p>Что касается лексических правил, союз "and"(и) переводится в функцию union(объединения), "without"(без) переводится в функцию, которая вычитает один набор из другого, а "to"(в) переводится в функцию, которая генерирует список целых чисел между двумя конечными точками. Цифры от "0" до "9" переводятся сами в себя. Обратите внимание, что как лексические правила, такие как "`CONJ -&gt;` and", так и нелексические правила, такие как "`NP -&gt; (N P N)`", могут иметь функции в качестве своих семантических переводов; в первом случае функция будет просто возвращена как семантический перевод, тогда как во втором случае функция будет применена к списку составляющих.</p>
<p>Для поддержки такого рода семантической обработки требуются лишь незначительные изменения. Как мы увидим ниже, мы добавляем аргумент sem для расширения - синтаксического анализа и упорядочивания для правильной передачи семантических компонентов. Когда мы собрали все компоненты с правой стороны, мы фактически выполняем применение(вызов) функции. Все изменения отмечены ***. Мы принимаем соглашение, согласно которому семантическое значение <code>nil</code> указывает на сбой, и отбрасываем все такие синтаксические анализы.</p>
<div class="fragment"><div class="line">(defun parse (words)</div><div class="line">  &quot;Bottom-up parse, returning all parses of any prefix of words.</div><div class="line">  This version has semantics.&quot;</div><div class="line">  (unless (null words)</div><div class="line">    (mapcan #&#39;(lambda (rule)</div><div class="line">                (extend-parse (rule-lhs rule) (rule-sem rule) ;***</div><div class="line">                              (list (first words)) (rest words) nil))</div><div class="line">            (lexical-rules (first words)))))</div><div class="line"></div><div class="line">(defun extend-parse (lhs sem rhs rem needed) ;***</div><div class="line">  &quot;Look for the categories needed to complete the parse.</div><div class="line">  This version has semantics.&quot;</div><div class="line">  (if (null needed)</div><div class="line">      ;; If nothing is needed, return this parse and upward extensions,</div><div class="line">      ;; unless the semantics fails</div><div class="line">      (let ((parse (make-parse :tree (new-tree lhs sem rhs) :rem rem)))</div><div class="line">        (unless (null (apply-semantics (parse-tree parse))) ;***</div><div class="line">          (cons parse</div><div class="line">                (mapcan</div><div class="line">                  #&#39;(lambda (rule)</div><div class="line">                      (extend-parse (rule-lhs rule) (rule-sem rule) ;***</div><div class="line">                                    (list (parse-tree parse)) rem</div><div class="line">                                    (rest (rule-rhs rule))))</div><div class="line">                  (rules-starting-with lhs)))))</div><div class="line">      ;; otherwise try to extend rightward</div><div class="line">      (mapcan</div><div class="line">        #&#39;(lambda (p)</div><div class="line">            (if (eq (parse-lhs p) (first needed))</div><div class="line">                (extend-parse lhs sem (append1 rhs (parse-tree p)) ;***</div><div class="line">                              (parse-rem p) (rest needed))))</div><div class="line">        (parse rem))))</div></div><!-- fragment --><p>Нам нужно добавить несколько новых функций для поддержки этого:</p>
<div class="fragment"><div class="line">(defun apply-semantics (tree)</div><div class="line">  &quot;For terminal nodes, just fetch the semantics.</div><div class="line">  Otherwise, apply the sem function to its constituents.&quot;</div><div class="line">  (if (terminal-tree-p tree)</div><div class="line">      (tree-sem tree)</div><div class="line">      (setf (tree-sem tree)</div><div class="line">            (apply (tree-sem tree)</div><div class="line">                   (mapcar #&#39;tree-sem (tree-rhs tree))))))</div><div class="line"></div><div class="line">(defun terminal-tree-p (tree)</div><div class="line">  &quot;Does this tree have a single word on the rhs?&quot;</div><div class="line">  (and (length=1 (tree-rhs tree))</div><div class="line">       (atom (first (tree-rhs tree)))))</div><div class="line"></div><div class="line">(defun meanings (words)</div><div class="line">  &quot;Return all possible meanings of a phrase.  Throw away the syntactic part.&quot;</div><div class="line">  (remove-duplicates (mapcar #&#39;tree-sem (parser words)) :test #&#39;equal))</div></div><!-- fragment --><p>Вот несколько примеров значений, которые может извлечь парсер:</p>
<p>(meanings '(1 to 5 without 3))</p>
<p>((1 2 4 5))</p>
<p>(meanings '(1 to 4 and 7 to 9))</p>
<p>((1 2 3 4 7 8 9))</p>
<p>(meanings '(1 to 6 without 3 and 4))</p>
<p>((12 4 5 6)</p>
<p>(1 2 5 6))</p>
<p>Пример "(1 to 6 without 3 and 4)"-(от 1 до 6 без 3 и 4) неоднозначен. Первое прочтение соответствует "((1 to 6) without 3) and 4", а второе соответствует "(1 to 6) without (3 and 4)". Синтаксическая неоднозначность приводит к семантической неоднозначности - два значения имеют в себе разные списки чисел. Однако кажется, что второе прочтение в чем-то лучше, поскольку не имеет большого смысла говорить о добавлении 4 к набору, который уже включает его, что и делает первый перевод.</p>
<p>Мы можем обновить лексикон, чтобы учесть это. Следующая лексика утверждает, что "and" соединяет непересекающиеся множества и что "without" удаляет только элементы, которые уже были в первом аргументе. Если эти условия не выполняются, перевод вернет nil, и синтаксический анализ завершится неудачно. Обратите внимание, что это также означает, что пустой список, такой как "3 to 2"» также не сработает.</p>
<p>Предыдущая грамматика допускала только цифры от 0 до 9. Мы можем допустить большее число, соединяя цифры вместе. Итак, теперь у нас есть два правила для чисел: число - это либо одна цифра, и в этом случае значение является самой цифрой (функция identity), либо это число, за которым следует другая цифра, и в этом случае значение равно 10-кратное число плюс цифра. В качестве альтернативы мы могли бы указать число как цифру, за которой следует число, или даже число, за которым следует число, но любая из этих формулировок потребует более сложной семантической интерпретации.</p>
<div class="fragment"><div class="line">(use</div><div class="line">  &#39;((NP -&gt; (NP CONJ NP) infix-funcall)</div><div class="line">    (NP -&gt; (N)          list)</div><div class="line">    (NP -&gt; (N P N)      infix-funcall)</div><div class="line">    (N -&gt;  (DIGIT)      identity)</div><div class="line">    (N -&gt;  (N DIGIT)    10*N+D)</div><div class="line">    (P -&gt;  to           integers)</div><div class="line">    (CONJ -&gt; and        union*)</div><div class="line">    (CONJ -&gt; without    set-diff)</div><div class="line">    (DIGIT -&gt; 1 1) (DIGIT -&gt; 2 2) (DIGIT -&gt; 3 3)</div><div class="line">    (DIGIT -&gt; 4 4) (DIGIT -&gt; 5 5) (DIGIT -&gt; 6 6)</div><div class="line">    (DIGIT -&gt; 7 7) (DIGIT -&gt; 8 8) (DIGIT -&gt; 9 9)</div><div class="line">    (DIGIT -&gt; 0 0)))</div><div class="line"></div><div class="line">(defun union* (x y) (if (null (intersection x y)) (append x y)))</div><div class="line">(defun set-diff (x y) (if (subsetp y x) (ordered-set-difference x y)))</div><div class="line">(defun 10*N+D (N D) (+ (* 10 N) D))</div></div><!-- fragment --><p>С помощью этой новой грамматики мы можем получить единственные интерпретации из наиболее разумных входных данных:</p>
<div class="fragment"><div class="line">&gt; (meanings &#39;(1 to 6 without 3 and 4))</div><div class="line">((1 2 5 6))</div><div class="line">&gt; (meanings &#39;(1 and 3 to 7 and 9 without 5 and 6))</div><div class="line">((13 4 7 9))</div><div class="line">&gt; (meanings &#39;(1 and 3 to 7 and 9 without 5 and 2))</div><div class="line">((1 3 4 6 7 9 2))</div><div class="line">&gt; (meanings &#39;(1 9 8 to 2 0 1))</div><div class="line">((198 199 200 201))</div><div class="line">&gt; (meanings &#39;(1 2 3))</div><div class="line">(123 (123))</div></div><!-- fragment --><p>Пример "1 2 3" показывает неоднозначность между числом 123 и списком (123), но все остальные однозначны.</p>
<h2>19.6 Разбор с Предпочтениями(Preferences)</h2>
<p>Одна из причин, по которой у нас есть однозначные интерпретации, заключается в том, что у нас очень ограниченная область интерпретации: мы имеем дело с наборами чисел, а не со списками. Это, возможно, типично для запросов, с которыми сталкивается проигрыватель компакт-дисков, но не учитывает весь желаемый ввод. Например, если у вас была любимая песня, вы не могли услышать ее трижды с запросом "1 and 1 and 1" по этой грамматике. Нам нужен некоторый компромисс между разрешающей грамматикой, которая генерирует все возможные синтаксические анализы, и ограничительной грамматикой, которая устраняет слишком много синтаксических анализов. Чтобы получить "лучшую" интерпретацию произвольного ввода, нам потребуется не только новая грамматика, но и модифицировать программу, чтобы сравнить относительную ценность возможных интерпретаций. Другими словами, мы присвоим каждой интерпретации числовой балл, а затем выберем интерпретацию с наивысшим баллом.</p>
<p>Мы начнем с того, что еще раз изменим правила и дерево типов данных, чтобы включить в них компонент оценки. Как и в случае с компонентом sem, он будет использоваться для хранения сначала функции для вычисления оценки, а затем, в конечном итоге, самой оценки.</p>
<div class="fragment"><div class="line">(defstruct (rule (:type list)</div><div class="line">                 (:constructor rule (lhs -&gt; rhs &amp;optional sem score)))</div><div class="line">  lhs -&gt; rhs sem score)</div><div class="line"></div><div class="line">(defstruct (tree (:type list) (:include rule) (:copier nil)</div><div class="line">                 (:constructor new-tree (lhs sem score rhs))))</div></div><!-- fragment --><p>Обратите внимание, что мы добавили функцию-конструктор <code>rule</code>. Намерение состоит в том, что компоненты sem и score в правилах грамматики должны быть необязательными(опциональными). Пользователь не обязан их указывать, но использование функции гарантирует, что функция rule будет вызвана для заполнения отсутствующих значений sem и score с помощью nil.</p>
<div class="fragment"><div class="line">(defun use (grammar)</div><div class="line">  &quot;Switch to a new grammar.&quot;</div><div class="line">  (clear-memoize &#39;rules-starting-with)</div><div class="line">  (clear-memoize &#39;lexical-rules)</div><div class="line">  (length (setf *grammar*</div><div class="line">                (mapcar #&#39;(lambda (r) (apply #&#39;rule r))</div><div class="line">                        grammar))))</div></div><!-- fragment --><p>Теперь модифицируем синтаксический анализатор, чтобы отслеживать баллы(score). Изменения снова незначительны и отражают изменения, необходимые для добавления семантики. Есть два места, где мы помещаем баллы в деревья при их создании, и одно место, где мы применяем функцию подсчета баллов к её аргументам.</p>
<div class="fragment"><div class="line">(defun parse (words)</div><div class="line">  &quot;Bottom-up parse, returning all parses of any prefix of words.&quot;</div><div class="line">  This version has semantics and preference scores.&quot;</div><div class="line">  (unless (null words)</div><div class="line">    (mapcan #&#39;(lambda (rule)</div><div class="line">                (extend-parse (rule-lhs rule) (rule-sem rule)</div><div class="line">                              (rule-score rule) (list (first words)) ;***</div><div class="line">                              (rest words) nil))</div><div class="line">            (lexical-rules (first words)))))</div><div class="line"></div><div class="line">(defun extend-parse (lhs sem score rhs rem needed) ;***</div><div class="line">  &quot;Look for the categories needed to complete the parse.</div><div class="line">  This version has semantics and preference scores.&quot;</div><div class="line">  (if (null needed)</div><div class="line">      ;; If nothing is needed, return this parse and upward extensions,</div><div class="line">      ;; unless the semantics fails</div><div class="line">      (let ((parse (make-parse :tree (new-tree lhs sem score rhs) ;***</div><div class="line">                               :rem rem)))</div><div class="line">        (unless (null (apply-semantics (parse-tree parse)))</div><div class="line">          (apply-scorer (parse-tree parse)) ;***</div><div class="line">          (cons parse</div><div class="line">                (mapcan</div><div class="line">                  #&#39;(lambda (rule)</div><div class="line">                      (extend-parse</div><div class="line">                        (rule-lhs rule) (rule-sem rule)</div><div class="line">                        (rule-score rule) (list (parse-tree parse)) ;***</div><div class="line">                        rem (rest (rule-rhs rule))))</div><div class="line">                  (rules-starting-with lhs)))))</div><div class="line">      ;; otherwise try to extend rightward</div><div class="line">      (mapcan</div><div class="line">        #&#39;(lambda (p)</div><div class="line">            (if (eq (parse-lhs p) (first needed))</div><div class="line">                (extend-parse lhs sem score</div><div class="line">                              (append1 rhs (parse-tree p)) ;***</div><div class="line">                              (parse-rem p) (rest needed))))</div><div class="line">        (parse rem))))</div></div><!-- fragment --><p>И снова нам нужны новые функции для поддержки этого. Самой важной является <code>apply-scorer</code>, которая вычисляет баллы для дерева. Если дерево является терминалом (словом), тогда функция просто ищет оценку(баллы), связанную с этим словом. В этой грамматике все слова имеют оценку 0, но в грамматике с неоднозначными словами было бы неплохо дать более низкие оценки для редко используемых значений неоднозначных слов. Если дерево нетерминальное, то оценка(баллы) вычисляется в два этапа. Сначала складываются все баллы составляющих дерева. Затем это добавляется к мере для дерева в целом. Правило, связанное с каждым деревом, будет иметь либо номер, который добавляется к сумме, либо функцию. В последнем случае функция применяется к дереву, и результат добавляется для получения окончательной оценки. В качестве последнего особого случая, если функция возвращает nil, мы предполагаем, что она должна была вернуть ноль. Это упростит определение некоторых функций подсчета очков.</p>
<div class="fragment"><div class="line">(defun apply-scorer (tree)</div><div class="line">  &quot;Compute the score for this tree.&quot;</div><div class="line">  (let ((score (or (tree-score tree) 0)))</div><div class="line">    (setf (tree-score tree)</div><div class="line">          (if (terminal-tree-p tree)</div><div class="line">              score</div><div class="line">              ;; Add up the constituent&#39;s scores,</div><div class="line">              ;; along with the tree&#39;s score</div><div class="line">              (+ (sum (tree-rhs tree) #&#39;tree-score-or-0)</div><div class="line">                 (if (numberp score)</div><div class="line">                     score</div><div class="line">                     (or (apply score (tree-rhs tree)) 0)))))))</div></div><!-- fragment --><p>Вот функция доступа, позволяющая выбрать баллы из дерева:</p>
<div class="fragment"><div class="line">(defun tree-score-or-0 (tree)</div><div class="line">    (if (numberp (tree-score tree)) (tree-score tree) 0))</div></div><!-- fragment --><p>Вот обновленная грамматика. Во-первых, я не мог отказаться от возможности добавить больше возможностей в грамматику. Я добавил постноминальные прилагательные "shuffled"(перемешанный), которые случайным образом меняют список песен, и "reversed"(обратный), который меняет порядок воспроизведения на обратный. Я также добавил оператор "repeat"(повтор), например "1 to 3 repeat 5", который повторяет список определенное количество раз. Я также добавил скобки, чтобы разрешить ввод, который явно говорит о том, как его следует анализировать.</p>
<div class="fragment"><div class="line">(use</div><div class="line">  &#39;((NP -&gt; (NP CONJ NP) infix-funcall  infix-scorer)</div><div class="line">    (NP -&gt; (N P N)      infix-funcall  infix-scorer)</div><div class="line">    (NP -&gt; (N)          list)</div><div class="line">    (NP -&gt; ([ NP ])     arg2)</div><div class="line">    (NP -&gt; (NP ADJ)     rev-funcall    rev-scorer)</div><div class="line">    (NP -&gt; (NP OP N)    infix-funcall)</div><div class="line">    (N  -&gt; (D)          identity)</div><div class="line">    (N  -&gt; (N D)        10*N+D)</div><div class="line">    (P  -&gt; to           integers       prefer&lt;)</div><div class="line">    ([  -&gt; [            [)</div><div class="line">    (]  -&gt; ]            ])</div><div class="line">    (OP -&gt; repeat       repeat)</div><div class="line">    (CONJ -&gt; and        append         prefer-disjoint)</div><div class="line">    (CONJ -&gt; without    ordered-set-difference prefer-subset)</div><div class="line">    (ADJ -&gt; reversed    reverse        inv-span)</div><div class="line">    (ADJ -&gt; shuffled    permute        prefer-not-singleton)</div><div class="line">    (D -&gt; 1 1) (D -&gt; 2 2) (D -&gt; 3 3) (D -&gt; 4 4) (D -&gt; 5 5)</div><div class="line">    (D -&gt; 6 6) (D -&gt; 7 7) (D -&gt; 8 8) (D -&gt; 9 9) (D -&gt; 0 0)))</div></div><!-- fragment --><p>Следующие функции оценки принимают деревья в качестве входных данных и вычисляют бонусы или штрафы для этих деревьев. Функция подсчета баллов <code>prefer&lt;</code>, используемая для слова "to"(к), дает штраф в один балл за обратные диапазоны: "5 to 1" получает оценку -1, в то время как "1 to 5" получает оценку 0. scorer(функция подсчета баллов) для "and", <code>prefer-disjoint</code>, дает штраф в один балл для пересечения списков: "1 to 3 and 7 to 9" получает оценку 0(нет пересечения), а "1 to 4 and 2 to 5" получает - 1. Функция подсчета баллов "x without y"(x без y), <code>prefer-subset</code>, дает трехочковый штраф, если в списке y есть элементы, которых нет в списке x. Она также присуждает очки обратно пропорционально длине (в словах) фразе x. Идея в том, что мы должны предпочесть жестко привязать "without" к какому-нибудь небольшому выражению слева. Если окончательные оценочные баллы оказываются положительными или нецелыми, то ответственным является этот компонент подсчета, поскольку все другие компоненты являются отрицательными целыми числами. Функция подсчета баллов "x shuffled", <code>prefer-not-singleton</code>, аналогична, за исключением того, что здесь штрафом является перетасовка списка из менее чем двух песен.</p>
<div class="fragment"><div class="line">(defun prefer&lt; (x y) (if (&gt;= (sem x) (sem y)) -1))</div><div class="line">(defun prefer-disjoint (x y) (if (intersection (sem x) (sem y)) -1))</div><div class="line">(defun prefer-subset (x y)</div><div class="line">  (+ (inv-span x) (if (subsetp (sem y) (sem x)) 0 -3)))</div><div class="line">(defun prefer-not-singleton (x)</div><div class="line">  (+ (inv-span x) (if (&lt; (length (sem x)) 2) -4 0)))</div></div><!-- fragment --><p>Функции i<code>infix-scorer</code> и <code>rev-scorer</code> не добавляют ничего нового, они просто гарантируют, что ранее упомянутые функции подсчета баллов будут применены в нужном месте.</p>
<div class="fragment"><div class="line">(defun infix-scorer (arg1 scorer arg2)</div><div class="line">  (funcall (tree-score scorer) arg1 arg2))</div><div class="line"></div><div class="line">(defun rev-scorer (arg scorer) (funcall (tree-score scorer) arg))</div></div><!-- fragment --><p>Вот функции, упомянутые в грамматике, а также некоторые полезные утилиты:</p>
<div class="fragment"><div class="line">(defun arg2 (a1 a2 &amp;rest a-n) (declare (ignore a1 a-n)) a2)</div><div class="line"></div><div class="line">(defun rev-funcall (arg function) (funcall function arg))</div><div class="line"></div><div class="line">(defun repeat (list n)</div><div class="line">  &quot;Append list n times.&quot;</div><div class="line">  (if (= n 0)</div><div class="line">      nil</div><div class="line">      (append list (repeat list (- n 1)))))</div><div class="line"></div><div class="line">(defun span-length (tree)</div><div class="line">  &quot;How many words are in tree?&quot;</div><div class="line">  (if (terminal-tree-p tree) 1</div><div class="line">      (sum (tree-rhs tree) #&#39;span-length)))</div><div class="line"></div><div class="line">(defun inv-span (tree) (/ 1 (span-length tree)))</div><div class="line"></div><div class="line">(defun sem (tree) (tree-sem tree))</div><div class="line"></div><div class="line">(defun integers (start end)</div><div class="line">  &quot;A list of all the integers in the range [start...end] inclusive.</div><div class="line">  This version allows start &gt; end.&quot;</div><div class="line">  (cond ((&lt; start end) (cons start (integers (+ start 1) end)))</div><div class="line">        ((&gt; start end) (cons start (integers (- start 1) end)))</div><div class="line">        (t (list start))))</div><div class="line"></div><div class="line">(defun sum (numbers &amp;optional fn)</div><div class="line">  &quot;Sum the numbers, or sum (mapcar fn numbers).&quot;</div><div class="line">  (if fn</div><div class="line">      (loop for x in numbers sum (funcall fn x))</div><div class="line">      (loop for x in numbers sum x)))</div><div class="line"></div><div class="line">(defun permute (bag)</div><div class="line">  &quot;Return a random permutation of the given input list.&quot;</div><div class="line">  (if (null bag)</div><div class="line">      nil</div><div class="line">      (let ((e (random-elt bag)))</div><div class="line">        (cons e (permute (remove e bag :count 1 :test #&#39;eq))))))</div></div><!-- fragment --><p>Нам понадобится способ показать рейтинг предпочтений:</p>
<div class="fragment"><div class="line">(defun all-parses (words)</div><div class="line">  (format t &quot;~%Score  Semantics~25T~a&quot; words)</div><div class="line">  (format t &quot;~%=====  =========~25T============================~%&quot;)</div><div class="line">  (loop for tree in (sort (parser words) #&#39;&gt; :key #&#39;tree-score)</div><div class="line">    do (format t &quot;~5,1f  ~9a~25T~a~%&quot; (tree-score tree) (tree-sem tree)</div><div class="line">               (bracketing tree)))</div><div class="line">  (values))</div><div class="line"></div><div class="line">(defun bracketing (tree)</div><div class="line">  &quot;Extract the terminals, bracketed with parens.&quot;</div><div class="line">  (cond ((atom tree) tree)</div><div class="line">        ((length=1 (tree-rhs tree))</div><div class="line">         (bracketing (first (tree-rhs tree))))</div><div class="line">        (t (mapcar #&#39;bracketing (tree-rhs tree)))))</div></div><!-- fragment --><p>Теперь мы можем попробовать несколько примеров:</p>
<div class="fragment"><div class="line">&gt; (all-parses &#39;(1 to 6 without 3 and 4))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>Score</code> </td><td><code>Semantics</code> </td><td><code>(1 TO 6 WITHOUT 3 AND 4)</code> </td></tr>
<tr>
<td><code>=======</code> </td><td><code>===========</code> </td><td><code>========================</code> </td></tr>
<tr>
<td><code>0.3</code> </td><td><code>(12 5 6)</code> </td><td><code>((1 TO 6) WITHOUT (3 AND 4))</code> </td></tr>
<tr>
<td><code>-0.7</code> </td><td><code>(12 4 5 6 4)</code> </td><td><code>(((1 TO 6) WITHOUT 3) AND 4)</code> </td></tr>
</table>
<div class="fragment"><div class="line">&gt; (all-parses &#39;(1 and 3 to 7 and 9 without 5 and 6))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>Score</code> </td><td><code>Semantics</code> </td><td><code>(1 AND 3 T0 7 AND 9 WITHOUT 5 AND 6)</code> </td></tr>
<tr>
<td><code>=======</code> </td><td><code>===========</code> </td><td><code>=================================</code> </td></tr>
<tr>
<td><code>0.2</code> </td><td><code>(1 3 4 7 9)</code> </td><td><code>(1 AND (((3 T0 7) AND 9) WITHOUT (5 AND 6)))</code> </td></tr>
<tr>
<td><code>0.1</code> </td><td><code>(1 3 4 7 9)</code> </td><td><code>(((1 AND (3 T0 7)) AND 9) WITHOUT (5 AND 6))</code> </td></tr>
<tr>
<td><code>0.1</code> </td><td><code>(1 3 4 7 9)</code> </td><td><code>((1 AND ((3 T0 7) AND 9)) WITHOUT (5 AND 6))</code> </td></tr>
<tr>
<td><code>-0.8</code> </td><td><code>(1 3 4 6 7 9 6)</code> </td><td><code>((1 AND (((3 T0 7) AND 9) WITHOUT 5)) AND 6)</code> </td></tr>
<tr>
<td><code>-0.8</code> </td><td><code>(1 3 4 6 7 9 6)</code> </td><td><code>(1 AND ((((3 T0 7) AND 9) WITHOUT 5) AND 6))</code> </td></tr>
<tr>
<td><code>-0.9</code> </td><td><code>(1 3 4 6 7 9 6)</code> </td><td><code>((((1 AND (3 T0 7)) AND 9) WITHOUT 5) AND 6)</code> </td></tr>
<tr>
<td><code>-0.9</code> </td><td><code>(1 3 4 6 7 9 6)</code> </td><td><code>(((1 AND ((3 T0 7) AND 9)) WITHOUT 5) AND 6)</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9)</code> </td><td><code>((1 AND (3 TO 7)) AND (9 WITHOUT (5 AND 6)))</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9)</code> </td><td><code>(1 AND ((3 TO 7) AND (9 WITHOUT (5 AND 6))))</code> </td></tr>
<tr>
<td><code>-3.0</code> </td><td><code>(1 3 4 5 6 7 9 6)</code> </td><td><code>(((1 AND (3 TO 7)) AND (9 WITHOUT 5)) AND 6)</code> </td></tr>
<tr>
<td><code>-3.0</code> </td><td><code>(1 3 4 5 6 7 9 6)</code> </td><td><code>((1 AND (3 TO 7)) AND ((9 WITHOUT 5) AND 6))</code> </td></tr>
<tr>
<td><code>-3.0</code> </td><td><code>(1 3 4 5 6 7 9 6)</code> </td><td><code>((1 AND ((3 TO 7) AND (9 WITHOUT 5))) AND 6)</code> </td></tr>
<tr>
<td><code>-3.0</code> </td><td><code>(1 3 4 5 6 7 9 6)</code> </td><td><code>(1 AND (((3 T0 7) AND (9 WITHOUT 5)) AND 6))</code> </td></tr>
<tr>
<td><code>-3.0</code> </td><td><code>(1 3 4 5 6 7 9 6)</code> </td><td><code>(1 AND ((3 T0 7) AND ((9 WITHOUT 5) AND 6)))</code> </td></tr>
</table>
<div class="fragment"><div class="line">&gt; (all -parses &#39;(1 and 3 to 7 and 9 without 5 and 2))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>Score</code> </td><td><code>Semantics</code> </td><td><code>(1 AND 3 T0 7 AND 9 WITHOUT 5 AND 2)</code> </td></tr>
<tr>
<td><code>======</code> </td><td><code>================</code> </td><td><code>===================================</code> </td></tr>
<tr>
<td><code>0.2</code> </td><td><code>(1 3 4 6 7 9 2)</code> </td><td><code>((1 AND (((3 T0 7) AND 9) WITHOUT 5)) AND 2)</code> </td></tr>
<tr>
<td><code>0.2</code> </td><td><code>(1 3 4 6 7 9 2)</code> </td><td><code>(1 AND ((((3 T0 7) AND 9) WITHOUT 5) AND 2))</code> </td></tr>
<tr>
<td><code>0.1</code> </td><td><code>(1 3 4 6 7 9 2)</code> </td><td><code>((((1 AND (3 T0 7)) AND 9) WITHOUT 5) AND 2)</code> </td></tr>
<tr>
<td><code>0.1</code> </td><td><code>(1 3 4 6 7 9 2)</code> </td><td><code>(((1 AND ((3 T0 7) AND 9)) WITHOUT 5) AND 2)</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9 2)</code> </td><td><code>(((1 AND (3 T0 7)) AND (9 WITHOUT 5)) AND 2)</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9 2)</code> </td><td><code>((1 AND (3 T0 7)) AND ((9 WITHOUT 5) AND 2))</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9)</code> </td><td><code>((1 AND (3 T0 7)) AND (9 WITHOUT (5 AND 2)))</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9 2)</code> </td><td><code>((1 AND ((3 T0 7) AND (9 WITHOUT 5))) AND 2)</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9 2)</code> </td><td><code>(1 AND (((3 T0 7) AND (9 WITHOUT 5)) AND 2))</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9 2)</code> </td><td><code>(1 AND ((3 T0 7) AND ((9 WITHOUT 5) AND 2)))</code> </td></tr>
<tr>
<td><code>-2.0</code> </td><td><code>(1 3 4 5 6 7 9)</code> </td><td><code>(1 AND ((3 T0 7) AND (9 WITHOUT (5 AND 2))))</code> </td></tr>
<tr>
<td><code>-2.8</code> </td><td><code>(1 3 4 6 7 9)</code> </td><td><code>(1 AND (((3 T0 7) AND 9) WITHOUT (5 AND 2)))</code> </td></tr>
<tr>
<td><code>-2.9</code> </td><td><code>(1 3 4 6 7 9)</code> </td><td><code>(((1 AND (3 T0 7)) AND 9) WITHOUT (5 AND 2))</code> </td></tr>
<tr>
<td><code>-2.9</code> </td><td><code>(1 3 4 6 7 9)</code> </td><td><code>((1 AND ((3 T0 7) AND 9)) WITHOUT (5 AND 2))</code> </td></tr>
</table>
<p>В каждом случае правила предпочтений могут присваивать более высокие баллы более разумным интерпретациям. Оказывается, в каждом случае все интерпретации с положительными оценками представляют собой один и тот же набор чисел, тогда как интерпретации с отрицательными оценками кажутся хуже. Просмотр всех оценок в мрачных деталях может представлять академический интерес, но на самом деле нам нужно что-то, чтобы выбрать лучшую интерпретацию. Следующий код подходит для многих ситуаций. Он выбирает лучшую функцию подсчета баллов(scorer), если есть уникальный, или запрашивает пользователя, совпадают ли несколько интерпретаций для лучшего результата, и жалуется, если вообще нет действительных синтаксических анализов. Функция query-user может быть полезна во многих приложениях, но обратите внимание, что meaning использует ее только по умолчанию; программа, у которой был некоторый автоматический способ принятия решений, могла бы предоставить еще одну функцию <code>tie-breaker</code>.</p>
<div class="fragment"><div class="line">(defun meaning (words &amp;optional (tie-breaker #&#39;query-user))</div><div class="line">  &quot;Choose the single top-ranking meaning for the words.&quot;</div><div class="line">  (let* ((trees (sort (parser words) #&#39;&gt; :key #&#39;tree-score))</div><div class="line">         (best-score (if trees (tree-score (first trees)) 0))</div><div class="line">         (best-trees (delete best-score trees</div><div class="line">                             :key #&#39;tree-score :test-not #&#39;eql))</div><div class="line">         (best-sems (delete-duplicates (mapcar #&#39;tree-sem best-trees)</div><div class="line">                                       :test #&#39;equal)))</div><div class="line">    (case (length best-sems)</div><div class="line">      (0 (format t &quot;~&amp;Sorry, I didn&#39;t understand that.&quot;) nil)</div><div class="line">      (1 (first best-sems))</div><div class="line">      (t (funcall tie-breaker best-sems)))))</div><div class="line"></div><div class="line">(defun query-user (choices &amp;optional</div><div class="line">                           (header-str &quot;~&amp;Please pick one:&quot;)</div><div class="line">                           (footer-str &quot;~&amp;Your choice? &quot;))</div><div class="line">  &quot;Ask user to make a choice.&quot;</div><div class="line">  (format *query-io* header-str)</div><div class="line">  (loop for choice in choices for i from 1 do</div><div class="line">        (format *query-io* &quot;~&amp;~3d: ~a&quot; i choice))</div><div class="line">  (format *query-io* footer-str)</div><div class="line">  (nth (- (read) 1) choices))</div></div><!-- fragment --><p>Здесь мы видим несколько заключительных примеров:</p>
<div class="fragment"><div class="line">&gt; (meaning &#39;(1 to 5 without 3 and 4))</div><div class="line">(1 2 5)</div><div class="line">&gt; (meaning &#39;(1 to 5 without 3 and 6))</div><div class="line">(1 2 4 5 6)</div><div class="line">&gt; (meaning &#39;(1 to 5 without 3 and 6 shuffled))</div><div class="line">(6 4 1 2 5)</div><div class="line">&gt; (meaning &#39;([ 1 to 5 without [ 3 and 6 ] ] reversed))</div><div class="line">(5 4 2 1)</div><div class="line">&gt; (meaning &#39;(1 to 5 to 9))</div></div><!-- fragment --><p><code>Sorry. I didn't understand that.</code></p>
<div class="fragment"><div class="line">NIL</div><div class="line">&gt; (meaning &#39;(1 to 5 without 3 and 7 repeat 2))</div><div class="line">Please pick one:</div><div class="line">      1: (12 4 5 7 12 4 5 7)</div><div class="line">      2: (12 4 5 7 7)</div></div><!-- fragment --><p><code>Your choice? 1</code></p>
<div class="fragment"><div class="line">(1 2 4 5 7 1 2 4 5 7)</div></div><!-- fragment --><div class="fragment"><div class="line">&gt; (all-parses &#39;(1 to 5 without 3 and 7 repeat 2))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>Score</code> </td><td><code>Semantics</code> </td><td><code>(1 TO 5 WITHOUT 3 AND 7 REPEAT 2)</code> </td></tr>
<tr>
<td><code>==========</code> </td><td><code>=========</code> </td><td><code>===========================</code> </td></tr>
<tr>
<td><code>0.3</code> </td><td><code>(1 2 4 5 7 1 2 4 5 7)</code> </td><td><code>((((1 TO 5) WITHOUT 3) AND 7) REPEAT 2)</code> </td></tr>
<tr>
<td><code>0.3</code> </td><td><code>(1 2 4 5 7 7)</code> </td><td><code>(((1 TO 5) WITHOUT 3) AND (7 REPEAT 2))</code> </td></tr>
<tr>
<td><code>-2.7</code> </td><td><code>(1 2 4 5 1 2 4 5)</code> </td><td><code>(((1 TO 5) WITHOUT (3 AND 7)) REPEAT 2)</code> </td></tr>
<tr>
<td><code>-2.7</code> </td><td><code>(1 2 4 5)</code> </td><td><code>((1 TO 5) WITHOUT ((3 AND 7) REPEAT 2))</code> </td></tr>
<tr>
<td><code>-2.7</code> </td><td><code>(1 2 4 5)</code> </td><td><code>((1 TO 5) WITHOUT (3 AND (7 REPEAT 2)))</code> </td></tr>
</table>
<p>Этот последний пример указывает на потенциальную проблему: я не был уверен, какая функция оценки для "repeat" была хорошей, поэтому я оставил ее пустым, по умолчанию она была равна 0, и в итоге мы получили два анализа с одинаковыми баллами. Этот пример предполагает, что "repeat", вероятно, должен включать в себя <code>inv-span</code>, как и другие модификаторы, но, возможно, должны быть задействованы и другие факторы. Между фразами может быть сложное взаимодействие, и не всегда ясно, где выставить оценку. Например, нет смысла повторять фразу "without"(без); то есть фраза <code>(x without (y repeat n))</code>, вероятно, плохая. Но scorer для "without" уже почти справляется с этим. Он назначает штраф, если его правый аргумент не является подмножеством его левого аргумента. К сожалению, повторяющиеся элементы не учитываются в множествах, поэтому, например, список (1 2 3 1 2 3) является подмножеством (1 2 3 4). Тем не менее, мы могли бы изменить scorer для "without", чтобы вместо этого проверять <code>sub-bag-p</code> (не встроенную функцию Common Lisp), и тогда "repeat" не должен был бы иметь дело с этим случаем.</p>
<h2>19.7 Проблема с правилами структуры фраз без контекста</h2>
<p>Фрагмент грамматики английского языка, который мы указали в <a href="#s0015">раздел 19.2</a>, допускает множество неграмматических фраз. Например, он одинаково доволен как "I liked her"(она мне понравилась), так и "me liked she.". Следует принять только первое из них; второй следует исключить. Точно так же наша грамматика не утверждает, что глаголы должны согласовываться со своим подлежащим лично и численно. И поскольку грамматика не имеет понятия значения, она будет принимать предложения, которые семантически аномальны (или, по крайней мере, необычны), например, "the table liked the man."(столу понравился человек).</p>
<p>Есть также некоторые технические проблемы с контекстно-свободной грамматикой. Например, можно показать, что никакая контекстно-свободная грамматика не может быть написана для учета языка, состоящего только из строк ABC, AABBCC, AAABBBCCC и т. Д., Где каждая строка имеет равное количество As, Bs и Cs. . Тем не менее, предложения примерно такой формы появляются (правда, редко) на естественных языках. Пример: "Robin and Sandy loved and hated Pat and Kim, respectively."(Робин и Сэнди любили и ненавидели Пэт и Ким соответственно). Хотя все еще существуют разногласия по поводу возможности создания естественных языков с помощью контекстно-свободной грамматики, очевидно, что гораздо проще использовать более мощный грамматический формализм. Например, рассмотрите решение проблемы согласования субъект-предикат. Это возможно сделать с помощью контекстно-свободного языка, включая такие категории, как singular-NP, plural-NP, singular-VP, и plural-VPP, но гораздо проще расширить грамматический формализм, чтобы разрешить передачу функций между составляющими.</p>
<p>Следует отметить, что контекстно-свободные правила структуры фраз оказались очень полезными для описания языков программирования. Начиная с Algol 60, этот формализм использовался компьютерными учеными под названием <em>Backus-NaurForm</em> (BNF). В этой книге нас больше интересуют естественные языки, поэтому в следующей главе мы увидим более мощный формализм, известный как <em>unification grammar</em>(объединяющая грамматика), который может решить проблему согласования, а также другие трудности. Более того, <em>Объединенные/унифицированные грамматики</em> позволяют естественным образом присоединять семантику к синтаксическому анализу.</p>
<h2>19.8 История и ссылки</h2>
<p>There is a class of parsing algorithms known as <em>chart parsers</em> that explicitly cache partial parses and reuse them in constructing larger parses. Earley's algorithm (1970) is the first example, and Martin <a href="B9780080571157500285.xhtml#bb0605">Kay (1980)</a> gives a good overview of the field and introduces a data structure, the <em>chart</em>, for storing substrings of a parse. <a href="B9780080571157500285.xhtml#bb1395">Winograd (1983)</a> gives a complex (five-page) specification of a chart parser. None of these authors have noticed that one can achieve the same results by augmenting a simple (one-page) parser with memoization. In fact, it is possible to write a top-down parser that is even more succinct. (See <a href="#p2455">exercise 19.3</a> below.)</p>
<p>For a general overview of natural language processing, my preferences (in order) are <a href="B9780080571157500285.xhtml#bb0030">Allen 1987</a>, <a href="B9780080571157500285.xhtml#bb1395">Winograd 1983</a> or <a href="B9780080571157500285.xhtml#bb0445">Gazdar and Mellish 1989</a>.</p>
<h2>19.9 Упражнения</h2>
<p><b>Exercise 19.2 [m-h]</b> Experiment with the grammar and the parser. Find sentences it cannot parse correctly, and try to add new syntactic rules to account for them.</p>
<p><b>Exercise 19.3 [m-h]</b> The parser works in a bottom-up fashion. Write a top-down parser, and compare it to the bottom-up version. Can both parsers work with the same grammar? If not, what constraints on the grammar does each parsing strategy impose?</p>
<p><b>Exercise 19.4 [h]</b> Imagine an interface to a dual cassette deck. Whereas the CD player had one assumed verb, "play," this unit has three explicit verb forms: "record," "play," and "erase." There should also be modifiers "from" and "to," where the object of a "to" is either 1 or 2, indicating which cassette to use, and the object of a "from" is either 1 or 2, or one of the symbols PHONO, CD, or AUX. It's up to you to design the grammar, but you should allow input something like the following, where I have chosen to generate actual Lisp code as the meaning:</p>
<div class="fragment"><div class="line">&gt; (meaning &#39;(play 1 to 5 from CD shuffled and</div><div class="line">                          record 1 to 5 from CD and 1 and 3 and 7 from 1))</div><div class="line">(PROGN (PLAY &#39;(15 2 3 4) :FROM &#39;CD)</div><div class="line">              (RECORD &#39;(12345) :FROM &#39;CD)</div><div class="line">              (RECORD &#39;(1 3 7) :FROM &#39;1))</div></div><!-- fragment --><p>This assumes that the functions play and record take keyword arguments (with defaults) for : <code>from</code> and : <code>to</code>. You could also extend the grammar to accommodate an automatic timer, with phrases like "at 3:00."</p>
<p><b>Exercise 19.5 [m]</b> In the definition of <code>permute</code>, repeated here, why is the :`test # ' eq needed?`</p>
<div class="fragment"><div class="line">(defun permute (bag)</div><div class="line">      &quot;Return a random permutation of the given input list.&quot;</div><div class="line">      (if (null bag)</div><div class="line">              nil</div><div class="line">              (let ((e (random-elt bag)))</div><div class="line">                  (cons e (permute (remove e bag :count 1 :test #&#39;eq))))))</div></div><!-- fragment --><p><b>Exercise 19.6 [m]</b> The definition of <code>permute</code> takes <em>O</em>(<em>n*2). Replace it by an *O</em>(<em>n</em>) algorithm.</p>
<h2>19.10 Ответы</h2>
<p><b>Answer 19.1</b></p>
<div class="fragment"><div class="line">(defun parser (words)</div><div class="line">      &quot;Return all complete parses of a list of words.&quot;</div><div class="line">      (let* ((table (make-array (+ (length words) 1) :initial-element 0))</div><div class="line">                        (parses (parse words (length words) table)))</div><div class="line">          (mapcar #&#39;parse-tree (complete-parses parses))))</div><div class="line">(defun parse (words num-words table)</div></div><!-- fragment --><p><code>"Bottom-up parse.
returning all parses of any prefix of words."</code></p>
<div class="fragment"><div class="line">      (unless (null words)</div><div class="line">          (let ((ans (aref table num-words)))</div><div class="line">              (if (not (eq ans 0))</div><div class="line">                      ans</div><div class="line">                      (setf (aref table num-words)</div><div class="line">                                    (mapcan #&#39;(lambda (rule)</div><div class="line">                                                            (extend-parse (rule-lhs rule)</div><div class="line">                                                                                        (list (firstwords))</div><div class="line">                                                                                        (rest words) nil</div><div class="line">                                                                                        (- num-words 1) table))</div><div class="line">                                                        (lexical-rules (first words))))))))</div><div class="line">(defun extend-parse (lhs rhs rem needed num-words table)</div><div class="line">      &quot;Look for the categories needed to complete the parse.&quot;</div><div class="line">      (if (null needed)</div><div class="line">            ;; If nothing is needed, return this parse and upward extensions</div><div class="line">            (let ((parse (make-parse :tree (new-tree lhs rhs) :rem rem)))</div><div class="line">                (cons parse</div><div class="line">                            (mapcan</div><div class="line">                          #&#39;(lambda (rule)</div><div class="line">                                          (extend-parse (rule-lhs rule)</div><div class="line">                                                                      (list (parse-tree parse))</div><div class="line">                                                                        rem (rest (rule-rhs rule))</div><div class="line">                                                                        num-words table))</div><div class="line">                                  (rules-starting-with lhs))))</div><div class="line">              ;; otherwise try to extend rightward</div><div class="line">              (mapcan</div><div class="line">                  #&#39;(lambda (p)</div><div class="line">                          (if (eq (parse-lhs p) (first needed))</div><div class="line">                                    (extend-parse lhs (appendl rhs (parse-tree p))</div><div class="line">                                                                (parse-rem p) (rest needed)</div><div class="line">                                                                (length (parse-rem p)) table)))</div><div class="line">                  (parse rem num-words table))))</div></div><!-- fragment --><p>It turns out that, for the Lisp system used in the timings above, this version is no faster than normal memoization.</p>
<p><b>Answer 19.3</b> Actually, the top-down parser is a little easier (shorter) than the bottom-up version. The problem is that the most straightforward way of implementing a top-down parser does not handle so-called <em>left recursive</em> rules-rules of the form <code>(X -&gt; (X ...))</code>. This includes rules we've used, like <code>(NP -&gt; (NP and NP))</code>. The problem is that the parser will postulate an NP, and then postulate that it is of the form <code>(NP and NP)</code>, and that the first NPof that expression is ofthe form <code>(NP and NP)</code>, and so on. An infinite structure of NPs is explored before even the first word is considered.</p>
<p>Bottom-up parsers are stymied by rules with null right-hand sides: <code>(X -&gt; O)</code>. Note that I was careful to exclude such rules in my grammars earlier.</p>
<div class="fragment"><div class="line">(defun parser (words &amp;optional (cat &#39;s))</div><div class="line">      &quot;Parse a list of words; return only parses with no remainder.&quot;</div><div class="line">      (mapcar #&#39;parse-tree (compiete-parses (parse words cat))))</div><div class="line">(defun parse (tokens start-symbol)</div><div class="line">      &quot;Parse a list of tokens, return parse trees and remainders.&quot;</div><div class="line">      (if (eq (first tokens) start-symbol)</div><div class="line">              (list (make-parse :tree (first tokens) :rem (rest tokens)))</div><div class="line">              (mapcan #&#39;(lambda (rule)</div><div class="line">                                      (extend-parse (lhs rule) nil tokens (rhs rule)))</div><div class="line">                                  (rules-for start-symbol))))</div><div class="line">(defun extend-parse (lhs rhs rem needed)</div><div class="line">      &quot;Parse the remaining needed symbols.&quot;</div><div class="line">      (if (null needed)</div><div class="line">              (list (make-parse :tree (cons lhs rhs) :rem rem))</div><div class="line">              (mapcan</div><div class="line">                  #&#39;(lambda (p)</div><div class="line">                            (extend-parse lhs (append rhs (list (parse-tree p)))</div><div class="line">                                                            (parse-rem p) (rest needed)))</div><div class="line">                  (parse rem (first needed)))))</div><div class="line">(defun rules-for (cat)</div><div class="line">      &quot;Return all the rules with category on lhs&quot;</div><div class="line">      (find-all cat *grammar* :key #&#39;rule-lhs))</div></div><!-- fragment --><p><b>Answer 19.5</b> If it were omitted, then : test would default <code>to #'eql</code>, and it would be possible to remove the "wrong" element from the list. Consider the list (1.0 1.0) in an implementation where floating-point numbers are <code>eql</code> but not <code>eq</code>. if <code>random-elt</code> chooses the first 1.0 first, then everything is satisfactory-the resuit list is the same as the input list. However, if <code>random-elt</code> chooses the second 1.0, then the second 1.0 will be the first element of the answer, but <code>remove</code> will remove the wrong 1.0! It will remove the first 1.0, and the final answer will be a list with two pointers to the second 1.0 and none to the first. In other words, we could have:</p>
<div class="fragment"><div class="line">&gt; (member (first x) (permute x) :test #&#39;eq)</div><div class="line">NIL</div></div><!-- fragment --><p><b>Answer 19.6</b></p>
<div class="fragment"><div class="line">(defun permute (bag)</div><div class="line">      &quot;Return a random permutation of the bag.&quot;</div><div class="line">      ;; It is done by converting the bag to a vector, but the</div><div class="line">      ;; resuit is always the same type as the input bag.</div><div class="line">      (let ((bag-copy (replace (make-array (length bag)) bag))</div><div class="line">                  (bag-type (if (listp bag) &#39;list (type-of bag))))</div></div><!-- fragment --><p><code>(coerce (permute-vector! bag-copy) bag-type)))</code></p>
<p><code>(defun permute-vector! (vector)</code></p>
<div class="fragment"><div class="line">      &quot;Destructively permute (shuffle) the vector.&quot;</div><div class="line">      (loop for i from (length vector) downto 2 do</div><div class="line">                  (rotatef (aref vector (- i 1))</div><div class="line">                                    (aref vector (random i))))</div><div class="line">vector)</div></div><!-- fragment --><p>The answer uses <code>rotatef</code>, a relative of <code>setf</code> that swaps 2 or more values. That is, <code>(rotatef a b)</code> is like:</p>
<div class="fragment"><div class="line">(let ((temp a))</div><div class="line">      (setf a b)</div><div class="line">      (setf b temp)</div><div class="line">      nil)</div></div><!-- fragment --><p>Rarely, <code>rotatef</code> is used with more than two arguments, <code>(rotatef a b c)</code> is like:</p>
<div class="fragment"><div class="line">(let ((temp a))</div><div class="line">      (setf a b)</div><div class="line">      (setf b c)</div><div class="line">      (setf c temp)</div><div class="line">      nil)</div></div><!-- fragment --> <hr/>
<p><a href="#xfn0015">1</a> Some erroneous expressions are underspecified and may return different results in different implementations, but we will ignore that problem. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">2</a> The number of parses of sentences of this kind is the same as the number of bracketings of a arithmetic expression, or the number of binary trees with a given number of leaves. The resulting sequence (1,2,5,14,42,...) is known as the Catalan Numbers. This kind of ambiguity is discussed by <a href="B9780080571157500285.xhtml#bb0200">Church and Patil (1982)</a> in their article <em>Coping with Syntactic Ambiguity, or How to Put the Block in the Box on the Table.</em> !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
