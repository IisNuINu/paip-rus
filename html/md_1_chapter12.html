<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 12</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 12 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Компиляция Логических Программ</h2>
<p>В конце <a href="B978008057115750011X.xhtml">главы 11</a> было представлено новое, более эффективное представление для логических переменных. Было бы разумно построить новую версию интерпретатора Пролога, включающую это представление. Однако <a href="B9780080571157500091.xhtml">глава 9</a> научила нас, что компиляторы работают быстрее, чем интерпретаторы, и их не так уж сложно построить. Таким образом, в этой главе будет представлен компилятор Пролога, который преобразует Пролог в Лисп.</p>
<p>Каждый предикат Пролога будет преобразован в функцию Лиспа, и мы примем соглашение, согласно которому предикат, вызываемый с другим числом аргументов, является другим(отличающимся от предыдущего) предикатом. Если символ <code>p</code> может быть вызван с одним или двумя аргументами, нам понадобятся две функции Лиспа для реализации двух предикатов. Следуя традиции Пролога, они будут называться <code>p/1</code> и <code>p/2</code>.</p>
<p>Следующий шаг - решить, как должен выглядеть сгенерированный код Lisp. Он должен объединить/унифицировать заголовок каждого предложения напротив аргументов, и, если объединение/унификация завершится успешно, он должен вызвать предикаты в теле. Трудность состоит в том, что нужно помнить о точках выбора. Если вызов предиката в первом предложении завершился неудачно, мы должны иметь возможность вернуться ко второму предложению и повторить попытку.</p>
<p>Это можно сделать, передав <em>успешное продолжение</em> в качестве дополнительного аргумента каждому предикату. Это продолжение представляет собой цели, которые остаются нерешенными, аргумент функции <code>prove</code> <code>other-goals</code>(другие цели). Для каждого предложения в предикате, если все цели в предложении выполнены, мы должны вызвать успешное продолжение. Если цель не удается/не достигается, мы не делаем ничего особенного; мы просто переходим к следующему предложению. Есть одно осложнение: после неудачи мы должны отменить все привязки, сделанные <code>unify!</code>. Рассмотрим пример. Предложения</p>
<div class="fragment"><div class="line">(&lt;- (likes Robin cats))</div><div class="line">(&lt;- (likes Sandy ?x) (likes ?x cats))</div><div class="line">(&lt;- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))</div></div><!-- fragment --><p>можно скомпилировать в это:</p>
<div class="fragment"><div class="line">(defun likes/2 (?arg1 ?arg2 cont)</div><div class="line">  ;; First clause:</div></div><!-- fragment --><p>` (if (and (unify! ?arg1 'Robin) (unify! ?arg2 'cats))`</p>
<div class="fragment"><div class="line">    (funcall cont))</div><div class="line">(undo-bindings)</div><div class="line">;; Second clause:</div></div><!-- fragment --><p><code>(if (unify! ?argl 'Sandy)</code></p>
<div class="fragment"><div class="line">    (likes/2 ?arg2 &#39;cats cont))</div><div class="line">(undo-bindings)</div><div class="line">;; Third clause:</div></div><!-- fragment --><p><code>(if (unify! ?argl 'Kim)</code></p>
<div class="fragment"><div class="line">(likes/2 ?arg2 &#39;Lee</div><div class="line">    #&#39;(lambda () (likes/2 ?arg2 &#39;Kim cont))))))</div></div><!-- fragment --><p>В первом предложении мы просто проверяем два аргумента и, если унификации успешны, вызываем продолжение напрямую, потому что первое предложение не имеет тела. Во втором предложении рекурсивно вызывается <code>likes/2</code>, чтобы увидеть, нравятся ли <code>?arg2</code> кошки(<code>cats</code>). Если это удалось, то исходная цель достигнута, и вызывается продолжение <code>cont</code>. В третьем предложении мы должны снова рекурсивно вызвать <code>likes/2</code>, на этот раз попросив проверить, нравится ли <code>?arg2</code> <code>Lee</code>. Если эта проверка прошла успешно, будет вызвано продолжение. В этом случае продолжение включает в себя еще один вызов функции <code>likes/2</code>, чтобы проверить, нравится ли <code>?аrg2</code> <code>Ким</code>. Если это удастся, то, наконец, будет вызвано исходное продолжение, <code>cont</code>.</p>
<p>Напомним, что в интерпретаторе Пролога мы должны были добавить список ожидающих целей, <code>other-goals</code>, к целям в теле предложения. В компиляторе нет необходимости выполнять <code>append</code>. Вместо этого продолжение cont представляет <code>other-goals</code>(другие цели), а тело предложения представлено явными вызовами функций.</p>
<p>Обратите внимание, что приведенный ранее код для <code>likes/2</code> устраняет некоторые ненужные вызовы <code>unify!</code>. Самая очевидная реализация будет иметь один вызов <code>unify!</code> для каждого аргумента. Таким образом, для второго предложения у нас будет код:</p>
<p>`(if (and (unify! ?argl 'Sandy) (unify! ?arg2 ?x))`</p>
<div class="fragment"><div class="line">(likes/2 ?x &#39;cats cont))</div></div><!-- fragment --><p>где нам понадобится подходящая привязка let для переменной <code>?x</code>.</p>
<h2>12.1 Компилятор Пролога</h2>
<p>В этом разделе представлен компилятор, показанный на <a href="#f0010">рис. 12.1</a>. На верхнем уровне находится функция <code>prolog-compile</code>, которая принимает символ, просматривает предложения, определенные для этого символа, и группирует их по арности(количеству аргументов). Каждый символ/арность компилируется в отдельную функцию Лиспа с помощью <code>compile-predicate</code>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter12/f12-01.jpg" alt="f12-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 12.1: Глоссарий для компилятора Prolog </td></tr>
</table>
<p>(ed: this should be a markdown table)</p>
<div class="fragment"><div class="line">(defun prolog-compile (symbol &amp;optional</div><div class="line">                       (clauses (get-clauses symbol)))</div><div class="line">  &quot;Compile a symbol; make a separate function for each arity.&quot;</div><div class="line">  (unless (null clauses)</div><div class="line">    (let ((arity (relation-arity (clause-head (first clauses)))))</div><div class="line">      ;; Compile the clauses with this arity</div><div class="line">      (compile-predicate</div><div class="line">        symbol arity (clauses-with-arity clauses #&#39;= arity))</div><div class="line">      ;; Compile all the clauses with any other arity</div><div class="line">      (prolog-compile</div><div class="line">        symbol (clauses-with-arity clauses #&#39;/= arity)))))</div></div><!-- fragment --><p>Сюда включены три служебные функции:</p>
<div class="fragment"><div class="line">(defun clauses-with-arity (clauses test arity)</div><div class="line">  &quot;Return all clauses whose head has given arity.&quot;</div><div class="line">  (find-all arity clauses</div><div class="line">            :key #&#39;(lambda (clause)</div><div class="line">                     (relation-arity (clause-head clause)))</div><div class="line">            :test test))</div><div class="line"></div><div class="line">(defun relation-arity (relation)</div><div class="line">  &quot;The number of arguments to a relation.</div><div class="line">  Example: (relation-arity &#39;(p a b c)) =&gt; 3&quot;</div><div class="line">  (length (args relation)))</div><div class="line"></div><div class="line">(defun args (x) &quot;The arguments of a relation&quot; (rest x))</div></div><!-- fragment --><p>Следующим шагом является компиляция предложений для данного предиката с фиксированной арностью в функцию Lisp. На данный момент это будет сделано путем независимой компиляции каждого предложения и помещения их в лямбда с правильным списком параметров.</p>
<div class="fragment"><div class="line">(defun compile-predicate (symbol arity clauses)</div><div class="line">  &quot;Compile all the clauses for a given symbol/arity</div><div class="line">  into a single LISP function.&quot;</div><div class="line">  (let ((predicate (make-predicate symbol arity))</div><div class="line">        (parameters (make-parameters arity)))</div><div class="line">    (compile</div><div class="line">     (eval</div><div class="line">      `(defun ,predicate (,@parameters cont)</div><div class="line">            .,(mapcar #&#39;(lambda (clause)</div><div class="line">                        (compile-clause parameters clause &#39;cont))</div><div class="line">              clauses))))))</div><div class="line"></div><div class="line">(defun make-parameters (arity)</div><div class="line">  &quot;Return the list (?arg1 ?arg2 ... ?arg-arity)&quot;</div><div class="line">  (loop for i from 1 to arity</div><div class="line">        collect (new-symbol &#39;?arg i)))</div><div class="line"></div><div class="line">(defun make-predicate (symbol arity)</div><div class="line">  &quot;Return the symbol: symbol/arity&quot;</div><div class="line">  (symbol symbol &#39;/ arity))</div></div><!-- fragment --><p>Теперь самое сложное: мы должны фактически сгенерировать код для предложения. Вот снова пример кода, желаемого для одного предложения. Начнем с установки в качестве цели простого кода:</p>
<div class="fragment"><div class="line">(&lt;- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))</div><div class="line">(defun likes/2 (?arg1 ?arg2 cont)</div><div class="line">  ...</div></div><!-- fragment --><p>` (if (and (unify! ?argl 'Kim) (unify! ?arg2 ?x)`</p>
<div class="fragment"><div class="line">(likes/2 ?arg2 &#39;Lee</div><div class="line">      #&#39;(lambda () (likes/2 ?x &#39;Kim))))</div></div><!-- fragment --><p>...)</p>
<p>но мы также рассмотрим возможность обновления до улучшенного кода:</p>
<div class="fragment"><div class="line">(defun likes/2 (?arg1 ?arg2 cont)</div><div class="line">  ...</div></div><!-- fragment --><p><code>(if (unify! ?arg1 'Kim)</code> </p><pre class="fragment">  `(likes/2 ?arg2 'Lee`

        `#'(lambda () (likes/2 ?arg2 'Kim))))`
</pre><p>...)</p>
<p>Один из подходов - написать две функции, <code>compile-head</code> и <code>compile-body</code>, а затем объединить их в код (if <em>head body</em>) Такой подход может легко сгенерировать предыдущий код. Однако позволим себе немного забежать вперед. Если мы в конечном итоге захотим сгенерировать улучшенный код, нам понадобится некоторая связь между головой(head) и телом(body). Нам нужно знать, что голова решила не компилировать объединение/унификацию <code>?arg2</code> и <code>?x</code>, но из-за этого тело должно будет заменить <code>?arg2</code> на <code>?x</code>. Это означает, что функция <code>compile-head</code> концептуально возвращает два значения: код для головы(head) и указание замен, которые необходимо выполнить в теле(body). С этим можно справиться, явно манипулируя мноожественными значениями, но это кажется сложным.</p>
<p>Альтернативный подход - исключить <code>compile-head</code> и просто написать <code>compile-body</code>. Это возможно, если мы действительно выполним преобразование исходного кода в предложении. Вместо того, чтобы трактовать это предложение как:</p>
<div class="fragment"><div class="line">(&lt;- (likes Kim ?x)</div><div class="line">  (likes ?x Lee) (likes ?x Kim))</div></div><!-- fragment --><p>преобразуем его в эквивалент:</p>
<div class="fragment"><div class="line">(&lt;- (likes ?arg1 ?arg2)</div><div class="line">  (= ?arg1 Kim) (= ?arg2 ?x) (likes ?x Lee) (likes ?x Kim))</div></div><!-- fragment --><p>Теперь аргументы в заголовке(head) предложения соответствуют аргументам в функции <code>likes/2</code>, поэтому нет необходимости создавать какой-либо код для заголовка(head). Это упрощает задачу за счет исключения <code>compile-head</code>, и это лучшая декомпозиция по другой причине: вместо добавления оптимизаций в <code>compile-head</code> мы добавим их в код в <code>compile-body</code>, который обрабатывает знак равно =. Таким образом, мы можем оптимизировать вызовы, которые пользователь делает к =, в дополнение к вызовам, вводимым преобразованием исходного кода.</p>
<p>Для ознакомления, последовательность вызовов функций окажется следующей:</p>
<div class="fragment"><div class="line">prolog-compile</div><div class="line">  compile-predicate</div><div class="line">    compile-clause</div><div class="line">      compile-body</div><div class="line">        compile-call</div><div class="line">        compile-arg</div><div class="line">        compile-unify</div><div class="line">            compile-arg</div></div><!-- fragment --><p>где каждая функция вызывает те, что ниже, с отступом на один уровень. Мы уже определили первые две функции. Вот наша первая версия <code>compile-clause</code>:</p>
<div class="fragment"><div class="line">(defun compile-clause (parms clause cont)</div><div class="line">  &quot;Transform away the head, and compile the resulting body.&quot;</div><div class="line">  (compile-body</div><div class="line">    (nconc</div><div class="line">      (mapcar #&#39;make-= parms (args (clause-head clause)))</div><div class="line">      (clause-body clause))</div><div class="line">    cont))</div><div class="line"></div><div class="line">(defun make-= (x y) `(= ,x ,y))</div></div><!-- fragment --><p>Основная часть работы выполняется в <code>compile-body</code>, который немного сложнее. Есть три случая. Если тела нет, мы просто вызываем продолжение. Если тело начинается с вызова =, мы компилируем вызов <code>unify!</code>. В противном случае мы компилируем вызов функции, передавая соответствующее продолжение.</p>
<p>Однако на этом этапе стоит подумать о будущем. Если мы хотим трактовать сейчас = специально, мы, вероятно, захотим позже обработать другие цели специально. Поэтому вместо явной проверки для = мы будем выполнять управляемую данными диспетчеризацию, ища любой предикат, к которому привязано свойство <code>prolog-compiler-macro</code>. Как и макросы компилятора Лиспа, макрос может не справиться с поставленной задачей. Мы примем соглашение, согласно которому возврат <code>:pass</code> означает, что макрос решил не обрабатывать это и следовательно, он должен быть скомпилирован как обычная цель.</p>
<div class="fragment"><div class="line">(defun compile-body (body cont)</div><div class="line">  &quot;Compile the body of a clause.&quot;</div><div class="line">  (if (null body)</div><div class="line">      `(funcall ,cont)</div><div class="line">      (let* ((goal (first body))</div><div class="line">             (macro (prolog-compiler-macro (predicate goal)))</div><div class="line">             (macro-val (if macro</div><div class="line">                            (funcall macro goal (rest body) cont))))</div><div class="line">        (if (and macro (not (eq macro-val :pass)))</div><div class="line">            macro-val</div><div class="line">            (compile-call</div><div class="line">               (make-predicate (predicate goal)</div><div class="line">                               (relation-arity goal))</div><div class="line">               (mapcar #&#39;(lambda (arg) (compile-arg arg))</div><div class="line">                       (args goal))</div><div class="line">               (if (null (rest body))</div><div class="line">                   cont</div><div class="line">                   `#&#39;(lambda ()</div><div class="line">                      ,(compile-body (rest body) cont))))))))</div><div class="line"></div><div class="line">(defun compile-call (predicate args cont)</div><div class="line">  &quot;Compile a call to a prolog predicate.&quot;</div><div class="line">  `(,predicate ,@args ,cont))</div><div class="line"></div><div class="line">(defun prolog-compiler-macro (name)</div><div class="line">  &quot;Fetch the compiler macro for a Prolog predicate.&quot;</div><div class="line">  ;; Note NAME is the raw name, not the name/arity</div><div class="line">  (get name &#39;prolog-compiler-macro))</div><div class="line"></div><div class="line">(defmacro def-prolog-compiler-macro (name arglist &amp;body body)</div><div class="line">  &quot;Define a compiler macro for Prolog.&quot;</div><div class="line">  `(setf (get &#39;,name &#39;prolog-compiler-macro)</div><div class="line">         #&#39;(lambda ,arglist .,body)))</div><div class="line"></div><div class="line">(def-prolog-compiler-macro = (goal body cont)</div><div class="line">  (let ((args (args goal)))</div><div class="line">    (if (/= (length args) 2)</div><div class="line">        :pass</div><div class="line">        `(if ,(compile-unify (first args) (second args))</div><div class="line">             ,(compile-body body cont)))))</div><div class="line"></div><div class="line">(defun compile-unify (x y)</div><div class="line">  &quot;Return code that tests if var and term unify.&quot;</div><div class="line">  `(unify! ,(compile-arg x) ,(compile-arg y)))</div></div><!-- fragment --><p>Все, что остается, это <code>compile-arg</code>, функция для компиляции аргументов в цели для тела предложения. Следует рассмотреть три случая, как показано ниже при компиляции аргумента <code>q</code>:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>1 (&lt;- (p ?x) (q ?x))</code> </td><td><code>(q/1 ?x cont)</code> </td></tr>
<tr>
<td><code>2 (&lt;- (p ?x) (q (f a b)))</code> </td><td>`(q/1 '(f a b) cont)<code> &lt;tr&gt;&lt;td&gt;</code>3 (&lt;- (p ?x) (q (f ?x b)))<code>&lt;td&gt;</code>(q/1 (list 'f ?x 'b) cont)` </td></tr>
</table>
<p>В случае 1 аргументом является переменная, и она компилируется как есть. В случае 2 аргумент - это постоянное выражение (без переменных), которое компилируется в цитируемое(quote) выражение. В случае 3 аргумент содержит переменную, поэтому мы должны сгенерировать код, который строит выражение. Случай 3 фактически разделен на две части в списке ниже: одна компилируется в вызов <code>list</code>, а другая - в вызов <code>cons</code>. Важно помнить, что цель <code>(q (f ?x b))</code> <em>не</em> включает вызов функции <code>f</code>. Скорее, она включает термин <code>(f ?x b)</code>, который представляет собой просто список из трех элементов.</p>
<div class="fragment"><div class="line">(defun compile-arg (arg)</div><div class="line">  &quot;Generate code for an argument to a goal in the body.&quot;</div><div class="line">  (cond ((variable-p arg) arg)</div><div class="line">        ((not (has-variable-p arg)) `&#39;,arg)</div><div class="line">        ((proper-listp arg)</div><div class="line">         `(list .,(mapcar #&#39;compile-arg arg)))</div><div class="line">        (t `(cons ,(compile-arg (first arg))</div><div class="line">                  ,(compile-arg (rest arg))))))</div><div class="line"></div><div class="line">(defun has-variable-p (x)</div><div class="line">  &quot;Is there a variable anywhere in the expression x?&quot;</div><div class="line">  (find-if-anywhere #&#39;variable-p x))</div><div class="line"></div><div class="line">(defun proper-listp (x)</div><div class="line">  &quot;Is x a proper (non-dotted) list?&quot;</div><div class="line">  (or (null x)</div><div class="line">      (and (consp x) (proper-listp (rest x)))))</div></div><!-- fragment --><p>Посмотрим, как это работает. Мы рассмотрим следующие пункты:</p>
<div class="fragment"><div class="line">(&lt;- (likes Robin cats))</div><div class="line">(&lt;- (likes Sandy ?x) (likes ?x cats))</div><div class="line">(&lt;- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))</div><div class="line">(&lt;- (member ?item (?item . ?rest)))</div><div class="line">(&lt;- (member ?item (?x . ?rest)) (member ?item ?rest))</div></div><!-- fragment --><p>Вот что дает нам <code>prolog-compile</code>:</p>
<div class="fragment"><div class="line">(DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'ROBIN)</code></p>
<p><code>(IF (UNIFY! ?ARG2 'CATS)</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'SANDY)</code></p>
<p><code>(IF (UNIFY! ?ARG2 ?X)</code></p>
<div class="fragment"><div class="line">(LIKES/2 ?X &#39;CATS CONT)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'KIM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 ?X)</code></p>
<div class="fragment"><div class="line">      (LIKES/2 ?X &#39;LEE (LAMBDA ()</div><div class="line">            (LIKES/2 ?X &#39;KIM CONT))))))</div><div class="line">(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?X ?REST))</code></p>
<div class="fragment"><div class="line">(MEMBER/2 ?ITEM ?REST CONT))))</div></div><!-- fragment --><h2>12.2 Исправление ошибок в компиляторе</h2>
<p>В этой версии компилятора есть некоторые проблемы:</p>
<ul>
<li>Мы забыли отменить привязки после каждого вызова <code>unify!</code>.</li>
<li>Определение <code>undo-bindings!</code> определенное ранее требует в качестве аргумента индекса в массиве <code>*trail*</code>. Таким образом, нам нужно будет сохранять текущую вершину trail при входе в каждую функцию.</li>
<li>Локальные переменные, такие как <code>?x</code>, использовались без введения. Они должны быть привязаны к новым переменным.</li>
</ul>
<p>Отменить привязку просто: мы добавляем одну строку в <code>compile-predicate</code>, вызов функции <code>might-add-undo-bindings</code>. Эта функция вставляет вызов <code>undo-bindings!</code> после каждой неудачи(failure). Если есть только одно предложение, отмены не требуется, потому что предикат, расположенный выше в вызывающей последовательности, сделает это в случае неудачи(failure). Если есть несколько предложений, функция оборачивает все тело функции в let, которая фиксирует начальное значение указателя заполнения trail, так что привязки могут быть отменены в нужной точке. Точно так же мы можем решить проблему несвязанных переменных, заключив вызов <code>bind-unbound-vars</code> вокруг каждого скомпилированного предложения:</p>
<div class="fragment"><div class="line">(defun compile-predicate (symbol arity clauses)</div><div class="line">  &quot;Compile all the clauses for a given symbol/arity</div><div class="line">  into a single LISP function.&quot;</div><div class="line">  (let ((predicate (make-predicate symbol arity))</div><div class="line">        (parameters (make-parameters arity)))</div><div class="line">    (compile</div><div class="line">     (eval</div><div class="line">      `(defun ,predicate (,@parameters cont)</div><div class="line">  .,(maybe-add-undo-bindings                  ;***</div><div class="line">     (mapcar #&#39;(lambda (clause)</div><div class="line">           (compile-clause parameters clause &#39;cont))</div><div class="line">      clauses)))))))</div><div class="line"></div><div class="line">(defun compile-clause (parms clause cont)</div><div class="line">  &quot;Transform away the head, and compile the resulting body.&quot;</div><div class="line">  (bind-unbound-vars                                   ;***</div><div class="line">    parms                                              ;***</div><div class="line">    (compile-body</div><div class="line">      (nconc</div><div class="line">        (mapcar #&#39;make-= parms (args (clause-head clause)))</div><div class="line">        (clause-body clause))</div><div class="line">      cont)))</div><div class="line"></div><div class="line">(defun maybe-add-undo-bindings (compiled-exps)</div><div class="line">  &quot;Undo any bindings that need undoing.</div><div class="line">  If there are any, bind the trail before we start.&quot;</div><div class="line">  (if (length=1 compiled-exps)</div><div class="line">      compiled-exps</div><div class="line">      `((let ((old-trail (fill-pointer *trail*)))</div><div class="line">          ,(first compiled-exps)</div><div class="line">          ,@(loop for exp in (rest compiled-exps)</div><div class="line">                  collect &#39;(undo-bindings! old-trail)</div><div class="line">                  collect exp)))))</div><div class="line"></div><div class="line">(defun bind-unbound-vars (parameters exp)</div><div class="line">  &quot;If there are any variables in exp (besides the parameters)</div><div class="line">  then bind them to new vars.&quot;</div><div class="line">  (let ((exp-vars (set-difference (variables-in exp)</div><div class="line">                                  parameters)))</div><div class="line">    (if exp-vars</div><div class="line">        `(let ,(mapcar #&#39;(lambda (var) `(,var (?)))</div><div class="line">                       exp-vars)</div><div class="line">           ,exp)</div><div class="line">        exp)))</div></div><!-- fragment --><p>С этими улучшениями мы получили код для <code>likes</code> и <code>member</code>:</p>
<div class="fragment"><div class="line">(DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)</div><div class="line">  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'ROBIN)</code></p>
<p><code>(IF (UNIFY! ?ARG2 'CATS)</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT)))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<div class="fragment"><div class="line">(LET ((?X (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'SANDY)</code></p>
<p><code>(IF (UNIFY! ?ARG2 ?X)</code></p>
<div class="fragment"><div class="line">(LIKES/2 ?X &#39;CATS CONT))))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<div class="fragment"><div class="line">(LET ((?X (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'KIM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 ?X)</code></p>
<div class="fragment"><div class="line">            (LIKES/2 ?X &#39;LEE (LAMBDA ()</div><div class="line">                    (LIKES/2 ?X &#39;KIM CONT))))))))</div><div class="line">(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)</div><div class="line">  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))</div><div class="line">    (LET ((?ITEM (?))</div><div class="line">            (?REST (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT))))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<div class="fragment"><div class="line">(LET ((?X (?))</div></div><!-- fragment --><p><code>(? ITEM (?))</code></p>
<div class="fragment"><div class="line">(?REST (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?X ?REST))</code></p>
<div class="fragment"><div class="line">(MEMBER/2 ?ITEM ?REST CONT))))))</div></div><!-- fragment --><h2>12.3 Улучшение компилятора</h2>
<p>Это неплохо, хотя есть еще возможности для улучшения. Одно небольшое улучшение - устранение ненужных переменных. Например, <code>?rest</code> в первом предложении <code>member</code> и <code>?x</code> во втором предложении привязаны к новым переменным - результату вызова (?) - и затем используются только один раз. Сгенерированный код можно было бы немного упростить, просто поместив вызов (?) в нужную позицию(inline), а не связывая его результат с переменной и затем ссылаясь на эту переменную. Это изменение состоит из двух частей: обновление <code>compile-arg</code> для компиляции анонимной переменной встроенной(inline) и изменение макроса &lt;- так, чтобы он преобразовывал все переменные, которые появляются только один раз в предложении, в анонимные переменные:</p>
<div class="fragment"><div class="line">(defmacro &lt;- (&amp;rest clause)</div><div class="line">  &quot;Add a clause to the data base.&quot;</div><div class="line">  `(add-clause &#39;,(make-anonymous clause)))</div><div class="line"></div><div class="line">(defun compile-arg (arg)</div><div class="line">  &quot;Generate code for an argument to a goal in the body.&quot;</div><div class="line">  (cond ((variable-p arg) arg)</div><div class="line">        ((not (has-variable-p arg)) `&#39;,arg)</div><div class="line">        ((proper-listp arg)</div><div class="line">         `(list .,(mapcar #&#39;compile-arg arg)))</div><div class="line">        (t `(cons ,(compile-arg (first arg))</div><div class="line">                  ,(compile-arg (rest arg))))))</div><div class="line"></div><div class="line">(defun make-anonymous (exp &amp;optional</div><div class="line">                       (anon-vars (anonymous-variables-in exp)))</div><div class="line">  &quot;Replace variables that are only used once with ?.&quot;</div><div class="line">  (cond ((consp exp)</div><div class="line">         (reuse-cons (make-anonymous (first exp) anon-vars)</div><div class="line">                     (make-anonymous (rest exp) anon-vars)</div><div class="line">                     exp))</div><div class="line">        ((member exp anon-vars) &#39;?)</div><div class="line">        (t exp)))</div></div><!-- fragment --><p>Найти анонимные переменные непросто. Следующая функция хранит два списка: переменные, которые были обнаружены один раз, и переменные, которые были обнаружены дважды или более. Затем для обхода дерева используется локальная функция <code>walk</code>, рекурсивно рассматривая компоненты каждой cons-ячейки и обновляя два списка при обнаружении каждой переменной. Следует помнить об использовании локальных функций, а также об альтернативе, обсуждаемой в <a href="#p4625">упражнении 12.23</a> на <a href="#p428">стр. 428</a>.</p>
<div class="fragment"><div class="line">(defun anonymous-variables-in (tree)</div><div class="line">  &quot;Return a list of all variables that occur only once in tree.&quot;</div><div class="line">  (let ((seen-once nil)</div><div class="line">            (seen-more nil))</div><div class="line">    (labels ((walk (x)</div><div class="line">            (cond</div><div class="line">                ((variable-p x)</div><div class="line">                    (cond ((member x seen-once)</div><div class="line">                              (setf seen-once (delete x seen-once))</div><div class="line">                              (push x seen-more))</div><div class="line">                        ((member x seen-more) nil)</div><div class="line">                        (t (push x seen-once))))</div><div class="line">                ((consp x)</div><div class="line">                    (walk (first x))</div><div class="line">                    (walk (rest x))))))</div><div class="line">      (walk tree)</div><div class="line">      seen-once)))</div></div><!-- fragment --><p>Теперь <code>member</code> компилируется в это:</p>
<div class="fragment"><div class="line">(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)</div></div><!-- fragment --><p><code>(LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))</code></p>
<p><code>(LET ((?ITEM (?)))</code></p>
<p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code> </p><pre class="fragment">    `(IF (UNIFY!
</pre><p> ?ARG2 (CONS ?ITEM (?)))` </p><pre class="fragment">            `(FUNCALL CONT))))`

`(UNDO-BINDINGS!
</pre><p> OLD-TRAIL)`</p>
<div class="fragment"><div class="line">(LET ((?ITEM (?))</div><div class="line">    (?REST (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS (?) ?REST))</code></p>
<div class="fragment"><div class="line">(MEMBER/2 ?ITEM ?REST CONT))))))</div></div><!-- fragment --><h2>12.4 Улучшение компиляции унификации</h2>
<p>Теперь перейдем к усовершенствованию <code>compile-unify</code>. Напомним, что мы хотим исключить определенные вызовы <code>unify!</code>, Чтобы, например, первое предложение <code>member:</code></p>
<div class="fragment"><div class="line">(&lt;- (member ?item (?item . ?rest)))</div></div><!-- fragment --><p>компилируется в:</p>
<div class="fragment"><div class="line">(LET ((?ITEM (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 ?ITEM)</code></p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?ITEM (?)))</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT))))</div></div><!-- fragment --><p>когда оно могло бы скомпилироваться в более эффективный:</p>
<p><code>(IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT))</div></div><!-- fragment --><p>Устранение объединения/унификации одной цели в дальнейшем отразится и на других целях, поэтому нам нужно будет отслеживать выражения, которые были объединены/унифицированы вместе. У нас есть выбор дизайна. Либо <code>compile-unify</code> может изменять глобальную переменную состояния, либо возвращать несколько значений. На основании того, что глобальные переменные беспорядочны, мы делаем второй выбор: <code>compile-unify</code> принимает список привязок в качестве дополнительного аргумента и возвращает два значения: фактический код и обновленный список привязок. Мы ожидаем, что для работы с этими множественными значениями придется изменить другие связанные функции.</p>
<p>Когда в нашем примере сначала вызывается <code>compile-unify</code>, её просят объединить/унифицировать <code>?argl</code> и <code>?item</code>. Мы хотим, чтобы она возвращала не код (точнее, тривиально верный тест t). Для второго значения она должна вернуть новый список привязок с <code>?item</code>, привязанным к <code>?arg1</code>. Эта привязка будет использоваться для замены <code>?item</code> на <code>?arg1</code> в последующем коде.</p>
<p>Как мы узнаем, что нужно привязать <code>?item</code> к <code>?arg1</code>, а не наоборот? Поскольку <code>?arg1</code> уже привязан к чему-то - значению, переданному в <code>member</code>. Мы не знаем, что это за значение, но мы не можем его игнорировать. Таким образом, в исходном списке привязки должно быть указано, что параметры к чему-то привязаны. Простое соглашение - привязать параметры к самим себе. Таким образом, исходный список привязки будет:</p>
<div class="fragment"><div class="line">((?arg1 .?arg1) (?arg2 . ?arg2))</div></div><!-- fragment --><p>В предыдущей главе (<a href="B978008057115750011X.xhtml#p354">страница 354</a>) мы видели, что привязка переменной к самой себе может привести к проблемам; нам придется быть осторожными.</p>
<p>Помимо устранения объединения/унификации новых переменных с параметрами, можно сделать еще несколько улучшений. Например, унификации, включающие только константы, могут быть выполнены во время компиляции. Вызов <code>(= (f a) (f a))</code> всегда успешен, а <code>(= 3 4)</code> всегда терпит неудачу. Кроме того, объединение/унификация двух cons-ячеек может быть разбита на компоненты во время компиляции: <code>(= (f ?x) (f a))</code> сокращается до <code>(= ?x a)</code> и <code>(= f f)</code>, где последний тривиально успешен(истинен). Мы даже можем выполнить проверку некоторых событий во время компиляции: <code>(= ?x (f ?x))</code> должно завершиться неудачей(fail).</p>
<p>В следующей таблице перечислены эти улучшения вместе с разбивкой по случаям объединения/унификации связанной переменной <code>(?arg1)</code> или несвязанной переменной <code>(?x)</code> с другим выражением. Первый столбец - это вызов унификации, второй - сгенерированный код, а третий - привязки, которые будут добавлены в результате вызова:</p>
<table class="doxtable">
<tr>
<th></th><th>Unification </th><th>Code </th><th>Bindings  </th></tr>
<tr>
<td>1 </td><td><code>(= 3 3)</code> </td><td><code>t</code> </td><td><code>-</code> </td></tr>
<tr>
<td>2 </td><td><code>(= 3 4)</code> </td><td><code>nil</code> </td><td><code>-</code> </td></tr>
<tr>
<td>3 </td><td><code>(= (f ?x) (?p 3))</code> </td><td><code>t</code> </td><td><code>(?x . 3) (?p . f)</code> </td></tr>
<tr>
<td>4 </td><td><code>(= ?arg1 ?y)</code> </td><td><code>t</code> </td><td><code>(?y . ?arg1)</code> </td></tr>
<tr>
<td>5 </td><td><code>(= ?arg1 ?arg2)</code> </td><td><code>(unify! ?arg1 ?arg2)</code> </td><td><code>(?arg1 . ?arg2)</code> </td></tr>
<tr>
<td>6 </td><td><code>(= ?arg1 3)</code> </td><td><code>(unify! ?arg1 3)</code> </td><td><code>(?arg1 . 3)</code> </td></tr>
<tr>
<td>7 </td><td><code>(= ?arg1 (f ? y))</code> </td><td><code>(unify! ?arg1 . . . )</code> </td><td><code>(?y . ?y)</code> </td></tr>
<tr>
<td>8 </td><td><code>(= ?x ?y)</code> </td><td><code>t</code> </td><td><code>(?y . ?y)</code> </td></tr>
<tr>
<td>9 </td><td><code>(= ?x 3)</code> </td><td><code>t</code> </td><td><code>(?x . 3)</code> </td></tr>
<tr>
<td>10 </td><td><code>(= ?x (f ? y))</code> </td><td><code>(unify! ?x . . . )</code> </td><td><code>(?y . ?y)</code> </td></tr>
<tr>
<td>11 </td><td><code>(= ?x (f ? x))</code> </td><td><code>nil</code> </td><td><code>-</code> </td></tr>
<tr>
<td>12 </td><td><code>(= ?x ?)</code> </td><td><code>t</code> </td><td><code>-</code> </td></tr>
</table>
<p>Из этой таблицы мы можем создать нашу новую версию <code>compile-unify</code>. Первая часть довольно проста. Она заботится о первых трех случаях в этой таблице и обеспечивает вызов <code>compile-unify-variable</code> с переменной в качестве первого аргумента для остальных случаев.</p>
<div class="fragment"><div class="line">(defun compile-unify (x y bindings)</div><div class="line">  &quot;Return 2 values: code to test if x and y unify,</div><div class="line">  and a new binding list.&quot;</div><div class="line">  (cond</div><div class="line">    ;; Unify constants and conses:                       ; Case</div><div class="line">    ((not (or (has-variable-p x) (has-variable-p y)))    ; 1,2</div><div class="line">     (values (equal x y) bindings))</div><div class="line">    ((and (consp x) (consp y))                           ; 3</div><div class="line">     (multiple-value-bind (code1 bindings1)</div><div class="line">         (compile-unify (first x) (first y) bindings)</div><div class="line">       (multiple-value-bind (code2 bindings2)</div><div class="line">           (compile-unify (rest x) (rest y) bindings1)</div><div class="line">         (values (compile-if code1 code2) bindings2))))</div><div class="line">    ;; Here x or y is a variable.  Pick the right one:</div><div class="line">    ((variable-p x) (compile-unify-variable x y bindings))</div><div class="line">    (t              (compile-unify-variable y x bindings))))</div><div class="line"></div><div class="line">(defun compile-if (pred then-part)</div><div class="line">  &quot;Compile a Lisp IF form. No else-part allowed.&quot;</div><div class="line">  (case pred</div><div class="line">    ((t) then-part)</div><div class="line">    ((nil) nil)</div><div class="line">    (otherwise `(if ,pred ,then-part))))</div></div><!-- fragment --><p>Следующая функция <code>compile-unify-variable</code> - одна из самых сложных, которые мы видели. Для каждого аргумента мы смотрим, есть ли у него привязка (локальные переменные <code>xb</code> и<code>yb</code>), а затем используем привязки, чтобы получить значение каждого аргумента (<code>x1</code> и <code>y1</code>). Обратите внимание, что либо для несвязанной переменной, либо для переменной, привязанной к самой себе, <code>x</code> будет равняться <code>x1</code> (и то же самое для <code>y</code> и <code>y1</code>). Если любая из пар значений не эквивалентна, мы должны использовать новые (<code>x1</code> или <code>y1</code>), и предложение с комментарием deref делает это. После этого мы просто рассмотрим случаи/варианты по одному. Оказалось, что было проще немного изменить порядок, чем в предыдущей таблице, но каждое предложение снабжено соответствующим номером:</p>
<div class="fragment"><div class="line">(defun compile-unify-variable (x y bindings)</div><div class="line">  &quot;X is a variable, and Y may be.&quot;</div><div class="line">  (let* ((xb (follow-binding x bindings))</div><div class="line">         (x1 (if xb (cdr xb) x))</div><div class="line">         (yb (if (variable-p y) (follow-binding y bindings)))</div><div class="line">         (y1 (if yb (cdr yb) y)))</div><div class="line">    (cond                                                 ; Case:</div><div class="line">      ((or (eq x &#39;?) (eq y &#39;?)) (values t bindings))      ; 12</div><div class="line">      ((not (and (equal x x1) (equal y y1)))              ; deref</div><div class="line">       (compile-unify x1 y1 bindings))</div><div class="line">      ((find-anywhere x1 y1) (values nil bindings))       ; 11</div><div class="line">      ((consp y1)                                         ; 7,10</div><div class="line">       (values `(unify! ,x1 ,(compile-arg y1 bindings))</div><div class="line">               (bind-variables-in y1 bindings)))</div><div class="line">      ((not (null xb))</div><div class="line">       ;; i.e. x is an ?arg variable</div><div class="line">       (if (and (variable-p y1) (null yb))</div><div class="line">           (values &#39;t (extend-bindings y1 x1 bindings))   ; 4</div><div class="line">           (values `(unify! ,x1 ,(compile-arg y1 bindings))</div><div class="line">                   (extend-bindings x1 y1 bindings))))    ; 5,6</div><div class="line">      ((not (null yb))</div><div class="line">       (compile-unify-variable y1 x1 bindings))</div><div class="line">      (t (values &#39;t (extend-bindings x1 y1 bindings)))))) ; 8,9</div></div><!-- fragment --><p>Найдите время, чтобы понять, как работает эта функция. Затем переходите к следующим вспомогательным функциям:</p>
<div class="fragment"><div class="line">(defun bind-variables-in (exp bindings)</div><div class="line">  &quot;Bind all variables in exp to themselves, and add that to</div><div class="line">  bindings (except for variables already bound).&quot;</div><div class="line">  (dolist (var (variables-in exp))</div><div class="line">    (unless (get-binding var bindings)</div><div class="line">      (setf bindings (extend-bindings var var bindings))))</div><div class="line">  bindings)</div><div class="line"></div><div class="line">(defun follow-binding (var bindings)</div><div class="line">  &quot;Get the ultimate binding of var according to bindings.&quot;</div><div class="line">  (let ((b (get-binding var bindings)))</div><div class="line">    (if (eq (car b) (cdr b))</div><div class="line">        b</div><div class="line">        (or (follow-binding (cdr b) bindings)</div><div class="line">            b))))</div></div><!-- fragment --><p>Теперь нам нужно интегрировать новый <code>compile-unify</code> в остальную часть компилятора. Проблема в том, что новая версия принимает дополнительный аргумент и возвращает дополнительное значение, поэтому все вызывающие его функции должны быть изменены. Давайте еще раз посмотрим на последовательность вызовов:</p>
<div class="fragment"><div class="line">prolog-compile</div><div class="line">  compile-predicate</div><div class="line">    compile-clause</div><div class="line">      compile-body</div><div class="line">        compile-call</div><div class="line">        compile-arg</div><div class="line">          compile-unify</div><div class="line">            compile-arg</div></div><!-- fragment --><p>Во-первых, спускаясь вниз, мы видим, что <code>compile-arg</code> должна принимать список привязок в качестве аргумента, чтобы она могла искать и подставлять соответствующие значения. Но она не изменяет список привязок, поэтому она все равно возвращает одно значение:</p>
<div class="fragment"><div class="line">(defun compile-arg (arg bindings)</div><div class="line">  &quot;Generate code for an argument to a goal in the body.&quot;</div><div class="line">  (cond ((eq arg &#39;?) &#39;(?))</div><div class="line">        ((variable-p arg)</div><div class="line">         (let ((binding (get-binding arg bindings)))</div><div class="line">           (if (and (not (null binding))</div><div class="line">                    (not (eq arg (binding-val binding))))</div><div class="line">             (compile-arg (binding-val binding) bindings)</div><div class="line">             arg)))</div><div class="line">        ((not (find-if-anywhere #&#39;variable-p arg)) `&#39;,arg)</div><div class="line">        ((proper-listp arg)</div><div class="line">         `(list .,(mapcar #&#39;(lambda (a) (compile-arg a bindings))</div><div class="line">                          arg)))</div><div class="line">        (t `(cons ,(compile-arg (first arg) bindings)</div><div class="line">                  ,(compile-arg (rest arg) bindings)))))</div></div><!-- fragment --><p>Теперь, поднимаясь вверх, <code>compile-body</code> надо взять список привязок и передать его различным функциям:</p>
<div class="fragment"><div class="line">(defun compile-body (body cont bindings)</div><div class="line">  &quot;Compile the body of a clause.&quot;</div><div class="line">  (cond</div><div class="line">    ((null body)</div><div class="line">     `(funcall ,cont))</div><div class="line">    ((eq (first body) &#39;!)                              ;***</div><div class="line">     `(progn ,(compile-body (rest body) cont bindings) ;***</div><div class="line">             (return-from ,*predicate* nil)))          ;***</div><div class="line">    (t (let* ((goal (first body))</div><div class="line">              (macro (prolog-compiler-macro (predicate goal)))</div><div class="line">              (macro-val (if macro</div><div class="line">                             (funcall macro goal (rest body)</div><div class="line">                                      cont bindings))))</div><div class="line">        (if (and macro (not (eq macro-val :pass)))</div><div class="line">            macro-val</div><div class="line">            `(,(make-predicate (predicate goal)</div><div class="line">                               (relation-arity goal))</div><div class="line">              ,@(mapcar #&#39;(lambda (arg)</div><div class="line">                            (compile-arg arg bindings))</div><div class="line">                        (args goal))</div><div class="line">              ,(if (null (rest body))</div><div class="line">                   cont</div><div class="line">                   `#&#39;(lambda ()</div><div class="line">                        ,(compile-body</div><div class="line">                           (rest body) cont</div><div class="line">                           (bind-new-variables bindings goal))))))))))</div></div><!-- fragment --><p>Функция <code>bind-new-variables</code> принимает любые переменные, упомянутые в цели, которые еще не были связаны, и связывает эти переменные с собой. Это потому, что цель, какой бы она ни была, может связывать ее аргументы.</p>
<div class="fragment"><div class="line">(defun bind-new-variables (bindings goal)</div><div class="line">  &quot;Extend bindings to include any unbound variables in goal.&quot;</div><div class="line">  (let ((variables (remove-if #&#39;(lambda (v) (assoc v bindings))</div><div class="line">                              (variables-in goal))))</div><div class="line">    (nconc (mapcar #&#39;self-cons variables) bindings)))</div><div class="line"></div><div class="line">(defun self-cons (x) (cons x x))</div></div><!-- fragment --><p>Одна из функций, которую необходимо изменить, чтобы принять список привязки, - это макрос компилятора для =:</p>
<div class="fragment"><div class="line">(def-prolog-compiler-macro = (goal body cont bindings)</div><div class="line">  &quot;Compile a goal which is a call to =.&quot;</div><div class="line">  (let ((args (args goal)))</div><div class="line">    (if (/= (length args) 2)</div><div class="line">        :pass ;; decline to handle this goal</div><div class="line">        (multiple-value-bind (code1 bindings1)</div><div class="line">            (compile-unify (first args) (second args) bindings)</div><div class="line">          (compile-if</div><div class="line">            code1</div><div class="line">            (compile-body body cont bindings1))))))</div></div><!-- fragment --><p>Последний шаг вверх - изменить <code>compile-clause</code> так, чтобы она запускала все, передавая <code>compile-body</code> список привязки со всеми параметрами, привязанными к себе:</p>
<div class="fragment"><div class="line">(defun compile-clause (parms clause cont)</div><div class="line">  &quot;Transform away the head, and compile the resulting body.&quot;</div><div class="line">  (bind-unbound-vars</div><div class="line">    parms</div><div class="line">    (compile-body</div><div class="line">      (nconc</div><div class="line">        (mapcar #&#39;make-= parms (args (clause-head clause)))</div><div class="line">        (clause-body clause))</div><div class="line">      cont</div><div class="line">      (mapcar #&#39;self-cons parms))))                    ;***</div></div><!-- fragment --><p>Наконец, мы видим плоды наших усилий:</p>
<div class="fragment"><div class="line">(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)</div><div class="line">  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<div class="fragment"><div class="line">(LET ((?REST (?)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG2 (CONS (?) ?REST))</code></p>
<div class="fragment"><div class="line">              (MEMBER/2 ?ARG1 ?REST CONT)))))</div><div class="line">(DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)</div><div class="line">  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))</div></div><!-- fragment --><p><code>(IF (UNIFY! ?ARG1 'ROBIN)</code></p>
<p><code>(IF (UNIFY! ?ARG2 'CATS)</code></p>
<div class="fragment"><div class="line">(FUNCALL CONT)))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<p><code>(IF (UNIFY! ?ARG1 'SANDY)</code></p>
<div class="fragment"><div class="line">(LIKES/2 ?ARG2 &#39;CATS CONT))</div></div><!-- fragment --><p><code>(UNDO-BINDINGS! OLD-TRAIL)</code></p>
<p><code>(IF (UNIFY! ?ARG1 'KIM)</code></p>
<div class="fragment"><div class="line">(LIKES/2 ?ARG2 &#39;LEE (LAMBDA ()</div><div class="line">            (LIKES/2 ?ARG2 &#39;KIM CONT))))))</div></div><!-- fragment --><h2>12.5 Дальнейшие улучшения унификации</h2>
<p>Можно ли еще раз улучшить <code>compile-unify</code>? Если мы будем настаивать на том, чтобы он вызывал <code>unify!</code>, кажется, что его нельзя сделать намного лучше. Однако мы могли бы улучшить его, фактически скомпилировав <code>unify!</code>. Это ключевая идея в абстрактной машине Уоррена, или WAM(Warren Abstract Machine), которая является наиболее часто используемой моделью для компиляторов Пролога.</p>
<p>Мы вызываем <code>unify!</code> в четырех случаях (5, 6, 7 и 10), и в каждом случае первый аргумент является переменной, и мы кое-что знаем о втором аргументе. Но первое, что делает <code>unify!</code> - это избыточно проверяет, является ли первый аргумент переменной. Мы могли бы исключить ненужные тесты, вызвав более специализированные функции, а не универсальную функцию <code>unify!</code>. Рассмотрим этот вызов:</p>
<p><code>(unify! ?arg2 (cons ?arg1 (?)))</code></p>
<p>Если <code>?arg2</code> является несвязанной переменной, этот код подходит. Но если <code>?arg2</code> - постоянный атом, мы должны немедленно выйти с ошибкой(fail), не позволяя <code>cons</code> и <code>?</code> генерировать мусор. Мы могли бы изменить тест на:</p>
<div class="fragment"><div class="line">(and (consp-or-variable-p ?arg2)</div></div><!-- fragment --><p><code>(unify-first! ?arg2 ?arg1)</code></p>
<p><code>(unify-rest! ?arg2 (?)))</code></p>
<p>с подходящими определениями упомянутых здесь функций. Это изменение должно ускорить время выполнения и ограничить количество генерируемого мусора. Конечно, это удлиняет сгенерированный код, так что это может замедлить работу, если программа в конечном итоге будет тратить слишком много времени на передачу кода процессору.</p>
<p>** Упражнение 12.1 [h] ** Напишите определения для <code>consp-or-variable-p, unify-first!</code> и <code>unify-rest!</code>, и измените компилятор для генерации кода, подобного описанному ранее. Вы можете посмотреть функцию <code>compile-rule</code> в <a href="B9780080571157500091.xhtml#s0035">раздел 9.6</a>, начиная с <a href="B9780080571157500091.xhtml#p300">страницы 300</a>. Эта функция скомпилировала вызов <code>pat-match</code> в отдельные тесты; теперь мы хотим сделать то же самое для <code>unify!</code>. Выполните несколько тестов, чтобы сравнить измененный компилятор с исходной версией.</p>
<p><b>Exercise 12.2 [h]</b> We can gain some more efficiency by keeping track of which variables have been dereferenced and calling an appropriate unification function: either one that dereferences the argument or one that assumes the argument has already been dereferenced. Implement this approach.</p>
<p><b>Упражнение 12.3 [m]</b> Какой код создается для <code>(= (f (g ?x) ?y) (f ?y (?p a)))?</code> Какой более эффективный код представляет ту же унификацию? Насколько легко изменить компилятор, чтобы получить более эффективный результат?</p>
<p><b>Упражнение 12.4 [h]</b> Оглядываясь назад, кажется, что привязка переменных к самим себе, как в <code>(?argl . ?argl</code>), была не такой уж хорошей идеей. Это усложняет значение привязок и запрещает нам использовать существующие инструменты. Например, для случая 11 мне пришлось использовать <code>find-anywhere</code> вместо <code>occur-check</code>, потому что <code>occur-check</code> ожидает незацикленный список привязок. Но функция find-anywhere не так хорошо выполняет свою работу, как <code>occur-check</code>. Напишите версию <code>compile-unify</code>, которая возвращает три значения: код, незацикленный список привязки и список переменных, которые привязаны к неизвестным значениям.</p>
<p><b>Упражнение 12.5 [h]</b> Альтернативой предыдущему упражнению является отказ от использования списков привязки во всех случаях. Вместо этого мы могли бы передать список классов эквивалентности, то есть список списков, где каждый подсписок содержит один или несколько элементов, которые были объединены/унифицированы. При таком подходе начальный список классов эквивалентности будет <code>((?arg1) (?arg2))</code>. После объединения/унификации <code>?arg1</code> с <code>?x</code>, <code>?arg2</code> с <code>?arg2</code> и <code>?x</code> с 4, список будет ( <code>(4 ?arg1 ?x) (?arg2 ?y))</code>. Это предполагает соглашение о том, что канонический член класса эквивалентности (тот, который будет заменен всеми остальными) идет первым. Реализуйте этот подход. Какие у него преимущества и недостатки?</p>
<h2>12.6 Пользовательский интерфейс для компилятора</h2>
<p>Компилятор может преобразовывать Пролог в Лисп, но это не принесет нам пользы, если мы не сможем удобно организовать компиляцию правильных отношений Пролога и вызвать правильные функции Лиспа. Другими словами, мы должны интегрировать компилятор с макросами <code>&lt;-</code> и <code>?</code>. Удивительно, но нам вообще не нужно менять эти макросы. Вместо этого мы изменим функции, которые вызывают эти макросы. Когда вводится новое предложение, мы вводим предикат предложения в список <code>*uncompiled*</code>. Это однострочное дополнение к <code>add-clause:</code></p>
<div class="fragment"><div class="line">(defvar *uncompiled* nil</div><div class="line">  &quot;Prolog symbols that have not been compiled.&quot;)</div><div class="line"></div><div class="line">(defun add-clause (clause)</div><div class="line">  &quot;Add a clause to the data base, indexed by head&#39;s predicate.&quot;</div><div class="line">  ;; The predicate must be a non-variable symbol.</div><div class="line">  (let ((pred (predicate (clause-head clause))))</div><div class="line">    (assert (and (symbolp pred) (not (variable-p pred))))</div><div class="line">    (pushnew pred *db-predicates*)</div><div class="line">    (pushnew pred *uncompiled*)                          ;***</div><div class="line">    (setf (get pred &#39;clauses)</div><div class="line">          (nconc (get-clauses pred) (list clause)))</div><div class="line">    pred))</div></div><!-- fragment --><p>Теперь, когда делается запрос, макрос <code>?-</code> заменяется вызовом <code>top-level-proof</code>. Список целей в запросе вместе с целью <code>show-prolog-vars</code> добавляется в качестве единственного предложения. для отношения <code>top-level-query</code>. Затем этот запрос, вместе с любыми другими, которые находятся в некомпилированном списке, компилируется. Наконец, вызывается вновь скомпилированная функция запроса верхнего уровня.</p>
<div class="fragment"><div class="line">(defun top-level-prove (goals)</div><div class="line">  &quot;Prove the list of goals by compiling and calling it.&quot;</div><div class="line">  ;; First redefine top-level-query</div><div class="line">  (clear-predicate &#39;top-level-query)</div><div class="line">  (let ((vars (delete &#39;? (variables-in goals))))</div><div class="line">    (add-clause `((top-level-query)</div><div class="line">                  ,@goals</div><div class="line">                  (show-prolog-vars ,(mapcar #&#39;symbol-name vars)</div><div class="line">                                    ,vars))))</div><div class="line">  ;; Now run it</div><div class="line">  (run-prolog &#39;top-level-query/0 #&#39;ignore)</div><div class="line">  (format t &quot;~&amp;No.&quot;)</div><div class="line">  (values))</div><div class="line"></div><div class="line">(defun run-prolog (procedure cont)</div><div class="line">  &quot;Run a 0-ary prolog procedure with a given continuation.&quot;</div><div class="line">  ;; First compile anything else that needs it</div><div class="line">  (prolog-compile-symbols)</div><div class="line">  ;; Reset the trail and the new variable counter</div><div class="line">  (setf (fill-pointer *trail*) 0)</div><div class="line">  (setf *var-counter* 0)</div><div class="line">  ;; Finally, call the query</div><div class="line">  (catch &#39;top-level-prove</div><div class="line">    (funcall procedure cont)))</div><div class="line"></div><div class="line">(defun prolog-compile-symbols (&amp;optional (symbols *uncompiled*))</div><div class="line">  &quot;Compile a list of Prolog symbols.</div><div class="line">  By default, the list is all symbols that need it.&quot;</div><div class="line">  (mapc #&#39;prolog-compile symbols)</div><div class="line">  (setf *uncompiled* (set-difference *uncompiled* symbols)))</div><div class="line"></div><div class="line">(defun ignore (&amp;rest args)</div><div class="line">  (declare (ignore args))</div><div class="line">  nil)</div></div><!-- fragment --><p>Обратите внимание, что на верхнем уровне нам не нужно продолжение, чтобы что-то делать. Произвольно мы решили передать функцию <code>ignore</code>, которая определена так, чтобы игнорировать свои аргументы. Эта функция полезна во многих местах; некоторые программисты объявляют её встроенной и затем используют вызов <code>ignore</code> вместо объявления(декларации) ignore:</p>
<div class="fragment"><div class="line">(defun third-arg (x y z)</div><div class="line">  (ignore x y)</div><div class="line">  z)</div></div><!-- fragment --><p>Соглашение о вызовах компилятора отличается от интерпретатора, поэтому необходимо переопределить примитивы. Старое определение примитива <code>show-prolog-vars</code> имело три параметра: список аргументов цели, список привязки и список ожидающих целей. Новое определение <code>show-prolog-vars/2</code> также имеет три параметра, но это просто совпадение. Первые два параметра - это два отдельных аргумента цели: список имен переменных и список значений переменных. Последний параметр - функция продолжение. Чтобы продолжить, мы вызываем эту функцию, но в случае неудачи мы переходим к точке перехвата, установленной в <code>top-level-prove</code>.</p>
<div class="fragment"><div class="line">(defun show-prolog-vars/2 (var-names vars cont)</div><div class="line">  &quot;Display the variables, and prompt the user to see</div><div class="line">  if we should continue.  If not, return to the top level.&quot;</div><div class="line">  (if (null vars)</div><div class="line">      (format t &quot;~&amp;Yes&quot;)</div><div class="line">      (loop for name in var-names</div><div class="line">            for var in vars do</div><div class="line">            (format t &quot;~&amp;~a = ~a&quot; name (deref-exp var))))</div><div class="line">  (if (continue-p)</div><div class="line">      (funcall cont)</div><div class="line">      (throw &#39;top-level-prove nil)))</div><div class="line"></div><div class="line">(defun deref-exp (exp)</div><div class="line">  &quot;Build something equivalent to EXP with variables dereferenced.&quot;</div><div class="line">  (if (atom (deref exp))</div><div class="line">      exp</div><div class="line">      (reuse-cons</div><div class="line">        (deref-exp (first exp))</div><div class="line">        (deref-exp (rest exp))</div><div class="line">        exp)))</div></div><!-- fragment --><p>Имея эти определения, мы можем вызвать компилятор автоматически, просто сделав запрос с макросом ?-.</p>
<p><b>Упражнение 12.6 [m]</b> Предположим, вы определяете предикат <code>p</code>, который вызывает <code>q</code>, а затем определяете <code>q</code>. В некоторых реализациях Lisp, когда вы делаете запрос типа <code>(?- (p? x))</code>, вы можете получить предупреждающее сообщение типа <code>"function q/1 undefined"</code> перед получением правильного ответа. Проблема в том, что каждая функция компилируется отдельно, поэтому предупреждения, обнаруженные во время компиляции <code>p/1</code>, будут выводиться сразу, даже если функция <code>q/1</code> будет определена позже. В ANSI Common Lisp есть способ отложить вывод предупреждений до тех пор, пока не будет выполнена серия компиляций: завершите компиляцию макросом <code>with-compilation-unit</code>. Даже если ваша реализация не предоставляет этот макрос, он может предоставлять те же функции под другим именем. Выясните, определен ли уже в вашей реализации <code>with-compilation-unit</code> или его можно определить.</p>
<h2>12.7 Тестирование компилятора</h2>
<p>Наш скомпилированный код Prolog запускает головоломку зебра за 17,4 секунды, что в 16 раз больше, чем у интерпретированной версии, со скоростью 740 LIPS.</p>
<p>Другой популярный тест - это обратная функция Lisp, которую мы можем закодировать как отношение rev:</p>
<div class="fragment"><div class="line">(&lt;- (rev () ()))</div><div class="line">(&lt;- (rev (?x . ?a) ?b) (rev ?a ?c) (concat ?c (?x) ?b))</div><div class="line">(&lt;- (concat () ?1 ?1)</div><div class="line">(&lt;- (concat (?x . ?a) ?b (?x . ?c)) (concat ?a ?b ?c))</div></div><!-- fragment --><p>rev использует отношение concat, которое означает конкатенацию, (<code>concat ?a ?b ?c</code>) истинно, когда <code>?a</code>, объединенное с <code>?b</code>, дает <code>?c</code>. Это родственное имя предпочтительнее других процедурных имен, таких как append. Но <code>rev</code> очень похож на следующие определения Лиспа:</p>
<div class="fragment"><div class="line">(defun rev (1)</div><div class="line">  (if (null 1)</div><div class="line">    nil</div><div class="line">    (app (rev (rest 1 ))</div><div class="line">        (list (first 1)))))</div><div class="line"></div><div class="line">(defun app (x y)</div><div class="line">  (if (null x)</div><div class="line">    y</div><div class="line">      (cons (first x)</div><div class="line">        (app (rest x) y))))</div></div><!-- fragment --><p>Обе версии неэффективны. Можно написать итеративную версию <code>reverse</code>, которая не требует дополнительных затрат и является хвосто-рекурсивной:</p>
<div class="fragment"><div class="line">(&lt;- (irev ?l ?r) (irev3 ?l () ?r))</div><div class="line">(&lt;- (irev3 (?x . ?l) ?so-far ?r) (irev3 ?l (?x . ?so-far) ?r))</div><div class="line">(&lt;- (irev3 () ?r ?r))</div></div><!-- fragment --><p>Пролог <code>irev</code> эквивалентен этой программе на Лиспе:</p>
<div class="fragment"><div class="line">(defun irev (list) (irev2 list nil))</div><div class="line"></div><div class="line">(defun irev2 (list so-far)</div><div class="line">  (if (consp list)</div><div class="line">      (irev2 (rest list) (cons (first list) so-far))</div><div class="line">      so-far))</div></div><!-- fragment --><p>В следующей таблице показано время в секундах для выполнения этих подпрограмм в списках длиной 20 и 100, как для Пролога, так и для Лиспа, как интерпретируемых, так и скомпилированных. (Только скомпилированный Lisp может выполнить rev для списка из 100 элементов, не исчерпывая пространства стека.) Также включены времена для головоломки "зебра", хотя версии этой программы на Lisp не существует.</p>
<table class="doxtable">
<tr>
<th>Problem </th><th>Interp. Prolog </th><th>Comp. Prolog </th><th>Speed-up </th><th>Interp. Lisp </th><th>Comp. Lisp  </th></tr>
<tr>
<td><code>zebra</code> </td><td>278.000 </td><td>17.241 </td><td>16 </td><td>- </td><td>- </td></tr>
<tr>
<td><code>rev 20</code> </td><td>4.24 </td><td>.208 </td><td>20 </td><td>.241 </td><td>.0023 </td></tr>
<tr>
<td><code>rev 100</code> </td><td>- </td><td>- </td><td>- </td><td>- </td><td>.0614 </td></tr>
<tr>
<td><code>irev 20</code> </td><td>.22 </td><td>.010 </td><td>22 </td><td>.028 </td><td>.0005 </td></tr>
<tr>
<td><code>irev 100</code> </td><td>9.81 </td><td>.054 </td><td>181 </td><td>.139 </td><td>.0014 </td></tr>
</table>
<p>Этот тест слишком мал, чтобы быть окончательным, но в этих примерах компилятор Prolog в 16–181 раз быстрее интерпретатора Prolog, немного быстрее, чем интерпретируемый Lisp, но все же в 17–90 раз медленнее, чем скомпилированный Lisp. Это говорит о том, что интерпретатор Пролога не может использоваться в качестве практического инструмента программирования, но компилятор Пролога может.</p>
<p>Прежде чем двигаться дальше, интересно отметить, что Пролог автоматически предоставляет необязательные аргументы. Хотя не существует специального синтаксиса для необязательных аргументов, часто используется соглашение о наличии двух версий отношения: одной с <em>n</em> аргументами и одной с *n -* 1. Единственное предложение для случая *n -* 1 обеспечивает отсутствующий и, следовательно, "необязательный" аргумент. В следующем примере <code>irev/2</code> можно рассматривать как версию <code>irev/3</code>, в которой отсутствует необязательный аргумент ().</p>
<div class="fragment"><div class="line">(&lt;- (irev ?l ?r) (irev ?l () ?r))</div><div class="line">(&lt;- (irev (?x . ?l ) ?so-far ?r) (irev ?l (?x . ?so-far) ?r))</div><div class="line">(&lt;- (irev () ?r ?r))</div></div><!-- fragment --><p>Это примерно эквивалентно следующей версии Лиспа:</p>
<div class="fragment"><div class="line">(defun irev (list &amp;optional (so-far nil))</div><div class="line">  (if (consp list)</div><div class="line">      (irev (rest list) (cons (first list) so-far))</div><div class="line">      so-far))</div></div><!-- fragment --><h2>12.8 Добавление дополнительных примитивов</h2>
<p>Точно так же, как компилятору Lisp нужны машинные инструкции для ввода/вывода, арифметики и т.п., наша система Prolog должна иметь возможность выполнять определенные примитивные действия. Для интерпретатора Пролога примитивы были реализованы с помощью символов функций. Когда интерпретатор отправлялся за списком предложений, если вместо этого он получал функцию, он вызывал эту функцию, передавая ей аргументы в текущее отношение, текущие привязки и список неудовлетворенных целей. Для компилятора Prolog примитивы могут быть установлены просто путем написания функции Lisp, которая соблюдает соглашение о принятии продолжения в качестве последнего аргумента и имеет имя в форме <em>symbol/arity</em>(символ/аность) Например, вот простой способ обработки ввода и вывод:</p>
<div class="fragment"><div class="line">(defun read/1 (exp cont)</div></div><!-- fragment --><p><code>(if (unify! exp (read))</code></p>
<div class="fragment"><div class="line">      (funcall cont)))</div><div class="line">(defun write/1 (exp cont)</div><div class="line">  (write (deref-exp exp) :pretty t)</div><div class="line">  (funcall cont))</div></div><!-- fragment --><p>Вызов <code>(write ?x)</code> всегда будет успешным, поэтому всегда будет вызываться продолжение. Точно так же можно использовать <code>(read ?x)</code> для чтения значения и объединения/унификации его с <code>?x</code>. Если <code>?x</code> не связан, это то же самое, что присвоение значения. Однако также можно выполнить вызов типа <code>(read (?x + ?y))</code>, который будет успешным только в том случае, если вход представляет собой список из трех элементов с + в середине. Это простое расширение для определения <code>read/2</code> и <code>write/2</code> как отношений, указывающих, какой поток использовать. Чтобы сделать это полезным, нужно определить <code>open/2</code> как отношение, которое принимает pathname(путь) в качестве одного аргумента и возвращает поток в качестве другого. При желании могут поддерживаться и другие необязательные аргументы.</p>
<p>Примитив nl выводит новую строку:</p>
<div class="fragment"><div class="line">(defun nl/0 (cont) (terpri) (funcall cont))</div></div><!-- fragment --><p>Мы предоставили специальную поддержку для предиката унификации, =. Однако мы могли бы значительно упростить компилятор, имея простое определение для <code>=/2</code>:</p>
<div class="fragment"><div class="line">(defun =/2 (?arg1 ?arg2 cont)</div></div><!-- fragment --><p><code>(if (unify! ?arg1 ?arg2)</code></p>
<div class="fragment"><div class="line">(funcall cont)))</div></div><!-- fragment --><p>Фактически, если мы дадим нашему компилятору единственное предложение:</p>
<p>(&lt;- (= ?x <code>?x))</code></p>
<p>он производит именно этот код для определения <code>=/ 2</code>. Есть и другие предикаты равенства, о которых стоит побеспокоиться. Предикат <code>= =/2</code> больше похож на equal в Лиспе. Он не объединяет/унифицирует, а вместо этого проверяет равенство двух структур по своим элементам. Переменная считается равной(equal) только самой себе. Вот реализация:</p>
<div class="fragment"><div class="line">(defun =/2 (?arg1 ?arg2 cont)</div><div class="line">  &quot;Are the two arguments EQUAL with no unification,</div></div><!-- fragment --><p>`но с разыменованием? Если так, то получится. "</p>
<div class="fragment"><div class="line">  (if (deref-equal ?arg1 ?arg2)</div><div class="line">    (funcall cont)))</div><div class="line">(defun deref-equal (x y)</div><div class="line">  &quot;Are the two arguments EQUAL with no unification,</div><div class="line">  but with dereferencing?&quot;</div><div class="line">  (or (eql (deref x) (deref y))</div><div class="line">    (and (consp x)</div><div class="line">      (consp y)</div><div class="line">      (deref-equal (first x) (first y))</div><div class="line">      (deref-equal (rest x) (rest y)))))</div></div><!-- fragment --><p>Один из самых важных примитивов - это <code>call</code>. Как и <code>funcall</code> в Лиспе, <code>call</code> позволяет нам создать цель, а затем попытаться ее доказать.</p>
<div class="fragment"><div class="line">(defun call/1 (goal cont)</div><div class="line">  &quot;Try to prove goal by calling it.&quot;</div><div class="line">  (deref goal)</div><div class="line">  (apply (make-predicate (first goal)</div><div class="line">          (length (args goal)))</div><div class="line">      (append (args goal) (list cont))))</div></div><!-- fragment --><p>Эта версия <code>call</code> выдаст ошибку времени выполнения, если цель не инстанцируется для списка, первый элемент которого является правильно определенным предикатом; можно проверить это и молча потерпеть неудачу, если нет определенного предиката. Вот пример call, в котором цель законна:</p>
<div class="fragment"><div class="line">&gt; (?- (= ?p member) (call (?p ?x (a b c))))</div><div class="line">?P = MEMBER</div><div class="line">?X = A;</div><div class="line">?P = MEMBER</div><div class="line">?X = B;</div><div class="line">?P = MEMBER</div><div class="line">?X = C;</div><div class="line">No.</div></div><!-- fragment --><p>Теперь, когда у нас есть <code>call</code>, можно реализовать много нового. Вот логические связки and и or:</p>
<div class="fragment"><div class="line">(&lt;- (or ?a ?b) (call ?a))</div><div class="line">(&lt;- (or ?a ?b) (call ?b))</div><div class="line">(&lt;- (and ?a ?b) (call ?a) (call ?b))</div></div><!-- fragment --><p>Обратите внимание, что это только бинарные связки, а не <em>n</em>-арные специальные формы, используемые в Лиспе. Кроме того, это определение сводит на нет большую часть преимуществ компиляции. Цели внутри and или or будут интерпретироваться с помощью <code>call</code>, а не компилироваться.</p>
<p>Мы также можем определить <code>not</code> или, по крайней мере, нормальный Пролог <code>not</code>, который сильно отличается от логического <code>not</code>. Фактически, в некоторых диалектах <code>not</code> пишется +, что предполагается как &amp;#x22AC;, то есть "не может быть производным". Интерпретация состоит в том, что если цель G не может быть доказана, то (<code>not G</code>) истинно. Логически существует разница между истинным и неизвестным (<code>not G</code>), но игнорирование этой разницы делает Prolog более практичным языком программирования. См. <a href="B9780080571157500285.xhtml#bb0745">Lloyd 1987</a> для получения дополнительной информации о формальной семантике отрицания в Прологе.</p>
<p>Вот реализация <code>not/1</code>. Поскольку он должен управлять trail, и у нас могут быть другие предикаты, которые захотят сделать то же самое, мы упакуем то, что было сделано в <code>might-add-undo-bindings</code> в макрос <code>with-undo-bindings:</code></p>
<div class="fragment"><div class="line">(defmacro with-undo-bindings (&amp;body body)</div><div class="line">  &quot;Undo bindings after each expression in body except the last.&quot;</div><div class="line">  (if (length=1 body)</div><div class="line">    (first body)</div><div class="line">    &#39;(let ((old-trail (fill-pointer *trail*)))</div><div class="line">      ,(first body)</div><div class="line">        ,@(loop for exp in (rest body)</div></div><!-- fragment --><p>` collect '(undo-bindings! old-trail)`</p>
<div class="fragment"><div class="line">                collect exp))))</div><div class="line">(defun not/1 (relation cont)</div></div><!-- fragment --><p><code>"Отрицание неудачей: Если вы не можете доказать, что G.
тогда (not G) верно"</code>.</p>
<div class="fragment"><div class="line">;; Either way, undo the bindings.</div><div class="line">(with-undo-bindings</div><div class="line">  (call/1 relation #&#39;(lambda () (return-from not/1 nil)))</div><div class="line">  (funcall cont)))</div></div><!-- fragment --><p>Вот пример, когда <code>not</code> работает нормально:</p>
<div class="fragment"><div class="line">&gt; (?- (member ?x (a b c)) (not (= ?x b)))</div><div class="line">?X = A;</div><div class="line">?X = C;</div><div class="line">No.</div></div><!-- fragment --><p>Теперь посмотрим, что произойдет, если мы просто изменим порядок двух целей:</p>
<div class="fragment"><div class="line">&gt; (?- (not (= ?x b)) (member ?x (a b c)))</div><div class="line">No.</div></div><!-- fragment --><p>Первый пример завершается успешно, если только <code>?x</code> не привязан к <code>b</code>. Во втором примере <code>?x</code> не cвязан в начале, поэтому <code>(= ?x b )</code> завершается успешно, not терпит неудачу и <code>member</code> цель никогда не достигается. Таким образом, наша реализация <code>not</code> имеет последовательную процедурную интерпретацию, но она не эквивалентна декларативной интерпретации, обычно применяемой для логического отрицания. Обычно можно было бы ожидать, что <code>a</code> и <code>c</code> будут допустимыми решениями запроса, независимо от порядка целей.</p>
<p>Одно из фундаментальных различий между Prolog и Lisp заключается в том, что Prolog является реляционным: вы можете легко выражать индивидуальные отношения. Lisp, с другой стороны, хорошо выражает коллекции вещей в виде списков. Пока у нас нет способа сформировать коллекцию объектов, удовлетворяющих отношению в Прологе. Мы можем легко перебирать объекты; мы просто не можем собрать их вместе. Примитивный <code>bagof</code> - это один из способов сбора данных. В общем, <code>(bagof ?x (p ?x) ?bag)</code> объединяет <code>?bag</code> со списком всех <code>?x</code>-ов, которые удовлетворяют <code>(p ?x)</code>. Если таких <code>?x</code>-ов нет, то вызов <code>bagof</code> не выполняется. A <em>bag</em> - это неупорядоченная коллекция, в которой разрешены дубликаты. Например, <em>bag</em> {<em>a</em>, <em>b, a</em>} такая же, как <em>bag</em> {<em>a</em>, <em>a</em>, <em>b</em>}, но отличается от {<em>a</em>, <em>b</em>}. Bags контрастируют с <em>sets</em>, которые представляют собой неупорядоченные коллекции без дубликатов. Набор(set) {<em>a</em>, <em>b</em>} такой же, как набор(set) {<em>a</em>, <em>b</em>}. Вот реализация <code>bagof:</code></p>
<div class="fragment"><div class="line">(defun bagof/3 (exp goal resuit cont)</div><div class="line">  &quot;Find all solutions to GOAL, and for each solution,</div><div class="line">  collect the value of EXP into the list RESULT.&quot;</div></div><!-- fragment --><p><code>;; Ex: Assume (p 1) (p 2) (p 3). Then:</code></p>
<div class="fragment"><div class="line">;: (bagof ?x (p ?x) ?1) =&gt; ?1 = (1 2 3)</div><div class="line">(let ((answers nil))</div><div class="line">(call/1 goal #&#39;(lambda ()</div><div class="line">    (push (deref-copy exp) answers)))</div><div class="line">(if (and (not (null answers))</div></div><!-- fragment --><p><code>(unify! resuit (nreverse answers)))</code></p>
<div class="fragment"><div class="line">(funcall cont))))</div><div class="line">(defun deref-copy (exp)</div><div class="line">&quot;Copy the expression, replacing variables with new ones.</div><div class="line">The part without variables can be returned as is.&quot;</div><div class="line">(sublis (mapcar #&#39;(lambda (var) (cons (deref var) (?))</div><div class="line">  (unique-find-anywhere-if #&#39;var-p exp))</div><div class="line">exp))</div></div><!-- fragment --><p>Ниже мы используем <code>bagof</code>, чтобы собрать список всех, кого любит Сэнди(Sandy likes). Обратите внимание, что в результате получается bag, а не set: Сэнди появляется несколько раз.</p>
<div class="fragment"><div class="line">&gt; (?- (bagof ?who (likes Sandy ?who) ?bag))</div><div class="line">?WHO = SANDY</div><div class="line">?BAG = (LEE KIM ROBIN SANDY CATS SANDY);</div><div class="line">No.</div></div><!-- fragment --><p>В следующем примере мы формируем bag из каждого списка длиной три, в котором в качестве членов входят <code>A</code> и <code>B</code>:</p>
<div class="fragment"><div class="line">&gt; (?- (bagof ?l (and (length ?l (1  + (1  + (1  + 0))))</div><div class="line">      (and (member a ?l) (member b ?l)))</div><div class="line">    ?bag))</div><div class="line">?L = (?5 ?8 ?11 ?68 ?66)</div><div class="line">?BAG = ((A B ?17) (A ?21 B) (B A ?31) (?38 A B) (B ?48 A) (?52 B A))</div><div class="line">No.</div></div><!-- fragment --><p>Те, кто разочарован bag, содержащим несколько версий одного и того же ответа, могут предпочесть примитивный <code>setof</code>, который выполняет те же вычисления, что и <code>bagof</code>, но затем отбрасывает дубликаты.</p>
<div class="fragment"><div class="line">(defun setof/3 (exp goal resuit cont)</div><div class="line">  &quot;Find all unique solutions to GOAL, and for each solution,</div><div class="line">  collect the value of EXP into the list RESULT.&quot;</div></div><!-- fragment --><p><code>;; Ex: Assume (p 1) (p 2) (p 3). Then:</code></p>
<div class="fragment"><div class="line">;;  (setof ?x (p ?x) ?l ) =&gt; ?l = (1 2 3)</div><div class="line">(let ((answers nil))</div><div class="line">(call/1 goal #&#39;(lambda ()</div><div class="line">    (push (deref-copy exp) answers)))</div><div class="line">(if (and (not (null answers))</div></div><!-- fragment --><p><code>(unify! resuit (delete-duplicates</code></p>
<div class="fragment"><div class="line">      answers</div><div class="line">      :test #&#39;deref-equal)))</div><div class="line">(funcall cont))))</div></div><!-- fragment --><p>Пролог поддерживает арифметические операции с оператором <code>is</code>. Например, <code>(is ?x (+ ?y 1))</code> объединяет/унифицирует <code>?x</code> со значением <code>?y</code> плюс один. Это выражение не работает, если <code>?y</code> не привязано, и выдает ошибку времени выполнения, если <code>?y</code> не является числом. В нашей версии Пролога мы можем поддерживать не только арифметику, но и любое выражение Лиспа:</p>
<div class="fragment"><div class="line">(defun is/2 (var exp cont)</div><div class="line">  ;; Example: (is ?x (+  3 (* ?y (+ ?z 4))))</div><div class="line">  ;; Or even: (is (?x ?y ?x) (cons (first ?z) ?l))</div><div class="line">  (if (and (not (find-if-anywhere #&#39;unbound-var-p exp))</div></div><!-- fragment --><p><code>(unify! var (eval (deref-exp exp))))</code></p>
<div class="fragment"><div class="line">  (funcall cont)))</div><div class="line">(defun unbound-var-p (exp)</div><div class="line">  &quot;Is EXP an unbound var?&quot;</div><div class="line">  (and (var-p exp) (not (bound-p exp))))</div></div><!-- fragment --><p>Кроме того, мы могли бы также предоставить программисту Prolog доступ к функции <code>unbound-var-p</code>. Стандартное имя этого предиката - <code>var/1</code>:</p>
<div class="fragment"><div class="line">(defun var/1 (?arg1 cont)</div><div class="line">  &quot;Succeeds if ?arg1 is an uninstantiated variable.&quot;</div><div class="line">  (if (unbound-var-p ?arg1)</div><div class="line">  (funcall cont)))</div></div><!-- fragment --><p>Это примитив не работает, если какая-либо часть второго аргумента не связана. Однако есть выражения с переменными, которые можно решить, хотя и не прямым вызовом <code>eval</code>. Например, следующая цель может быть решена путем привязки <code>?x</code> к <code>2</code>:</p>
<div class="fragment"><div class="line">(solve (=  12 (* (+ ?x 1) 4)))</div></div><!-- fragment --><p>Мы могли бы захотеть иметь более прямой доступ к Лиспу из Пролога. Проблема с <code>is</code> в том, что он требует проверки на наличие несвязанных переменных и вызывает <code>eval</code> для рекурсивного вычисления аргументов. В некоторых случаях мы просто хотим добраться до Лисп <code>apply</code>, не прибегая к страховочной сетке, предоставляемой <code>is</code>. Это делает примитив <code>lisp</code>. Излишне говорить, что <code>lisp</code> не является частью стандартного Пролога.</p>
<div class="fragment"><div class="line">(defun lisp/2 (?result exp cont)</div><div class="line">  &quot;Apply (first exp) to (rest exp), and return the result.&quot;</div><div class="line">  (if (and (consp (deref exp))</div></div><!-- fragment --><p><code>(unify! ?result (apply (first exp) (rest exp))))</code></p>
<div class="fragment"><div class="line">(funcall cont)))</div></div><!-- fragment --><p><b>Упражнение 12.7 [m]</b> Определите примитив <code>solve/1</code>, который работает аналогично функции <code>solve</code>, используемой в student (<a href="B9780080571157500078.xhtml#p225">страница 225</a>). Решите, следует использовать в качестве аргумента одно уравнение или список уравнений.</p>
<p><b>Упражнение 12.8 [h]</b> Предположим, у нас есть цель вида <code>(solve (= 12 (* (+ ?x 1) 4)))</code>. Вместо того, чтобы манипулировать уравнением, когда во время выполнения вызывается <code>solve/1</code>, мы могли бы предпочесть выполнять часть работы во время компиляции, обрабатывая вызов, как если бы он был <code>(solve (= ?x 2))</code>. Напишите макрос компилятора Пролога для <code>solve</code>. Обратите внимание, что даже если вы определили макрос компилятора, вам все равно понадобится базовый примитив, потому что предикат может быть вызван через <code>call/1</code>. То же самое происходит в Лиспе: даже когда вы предоставляете макрос компилятора, вам все равно нужна фактическая функция в случае <code>funcall</code> или <code>apply</code>.</p>
<p><b>Упражнение 12.9 [h]</b> Для какого из предикатов <code>call</code>, <code>and</code>, <code>or</code>, <code>not</code> или<code>repeat</code> можно использовать макросы компилятора? Напишите макросы компилятора для тех предикатов, которые могут его использовать.</p>
<p><b>Упражнение 12.10 [m]</b> Вы могли заметить, что <code>call/1</code> неэффективен по двум важным причинам. Сначала он вызывает <code>make-predicate</code>, который должен построить символ, добавляя строки, а затем искать строку в таблице символов Lisp. Измените <code>make-predicate</code> для сохранения символа предиката при его первом создании, чтобы он мог быстрее выполнять поиск при последующих вызовах. Вторая неэффективность - это вызов append. Измените весь компилятор так, чтобы аргумент продолжение шел первым, а не последним, что устраняет необходимость применения <code>append</code> в <code>call</code>.</p>
<p><b>Упражнение 12.11 [s]</b> Примитив <code>true/0</code> всегда выполняется успешно, а <code>fail/0</code> всегда терпит неудачу. Определите эти примитивы. Подсказка: первая соответствует функции Common Lisp, а вторая - функции, уже определенной в этой главе.</p>
<p><b>Упражнение 12.12 [s]</b> Можно ли написать <code>= =/2</code> как список предложений, а не как примитив?</p>
<p><b>Упражнение 12.13 [m]</b> Напишите версию <code>deref-copy</code>, которая обходит выражение аргумента только один раз.</p>
<h2>12.9 Cut(Обрезка)</h2>
<p>В Лиспе можно писать программы с явным откатом(backtrack), хотя это может быть неудобно, если имеется более одной или двух точек возврата. В Прологе откат является автоматическим и неявным, но мы пока не знаем никакого способа <em>избежать</em> его. Существует две причины, по которым программист на Prolog может захотеть отключить откат. Во-первых, отслеживание точек отката требует времени и места. Программист, который знает, что у определенной проблемы есть только одно решение, должен иметь возможность ускорить вычисления, сказав программе не рассматривать другие возможные ответвления. Во-вторых, иногда простая логическая спецификация проблемы приводит к избыточным решениям или даже к некоторым непредвиденным решениям. Может случиться так, что простое сокращение пространства поиска, чтобы исключить некоторые отслеживания откатов, даст только желаемые ответы, в то время как реструктуризация программы, чтобы давать все и только правильные ответы, будет сложнее. Вот пример. Предположим, мы хотим определить предикат <code>max/3</code>, который выполняется, когда третий аргумент является максимумом из первых двух аргументов, где первые два аргумента всегда будут преобразованы в числа. Прямое определение:</p>
<div class="fragment"><div class="line">(&lt;- (max ?x ?y ?x) (&gt;= ?x ?y))</div><div class="line">(&lt;- (max ?x ?y ?y) (&lt; ?x ?y))</div></div><!-- fragment --><p>Декларативно оно правильно, но с процедурной точки зрения вычисление отношения &lt; является пустой тратой времени, если &gt;= успешно: в этом случае &lt; не может быть успешным. Символ сокращения/обрезки, записываемый !, Можно использовать, чтобы остановить бесполезные вычисления. Мы могли бы написать:</p>
<div class="fragment"><div class="line">(&lt;- (max ?x ?y ?x) (&gt;= ?x ?y) !)</div><div class="line">(&lt;- (max ?x ?y ?y))</div></div><!-- fragment --><p>Обрезка в первом предложении говорит о том, что если первое предложение будет успешным, то никакие другие предложения не будут рассматриваться. Так что теперь второй пункт нельзя толковать самостоятельно. Скорее, он интерпретируется как "если первое предложение не выполняется, то второе из двух чисел является максимальным".</p>
<p>Как правило, сокращение/обрезка может происходить в любом месте предложения, а не только в конце. Хорошей декларативной интерпретации обрезки не существует, но процедурная интерпретация двояка. Во-первых, когда обрезка "выполняется" как цель, она всегда успешна. Но в дополнение к успеху она устанавливает барьер, который нельзя преодолеть последующим откатом. Обрезка служит для отключения отката как от целей справа от обрезки (в том же предложении), так и от предложений ниже обрезки (в том же предикате). Давайте посмотрим на более абстрактный пример:</p>
<div class="fragment"><div class="line">(&lt;- (p) (q) (r) ! (s) (t))</div><div class="line">(&lt;- (p) (s))</div></div><!-- fragment --><p>При обработке первого предложения <code>p</code> откат может происходить свободно при попытке решить <code>q</code> и <code>r</code>. Как только <code>r</code> решен, встречается обрезка. С этого момента откат может происходить свободно при решении <code>s</code> и<code>t</code>, но Prolog никогда не будет откатываться за обрез в <code>r</code>, и второе предложение не будет рассматриваться. С другой стороны, если <code>q</code> или <code>r</code> завершились неудачно (до того, как произойдет обрезка), тогда Пролог перейдет ко второму предложению.</p>
<p>Теперь, когда цель сокращения ясна, давайте подумаем, как его следует реализовать. Мы рассмотрим немного более сложный предикат с переменными и несколькими разрезами:</p>
<div class="fragment"><div class="line">(&lt;- (p ?x a) ! (q ?x))</div><div class="line">(&lt;- (p ?x b) (r ?x) ! (s ?x))</div></div><!-- fragment --><p>Мы должны организовать это так, чтобы, как только мы возвращаемся к сокращению, цели больше не учитывались. В первом предложении, когда <code>q / 1</code> не работает, мы хотим немедленно вернуться из<code>p / 2</code>, а не рассматривать второе предложение. Точно так же в первый раз, когда «s / 1» терпит неудачу, мы хотим вернуться из «p / 2», вместо того, чтобы рассматривать другие решения для «r / 1». Таким образом, нам нужен код, который выглядит примерно так:</p>
<div class="fragment"><div class="line">(defun p/2 (argl arg2 cont)</div><div class="line">  (let ((old-trail (fill-pointer *trail*)))</div></div><!-- fragment --><p><code>(if (unify! arg2 'a)</code></p>
<div class="fragment"><div class="line">(progn (q/1 argl cont)</div><div class="line">    (return-from p/2 nil)))</div></div><!-- fragment --><p><code>(undo-bindings! old-trail)</code></p>
<p><code>(if (unify! arg2 'b)</code></p>
<div class="fragment"><div class="line">(r/1 argl #&#39;(lambda ()</div><div class="line">        (progn (s/1 argl cont)</div><div class="line">          (return-from p/2 nil)))))))</div></div><!-- fragment --><p>Мы можем получить этот код, сделав одно изменение в <code>compile-body:</code> когда первая цель в теле (или то, что осталось от тела) является отрезанным символом, тогда мы должны сгенерировать <code>progn</code>, содержащий код для остальной части тела, за которой следует <code>return-from</code> компилируемого предиката. К сожалению, имя предиката недоступно для <code>compile-body</code>. Мы могли бы изменить <code>compile-clause</code> и <code>compile-body</code>, чтобы использовать имя предиката в качестве дополнительного аргумента, или мы могли бы привязать предикат как специальную переменную в <code>compile-predicate</code>. Я выбираю последнее:</p>
<div class="fragment"><div class="line">(defvar *predicate* nil</div><div class="line">  &quot;The Prolog predicate currently being compiled&quot;)</div><div class="line"></div><div class="line">(defun compile-predicate (symbol arity clauses)</div><div class="line">  &quot;Compile all the clauses for a given symbol/arity</div><div class="line">  into a single LISP function.&quot;</div><div class="line">  (let ((*predicate* (make-predicate symbol arity))    ;***</div><div class="line">        (parameters (make-parameters arity)))</div><div class="line">    (compile</div><div class="line">     (eval</div><div class="line">      `(defun ,*predicate* (,@parameters cont)</div><div class="line">  .,(maybe-add-undo-bindings</div><div class="line">     (mapcar #&#39;(lambda (clause)</div><div class="line">           (compile-clause parameters clause &#39;cont))</div><div class="line">      clauses)))))))</div><div class="line"></div><div class="line">(defun compile-body (body cont bindings)</div><div class="line">  &quot;Compile the body of a clause.&quot;</div><div class="line">  (cond</div><div class="line">    ((null body)</div><div class="line">     `(funcall ,cont))</div><div class="line">    ((eq (first body) &#39;!)                              ;***</div><div class="line">     `(progn ,(compile-body (rest body) cont bindings) ;***</div><div class="line">             (return-from ,*predicate* nil)))          ;***</div><div class="line">    (t (let* ((goal (first body))</div><div class="line">              (macro (prolog-compiler-macro (predicate goal)))</div><div class="line">              (macro-val (if macro</div><div class="line">                             (funcall macro goal (rest body)</div><div class="line">                                      cont bindings))))</div><div class="line">        (if (and macro (not (eq macro-val :pass)))</div><div class="line">            macro-val</div><div class="line">            `(,(make-predicate (predicate goal)</div><div class="line">                               (relation-arity goal))</div><div class="line">              ,@(mapcar #&#39;(lambda (arg)</div><div class="line">                            (compile-arg arg bindings))</div><div class="line">                        (args goal))</div><div class="line">              ,(if (null (rest body))</div><div class="line">                   cont</div><div class="line">                   `#&#39;(lambda ()</div><div class="line">                        ,(compile-body</div><div class="line">                           (rest body) cont</div><div class="line">                           (bind-new-variables bindings goal))))))))))</div></div><!-- fragment --><p><b>Упражнение 12.14 [m]</b> Учитывая приведенные ниже определения, выясните, что будет делать вызов <code>test-cut</code> и что он будет писать:</p>
<div class="fragment"><div class="line">(&lt;- (test-cut) (p a) (p b) ! (p c) (p d))</div><div class="line">(&lt;- (test-cut) (p e))</div><div class="line">(&lt;- (p ?x) (write (?x 1)))</div><div class="line">(&lt;- (p ?x) (write (?x 2)))</div></div><!-- fragment --><p>Другой способ использовать обрезку - это цикл <em>repeat/fail</em>(повтор/сбой). Повторение предиката определяет следующие два предложения:</p>
<div class="fragment"><div class="line">(&lt;- (repeat))</div><div class="line">(&lt;- (repeat) (repeat))</div></div><!-- fragment --><p>Альтернативное определение примитива:</p>
<div class="fragment"><div class="line">(defun repeat/0 (cont)</div><div class="line">  (loop (funcall cont)))</div></div><!-- fragment --><p>К сожалению, <code>repeat</code> - один из предикатов, которым злоупотребляют. В нескольких книгах по Прологу представлены такие программы:</p>
<div class="fragment"><div class="line">(&lt;- (main)</div><div class="line">  (write &quot;Hello.&quot;)</div><div class="line">  (repeat)</div><div class="line">  (write &quot;Command: &quot;)</div><div class="line">  (read ?command)</div><div class="line">  (process ?command)</div><div class="line">  (= ?command exit)</div><div class="line">  (write &quot;Good bye.&quot;))</div></div><!-- fragment --><p>Смысл состоит в том, что команды читаются по одной, а затем обрабатываются. Для каждой команды, кроме <code>exit</code>, процесс выполняет соответствующее действие и затем терпит неудачу. Это вызывает откат к цели repeat(повторения), и новая команда считывается и обрабатывается. Когда команда <code>exit</code>, процедура возвращается.</p>
<p>Есть две причины, почему это плохая программа. Во-первых, это нарушает принцип ссылочной прозрачности. Вещи, которые выглядят одинаково, должны быть одинаковыми, независимо от контекста, в котором они используются. Но здесь невозможно сказать, что четыре из шести целей в теле составляют цикл, а другие цели находятся вне цикла. Во-вторых, это нарушает принцип абстракции. Предикат должен быть понятен как отдельная единица. Но здесь процесс предиката можно понять только при рассмотрении контекста, в котором он вызывается: контекста, который требует его сбоя после обработки каждой команды. Как указывает <a href="B9780080571157500285.xhtml#bb0925">Ричард О'Киф 1990</a>, правильный способ написания этого предложения выглядит следующим образом:</p>
<div class="fragment"><div class="line">(&lt;- (main)</div><div class="line">  (write &quot;Hello.&quot;)</div><div class="line">  (repeat)</div><div class="line">      (write &quot;Command: &quot;)</div><div class="line">      (read ?command)</div><div class="line">      (process ?command)</div><div class="line">      (or (= ?command exit) (fail))</div><div class="line">  !</div><div class="line">  (write &quot;Good bye.&quot;))</div></div><!-- fragment --><p>Отступ четко указывает на пределы повторения цикла. Цикл завершается явным тестом, за которым следует отрезка, чтобы вызывающая программа не могла случайно вернуться(откатиться) в цикл после выхода. Лично я предпочитаю такой язык, как Lisp, где круглые скобки делают такие конструкции, как циклы, явными, а отступы могут выполняться автоматически. Но О'Киф показывает, что хорошо структурированные читаемые программы можно писать и на Прологе.</p>
<p>Конструкции if-then и if-then-else можно легко записать в виде предложений. Обратите внимание, что if-then-else использует обрезку для фиксации части <code>then</code>, если тест удовлетворен.</p>
<div class="fragment"><div class="line">(&lt;- (if ?test ?then) (if ?then ?else (fail)))</div><div class="line">(&lt;- (if ?test ?then ?else)</div><div class="line">  (call ?test)</div><div class="line">  !</div><div class="line">  (call ?then))</div><div class="line">(&lt;- (if ?test ?then ?else)</div><div class="line">  (call ?else))</div></div><!-- fragment --><p>Обрезка может использоваться для реализации нелогического <code>не</code>. Следующие два предложения часто приводятся перед определением <code>not</code>. Наш компилятор успешно превращает эти два предложения в точно такой же код, который был приведен ранее для примитива <code>not/1</code>:</p>
<div class="fragment"><div class="line">(&lt;- (not ?p) (call ?p) ! (fail))</div><div class="line">(&lt;- (not ?p))</div></div><!-- fragment --><h2>12.10 "Настоящий" Пролог</h2>
<p>Система Prolog-In-Lisp, разработанная в этой главе, использует синтаксис Lisp, потому что она предназначена для встраивания в систему Lisp. Другие реализации Пролога, использующие синтаксис Лиспа, включают микро-Пролог, Символический Пролог и Пролог LMI.</p>
<p>Однако большинство систем Пролога используют синтаксис, близкий к традиционным математическим обозначениям. В следующей таблице сравнивается синтаксис "стандартного" Пролога с синтаксисом Пролога-в-Лиспе. Хотя в настоящее время над стандартизацией Пролога работает международный комитет, окончательный отчет еще не выпущен, поэтому разные диалекты могут иметь немного отличающийся синтаксис. Тем не менее, в большинстве реализаций используются обозначения, приведенные здесь. Они являются производными от Пролога, разработанного в Эдинбургском университете для DEC-10 Дэвидом Х. Д. Уоррен и его коллеги. Имена примитивов в последнем разделе также взяты из Эдинбургского Пролога.</p>
<table class="doxtable">
<tr>
<th></th><th>Prolog </th><th>Prolog-In-Lisp  </th></tr>
<tr>
<td>atom </td><td><code>lower</code> </td><td><code>const</code> </td></tr>
<tr>
<td>variable </td><td><code>Upper</code> </td><td><code>?var</code> </td></tr>
<tr>
<td>anonymous </td><td><code>-</code> </td><td><code>?</code> </td></tr>
<tr>
<td>goal </td><td><code>p(Var,const)</code> </td><td><code>(p ?var const)</code> </td></tr>
<tr>
<td>rule </td><td><code>p(X) :- q(X).</code> </td><td><code>(&lt;- (p ?x) (q ?x))</code> </td></tr>
<tr>
<td>fact </td><td><code>p(a).</code> </td><td><code>(&lt;- (p a))</code> </td></tr>
<tr>
<td>query </td><td><code>?- p(X).</code> </td><td><code>(?- (p ?x))</code> </td></tr>
<tr>
<td>list </td><td><code>[a,b,c]</code> </td><td><code>(a b c)</code> </td></tr>
</table>
<p>| cons | <code>[a| Rest]</code> | <code>(a . ?rest)</code> | | nil | <code>[]</code> | <code>()</code> | | and | <code>p(X). q(X)</code> | <code>(and (p ?x) (q ?x)&gt;</code> | | or | <code>P(X): q(X)</code> | <code>(or (p ?x) (q ?x))</code> | | not | <code>\+ p(X)</code> | <code>(not (p ?x))</code> |</p>
<p>Мы переняли склонность Лиспа к спискам; термины состоят из атомов, переменных и заключений других терминов. В реальном Prolog есть cons-ячейки, но термины обычно строятся из <em>структур</em>, а не списков. Термин Пролога <code>p(a, b)</code> соответствует вектору Лиспа <code>#(p/2 a b)</code>, а не списку <code>(p a b)</code>. Меньшая часть реализаций Prolog использует <em>совместное использование структур.</em> В этом подходе каждый неатомарный термин представлен каркасом, который содержит заполнители для переменных и заголовок, который указывает на каркас, а также содержит переменные, которые будут заполнять заполнители . С разделяемой структуры просто сделать копию: просто скопируйте заголовок, независимо от размера скелета. Однако манипулирование терминами осложняется необходимостью отслеживать как скелет, так и заголовок. См. <a href="B9780080571157500285.xhtml#bb0110">Boyer and Moore 1972</a> для получения дополнительной информации о совместном использовании структуры.</p>
<p>Еще одно важное отличие состоит в том, что настоящий Пролог использует эквивалент продолжений неудач, а не продолжений успехов. Никакого фактического продолжения в смысле замыкания не создается. Вместо этого, когда выбор сделан, адрес кода для следующего выбора помещается в стек. В случае неудачи из стека выскакивает следующий вариант. Это напоминает подход с откатом с использованием возможности Scheme <code>call/cc</code>, описанный на <a href="B9780080571157500224.xhtml#p772">стр. 772</a>.</p>
<p><b>Упражнение 12.15 [m]</b> Предполагая подход, использующий стек продолжений неудач вместо продолжений успехов, покажите, как будет выглядеть код для <code>p</code> и <code>member</code>. Обратите внимание, что вам не нужно передавать продолжения сбоя; вы можете просто поместить их в стек, который вызовет <code>top-level-prove</code>. Как будет реализовано сокращение? Правильно ли мы сделали выбор, реализовав наш компилятор с продолжениями успехов, или было бы лучше продолжать неудачи?</p>
<h2>12.11 История и ссылки</h2>
<p>As described in <a href="B978008057115750011X.xhtml">chapter 11</a>, the idea of logic programming was fairly well understood by the mid-1970s. But because the implementations of that time were slow, logic programming did not catch on. It was the Prolog compiler for the DEC-10 that made logic programming a serious alternative to Lisp and other general-purpose languages. The compiler was developed in 1977 by David H. D. Warren with Fernando Pereira and Luis Pereira. See the paper by <a href="B9780080571157500285.xhtml#bb1325">Warren (1979)</a> and by all three (1977).</p>
<p>Unfortunately, David H. D. Warren's pioneering work on compiling Prolog has never been published in a widely accessible form. His main contribution was the description of the Warren Abstract Machine (WAM), an instruction set for compiled Prolog. Most existing compilers use this instruction set, or a slight modification of it. This can be done either through byte-code interpretation or through macroexpansion to native machine instructions. <a href="B9780080571157500285.xhtml#bb0020">A&iuml;t-Kaci 1991</a> provides a good tutorial on the WAM, much less terse than the original (<a href="B9780080571157500285.xhtml#bb1330">Warren 1983</a>). The compiler presented in this chapter does not use the WAM. Instead, it is modeled after Mark <a href="B9780080571157500285.xhtml#bb1200">Stickel's (1988)</a> theorem prover. A similar compiler is briefly sketched by Jacques <a href="B9780080571157500285.xhtml#bb0225">Cohen 1985</a>.</p>
<h2>12.12 Упражнения</h2>
<p><b>Exercise 12.16 [m]</b> Change the Prolog compiler to allow implicit <code>calls</code>. That is, if a goal is not a cons cell headed by a predicate, compile it as if it were a <code>call</code>. The clause:</p>
<div class="fragment"><div class="line">(&lt;- (p ?x ?y) (?x c) ?y)</div></div><!-- fragment --><p>should be compiled as if it were:</p>
<div class="fragment"><div class="line">(&lt;- (p ?x ?y) (call (?x c)) (call ?y))</div></div><!-- fragment --><p><b>Exercise 12.17 [h]</b> Here are some standard Prolog primitives:</p>
<ul>
<li><code>get/1</code> Read a single character and unify it with the argument.</li>
<li><code>put/1</code> Print a single character.</li>
<li><code>nonvar/1, /=, /==</code> The opposites of <code>var, = and = =</code> , respectively.</li>
<li><code>integer/1</code> True if the argument is an integer.</li>
<li><code>atom/1</code> True if the argument is a symbol (like Lisp's <code>symbol p</code>).</li>
<li><code>atomic/1</code> True if the argument is a number or symbol (like Lisp's <code>atom</code>).</li>
<li>&lt;,&gt;,=&lt;,&gt;= Arithmetic comparison; succeeds when the arguments are both instantiated to numbers and the comparison is true.</li>
<li><code>listing/0</code> Print out the clauses for all defined predicates.</li>
<li><code>listing/1</code> Print out the clauses for the argument predicate.</li>
</ul>
<p>Implement these predicates. In each case, decide if the predicate should be implemented as a primitive or a list of clauses, and if it should have a compiler macro.</p>
<p>There are some naming conflicts that need to be resolved. Terms like <code>atom</code> have one meaning in Prolog and another in Lisp. Also, in Prolog the normal notation is \= and \==, not /= and /==. For Prolog-In-Lisp, you need to decide which notations to use: Prolog's or Lisp's.</p>
<p><b>Exercise 12.18 [s]</b> In Lisp, we are used to writing n-ary calls like <code>(&lt; 1 n 10 ) or (= x y z )</code>. Write compiler macros that expand n-ary calls into a series of binary calls. For example, <code>(&lt; 1 n 10)</code> should expand into <code>(and (&lt; 1 n) (&lt; n 10))</code>.</p>
<p><b>Exercise 12.19 [m]</b> One feature of Lisp that is absent in Prolog is the <code>quote</code> mechanism. Is there a use for <code>quote?</code> If so, implement it; if not, explain why it is not needed.</p>
<p><b>Exercise 12.20 [h]</b> Write a tracing mechanism for Prolog. Add procedures <code>p-trace</code> and <code>p-untrace</code> to trace and untrace Prolog predicates. Add code to the compiler to generate calls to a printing procedure for goals that are traced. In Lisp, we have to trace procedures when they are called and when they return. In Prolog, there are four cases to consider: the call, successful completion, backtrack into subsequent clauses, and failure with no more clauses. We will call these four <code>cases call</code>, <code>exit</code>, <code>redo,</code> and <code>fail</code>, respectively. If we traced <code>member,</code> we would expect tracing output to look something like this:</p>
<div class="fragment"><div class="line">&gt; (?- (member ?x (a b c d)) (fail))</div><div class="line">  CALL MEMBER: ?1 (A B C D)</div><div class="line">  EXIT MEMBER: A (A B C D)</div><div class="line">  REDO MEMBER: ?1 (A B C D)</div><div class="line">    CALL MEMBER: ?1 (B C D)</div><div class="line">    EXIT MEMBER: B (B C D)</div><div class="line">    REDO MEMBER: ?1 (B C D)</div><div class="line">      CALL MEMBER: ?1 (C D)</div><div class="line">      EXIT MEMBER: C (C D)</div><div class="line">      REDO MEMBER: ?1 (C D)</div><div class="line">        CALL MEMBER: ?1 (D)</div><div class="line">        EXIT MEMBER: D (D)</div><div class="line">        REDO MEMBER: ?1 (D)</div><div class="line">          CALL MEMBER: ?1 NIL</div><div class="line">          REDO MEMBER: ?1 NIL</div><div class="line">          FAIL MEMBER: ?1 NIL</div><div class="line">        FAIL MEMBER: ?1 (D)</div><div class="line">      FAIL MEMBER: ?1 (C D)</div><div class="line">    FAIL MEMBER: ?1 (B C D)</div><div class="line">  FAIL MEMBER: ?1 (A B C D)</div><div class="line">No.</div></div><!-- fragment --><p><b>Exercise 12.21 [m]</b> Some Lisp systems are very slow at compiling functions. <code>KCL</code> is an example; it compiles by translating to <code>C</code> and then calling the <code>C</code> compiler and assembler. In <code>KCL</code> it is best to compile only code that is completely debugged, and run interpreted while developing a program.</p>
<p>Alter the Prolog compiler so that calling the Lisp compiler is optional. In all cases, Prolog functions are translated into Lisp, but they are only compiled to machine language when a variable is set.</p>
<p><b>Exercise 12.22 [d]</b> Some Prolog systems provide the predicate <code>freeze</code> to "freeze" a goal until its variables are instantiated. For example, the goal <code>(freeze x (&gt; x 0))</code> is interpreted as follows: if <code>x</code> is instantiated, then just evaluate the goal <code>(&gt; x 0)</code>, and succeed or fail depending on the result. However, if <code>x</code> is unbound, then succeed and continue the computation, but remember the goal <code>(&gt; x 0)</code> and evaluate it as soon as <code>x</code> becomes instantiated. Implement freeze.</p>
<p><b>Exercise 12.23 [m]</b> Write a recursive version of <code>anonymous-variables-in</code> that does not use a local function.</p>
<h2>12.13 Ответы</h2>
<p><b>Answer 12.6</b> Here's a version that works for Texas Instruments and Lucid implementations:</p>
<div class="fragment"><div class="line">(defmacro with-compilation-unit (options &amp;body body)</div><div class="line">  &quot;Do the body, but delay compiler warnings until the end.&quot;</div><div class="line">  ;; This is defined in Common Lisp the Language, 2nd ed.</div><div class="line">  &#39;(,(read-time-case</div><div class="line">    #+TI &#39;compiler:compiler-warnings-context-bind</div><div class="line">    #+Lucid &#39;with-deferred-warnings</div><div class="line">        &#39;progn)</div><div class="line">    .,body))</div><div class="line"></div><div class="line">(defun prolog-compile-symbols (&amp;optional (symbols *uncompiled*))</div><div class="line">  &quot;Compile a list of Prolog symbols.</div><div class="line">  By default, the list is all symbols that need it.&quot;</div><div class="line">  (with-compilation-unit ()</div><div class="line">  (mapc #&#39;prolog-compile symbols)</div><div class="line">  (setf *uncompiled* (set-difference *uncompiled* symbols))))</div></div><!-- fragment --><p><b>Answer 12.9</b> Macros for <code>and</code> and <code>or</code> are very important, since these are commonly used. The macro for <code>and</code> is trivial:</p>
<div class="fragment"><div class="line">(def-prolog-compiler-macro and (goal body cont bindings)</div><div class="line">  (compile-body (append (args goal) body) cont bindings))</div></div><!-- fragment --><p>The macro for or is trickier:</p>
<div class="fragment"><div class="line">(def-prolog-compiler-macro or (goal body cont bindings)</div><div class="line">  (let ((disjuncts (args goal)))</div><div class="line">    (case (length disjuncts)</div><div class="line">      (0 fail)</div><div class="line">      (1 (compile-body (cons (first disjuncts) body) cont bindings))</div><div class="line">      (t (let ((fn (gensym &quot;F&quot;)))</div><div class="line">        &#39;(fl&amp;egrave;t ((,fn () ,(compile-body body cont bindings)))</div><div class="line">          .,(maybe-add-undo-bindings</div><div class="line">            (loop for g in disjuncts collect</div><div class="line">              (compile-body (list g) &#39;#&#39;,fn</div><div class="line">                bindings)))))))))</div></div><!-- fragment --><p><b>Answer 12.11</b><code>true/0</code> is <code>funcall</code> : when a goal succeeds, we call the continuation, <code>fail/0</code> is <code>ignore</code>: when a goal fails, we ignore the continuation. We could also define compiler macros for these primitives:</p>
<div class="fragment"><div class="line">(def-prolog-compiler-macro true (goal body cont bindings)</div><div class="line">  (compile-body body cont bindings))</div><div class="line"></div><div class="line">(def-prolog-compiler-macro fail (goal body cont bindings)</div><div class="line">  (declare (ignore goal body cont bindings))</div><div class="line">  nil)</div></div><!-- fragment --><p><b>Answer 12.13</b></p>
<div class="fragment"><div class="line">(defun deref-copy (exp)</div><div class="line">  &quot;Build a copy of the expression, which may have variables.</div><div class="line">  The part without variables can be returned as is.&quot;</div><div class="line">  (let ((var-alist nil ))</div><div class="line">    (labels</div><div class="line">      ((walk (exp)</div><div class="line">        (deref exp)</div><div class="line">        (cond ((consp exp)</div><div class="line">          (reuse-cons (walk (first exp))</div><div class="line">              (walk (rest exp))</div><div class="line">              exp))</div><div class="line">          ((var-p exp)</div><div class="line">          (let ((entry (assoc exp var-alist)))</div><div class="line">            (if (not (null entry))</div><div class="line">            (cdr entry)</div><div class="line">            (let ((var-copy (?)))</div><div class="line">                (push (cons exp var-copy) var-alist)</div><div class="line">                var-copy))))</div><div class="line">          (t exp))))</div><div class="line">    (walk exp))))</div></div><!-- fragment --><p><b>Answer 12.14</b> In the first clause of <code>test-cut</code>, all four calls to <code>p</code> will succeed via the first clause of <code>p</code>. Then backtracking will occur over the calls to <code>(p c)</code> and <code>(p d)</code>. All four combinations of <code>1</code> and <code>2</code> succeed. After that, backtracking would normally go back to the call to <code>(p b)</code>. But the cut prevents this, and the whole <code>(test-cut)</code> goal fails, without ever considering the second clause. Here's the actual output:</p>
<div class="fragment"><div class="line">(?- (test-cut))</div><div class="line">(A 1)(B 1)(C 1) (D 1)</div><div class="line">Yes;</div><div class="line">(D 2)</div><div class="line">Yes;</div><div class="line">(C 2)(D 1)</div><div class="line">Yes;</div><div class="line">(D 2)</div><div class="line">Yes;</div><div class="line">No.</div></div><!-- fragment --><p><b>Answer 12.17</b> For example:</p>
<div class="fragment"><div class="line">(defun &gt;/2 (x y cont)</div><div class="line">  (if (and (numberp (deref x)) (numberp (deref y)) (&gt; x y))</div><div class="line">    (funcall cont)))</div><div class="line">(defun numberp/1 (x cont)</div><div class="line">  (if (numberp (deref x))</div><div class="line">    (funcall cont)))</div></div><!-- fragment --><p><b>Answer 12.19</b> Lisp uses quote in two ways: to distinguish a symbol from the value of the variable represented by that symbol, and to distinguish a literal list from the value that would be returned by evaluating a function call. The first distinction Prolog makes by a lexical convention: variables begin with a question mark in our Prolog, and they are capitalized in real Prolog. The second distinction is not necessary because Prolog is relational rather than functional. An expression is a goal if it is a member of the body of a clause, and is a literal if it is an argument to a goal.</p>
<p><b>Answer 12.20</b> Hint: Here's how <code>member</code> could be augmented with calls to a procedure, <code>prolog-trace</code>, which will print information about the four kinds of tracing events:</p>
<div class="fragment"><div class="line">(defun member/2 (?arg1 ?arg2 cont)</div><div class="line">  (let ((old-trail (fill-pointer *tra1l*))</div><div class="line">      (exit-cont #&#39;(lambda ()</div><div class="line">          (prolog-trace &#39;exit &#39;member ?arg1 ?arg2 )</div><div class="line">          (funcall cont))))</div><div class="line">    (prolog-trace &#39;call &#39;member ?arg1 ?arg2)</div></div><!-- fragment --><p><code>(if (unify! ?arg2 (cons ?arg1 (?)))</code></p>
<div class="fragment"><div class="line">(funcall exit-cont))</div></div><!-- fragment --><p><code>(undo-bindings! old-trail)</code></p>
<div class="fragment"><div class="line">(prolog-trace &#39;redo &#39;member ?arg1 ?arg2)</div><div class="line">(let ((?rest (?)))</div></div><!-- fragment --><p><code>(if (unify! ?arg2 (cons (?) ?rest))</code></p>
<div class="fragment"><div class="line">  (member/2 ?arg1 ?rest exit-cont)))</div><div class="line">(prolog-trace &#39;fail &#39;member ?arg1 ?arg2)))</div></div><!-- fragment --><p>The definition of <code>prolog-trace</code> is:</p>
<div class="fragment"><div class="line">(defvar *prolog-trace-indent* 0)</div><div class="line">(defun prolog-trace (kind predicate &amp;rest args)</div><div class="line">  (if (member kind &#39;(call redo))</div><div class="line">  (incf *prolog-trace-indent* 3))</div><div class="line">  (format t &quot;~&amp;~VT~a ~  a:~{ ~  a  ~}&quot;</div><div class="line">      *prolog-trace-indent* kind predicate args)</div><div class="line">  (if (member kind &#39;(fail exit))</div><div class="line">  (decf *prolog-trace-indent* 3)))</div></div><!-- fragment --><p><b>Answer 12.23</b></p>
<div class="fragment"><div class="line">(defun anonymous-variables-in (tree)</div><div class="line">  &quot;Return a list of all variables that occur only once in tree.&quot;</div><div class="line">  (values (anon-vars-in tree nil nil)))</div><div class="line"></div><div class="line">(defun anon-vars-in (tree seen-once seen-more)</div><div class="line">  &quot;Walk the data structure TREE, returning a list of variables</div><div class="line">  seen once, and a list of variables seen more than once.&quot;</div><div class="line">  (cond</div><div class="line">    ((consp tree)</div><div class="line">    (multiple-value-bind (new-seen-once new-seen-more)</div><div class="line">      (anon-vars-in (first tree) seen-once seen-more)</div><div class="line">      (anon-vars-in (rest tree) new-seen-once new-seen-more)))</div><div class="line">    ((not (variable-p tree)) (values seen-once seen-more))</div><div class="line">    ((member tree seen-once)</div><div class="line">    (values (delete tree seen-once) (cons tree seen-more)))</div><div class="line">    ((member tree seen-more)</div><div class="line">    (values seen-once seen-more))</div><div class="line">    (t (values (cons tree seen-once) seen-more))))</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
