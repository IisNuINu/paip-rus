<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Chapter 6</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Chapter 6 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Построение Программных Средств</h2>
<blockquote class="doxtable">
<p><em>Человек - животное, использующее инструменты ... Без инструментов он - ничто, с инструментами он все.</em> </p>
</blockquote>
<blockquote class="doxtable">
<p>-Thomas Carlyle (1795-1881) </p>
</blockquote>
<p>В <a href="B9780080571157500042.xhtml">главах 4</a> и <a href="B9780080571157500054.xhtml">5</a> мы были заинтересованы в создании двух конкретных программ, GPS и ELIZA. В этой главе мы еще раз рассмотрим эти две программы, чтобы выявить некоторые общие закономерности(шаблоны). Эти закономерности(шаблоны) будут абстрагированы, чтобы сформировать программные инструменты для многократного использования, которые окажутся полезными в следующих главах.</p>
<h2>6.1 Интерактивный Инструмент Интерпретатора</h2>
<p>Структура функции <code>eliza</code> обычная. Она повторяется ниже:</p>
<div class="fragment"><div class="line">(defun eliza ()</div><div class="line">  &quot;Respond to user input using pattern matching rules.&quot;</div><div class="line">  (loop</div><div class="line">    (print &#39;eliza&gt;)</div><div class="line">    (print (flatten (use-eliza-rules (read))))))</div></div><!-- fragment --><p>Многие другие приложения используют этот шаблон, включая сам Лисп. Верхний уровень Lisp можно определить как:</p>
<div class="fragment"><div class="line">(defun lisp ()</div><div class="line">  (loop</div><div class="line">    (print &#39;&gt;)</div><div class="line">    (print (eval (read)))))</div></div><!-- fragment --><p>Верхний уровень системы Lisp исторически назывался "read-eval-print loop/циклом чтения-вычисления-печати(REPL)". Большинство современных Лиспов выводят приглашение перед чтением ввода, поэтому его на самом деле следует называть "цикл подсказка-чтение-вычисление-печать", но в некоторых ранних системах, таких как MacLisp, приглашения не было, поэтому более короткое имя прижилось. Если бы мы не указали приглашение, мы могли бы написать полный интерпретатор Лиспа, используя всего четыре символа:</p>
<div class="fragment"><div class="line">(loop (print (eval (read))))</div></div><!-- fragment --><p>Может показаться шуткой утверждение, что эти четыре символа и восемь круглых скобок составляют интерпретатор Лиспа. Когда мы напишем эту строку, действительно ли мы чего-нибудь достигнем? Один из ответов на этот вопрос - подумать о том, что нам нужно сделать, чтобы написать интерпретатор Лиспа (или Паскаля) на Паскале. Нам понадобится лексический анализатор и менеджер таблиц символов. Это значительный объем работы, но все это выполняется с помощью <code>read</code>. Нам понадобится синтаксический анализатор для сборки лексических токенов в операторы. <code>read</code> также обрабатывает это, но только потому, что операторы Lisp имеют тривиальный синтаксис: синтаксис списков и атомов. Таким образом, <code>read</code> отлично работает как синтаксический анализатор для Лиспа, но не работает для Паскаля. Затем нам понадобится часть интерпретатора, которая занимается оценкой(eval)/вычислением или интерпретацией; <code>eval</code> делает это прекрасно, и с таким же успехом может обрабатывать выражения Паскаля, если мы разберем синтаксис Паскаля в выражениях Лиспа, <code>print</code> выполняет гораздо меньше работы, чем <code>read</code> или <code>eval</code>, но все же довольно удобна.</p>
<p>Важный момент не в том, можно ли считать одну строчку кода реализацией Лиспа, а в выявлении общих схем вычислений. И <code>eliza</code>, и <code>lisp</code> можно рассматривать как интерактивные интерпретаторы, которые читают некоторый ввод, преобразуют или вычисляют ввод каким-либо образом, распечатывают результат и затем возвращаются за дополнительным вводом. Мы можем выделить следующий общий шаблон:</p>
<div class="fragment"><div class="line">(defun *program* ()</div><div class="line">  (loop</div><div class="line">    (print *prompt*)</div><div class="line">    (print (*transform* (read)))))</div></div><!-- fragment --><p>Есть два способа использовать повторяющиеся шаблоны, подобные этому: формально и неформально. Неформальная альтернатива - рассматривать шаблон как клише или идиому, которые будут часто встречаться при написании программ, но будут варьироваться от одного использования к другому. Когда мы захотим написать новую программу, мы вспоминаем, как писали или читали похожую, возвращаемся назад и смотрим на первую программу, копируем соответствующие разделы, а затем изменяем их для новой программы. Если заимствование обширное, было бы хорошей практикой вставить комментарий в новую программу со ссылкой на оригинал, но тогда бы небыло никакой "официальной" связи между исходной и производной программой.</p>
<p>Формальной альтернативой является создание абстракции в форме функций и, возможно, структур данных, и явной ссылки на эту абстракцию в каждом новом приложении - другими словами, для фиксации абстракции в форме пригодного для повторного использования программного инструмента. Шаблон интерпретатора можно абстрагировать в функцию следующим образом:</p>
<div class="fragment"><div class="line">(defun interactive-interpreter (prompt transformer)</div><div class="line">  &quot;Read an expression, transform it, and print the result.&quot;</div><div class="line">  (loop</div><div class="line">    (print prompt)</div><div class="line">    (print (funcall transformer (read)))))</div></div><!-- fragment --><p>Затем эту функцию можно было бы использовать при написании каждого нового интерпретатора:</p>
<div class="fragment"><div class="line">(defun lisp ()</div><div class="line">  (interactive-interpreter &#39;&gt; #&#39;eval))</div><div class="line"></div><div class="line">(defun eliza ()</div><div class="line">  (interactive-interpreter &#39;eliza&gt;</div><div class="line">    #&#39;(lambda (x) (flatten (use-eliza-rules x)))))</div></div><!-- fragment --><p>Или с помощью функции высшего порядка compose:</p>
<div class="fragment"><div class="line">(defun compose (f g)</div><div class="line">  &quot;Return the function that computes (f (g x)).&quot;</div><div class="line">  #&#39;(lambda (x) (funcall f (funcall g x))))</div><div class="line"></div><div class="line">(defun eliza ()</div><div class="line">  (interactive-interpreter &#39;eliza&gt;</div><div class="line">    (compose #&#39;flatten #&#39;use-eliza-rules)))</div></div><!-- fragment --><p>Есть два различия между формальным и неформальным подходами. Во-первых, они выглядят поразному. Если абстракция простая, как эта, то, вероятно, легче прочитать выражение, в котором цикл явно выписан, чем прочитать выражение, вызывающее <code>interactive-interpreter</code>(интерактивный интерпретатор), поскольку для этого требуется найти определение <code>interactive-interpreter</code> и понять его.</p>
<p>Другое отличие проявляется в так называемом <em>обслуживании/сопровождение</em>. Предположим, мы обнаружили недостаточную функциональность в определении интерактивного интерпретатора. Одно из таких упущений состоит в том, что <code>loop</code> не имеет выхода. Я предполагал, что пользователь может завершить цикл, нажав какую-либо клавишу прерывания (или break, или abort). Более понятная реализация позволила бы пользователю дать интерпретатору явную команду завершения. Еще одна полезная функция - обработка ошибок в интерпретаторе. Если мы будем использовать неформальный подход, то добавление такой возможности в одну программу не повлияет на другие. Но если мы воспользуемся формальным подходом, то улучшение <code>interactive-interpreter</code>(интерактивного интерпретатора) автоматически внесет новую функциональность во все программы, которые её используют.</p>
<p>Следующая версия <code>interactive-interpreter</code> добавляет две новых возможности. Во-первых, она использует макрос <code>handler-case</code> <a href="# fn0015">1</a> для обработки ошибок. Этот макрос вычисляет свой первый аргумент и обычно просто возвращает это значение. Однако при возникновении ошибки последующие аргументы проверяются на наличие условия ошибки, которое соответствует возникшей ошибке. При таком использовании, в случае <code>error</code> соответствует всем ошибкам, и предпринимаемое действие - распечатать состояние ошибки и продолжить.</p>
<p>Эта версия также позволяет приглашению быть либо строкой, либо функцией без аргументов, которая будет вызываться для печати приглашения. Например, функция <code>prompt-generator</code> возвращает функцию, которая будет печатать подсказки вида [1], [2] и так далее.</p>
<div class="fragment"><div class="line">(defun interactive-interpreter (prompt transformer)</div><div class="line">   &quot;Read an expression, transform it, and print the result.&quot;</div><div class="line">   (loop</div><div class="line">      (handler-case</div><div class="line">      (progn</div><div class="line">        (if (stringp prompt)</div><div class="line">        (print prompt)</div><div class="line">        (funcall prompt))</div><div class="line">        (print (funcall transformer (read))))</div><div class="line">    ;; In case of error, do this:</div><div class="line">    (error (condition)</div><div class="line">      (format t &quot;~&amp;;; Error ~a ignored, back to top level.&quot;</div><div class="line">          condition)))))</div><div class="line"></div><div class="line">(defun prompt-generator (&amp;optional (num 0) (ctl-string &quot;[~d] &quot;))</div><div class="line">  &quot;Return a function that prints prompts like [l], [2], etc.&quot;</div><div class="line">  #&#39;(lambda () (format t ctl-string (incf num))))</div></div><!-- fragment --><h2>6.2 Инструмент Сопоставления с образцом</h2>
<p>Функция <code>pat-match</code> была средством сопоставления с образцом, определенным специально для программы ELIZA. Последующим программам также потребуются сопоставители с образцами, и вместо того, чтобы писать специализированные сопоставители для каждой новой программы, легче определить один общий сопоставитель с образцом, который может удовлетворить большинство потребностей и может быть расширен в случае возникновения новых потребностей.</p>
<p>Проблема при разработке "общего" инструмента - решить, какие функции предоставить. Мы можем попытаться определить функции, которые могут быть полезны, но также неплохо сделать список функций открытым, чтобы при необходимости можно было легко добавлять новые.</p>
<p>Функции могут быть добавлены путем обобщения или специализации уже существующих. Например, мы предоставляем сегментные переменные, которые соответствуют нулю или нескольким входным элементам. Мы можем специализировать эту функциональность, предоставляя своего рода сегментную переменную, которая соответствует одному или нескольким элементам, или необязательную переменную, которая соответствует нулю или одному элементу. Другая возможность состоит в том, чтобы обобщить сегментные переменные, чтобы указать соответствие <em>m</em> к <em>n</em> элементов, для любого заданного <em>m</em> и <em>n</em>. Эти идеи приходят из опыта работы с нотациями для написания регулярных выражений, а также из очень общих эвристик для обобщения, таких как "рассмотрения важных частных случаев" и "ноль и один, вероятно, будут важными частными случаями".</p>
<p>Еще одна полезная функциональность заключается в том, чтобы позволить пользователю указать произвольный предикат, которому должно соответствовать сопоставление. Обозначение <code>(?is ?n numberp)</code> может быть использовано для сопоставления любого выражения, которое является числом, и привязки его к переменной <code>?n</code>. Это будет выглядеть как-то так:</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(x = (?is ?n numberp)) &#39;(x = 34)) =&gt; ((?n . 34))</div><div class="line">&gt; (pat-match &#39;(x = (?is ?n numberp)) &#39;(x = x)) =&gt; NIL</div></div><!-- fragment --><p>Поскольку образцы подобны булевым(логическим) выражениям, имеет смысл разрешить булевы операторы над ними. Следуя соглашению о вопросительном знаке в именах переменных, мы будем использовать <code>?and</code>, <code>?or</code> и <code>?not</code> для операторов.<a href="#fn0020">2</a> Вот образец для сопоставления реляционного выражения с одним из трех отношений. Оно удачно, потому что &lt; соответствует одной из трех возможностей, указанных как <code>(?or &lt; = &gt;).</code></p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(?x (?or &lt; = &gt;) ?y) &#39;(3 &lt; 4)) =&gt; ((?Y . 4) (?X . 3))</div></div><!-- fragment --><p>Вот пример образца с <code>?and</code>, который проверяет является ли выражение одновременно числом и при этом еще нечетным:</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(x = (?and (?is ?n numberp) (?is ?n oddp))) &#39;(x = 3)) =&gt; ((?N . 3))</div></div><!-- fragment --><p>В следующем образце использование <code>?not</code> гарантирует, что две части не равны:</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(?x /= (?not ?x)) &#39;(3 /= 4)) =&gt; ((?X . 3))</div></div><!-- fragment --><p>Обозначение сегментных совпадений мы видели ранее. Оно расширено, чтобы учесть три возможности: ноль или более выражений; одно или более выражений; и ноль или одно выражения. Наконц, обозначение <code>(?if *exp*)</code> может использоваться для проверки связи между несколькими переменными. Оно должно быть указано как сегментный образец, а не как отдельный образец, потому что оно вообще не использует вход:</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(?x &gt; ?y (?if (&gt; ?x ?y))) &#39;(4 &gt; 3)) =&gt;</div><div class="line">((?Y . 3) (?X . 4))</div></div><!-- fragment --><p>Когда описание проблемы становиться таким сложным, рекомендуется попытаться сформулировать более формальную спецификацию. В следующей таблице описана граматика образцов с испольованием того же формата правил грамматики, который описан в <a href="B9780080571157500029.xhtml">chapter 2</a>.</p>
<table class="doxtable">
<tr>
<th>входн.символ </th><th>выходной символ или значение </th><th>расшифровка  </th></tr>
<tr>
<td><em>pat</em> =&gt; </td><td><em>var</em> </td><td>соответствие одному произвольному выражению </td></tr>
<tr>
<td></td><td><em>Constant</em> </td><td>соответствие только этому атому </td></tr>
<tr>
<td></td><td><em>segment-pat</em> </td><td>соответствие какой то последовательности </td></tr>
<tr>
<td></td><td><em>single-pat</em> </td><td>соответствие чего-либо с одним выражением </td></tr>
<tr>
<td></td><td>(<em>pat</em> . <em>pat</em>) </td><td>соответствие первого и остатка </td></tr>
<tr>
<td><em>single-pat</em> =&gt; </td><td>(?is <em>var predicate</em>) </td><td>тестовый предикат для одного выражения </td></tr>
<tr>
<td></td><td>(?or <em>pat</em>...) </td><td>соответствие любому образцу в одном выражении </td></tr>
<tr>
<td></td><td>(?and <em>pat</em>...) </td><td>соответствие всем образцам в одном выражении </td></tr>
<tr>
<td></td><td>(?not <em>pat</em>...) </td><td>соответствует, если образец не совпадает </td></tr>
<tr>
<td><em>segment-pat</em> =&gt; </td><td>( (?* <em>var</em>)...) </td><td>соответствие нулю или более выражений </td></tr>
<tr>
<td></td><td>( (?+ <em>var</em>) ... ) </td><td>соответствие одному или нескольким выражениям </td></tr>
<tr>
<td></td><td>( ( ?? <em>var</em>) ... ) </td><td>соответствие нулю или одному выражинию </td></tr>
<tr>
<td></td><td>( ( ?if <em>exp</em> )...) </td><td>тест если exp ( может иметь перем.) истинно </td></tr>
<tr>
<td><em>Var</em> =&gt; </td><td>?chars </td><td>некоторый символ начинающийся с ? </td></tr>
<tr>
<td><em>constant</em> =&gt; </td><td><em>atom</em> </td><td>любой неизменяемый атом </td></tr>
</table>
<p>Не смотря на дополнительную сложность, все образцы можно разделить на пять случаев. Образец должен быть либо переменнной, либо константой, либо (обобщенным) сегментынм образцом, либо (обобщенным) одноэлементным образцом, либо конструкцией(точечной парой) из двух образцов. Следующее определение <code>pat-match</code> отражает пять случаев (вместе с двумя проверками на неудачу):</p>
<div class="fragment"><div class="line">(defun pat-match (pattern input &amp;optional (bindings no-bindings))</div><div class="line">  &quot;Match pattern against input in the context of the bindings&quot;</div><div class="line">  (cond ((eq bindings fail) fail)</div><div class="line">    ((variable-p pattern)</div><div class="line">      (match-variable pattern input bindings))</div><div class="line">    ((eql pattern input) bindings)</div><div class="line">    ((segment-pattern-p pattern)</div><div class="line">      (segment-matcher pattern input bindings))</div><div class="line">    ((single-pattern-p pattern) ; ***</div><div class="line">      (single-matcher pattern input bindings)) ; ***</div><div class="line">    ((and (consp pattern) (consp input))</div><div class="line">      (pat-match (rest pattern) (rest input)</div><div class="line">            (pat-match (first pattern) (first input)</div><div class="line">                bindings)))</div><div class="line">    (t fail)))</div></div><!-- fragment --><p>Для полноты картины, повтрим необходимые константы и низкоуровневые функции из ELIZA:</p>
<div class="fragment"><div class="line">(defconstant fail nil &quot;Indicates pat-match failure&quot;)</div><div class="line"></div><div class="line">(defconstant no-bindings &#39;((t . t))</div><div class="line">  &quot;Indicates pat-match success, with no variables.&quot;)</div><div class="line"></div><div class="line">(defun variable-p (x)</div><div class="line">  &quot;Is x a variable (a symbol beginning with &#39;?&#39;)?&quot;</div><div class="line">  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))</div><div class="line"></div><div class="line">(defun get-binding (var bindings)</div><div class="line">  &quot;Find a (variable . value) pair in a binding list.&quot;</div><div class="line">  (assoc var bindings))</div><div class="line"></div><div class="line">(defun binding-var (binding)</div><div class="line">  &quot;Get the variable part of a single binding.&quot;</div><div class="line">  (car binding))</div><div class="line"></div><div class="line">(defun binding-val (binding)</div><div class="line">  &quot;Get the value part of a single binding.&quot;</div><div class="line">  (cdr binding))</div><div class="line"></div><div class="line">(defun make-binding (var val) (cons var val))</div><div class="line"></div><div class="line">(defun lookup (var bindings)</div><div class="line">  &quot;Get the value part (for var) from a binding list.&quot;</div><div class="line">  (binding-val (get-binding var bindings)))</div><div class="line"></div><div class="line">(defun extend-bindings (var val bindings)</div><div class="line">  &quot;Add a (var . value) pair to a binding list.&quot;</div><div class="line">  (cons (make-binding var val)</div><div class="line">    ;; Once we add a &quot;real&quot; binding,</div><div class="line">    ;; we can get rid of the dummy no-bindings</div><div class="line">    (if (eq bindings no-bindings)</div><div class="line">      nil</div><div class="line">      bindings)))</div><div class="line"></div><div class="line">(defun match-variable (var input bindings)</div><div class="line">  &quot;Does VAR match input? Uses (or updates) and returns bindings.&quot;</div><div class="line">  (let ((binding (get-binding var bindings)))</div><div class="line">    (cond ((not binding) (extend-bindings var input bindings))</div><div class="line">      ((equal input (binding-val binding)) bindings)</div><div class="line">      (t fail))))</div></div><!-- fragment --><p>Следующим шагом является определение предикатов, распознающих обобщенные сегментные и одноэлементные образцы, а также функции сопоставления, которые работают с ними. Мы могли бы реализовать <code>segment-matcher</code> и <code>single-matcher</code> с операторами case, которые учитывают все возможные случаи. Однако это затруднило бы расширение сопоставителя. Программист, который захотел бы добавить новый тип сегментного образца, должен был бы отредактировать определения как <code>segment-pattern-p</code>, так и <code>segment-matcher</code>, чтобы добавить новую функциональность. Само по себе это может быть неплохо, но подумайте, что произойдет, когда два программиста добавляют независимую функциональность одновременно. Если вы захотите использовать и ту и другую, то ни одна из версий <code>segment-matcher</code> (или <code>segment-pattern-p</code>) не подойдет. Вам придется снова отредактировать функции, чтобы просто объединить эти два расширения.</p>
<p>Решение этой дилеммы состоит в том, чтобы раз и навсегда написать одну версию <code>segment-pattern-p</code> и <code>segment-matcher</code>, но чтобы эти функции ссылались на таблицу пар образец/действие(pattern/action). В таблице будет сказано "если вы видите `?*` в образце, тогда используйте функцию `segment-match`" и так далее. Затем программисты, которые хотят расширить сопоставитель, просто добавляют записи в таблицу, и тогда тривиально объединить разные расширения (если, конечно, два программиста не выбрали один и тот же символ для обозначения различных действий).</p>
<p>Такой стиль программирования, при котором пары образец/действие хранятся в таблице, называется программированием, управляемым данными, т.е.: <em>data-driven</em> <em>programming</em>. Это очень гибкий стиль, подходящий для написания расширяемых систем.</p>
<p>Есть много способов реализовать таблицы в Common Lisp, как обсуждалось в <a href="B9780080571157500030.xhtml#s0080">section 3.6</a>, <a href="B9780080571157500030.xhtml#p73">page 73</a>. В этом случае ключи к таблице будут символами (подобно <code>?*</code>), и нормально, если представление таблицы распределено в памяти. Таким образом, списки свойств являются подходящим выбором. У нас будет две таблицы, представляющих свойства <code>segment-match</code> и свойства <code>single-match</code> для символов подобных <code>?*</code>. Значение каждого свойства будет именем функции, которая реализует сопоставление. Вот записи таблицы для реализации описанной ранее грамматики:</p>
<div class="fragment"><div class="line">(setf (get &#39;?is &#39;single-match) &#39;match-is)</div><div class="line">(setf (get &#39;?or &#39;single-match) &#39;match-or)</div><div class="line">(setf (get &#39;?and &#39;single-match) &#39;match-and)</div><div class="line">(setf (get &#39;?not &#39;single-match) &#39;match-not)</div><div class="line">(setf (get &#39;?* &#39;segment-match) &#39;segment-match)</div><div class="line">(setf (get &#39;?+ &#39;segment-match) &#39;segment-match+)</div><div class="line">(setf (get &#39;?? &#39;segment-match) &#39;segment-match?)</div><div class="line">(setf (get &#39;?if &#39;segment-match) &#39;match-if)</div></div><!-- fragment --><p>Определив таблицу, нам нужно сделать две вещи. Во-первых, определить "клей" скрепляющий таблицу: предикаты и функции выполняющие действия. Функция управляемая данными(нашей таблицей), которая находит функции и вызывает их (такие как <code>segment-matcher</code> и <code>single-matcher</code>) называется <em>функцией диспетчеризации</em>.</p>
<div class="fragment"><div class="line">(defun segment-pattern-p (pattern)</div><div class="line">  &quot;Is this a segment-matching pattern like ((?* var) . pat)?&quot;</div><div class="line">  (and (consp pattern) (consp (first pattern))</div><div class="line">    (symbolp (first (first pattern)))</div><div class="line">    (segment-match-fn (first (first pattern)))))</div><div class="line"></div><div class="line">(defun single-pattern-p (pattern)</div><div class="line">  &quot;Is this a single-matching pattern? </div><div class="line">  E.g. (?is x predicate) (?and . patterns) (?or . patterns).&quot;</div><div class="line">  (and (consp pattern)</div><div class="line">      (single-match-fn (first pattern))))</div><div class="line"></div><div class="line">(defun segment-matcher (pattern input bindings)</div><div class="line">  &quot;Call the right function for this kind of segment pattern.&quot;</div><div class="line">  (funcall (segment-match-fn (first (first pattern)))</div><div class="line">        pattern input bindings))</div><div class="line"></div><div class="line">(defun single-matcher (pattern input bindings)</div><div class="line">  &quot;Call the right function for this kind of single pattern.&quot;</div><div class="line">  (funcall (single-match-fn (first pattern))</div><div class="line">        (rest pattern) input bindings))</div><div class="line"></div><div class="line">(defun segment-match-fn (x)</div><div class="line">  &quot;Get the segment-match function for x,</div><div class="line">  if it is a symbol that has one.&quot;</div><div class="line">  (when (symbolp x) (get x &#39;segment-match)))</div><div class="line"></div><div class="line">(defun single-match-fn (x)</div><div class="line">  &quot;Get the single-match function for x,</div><div class="line">  if it is a symbol that has one.&quot;</div><div class="line">  (when (symbolp x) (get x &#39;single-match)))</div></div><!-- fragment --><p>Последнее, что нужно сделать, это определить остальные функции сопоставления. Во превых, функции сопоставления с одним образцом:</p>
<div class="fragment"><div class="line">(defun match-is (var-and-pred input bindings)</div><div class="line">  &quot;Succeed and bind var if the input satisfies pred,</div><div class="line">  where var-and-pred is the list (var pred).&quot;</div><div class="line">  (let* ((var (first var-and-pred))</div><div class="line">      (pred (second var-and-pred))</div><div class="line">      (new-bindings (pat-match var input bindings)))</div><div class="line">    (if (or (eq new-bindings fail)</div><div class="line">        (not (funcall pred input)))</div><div class="line">      fail</div><div class="line">      new-bindings)))</div><div class="line"></div><div class="line">(defun match-and (patterns input bindings)</div><div class="line">  &quot;Succeed if all the patterns match the input.&quot;</div><div class="line">  (cond ((eq bindings fail) fail)</div><div class="line">      ((null patterns) bindings)</div><div class="line">      (t (match-and (rest patterns) input</div><div class="line">              (pat-match (first patterns) input</div><div class="line">                  bindings)))))</div><div class="line"></div><div class="line">(defun match-or (patterns input bindings)</div><div class="line">  &quot;Succeed if any one of the patterns match the input.&quot;</div><div class="line">  (if (null patterns)</div><div class="line">      fail</div><div class="line">        (let ((new-bindings (pat-match (first patterns)</div><div class="line">                    input bindings)))</div><div class="line">        (if (eq new-bindings fail)</div><div class="line">          (match-or (rest patterns) input bindings)</div><div class="line">          new-bindings))))</div><div class="line"></div><div class="line">(defun match-not (patterns input bindings)</div><div class="line">  &quot;Succeed if none of the patterns match the input</div><div class="line">  This will never bind any variables.&quot;</div><div class="line">  (if (match-or patterns input bindings)</div><div class="line">      fail</div><div class="line">      bindings))</div></div><!-- fragment --><p>Теперь функции сопоставления сегментных образцов. <code>segment-match</code> аналогичен версии, представленной как часть ELIZA. Разница в том, как мы определяем <code>pos</code>, позицию первого элемента ввода, который может соответствовать следующему элементу образца после сегментной переменной. В ELIZA мы предполагали, что сегментная переменная была либо последним элементом образца, либо сопровождалась константой. В следующей версии, мы разрешаем не константные образцам следовать за сегментными переменными. Для обработки этого добавлена функция <code>first-match-pos</code>. Если следующий элемент на самом деле является константой, тот же расчет выполняется с использованием <code>position</code>. Если это не константа, мы просто возвращаем первую возможную начальную позицию - если только это не приведет к тому, что мы пройдем конец ввода, и в этом случае мы возвращаем nil, чтобы указать на сбой:</p>
<div class="fragment"><div class="line">(defun segment-match (pattern input bindings &amp;optional (start 0))</div><div class="line">  &quot;Match the segment pattern ((?* var) . pat) against input.&quot;</div><div class="line">  (let ((var (second (first pattern)))</div><div class="line">      (pat (rest pattern)))</div><div class="line">    (if (null pat)</div><div class="line">      (match-variable var input bindings)</div><div class="line">      (let ((pos (first-match-pos (first pat) input start)))</div><div class="line">        (if (null pos)</div><div class="line">            fail</div><div class="line">            (let ((b2 (pat-match</div><div class="line">                    pat (subseq input pos)</div><div class="line">                    (match-variable var (subseq input 0 pos)</div><div class="line">                        bindings))))</div><div class="line">              ;; If this match failed, try another longer one</div><div class="line">              (if (eq b2 fail)</div><div class="line">                (segment-match pattern input bindings (+ pos 1))</div><div class="line">                b2)))))))</div><div class="line"></div><div class="line"> (defun first-match-pos (pat1 input start)</div><div class="line">   &quot;Find the first position that pat1 could possibly match input,</div><div class="line">   starting at position start. If pat1 is non-constant, then just  return start.&quot;</div><div class="line">   (cond ((and (atom pat1) (not (variable-p pat1)))</div><div class="line">      (position pat1 input :start start :test #&#39;equal))</div><div class="line">     ((&lt;= start (length input)) start)</div><div class="line">     (t nil)))</div></div><!-- fragment --><p>В первом примере ниже сегментная переменная <code>?x</code> соответствует последовательности (<code>b c</code>). Во втором примере есть две сегментные переменные в строке. Первое успешное совпадение достигается первой переменной <code>?x</code> соответствующей пустой последовательности, а второй <code>?y</code> соответствует (<code>b c</code>).</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(a (?* ?x) d) &#39;(a b c d)) =&gt; ((?X B C))</div><div class="line">&gt; (pat-match &#39;(a (?* ?x) (?* ?y) d) &#39;(a b c d))=&gt; ((?Y B C) (?X))</div></div><!-- fragment --><p>В следующем примере <code>?x</code> сначала сопоставляется с nil, а <code>?y</code> с (<code>b c d</code> ), но это приводит к неудаче, поэтому мы пытаемся сопоставить <code>?x</code> с сегментом единичной длины. Это тоже приводит к неудаче, но наконец сопоставление проходит успешно с <code>?x</code> сопоставленным с двух элементным сегментом (<code>b c</code>) и <code>?y</code> сопоставленным с (<code>d</code>).</p>
<div class="fragment"><div class="line">&gt; (pat-match  &#39;(a (?* ?x) (?* ?y) ?x ?y)  &#39;(a b c d (b c) (d))) =&gt; ((?Y D) (?X B C))</div></div><!-- fragment --><p> Учитывая <code>segment-match</code>, легко определить функцию для сопоставления одного или нескольких элементов и функцию для сопоставления нуля или одного элемента:</p>
<div class="fragment"><div class="line">(defun segment-match+ (pattern input bindings)</div><div class="line">  &quot;Match one or more elements of input.&quot;</div><div class="line">  (segment-match pattern input bindings 1))</div><div class="line"></div><div class="line">(defun segment-match? (pattern input bindings)</div><div class="line">  &quot;Match zero or one element of input.&quot;</div><div class="line">  (let ((var (second (first pattern)))</div><div class="line">      (pat (rest pattern)))</div><div class="line">    (or (pat-match (cons var pat) input bindings)</div><div class="line">      (pat-match pat input bindings))))</div></div><!-- fragment --><p>Наконец, мы предоставляем функцию для проверки произвольного фрагмента кода Лиспа. Это достигается путем выполнения кода с привязками подразумеваемыми списком привязок. Это один из немногих случаев, когда уместно вызвать <code>eval</code>: когда мы хотим предоставить пользователю неограниченный доступ к интерпретатору Лисп.</p>
<div class="fragment"><div class="line">(defun match-if (pattern input bindings)</div><div class="line">  &quot;Test an arbitrary expression involving variables</div><div class="line">  The pattern looks like ((?if code) . rest).&quot;</div><div class="line">  (and (progv (mapcar #&#39;car bindings)</div><div class="line">        (mapcar #&#39;cdr bindings)</div><div class="line">      (eval (second (first pattern))))</div><div class="line">    (pat-match (rest pattern) input bindings)))</div></div><!-- fragment --><p> Прим. преводчика: код предложенный автором в common lisp не работает, т.к. eval вычисляется в нулевом лексическом окружении, поэтому его создание с помощью progv бесполезно. Я предлагаю реализовать эту функцию воспользовашись функцией подстановки значений переменных в заданный образец с помощью функции sublis.</p>
<div class="fragment"><div class="line">(defun match-if (pattern input bindings)</div><div class="line">  &quot;Проверить произвольное выражение с переменными</div><div class="line">   Образец выглядит как ((?if code) . rest)&quot;</div><div class="line">  (and (eval (sublis bindings (second (first pattern))))</div><div class="line">       (pat-match (rest pattern) input bindings)))</div></div><!-- fragment --><p>Вот два примера использования <code>?if</code>. Первый успешен, потому что <code>(+ 3 4)</code> действительно <code>7</code>, и второй неудачен, потому что <code>(&gt; 3 4)</code> является ложным.</p>
<div class="fragment"><div class="line">&gt; (pat-match  &#39;(?x ?op ?y is ?z (?if (eql (?op ?x ?y) ?z))) &#39;(3 + 4 is 7)) =&gt; ((?Z . 7) (?Y . 4) (?OP . +) (?X . 3))</div><div class="line">&gt; (pat-match  &#39;(?x ?op ?y (?if (?op ?x ?y))) &#39;(3 &gt; 4)) =&gt; NIL</div></div><!-- fragment --><p>Синтаксис, который мы определили для образцов имеет два достоинства: во-первых, синтаксис очень общий, поэтому его легко расширить. Во-вторых, синтаксисом может легко управлять <code>pat-match</code>. Однако, есть один недостаток: синтаксис многословен, и некоторые могут счесть его уродливым. Сравните следующие два образца:</p>
<div class="fragment"><div class="line">(a (?* ?x) (?* ?y) d)</div><div class="line">(a ?x* ?y* d)</div></div><!-- fragment --><p>Многие читатели находят, что второй образец легче понять с первого взгляда. Мы могли бы изменить <code>pat-match</code>, чтобы учесть образцы формы <code>?x*</code>, но это означало бы, что <code>pat-match</code> будет выполнять гораздо больше работы, для выполнения каждого соответствия. Альтернативой является оставить <code>pat-match</code> как есть, но определить другой уровень синтаксиса для использования только человеком читателем. То есть программист может ввести второе выражение выше и преобразовать его в первое, которое затем будет обработано с помощью <code>pat-match</code>.</p>
<p>Другими словами, мы определим средство для определения своего рода макроса сопоставления с образцом, который будет расширен при первом просмотре образца. Лучше сделать это расширение один раз, чем усложнять <code>pat-match</code> и фактически делать это расширение каждый раз, когда используется образец. (Конечно, если образец используется только один раз, то нет никакого преимущества. Но в большинстве программ каждый образец будет использоваться снова и снова.)</p>
<p>Нам нужно определить две функции: одну для определения макроса сопоставления с образцом, а другую для развертывания образцов, которые могут содержать эти макросы. Мы разрешаем только символыам быть макросами, поэтому разумно хранить расширение в списке свойств каждого символа:</p>
<div class="fragment"><div class="line">(defun pat-match-abbrev (symbol expansion)</div><div class="line">  &quot;Define symbol as a macro standing for a pat-match pattern.&quot;</div><div class="line">  (setf (get symbol &#39;expand-pat-match-abbrev)</div><div class="line">    (expand-pat-match-abbrev expansion))</div><div class="line"></div><div class="line">(defun expand-pat-match-abbrev (pat)</div><div class="line">  &quot;Expand out all pattern matching abbreviations in pat.&quot;</div><div class="line">  (cond ((and (symbolp pat) (get pat &#39;expand-pat-match-abbrev)))</div><div class="line">      ((atom pat) pat)</div><div class="line">      (t (cons (expand-pat-match-abbrev (first pat))</div><div class="line">          (expand-pat-match-abbrev (rest pat))))))</div></div><!-- fragment --><p>Мы бы использовали эту возможность следующим образом:</p>
<div class="fragment"><div class="line">&gt; (pat-match-abbrev &#39;?x* &#39;(?* ?x)) =&gt; (?* ?X)</div><div class="line">&gt; (pat-match-abbrev &#39;?y* &#39;(?* ?y)) =&gt; (?* ?Y)</div><div class="line">&gt; (setf axyd (expand-pat-match-abbrev &#39;(a ?x* ?y* d))) =&gt; (A (?* ?X) (?* ?Y) D)</div><div class="line">&gt; (pat-match axyd &#39;(a b c d)) =&gt; ((?Y B C) (?X))</div></div><!-- fragment --><p><b>Exercise 6</b>.**1** [<b>m</b>] Вернитесь назад и измените правила ELIZA, чтобы использовать возможность сокращения. Легче ли стало читать правила?</p>
<p><b>Exercise 6</b>.**2** [<b>h</b>] В нескольких предыдущих примерах эта привязка обнаруживалась каждый раз, когда выполнялась привязка переменных образца, удовлетворяющих входным данным. Неформально покажите, что <code>pat-match</code> всегда найдет такую привязку, или покажите контрпример, где она не может ее найти.</p>
<h2>6.3 Инструмент Преобразования На Основе Правил</h2>
<p>Как мы определили, сопоставитель с образцом сопоставляет один ввод с одним образцом. В <code>eliza</code> нам нужно сопоставить каждый ввод с рядом образцов, а затем вернуть результат на основе правила, содержащего первый совпадающий образец. Чтобы освежить вашу память, вот функция <code>use-eliza-rules</code>:</p>
<div class="fragment"><div class="line">(defun use-eliza-rules (input)</div><div class="line">  &quot;Find some rule with which to transform the input.&quot;</div><div class="line">  (some #&#39;(lambda (rule)</div><div class="line">      (let ((result (pat-match (rule-pattern rule) input)))</div><div class="line">        (if (not (eq result fail))</div><div class="line">          (sublis (switch-viewpoint result)</div><div class="line">            (random-elt (rule-responses rule))))))</div><div class="line">    *eliza-rules*))</div></div><!-- fragment --><p>Оказывается, это довольно обычная вещь: поиск в списке правил подходящего правила и выполнение действий в соответствии с этим правилом. Чтобы превратить структуру <code>use-eliza-rules</code> в программный инструмент, мы позволим пользователю указать каждое из следующих действий:</p>
<ul>
<li>* Какое правило использовать. Каждое правило будет охарактеризовано как if-part и then-part, но способы достижения этих двух частей могут отличаться.</li>
<li>Какой список правил использовать. Очень часто, для каждого приложения будет свой список правил.</li>
<li>Как узнать, соответствует ли правило. По умолчанию мы будем использовать <code>pat-match</code>, но должна быть возможность использование других сопоставителей.</li>
<li>Что делать при совпадении правила. После того как мы определили, какое правило использовать, мы должны определить, что означает его использование. По умолчанию привязка совпадения просто подставляется в часть then-part правила.</li>
</ul>
<p>Инструмент преобразования на основе правил теперь выглядит так:</p>
<div class="fragment"><div class="line">(defun rule-based-translator</div><div class="line">      (input rules &amp;key (matcher #&#39;pat-match)</div><div class="line">        (rule-if #&#39;first) (rule-then #&#39;rest) (action #&#39;sublis))</div><div class="line">  &quot;Find the first rule in rules that matches input,</div><div class="line">  and apply the action to that rule.&quot;</div><div class="line">  (some</div><div class="line">    #&#39;(lambda (rule)</div><div class="line">        (let ((result (funcall matcher (funcall rule-if rule)</div><div class="line">                input)))</div><div class="line">        (if (not (eq result fail))</div><div class="line">          (funcall action result (funcall rule-then rule)))))</div><div class="line">    rules))</div><div class="line"></div><div class="line">(defun use-eliza-rules (input)</div><div class="line">  &quot;Find some rule with which to transform the input.&quot;</div><div class="line">  (rule-based-translator input *eliza-rules*</div><div class="line">    :action #&#39;(lambda (bindings responses)</div><div class="line">          (sublis (switch-viewpoint bindings)</div><div class="line">                (random-elt responses)))))</div></div><!-- fragment --><h2>6.4 набор инструментов поиска</h2>
<p>Программа GPS может рассматриваться как проблема решаемая <em>поиском</em>. В общем, задача поиска включает нахождение(исследование/проверка) из некоторого начального состояния и исследования соседних состояний, и т.д. пока не будет найдено решение(необходимое состояние). Как и в GPS, <em>состояние</em> означает описание любой ситуации или положения дел. У каждого состояния может быть несколько соседей, поэтому необходим выбор способа поиска. Мы можем идти по одному пути, пока не увидим, что это тупик, или мы можем рассматривать множество разных путей одновременно, расширяя каждый путь шаг за шагом. Проблемы поиска называются <em>недетерминированными</em>, потому что невозможно определить, что лучше всего предпринять дальше. Проблемы ИИ по самой своей природе, как правило, недетерминированы. Это может сбивать с толку программистов, привыкших к детерминированным задачам. В этом разделе мы попытаемся прояснить эту путаницу. Этот раздел также служит примером того, как функции высшего порядка могут использоваться для реализации общих инструментов, которые могут быть определены при помощи передачи специальных функций.</p>
<p>Абстрактно задачу поиска можно охарактеризовать четырьмя признаками:</p>
<ul>
<li><em>Начальное/start</em> состояние.</li>
<li><em>Целевое/goal</em> состояние (или состояния).</li>
<li><em>Наследники/преемники/successors</em> или состояния, которые могут быть достигнуты из любого другого состояния.</li>
<li><em>Стратегия/strategy</em>, определяющая <em>порядок</em> поиска.</li>
</ul>
<p>Первые три признака являются частью проблемы, а четвертый - частью решения. В GPS было дано начальное состояние вместе с описанием состояний цели. Состояния наследники определялись путем консультаций с операторами. Стратегия поиска заключалась в анализе конечных целей. Это никогда не оговаривалось явно, но было скрыто в структуре всей программы. В этом разделе мы сформулируем общий инструмент поиска, покажем, как его можно использовать для реализации нескольких различных стратегий поиска, а затем покажем, как с помощью этого инструмента можно реализовать GPS.</p>
<p>Первое понятие, которое мы должны определить, - это <em>пространство состояний</em> или набор всех возможных состояний. Мы можем рассматривать состояния как узлы, а отношения к наследнику как связи на графе. Некоторые графы пространства состояний будут иметь небольшое количество состояний, в то время как другие - бесконечное количество, но их все же можно решить, если мы будем искать с умом. Некоторые графы будут иметь регулярную структуру, в то время как другие - случайную. Мы начнем с рассмотрения только деревьев, то есть графов, в которых состояние может быть достигнуто только одной уникальной последовательностью ссылок на наследников/преемников. Вот дерево:</p>
<div class="image">
<img src="images/chapter6/u06-01.jpg" alt="u06-01"/>
</div>
<h3>Поиск по Дереву</h3>
<p>Мы назовем наш первый инструмент поиска <code>tree-search</code>, потому что он предназначен для поиска в пространстве состояний, которые имеют форму деревьев. Требуется четыре аргумента: (1) список допустимых начальных состояний, (2) предикат, чтобы решить, достигли ли мы целевого состояния, (3) функция, чтобы генерировать преемников состояния, и (4) функция, которая решает, в каком порядке искать. Первый аргумент-это список, а не одно состояние, так что <code>tree-search</code> может рекурсивно вызвать себя после того, как он исследовал несколько путей в пространстве состояний. Думайте о первом аргументе не как о начальном состоянии, а как о списке возможных состояний, из которых может быть достигнута цель. Этот список представляет собой край дерева, который был исследован до сих пор. <code>tree-search</code> имеет три случая: если больше нет состояний для рассмотрения, то алгоритм сдается и возвращает <code>fail</code>. Если первое возможное состояние - это состояние цели, то возвращается успешное состояние. В противном случае создаются наследники/преемники первого состояния и присоединяются к другим состояниям. Порядок в этом комбинированном списке устанавливается в соответствии с конкретной стратегией поиска и продолжает поиск. Обратите внимание, что <code>tree-search</code> сам по себе не определяет никакой конкретной стратегии поиска.</p>
<div class="fragment"><div class="line">(defun tree-search (states goal-p successors combiner)</div><div class="line">  &quot;Find a state that satisfies goal-p.</div><div class="line">   Start with states,and search according to successors and combiner.&quot;</div><div class="line">  (dbg :search &quot;~&amp;; ; Search: ~  a&quot; states)</div><div class="line">  (cond ((null states) fail)</div><div class="line">      ((funcall goal-p (first states)) (first states))</div><div class="line">      (t (tree-search</div><div class="line">          (funcall combiner</div><div class="line">                (funcall successors (first states))</div><div class="line">                (rest states))</div><div class="line">          goal-p successors combiner))))</div></div><!-- fragment --><p>Первая стратегия, которую мы рассмотрим, называется <em>поиск в глубину/depth-first search</em>. При поиске в глубину сначала рассматриваются самые длинные пути. Другими словами, мы создаем наследников состояния, а затем сначала работаем над первым наследником. Мы возвращаемся к одному из последующих наследников только в том случае, если достигаем состояния, в котором вообще нет наследников. Эта стратегия может быть реализована простым добавлением предыдущих состояний в конец списка новых наследников на каждой итерации. Функция <code>depth-first-search</code> принимает одно начальное состояние, предикат цели и функцию-наследников. Она упаковывает начальное состояние в список, как и ожидалось при <code>tree-search</code>, и указывает append в качестве комбинирующей функции:</p>
<div class="fragment"><div class="line">(defun depth-first-search (start goal-p successors)</div><div class="line">  &quot;Search new states first until goal is reached.&quot;</div><div class="line">  (tree-search (list start) goal-p successors #&#39;append))</div></div><!-- fragment --><p>Давайте посмотрим, как мы можем искать в двоичном дереве, определенном ранее. Сначала мы определяем функцию-генерации наследников <code>binary-tree</code>. Она возвращает список из двух состояний: два числа, одно вдвое превышает входное состояние, и второе на один больше первого. Таким образом, наследниками 1 будут 2 и 3, а наследниками 2 будут 4 и 5. Функция <code>binary-tree</code> генерирует бесконечное дерево, первые 15 узлов которого показаны в нашем примере.</p>
<div class="fragment"><div class="line">(defun binary-tree (x) (list (* 2 x) (+  1 (* 2 x))))</div></div><!-- fragment --><p>Чтобы упростить определение цели, мы определяем функцию как функцию, которая возвращает предикат, проверяющий конкретное значение. Обратите внимание, что это не сам тест. Скорее, он возвращает функцию, которую можно вызвать для выполнения тестов:</p>
<div class="fragment"><div class="line">(defun is (value) #&#39;(lambda (x) (eql x value)))</div></div><!-- fragment --><p>Теперь мы можем включить вывод отладки и выполнить поиск в двоичном дереве, начиная с 1 и ища, скажем, 12 в качестве состояния цели. Каждая строка вывода отладки показывает список состояний, которые были сгенерированы как наследники, но еще не исследованы:</p>
<div class="fragment"><div class="line">&gt; (debug :search) =&gt; (SEARCH)</div><div class="line">&gt; (depth-first-search 1 (is 12) #&#39;binary-tree)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (4 5 3)</div><div class="line">;; Search: (8 9 5 3)</div><div class="line">;; Search: (16 17 9 5 3)</div><div class="line">;; Search: (32 33 17 9 5 3)</div><div class="line">;; Search: (64 65 33 17 9 5 3)</div><div class="line">;; Search: (128 129 65 33 17 9 5 3)</div><div class="line">;; Search: (256 257 129 65 33 17 9 5 3)</div><div class="line">;; Search: (512 513 257 129 65 33 17 9 5 3)</div><div class="line">;; Search: (1024 1025 513 257 129 65 33 17 9 5 3)</div><div class="line">;; Search: (2048 2049 1025 513 257 129 65 33 17 9 5 3)</div><div class="line">[Abort]</div></div><!-- fragment --><p>Проблема в том, что мы ищем в бесконечном дереве, а стратегия поиска в глубину просто ныряет вниз по левой ветви на каждом шаге. Единственный способ остановить обреченный поиск - это набрать код прерывания.</p>
<p>Альтернативной стратегией является <em>поиск в ширину/breadth-first search</em>, когда кратчайший путь исследуется/продолжается первым на каждом шаге. Её можно реализовать, просто добавив новые состояния-наследники в конец существующих состояний:</p>
<div class="fragment"><div class="line">(defun prepend (x y) &quot;Prepend y to start of x&quot; (append y x))</div><div class="line"></div><div class="line">(defun breadth-first-search (start goal-p successors)</div><div class="line">  &quot;Search old states first until goal is reached.&quot;</div><div class="line">  (tree-search (list start) goal-p successors #&#39;prepend))</div></div><!-- fragment --><p>Единственная разница между поиском в глубину и в ширину - это разница между <code>append</code> и <code>prepend</code>. Здесь мы видим поиск в ширину - <code>breadth-first-search</code> - в действии:</p>
<div class="fragment"><div class="line">&gt; (breadth-first-search 1 (is 12) &#39;binary-tree)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (3 4 5)</div><div class="line">;; Search: (4 5 6 7)</div><div class="line">;; Search: (5 6 7 8 9)</div><div class="line">;; Search: (6 7 8 9 10 11)</div><div class="line">;; Search: (7 8 9 10 11 12 13)</div><div class="line">;; Search: (8 9 10 11 12 13 14 15)</div><div class="line">;; Search: (9 10 11 12 13 14 15 16 17)</div><div class="line">;; Search: (10 11 12 13 14 15 16 17 18 19)</div><div class="line">;; Search: (11 12 13 14 15 16 17 18 19 20 21)</div><div class="line">;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)</div><div class="line">12</div></div><!-- fragment --><p>Поиск в ширину сначала ищет соседей каждого узла в числовом порядке, и поэтому он в конечном итоге найдет любую цель. Это методично, а, следовательно медленно и тяжело. Поиск в глубину будет намного быстрее - если ему вообще удастся найти цель. Например, если бы мы искали 2048, то поиск в глубину занял бы 12 шагов, а поиск в ширину-2048 шагов. Поиск в ширину также требует большего объема памяти, поскольку он сохраняет больше промежуточных состояний.</p>
<p>Если дерево поиска конечно, то цель в конечном итоге будет найдена либо поиском в ширину, либо поиском в глубину. Оба метода выполняют поиск во всем пространстве состояний, но в различном порядке. Теперь мы покажем поиск в глубину в двоичном дереве из 15 узлов, представленном ранее. На поиск цели (12) уходит примерно столько же времени, сколько и при поиске в ширину. Чтобы найти 15, потребовалось бы больше времени; и меньше, чтобы найти 8. Большая разница в количестве состояний, рассматриваемых одновременно. Самое большее, поиск в глубину рассматривает одновременно четыре; в общем, для поиска по дереву <em>n-узлов</em> требуется хранить только состояния <em>log2 n</em>, тогда как поиск в ширину должен сохранять состояния <em>n/2</em>.</p>
<div class="fragment"><div class="line">(defun finite-binary-tree (n)</div><div class="line">  &quot;Return a successor function that generates a binary tree</div><div class="line">  with n nodes.&quot;</div><div class="line">  #&#39;(lambda (x)</div><div class="line">          (remove-if #&#39;(lambda (child) (&gt; child n))</div><div class="line">                (binary-tree x))))</div></div><!-- fragment --><div class="fragment"><div class="line">&gt; (depth-first-search 1 (is 12) (finite-binary-tree 15))</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (4 5 3)</div><div class="line">;; Search: (8 9 5 3)</div><div class="line">;; Search: (9 5 3)</div><div class="line">;; Search: (5 3)</div><div class="line">;; Search: (10 11 3)</div><div class="line">;; Search: (11 3)</div><div class="line">;; Search: (3)</div><div class="line">;; Search: (6 7)</div><div class="line">;; Search: (12 13 7)</div><div class="line">12</div></div><!-- fragment --><h3>Управление поиском</h3>
<p>Хотя поиск в ширину более методичен, ни одна из стратегий не может использовать какие-либо знания о пространстве состояний. Оба этих поиска ищут вслепую. В большинстве реальных приложений мы будем иметь некоторую оценку того, насколько далеко состояние находится от решения. В таких случаях мы можем реализовать <em>поиск по первому наилучшему/best-first</em>. Название не совсем точное; если бы мы действительно могли найти первого лучшего, это был бы совсем не поиск. Название указывает на то, что вначале ищется состояние, которое <em>кажется</em> лучшим.</p>
<p>Чтобы реализовать поиск "первый-наилучший", нам нужно добавить еще одну информацию: функцию стоимости, которая дает оценку того, насколько далеко данное состояние находится от цели.</p>
<p>Например с бинарным деревом мы будем использовать в качестве оценки стоимости численное отличие от цели. Итак, если мы ищем 12, то 12 стоит 0, 8 стоит 4, а 2048 стоит 2036. Функция высшего порядка <code>diff</code>, показанная ниже, возвращает функцию стоимости, которая вычисляет отличие(дистанцию) от(до) цели. Функция высшего порядка sorter принимает функцию стоимости в качестве аргумента и возвращает объединенную функцию, которая берет списки старых и новых состояний, соединяет их вместе и сортирует результат на основе функции стоимости, ставя в начало наименьшую стоимость. (Встроенная функция <code>sort</code> сортирует список в соответствии с функцией сравнения. В этом случае на первом месте стоят меньшие числа. <code>sort</code> принимает необязательный аргумент <code>: key</code>, который говорит, как вычислить цену для каждого элемента. Будьте осторожны - <code>sort</code> - это разрушающая функция.)</p>
<div class="fragment"><div class="line">(defun diff (num)</div><div class="line">  &quot;Return the function that finds the difference from num.&quot;</div><div class="line">  #&#39;(lambda (x) (abs (- x num))))</div><div class="line"></div><div class="line">(defun sorter (cost-fn)</div><div class="line">  &quot;Return a combiner function that sorts according to cost-fn.&quot;</div><div class="line">  #&#39;(lambda (new old)</div><div class="line">      (sort (append new old) #&#39;&lt; :key cost-fn)))</div><div class="line"></div><div class="line">(defun best-first-search (start goal-p successors cost-fn)</div><div class="line">  &quot;Search lowest cost states first until goal is reached.&quot;</div><div class="line">  (tree-search (list start) goal-p successors (sorter cost-fn)))</div></div><!-- fragment --><p>Теперь, используя отличие от цели в качестве функции стоимости, мы можем искать с помощью поиска best-first:</p>
<div class="fragment"><div class="line">&gt; (best-first-search 1 (is 12) #&#39;binary-tree (diff 12))</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6 2)</div><div class="line">;; Search: (14 15 6 2)</div><div class="line">;; Search: (15 6 2 28 29)</div><div class="line">;; Search: (6 2 28 29 30 31)</div><div class="line">;; Search: (12 13 2 28 29 30 31)</div><div class="line">12</div></div><!-- fragment --><p>Чем больше мы знаем о пространстве состояний, тем лучше мы можем искать. Например, если мы знаем, что все наследники больше, чем состояния, из которых они происходят, то мы можем использовать функцию стоимости, которая дает очень высокую стоимость для чисел превышающих цель. Функция <code>price-is-right</code> похожа на <code>diff</code>, за исключением того, что она дает высокий штраф за превышение цели.<a href="#fn0025">3</a> использование этой функции стоимости приводит к почти оптимальному поиску в данном примере. Он совершает "ошибку" поиска находя 7 перед 6 (потому что 7 ближе к 12), но не тратит время на поиск 14 и 15:</p>
<div class="fragment"><div class="line">(defun price-is-right (price)</div><div class="line">  &quot;Return a function that measures the difference from price,</div><div class="line">  but gives a big penalty for going over price.&quot;</div><div class="line">  #&#39;(lambda (x) (if (&gt; x price)</div><div class="line">              most-positive-fixnum</div><div class="line">              (- price x))))</div><div class="line"></div><div class="line">&gt; (best-first-search 1 (is 12) #&#39;binary-tree (price-is-right 12)) ;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6 2)</div><div class="line">;; Search: (6 2 14 15)</div><div class="line">;; Search: (12 2 13 14 15)</div><div class="line">12</div></div><!-- fragment --><p>Все методы поиска, которые мы видели до сих пор, рассматривали постоянно увеличивающиеся списки состояний, по мере выполнения поиска. Для проблем, где есть только одно решение или небольшое число решений, это неизбежно. Чтобы найти иголку в стоге сена, нужно просмотреть кучу сена. Но для проблем со многими решениями, возможно, стоит отказаться от бесперспективных путей. При этом возникнет риск вообще не найти решение, но это может сэкономить достаточно места и времени, чтобы компенсировать этот риск. Поиск наилучшего первого(best-first), который сохраняет только фиксированное число альтернативных состояний в любой момент времени, известен как поиск по лучу(<em>beam search</em>). Думайте о поиске как о луче света сквозь тьму пространства состояний. В других стратегиях поиска свет расширяется по мере того, какёёёёёёёёёёёёё мы ищем глубже, но в поиске по лучу свет остается плотно сфокусированным. Поиск по лучу-это вариант поиска первого лучшего(best-first), но он также похож на поиск в глубину. Разница заключается в том, что поиск по лучу смотрит на несколько путей сразу, а не только на один, и выбирает лучший из них, чтобы посмотреть на следующий. Но он отказывается от возможности бесконечно возвращаться назад. Функция <code>beam-search</code> точно такая же, как <code>best-first-search</code>, за исключением того, что после сортировки состояний мы берем только первые состояния <code>beam-width</code>. Это делается с помощью <code>subseq</code>; <code>(subseq list start end)</code> возвращает подсписок, который начинается в позиции <em>start</em> и заканчивается непосредственно перед позицией <em>end</em>.</p>
<div class="fragment"><div class="line">(defun beam-search (start goal-p successors cost-fn beam-width)</div><div class="line">  &quot;Search highest scoring states first until goal is reached,</div><div class="line">  but never consider more than beam-width states at a time.&quot;</div><div class="line">  (tree-search (list start) goal-p successors</div><div class="line">        #&#39;(lambda (old new)</div><div class="line">          (let ((sorted (funcall (sorter cost-fn) old new)))</div><div class="line">            (if (&gt; beam-width (length sorted))</div><div class="line">              sorted</div><div class="line">              (subseq sorted 0 beam-width))))))</div></div><!-- fragment --><p>Мы можем успешно искать 12 в двоичном дереве используя ширину луча только 2:</p>
<div class="fragment"><div class="line">&gt; (beam-search 1 (is 12) #&#39;binary-tree (price-is-right 12) 2)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6)</div><div class="line">;; Search: (6 14)</div><div class="line">;; Search: (12 13)</div><div class="line">12</div></div><!-- fragment --><p>Однако если мы вернемся к функции scoring(подсчета очков), которая просто принимает разницу от 12, то поиск по лучу завершится неудачей. Когда он генерирует 14 и 15, он отбрасывает 6, и таким образом теряет свой единственный шанс найти цель:</p>
<div class="fragment"><div class="line">&gt; (beam-search 1 (is 12) #&#39;binary-tree (diff 12) 2)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6)</div><div class="line">;; Search: (14 15)</div><div class="line">;; Search: (15 28)</div><div class="line">;; Search: (28 30)</div><div class="line">;; Search: (30 56)</div><div class="line">;; Search: (56 60)</div><div class="line">;; Search: (60 112)</div><div class="line">;; Search: (112 120)</div><div class="line">;; Search: (120 224)</div><div class="line">[Abort]</div></div><!-- fragment --><p>Этот поиск был бы успешным, если бы мы задали ширину луча равную 3. Это иллюстрирует общий принцип: мы можем найти цель, либо просматривая на большее количество состояний, либо будучи информированее в отношении состояний, на которые мы смотрим. Это означает, что у вас есть лучшая функция упорядочения.</p>
<p>Обратите внимание, что при бесконечной ширине луча мы получаем поиск первого лучшего. При ширине луча 1 мы получаем поиск в глубину без возвратов. Это можно было бы назвать "глубинным поиском", но он более широко известен как <em>восхождение на холм</em>. Представьте себе альпиниста, пытающегося достичь вершины в густом тумане. Одна из стратегий заключается в том, чтобы альпинист посмотрел на соседние локации, поднялся на самую высокую и снова посмотрел. Эта стратегия может в конечном итоге достичь пика, но она также может застрять на вершине предгорья или <em>локального максимума</em>. Другая стратегия была бы для альпиниста, чтобы повернуть назад и попробовать снова, когда туман поднимается, но в AI, к сожалению, туман редко поднимается.<a href="#fn0030">4</a></p>
<p>В качестве конкретного примера задачи, которую можно решить с помощью поиска, рассмотрим задачу планирования полета через североамериканский континент на небольшом самолете, дальность полета которого ограничена 1000 километрами. Предположим, у нас есть список выбранных городов с аэропортами, а также их положение по долготе и широте:</p>
<div class="fragment"><div class="line">(defstruct (city (:type list)) name long lat)</div><div class="line"></div><div class="line">(defparameter *cities*</div><div class="line">   &#39;((Atlanta        84.23 33.45)      (Los Angeles       118.15 34.03)     </div><div class="line">   (Boston           71.05 42.21)      (Memphis           90.03 35.09)     </div><div class="line">   (Chicago          87.37 41.50)      (New York          73.58 40.47)     </div><div class="line">   (Denver           105.00 39.45)     (Oklahoma City     97.28 35.26)     </div><div class="line">   (Eugene           123.05 44.03)     (Pittsburgh        79.57 40.27)     </div><div class="line">   (Flagstaff        111.41 35.13)     (Quebec            71.11 46.49)     </div><div class="line">   (Grand Jet        108.37 39.05)     (Reno              119.49 39.30)    </div><div class="line">   (Houston          105.00 34.00)     (San Francisco     122.26 37.47)    </div><div class="line">   (Indianapolis     86.10 39.46)      (Tampa             82.27 27.57)     </div><div class="line">   (Jacksonville     81.40 30.22)      (Victoria          123.21 48.25)    </div><div class="line">   (Kansas City      94.35 39.06)      (Wilmington        77.57 34.14)))   </div></div><!-- fragment --><p>В этом примере вводится новая опция для <code>defstruct</code>. Вместо того чтобы просто дать название структуре, можно также использовать:</p>
<div class="fragment"><div class="line">(defstruct (structure-name (option value)...) &quot;optional doc&quot; slot...)</div></div><!-- fragment --><p>Для города опция :type указывается как <code>list</code>. Это означает, что города будут реализованы в виде списков из трех элементов, так как они находятся в начальном значении для <code>*cities*</code>.</p>
<p>Города показаны на карте в [<a href="#f0010">figure 6.1</a>, которая имеет связи между всеми городами в пределах 1000-километрового диапазона друг от друга. <a href="#fn0035">5</a> Эта карта была нарисована с помощью функции <code>air-distance</code>, которая возвращает расстояние в километрах между двумя городами "по мере полета вороны".- Она будет определена позже. Две другие полезные функции - это <code>neighbors</code>(соседи), которая находит все города в радиусе 1000 километров, и <code>city</code>(город), которая отображает имя города. Первая использует <code>find-all-if</code>, которая была определена на <a href="B9780080571157500030.xhtml#p101">стр. 101</a> как синоним для <code>remove-if-not</code>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter6/f06-01.jpg" alt="f06-01"/>
</div>
 </td></tr>
<tr>
<td>Figure 6.1: Карта некоторых городов </td></tr>
</table>
<div class="fragment"><div class="line">(defun neighbors (city)</div><div class="line">  &quot;Find all cities within 1000 kilometers.&quot;</div><div class="line">  (find-all-if #&#39;(lambda (c)</div><div class="line">          (and (not (eq c city))</div><div class="line">              (&lt; (air-distance c city) 1000.0)))</div><div class="line">        *cities*))</div><div class="line"></div><div class="line">(defun city (name)</div><div class="line">  &quot;Find the city with this name.&quot;</div><div class="line">  (assoc name *cities*))</div></div><!-- fragment --><p>Теперь мы готовы планировать поездку. Функция <code>trip</code>(поездка) принимает название города отправления и назначения и выполняет поиск по лучу шириной в единицу, рассматривая всех соседей как преемников состояния. Стоимость для состояния - это расстояние по воздуху до города назначения:</p>
<div class="fragment"><div class="line">(defun trip (start dest)</div><div class="line">  &quot;Search for a way from the start to dest.&quot;</div><div class="line">  (beam-search start (is dest) #&#39;neighbors</div><div class="line">          #&#39;(lambda (c) (air-distance c dest))</div><div class="line">          1))</div></div><!-- fragment --><p>Здесь мы планируем поездку из Сан-Франциско в Бостон. Результат кажется наилучшим из возможных путей:</p>
<div class="fragment"><div class="line">&gt; (trip (city &#39;san-francisco) (city &#39;boston))</div><div class="line">;; Search: ((SAN-FRANCISCO 122.26 37.47))</div><div class="line">;; Search: ((RENO 119.49 39.3))</div><div class="line">;; Search: ((GRAND-JCT 108.37 39.05))</div><div class="line">;; Search: ((DENVER 105.0 39.45))</div><div class="line">;; Search: ((KANSAS-CITY 94.35 39.06))</div><div class="line">;; Search: ((INDIANAPOLIS 86.1 39.46))</div><div class="line">;; Search: ((PITTSBURGH 79.57 40.27))</div><div class="line">;; Search: ((BOSTON 71.05 42.21))</div><div class="line">(BOSTON 71.05 42.21)</div></div><!-- fragment --><p>Но посмотрите, что происходит, когда мы планируем обратный путь. Есть два объезда, в Чикаго и Флагстафф:</p>
<div class="fragment"><div class="line">&gt; (trip (city &#39;boston) (city &#39;san-francisco))</div><div class="line">;; Search: ((BOSTON 71.05 42.21))</div><div class="line">;; Search: ((PITTSBURGH 79.57 40.27))</div><div class="line">;; Search: ((CHICAGO 87.37 41.5))</div><div class="line">;; Search: ((KANSAS-CITY 94.35 39.06))</div><div class="line">;; Search: ((DENVER 105.0 39.45))</div><div class="line">;; Search: ((FLAGSTAFF 111.41 35.13))</div><div class="line">;; Search: ((RENO 119.49 39.3))</div><div class="line">;; Search: ((SAN-FRANCISCO 122.26 37.47))</div><div class="line">(SAN-FRANCISCO 122.26 37.47)</div></div><!-- fragment --><p>Почему <code>trip</code> отправился из Денвера в Сан-Франциско через Флагстафф? Потому что Флагстафф ближе к месту назначения, чем Grand Junction. Проблема в том, что мы минимизируем расстояние до пункта назначения на каждом шаге, тогда как мы должны минимизировать сумму расстояний до пункта назначения плюс уже пройденное расстояние.</p>
<h3>Поиск Путей</h3>
<p>Чтобы свести к минимуму общее расстояние, нам нужно каким-то образом поговорить о пути(<em>path</em>), ведущем к цели. Но функции, которые мы определили до сих пор, имеют дело только с отдельными состояниями на этом пути. Представление путей привело бы к еще одному преимуществу: мы могли бы вернуть путь как решение, а не просто вернуть целевое состояние. Как бы то ни было, <code>trip</code> возвращает только целевое состояние, а не путь к нему. Таким образом, нет никакого способа определить, что сделал <code>trip</code>, кроме как прочитав выходные данные отладки.</p>
<p>Структура данных путь(path) предназначена для решения обеих этих проблем. Путь имеет четыре поля: текущее состояние, предыдущая часть пути, которую продолжает этот путь, стоимость пути до сих пор и оценка общей стоимости до достижения цели. Вот определение структуры для path. Она использует опцию <code>:print-function</code>, чтобы сказать, что все пути должны быть напечатаны с помощью функции <code>print-path</code>, которая будет определена ниже.</p>
<div class="fragment"><div class="line">(defstruct (path (:print-function print-path))</div><div class="line">    state (previous nil) (cost-so-far 0) (total-cost 0))</div></div><!-- fragment --><p>Следующий вопрос заключается в том, как интегрировать пути в процедуры поиска с наименьшим количеством переделок. Очевидно, что было бы лучше внести одно изменение в <code>tree-search</code>(поиск по дереву), а не менять <code>depth-first-search</code>, <code>breadth-first-search</code> и <code>beam-search</code> Однако, оглядываясь назад на определение <code>tree-search</code>, мы видим, что оно не делает никаких предположений о структуре состояний, кроме того факта, что ими можно манипулировать с помощью функций предиката цели, функции определения приемников и функции объединителя/комбинатора. Это предполагает, что мы можем использовать <code>tree-search</code> без изменений, если мы передадим ей пути вместо состояний и предоставим ей функции, которые могут обрабатывать пути.</p>
<p>В следующем переопределении <code>trip</code> функция <code>beam-search</code> вызывается с пятью аргументами. Вместо того, чтобы передать ей город в качестве начального состояния, мы передаем путь, который имеет город в качестве своего поля состояния. Предикат цели должен проверить, является ли его аргумент путем, состояние которого является назначением; мы предполагаем (и позже определяем) версию <code>is</code>, которая вмещает её. Функция successor(преемник) - самая сложная. Вместо того чтобы просто генерировать список соседей, мы хотим сначала сгенерировать соседей, а затем превратить каждый из них в путь, который расширяет текущий путь, но с обновленной стоимостью уплаченной сих пор и общей расчетной стоимостью. Функция <code>path-saver</code> возвращает функцию, которая будет делать именно это. Наконец, функция cost(стоимости), которую мы пытаемся минимизировать, - это <code>path-total-cost</code> и мы предоставляем ширину луча, которая теперь является необязательным аргументом для <code>trip</code>, и которая по умолчанию равна единице:</p>
<div class="fragment"><div class="line">(defun trip (start dest &amp;optional (beam-width 1))</div><div class="line">  &quot;Search for the best path from the start to dest.&quot;</div><div class="line">  (beam-search</div><div class="line">    (make-path :state start)</div><div class="line">    (is dest :key #&#39;path-state)</div><div class="line">    (path-saver #&#39;neighbors #&#39;air-distance</div><div class="line">          #&#39;(lambda (c) (air-distance c dest)))</div><div class="line">#&#39;path-total-cost</div><div class="line">beam-width))</div></div><!-- fragment --><p>Расчет <code>air-distance</code> включает в себя некоторое сложное преобразование долготы и широты в координаты <code>x-y-z</code>. Поскольку это проблема геометрии, а не искусственного интеллекта, код представлен без дальнейших комментариев:</p>
<div class="fragment"><div class="line">(defconstant earth-diameter 12765.0</div><div class="line">  &quot;Diameter of planet earth in kilometers.&quot;)</div><div class="line">(defun air-distance (city1 city2)</div><div class="line">  &quot;The great circle distance between two cities.&quot;</div><div class="line">  (let ((d (distance (xyz-coords city1) (xyz-coords city2))))</div><div class="line">    ;; d is the straight-line chord between the two cities,</div><div class="line">    ;; The length of the subtending arc is given by:</div><div class="line">    (* earth-diameter (asin (/ d 2)))))</div><div class="line"></div><div class="line">(defun xyz-coords (city)</div><div class="line">  &quot;Returns the x,y,z coordinates of a point on a sphere.</div><div class="line">  The center is (0 0 0) and the north pole is (0 0 1).&quot;</div><div class="line">  (let ((psi (deg-&gt;radians (city-lat city)))</div><div class="line">        (phi (deg-&gt;radians (city-long city))))</div><div class="line">      (list (* (cos psi) (cos phi))</div><div class="line">            (* (cos psi) (sin phi))</div><div class="line">            (sin psi))))</div><div class="line"></div><div class="line">(defun distance (point1 point2)</div><div class="line">  &quot;The Euclidean distance between two points.</div><div class="line">  The points are coordinates in n-dimensional space.&quot;</div><div class="line">  (sqrt (reduce #&#39;+ (mapcar #&#39;(lambda (a b) (expt (- a b) 2))</div><div class="line">                point1 point2))))</div><div class="line"></div><div class="line">(defun deg-&gt;radians (deg)</div><div class="line">  &quot;Convert degrees and minutes to radians.&quot;</div><div class="line">  (* (+ (truncate deg) (* (rem  deg 1) 100/60)) pi 1/180))</div></div><!-- fragment --><p>Прежде чем показать вспомогательные функции, которые реализуют это, вот несколько примеров, которые показывают, что она может сделать. При ширине луча 1 проезд через Флагстаффа исключается, но остается объезд через Чикаго. При ширине луча 3 найден правильный оптимальный путь. В следующих примерах каждый вызов новой версии <code>trip</code> возвращает путь, который печатается с помощью <code>show-city-path</code>:</p>
<div class="fragment"><div class="line">&gt; (show-city-path (trip (city &#39;san-francisco) (city &#39;boston) 1))</div><div class="line">#&lt;Path 4514.8  km: San-Francisco - Reno - Grand-Jet - Denver -</div><div class="line">  Kansas-City - Indianapolis - Pittsburgh - Boston  &gt;</div><div class="line">&gt; (show-city-path (trip (city &#39;boston) (city &#39;san-francisco) 1))</div><div class="line">#&lt;Path 4577.3  km: Boston - Pittsburgh - Chicago - Kansas-City -</div><div class="line">  Denver - Grand-Jet - Reno - San-Francisco  &gt;</div><div class="line">&gt; (show-city-path (trip (city &#39;boston) (city &#39;san-francisco) 3))</div><div class="line">#&lt;Path 4514.8  km: Boston - Pittsburgh - Indianapolis -</div><div class="line">  Kansas-City - Denver - Grand-Jet - Reno - San-Francisco  &gt;</div></div><!-- fragment --><p>Этот пример показывает, как поиск подвержен нарушениям в пространстве поиска. Было легко найти правильный путь с запада на восток, но обратный путь потребовал больше поисков, потому что Флагстафф - это ложный многообещающий шаг. В общем, в пространстве поиска могут таиться еще худшие тупики. Посмотрите, что происходит, когда мы ограничиваем дальность полета самолета до 700 километров. Карта показана на <a href="#f0015">рис. 6.2</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter6/f06-02.jpg" alt="f06-02"/>
</div>
 </td></tr>
<tr>
<td>Рис.6.2: Карта городов с достиж. в 700 км </td></tr>
</table>
<p>Если мы попытаемся спланировать поездку из Тампы в Квебек, у нас могут возникнуть проблемы с тупиком в Уилмингтоне, Северная Каролина. При ширине луча 1 путь в Джексонвилл(Jacksonville), а затем в Уилмингтон(Wilmington) будет опробован в первую очередь. Оттуда каждый шаг пути чередуется между Атлантой(Atlanta) и Уилмингтоном(Wilmington). Поиск никогда не приближается к цели. Но при ширине Луча 2 путь из Тампы в Атланту не отбрасывается, и в конечном итоге он продолжается до Индианаполиса и, в конечном счете, до Квебека. Таким образом, возможность возврата имеет важное значение для избежания тупиков.</p>
<p>Теперь перейдем к деталям реализации. Функция <code>is</code> по-прежнему возвращает предикат, который проверяет значение, но теперь она принимает ключевые слова <code>:key</code> и <code>:test</code>:</p>
<div class="fragment"><div class="line">(defun is (value &amp;key (key #&#39;identity) (test #&#39;eql))</div><div class="line">  &quot;Returns a predicate that tests for a given value.&quot;</div><div class="line">  #&#39;(lambda (path) (funcall test value (funcall key path))))</div></div><!-- fragment --><p>Функция <code>path-saver</code> возвращает функцию, которая будет принимать путь в качестве аргумента и генерировать пути-преемники. <code>path-saver</code> принимает в качестве аргумента функцию-генерации преемников, которая работает с голыми состояниями. Она вызывает эту функцию и для каждого возвращенного состояния создает путь, который расширяет существующий путь и сохраняет стоимость пути пройденного до сих пор, а также предполагаемую общую стоимость:</p>
<div class="fragment"><div class="line">(defun path-saver (successors cost-fn cost-left-fn)</div><div class="line">  #&#39;(lambda (old-path)</div><div class="line">      (let ((old-state (path-state old-path)))</div><div class="line">        (mapcar</div><div class="line">          #&#39;(lambda (new-state)</div><div class="line">            (let ((old-cost</div><div class="line">                  (+ (path-cost-so-far old-path)</div><div class="line">                      (funcall cost-fn old-state new-state))))</div><div class="line">              (make-path</div><div class="line">                :state new-state</div><div class="line">                :previous old-path</div><div class="line">                :cost-so-far old-cost</div><div class="line">                :total-cost (+ old-cost (funcall cost-left-fn</div><div class="line">                        new-state)))))</div><div class="line">          (funcall successors old-state)))))</div></div><!-- fragment --><p>По умолчанию структура path будет напечатана как <code>#S ( PATH ... )</code>. Но поскольку каждый путь имеет поле <code>previous</code>, которое заполняется другим путем, этот вывод будет довольно подробным. Вот почему мы установили <code>print-path</code> в качестве функции печати для путей, когда определяли структуру. Она использует обозначение <code>#&lt;...&gt;</code> , что является общим соглашением Lisp для вывода на печать, который не может быть восстановлен с помощью <code>read</code>. Функция <code>show-city-path</code> выводит более полное представление пути. Мы также определяем <code>map-path</code> для итерации(прхода) по пути, для сбора значений:</p>
<div class="fragment"><div class="line">(defun print-path (path &amp;optional (stream t) depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;#&lt;Path to ~a cost ~,lf&gt;&quot;</div><div class="line">        (path-state path) (path-total-cost path)))</div><div class="line"></div><div class="line">(defun show-city-path (path &amp;optional (stream t))</div><div class="line">  &quot;Show the length of a path, and the cities along it.&quot;</div><div class="line">  (format stream &quot;#&lt;Path ~,lf km: ~{~:(~a~)~^- ~}&gt;&quot;</div><div class="line">        (path-total-cost path)</div><div class="line">        (reverse (map-path #&#39;city-name path)))</div><div class="line">  (values))</div><div class="line"></div><div class="line">(defun map-path (fn path)</div><div class="line">  &quot;Call fn on each state in the path, collecting results.&quot;</div><div class="line">  (if (null path)</div><div class="line">      nil</div><div class="line">      (cons (funcall fn (path-state path))</div><div class="line">          (map-path fn (path-previous path)))))</div></div><!-- fragment --><h3>Угадывание против гарантированно хорошего решения</h3>
<p>В учебниках по элементарному искусственному интеллекту большое внимание уделяется алгоритмам поиска, которые гарантированно найдут наилучшее решение. Однако на практике эти алгоритмы практически не используются. Проблема заключается в том, что для того, чтобы гарантировать наилучшее решение, необходимо рассмотреть множество других решений, чтобы исключить их. Для проблем с большими пространствами поиска это обычно занимает слишком много времени. Альтернативой является использование алгоритма, который, вероятно, вернет решение, близкое к лучшему решению, но не дает никаких гарантий. Такие алгоритмы, традиционно известные как алгоритмы <em>недопустимого эвристического поиска</em>, могут быть намного быстрее.</p>
<p>Из алгоритмов, которые мы видели до сих пор, поиск best-first(первый лучший) почти, но не совсем, гарантирует лучшее решение. Проблема в том, что он заканчивается слишком рано. Предположим, что он рассчитал три пути стоимостью 90, 95 и 110 долларов. Затем он расширяет путь 90. Предположим, что это приводит к решению общей стоимостью 100. Поиск первого лучшего затем вернет это решение. Но вполне возможно, что путь 95 может привести к решению с общей стоимостью менее 100. Возможно, путь 95 находится всего в одной единице от цели, поэтому он может привести к полному пути длиной 96. Это означает, что оптимальный поиск должен исследовать путь 95 (но не путь 110) перед завершением поиска.</p>
<p>С другой стороны, поиск в глубину и поиск по лучу - это определенно эвристические алгоритмы. Поиск в глубину находит решение без учета его стоимости. При поиске по лучу выбор хорошего значения для ширины луча может привести к хорошему, быстрому решению, в то время как выбор неправильного значения может привести к неудаче или к плохому решению. Один из выходов из этой дилеммы состоит в том, чтобы начать с узкой ширины луча, и если это не приведет к приемлемому решению, расширить Луч и попробовать снова. Мы будем называть это итеративным расширением, хотя это не стандартный термин. Есть много вариаций на эту тему, но вот одна простая:</p>
<div class="fragment"><div class="line">(defun iter-wide-search (start goal-p successors cost-fn</div><div class="line">                &amp;key (width 1) (max 100))</div><div class="line">  &quot;Search, increasing beam width from width to max.</div><div class="line">  Return the first solution found at any width.&quot;</div><div class="line">  (dbg :search &quot;; Width: ~d&quot; width)</div><div class="line">  (unless (&gt; width max)</div><div class="line">    (or (beam-search start goal-p successors cost-fn width)</div><div class="line">      (iter-wide-search start goal-p successors cost-fn</div><div class="line">                        :width (+ width 1) :max max))))</div></div><!-- fragment --><p>Здесь <code>iter-wide-search</code> использующийся для поиска по двоичному дереву, терпит неудачу с шириной луча 1 и 2, и в конечном итоге преуспевая с шириной луча 3:</p>
<div class="fragment"><div class="line">&gt; (iter-wide-search 1 (is 12) (finite-binary-tree 15) (diff 12))</div><div class="line">Width: 1</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3)</div><div class="line">;; Search: (7)</div><div class="line">;; Search: (14)</div><div class="line">; Width: 2</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6)</div><div class="line">;; Search: (14 15)</div><div class="line">;; Search: (15)</div><div class="line">;; Search: NIL</div><div class="line">; Width: 3</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6 2)</div><div class="line">;; Search: (14 15 6)</div><div class="line">;; Search: (15 6)</div><div class="line">;; Search: (6)</div><div class="line">;; Search: (12 13)</div><div class="line">12</div></div><!-- fragment --><p>Название итеративное расширение происходит от устоявшегося термина <code>итеративное углубление</code>. Итеративное углубление используется для управления поиском в глубину, когда мы не знаем глубину искомого решения. Идея состоит в том, чтобы сначала ограничить поиск глубиной 1, затем 2 и так далее. Таким образом, мы гарантированно найдем решение на минимальной глубине, как и при поиске в ширину, но не теряя при этом много места для хранения. Конечно, итеративное углубление действительно тратит некоторое время, потому что на каждой увеличивающейся глубине оно повторяет всю работу, проделанную на предыдущей глубине. Но предположим, что среднее состояние имеет десять преемников. Это означает, что увеличение глубины на единицу приводит к увеличению поиска в десять раз, поэтому только 10% времени тратится на повторную работу. Таким образом, итеративное углубление использует лишь немного больше времени и гораздо меньше пространства. Мы увидим это снова в <a href="B978008057115750011X.xhtml">главах 11</a> и <a href="B9780080571157500182.xhtml">18</a>.</p>
<h3>Графы Поиска</h3>
<p>До сих пор <code>tree-search</code> была рабочей лошадкой, стоящей за всеми поисковыми процедурами. Это любопытно, если учесть, что проблема путешествия между городами включает в себя граф, который вовсе не является деревом. Причина, по которой работает <code>tree-search</code>, заключается в том, что любой граф можно рассматривать как дерево, если мы игнорируем тот факт, что некоторые узлы идентичны. Например, граф на <a href="#f0020">рис. 6.3</a> может быть представлен в виде дерева. <a href="#f0025">Рисунок 6.4</a> показывает только верхние четыре уровня дерева; каждый из нижних узлов (за исключением 6s) нуждается в дальнейшем расширении.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter6/f06-03.jpg" alt="f06-03"/>
</div>
 </td></tr>
<tr>
<td>Рис. 6.3: Граф с шестью узлами </td></tr>
</table>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter6/f06-04.jpg" alt="f06-04"/>
</div>
 </td></tr>
<tr>
<td>Рис. 6.4: Соответствующее дерево </td></tr>
</table>
<p>При поиске путей через граф городов мы неявно превращали граф в дерево. То есть, если <code>tree-search</code> найдет два пути из Питтсбурга в Канзас-Сити (через Чикаго или Индианаполис), то он будет рассматривать их как два независимых пути, точно так же, как если бы было два разных города Канзас. Это упростило алгоритмы, но также удвоило количество путей, оставшихся для изучения. Если конечная цель-Сан-Франциско, нам придется искать путь из Канзас-Сити в Сан-Франциско дважды, а не один раз. На самом деле, хотя граф имеет только 22 города, дерево бесконечно, потому что мы можем перемещаться между соседними городами любое количество раз. Таким образом, хотя можно рассматривать граф как дерево, существует потенциальная экономия при рассмотрении его как истинного графа.</p>
<p>Функция <code>graph-search</code> делает именно это. Она похожа на <code>tree-search</code>, но принимает два дополнительных аргумента: функцию сравнения, которая проверяет, равны ли два состояния, и список состояний, которые больше не рассматриваются, т.к были рассмотрены ранее. Разница между <code>graph-search</code> и <code>tree-search</code> заключается в вызове <code>new-states</code>, которая генерирует преемников, но устраняет состояния, которые находятся либо в списке рассматриваемых в настоящее время состояний, либо в списке старых состояний, рассматривавшихся в прошлом.</p>
<div class="fragment"><div class="line">(defun graph-search (states goal-p successors combiner &amp;optional (state= #&#39;eql) old-states)</div><div class="line"> &quot;Find a state that satisfies goal-p. Start with states,and search according to successors and combiner.</div><div class="line">  Don&#39;t try the same state twice.&quot;</div><div class="line">  (dbg :search &quot;~&amp;;; Search: ~a&quot; states)</div><div class="line">  (cond ((null states) fail)</div><div class="line">        ((funcall goal-p (first states)) (first states))</div><div class="line">        (t (graph-search</div><div class="line">            (funcall</div><div class="line">              combiner</div><div class="line">              (new-states states successors state= old-states)</div><div class="line">              (rest states))</div><div class="line">            goal-p successors combiner state=</div><div class="line">            (adjoin (first states) old-states</div><div class="line">                      :test state=)))))</div><div class="line"></div><div class="line">(defun new-states (states successors state= old-states)</div><div class="line">  &quot;Generate successor states that have not been seen before.&quot;</div><div class="line">  (remove-if</div><div class="line">    #&#39;(lambda (state)</div><div class="line">      (or (member state states :test state=)</div><div class="line">        (member state old-states :test state=)))</div><div class="line">      (funcall successors (first states))))</div></div><!-- fragment --><p>Используя функцию-преемницу <code>next2</code>, мы можем искать на графе, показанном здесь, либо в виде дерева, либо в виде графа. Если мы ищем по нему в виде графа, требуется меньше итераций и меньше места для хранения, чтобы найти цель. Конечно, существуют дополнительные накладные расходы для проверки идентичности состояний, но на графах, подобных этому, мы получаем экспоненциальное ускорение при постоянном объеме накладных расходов.</p>
<div class="fragment"><div class="line">(defun next2 (x) (list (+ x 1) (+ x 2)))</div><div class="line"></div><div class="line">&gt; (tree-search &#39;(1) (is 6) #&#39;next2 #&#39;prepend)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (3 3 4)</div><div class="line">;; Search: (3 4 4 5)</div><div class="line">;; Search:(4 4 5 4 5)</div><div class="line">;; Search: (4 5 4 5 5 6)</div><div class="line">;; Search: (5 4 5 5 6 5 6)</div><div class="line">;; Search: (4 5 5 6 5 6 6 7)</div><div class="line">;; Search: (5 5 6 5 6 6 7 5 6)</div><div class="line">;; Search: (5 6 5 6 6 7 5 6 6 7)</div><div class="line">;; Search: (6 5 6 6 7 5 6 6 7 6 7)</div><div class="line">6</div><div class="line">&gt; (graph-search &#39;(1) (is 6) #&#39;next2 #&#39;prepend)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (3 4)</div><div class="line">;; Search: (4 5)</div><div class="line">;; Search: (5 6)</div><div class="line">;; Search: (6 7)</div><div class="line">6</div></div><!-- fragment --><p>Следующим шагом является расширение алгоритма графового поиска - <code>graph-search</code> для обработки путей. Сложность заключается в том, чтобы решить, какой путь выбрать, когда два пути достигают одного и того же состояния. Если у нас есть функция стоимости, то ответ прост: сохраняем путь с более дешевой стоимостью. Поиск лучшего первого(Best-first в графе, удаляющий повторяющиеся состояния, называется A* поиском.</p>
<p>Поиск A* более сложен, чем <code>graph-search</code>, из-за необходимости как добавлять, так и удалять пути в списках текущих и старых путей. Для каждого нового состояния-преемника существует три возможности. Новое состояние может быть в списке текущих путей, в списке старых путей или ни в одном из них. В первых двух случаях имеются две подслучая. Если новый путь дороже старого, то игнорируйте новый путь- т.к. он не может привести к лучшему решению. Если новый путь дешевле, чем соответствующий путь в списке текущих путей, то замените его новым путем. Если он дешевле, чем соответствующий путь в списке старых путей, то удалите старый путь и поместите новый путь в список текущих путей.</p>
<p>Кроме того, вместо того, чтобы сортировать пути по общей стоимости на каждой итерации, они сортируются, и новые пути вставляются в нужное место по одному с помощью <code>insert-path</code>. Еще две функции <code>better-path</code> и <code>find-path</code> используются, чтобы сравнить пути и посмотреть, появилось ли уже нужное состояние.</p>
<div class="fragment"><div class="line">(defun a*-search (paths goal-p successors cost-fn cost-left-fn</div><div class="line">                  &amp;optional (state= #&#39;eql) old-paths)</div><div class="line">  &quot;Find a path whose state satisfies goal-p.  Start with paths,</div><div class="line">  and expand successors, exploring least cost first.</div><div class="line">  When there are duplicate states, keep the one with the</div><div class="line">  lower cost and discard the other.&quot;</div><div class="line">  (dbg :search &quot;;; Search: ~a&quot; paths)</div><div class="line">  (cond</div><div class="line">    ((null paths) fail)</div><div class="line">    ((funcall goal-p (path-state (first paths)))</div><div class="line">     (values (first paths) paths))</div><div class="line">    (t (let* ((path (pop paths))</div><div class="line">              (state (path-state path)))</div><div class="line">         ;; Update PATHS and OLD-PATHS to reflect</div><div class="line">         ;; the new successors of STATE:</div><div class="line">         (setf old-paths (insert-path path old-paths))</div><div class="line">         (dolist (state2 (funcall successors state))</div><div class="line">           (let* ((cost (+ (path-cost-so-far path)</div><div class="line">                           (funcall cost-fn state state2)))</div><div class="line">                  (cost2 (funcall cost-left-fn state2))</div><div class="line">                  (path2 (make-path</div><div class="line">                           :state state2 :previous path</div><div class="line">                           :cost-so-far cost</div><div class="line">                           :total-cost (+ cost cost2)))</div><div class="line">                  (old nil))</div><div class="line">             ;; Place the new path, path2, in the right list:</div><div class="line">             (cond</div><div class="line">               ((setf old (find-path state2 paths state=))</div><div class="line">                (when (better-path path2 old)</div><div class="line">                  (setf paths (insert-path</div><div class="line">                                path2 (delete old paths)))))</div><div class="line">               ((setf old (find-path state2 old-paths state=))</div><div class="line">                (when (better-path path2 old)</div><div class="line">                  (setf paths (insert-path path2 paths))</div><div class="line">                  (setf old-paths (delete old old-paths))))</div><div class="line">               (t (setf paths (insert-path path2 paths))))))</div><div class="line">         ;; Finally, call A* again with the updated path lists:</div><div class="line">         (a*-search paths goal-p successors cost-fn cost-left-fn</div><div class="line">                    state= old-paths)))))</div></div><!-- fragment --><p>Вот три вспомогательные функции::</p>
<div class="fragment"><div class="line">(defun find-path (state paths state=)</div><div class="line">  &quot;Find the path with this state among a list of paths.&quot;</div><div class="line">  (find state paths :key #&#39;path-state :test state=))</div><div class="line"></div><div class="line">(defun better-path (pathl path2)</div><div class="line">  &quot;Is path1 cheaper than path2?&quot;</div><div class="line">  (&lt; (path-total-cost path1) (path-total-cost path2)))</div><div class="line"></div><div class="line">(defun insert-path (path paths)</div><div class="line">  &quot;Put path into the right position, sorted by total cost.&quot;</div><div class="line">  ;; MERGE is a built-in function</div><div class="line">  (merge &#39;list (list path) paths #&#39;&lt; :key #&#39;path-total-cost))</div><div class="line"></div><div class="line">(defun path-states (path)</div><div class="line">  &quot;Collect the states along this path.&quot;</div><div class="line">  (if (null path)</div><div class="line">      nil</div><div class="line">      (cons (path-state path)</div><div class="line">            (path-states (path-previous path)))))</div></div><!-- fragment --><p>Ниже мы используем <code>a*-search</code> для поиска 6 на графе, ранее показанном на <a href="#f0020">рис. 6.3</a>. Функция стоимости-это константа 1 для каждого шага. Другими словами, общая стоимость-это длина пути. Эвристическая функция оценки - это всего лишь отличие от цели. A* алгоритму требуется всего три шага поиска, чтобы найти оптимальное решение. Сравните это с алгоритмом поиска по графу, который требовал пяти шагов, и алгоритмом поиска по дереву, который требовал десяти шагов - и ни один из них не нашел оптимального решения.</p>
<div class="fragment"><div class="line">&gt; (path-states</div><div class="line">      (a*-search (list (make-path :state 1)) (is 6)</div><div class="line">                    #&#39;next2 #&#39;(lambda (x y) 1) (diff 6)))</div><div class="line">;; Search: (#&lt;Path to 1 cost 0.0  &gt;)</div><div class="line">;; Search: (#&lt;Path to 3 cost 4.0  &gt; #&lt;Path to 2 cost 5.0  &gt;)</div><div class="line">;; Search: (#&lt;Path to 5 cost 3.0  &gt; #&lt;Path to 4 cost 4.0  &gt;</div><div class="line">                #&lt;Path to 2 cost 5.0  &gt;)</div><div class="line">;; Search: (#&lt;Path to 6 cost 3.0  &gt; #&lt;Path to 7 cost 4.0  &gt;</div><div class="line">                #&lt;Path to 4 cost 4.0  &gt; #&lt;Path to 2 cost 5.0  &gt;)</div><div class="line">(6 5 3 1)</div></div><!-- fragment --><p>Может показаться ограничивающим, что все эти функции поиска возвращают один ответ. В некоторых приложениях мы можем рассматирвать несколько решений или все возможные решения. Другие приложения более естественно рассматривать как задачи оптимизации, где мы не знаем заранее, что считается достижением цели, но просто пытаемся найти какое-то действие приводящее к уменьшению стоимости решения.</p>
<p>Оказывается, что функции, которые мы определили, совсем не ограничивают нас в этом отношении. Они могут быть использованы для достижения обеих этих новых целей-при условии, что мы тщательно определим предикат цели. Чтобы найти все решения проблемы, всё, что нам нужно сделать, это определить и передать такой предикат цели, который всегда терпит неудачу, но сохраняет все решения в списке. Предикат цели будет видеть все возможные решения и сохранять только те, которые являются реальными решениями. Конечно, если пространство поиска бесконечно, это никогда не закончится, поэтому пользователь должен быть осторожен в применении этой техники. Также можно было бы написать предикат цели, который остановил бы поиск после нахождения определенного числа решений или после просмотра определенного числа состояний. Вот функция, которая находит все решения, используя поиск по лучу:</p>
<div class="fragment"><div class="line">(defun search-all (start goal-p successors cost-fn beam-width)</div><div class="line">  &quot;Find all solutions to a search problem, using beam search.&quot;</div><div class="line">  ;; Be careful: this can lead to an infinite loop.</div><div class="line">  (let ((solutions nil))</div><div class="line">    (beam-search</div><div class="line">      start #&#39;(lambda (x)</div><div class="line">              (when (funcall goal-p x) (push x solutions))</div><div class="line">              nil)</div><div class="line">      successors cost-fn beam-width)</div><div class="line">  solutions))</div></div><!-- fragment --><h2>6.5 GPS как поиск</h2>
<p>Программа GPS может рассматриваться как проблема поиска. Например, в мире трех блоков блоков есть только 13 различных состояний. Их можно было расположить в виде графа и искать точно так же, как мы искали маршрут между городами. <a href="#f0030">Рисунок 6.5</a> показывает этот граф.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter6/f06-05.jpg" alt="f06-05"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 6.5: мир блоков в виде графа </td></tr>
</table>
<p>Функция <code>search-gps</code> делает именно это. Например, функция gps на <a href="B9780080571157500042.xhtml#p135">стр. 135</a>, она вычисляет конечное состояние, а затем выбирает действия, которые приводят к этому состоянию. Но она вычисляет состояние с помощью поиска по лучу. Предикат цели проверяет, удовлетворяет ли текущее состояние каждому условию в цели, функция - successor находит все применимые операторы и применяет их, а функция стоимости просто суммирует количество действий, выполненных до сих пор, плюс количество условий, которые еще не выполнены:</p>
<div class="fragment"><div class="line">(defun search-gps (start goal &amp;optional (beam-width 10))</div><div class="line">  &quot;Search for a sequence of operators leading to goal.&quot;</div><div class="line">  (find-all-if</div><div class="line">    #&#39;action-p</div><div class="line">    (beam-search</div><div class="line">      (cons &#39;(start) start)</div><div class="line">      #&#39;(lambda (state) (subsetp goal state :test #&#39;equal))</div><div class="line">      #&#39;gps-successors</div><div class="line">      #&#39;(lambda (state)</div><div class="line">          (+ (count-if #&#39;action-p state)</div><div class="line">             (count-if #&#39;(lambda (con)</div><div class="line">                           (not (member-equal con state)))</div><div class="line">                       goal)))</div><div class="line">      beam-width)))</div></div><!-- fragment --><p>Вот функция определения преемников(successor):</p>
<div class="fragment"><div class="line">(defun gps-successors (state)</div><div class="line">  &quot;Return a list of states reachable from this one using ops.&quot;</div><div class="line">  (mapcar</div><div class="line">    #&#39;(lambda (op)</div><div class="line">        (append</div><div class="line">          (remove-if #&#39;(lambda (x)</div><div class="line">                         (member-equal x (op-del-list op)))</div><div class="line">                     state)</div><div class="line">          (op-add-list op)))</div><div class="line">    (applicable-ops state)))</div><div class="line"></div><div class="line">(defun applicable-ops (state)</div><div class="line">  &quot;Return a list of all ops that are applicable now.&quot;</div><div class="line">  (find-all-if</div><div class="line">    #&#39;(lambda (op)</div><div class="line">        (subsetp (op-preconds op) state :test #&#39;equal))</div><div class="line">    *ops*))</div></div><!-- fragment --><p>Техника поиска быстро находит хорошие решения для самых разных задач. Здесь мы видим решение аномалии Сассмана в мире трех блоков блоков:</p>
<div class="fragment"><div class="line">(setf start &#39;((c on a) (a on table) (b on table) (space on c)</div><div class="line">            (space on b) (space on table)))</div><div class="line">&gt; (search-gps start &#39;((a on b) (b on c)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE C FROM A TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM TABLE TO C))</div><div class="line">  (EXECUTING (MOVE A FROM TABLE TO B)))</div><div class="line">&gt; (search-gps start &#39;((b on c) (a on b)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE C FROM A TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM TABLE TO C))</div><div class="line">  (EXECUTING (MOVE A FROM TABLE TO B)))</div></div><!-- fragment --><p>В этих решениях мы ищем вперед от начала к цели; это совершенно отличается от подхода средство-анализа коненой цели (means-ends), при котором мы ищем назад от цели, для достижения которой ищем применимые операторы. Но мы могли бы сформулировать анализ конечных целей аналитически, как поиск вперед, просто переставив старт и цель: состояние цели GPS - это начальное состояние поиска, а предикат цели поиска проверяет, совпадает ли состояние с начальным состоянием GPS. Оставим это вам как упражнение.</p>
<h2>6.6 истории и литература</h2>
<p>Pattern matching is one of the most important tools for AI. As such, it is covered in most textbooks on Lisp. Good treatments include Abelson and Sussman (1984), <a href="B9780080571157500285.xhtml#bb1390">Wilensky (1986)</a>, <a href="B9780080571157500285.xhtml#bb1410">Winston and Horn (1988)</a>, and <a href="B9780080571157500285.xhtml#bb0680">Kreutzer and McKenzie (1990)</a>. An overview is presented in the "pattern-matching" entry in <em>Encyclopedia of AI</em> (<a href="B9780080571157500285.xhtml#bb1085">Shapiro 1990</a>).</p>
<p>Nilsson's <em>Problem</em>-*Solving Methods in Artificial Intelligence* (1971) was an early text-book that emphasized search as the most important defining characteristic of AI. More recent texts give less importance to search; Winston's <em>Artificial Intelligence</em> (1984) gives a balanced overview, and his <em>Lisp</em> (1988) provides implementations of some of the algorithms. They are at a lower level of abstraction than the ones in this chapter. Iterative deepening was first presented by <a href="B9780080571157500285.xhtml#bb0640">Korf (1985)</a>, and iterative broadening by <a href="B9780080571157500285.xhtml#bb0470">Ginsberg and Harvey (1990)</a>.</p>
<h2>6.7 Упражнения</h2>
<p><b>Exercise 6</b>.**3** [<b>m</b>] Напишите более общую версию <code>interaetive-interpreter</code>, чем та, которая определена в этой главе. Решите, какую функциональность можно определить, и укажите для них значения по умолчанию.</p>
<p><b>Exercise 6</b>.**4** [<b>m</b>] Определите версию <code>compose</code>, которая допускает любое количество аргументов, а не только два. Подсказка: вы можете использовать функцию <code>reduce</code>.</p>
<p><b>Exercise 6</b>.**5** [<b>m</b>] Определите версию <code>compose</code>, которая допускает любое количество аргументов, но более эффективна, чем ответ на предыдущее упражнение. Подсказка: попробуйте принимать решения, когда вызывается <code>compose</code> для построения результирующей функции, а не принимать одни и те же решения снова и снова каждый раз, когда вызывается результирующая функция.</p>
<p><b>Exercise 6</b>.**6** [<b>m</b>] Одна из проблем с <code>pat-match</code> состоит в том, что он придает особое значение символам, начинающимся с ?, Что означает, что они не могут использоваться для сопоставления с литеральным образцом. Определите образец, который буквально соответствует литеральному вводу, чтобы такие символы можно было сопоставить.</p>
<p><b>Exercise 6</b>.**7** [<b>m</b>] Обсудите плюсы и минусы программирования, управляемого данными, по сравнению с традиционным подходом.</p>
<p><b>Exercise 6</b>.**8** [<b>m</b>] Напишите версию <code>tree-search</code> используя явный цикл, а не рекурсию.</p>
<p><b>Exercise 6</b>.**9** [<b>m</b>] Функция <code>sorter</code> неэффективна по двум причинам: она вызывает <code>append</code>, который должен сделать копию первого аргумента, и сортирует весь результат, а не просто вставляет новые состояния в уже отсортированные <em>старые</em> состояния. Напишите более эффективный <code>sorter</code>.</p>
<p><b>Exercise 6</b>.**10** [<b>m</b>] Напишите версии <code>graph-search</code> и <code>a*-search</code>, которые используют хэш-таблицы, а не списки, чтобы проверить, было ли состояние замечено ранее.</p>
<p><b>Exercise 6</b>.**11** [<b>m</b>] Напишите функцию, которая вызывает <code>beam-search</code> для поиска первых <em>n</em> решений проблемы и возвращает их в виде списка.</p>
<p><b>Exercise 6</b>.**12** [<b>m</b>] На персональных компьютерах без оборудования с плавающей запятой расчет <code>air-distance</code> будет довольно медленным. Если для вас это проблема, договоритесь вычислять <code>xyz-coords</code> каждого города только один раз, а затем сохраните их, или сохраните полную таблицу расстояний между городами. Также предварительно вычислите и сохраните соседей каждого города.</p>
<p><b>Exercise 6</b>.**13** [<b>d</b>] Напишите версию GPS, которая использует поиск A* вместо поиска по лучу. Сравните две версии в различных областях.</p>
<p><b>Exercise 6</b>.**14** [<b>d</b>] Напишите версию GPS, которая учитывает стоимость для каждого оператора. Например, доставка ребенка в школу может стоить 2, а вызов лимузина для перевозки ребенка может стоить 100. Используйте эти стоимости вместо постоянной стоимости 1 для каждой операции.</p>
<p><b>Exercise 6</b>.**15** [<b>d</b>] Напишите версию GPS, которая использует инструменты поиска, но выполняет анализ средств и результатов.</p>
<h2>6.8 Ответы</h2>
<p><b>Answer 6</b>.**2** К сожалению, <code>pat-match</code> не всегда дает ответ. Проблема в том, что он будет повторно связывать сегментную переменную только в случае несоответствия остальной части шаблона после переменной сегмента. Во всех приведенных выше примерах "остальная часть шаблона после переменной сегмента" была всем шаблоном, поэтому <code>pat-match</code> всегда работал правильно. Но если переменная сегмента оказывается вложенной в список, то оставшаяся часть подсписка переменной сегмента является только частью остальной части всего образца, как показано в следующем примере:</p>
<div class="fragment"><div class="line">&gt; (pat-match &#39;(((?* ?x) (?* ?y)) ?x ?y) &#39;((a b c d ) (a b) (c d))) =&gt; NIL</div></div><!-- fragment --><p>Правильный ответ с <code>?x</code> связывается с <code>(a b)</code> и <code>?y</code> связывается с <code>(c d)</code>, не найден, потому что соответствие внутреннему сегменту выполнено успешно с <code>?x</code>, привязанным к <code>( )</code> и <code>?y</code> привязан к <code>(a b c d)</code>, и как только мы выйдем из внутреннего соответствия и вернемся на верхний уровень, для альтернативных привязок не будет возврата.</p>
<p><b>Answer 6</b>.**3** Следующая версия позволяет пользователю указать все четыре компонента цикла prompt-read-eval-print(REPL), а также потоки, которые будут использоваться для ввода и вывода. Значения по умолчанию устанавливаются как для интерпретатора Лиспа.</p>
<div class="fragment"><div class="line">(defun interactive-interpreter</div><div class="line">        (&amp;key (read #&#39;read) (eval #&#39;eval) (print #&#39;print)</div><div class="line">          (prompt &quot;&gt; &quot;) (input t) (output t))</div><div class="line">  &quot;Read an expression, evaluate it, and print the result.&quot;</div><div class="line">  (loop</div><div class="line">    (fresh-line output)</div><div class="line">    (princ prompt output)</div><div class="line">      (funcall print (funcall eval (funcall read input))</div><div class="line">              output)))</div></div><!-- fragment --><p>Вот еще одна версия, которая выполняет все вышеперечисленное, а также обрабатывает несколько значений и связывает различные "исторические переменные", которые связывает верхний уровень Lisp.</p>
<div class="fragment"><div class="line">(defun interactive-interpreter</div><div class="line">      (&amp;key (read #&#39;read) (eval #&#39;eval) (print #&#39;print)</div><div class="line">      (prompt &quot;&gt; &quot;) (input t) (output t))</div><div class="line">  &quot;Read an expression, evaluate it, and print the result(s).</div><div class="line">  Does multiple values and binds: * ** ***-+ ++ +++/ // ///&quot;</div><div class="line">  (let (* ** *** - + ++ +++ / // /// vals)</div><div class="line">    ;; The above variables are all special, except VALS</div><div class="line">    ;; The variable - holds the current input</div><div class="line">    ;; * *** *** are the 3 most recent values</div><div class="line">    ;; + ++ +++ are the 3 most recent inputs</div><div class="line">    ;;/ // /// are the 3 most recent lists of multiple-values</div><div class="line">    (loop</div><div class="line">      (fresh-line output)</div><div class="line">      (princ prompt output)</div><div class="line">      ;; First read and evaluate an expression</div><div class="line">      (setf - (funcall read input)</div><div class="line">          vals (multiple-value-list (funcall eval -)))</div><div class="line">      ;; Now update the history variables</div><div class="line">   (setf +++ ++     /// //     *** (first ///)   </div><div class="line">         ++ +       // /       ** (first //)     </div><div class="line">         + -        / vals     * (first /)) </div><div class="line">      ;; Finally print the computed value(s)</div><div class="line">      (dolist (value vals)</div><div class="line">        (funcall print value output)))))</div></div><!-- fragment --><p><b>Answer 6</b>.**4**</p>
<div class="fragment"><div class="line">(defun compose (&amp;rest functions)</div><div class="line">  &quot;Return the function that is the composition of all the args. i.e.</div><div class="line">(compose f g h) = (lambda (x) (f (g (h x)))).&quot; </div><div class="line">#&#39;(lambda (x)</div><div class="line">      (reduce #&#39;funcall functions :from-end t :initial-value x)))</div></div><!-- fragment --><p><b>Answer 6</b>.**5**</p>
<div class="fragment"><div class="line">(defun compose (&amp;rest functions)</div><div class="line">  &quot;Return the function that is the composition of all the args. i.e.</div><div class="line">(compose f g h) = (lambda (x) (f (g (h x)))).&quot;</div><div class="line">  (case (length functions)</div><div class="line">    (0 #&#39;identity)</div><div class="line">    (1 (first functions))</div><div class="line">    (2 (let ((f (first functions))</div><div class="line">            (g (second functions)))</div><div class="line">        #&#39;(lambda (x) (funcall f (funcall g x)))))</div><div class="line">    (t #&#39;(lambda (x)</div><div class="line">          (reduce #&#39;funcall functions :from-end t</div><div class="line">                  :initia1-value x)))))</div></div><!-- fragment --><p><b>Answer 6</b>.**8**</p>
<div class="fragment"><div class="line">(defun tree-search (states goal-p successors combiner)</div><div class="line">&quot;Find a state that satisfies goal-p.</div><div class="line">Start with states, and search according to successors and combiner.&quot;</div><div class="line">  (loop</div><div class="line">    (cond ((null states) (RETURN fail))</div><div class="line">          ((funcall goal-p (first states))</div><div class="line">          (RETURN (first states))</div><div class="line">          (t (setf states</div><div class="line">                  (funcall combiner</div><div class="line">                          (funcall successors (first states))</div><div class="line">                          (rest states))))))))</div></div><!-- fragment --><p><b>Answer 6</b>.**9**</p>
<div class="fragment"><div class="line">(defun sorter (cost-fn)</div><div class="line">  &quot;Return a combiner function that sorts according to cost-fn.&quot;</div><div class="line">  #&#39;(lambda (new old)</div><div class="line">      (merge &#39;list (sort new #&#39;&gt; :key cost-fn)</div><div class="line">          old #&#39;&gt; :key cost-fn)))</div></div><!-- fragment --><p><b>Answer 6</b>.**11**</p>
<div class="fragment"><div class="line">(defun search-n (start n goal-p successors cost-fn beam-width)</div><div class="line">  &quot;Find n solutions to a search problem, using beam search.&quot;</div><div class="line">  (let ((solutions nil))</div><div class="line">    (beam-search</div><div class="line">      start #&#39;(lambda (x)</div><div class="line">          (cond ((not (funcall goal-p x)) nil)</div><div class="line">              ((= n 0) x)</div><div class="line">              (t (decf n)</div><div class="line">                  (push x solutions)</div><div class="line">                  nil)))</div><div class="line">      successors cost-fn beam-width)</div><div class="line">    solutions))</div></div><!-- fragment --> <hr/>
<p><a href="#xfn0015">1</a> Макрос <code>handler-case</code> есть только в ANSI Common Lisp.</p>
<p><a href="#xfn0020">2</a> В качестве альтернативы можно было бы зарезервировать вопросительный знак только для переменных и использовать другие обозначения для этих операторов сопоставления. Подойдут ключевые слова, такие как <code>:and</code>, <code>:or</code>, <code>:is</code> и т. д.</p>
<p><a href="#xfn0025">3</a> Встроенная константа <code>most-positive-fixnum</code> - это большое целое число, самое большое, которое может быть выражено без использования больших чисел. Его значение зависит от реализации, но в большинстве Лиспов оно превышает 16 миллионов.</p>
<p><a href="#xfn0030">4</a> В <a href="B978008057115750008X.xhtml">Главе 8</a> мы увидим пример, когда туман рассеялся: когда-то символическое интегрирование рассматривалось как проблема поиска, но теперь новые математические результаты позволяют решать тот же класс задач интеграции без поиска.</p>
<p><a href="#xfn0035">5</a> Проницательный читатель поймет, что этот граф - не дерево. Разница между деревьями и графами и последствия для поиска будут рассмотрены позже. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
