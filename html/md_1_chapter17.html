<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 17</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 17 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Маркировка линейных диаграмм удовлетворением ограничений</h2>
<blockquote class="doxtable">
<p>Неверно думать о работе Вальса только как об изложении эпистемологии штриховых рисунков многогранников. </p>
</blockquote>
<p>Вместо этого я думаю, что это элегантный пример парадигмы, которую мы можем ожидать увидеть снова и снова.</p>
<blockquote class="doxtable">
<p>-Patrick Winston </p>
</blockquote>
<blockquote class="doxtable">
<p>The Psychology of Computer Vision (1975) </p>
</blockquote>
<p>Эта книга касается только тех областей ИИ, которые имеют дело с абстрактными рассуждениями. Есть и другая сторона искусственного интеллекта, область <em>робототехники</em>, которая связана с взаимодействием абстрактных рассуждений с реальным миром с помощью датчиков и двигателей. Робот получает входные данные от камер, микрофонов, сонара и сенсорных устройств и производит "выходной сигнал", перемещая свои придатки или генерируя звуки. Реальный мир - более беспорядочное место, чем абстрактные миры, которые мы рассматривали. Робот должен иметь дело с зашумленными данными, неисправными компонентами и другими агентами и событиями в мире, которые могут повлиять на изменения в окружающей среде.</p>
<p>Компьютерное зрение - это подраздел робототехники, который занимается интерпретацией визуальной информации. Низкоуровневое зрение принимает данные непосредственно с камеры и обнаруживает линии, области и текстуры. Мы не будем этим заниматься. Высокоуровневое зрение использует результаты низкоуровневого компонента для построения трехмерной модели объектов, изображенных на сцене. В этой главе рассматривается один небольшой аспект видения(зрения) высокого уровня.</p>
<h2>17.1 Проблема маркировки строк</h2>
<p>В этой главе мы рассмотрим проблему маркировки линейной диаграммы: имея список линий и вершин, в которых они пересекаются, как мы можем определить, что эти линии представляют? Например, даны девять линий на <a href="#f0010">рис. 17.1</a>, как мы можем интерпретировать диаграмму как куб?</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-01.jpg" alt="f17-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.1: Куб </td></tr>
</table>
<p>Прежде чем мы сможем пререйти к интерпретации, мы должны договориться о кандидатах. В конце концов, <a href="#f0010">рисунок 17.1</a> может быть просто шестиугольником с тремя линиями посередине. Для целей этой главы мы будем рассматривать только диаграммы, которые изображают один или несколько <em>многогранников-* трехмерных твердых фигур, поверхности которых являются плоскими гранями, ограниченными прямыми линиями. Кроме того, мы разрешаем только *трехгранные</em> вершины. То есть каждая вершина должна быть образована пересечением трех граней, как в углу куба, где вершина, передняя часть и сторона куба сходятся. Третье ограничение на диаграммы - недопустимость так называемых "случайных" вершин. Например, <a href="#f0010">рисунок 17.1</a> может быть изображением трех разных кубиков, висящих в пространстве, которые случайно выстраиваются так, что край одного выровнен с краем другого с нашей точки зрения. Предположим, что это не так.</p>
<p>Учитывая диаграмму, которая соответствует этим трем ограничениям, наша цель - идентифицировать каждую линию, помещая ее в один из трех классов:</p>
<ol type="1">
<li>Выпуклая линия разделяет две видимые грани многогранника так, что прямая от одной грани до другой проходит внутри многогранника. Он будет отмечен знаком плюс: +. !!!(p) {:.numlist}</li>
<li>Вогнутая линия разделяет две грани двух многогранников, так что линия между двумя пространствами проходит через пустое пространство. Он будет отмечен знаком минус: -. !!!(p) {:.numlist}</li>
<li>Граничная линия обозначает ту же физическую ситуацию, что и выпуклая линия, но диаграмма ориентирована таким образом, что видна только одна из двух граней многогранника. Таким образом, линия отмечает границу между многогранником и фоном. Он будет отмечен стрелкой: &amp;rarr ;. Двигаясь по линии от хвоста до точки стрелки, многогранник находится справа, а фон - слева. !!!(p) {:.numlist}</li>
</ol>
<p><a href="#f0015">Рисунок 17.2</a> показывает маркировку куба с использованием этих соглашений. Вершина A - это ближний угол куба, а три выходящие из нее прямые - выпуклые. Линии GD и DF - вогнутые линии, обозначающие стык между кубом и поверхностью, на которой он лежит. Остальные линии являются граничными линиями, указывающими на то, что между кубом и фоном нет физической связи, но есть другие стороны куба, которые нельзя увидеть.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-02.jpg" alt="f17-02"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.2: Куб, помеченный линией </td></tr>
</table>
<p>Техника маркировки линий, разработанная в этой главе, основана на простой идее. Сначала мы перечисляем все возможные вершины и все возможные обозначения для каждой вершины. Оказывается, в мире трехгранных многоугольников всего четыре разных типа вершин. Мы называем их вершинами L, Y, W и T. из-за их формы. Вершины Y и W также называются вилками и стрелками соответственно. Вершины перечислены на <a href="#f0020">рисунок 17.3</a>. Каждая вершина накладывает некоторые ограничения на составляющие ее линии. Например, в вершине W средняя линия может быть помечена знаком + или -, но не стрелкой.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-03.jpg" alt="f17-03"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.3: Возможные вершины и метки </td></tr>
</table>
<p>Каждая линия соединяет две вершины, поэтому должна удовлетворять обоим ограничениям. Это предлагает простой алгоритм для разметки диаграммы, основанный на распространении ограничений: сначала пометьте каждую вершину всеми возможными метками для типа вершины. L вершина имеет шесть возможностей, Y - пять, T - четыре, а W - три. Затем выберите вершину V. Рассмотрим соседнюю вершину N (то есть N и V соединены линией). N также будет иметь набор возможных меток. Если N и V согласовывают возможные обозначения линии между ними, то мы ничего не выиграем. Но если пересечение двух множеств возможностей меньше, чем множество возможностей V, то мы нашли ограничение на диаграмме. Мы соответствующим образом корректируем возможные маркировки N и V. Каждый раз, когда мы добавляем ограничение в вершину, мы повторяем весь процесс для всех соседних вершин, чтобы дать ограничению возможность распространиться как можно дальше. Когда каждая вершина была посещена хотя бы один раз и больше нет ограничений для распространения, тогда мы закончили.</p>
<p><a href="#f0025">Рисунок 17.4</a> иллюстрирует этот процесс. Слева начинаем с куба. Все вершины имеют все возможные обозначения, за исключением того, что мы знаем, что линия GD вогнута (-), что означает, что куб покоится на поверхности. Это ограничивает вершину D таким образом, что прямая DA должна быть выпуклой (+). На среднем рисунке ограничение на вершину D распространилось на вершину A, а на правом рисунке оно распространяется на вершину B. Скоро весь куб будет промаркирован уникальными метками.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-04.jpg" alt="f17-04"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.4: Распространение ограничений </td></tr>
</table>
<p>Многие диаграммы будут иметь уникальные(однозначно расставленные) метки в процессе распространения ограничений. Однако некоторые диаграммы неоднозначны. У них все еще будет несколько меток после завершения распространения ограничения. В этом случае мы можем искать решение. Просто выберите неоднозначную вершину, выберите одну из возможных меток для этой вершины и повторите процесс распространения/поиска ограничения. Продолжайте, пока диаграмма не станет однозначной или противоречивой.</p>
<p>На этом набросок алгоритма маркировки линий завершен. Теперь мы готовы к реализации программы маркировки. Её глоссарий находится на <a href="#f0030">рис. 17.5</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-05.jpg" alt="f17-05"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.5: Глоссарий программы маркировки линий </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<p>Две основные структуры данных - это диаграмма(diagram) и вершина(vertex). Можно было бы реализовать тип данных для <code>lines</code>(линий), но это не обязательно: линии неявно определяются двумя вершинами в их конечных точках.</p>
<p>Диаграмма полностью определяется списком вершин, поэтому для структы diagram(диаграммы) нужен только один слот. vertex(Вершина) же - более сложная структура. Каждая вершина имеет идентифицирующее имя(name) (обычно из одной буквы), тип вершины(type) (L, Y, W или T), список соседних вершин(neighboring) и список возможных меток/марок(possible labelings). Маркировка(labeling) - это список меток линии. Например, вершина Y изначально будет иметь список из пяти возможных меток. Если обнаруживается, что вершина является внутренней частью вогнутого угла, то она будет иметь единственную маркировку (- - -). Мы даем информацию о типе в слотах вершины, потому что это сложный тип данных. Синтаксис defstruct таков, что вы не можете указать: тип(type) без предварительного указания значения по умолчанию. Мы выбрали L в качестве значения по умолчанию для слота типа случайным образом, но обратите внимание, что было бы ошибкой указать <code>nil</code> в качестве значения по умолчанию, потому что <code>nil</code> не относится к правильному типу.</p>
<div class="fragment"><div class="line">(defstruct diagram &quot;A diagram is a list of vertexes.&quot; vertexes)</div><div class="line"></div><div class="line">(defstruct (vertex (:print-function print-vertex))</div><div class="line">  (name      nil :type atom)</div><div class="line">  (type      &#39;L  :type (member L Y W T))</div><div class="line">  (neighbors nil :type list)  ; of vertex</div><div class="line">  (labelings nil :type list)) ; of lists of (member + - L R)))))</div></div><!-- fragment --><p>Неоднозначная вершина будет иметь несколько маркировок, в то время как однозначная вершина имеет ровно одну, а вершина без маркировки указывает на невозможную диаграмму. Изначально мы не знаем, какие вершины какие, поэтому все они начинаются с нескольких возможных обозначений. Обратите внимание, что маркировка - это список, а не набор: порядок меток имеет значение и соответствует порядку соседних вершин. Функция possible-labelings дает список всех возможных маркировок для каждого типа вершины. Мы используем R и L вместо стрелок в качестве меток, потому что ориентация стрелок имеет значение. R означает, что когда вы путешествуете от вершины к ее соседу, многогранник находится справа, а фоновый объект - слева. Таким образом, R эквивалентно стрелке, указывающей от вершины. Буква L как раз наоборот.</p>
<div class="fragment"><div class="line">(defun ambiguous-vertex-p (vertex)</div><div class="line">  &quot;A vertex is ambiguous if it has more than one labeling.&quot;</div><div class="line">  (&gt; (number-of-labelings vertex) 1))</div><div class="line"></div><div class="line">(defun number-of-labelings (vertex)</div><div class="line">  (length (vertex-labelings vertex)))</div><div class="line"></div><div class="line">(defun impossible-vertex-p (vertex)</div><div class="line">  &quot;A vertex is impossible if it has no labeling.&quot;</div><div class="line">  (null (vertex-labelings vertex)))</div><div class="line"></div><div class="line">(defun impossible-diagram-p (diagram)</div><div class="line">  &quot;An impossible diagram is one with an impossible vertex.&quot;</div><div class="line">  (some #&#39;impossible-vertex-p (diagram-vertexes diagram)))</div><div class="line"></div><div class="line">(defun possible-labelings (vertex-type)</div><div class="line">  &quot;The list of possible labelings for a given vertex type.&quot;</div><div class="line">  ;; In these labelings, R means an arrow pointing away from</div><div class="line">  ;; the vertex, L means an arrow pointing towards it.</div><div class="line">  (case vertex-type</div><div class="line">    ((L) &#39;((R L)   (L R)   (+ R)   (L +)   (- L)   (R -)))</div><div class="line">    ((Y) &#39;((+ + +) (- - -) (L R -) (- L R) (R - L)))</div><div class="line">    ((T) &#39;((R L +) (R L -) (R L L) (R L R)))</div><div class="line">    ((W) &#39;((L R +) (- - +) (+ + -)))))</div></div><!-- fragment --><h2>17.2 Комбинирование ограничений и поиска</h2>
<p>Основная функция <code>print-labelings</code> принимает диаграмму в качестве входных данных, уменьшает количество меток на каждой вершине путем распространения ограничений, а затем выполняет поиск всех согласованных интерпретаций. Вывод печатается до и после каждого шага.</p>
<div class="fragment"><div class="line">(defun print-labelings (diagram)</div><div class="line">  &quot;Label the diagram by propagating constraints and then</div><div class="line">  searching for solutions if necessary.  Print results.&quot;</div><div class="line">  (show-diagram diagram &quot;~&amp;The initial diagram is:&quot;)</div><div class="line">  (every #&#39;propagate-constraints (diagram-vertexes diagram))</div><div class="line">  (show-diagram diagram</div><div class="line">                &quot;~2&amp;After constraint propagation the diagram is:&quot;)</div><div class="line">  (let* ((solutions (if (impossible-diagram-p diagram)</div><div class="line">                        nil</div><div class="line">                        (search-solutions diagram)))</div><div class="line">         (n (length solutions)))</div><div class="line">    (unless (= n 1)</div><div class="line">      (format t &quot;~2&amp;There are ~r solution~:p:&quot; n)</div><div class="line">      (mapc #&#39;show-diagram solutions)))</div><div class="line">  (values))</div></div><!-- fragment --><p>Функция <code>propagate-constraints</code>(распространять-ограничения) берет вершину и рассматривает ограничения, налагаемые соседними вершинами, чтобы получить список всех <code>propagate-constraints</code>(согласованных маркировок) для вершины. Если количество согласованных маркировок меньше, чем количество до того, как мы начали, тогда ограничения соседей повлияли на эту вершину, поэтому мы распространяем вновь найденные ограничения на эту вершину обратно каждому соседу. Функция возвращает nil и, таким образом, немедленно останавливает распространение, если есть невозможная вершина. В противном случае распространение продолжается до тех пор, пока не останется никаких изменений в маркировке.</p>
<p>Весь алгоритм распространения запускается вызовом <code>every in print-labelings,</code> который распространяет ограничения из каждой вершины диаграммы. Но не очевидно, что это все, что требуется. Разве после однократного распространения из каждой вершины не может быть другой вершины, которую нужно изменить? Единственная вершина, которая может нуждаться в перемаркировке, - это та, у которой был изменен сосед с момента ее последнего обновления. Но любую такую вершину посетило бы <code>propagate-constraint</code> (распространение ограничения), поскольку мы распространяемся на всех соседей. Таким образом, за один проход по вершинам в сочетании с рекурсивными вызовами будут найдены и применены все возможные ограничения.</p>
<p>Следующий вопрос, который стоит задать, - гарантировано ли завершение работы алгоритма. Ясно, что это так, потому что <code>propagate-constraints</code>(распространение ограничения) может производить рекурсивные вызовы только тогда, когда удаляет метку. Но так как изначально существует конечное число разметок (не более шести на вершину), должно быть конечное количество вызовов для <code>propagate-constraints.</code></p>
<div class="fragment"><div class="line">(defun propagate-constraints (vertex)</div><div class="line">  &quot;Reduce the labelings on vertex by considering neighbors.</div><div class="line">  If we can reduce, propagate the constraints to each neighbor.&quot;</div><div class="line">  ;; Return nil only when the constraints lead to an impossibility</div><div class="line">  (let ((old-num (number-of-labelings vertex)))</div><div class="line">    (setf (vertex-labelings vertex) (consistent-labelings vertex))</div><div class="line">    (unless (impossible-vertex-p vertex)</div><div class="line">      (when (&lt; (number-of-labelings vertex) old-num)</div><div class="line">        (every #&#39;propagate-constraints (vertex-neighbors vertex)))</div><div class="line">      t)))</div></div><!-- fragment --><p>Вершина передается функции <code>consistent-labelings</code>(согласовать метки). Она получает все метки для этой вершины от соседних вершин, собирая их в <code>neighbor-labels</code>(метки соседей). Затем она проверяет все метки на текущей вершине, оставляя только те, которые согласуются со всеми ограничениями соседей. Вспомогательная функция <code>labels-for</code> находит метки для конкретного соседа у вершины, и <code>reverse-label</code> учитывает тот факт, что метки L и R интерпретируются относительно вершины, на которую они указывают.</p>
<div class="fragment"><div class="line">(defun consistent-labelings (vertex)</div><div class="line">  &quot;Return the set of labelings that are consistent with neighbors.&quot;</div><div class="line">  (let ((neighbor-labels</div><div class="line">          (mapcar #&#39;(lambda (neighbor) (labels-for neighbor vertex))</div><div class="line">                  (vertex-neighbors vertex))))</div><div class="line">    ;; Eliminate labelings that don&#39;t have all lines consistent</div><div class="line">    ;; with the corresponding line&#39;s label from the neighbor.</div><div class="line">    ;; Account for the L-R mismatch with reverse-label.</div><div class="line">    (find-all-if</div><div class="line">      #&#39;(lambda (labeling)</div><div class="line">          (every #&#39;member (mapcar #&#39;reverse-label labeling)</div><div class="line">                 neighbor-labels))</div><div class="line">      (vertex-labelings vertex))))</div></div><!-- fragment --><p>Распространения ограничений часто бывает достаточно, чтобы получить уникальную интерпретацию. Но иногда диаграмма все же недостаточно ограничена, и нам придется выполнить поиск для решения. Функция <code>search-solutions</code> сначала проверяет, является ли диаграмма неоднозначной, проверяя, есть ли у нее неоднозначная вершина v. Если диаграмма недвусмысленна(т.е однозначна), то это решение, и мы его возвращаем (в виде списка, поскольку <code>since search-solutions</code> предназначен для возврата списка всех решений). В противном случае для каждой из возможных меток для неоднозначной вершины мы создаем новую копию диаграммы и устанавливаем метку вершины v в копии в одну из возможных меток. Фактически, мы предполагаем, что маркировка правильная. Мы вызываем <code>propagate-constraints;</code> если она возвращает сбой(fails), значит, мы ошиблись, поэтому нет никаких решений с такой маркировкой(метка установлена не правильно). Но если она возвращает успех, мы рекурсивно вызываем <code>search-solutions</code>, чтобы получить список решений, сгенерированных с этой меткой.</p>
<div class="fragment"><div class="line">(defun search-solutions (diagram)</div><div class="line">  &quot;Try all labelings for one ambiguous vertex, and propagate.&quot;</div><div class="line">  ;; If there is no ambiguous vertex, return the diagram.</div><div class="line">  ;; If there is one, make copies of the diagram trying each of</div><div class="line">  ;; the possible labelings.  Propagate constraints and append</div><div class="line">  ;; all the solutions together.</div><div class="line">  (let ((v (find-if #&#39;ambiguous-vertex-p</div><div class="line">                    (diagram-vertexes diagram))))</div><div class="line">    (if (null v)</div><div class="line">        (list diagram)</div><div class="line">        (mapcan</div><div class="line">          #&#39;(lambda (v-labeling)</div><div class="line">              (let* ((diagram2 (make-copy-diagram diagram))</div><div class="line">                     (v2 (find-vertex (vertex-name v) diagram2)))</div><div class="line">                (setf (vertex-labelings v2) (list v-labeling))</div><div class="line">                (if (propagate-constraints v2)</div><div class="line">                    (search-solutions diagram2)</div><div class="line">                    nil)))</div><div class="line">          (vertex-labelings v)))))</div></div><!-- fragment --><p>Вот и все, что касается алгоритма; остались лишь вспомогательные функции. Вот три из них:</p>
<div class="fragment"><div class="line">(defun labels-for (vertex from)</div><div class="line">  &quot;Return all the labels for the line going to vertex.&quot;</div><div class="line">  (let ((pos (position from (vertex-neighbors vertex))))</div><div class="line">    (mapcar #&#39;(lambda (labeling) (nth pos labeling))</div><div class="line">            (vertex-labelings vertex))))</div><div class="line"></div><div class="line">(defun reverse-label (label)</div><div class="line">  &quot;Account for the fact that one vertex&#39;s right is another&#39;s left.&quot;</div><div class="line">  (case label (L &#39;R) (R &#39;L) (otherwise label)))</div><div class="line"></div><div class="line">(defun find-vertex (name diagram)</div><div class="line">  &quot;Find the vertex in the given diagram with the given name.&quot;</div><div class="line">  (find name (diagram-vertexes diagram) :key #&#39;vertex-name))</div></div><!-- fragment --><p>Вот функции печати. <code>print-vertex</code> печатает вершину в краткой форме. Она подчиняется соглашению <code>print</code> о возврате первого аргумента. Функции <code>show-vertex</code> и <code>show-diagram</code> печатают более подробные формы. Они подчиняются соглашению о функциях, подобных <code>describe</code>, т.е. о том, что они вообще не возвращают никаких значений.</p>
<div class="fragment"><div class="line">(defun print-vertex (vertex stream depth)</div><div class="line">  &quot;Print a vertex in the short form.&quot;</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;~a/~d&quot; (vertex-name vertex)</div><div class="line">          (number-of-labelings vertex))</div><div class="line">  vertex)</div><div class="line"></div><div class="line">(defun show-vertex (vertex &amp;optional (stream t))</div><div class="line">  &quot;Print a vertex in a long form, on a new line.&quot;</div><div class="line">  (format stream &quot;~&amp;   ~a ~d:&quot; vertex (vertex-type vertex))</div><div class="line">  (mapc #&#39;(lambda (neighbor labels)</div><div class="line">            (format stream &quot; ~a~a=[~{~a~}]&quot; (vertex-name vertex)</div><div class="line">                    (vertex-name neighbor) labels))</div><div class="line">        (vertex-neighbors vertex)</div><div class="line">        (matrix-transpose (vertex-labelings vertex)))</div><div class="line">  (values))</div><div class="line"></div><div class="line">(defun show-diagram (diagram &amp;optional (title &quot;~2&amp;Diagram:&quot;)</div><div class="line">                             (stream t))</div><div class="line">  &quot;Print a diagram in a long form.  Include a title.&quot;</div><div class="line">  (format stream title)</div><div class="line">  (mapc #&#39;show-vertex (diagram-vertexes diagram))</div><div class="line">  (let ((n (reduce #&#39;* (mapcar #&#39;number-of-labelings</div><div class="line">                               (diagram-vertexes diagram)))))</div><div class="line">  (when (&gt; n 1)</div><div class="line">    (format stream &quot;~&amp;For ~:d interpretation~:p.&quot; n))</div><div class="line">  (values)))</div></div><!-- fragment --><p>Обратите внимание, что <code>matrix-transpose</code> вызывается <code>show-vertex</code>, чтобы перевернуть матрицу меток на свою сторону. Это работает так:</p>
<div class="fragment"><div class="line">(possible-labelings &#39;Y)</div><div class="line">((+ + +)</div><div class="line">  (- - -)</div><div class="line">  (L R -)</div><div class="line">  (- L R)</div><div class="line">  (R - L))</div><div class="line">(matrix-transpose (possible-labelings &#39;Y))</div><div class="line">((+ - L - R)</div><div class="line">  (+ - R L -)</div><div class="line">  (+ - - R L))</div></div><!-- fragment --><p>Реализация <code>matrix-transpose</code> на удивление лаконична. Это старый Lisp-трюк, и его стоит понять:</p>
<div class="fragment"><div class="line">(defun matrix-transpose (matrix)</div><div class="line">  &quot;Turn a matrix on its side.&quot;</div><div class="line">  (if matrix (apply #&#39;mapcar #&#39;list matrix)))</div></div><!-- fragment --><p>Оставшийся код связан с созданием диаграмм. Нам нужен удобный способ задания диаграмм. Один из способов - программа распознавания линий, работающая на оцифрованном вводе с камеры или растрового изображения. Другая возможность - интерактивная программа рисования, использующая мышь и отображение растрового изображения. Но поскольку пока нет стандарта Common Lisp для взаимодействия с такими устройствами, нам придется довольствоваться текстовым описанием. Макрос <code>defdiagram</code> определяет диаграмму и дает ей имя. За именем следует список описаний вершин. Каждое описание представляет собой список, состоящий из имени вершины, типа вершины (Y, A, L или T) и имен соседних вершин. Вот снова описание <code>defdiagram</code> для куба, показанного на <a href="#f0035">рис. 17.6</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-06.jpg" alt="f17-06"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.6: Куб </td></tr>
</table>
<div class="fragment"><div class="line">(defdiagram cube</div><div class="line">  (a Y b c d)</div><div class="line">  (b W g e a)</div><div class="line">  (c W e f a)</div><div class="line">  (d W f g a)</div><div class="line">  (e L c b)</div><div class="line">  (f L d c)</div><div class="line">  (g L b d))</div></div><!-- fragment --><p>Макрос <code>defdiagram</code> вызывает <code>construct-diagram</code> для выполнения реальной работы. Было бы возможно преобразовать <code>defdiagram</code> в <code>defvar</code>, сделав имена специальными переменными. Но тогда ответственность за создание копий такой переменной перед ее передачей деструктивной функции будет лежать на пользователе. Вместо этого я использую <code>put-diagram</code> и <code>diagram</code> для размещения и получения диаграмм в таблице, <code>diagram</code> извлекает названную диаграмму и делает ее копию. Таким образом, пользователь не может повредить исходные диаграммы, хранящиеся в таблице. Другой возможностью было бы расширение <code>defdiagram</code> в определение функции для <code>name</code>, возвращающей копию диаграммы. Я решил хранить пространство имен диаграммы отдельно от пространства имен функций, поскольку имена вроде <code>cube</code> имеют смысл в обоих пространствах.</p>
<div class="fragment"><div class="line">(defmacro defdiagram (name &amp;rest vertex-descriptors)</div><div class="line">  &quot;Define a diagram.  A copy can be gotten by (diagram name).&quot;</div><div class="line">  `(put-diagram &#39;,name (construct-diagram</div><div class="line">                         (check-diagram &#39;,vertex-descriptors))))</div><div class="line"></div><div class="line">(let ((diagrams (make-hash-table)))</div><div class="line"></div><div class="line">(defun diagram (name)</div><div class="line">  &quot;Get a fresh copy of the diagram with this name.&quot;</div><div class="line">  (make-copy-diagram (gethash name diagrams)))</div><div class="line"></div><div class="line">(defun put-diagram (name diagram)</div><div class="line">  &quot;Store a diagram under a name.&quot;</div><div class="line">  (setf (gethash name diagrams) diagram)</div><div class="line">  name))</div></div><!-- fragment --><p>Функция <code>construct-diagram</code> переводит описание каждой вершины, используя <code>construct-vertex</code>, а затем заполняет соседей каждой вершины.</p>
<div class="fragment"><div class="line">(defun construct-diagram (vertex-descriptors)</div><div class="line">  &quot;Build a new diagram from a set of vertex descriptor.&quot;</div><div class="line">  (let ((diagram (make-diagram)))</div><div class="line">    ;; Put in the vertexes</div><div class="line">    (setf (diagram-vertexes diagram)</div><div class="line">          (mapcar #&#39;construct-vertex vertex-descriptors))</div><div class="line">    ;; Put in the neighbors for each vertex</div><div class="line">    (dolist (v-d vertex-descriptors)</div><div class="line">      (setf (vertex-neighbors (find-vertex (first v-d) diagram))</div><div class="line">            (mapcar #&#39;(lambda (neighbor)</div><div class="line">                        (find-vertex neighbor diagram))</div><div class="line">                    (v-d-neighbors v-d))))</div><div class="line">    diagram))</div><div class="line"></div><div class="line">(defun construct-vertex (vertex-descriptor)</div><div class="line">  &quot;Build the vertex corresponding to the descriptor.&quot;</div><div class="line">  ;; Descriptors are like: (x L y z)</div><div class="line">  (make-vertex</div><div class="line">    :name (first vertex-descriptor)</div><div class="line">    :type (second vertex-descriptor)</div><div class="line">    :labelings (possible-labelings (second vertex-descriptor))))</div><div class="line"></div><div class="line">(defun v-d-neighbors (vertex-descriptor)</div><div class="line">  &quot;The neighboring vertex names in a vertex descriptor.&quot;</div><div class="line">  (rest (rest vertex-descriptor)))</div></div><!-- fragment --><p><code>defstruct</code> для <code>diagram</code> автоматически создает функцию <code>copy-diagram</code>, но она просто копирует каждое поле, не копируя содержимое каждого поля. Таким образом, нам нужно <code>make-copy-diagram</code> для создания копии, не имеющей общей структуры с оригиналом.</p>
<div class="fragment"><div class="line">(defun make-copy-diagram (diagram)</div><div class="line">  &quot;Make a copy of a diagram, preserving connectivity.&quot;</div><div class="line">  (let* ((new (make-diagram</div><div class="line">                :vertexes (mapcar #&#39;copy-vertex</div><div class="line">                                  (diagram-vertexes diagram)))))</div><div class="line">    ;; Put in the neighbors for each vertex</div><div class="line">    (dolist (v (diagram-vertexes new))</div><div class="line">      (setf (vertex-neighbors v)</div><div class="line">            (mapcar #&#39;(lambda (neighbor)</div><div class="line">                        (find-vertex (vertex-name neighbor) new))</div><div class="line">                    (vertex-neighbors v))))</div><div class="line">    new))</div></div><!-- fragment --><h2>17.3 Маркировка Диаграм</h2>
<p>Теперь мы готовы попробовать маркировку диаграмм. Сначала куб:</p>
<div class="fragment"><div class="line">&gt; (print-labelings (diagram &#39;cube))</div><div class="line">The initial diagram is:</div><div class="line">  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]</div><div class="line">  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]</div><div class="line">  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]</div><div class="line">  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]</div><div class="line">  E/6 L: EC=[RL+L-R] EB=[LRR+L-]</div><div class="line">  F/6 L: FD=[RL+L-R] FC=[LRR+L-]</div><div class="line">  G/6 L: GB=[RL+L-R] GD=[LRR+L-]</div></div><!-- fragment --><p><code>For 29,160 interpr</code>e<code>tations.</code></p>
<div class="fragment"><div class="line">After constraint propagation the diagram is:</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/2 W: BG=[L-] BE=[R-] BA=[++]</div><div class="line">  C/2 W: CE=[L-] CF=[R-] CA=[++]</div><div class="line">  D/2 W: DF=[L-] DG=[R-] DA=[++]</div><div class="line">  E/3 L: EC=[R-R] EB=[LL-]</div><div class="line">  F/3 L: FD=[R-R] FC=[LL-]</div><div class="line">  G/3 L: GB=[R-R] GD=[LL-]</div></div><!-- fragment --><p><code>For 216 interpr</code>e<code>tations.</code></p>
<div class="fragment"><div class="line">There are four solutions:</div><div class="line">Diagram:</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/1 W: BG=[L] BE=[R] BA=[+]</div><div class="line">  C/l W: CE=[L] CF=[R] CA=[+]</div><div class="line">  D/1 W: DF=[L] DG=[R] DA=[+]</div><div class="line">  E/l L: EC=[R] EB=[L]</div><div class="line">  F/1 L: FD=[R] FC=[L]</div><div class="line">  G/1 L: GB=[R] GD=[L]</div><div class="line">  Diagram:</div><div class="line">  A/1 Y: AD=[+] AC=[+] AD=[+]</div><div class="line">  B/1 W: BG=[L] BE=[R] BA=[+]</div><div class="line">  C/l W: CE=[L] CF=[R] CA=[+]</div><div class="line">  D/1 W: DF=[-] DG=[-] DA=[+]</div><div class="line">  E/l L: EC=[R] EB=[L]</div><div class="line">  F/1 L: FD=[-] FC=[L]</div><div class="line">  G/1 L: GB=[R] GD=[-]</div><div class="line">Diagram:</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/1 W: BG=[L] BE=[R] BA=[+]</div><div class="line">  C/l W: CE=[-] CF=[-] CA=[+]</div><div class="line">  D/1 W: DF=[L] DG=[R] DA=[+]</div><div class="line">  E/l L: EC=[-] EB=[L]</div><div class="line">  F/1 L: FD=[R] FC=[-]</div><div class="line">  G/1 L: GB=[R] GD=[L]</div><div class="line">Diagram:</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/1 W: BG=[-] BE=[-] BA=[+]</div><div class="line">  C/1 W: CE=[L] CF=[R] CA=[+]</div><div class="line">  D/1 W: DF=[L] DG=[R] DA=[+]</div><div class="line">  E/1 L: EC=[R] EB=[-]</div><div class="line">  F/1 L: FD=[R] FC=[L]</div><div class="line">  G/1 L: GB=[-] GD=[L]</div></div><!-- fragment --><p>Четыре интерпретации соответствуют, соответственно, случаям, когда куб свободно плавает, прикреплен к полу (GD и DF = -), прикреплен к стене справа (EC и CF = -) или прикреплен к стене на слева (BG и BE = -). Они показаны на <a href="#f0040">рисунок 17.7</a>. Было бы неплохо, если бы мы могли предоставить информацию о том, где прикреплен куб, и посмотреть, сможем ли мы получить уникальную интерпретацию. Функция <code>ground</code>(земля) принимает диаграмму и модифицирует ее, делая одну или несколько линий линиями примыкающими к земле - линиями, имеющими вогнутую (-) метку, соответствующую месту соединения с землей.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-07.jpg" alt="f17-07"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.7: Четыре интерпретации куба </td></tr>
</table>
<div class="fragment"><div class="line">(defun ground (diagram vertex-a vertex-b)</div><div class="line">  &quot;Attach the line between the two vertexes to the ground.</div><div class="line">  That is, label the line with a -&quot;</div><div class="line">  (let* ((A (find-vertex vertex-a diagram))</div><div class="line">         (B (find-vertex vertex-b diagram))</div><div class="line">         (i (position B (vertex-neighbors A))))</div><div class="line">    (assert (not (null i)))</div><div class="line">    (setf (vertex-labelings A)</div><div class="line">          (find-all-if #&#39;(lambda (l) (eq (nth i l) &#39;-))</div><div class="line">                     (vertex-labelings A)))</div><div class="line">    diagram))</div></div><!-- fragment --><p>Мы можем увидеть, как это работает на кубе:</p>
<div class="fragment"><div class="line">&gt; (print-labelings (ground (diagram &#39;cube) &#39;g &#39;d))</div><div class="line">The initial diagram is:</div><div class="line">  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]</div><div class="line">  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]</div><div class="line">  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]</div><div class="line">  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]</div><div class="line">  E/6 L: EC=[RL+L-R] EB[LRR+L-]</div><div class="line">  F/6 L: FD=[RL+L-R] FC=[LRR+L-]</div><div class="line">  G/1 L: GB=[R] GD=[-]</div></div><!-- fragment --><p><code>For 4,860 interpr</code>e<code>tations.</code></p>
<div class="fragment"><div class="line">After constraint propagation the diagram is:</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/l W: BG=[L] BE=[R] BA=[+]</div><div class="line">  C/l W: CE=[L] CF=[R] CA=[C  +]</div><div class="line">  D/l W: DF=[-] DG=[-] DA=[+]</div><div class="line">  E/l L: EC=[R] EB=[L]</div><div class="line">  F/1 L: FD=[-] FC=[L]</div><div class="line">  G/1 L: GB=[R] GD=[-]</div></div><!-- fragment --><p>Обратите внимание, что пользователю нужно было указать только одну из двух линий примыкающих к земле, GD. Программа обнаружила, что DF тоже заземлен. Точно так же при программировании <code>ground-line</code>(наземной линии) нам нужно было обновить только одну из вершин. Остальное делается путем распространения ограничений.</p>
<p>Следующий пример дает те же четыре интерпретации в том же порядке (свободно плавающий, прикрепленный снизу, прикрепленный справа и прикрепленный слева) при интерпретации без земли. Заземленная версия дает уникальное решение, показанное в следующих выходных данных и на <a href="#f0050">рис. 17.9</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-08.jpg" alt="f17-08"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.8: Куб на тарелке </td></tr>
</table>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-09.jpg" alt="f17-09"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.9: Промаркированный куб на тарелке </td></tr>
</table>
<div class="fragment"><div class="line">(defdiagram cube-on-plate</div><div class="line">  (a Y b c d)</div><div class="line">  (b W g e a)</div><div class="line">  (c W e f a)</div><div class="line">  (d W f g a)</div><div class="line">  (e L c b)</div><div class="line">  (f Y d c i)</div><div class="line">  (g Y b d h)</div><div class="line">  (h W l g j)</div><div class="line">  (i W f m j)</div><div class="line">  (j Y h i k)</div><div class="line">  (k W m l j)</div><div class="line">  (l L h k)</div><div class="line">  (m L k i))</div><div class="line">&gt; (print-labelings (ground (diagram &#39;cube-on-plate) &#39;k &#39;m))</div><div class="line">The initial diagram is:</div><div class="line">  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]</div><div class="line">  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]</div><div class="line">  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]</div><div class="line">  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]</div><div class="line">  E/6 L: EC=[RL+L-R] EB=[LRR+L-]</div><div class="line">  F/5 Y: FD=C+-L-R] FC=[+-RL-] FI=[+--RL]</div><div class="line">  G/5 Y: GB=[+-L-R] GD=[+-RL-] GH=[+--RL]</div><div class="line">  H/3 W: HL=[L-+] HG=[R-+] HJ=[++-]</div><div class="line">  I/3 W: IF=[L-+] IM=[R-+] IJ=[++-]</div><div class="line">  J/5 Y: JH=[+-L-R] JI=[+-RL-] JK=[+--RL]</div><div class="line">  K/1 W: KM=[-] KL=[-] KJ=[+]</div><div class="line">  L/6 L: LH=[RL+L-R] LK=[LRR+L-]</div><div class="line">  M/6 L: MK=[RL+L-R] MI=[LRR+L-]</div></div><!-- fragment --><p><code>For 32.805.000 interpr</code>e<code>tations.</code></p>
<div class="fragment"><div class="line">After constraint propagation the diagram is</div><div class="line">  A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">  B/2 W: BG=[L-] BE=[R-] BA=[++]</div><div class="line">  C/2 W: CE=[L-] CF=[R-] CA=[++]</div><div class="line">  D/2 W: DF=[L-] DG=[R-] DA=[++]</div><div class="line">  E/1 L: EC=[R] EB=[L]</div><div class="line">  F/1 Y: FD=[-] FC=[L] FI=[R]</div><div class="line">  G/1 Y: GB=[R] GD=[-] GH=[L]</div><div class="line">  H/1 W: HL=[L] HG=[R] HJ=[+]</div><div class="line">  I/1 W: IF=[L] IM=[R] IJ=[+]</div><div class="line">  J/1 Y: JH=[+] JI=[+] JK=[+]</div><div class="line">  K/1 W: KM=[-] KL=[-] KJ=[+]</div><div class="line">  L/1 L: LH=[R] LK=[-]</div><div class="line">  M/1 L: MK=[-] MI=[L]</div></div><!-- fragment --><p>Интересно опробовать алгоритм на "невозможной" диаграмме. Оказывается, алгоритм не находит никакой интерпретации этой хорошо известной иллюзии:</p>
<div class="fragment"><div class="line">(defdiagram poiuyt</div><div class="line">  (a L b g)</div><div class="line">  (b L j a)</div><div class="line">  (c L d l)</div><div class="line">  (d L h c)</div><div class="line">  (e L f i)</div><div class="line">  (f L k e)</div><div class="line">  (g L a l)</div><div class="line">  (h L l d)</div><div class="line">  (i L e k)</div><div class="line">  (j L k b)</div><div class="line">  (k W j i f)</div><div class="line">  (l W h g c))</div><div class="line">&gt; (print-1 abel ings (diagram &#39;poiuyt))</div><div class="line">The initial diagram is:</div><div class="line">  A/6 L: AB=[RL+L-R] AG=[LRR+L-]</div><div class="line">  B/6 L: BJ=[RL+L-R] BA=[LRR+L-]</div><div class="line">  C/6 L: CD=[RL+L-R] CL=[LRR+L-]</div><div class="line">  D/6 L: DH=[RL+L-R] DC=[LRR+L-]</div><div class="line">  E/6 L: EF=[RL+L-R] EI=[LRR+L-]</div><div class="line">  F/6 L: FK=[RL+L-R] FE=[LRR+L-]</div><div class="line">  G/6 L: GA=[RL+L-R] GL=[LRR+L-]</div><div class="line">  H/6 L: HL=[RL+L-R] HD=[LRR+L-]</div><div class="line">  I/6 L: IE=[RL+L-R] IK=[LRR+L-]</div><div class="line">  J/6 L: JK=[RL+L-R] JB=[LRR+L-]</div><div class="line">  K/3 W: KJ=[L-+] KI=[R-+] KF=[++-]</div><div class="line">  L/3 W: LH=[L-+] LG=[R-+] LC=[++-]</div></div><!-- fragment --><p><code>For 544,195.584 interpr</code>e<code>tations.</code></p>
<div class="fragment"><div class="line">After constraint propagation the diagram is:</div><div class="line">  A/5 L: AB=[RL+-R] AG=[LRRL-]</div><div class="line">  B/5 L: BJ=[RLL-R] BA=[LR+L-]</div><div class="line">  C/2 L: CD=[LR] CL=[+-]</div><div class="line">  D/3 L: DH=[RL-] DC=[LRL]</div><div class="line">  E/3 L: EF=[RLR] EI=[LR-]</div><div class="line">  F/2 L: FK=[+-] FE=[RL]</div><div class="line">  G/4 L: GA=[RL-R] GL=[L+L-]</div><div class="line">  H/4 L: HL=[R+-R] HD=[LRL-]</div><div class="line">  I/4 L: IE=[RL-R] IK=[L+L-]</div><div class="line">  J/4 L: JK=[R+-R] JB=[LRL-]</div><div class="line">  K/3 W: KJ=[L-+] KI=[R-+] KF=[++-]</div><div class="line">  L/3 W: LH=[L-+] LG=[R-+] LC=[++-]</div></div><!-- fragment --><p><code>For 2,073,600 interpr</code>e<code>tations.</code></p>
<p><code>There are z</code>e<code>ro solutions:</code></p>
<p>Теперь попробуем более сложную диаграмму(схему):</p>
<div class="fragment"><div class="line">(defdiagram tower</div><div class="line">  (a Y b c d)    (n L q o)</div><div class="line">  (b W g e a)    (o W y j n)</div><div class="line">  (c W e f a)    (P L r i)</div><div class="line">  (d W f g a)    (q W n s w)</div><div class="line">  (e L c b)      (r W s p x)</div><div class="line">  (f Y d c i)    (s L r q)</div><div class="line">  (g Y b d h)    (t W w x z)</div><div class="line">  (h W l g J)    (u W x y z)</div><div class="line">  (i W f m p)    (v W y w z)</div><div class="line">  (j Y h o k)    (w Y t v q)</div><div class="line">  (k W m l j)    (x Y r u t)</div><div class="line">  (l L h k)      (y Y v u o)</div><div class="line">  (m L k i)      (z Y t u v))</div><div class="line">&gt; (print-labelings (ground (diagram &#39;tower) &#39;l &#39;k))</div><div class="line">The initial diagram is:</div><div class="line">  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]</div><div class="line">  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]</div><div class="line">  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]</div><div class="line">  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]</div><div class="line">  E/6 L: EC[RL+L-R] EB=[LRR+L-]</div><div class="line">  F/5 Y: FD=[+-L-R] FC=[+-RL-] FI=[+--RL]</div><div class="line">  G/5 Y: GB=[+-L-R] GD=[+-RL-] GH=[+--RL]</div><div class="line">  H/3 W: HL=[L-+] HG=[R-+] HJ=[++-]</div><div class="line">  I/3 W: IF=[L-+] IM=[R-+] IP=[++-]</div><div class="line">  J/5 Y: JH=[+-L-R] JO=[+-RL-] JK=[+--RL]</div><div class="line">  K/3 W: KM=[L-+] KL=[R-+] KJ=[++-]</div><div class="line">  L/1 L: LH=[R] LK=[-]</div><div class="line">  M/6 L: MK=[RL+L-R] MI=[LRR+L-]</div><div class="line">  N/6 L: NQ=[RL+L-R] NO=[LRR+L-]</div><div class="line">  O/3 W: OY=[L-+] OJ=[R-+] ON=[++-]</div><div class="line">  P/6 L: PR=[RL+L-R] PI=[LRR+L-]</div><div class="line">  Q/3 W: QN=[L-+] QS=[R-+] QW=[++-]</div><div class="line">  R/3 W: RS=[L-+] RP=[R-+] RX=[++-]</div><div class="line">  S/6 L: SR=[RL+L-R] SQ=[LRR+L-]</div></div><!-- fragment --><p><code>T/3 W:</code> TW=[L-+] <code>TX=[R-+] TZ=[++-]</code></p>
<div class="fragment"><div class="line">  U/3 W: UX=[L-+] UY=[R-+] UZ=[++-]</div><div class="line">  V/3 W: VY=[L-+] VW=[R-+] VZ=[++-]</div><div class="line">  W/5 Y: WT=[+-L-R] WV=[+-RL-] WQ=[+--RL]</div><div class="line">  X/5 Y: XR=[+-L-R] XU=[+-RL-] XT=[+--RL]</div><div class="line">  Y/5 Y: YV=[+-L-R] YU=[+-RL-] YO=[+--RL]</div><div class="line">  Z/5 Y: ZT=[+-L-R] ZU=[+-RL-] ZV=[+--RL]</div><div class="line">For 1,614,252,037,500,000 interpretations.</div></div><!-- fragment --><p>После распространения ограничения диаграмма выглядит так:</p>
<div class="fragment"><div class="line">A/1 Y: AB=[+] AC=[+] AD=[+]</div><div class="line">B/l W: BG=[L] BE=[R] BA=[+]</div><div class="line">C/1 W: CE=[L] CF=[R] CA=[+]</div><div class="line">D/l W: DF=[-] DG=[-] DA=[+]</div><div class="line">E/1 L: EC=[R] EB=[L]</div><div class="line">F/1 Y: FD=[-] FC=[L] FI=[R]</div><div class="line">G/1 Y: GB=[R] GD=[-]GH=[L]</div><div class="line">H/1 W: HL=[L] HG=[R] HJ=[+]</div><div class="line">I/1 W: IF=[L] IM=[R] IP=[+]</div><div class="line">J/l Y: JH=[+] JO=[+] JK=[+]</div><div class="line">K/l W: KM=[-] KL=[-] KJ=[+]</div><div class="line">L/l L: LH=[R] LK=[-]</div><div class="line">M/1 L: MK=[-] MI=[L]</div><div class="line">N/l L: NQ=[R] NO[-]</div><div class="line">O/l W: OY=[+] OJ=[+] ON=[-]</div><div class="line">P/l L: PR=[L] PI=[+]</div><div class="line">Q/1 W: QN=[L] QS=[R] QW=[+]</div><div class="line">R/1 W: RS=[L] RP=[R] RX=[+]</div><div class="line">S/1 L: SR=[R] SQ=[L]</div><div class="line">T/1 W: TW=[+] TX=[+] TZ=[-]</div><div class="line">U/1 W: UX=[+] UY=[+] UZ=[-]</div><div class="line">V/l W: VY=[+] VW=[+] VZ=[-]</div><div class="line">W/l Y: WT=[+] WV=[+] WQ=[+]</div><div class="line">X/1 Y: XR=[+] XU=[+] XT=[+]</div><div class="line">Y/1 Y: YV=[+] YU=[+] YO=[+]</div><div class="line">Z/l Y: ZT=[-] ZU=[-] ZV=[-]</div></div><!-- fragment --><p>Мы видим, что алгоритм смог прийти к единственной интерпретации. Более того, даже несмотря на то, что было большое количество возможностей - более квадриллиона, - вычисления выполняются довольно быстро. Большая часть времени уходит на печать, поэтому для получения точных результатов мы определяем функцию для поиска решений, ничего не печатая:</p>
<div class="fragment"><div class="line">(defun find-labelings (diagram)</div><div class="line">  &quot;Return a list of all consistent labelings of the diagram.&quot;</div><div class="line">  (every #&#39;propagate-constraints (diagram-vertexes diagram))</div><div class="line">  (search-solutions diagram))</div></div><!-- fragment --><p>Когда мы измеряем время применения <code>find-labelings</code> к расположенной на земле башне и poiuyt, мы обнаруживаем, что расчет башни занимает 0,11 секунды, а poiuyt 21 секунду. Это более чем в 180 раз дольше, даже несмотря на то, что у poiuyt вдвое меньше вершин и всего около полумиллиона интерпретаций по сравнению с квадриллионом башни. Обработка poiuyt занимает много времени из-за небольшого количества локальных ограничений, поэтому нарушения обнаруживаются только при одновременном рассмотрении нескольких широко разделенных частей фигуры. Интересно, что тот же факт, из-за которого обработка poiuyt занимает больше времени, также ответственен за его восприятие как иллюзию.</p>
<h2>17.4 Проверка диаграмм на наличие ошибок</h2>
<p>В этом разделе рассматривается еще один пример и рассматривается, что делать, если во входных данных есть очевидные ошибки. Пример взят из книги Чарняка и Макдермотта <em>Introduction to Artificial Intelligence</em>(Введение в искусственный интеллект), стр. 138, и показан на <a href="#f0065">рис. 17.12</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-10.jpg" alt="f17-10"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.10: Невозможная фигура (Poiuyt) </td></tr>
</table>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-11.jpg" alt="f17-11"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.11: Башня </td></tr>
</table>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter17/f17-12.jpg" alt="f17-12"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 17.12: Диаграмма(Схема) арки </td></tr>
</table>
<div class="fragment"><div class="line">(defdiagram arch</div><div class="line">  (a W e b c)    (p L o q)</div><div class="line">  (b L d a)      (q T P i r)</div><div class="line">  (c Y a d g)    (r T j s q)</div><div class="line">  (d Y c b m)    (s L r t)</div><div class="line">  (e L a f)      (t W v s k)</div><div class="line">  (f T e g n)    (u L t l)</div><div class="line">  (g W h f c)    (v L t l)</div><div class="line">  (h T g i o)    (w W x l y)</div><div class="line">  (i T h j q)    (x L w z)</div><div class="line">  (j T i k r)    (y Y w 2 z)</div><div class="line">  (k T J l t)    (z W 3 x y)</div><div class="line">  (l T k m v)    (l T n o w)</div><div class="line">  (m L l d)      (2 W v 3 y)</div><div class="line">  (n L f 1)      (3 L z 2)</div><div class="line">  (o W P 1 h)    (4 T u l v))</div></div><!-- fragment --><p>К сожалению, выполнение этого примера не дает согласованных интерпретаций после распространения ограничения. Это кажется неправильным. Хуже того, когда мы пытаемся заземлить(приложить к земле) диаграмму по линии XZ и вызывать для неё <code>print-labelings</code>, мы получаем следующую ошибку:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt;ERROR: The first argument to NTH was of the wrong type.</div></div><!-- fragment --><p><code>The function expected a fixnum &gt;= z</code>e<code>ro.</code></p>
<p><code>While in the function LABELS-FOR</code>&lt;= <code>CONSISTENT-LABELINGS</code></p>
<div class="fragment"><div class="line">Debugger entered while in the following function:</div></div><!-- fragment --><p><code>LABELS-FOR (P.C. = 23)</code></p>
<div class="fragment"><div class="line">Arg 0 (VERTEX): U/6</div><div class="line">Arg 1 (FROM): 4/4</div></div><!-- fragment --><p>Что пошло не так? Хорошее предположение - что диаграмма непоследовательна - где-то была допущена ошибка при расшифровке диаграммы. Может быть, диаграмма на самом деле невозможна, как и poiuyt. Но это маловероятно, поскольку нам легко дать интуитивную интерпретацию. Нам нужно отладить диаграмму, и было бы неплохо обработать ошибку более изящно.</p>
<p>Одно свойство диаграммы, которое легко проверить, - это то, что каждая линия должна упоминаться дважды. Если между вершинами A и B есть линия, в дескрипторах вершин должно быть две записи следующего вида:</p>
<div class="fragment"><div class="line">(A ? ... B ...)</div><div class="line">(B ? ... A ...)</div></div><!-- fragment --><p>Здесь символ "?" означает, что нас не беспокоит тип вершин, только наличие линии в двух местах. Следующий код выполняет эту проверку при определении диаграммы. Он также проверяет, что каждая вершина относится к одному из четырех допустимых типов и имеет правильное количество соседей.</p>
<div class="fragment"><div class="line">(defmacro defdiagram (name &amp;rest vertex-descriptors)</div></div><!-- fragment --><p><code>"Define a diagram.
A copy can be gotten by (diagram name)."</code></p>
<div class="fragment"><div class="line">  &#39;(put-diagram &#39;.name (construct-diagram</div><div class="line">                    (check-diagram &#39;,vertex-descriptors))))</div><div class="line"></div><div class="line">(defun check-diagram (vertex-descriptors)</div><div class="line">  &quot;Check if the diagram description appears consistent.&quot;</div><div class="line">  (let ((errors 0))</div><div class="line">    (dolist (v-d vertex-descriptors)</div><div class="line">      ;; v-d is like: (a Y b c d)</div><div class="line">      (let ((A (first v-d))</div><div class="line">            (v-type (second v-d)))</div><div class="line">        ;; Check that the number of neighbors is right for</div><div class="line">        ;; the vertex type (and that the vertex type is legal)</div><div class="line">        (when (/= (length (v-d-neighbors v-d))</div><div class="line">                  (case v-type ((W Y T) 3) ((L) 2) (t -1)))</div><div class="line">          (warn &quot;Illegal type/neighbor combo: ~a&quot; v-d)</div><div class="line">          (incf errors))</div><div class="line">        ;; Check that each neighbor B is connected to</div><div class="line">        ;; this vertex, A, exactly once</div><div class="line">        (dolist (B (v-d-neighbors v-d))</div><div class="line">          (when (/= 1 (count-if</div><div class="line">                        #&#39;(lambda (v-d2)</div><div class="line">                            (and (eql (first v-d2) B)</div><div class="line">                                 (member A (v-d-neighbors v-d2))))</div><div class="line">                        vertex-descriptors))</div><div class="line">            (warn &quot;Inconsistent vertex: ~a-~a&quot; A B)</div><div class="line">            (incf errors)))))</div><div class="line">    (when (&gt; errors 0)</div><div class="line">      (error &quot;Inconsistent diagram.  ~d total error~:p.&quot;</div><div class="line">             errors)))</div><div class="line">  vertex-descriptors)</div></div><!-- fragment --><p>Теперь попробуем еще раз арку:</p>
<div class="fragment"><div class="line">(defdiagram arch</div><div class="line">  (a W e b c)    (p L o q)</div><div class="line">  (b L d a)      (q T p i r)</div><div class="line">  (c Y a d g)    (r T j s q)</div><div class="line">  (d Y c b m)    (s L r t)</div><div class="line">  (e L a f)      (t W v s k)</div><div class="line">  (f T e g n)    (u L t l)</div><div class="line">  (g W h f c)    (v L 2 4)</div><div class="line">  (h T g i o)    (w W x l y)</div><div class="line">  (i T h j q)    (x L w z)</div><div class="line">  (j T i k r)    (y Y w 2 z)</div><div class="line">  (k T j l t)    (z W 3 x y)</div><div class="line">  (l T k m v)    (1 T n o w)</div><div class="line">  (m L l d)      (2 W v 3 y)</div><div class="line">  (n L f 1)      (3 L z 2)</div><div class="line">  (o W P 1 h)    (4 T u l v))</div><div class="line">Warning: Inconsistent vertex: T-V</div><div class="line">Warning: Inconsistent vertex: U-T</div><div class="line">Warning: Inconsistent vertex: U-L</div><div class="line">Warning: Inconsistent vertex: L-V</div><div class="line">Warning: Inconsistent vertex: 4-U</div><div class="line">Warning: Inconsistent vertex: 4-L</div></div><!-- fragment --><p><code>&gt;&gt;ERROR: Inconsistent diagram. 6 total errors.</code></p>
<p><code>defdiagram</code> выполнял расшифровку из промаркированной вручную диаграммы, и похоже, что эта транскрипция стала жертвой одной из старейших проблем математической записи: путать "u" с "v". Другая проблема заключалась в том, чтобы рассматривать линию U-L как единую линию, когда на самом деле она разбита на два сегмента, U-4 и 4-L. Исправление этих ошибок дает диаграмму:</p>
<div class="fragment"><div class="line">(defdiagram arch</div><div class="line">  (a W e b c)    (P L o q)</div><div class="line">  (b L d a)      (q T P i r)</div><div class="line">  (c Y a d g)    (r T j s q)</div><div class="line">  (d Y c b m)    (s L r t)</div><div class="line">  (e L a f)      (t W u s k)        *;t-u not t-v*</div><div class="line">  (f T e g n)    (u L t 4)          *;u-4 not u-l*</div><div class="line">  (g W h f c)    (v L 2 4)</div><div class="line">  (h T g i o)    (w W x l y)</div><div class="line">  (i T h j q)    (x L w z)</div><div class="line">  (j T i k r)    (y Y w 2 z)</div><div class="line">  (k T J l t)    (z W 3 x y)</div><div class="line">  (l T k m 4)    (1 T n o w)          *;l-4 not l-v*</div><div class="line">  (m L l d)      (2 W v 3 y)</div><div class="line">  (n L f 1)      (3 L z 2)</div><div class="line">  (o W P 1 h)    (4 T u l v))</div></div><!-- fragment --><p>На этот раз <code>check-diagram</code> ошибок не обнаружила, но запуск <code>print-labelings</code> еще раз не дает решения. <code>Чтобы</code> получить больше информации о том, какие ограничения применяются, <code>я</code> изменил <code>progate-constraints</code>, чтобы распечатать некоторую информацию:</p>
<div class="fragment"><div class="line">(defun propagate-constraints (vertex)</div><div class="line">  &quot;Reduce the number of labelings on vertex by considering neighbors.</div><div class="line">  If we can reduce, propagate the new constraint to each neighbor.&quot;</div><div class="line">  :: Return nil only when the constraints lead to an impossibility</div><div class="line">  (let ((old-num (number-of-labelings vertex)))</div><div class="line">    (setf (vertex-labelings vertex) (consistent-labelings vertex))</div><div class="line">    (unless (impossible-vertex-p vertex)</div><div class="line">      (when (&lt; (number-of-labelings vertex) old-num)</div><div class="line">        (format t &quot;~&amp;; ~a: ~14a ~a&quot; vertex ;***</div><div class="line">                (vertex-neighbors vertex) ;***</div><div class="line">                (vertex-labelings vertex)) ;***</div><div class="line">        (every #&#39;propagate-constraints (vertex-neighbors vertex)))</div><div class="line">      vertex)))</div></div><!-- fragment --><p>Повторный запуск проблемы дает следующую трассу:</p>
<div class="fragment"><div class="line">&gt; (print-labelings (ground (diagram &#39;arch) &#39;x &#39;z))</div><div class="line">The initial diagram is:</div><div class="line">  A/3 W: AE=[L-+] AB-CR-+] AC=[++-]</div><div class="line">  P/6 L: P0=[RL+L-R] PQ=[LRR+L-]</div><div class="line">  B/6 L: BD=[RL+L-R] BA=[LRR+L-]</div><div class="line">  Q/4 T: QP=[RRRR] QI=[LLLL] QR=[+-LR]</div><div class="line">  C/5 Y: CA=[+-L-R] CD=[+-RL-] CG=[+--RL]</div><div class="line">  R/4 T: RJ=[RRRR] RS=[LLLL] RQ=[+-LR]</div><div class="line">  D/5 Y: DC=[+-L-R] DB=[+-RL-] DM=[+--RL]</div><div class="line">  S/6 L: SR=[RL+L-R] ST=[LRR+L-]</div><div class="line">  S/6 L: EA=[RL+L-R] EF=[LRR+L-]</div><div class="line">  T/3 W: TU=[L-+] TS=[R-+] TK=[++-]</div><div class="line">  F/4 T: FE=[RRRR] FG=[LLLL] FN=[+-LR]</div><div class="line">  U/6 L: UT=[RL+L-R] U4=[LRR+L-]</div><div class="line">  G/3 W: GH=[L-+] GF=[R-+] GC=[++-]</div><div class="line">  V/6 L: V2=[RL+L-R] V4=[LRR+L-]</div><div class="line">  H/4 T: HG=[RRRR] HI=[LLLL] Ho=[+-LR]</div><div class="line">  W/3 W: WX=[L-+] W1=[R-+] WY=[++-]</div><div class="line">  I/4 T: IH=[RRRR] IJ=[LLLL] IQ=[+-LR]</div><div class="line">  X/1 L: XW=[R] XZ=[-]</div><div class="line">  J/4 T: JI=[RRRR] JK=[LLLL] JR=[+-LR]</div><div class="line">  Y/5 Y: YW=[+-L-R] Y2=[+-RL-] YZ=[+--RL]</div><div class="line">  K/4 T: KJ=[RRRR] KL=[LLLL] KT=[+-LR]</div><div class="line">  Z/3 W: Z3=[L-+] ZX=[R-+] ZY=[++-]</div><div class="line">  L/4 T: LK=[RRRR] LM=[LLLL] L4=[+-LR]</div><div class="line">  1/4 T: 1N=[RRRR] 10=[LLLL] 1 W=[+-LR]</div><div class="line">  M/6 L: ML=[RL+L-R] MD=[LRR+L-]</div><div class="line">  2/3 W: 2 V=[L-+] 23=[R-+] 2Y=[++-]</div><div class="line">  N/6 L: NF=[RL+L-R] N1=[LRR+L-]</div><div class="line">  3/6 L: 3Z=[RL+L-R] 32=[LRR+L-]</div><div class="line">  0/3 W: 0P=[L-+] 01=[R-+] 0H=[++-]</div><div class="line">  4/4 T: 4U=[RRRR] 4 L=[LLLL] 4 V=[+-LR]</div><div class="line">For 2,888, 816, 545.234, 944,000 interpretations</div><div class="line">: P/2: (0/3 Q/4)        ((R L) (- L))</div><div class="line">: 0/1: (P/2 1/4 H/4)    ((L R +))</div><div class="line">: P/1: (0/1 Q/4)        ((R L))</div><div class="line">: 1/3: (N/6 0/1 W/3)    ((R L +) (R L -) (R L L))</div><div class="line">: N/2: (F/4 1/3)        ((R L) (- L))</div><div class="line">: F/2: (E/6 G/3 N/2)    ((R L -) (R L L))</div><div class="line">: E/2: (A/3 F/2)      ((R L) (- L))</div><div class="line">: A/2: (E/2 B/6 C/5)    ((L R +) (- - +))</div><div class="line">: B/3: (D/5 A/2)      ((R L) (- L) (R -))</div><div class="line">: D/3: (C/5 B/3 M/6)    ((- - -) (- L R) (R - L))</div><div class="line">: W/1: (X/l 1/3 Y/5)    ((L R +))</div><div class="line">: 1/1: (N/2 0/1 W/l)    ((R L L))</div><div class="line">: Y/1: (W/l 2/3 Z/3)    ((+ + +))</div><div class="line">: 2/2: (V/6 3/6 Y/1)    ((L R +) (- - +))</div><div class="line">: V/3: (2/2 4/4)      ((R L) (- L) (R -))</div><div class="line">: 4/2: (U/6 L/4 V/3)    ((R L -) (R L R))</div><div class="line">: U/2: (T/3 4/2)      ((R L) (- L))</div><div class="line">: T/2: (U/2 S/6 K/4)    ((L R +) (- - +))</div><div class="line">: S/2: (R/4 T/2)      ((R L) (R -))</div><div class="line">: K/1: (J/4 L/4 T/2)    ((R L +))</div><div class="line">: J/1: (1/4 K/1 R/4)    ((R L L))</div><div class="line">: I/1: (H/4 J/1 Q/4)    ((R L R))</div><div class="line">: L/1: (K/l M/6 4/2)    ((R L R))</div><div class="line">: M/2: (L/1 D/3)      ((R L) (R -))</div><div class="line">: 3/3: (Z/3 2/2)      ((R L) (- L) (R -))</div><div class="line">: Z/1 : (3/3 X/1 Y/1)    ((- - +))</div><div class="line">: 3/1: (Z/l 2/2)    ((- L))</div><div class="line">: 2/1: (V/3 3/1 Y/1)    ((L R +))</div><div class="line">: V/2: (2/1 4/2)      ((R L) (R -))</div><div class="line">After constraint propagation the diagram is:</div><div class="line">  A/0 W:</div><div class="line">  P/l L: P0=[R] PQ=CL]</div><div class="line">  B/0 L:</div><div class="line">  Q/4 T: QP=[RRRR] QI=[LLLL] QR=[+-LR]</div><div class="line">  C/0 Y:</div><div class="line">  R/4 T: RJ=[RRRR] RS=[LLLL] RQ=[+-LR]</div><div class="line">  D/0 Y:</div><div class="line">  S/2 L: SR=[RR] ST=[L-]</div><div class="line">  E/2 L: EA=[R-] EF=[LL]</div><div class="line">  T/2 W: TU=[L-] TS=CR-] TK=[++]</div><div class="line">  F/2 T: FE=[RR] FG=[LL] FN=[-  L]</div><div class="line">  U/2 L: UT=[R-] U4=[LL]</div><div class="line">  G/0 W:</div><div class="line">  V/2 L: V2=[RR] V4=[L-]</div><div class="line">  H/0 T:</div><div class="line">  W/l W: WX=[L] W1=[R] WY=[+]</div><div class="line">  I/1 T: IH=[R] IJ=[L] IQ=[R]</div><div class="line">  X/1 L: XW=[R] XZ=[-]</div><div class="line">  J/1 T: JI=[R] JK=[L] JR=[L]</div><div class="line">  Y/1 Y: YW=[+] Y2=[+] YZ=[+]</div><div class="line">  K/1 T: KJ=[R] KL=[L] KT=[+]</div><div class="line">  Z/1 W: Z3=[-] ZX=[-] ZY=[+]</div><div class="line">  L/1 T: LK=[R] LM=[L] L4=[R]</div><div class="line">  1/1 T: 1 N=[R] 10=[L] 1 W=[L]</div><div class="line">  M/2 L: ML=[RR] MD=[L-]</div><div class="line">  2/1 W: 2 V=[L] 23=[R] 2Y=[+]</div><div class="line">  N/2 L: NF=[R-] N1=[LL]</div><div class="line">  3/1 L: 3Z=[-] 32=[L]</div><div class="line">  0/1 W: 0P=[L] 01=[R] 0H=[+]</div><div class="line">  4/2 T: 4U=[RR] 4 L=[LL] 4 V=[-  R]</div></div><!-- fragment --><p>На диаграмме после распространения ограничений мы видим, что вершины A, B, C, D, G и H не имеют интерпретаций, поэтому они являются хорошим местом для поиска ошибки в первую очередь. Из трассы(распечатанного следа), генерируемого <code>propagate-constraints</code>(распространением ограничений (линии, начинающиеся с точки с запятой), мы видим, что распространение ограничений началось в точке P и после семи распространений достигло некоторых подозрительных вершин:</p>
<div class="fragment"><div class="line">: A/2: (E/2 B/6 C/5)    ((L R +) (- - + ))</div><div class="line">: B/3: (D/5 A/2)        ((R L) (- L) (R -))</div><div class="line">: D/3: (C/5 B/3 M/6)    ((- - -) (- L R) (R - L))</div></div><!-- fragment --><p>A и B выглядят приемлемо, но посмотрите на запись для вершины D. Она показывает три интерпретации и показывает, что соседями являются C, B и M. Обратите внимание, что линия DC, первая запись в каждой из интерпретаций, должна быть либо -, либо R. Но это ошибка, потому что "правильная" интерпретация имеет DC как линию +. При более внимательном рассмотрении мы замечаем, что D на самом деле является вершиной W-типа, а не вершиной Y, как написано в определении. Мы должны иметь:</p>
<div class="fragment"><div class="line">(defdiagram arch</div><div class="line">  (a W e b c)    (p L o q)</div><div class="line">  (b L d a)      (q T p i r)</div><div class="line">  (c Y a d g)    (r T j s q)</div><div class="line">  (d W b m c)    (s L r t)          ;*d is a W, not Y*</div><div class="line">  (e L a f)      (t W u s k)</div><div class="line">  (f T e g n)    (u L t 4)</div><div class="line">  (g W h f c)    (v L 2 4)</div><div class="line">  (h T g i o)    (w W x 1 y)</div><div class="line">  (i T h j q)    (x L w z)</div><div class="line">  (j T i k r)    (y Y w 2 z)</div><div class="line">  (k T J l t)    (z W 3 x y)</div><div class="line">  (1 T k m 4)    (1 T n o w)</div><div class="line">  (m L l d)      (2 W v 3 y)</div><div class="line">  (n L f 1)      (3 L z 2)</div><div class="line">  (o W P 1 h)    (4 T u l v))</div></div><!-- fragment --><p>Запустив задачу еще раз и проверив вывод трассировки, мы вскоре обнаружим настоящий корень проблемы: наиболее естественная интерпретация диаграммы выходит за рамки программы! Есть много интерпретаций, в которых блоки летают в воздухе, но если мы заземлим линии OP, TU и XZ, мы столкнемся с проблемами. Помните, мы говорили, что рассматриваем только трехгранные вершины. Но вершина 1 будет четырехгранной вершиной, образованной пересечением четырех плоскостей: верхней и задней части основания, а также нижней и левой стороны левой колонны. Интуитивно правильная маркировка для диаграммы будет иметь O1 вогнутой (-) линией, а Al - закрывающей линией, но наш репертуар разметки для T вершин не позволяет этого. Следовательно, диаграмма не может быть корректно промаркирована.</p>
<p>Вернемся назад и рассмотрим ошибку, появившуюся в первой версии диаграммы. Несмотря на то, что ошибка больше не появляется на этой диаграмме, мы хотим убедиться, что она не появится в другом случае. Вот ошибка:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt;ERROR: The first argument to NTH was of the wrong type.</div></div><!-- fragment --><p>Функция ожидала fixnum &gt;= <code>zero.</code></p>
<p><code>Находясь в функции LABELS-FOR</code> &lt;= <code>CONSISTENT-LABELINGS</code></p>
<div class="fragment"><div class="line">Debugger entered while in the following function:</div></div><!-- fragment --><p><code>LABELS-FOR (P.C. = 23)</code></p>
<div class="fragment"><div class="line">Arg 0 (VERTEX): U/6</div><div class="line">Arg 1 (FROM): 4/4</div></div><!-- fragment --><p>Глядя на определение <code>labels-for</code>, мы видим, что он ищет исходную вершину, которая в данном случае равна 4, среди соседей U. Она не была найдена, поэтому pos стал nil, а функция nth пожаловалась, что ей не было дано целое число в качестве аргумента. Таким образом, эта ошибка, если бы мы преследовали ее раньше, указала бы на то, что 4 не был указан как сосед U, хотя должен был быть. Конечно, мы выяснили это другими способами. В любом случае, здесь нет ошибки, которую нужно исправить - до тех пор, пока диаграмма будет непротиворечивой, ошибка <code>label-for</code> больше не появится.</p>
<p>В этом разделе выделены два момента. Во-первых, пишите код, который проверяет ввод как можно тщательнее. Во-вторых, даже когда проверка ввода выполнена, пользователю по-прежнему остается понять ограничения программы.</p>
<h2>17.5 История и Ссылки</h2>
<p><a href="B9780080571157500285.xhtml#bb0500">Guzman (1968)</a> was one of the first to consider the problem of interpreting line diagrams. He classified vertexes, and defined some heuristics for combining information from adjacent vertexes. <a href="B9780080571157500285.xhtml#bb0560">Huffman (1971)</a> and <a href="B9780080571157500285.xhtml#bb0215">Clowes (1971)</a> independently came up with more formai and complete analyses, and David <a href="B9780080571157500285.xhtml#bb1300">Waltz (1975)</a> extended the analysis to handle shadows, and introduced the constraint propagation algorithm to eut down on the need for search. The algorithm is sometimes called "Waltz filtering" in his honor. With shadows and nontrihedral angles, there are thousands of vertex labelings instead of 18, but there are also more constraints, so the constraint propagation actually does better than it does in our limited world. Waltz's approach and the Huf f man-Clowes labels are covered in most introductory AI books, including Rich and Knight 1990, <a href="B9780080571157500285.xhtml#bb0175">Charniak and McDermott 1985</a>, and <a href="B9780080571157500285.xhtml#bb1405">Winston 1984</a>. Waltz's original paper appears in <em>The Psychology of Computer Vision</em> (<a href="B9780080571157500285.xhtml#bb1400">Winston 1975</a>), an influential volume collecting early work done at MIT. He also contributed a summary article on Waltz filtering (<a href="B9780080571157500285.xhtml#bb1305">Waltz 1990</a>).</p>
<p>Many introductory AI texts give vision short coverage, but <a href="B9780080571157500285.xhtml#bb0175">Charniak and McDermott (1985)</a> and <a href="B9780080571157500285.xhtml#bb1220">Tanimoto (1990)</a> provide good overviews of the field. <a href="B9780080571157500285.xhtml#bb1450">Zucker (1990)</a> provides an overview of low-level vision.</p>
<p><a href="B9780080571157500285.xhtml#bb0975">Ramsey and Barrett (1987)</a> give an implementation of a line-recognition program. It would make a good project to connect their program to the one presented in this chapter, and thereby go all the way from pixels to 3-D descriptions.</p>
<h2>17.6 Упражнения</h2>
<p>This chapter has solved the problem of line-labeling for polyhedra made of trihedral vertexes. The following exercises extend this solution.</p>
<p><b>Exercise 17.1 [h]</b> Use the line-labeling to produce a face labeling. Write a function that takes a labeled diagram as input and produces a list of the faces (planes) that comprise the diagram.</p>
<p><b>Exercise 17.2 [h]</b> Use the face labeling to produce a polyhedron labeling. Write a function that takes a list of faces and a diagram and produces a list of polyhedra (blocks) that comprise the diagram.</p>
<p><b>Exercise 17.3 [d]</b> Extend the system to include quad-hedral vertexes and/or shadows. There is no conceptual difficulty in this, but it is a very demanding task to find all the possible vertex types and labelings for them. Consult <a href="B9780080571157500285.xhtml#bb1300">Waltz 1975</a>.</p>
<p><b>Exercise 17.4 [d]</b> Implement a program to recognize lines from pixels.</p>
<p><b>Exercise 17.5 [d]</b> If you have access to a workstation with a graphical interface, implement a program to allow a user to draw diagrams with a mouse. Have the program generate output in the form expected by <code>construct-diagram</code> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
