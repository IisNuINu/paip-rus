<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 4 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>GPS: Универсальный решатель проблем(General problem Solver)</h2>
<blockquote class="doxtable">
<p><em>Сейчас в мире есть машины, которые думают.</em> </p>
</blockquote>
<blockquote class="doxtable">
<p>-Herbert Simon </p>
</blockquote>
<blockquote class="doxtable">
<p>Nobel Prize-winning Al researcher </p>
</blockquote>
<p>Универсальный решатель проблем, разработанный в 1957 году Аланом Ньюэллом и Гербертом Саймоном, воплощал грандиозное видение: единую компьютерную программу, которая могла бы решить любую проблему, получив соответствующее описание проблемы. GPS вызвал настоящий ажиотаж, когда он был представлен, и некоторые люди в ИИ чувствовали, что он открыл грандиозную новую эру интеллектуальных машин. Саймон зашел так далеко, что сделал это заявление о своем творении:</p>
<blockquote class="doxtable">
<p><em>В мои намерения не входит удивлять или шокировать вас.... Но самый простой способ подвести итог-это сказать, что сейчас в мире существуют машины, которые думают, учатся и творят.</em> &gt;*Более того, их способность делать эти вещи будет быстро возрастать до тех пор, пока - в обозримом будущем - диапазон проблем, с которыми они могут справиться, не станет соразмерным с диапазоном, к которому может быть применен человеческий разум.* </p>
</blockquote>
<p>Хотя GPS никогда не соответствовала этим преувеличенным заявлениям, она все же является важной программой по историческим причинам. Это была первая программа, которая отделила свою стратегию решения проблем от знания конкретных проблем, и она стимулировала дальнейшие исследования в области решения проблем. По всем этим причинам она является подходящим для изучения объектом.</p>
<p>Оригинальная программа GPS имела ряд незначительных особенностей, которые делали ее довольно сложной. Кроме того, она была написана на устаревшем низкоуровневом языке IPL, что добавляло ей неоправданной сложности. На самом деле запутанная природа IPL, вероятно, была важной причиной для грандиозных заявлений о GPS. Если программа была настолько сложной, она должна была сделать что-то важное. Мы будем игнорировать некоторые тонкости оригинальной программы, и мы будем использовать Common Lisp, гораздо более ясный язык, чем IPL. Результатом будет версия GPS, которая довольно проста, но иллюстрирует некоторые важные моменты ИИ.</p>
<p>С одной стороны, эта глава посвящена GPS. Но на другом уровне речь идет о процессе разработки компьютерной программы искусственного интеллекта. Мы выделяем пять этапов в разработке программы. Во-первых, это описание проблемы, которое представляет собой приблизительное представление - обычно написанное простым текстом - о том, что мы хотим сделать. Во-вторых, это спецификация программы, где мы заново описываем проблему в терминах, которые ближе к вычислительной процедуре. Третий этап-это реализация программы на таком языке программирования, как Common Lisp, Четвертый-тестирование, и Пятый-отладка и анализ. Границы между этими стадиями изменчивы, и стадии не обязательно завершаются в указанном порядке. Проблемы на любом этапе могут привести к изменению предыдущего этапа или даже к полному перепроектированию или отказу от проекта. Программист может предпочесть завершить только частичное описание или спецификацию, перейти непосредственно к реализации и тестированию, а затем вернуться к завершению спецификации на основе улучшевшегося понимания.</p>
<p>Мы пройдем по всем пяти этапам разработки наших версий GPS, надеясь, что читатель лучше поймет GPS, а также лучше поймет, как написать собственную программу. Подводя итог, можно выделить пять этапов проекта по программированию искусственного интеллекта:</p>
<ol type="1">
<li><b>Опишите</b> проблему в расплывчатых терминах</li>
<li><b>Определите</b> задачу в алгоритмических терминах</li>
<li><b>Реализуйте</b> задачу на языке программирования</li>
<li><b>Проверьте</b> программу на репрезентативных примерах</li>
<li><b>Отладьте</b> и <b>проанализируйте</b> полученную программу и повторите процесс</li>
</ol>
<h2>4.1 Этап 1: Описание</h2>
<p>В качестве описания нашей проблемы мы начнем с цитаты из книги Ньюэлла и Саймона 1972 года: <em>Решение Человеческих Проблем</em></p>
<blockquote class="doxtable">
<p><em>Основные методы GPS совместно воплощают эвристику анализа конечных целей. </em></p>
</blockquote>
<p>Анализ конечных целей характеризуется следующим типом аргументов здравого смысла:</p>
<p><em><em>Я хочу отвести своего сына в детский сад. Какая разница между тем, что у меня есть, и тем, что я хочу? Одна из дистанций. Что изменяет расстояние? Мой автомобиль. Мой автомобиль не работает. Что нужно для того, чтобы он заработал? Новая батарея. У кого есть новые батареи? В Мастерской по ремонту автомобилей. Я хочу, чтобы ремонтная мастерская поставила новую батарею, но мастерская не знает, что она мне нужна. В чем же затруднение? Один из способов общения. Что позволяет общаться? Телефон... и так далее.</em></em></p>
<p><em></p><blockquote class="doxtable">
<p><em>Тип анализа, классифицирующий вещи в терминах функций, которые они выполняют и который колеблется(переключается) между целями, требуемыми функциями и средствами, которые их выполняют, формирует базовую систему эвристики GPS.</em> </p>
</blockquote>
<p></em></p>
<p><em>Конечно, этот вид анализа не совсем новый. Теория анализа конечных целей была довольно изящно изложена Аристотелем 2300 годами ранее в главе под названием "Природа размышлений и ее объекты" <em>Никомаховой этики</em> (Книга III. 3,1112b)</em></p>
<p><em></p><blockquote class="doxtable">
<p><em>Мы размышляем не о целях, а о средствах. </em></p>
</blockquote>
<p>Ибо врач не обдумывает, будет ли он исцелять, или оратор, будет ли он убеждать, или государственный деятель, будет ли он создавать закон и порядок, и никто другой не обдумывает об этом. Они предполагают цель и рассматривают, как и какими средствами она достигается; и если кажется, что она может быть достигнута несколькими средствами, они рассматривают, с помощью которых она наиболее легко и наилучшим образом достигается, в то время как если она достигается только одним, они рассматривают, как она будет им достигнута и какими дополнительными средствами это средство будет достигнуто, пока они не придут к первой причине, которая в порядке открытия является последней... и то, что является последним в порядке анализа, кажется первым в порядке установления. И если мы приходим к невозможности, мы отказываемся от поиска, например, если нам нужны деньги, а их нельзя получить; но если что-то кажется возможным, мы пытаемся это сделать.</em></p>
<p><em>Учитывая это описание теории решения проблем, как мы должны писать программу? Сначала мы пытаемся более полно понять процедуру, изложенную в кавычках. Основная идея состоит в том, чтобы решить проблему, используя процесс, называемый анализом конечных целей, где проблема формулируется в терминах того, что нам надо чтобы это произошло. В примере Ньюэлла и Саймона проблема состоит в том, чтобы доставить ребенка в школу, но в целом мы хотели бы, чтобы программа могла решать широкий класс проблем. Мы можем решить проблему, если найдем способ устранить «разницу между тем, что у меня есть, и тем, что я хочу». Например, если у меня есть ребенок дома, а то, что я хочу, это ребенок в школе, то поездка может быть решением, потому что мы знаем, что езда на машине ведет к изменению местоположения. Нам следует помнить, что использование анализа конечных целей - это наш выбор: также можно начать с текущей ситуации и идти к цели или использовать смесь различных поисковых стратегий.</em></p>
<p><em>Некоторые действия требуют решения <em>предварительных условий</em> как подзадач. Прежде чем мы сможем управлять автомобилем, нам нужно решить подзадачу приведения автомобиля в рабочее состояние. Возможно, что машина уже работает, и в этом случае нам ничего не нужно делать, чтобы решить эту подзадачу. Таким образом, проблема решается либо путем принятия соответствующего действия непосредственно, либо путем предварительного решения для предварительных условий для выполнения этого действия, а затем уже и выполнения самого действия. Понятно, что нам потребуется некоторое описание допустимых действий, а также их предпосылок и последствий(результатов/effects). Нам также необходимо разработать определение уместности. Однако если мы сможем лучше определить эти понятия, то, похоже, нам не понадобятся никакие новые понятия. Таким образом, мы произвольно решаем, что описание проблемы завершено и перейдем к спецификации проблемы.</em></p>
<p><em></p><h2>4.2 Этап 2: Спецификация(Детализация)</h2>
<p></em></p>
<p><em></em></p>
<p><em>На данный момент у нас есть представление, правда смутное, о том, что значит решать проблему в <code>GPS</code>. Мы можем уточнить эти понятия в представления, которые ближе к Lisp следующим образом:</em></p>
<p><em></p><ul>
<li>Мы можем представить текущее состояние мира как "то, что у меня есть" и состояние цели, как "то, что я хочу", как набор условий. Common Lisp не имеет типа данных для множеств, но у него есть списки, которые можно использовать для реализации множеств. Каждое условие может быть представлено символом. Таким образом, типичной целью может быть список двух состояний (<code>rich famous</code>)/(<code>богатый знаменитый</code>), а типичным текущим состоянием может быть (<code>unknown poor</code>)/(<code>неизвестный бедный</code>).</li>
<li>Нам нужен список допустимых операторов. Этот список будет постоянным течение проблемы или даже серии проблем, но мы хотим иметь возможность изменять его и искать решение в новой проблемной области.</li>
<li>Оператор может быть представлен в виде структуры, состоящей из действия(action), списка предварительных условий(preconditions) и списка эффектов(effects). Мы можем установить ограничения на виды возможных эффектов, сказав, что эффект либо добавляет, либо удаляет условие из текущего состояния. Таким образом, список эффектов можно разделить на список добавления(add-list) и список удаления(delete-list). Это был подход, принятый в Stripes <a href="#fn0010">1</a> реализации GPS, который мы фактически реконструируем в этой главе. Оригинальный GPS позволял большую гибкость в спецификации/определении эффектов, но гибкость приводит к неэффективности.</li>
<li>Полная задача описывается для GPS в терминах начального состояния(starting state), целевого состояния(goal state) и набора/множества известных операторов(known operators). Таким образом, GPS будет функцией трех аргументов. Например, пример вызова может быть: `(GPS '(unknown poor) '(rich famous) list-of-ops)`, другими словами, начиная с состояния быть бедным(poor) и неизвестным(unknown), надо достичь состояния быть богатым(rich) и знаменитым(famous), используя любую комбинацию известных операторов(list-of-ops). GPS должен возвращать истинное значение только в том случае, если он решает проблему, и он должен напечатать запись о предпринятых действиях. Самый простой подход состоит в том, чтобы пройти через условия к состоянию цели по одному(условию цели) за раз и попытаться достичь каждого из них. Если все они могут быть достигнуты, то проблема решена.</li>
<li>Одно условие цели может быть достигнуто двумя способами. Если оно(целевое условие) уже находится в текущем состоянии, то цель тривиально достигается без каких-либо усилий. В противном случае мы должны найти какой-то подходящий оператор(добавляющий это условие) и попытаться применить его.</li>
<li>Оператор уместен/применим, если одним из эффектов оператора является добавление рассматриваемой цели в текущее состояние; другими словами, если цель находится в списке добавлений(add-list) оператора.</li>
<li>Мы можем применить оператор, если мы можем достичь всех предварительных условий. Но это легко, потому что мы только что определили понятие достижения цели в предыдущем абзаце. После выполнения предварительных условий применение оператора означает выполнение действия и обновление текущего состояния в терминах операторов списка добавлений(add-list) и списка удалений(delete-list). Поскольку наша программа-это всего лишь симуляция, а не фактическое вождение автомобиля или набора номера телефона, мы должны довольствоваться просто распечаткой действия, а не выполнением каких-либо реальных действий.</li>
</ul>
<p></em></p>
<p><em></p><h2>4.3 Этап 3: Реализация</h2>
<p></em></p>
<p><em></em></p>
<p><em>Спецификация достаточно полна, чтобы привести непосредственно к полной программе Common Lisp. <a href="#f0010">Рисунок 4.1</a> суммирует переменные, типы данных и функции, составляющие программу GPS, а также некоторые из функций Common Lisp, используемых для ее реализации.</em></p>
<p><em></p><table class="doxtable">
<tr>
<th>Символ </th><th>Использование  </th></tr>
<tr>
<td></td><td><b>Функция верхнего уровня</b> </td></tr>
<tr>
<td><code>GPS</code> </td><td>Решает задачу из сост., используя список операторов. </td></tr>
<tr>
<td></td><td><b>Специальные переменные</b> </td></tr>
<tr>
<td><code>*state*</code> </td><td>Текущее состояние, это список условий. </td></tr>
<tr>
<td><code>*ops*</code> </td><td>Список доступных операций. </td></tr>
<tr>
<td></td><td><b>Типы Данных</b> </td></tr>
<tr>
<td><code>op</code> </td><td>Операции с preconds, add-list и del-list. </td></tr>
<tr>
<td></td><td><b>Функции</b> </td></tr>
<tr>
<td><code>achieve</code> </td><td>Достижение индивидуальной цели. </td></tr>
<tr>
<td><code>appropriate-p</code> </td><td>Решает, подходит ли оператор для достижения цели. </td></tr>
<tr>
<td><code>apply-op</code> </td><td>Применяет оператор к текущему состоянию. </td></tr>
<tr>
<td></td><td><b>Выбранные Функции Common Lisp</b> </td></tr>
<tr>
<td><code>member</code> </td><td>Проверяет содержиться ли элемент в списке. (p.78) </td></tr>
<tr>
<td><code>set-difference</code> </td><td>Все элементы из одного можества, которых нет в другом. </td></tr>
<tr>
<td><code>union</code> </td><td>Все элементы из обоих мноожеств </td></tr>
<tr>
<td><code>every</code> </td><td>Проверяет, проходит ли тест каждый элемент списка. (p. 62) </td></tr>
<tr>
<td><code>some</code> </td><td>Проверяет, проходит ли тест какой-либо элемент списка. </td></tr>
<tr>
<td></td><td><b>Ранее Определенные Функции</b> </td></tr>
<tr>
<td><code>find-all</code> </td><td>Список всех совпадающих элементов. (p. 101) </td></tr>
</table>
<p>Вот полная программа GPS сама по себе:</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *state* nil &quot;The current state: a list of conditions.&quot;)</div><div class="line"></div><div class="line">(defvar *ops* nil &quot;A list of available operators.&quot;)</div><div class="line"></div><div class="line">(defstruct op &quot;An operation&quot;</div><div class="line">  (action nil) (preconds nil) (add-list nil) (del-list nil))</div><div class="line"></div><div class="line">(defun GPS (*state* goals *ops*)</div><div class="line">  &quot;General Problem Solver: achieve all goals using *ops*.&quot;</div><div class="line">  (if (every #&#39;achieve goals) &#39;solved))</div><div class="line"></div><div class="line">(defun achieve (goal)</div><div class="line">  &quot;A goal is achieved if it already holds,</div><div class="line">  or if there is an appropriate op for it that is applicable.&quot;</div><div class="line">  (or (member goal *state*)</div><div class="line">    (some #&#39;apply-op</div><div class="line">      (find-all goal *ops* :test #&#39;appropriate-p))))</div><div class="line"></div><div class="line">(defun appropriate-p (goal op)</div><div class="line">  &quot;An op is appropriate to a goal if it is in its add list.&quot;</div><div class="line">  (member goal (op-add-list op)))</div><div class="line"></div><div class="line">(defun apply-op (op)</div><div class="line">  &quot;Print a message and update *state* if op is applicable.&quot;</div><div class="line">  (when (every #&#39;achieve (op-preconds op))</div><div class="line">    (print (list &#39;executing (op-action op)))</div><div class="line">    (setf *state* (set-difference *state* (op-del-list op)))</div><div class="line">    (setf *state* (union *state* (op-add-list op)))</div><div class="line">  t))</div></div><!-- fragment --><p> Мы видим, что программа состоит из семи определений. Они соответствуют семи пунктам приведенной выше спецификации. В общем, вы не должны ожидать такого идеального соответствия между спецификацией и реализацией. Существует две формы <code>defvar</code>, одна <code>defstruct</code> и четыре формы <code>defun</code>. Это формы Lisp для определения переменных, структур и функций соответственно. Они являются наиболее распространенными формами верхнего уровня в Lisp, но в них нет ничего волшебного; это просто специальные формы, которые имеют побочный эффект добавления новых определений в среду Lisp.</em></p>
<p><em>Две формы <code>defvar</code>, повторенные ниже, объявляют специальные переменные с именами <code>*state*</code> и <code>*ops*,</code> к которым затем можно получить доступ из любой точки программы.</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *state* nil &quot;The current state: a list of conditions.&quot;)</div><div class="line">(defvar *ops* nil &quot;A list of available operators.&quot;)</div></div><!-- fragment --><p> Форма <code>defstruct</code> определяет структуру называемую <code>op</code>, которая имеет слоты под названием <code>action</code>, <code>preconds</code>, <code>add-list</code> и <code>del-list</code>(действие, предварительные условия, списко добавления и список удаления). Структуры в Common Lisp подобны структурам в Си или записям в Pascal. <code>defstruct</code> автоматически определяет функцию конструктора, которая называется <code>make-op</code> и функцию доступа для каждого слота структуры. Функции доступа называются <code>op-action</code>, <code>op-preconds</code>, <code>op-add-list</code> и <code>op-del-list</code>. В <code>defstruct</code> также определяется функция копирования <code>copy-op</code>, предикат <code>op-p</code> и определения <code>setf</code> для изменения каждого слота. Ни одина из них не используется в программе GPS. Грубо говоря, это как если бы форма <code>defstruct</code></em></p>
<p><em></p><div class="fragment"><div class="line">(defstruct op &quot;An operation&quot;</div><div class="line">  (action nil) (preconds nil) (add-list nil) (del-list nil))</div></div><!-- fragment --><p> расширялась бы в следующие определения:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun make-op (&amp;key action preconds add-list del-list)</div><div class="line">  (vector &#39;op action preconds add-list del-list))</div><div class="line"></div><div class="line">(defun op-action (op) (elt op 1))</div><div class="line"></div><div class="line">(defun op-preconds (op) (elt op 2))</div><div class="line"></div><div class="line">(defun op-add-list (op) (elt op 3))</div><div class="line"></div><div class="line">(defun op-del-list (op) (elt op 4))</div><div class="line"></div><div class="line">(defun copy-op (op) (copy-seq op))</div><div class="line"></div><div class="line">(defun op-p (op)</div><div class="line">  (and (vectorp op) (eq (elt op 0) &#39;op)))</div><div class="line"></div><div class="line">(setf (documentation &#39;op &#39;structure) &quot;An operation&quot;)</div></div><!-- fragment --><p> Далее в программе GPS идут четыре определения функций. Основная функция <code>GPS</code>, принимает три аргумента. Первый - это текущее состояние мира, второй - целевое состояние, а третий - список допустимых операций(операторов). Тело функции просто говорит, что если мы сможем достичь каждой из поставленных целей, то проблема будет решена. Неназванная альтернатива заключается в том, что в противном случае проблема не будет решена.</em></p>
<p><em>Функция achieve принимает в качестве аргумента единственную цель(goal). Функция работает успешно, если эта цель уже верна(достигнута) в текущем состоянии (в этом случае нам ничего не нужно делать) или если мы можем применить соответствующий оператор. Это достигается путем предварительного построения списка подходящих операторов, а затем тестирования каждого по очереди, пока один из них не сможет быть применен. <code>achieve</code> вызывает <code>find-all</code>, который мы определили на <a href="B9780080571157500030.xhtml#p101">page 101</a>. При таком использовании <code>find-all</code> возвращает список операторов, соответствующих текущей цели, в соответствии с предикатом <code>appropriate-p</code>.</em></p>
<p><em>Функция <code>appropriate-p</code> проверяет, подходит ли оператор для достижения цели. (Это следует из соглашения об именовании Lisp, что предикаты заканчиваются на <code>-p</code>.)</em></p>
<p><em>Наконец, функция <code>apply-op</code> говорит, что если мы можем достичь всех предварительных условий для соответствующего оператора, то мы можем применить оператор. Это включает в себя печать сообщения об этом эффекте и изменение состояния мира путем удаления того, что было в списке удаления(delete-list), и добавления того, что было в списке добавления(add-list). <code>apply-op</code> также является предикатом; он возвращает <code>t</code> только тогда, когда оператор может быть применен.</em></p>
<p><em></p><h2>4.4 Этап 4: Тестирование</h2>
<p></em></p>
<p><em></em></p>
<p><em>В этом разделе будет определен список операторов, применимых к домену "вождение в детский сад", и показано, как ставить и решать некоторые проблемы в этом домене. Во-первых, нам нужно построить список операторов для домена. Форма <code>defstruct</code> для типа <code>op</code> автоматически определяет функцию <code>make-op</code>, которую можно использовать следующим образом:</em></p>
<p><em></p><div class="fragment"><div class="line">(make-op :action &#39;drive-son-to-school</div><div class="line">    :preconds &#39;(son-at-home car-works)</div><div class="line">    :add-list &#39;(son-at-school)</div><div class="line">    :del-list &#39;(son-at-home))</div></div><!-- fragment --><p> Это выражение возвращает оператор, чьим действием является символ <code>drive-son-to-school</code> и чьи предварительные условия, список добавления(add-list) и список удаления(delete-list) являются указанными списками. Цель этого оператора заключается в том, что всякий раз, когда сын находится дома(son-at-home) и машина работает(car-works), можно применить <code>drive-son-to-school</code>("отвезти сына в школу"), изменяя состояние, удалив тот факт, что сын находится дома(son-at-home), и добавив тот факт, что он находится в школе(son-at-school).</em></p>
<p><em>Следует отметить, что использование длинных атомов с разделлительными дефисами, таких как <code>son-at-home</code>, является полезным подходом только для очень простых примеров, подобных этому. Более точное представление разбило бы атом на его компоненты: возможно (<code>at son home</code>).. Проблема атомного подхода - это комбинаторная проблема. Если есть 10 предикатов (таких как, <code>at</code>) и 10 людей или объектов, то будет 10 x 10 x 10 = 1000 возможных атомов разделенных дефисом, но только 20 компонентов. Очевидно, что было бы проще описать компоненты. В этой главе мы придерживаемся разделенных дефисами атомов, потому что это проще, и нам не нужно описывать весь мир. В последующих главах представление знаний рассматривается более серьезно.</em></p>
<p><em>Используя этот оператор в качестве модели, мы можем определить другие операторы, соответствующие цитате Ньюэлла и Саймона на <a href="B9780080571157500042.в XHTML#р109">page 109</a>. Там будет оператор для установки батареи, сообщающий в ремонтную мастерскую о проблеме и звонящий в мастерскую. Мы можем заполнить "и так далее", добавив операторы для поиска номера телефона магазина и для передаче магазину денег:</em></p>
<p><em></p><div class="fragment"><div class="line">(defparameter *school-ops*</div><div class="line">  (list</div><div class="line">    (make-op :action &#39;drive-son-to-school</div><div class="line">      :preconds &#39;(son-at-home car-works)</div><div class="line">      :add-list &#39;(son-at-school)</div><div class="line">      :del-list &#39;(son-at-home))</div><div class="line">    (make-op :action &#39;shop-installs-battery</div><div class="line">      :preconds &#39;(car-needs-battery shop-knows-problem shop-has-money)</div><div class="line">      :add-list &#39;(car-works))</div><div class="line">    (make-op :action &#39;tell-shop-problem</div><div class="line">      :preconds &#39;(in-communication-with-shop)</div><div class="line">      :add-list &#39;(shop-knows-problem))</div><div class="line">    (make-op :action &#39;telephone-shop</div><div class="line">      :preconds &#39;(know-phone-number)</div><div class="line">      :add-list &#39;(in-communication-with-shop))</div><div class="line">    (make-op :action &#39;look-up-number</div><div class="line">      :preconds &#39;(have-phone-book)</div><div class="line">      :add-list &#39;(know-phone-number))</div><div class="line">    (make-op :action &#39;give-shop-money</div><div class="line">      :preconds &#39;(have-money)</div><div class="line">      :add-list &#39;(shop-has-money)</div><div class="line">      :del-list &#39;(have-money))))</div></div><!-- fragment --><p> Следующий шаг-поставить некоторые проблемы перед GPS и изучить их решения. Ниже приведены три примера проблем. В каждом случае цель одна и та же: достичь единственного условия <code>son-at-school</code>(сын-в-школе). Список доступных операторов также одинаков в каждой задаче; разница заключается в исходном состоянии. Каждый из трех примеров состоит из подсказки "&gt;", которая печатается системой Lisp, а затем следует вызов GPS " ( `gps`... )", который набирается пользователем, а затем выводится программой "(`EXECUTING`...)" и, наконец, результат вызова функции, который может быть либо <code>SOLVED</code>(решен), либо <code>NIL</code>(не решен).</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">    &#39;(son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">(EXECUTING LOOK-UP-NUMBER)</div><div class="line">(EXECUTING TELEPHONE-SHOP)</div><div class="line">(EXECUTING TELL-SHOP-PROBLEM)</div><div class="line">(EXECUTING GIVE-SHOP-MONEY)</div><div class="line">(EXECUTING SHOP-INSTALLS-BATTERY)</div><div class="line">(EXECUTING DRIVE-SON-TO-SCHOOL)</div><div class="line">SOLVED</div><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money)</div><div class="line">    &#39;(son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">NIL</div><div class="line">&gt; (gps &#39;(son-at-home car-works)</div><div class="line">    &#39;(son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">(EXECUTING DRIVE-SON-TO-SCHOOL)</div><div class="line">SOLVED</div></div><!-- fragment --><p> Во всех трех примерах цель состоит в том, чтобы <code>son-at-school</code>(сын был в школе). Единственный оператор, у которого есть <code>son-at-school</code> в своем списке добавлениядополнений(add-list) -это <code>drive-son-to-school</code>(отвезти/переместить сына в школу), поэтому GPS изначально выбирает этот оператор. Прежде чем он сможет выполнить этот оператор, GPS должен решить для себя предварительные условия этого оператора. В первом примере программа работает в обратном направлении через операторы <code>shop-installs-battery</code>, <code>give-shop-money</code>, <code>tell-shop-problem</code> и <code>telephone-shop</code> к <code>look-up-number</code>, который не имеет никаких значимых предварительных условий. Таким образом, действие <code>look-up-number</code>(поиск номера) может быть выполнено, и программа переходит к другим действиям. Как сказал Аристотель: "то, что появляется последним в порядке анализа, будет первым в порядке становления(выполнения)."</em></p>
<p><em>Второй пример начинается точно так же, но оператор <code>look-up-number</code> терпит неудачу, потому что его предварительное условие <code>have-phone-book</code>, не может быть достигнуто. Знание номера телефона является обязательным условием, прямо или косвенно, для всех операторов, поэтому никаких действий не предпринимается и GPS возвращает <code>NIL</code>.</em></p>
<p><em>Наконец, третий пример является гораздо более прямым; начальное состояние указывает, что автомобиль работает, поэтому оператор вождения может быть применен немедленно.</em></p>
<p><em></p><h2>4.5 Стадия 5: анализ, или "мы солгали о G(Общности решателя проблем)"</h2>
<p></em></p>
<p><em></em></p>
<p><em>В следующих разделах мы рассмотрим вопрос о том, насколько общим является этот общий решатель проблем. Следующие четыре раздела указывают на ограничения нашей версии GPS, и мы покажем, как исправить эти ограничения во второй версии программы.</em></p>
<p><em>Можно было бы спросить, не является ли "ограничения" просто эвфемизмом(хорошим термином) для "ошибок".- Мы "расширяем" программу или "корректируем" ее? На этот вопрос нет четких ответов, потому что мы никогда не настаивали на однозначном описании или спецификации проблемы. Программирование ИИ в значительной степени является исследовательским программированием; цель часто состоит в том, чтобы узнать больше о проблемной области, а не соответствовать четко определенной спецификации. Это противоречит более традиционному представлению о программировании, где задача полностью определяется до того, как будет написана первая строка кода.</em></p>
<p><em></p><h2>4.6 Проблема бега вокруг блока.</h2>
<p></em></p>
<p><em></em></p>
<p><em>Представление оператора "вождение из дома в школу" простое: предварительное условие и список удалений включают в себя пребывание дома, а список добавлений включает в себя пребывание в школе. Но предположим, что мы хотим изобразить "бег вокруг блока"."Не будет никакого чистого изменения местоположения, так означает ли это, что не будет никакого списка добавления или удаления? Если бы это было так, то не было бы никакой причины когда-либо применять какой-либо оператор. Возможно, список дополнений должен содержать что-то вроде "немного потренировался" или "чувствую усталость", или что-то более общее, например "опыт бега вокруг блока".- Мы вернемся к этому вопросу позже.</em></p>
<p><em></p><h2>4.7 Проблема цели - сломаный брат</h2>
<p></em></p>
<p><em></em></p>
<p><em>Подумайте о том, чтобы не только доставить ребенка в школу, но и иметь немного денег, чтобы использовать их до конца дня. GPS может легко решить эту проблему из следующего начального условия:</em></p>
<p><em></p><div class="fragment"><div class="line">(gps &#39;(son-at-home have-money car-works)</div><div class="line">    &#39;(have-money son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">(EXECUTING DRIVE-SON-TO-SCHOOL)</div><div class="line">SOLVED</div></div><!-- fragment --><p> Однако в следующем примере GPS неверно сообщает об успехе, когда на самом деле он потратил деньги на батарею.</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">    &#39;(have-money son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">(EXECUTING LOOK-UP-NUMBER)</div><div class="line">(EXECUTING TELEPHONE-SHOP)</div><div class="line">(EXECUTING TELL-SHOP-PROBLEM)</div><div class="line">(EXECUTING GIVE-SHOP-MONEY)</div><div class="line">(EXECUTING SHOP-INSTALLS-BATTERY)</div><div class="line">(EXECUTING DRIVE-SON-TO-SCHOOL)</div><div class="line">SOLVED</div></div><!-- fragment --><p> "Ошибка" заключается в том, что GPS использует выражение (<code>every #'achieve goals</code>) для достижения набора целей. Если это выражение возвращает true, это означает, что каждая из целей была достигнута последовательно, но это не значит, что все они по-прежнему верны в конце. Иными словами, цель (<code>have-money son-at-school</code>), который у нас означает "оказаться в состоянии, когда есть деньги и сын в школе - истина" было истолковано GPS так: "вначале достичь" <code>have-money</code>, а затем достичь <code>son-at-school</code>. Иногда достижение одной цели может отменить другую, ранее достигнутую цель. Мы назовем это проблемой "предпосылок для достижения братской цели".<a href="#fn0015">2</a> то есть <code>have-money</code> и <code>son-at-school</code> -это родственные цели, одна из предпосылок для плана <code>son-at-school</code> - это работающая машина(<code>car-works</code>), и достижение этой цели разрушает цель <code>have-money</code>.</em></p>
<p><em>Изменение программы для распознавания проблемы "предпосылки повреждение брата цели" является простым. Во-первых, обратите внимание, что мы вызываем (<code>every #</code><code>achieve</code> <em>something</em>) дважды в рамках программы, поэтому давайте заменим эти две формы на ( <code>achieve-all</code> <em>something</em>). Затем мы можем определить <code>achieve-all</code> следующим образом:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun achieve-all (goals)</div><div class="line">  &quot;Try to achieve each goal, then make sure they still hold.&quot;</div><div class="line">  (and (every #&#39;achieve goals) (subsetp goals *state*)))</div></div><!-- fragment --><p> Функция Common Lisp subsetp возвращает true, если ее первый аргумент является подмножеством его вторго аргумента. В <code>achieve-all</code>, она возвращает значение true, если каждая из целей все еще находится в текущем состоянии после достижения всех целей. Это то, что мы хотели проверить.</em></p>
<p><em>Введение <code>achieve-all</code> предотвращает возврат из GPS истины, когда одина из целей повреждена, но это не заставляет GPS перепланировать и попытаться восстановиться из за поврежденной цели. Мы не будем рассматривать эту возможность сейчас, но мы ее рассмотрим снова в разделе о домене мира блоков, который был основным примером Суссмана.</em></p>
<p><em></p><h2>4.8 Прыжок перед тем как вы увидели проблему(прыгнуть в слепую).</h2>
<p></em></p>
<p><em></em></p>
<p><em>Еще один способ решить проблему "предпослыки повреждения брата цели" - это просто более внимательно отнестись к порядку целей в списке целей. Если мы хотим отправить ребенка в школу и еще иметь немного денег, почему бы просто не сказать (<code>son-at-school have-money</code>), а не (<code>have-money son-at-school</code>)? Давайте посмотрим, что произойдет когда мы попробуем это сделать:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">    &#39;(son-at-school have-money)</div><div class="line">    *school-ops*)</div><div class="line">(EXECUTING LOOK-UP-NUMBER)</div><div class="line">(EXECUTING TELEPHONE-SHOP)</div><div class="line">(EXECUTING TELL-SHOP-PROBLEM)</div><div class="line">(EXECUTING GIVE-SHOP-MONEY)</div><div class="line">(EXECUTING SHOP-INSTALLS-BATTERY)</div><div class="line">(EXECUTING DRIVE-SON-TO-SCHOOL)</div><div class="line">NIL</div></div><!-- fragment --><p> GPS возвращает nil, отражая тот факт, что цель не может быть достигнута, но только после того, как выполнены все действия, вплоть до поездки в школу, включительно. Я называю это "прыжком перед тем как проблема будет видна", потому что если бы вы попросили программу решить проблему для двух целей <code>(jump-off-cliff land-safely)</code>, она бы вначале прыгнула и только потом обнаружила, что в ней нет оператора, чтобы безопасно приземлиться. Это далеко не благоразумное поведение.</em></p>
<p><em>Проблема возникает потому, что планирование и исполнение чередуются. Как только предварительные условия для оператора достигнуты, предпринимается дейтсвие-и состояние <code>*state*</code> бесповоротно изменяется, даже если это действие, в конечном итоге, может завести в тупк. Альтернативой было бы заменить одно глобальное состояние <code>*state*</code> различными локальными переменными состояния, так что для каждого нового состояния создавалась бы новая переменная. как мы увидим в следующем разделе, эта альтернатива хороша и по другой, независимой причине.</em></p>
<p><em></p><h2>4.9 Проблема рекурсивности подцели</h2>
<p></em></p>
<p><em></em></p>
<p><em>В нашем моделируемом мире с детским садом есть только один способ узнать номер телефона: посмотреть его в телефонной книге. Предположим, мы хотим добавить оператор, позволяющий узнать номер телефона, спросив кого-либо. Конечно, для того чтобы спросить кого-то о чем-то, вы должны общаться с ним или ней. Оператор для запроса телефонного номера(asking-for-a-phone-number) может быть реализован следующим образом:</em></p>
<p><em></p><div class="fragment"><div class="line">(push (make-op :action &#39;ask-phone-number</div><div class="line">      :preconds &#39;(in-communication-with-shop)</div><div class="line">      :add-list &#39;(know-phone-number))</div><div class="line">    *school-ops*)</div></div><!-- fragment --><p> (Специальная форма ( <code>push</code>*item list*) помещает элемент в начало списка; это выражение эквивалентно (setf <em>list</em> (<code>cons</code>*item list*) ) в простом случае.) К сожалению, иногда случается нечто не ожиданное, когда мы пытаемся решить, казалось бы простые, проблемы с этим новым набором(множеством) операторов. Обратите внимание на следующее:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money)</div><div class="line">    &#39;(son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">&gt;&gt;TRAP 14877 (SYSTEM:PDL-OVERFLOW EH: :REGULAR)</div><div class="line">The regular push-down list has overflown.</div><div class="line">While in the function ACHIEVE &lt;- EVERY &lt;- REMOVE</div></div><!-- fragment --><p> Сообщение об ошибке (которое будет варьироваться от одной реализации Common Lisp к другой) означает, что было сделано слишком много рекурсивно вложенных вызовов функций. Это указывает либо на очень сложную проблему, либо, чаще всего, на ошибку в программе, которая ведет к бесконечной рекурсси. Один из способов попытаться увидеть причину ошибки - это трассировать соответствующую функцию, такую как <code>achieve</code>:</em></p>
<p><em><code>&gt; (trace achieve)</code>=&gt; <code>(ACHIEVE)</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money)</div><div class="line">    &#39;(son-at-school)</div><div class="line">    *school-ops*)</div><div class="line">(1 ENTER ACHIEVE: SON-AT-SCHOOL)</div><div class="line">  (2 ENTER ACHIEVE: SON-AT-HOME)</div><div class="line">  (2 EXIT ACHIEVE: (SON-AT-HOME CAR-NEEDS-BATTERY HAVE-MONEY))</div><div class="line">  (2 ENTER ACHIEVE: CAR-WORKS)</div><div class="line">    (3 ENTER ACHIEVE: CAR-NEEDS-BATTERY)</div><div class="line">    (3 EXIT ACHIEVE: (CAR-NEEDS-BATTERY HAVE-MONEY))</div><div class="line">    (3 ENTER ACHIEVE: SHOP-KNOWS-PROBLEM)</div><div class="line">      (4 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)</div><div class="line">        (5 ENTER ACHIEVE: KNOW-PHONE-NUMBER)</div><div class="line">          (6 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)</div><div class="line">            (7 ENTER ACHIEVE: KNOW-PHONE-NUMBER)</div><div class="line">              (8 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)</div><div class="line">                (9 ENTER ACHIEVE: KNOW-PHONE-NUMBER)</div></div><!-- fragment --><p> Выходные данные трассировки trace дают необходимые подсказки. Ньюэл и Саймон говорят о "колебании(переключении) между целями, требуемыми функциями и средствами, которые необходимы для их выполнения." Здесь, кажется, мы имеем бесконечное колебание между тем, чтобы быть в общеии с магазином (levels 4, 6, 8,...) и попыткой узнать номер телефона магазина (levels 5, 7, 9,...). Рассуждение заключается в следующем: мы хотим, чтобы магазин узнал о проблеме с батареей, и для этого необходимо с ним(или с ней) проконтактировать. Один из спопособов проконтактировать, это позвонить по телефону, но у нас нет телефонной книги, чтобы посмотреть номер. Мы могли бы спросить у них их номер телефона, но для этого нажно с ними проконтактировать. Как выразился Аристотель, "если мы хотим постоянно размышлять, нам придется дойти до бесконечности". Мы назовем это проблемой "рекусивной подцели": попытке решить проблему в териминах самой проблемы. Один из способов избежать этой проблемы - заставить achieve отслеживать все цели, над которыми она работает, и прекращать работу, если она найдет петлю в стеке целей.</em></p>
<p><em></p><h2>4.10 проблема отсутствия промежуточной информации</h2>
<p></em></p>
<p><em></em></p>
<p><em>Когда GPS не может найт решение, он просто возвращает <code>nil</code>. Это раздражает в тех случаях, когда пользователь ожидал, что решение будет найдено, потому что этот nil не дает никакой информации о причине сбоя. Пользователь всегда может отследить(трассировать)какую-то функцию, как мы трассировали выше, но вывод трассировки редко является именно той информцией, которая требуется. Было бы неплохо иметь общий инструмент выводящий отладочную информацию, используя который программист мог бы вставлять операторы печати в свой код и выборочно печатать их в зависимости от желаемой информации.</em></p>
<p><em>Функция <code>dbg</code> обеспечивает эту возможность. <code>dbg</code> печатает выходные данные также как <code>format</code>, но она будет печатать только тогда, когда троебуется отладочный вывод. Каждый вызов <code>dbg</code> сопровождается идентификатором, который используется для укзанания класса отладочных сообщений. Функции <code>debug</code> и <code>undebug</code> используются для добавления или удаления классов сообщений в список классов, которые должны быть напечатаны. В этой главе, все выходные отладочные данные будут использовать идентификатор: <code>gps</code>. Другие программы будут использовать другие идентификаторы, а сложная программа будет использовать много идентификаторов.</em></p>
<p><em>Вызов <code>dbg</code> приведет к выводу, если первый аргумент <code>dbg</code>, является тем, который был указан в вызове <code>debug</code>. Остальные аргументы <code>dbg</code> - это строка формата, за которой следует список аргументов, которые должны быть напечатаны в соответствии с этой строкой формата. Другими словами, мы будем писать функции, которые включают в себя вызовы <code>dbg</code> такие как:</em></p>
<p><em></p><div class="fragment"><div class="line">(dbg :gps &quot;The current goal is: ~a&quot; goal)</div></div><!-- fragment --><p> Если мы включили отладку с помощью <code>(debug :gps)</code>, то вызовы dbg с идентификатором :<code>gps</code> будут выводить выходные данные. Вывод выключается с помощью <code>(undebug :gps)</code>. <code>debug</code> и <code>undebug</code> предназначены для того, чтобы быть похожими на <code>trace</code> и <code>untrace</code>, в том смысле, что они включают и выключают диагностический вывод. Они также следуют соглашению, что <code>debug</code> без аргументов возвращает текущий список идентификаторов, а <code>undebug</code> без аргументов отключает вывод всей отладочной информации. Однако они в отличии от <code>trace</code> и <code>untrace</code>, являются функциями, а не макросами. Если вы исползуете только ключевые слова и целые числа для идентификаторов, то вы не заметите разницы.</em></p>
<p><em>Здесь представлены две новые встроенные функции. Во первых, <code>*debug-io*</code> это поток, обычно используемый для отладки ввода/вывода. Во всех предыдущих вызовах <code>format</code> мы использовали t в качестве аргумента потока, что приводило к переходу вывода в поток <code>*standard-output*</code>. Отправка различных типов выходных данных в различные потоки позволяет пользователю проявлять некоторую гибкость. Например, отладочный вывод может быть направлен в отдельное окно или скопирован в файл. Во вторых, функция <code>fresh-line</code> переходит к следующей строке вывода, если только выходной поток уже не находиться в начале строки.</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *dbg-ids* nil &quot;Identifiers used by dbg&quot;)</div><div class="line"></div><div class="line">(defun dbg (id format-string &amp;rest args)</div><div class="line">  &quot;Print debugging info if (DEBUG ID) has been specified.&quot;</div><div class="line">  (when (member id *dbg-ids*)</div><div class="line">    (fresh-line *debug-io*)</div><div class="line">    (apply #&#39;format *debug-io* format-string args)))</div><div class="line"></div><div class="line">(defun debug (&amp;rest ids)</div><div class="line">  &quot;Start dbg output on the given ids.&quot;</div><div class="line">  (setf *dbg-ids* (union ids *dbg-ids*)))</div><div class="line"></div><div class="line">(defun undebug (&amp;rest ids)</div><div class="line"> &quot;Stop dbg on the ids. With no ids, stop dbg altogether.&quot;</div><div class="line">  (setf *dbg-ids* (if (null ids) nil</div><div class="line">            (set-difference *dbg-ids* ids))))</div></div><!-- fragment --><p> Иногда легче посмотреть отладочный вывод, если он имеет отступ в соответствии с каким-то шаблоном, например глубиной вложенных вызовов функции. Для генерации выходных с отступом определяется функция <code>dbg-indent</code>:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun dbg-indent (id indent format-string &amp;rest args)</div><div class="line">  &quot;Print indented debugging info if (DEBUG ID) has been specified.&quot;</div><div class="line">  (when (member id *dbg-ids*)</div><div class="line">    (fresh-line *debug-io*)</div><div class="line">    (dotimes (i indent) (princ &quot; &quot; *debug-io*))</div><div class="line">    (apply #&#39;format *debug-io* format-string args)))</div></div><!-- fragment --> <h2>4.11 GPS Версия 2: более общий решатель проблем</h2>
<p></em></p>
<p><em></em></p>
<p><em>На этом этапе мы готовы собрать воедино новую версию GPS с решениями для проблем "бега вокруг блока", "предварительных условий ломающего цель брата", "прыжка, прежде чем вы увидите проблему" и "рекурсивной подцели". Глоссарий для новой версии находится в <a href="#f0015">figure 4.2</a>.</em></p>
<p><em></p><table class="doxtable">
<tr>
<th>Символ </th><th>Использование  </th></tr>
<tr>
<td></td><td><b>Функция верхнего уровняunction</b> </td></tr>
<tr>
<td><code>GPS</code> </td><td>Достигает цели из состояния state используя список операторов </td></tr>
<tr>
<td></td><td><b>Специальные переменные</b> </td></tr>
<tr>
<td><code>*ops*</code> </td><td>Список доступных операторов . </td></tr>
<tr>
<td></td><td><b>Типы данных</b> </td></tr>
<tr>
<td><code>op</code> </td><td>Операция с условиями/состояниями preconds, add-list и del-list. </td></tr>
<tr>
<td></td><td><b>Главные функции</b> </td></tr>
<tr>
<td><code>achieve-all</code> </td><td>достижение списка целей. </td></tr>
<tr>
<td><code>achieve</code> </td><td>достижение индивидуальной цели </td></tr>
<tr>
<td><code>appropriate-p</code> </td><td>Решает, подходит ли оператор для достижения цели. </td></tr>
<tr>
<td><code>apply-op</code> </td><td>Применяет оператор к текущему состоянию </td></tr>
<tr>
<td></td><td><b>вспомогательные функции</b> </td></tr>
<tr>
<td><code>executing-p</code> </td><td>Является ли условие <em>исполняемой</em> формой? </td></tr>
<tr>
<td><code>starts-with</code> </td><td>Является ли аргумент списком, который начинается с данного атома? </td></tr>
<tr>
<td><code>convert-op</code> </td><td>Преобраз. оператора при использовании соглашения о <em>исполнении</em>. </td></tr>
<tr>
<td><code>op</code> </td><td>Создает оператор. </td></tr>
<tr>
<td><code>use</code> </td><td>Используемый список операторов. </td></tr>
<tr>
<td><code>member-equal</code> </td><td>Проверяет, равен ли элемент члену списка. </td></tr>
<tr>
<td></td><td><b>Выбранные Функции Common Lisp</b> </td></tr>
<tr>
<td><code>member</code> </td><td>Проверяет является ли элемент членом списка (p.78) </td></tr>
<tr>
<td><code>set-difference</code> </td><td>Все элементы в одном множестве, не входящие в другое </td></tr>
<tr>
<td><code>subsetp</code> </td><td>Содержится ли одино множество целиком в другом? </td></tr>
<tr>
<td><code>union</code> </td><td>Все элементы в любом из двух наборов (p. 62) </td></tr>
<tr>
<td><code>every</code> </td><td>проверяет, проходит ли тест каждый элемент списка. </td></tr>
<tr>
<td><code>some</code> </td><td>Проверяет, проходит ли тест какой-либо элемент списка. </td></tr>
<tr>
<td><code>remove-if</code> </td><td>Удаляет все элементы, удовлетворяющие тесту. </td></tr>
<tr>
<td></td><td><b>Ранее определенные функции</b> </td></tr>
<tr>
<td><code>find-all</code> </td><td>Список всех совпадающих элементов (p. 101) </td></tr>
<tr>
<td><code>find-all-if</code> </td><td>Список всех элементов, удовлетворяющих предикату </td></tr>
</table>
<p>Самое важное изменение заключается в том, что вместо печати сообщения при применении каждого оператора мы будем иметь <code>GPS</code>, возвращающий результирующее состояние. Список "сообщений" в каждом состоянии указывает, какие действия были предприняты. Каждое сообщение на самом деле является условием, списком формы (executing <em>operator</em>). Это решает проблему "бега вокруг блока": мы можем вызвать <code>GPS</code> с начальной целью <code>((executing run-around-block))</code>, И он выполнит оператор <code>run-around-block</code>, Тем самым удовлетворяя этой цели. Следующий код определяет новую функцию op, которая строит операторы, включающие сообщение(message) в свой список add-list.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun executing-p (x)</div><div class="line">  &quot;Is x of the form: (executing ...) ?&quot;</div><div class="line">  (starts-with x &#39;executing))</div><div class="line"></div><div class="line">(defun starts-with (list x)</div><div class="line">  &quot;Is this a list whose first element is x?&quot;</div><div class="line">  (and (consp list) (eql (first list) x)))</div><div class="line"></div><div class="line">(defun convert-op (op)</div><div class="line">  &quot;Make op conform to the (EXECUTING op) convention.&quot;</div><div class="line">  (unless (some #&#39;executing-p (op-add-list op))</div><div class="line">    (push (list &#39;executing (op-action op)) (op-add-list op)))</div><div class="line">  op)</div><div class="line"></div><div class="line">(defun op (action &amp;key preconds add-list del-list)</div><div class="line">  &quot;Make a new operator that obeys the (EXECUTING op) convention.&quot;</div><div class="line">  (convert-op</div><div class="line">    (make-op :action action :preconds preconds</div><div class="line">          :add-list add-list :del-list del-list)))</div></div><!-- fragment --><p> Операторы, построенные op, будут правильными, но мы можем конвертировать существующие операторы, используя <code>convert-op</code> напрямую:</em></p>
<p><em></p><div class="fragment"><div class="line">(mapc #&#39;convert-op *school-ops*)</div></div><!-- fragment --><p></em></p>
<p><em>Это пример исследовательского программирования: вместо того, чтобы начинать все сначала, когда мы обнаруживаем ограничение первой версии, мы можем использовать Lisp для изменения существующих структур данных для новой версии программы.</em></p>
<p><em>Определение переменной <code>*ops*</code> и структуры op точно такие же, как и раньше, а остальная часть программы состоит из пяти функций, которые мы уже видели: <code>GPS</code>, <code>achieve-all</code>, <code>achieve</code>, <code>appropriate-p</code> и <code>apply-op</code>. На верхнем уровне функция <code>GPS</code> вызывает <code>achieve-all</code>, которая возвращает либо nil, либо допустимое состояние. Из него мы удаляем все атомы, в результате чего остаются только элементы конечного состояния, которые являются списками - другими словами, действиями формы (<code>executing</code>*operator*). Таким образом, значение возвращаемое <code>GPS</code> само по себе является списком действий, предпринимаемых для достижения конечного состояния. <code>GPS</code> больше не возвращает <code>SOLVED</code>, когда он находит решение, но она по-прежнему подчиняется условию возврата nil в случае неудачи и не-nil для успеха. В общем, это хорошая идея, чтобы программа возвращала значимое значение, а не печатала это значение, если есть вероятность, что какая-то другая программа когда-нибудь захочет использовать это значение.</em></p>
<p><em></p><div class="fragment"><div class="line">(defvar *ops* nil &quot;A list of available operators.&quot;)</div><div class="line"></div><div class="line">(defstruct op &quot;An operation&quot;</div><div class="line">  (action nil) (preconds nil) (add-list nil) (del-list nil))</div><div class="line"></div><div class="line">(defun GPS (state goals &amp;optional (*ops* *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (remove-if #&#39;atom (achieve-all (cons &#39;(start) state) goals nil)))</div></div><!-- fragment --><p></em></p>
<p><em>Первое серьезное изменение в версии 2 очевидно из первой строки программы: отсутствует переменная <code>*state*</code>. Вместо этого программа отслеживает локальные переменные состояния - state. Это сделано для того, чтобы решить проблему «прыжка, прежде чем посмотреть», как было сказано ранее. Все функции <code>achieve</code>, <code>achieve-all</code> и <code>apply-op</code> принимают дополнительный аргумент, который является текущим состоянием, и все возвращают новое состояние в качестве своего значения. Они также должны подчиняются соглашению о возврате nil в случае неудачи.</em></p>
<p><em>Таким образом, у нас получается потенциальная двусмысленность: обозначает ли nil, что решение не найдено или допустимое состояние, которое не имеет условий? Мы разрешаем двусмысленность, принимая соглашение, согласно которому все состояния должны иметь хотя бы одно условие. Это соглашение обеспечивается функцией GPS. Вместо вызова (<code>achieve-all state goals nil</code>), GPS вызывает `(achieve-all (cons '(start) state) goals nil)<code>. Таким образом, даже если пользователь передает GPS нулевое начальное состояние, та создаст состояние, содержащее</code>(start)<code>, передав его в</code>achieve-all<code>. С этого момента нам гарантируется, что ни одно состояние никогда не станет nil, потому что единственная функция, которая создает новое состояние - это</code>apply-op<code>, и мы можем видеть, посмотрев на последнюю строку</code>apply-op`, что она всегда добавляет что-то в возвращаемое состояние. (Список добавлений - add-list никогда не может быть nil, потому что в противном случае оператор не был бы уместен. Кроме того, каждый оператор включает условие (executing ...).)</em></p>
<p><em>Обратите внимание, что из конечного значения, которое мы возвращаем из GPS, удалены все атомы, поэтому в конечном итоге мы сообщаем только о выполненных действиях, поскольку они представлены условиями формы (<code>executing *action*</code>). Добавление условия <code>(start)</code> в начале также служит для отличия проблемы, которая не может быть решена, от проблемы, которая решается без выполнения каких-либо действий. Отказ возвращает nil, в то время как решение без выполнения шагов будет, по крайней мере, включать условие <code>(start)</code>, если ничего больше требуется.</em></p>
<p><em>Функции, которые возвращают nil как признак сбоя и возвращают какое-то полезное значение, иначе известны как <em>полупредикаты</em>(<em>semipredicates</em>). Они подвержены ошибкам только в тех случаях, когда nil может быть истолковано как полезное значение. Будьте осторожны при определении и использовании полупредикатов: (1) Решите, может ли nil когда-либо быть значимым значением. (2) Убедитесь, что <em>пользователь</em> не может повредить программу, указав в качестве значения nil. В этой программе GPS - единственная функция, которую пользователь должен вызывать, поэтому, как только мы это учли, все готово. (3) Убедитесь, что <em>программа</em> не может передать значение nil. Мы сделали это, увидев, что в программе было только одно место, где были созданы новые состояния, и что это новое состояние было сформировано путем добавления одноэлементного списка к другому состоянию. Следуя этой трехэтапной процедуре, мы получаем неформальное доказательство того, что полупредикаты, работающие с состояниями, будут работать правильно. Такая процедура неформального доказательства является обычным элементом хорошего дизайна программы.</em></p>
<p><em>Другое большое изменение в версии 2 - это введение стека целей для решения проблемы рекурсивных подцелей. Программа отслеживает цели, над которыми она работает, и немедленно терпит неудачу, если цель выступает в качестве подцели. Эта проверка выполняется во втором предложении/пункте <code>achieve</code>.</em></p>
<p><em>Функция <code>achieve-all</code> пытается достичь каждой из целей по очереди, устанавливая переменную <code>current-state</code> как значение, возвращаемое при каждом последующем вызове функции <code>achieve</code>. Если все цели достигаются по очереди, и если все цели все еще сохраняются в конце (что и проверяет <code>subsetp</code>), то возвращается конечное состояние; в противном случае функция завершается ошибкой, возвращая nil.</em></p>
<p><em>Большая часть работы выполняется с помощью <code>achieve</code>, которой передается состояние, условие единственной цели и набор целей, над которыми до сих пор работали. Если условие уже находится в состоянии, то <code>achieve</code> завершается успешно и возвращает состояние. С другой стороны, если целевое условие уже находится в стеке целей, тогда нет смысла продолжать - мы застрянем в бесконечном цикле, поэтому <code>achieve</code> вернет nil. В противном случае <code>achieve</code> просматривает список операторов, пытаясь найти подходящий для применения.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun achieve-all (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, and make sure they still hold at the end.&quot;</div><div class="line">  (let ((current-state state))</div><div class="line">    (if (and (every #&#39;(lambda (g)</div><div class="line">            (setf current-state</div><div class="line">              (achieve current-state g goal-stack)))</div><div class="line">          goals)</div><div class="line">        (subsetp goals current-state :test #&#39;equal))</div><div class="line">      current-state)))</div><div class="line"></div><div class="line">(defun achieve (state goal goal-stack)</div><div class="line">  &quot;A goal is achieved if it already holds,</div><div class="line">  or if there is an appropriate op for it that is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Goal: &quot;a&quot; goal)</div><div class="line">  (cond ((member-equal goal state) state)</div><div class="line">      ((member-equal goal goal-stack) nil)</div><div class="line">      (t (some #&#39;(lambda (op) (apply-op state goal op goal-stack))</div><div class="line">          (find-all goal *ops* :test #&#39;appropriate-p)))))</div></div><!-- fragment --><p></em></p>
<p><em>Цель <code>( (executing run-around-block) )</code> представляет собой список из одного условия, где условие является списком из двух элементов. Применение списков в качестве условий дает нам большую гибкость, но мы также должны быть осторожны. Проблема в том, что не все похожие списки на самом деле одинаковы. Предикат equal по существу проверяет, похожи ли два его аргумента, а предикат <code>eql</code> проверяет, идентичны ли два его аргумента. Поскольку такие функции, как <code>member</code> по умолчанию используют <code>eql</code>, мы должны указать с помощью ключевого слова <code>:test</code>, которое мы хотим вместо него использовать. Поскольку это делается несколько раз, мы вводим функцию <code>member-equal</code>. Фактически, мы могли бы продвинуть абстракцию еще на один шаг и определить <code>member-situation</code>, функцию для проверки того, является ли условие истинным в некоторой ситуации. Это позволит пользователю изменить функцию сопоставления с <code>eql</code> на <code>equal</code> и на все остальное, что может быть полезно.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun member-equal (item list)</div><div class="line">  (member item list :test #&#39;equal))</div></div><!-- fragment --><p></em></p>
<p><em>Функция <code>apply-op</code>, которая раньше безвозвратно изменяла состояние и печатала сообщение, отражающее это, теперь возвращает новое состояние вместо того, чтобы что-либо печатать. Сначала она вычисляет состояние, которое будет результатом выполнения всех предварительных условий оператора. Если возможно достичь такого состояния, то <code>apply-op</code> возвращает новое состояние, из полученного состояния, добавляя то, что находится в списке добавления(add-list), и удаляя все что находится в списке удаления(delete-list).</em></p>
<p><em></p><div class="fragment"><div class="line">(defun apply-op (state goal op goal-stack)</div><div class="line">  &quot;Return a new, transformed state if op is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Consider: ~a&quot; (op-action op))</div><div class="line">  (let ((state2 (achieve-all state (op-preconds op)</div><div class="line">            (cons goal goal-stack))))</div><div class="line">    (unless (null state2)</div><div class="line">      ;; Return an updated state</div><div class="line">      (dbg-indent :gps (length goal-stack) &quot;Action: ~a&quot; (op-action op))</div><div class="line">      (append (remove-if #&#39;(lambda (x)</div><div class="line">            (member-equal x (op-del-list op)))</div><div class="line">          state2)</div><div class="line">        (op-add-list op)))))</div><div class="line"></div><div class="line">(defun appropriate-p (goal op)</div><div class="line">  &quot;An op is appropriate to a goal if it is in its add-list.&quot;</div><div class="line">  (member-equal goal (op-add-list op)))</div></div><!-- fragment --><p></em></p>
<p><em>Есть еще одна сложность в способе вычисления нового состояния. В версии 1 GPS состояния были (концептуально) неупорядоченными наборами(множествами) условий, поэтому мы могли использовать <code>union</code> и <code>set-difference</code> для работы с ними. В версии 2 состояния становятся упорядоченными списками, потому что нам нужно сохранить порядок действий. Таким образом, мы должны использовать функции <code>append</code> и <code>remove-if</code>, так как они сохраненяют порядок обрабатываемого списка, а <code>union</code> и <code>set-difference</code> - нет.</em></p>
<p><em>Наконец, последнее отличие версии 2 состоит в том, что она вводит новую функцию: <code>use</code>. Эта функция предназначена для использования в качестве своего рода объявления о том, что данный список операторов должен использоваться для решения ряда проблем.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun use (oplist)</div><div class="line">  &quot;Use oplist as the default list of operators.&quot;</div><div class="line">  ;; Return something useful, but not too verbose:</div><div class="line">  ;; the number of operators.</div><div class="line">   (length (setf *ops* oplist)))</div></div><!-- fragment --><p></em></p>
<p><em>Вызов use устанавливает параметр <code>*ops*</code>, поэтому его не нужно указывать при каждом вызове GPS. Соответственно, в определении самого GPS третий аргумент, <code>*ops*</code>, теперь необязателен; если он не указан, будет использоваться значение по умолчанию. Значение по умолчанию для <code>*ops*</code> дается как <code>*ops*</code>. Это может показаться излишним или черезмерным - как переменная может быть сама собой по умолчанию? Ответ заключается в том, что два появления <code>*ops*</code> похожи друг на друга, но на самом деле они относятся к двум совершенно отдельным привязкам специальной переменной <code>*ops*</code>. В большинстве случаев переменные в списках параметров являются локальными переменными, но нет правила, запрещающего привязку специальной переменной в качестве параметра. Помните, что эффект привязки специальной переменной заключается в том, что все ссылки на специальную переменную, которые встречаются в любом месте программы - даже за пределами лексической области действия функции, - относятся к новой привязке специальной переменной. Итак, после последовательности вызовов мы в конечном итоге достигаем достижения, которое ссылается на <code>*ops*</code>, и оно увидит новое связанное значение <code>*ops*</code>.</em></p>
<p><em>Определение GPS повторяемоездесь вместе с альтернативной версией, которая связывает локальную переменную и явно устанавливает и сбрасывает специальную переменную <code>*ops*</code>. Очевидно, что идиома привязки специальной переменной более лаконична, хотя она и может выглядеть вначале запутанной, она полезна, когда ее понимают.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun GPS (state goals &amp;optional (*ops* *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (remove-if #&#39;atom (achieve-all (cons &#39;(start) state) goals nil)))</div><div class="line"></div><div class="line">(defun GPS (state goals &amp;optional (ops *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (let ((old-ops *ops*))</div><div class="line">    (setf *ops* ops)</div><div class="line">    (let ((result (remove-if #&#39;atom (achieve-all</div><div class="line">                  (cons&#39;(start) state)</div><div class="line">                  goals nil ))))</div><div class="line">      (setf *ops* old-ops)</div><div class="line">      result)))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь давайте посмотрим, как работает версия 2. Мы используем список операторов, который включает в себя оператор "спросить у магазина их номер телефона". Сначала мы убедимся, что он все еще будет делать примеры, которые сделала Версия 1:</em></p>
<p><em><code>&gt; (use *school-ops*)</code>=&gt; <code>7</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">      &#39;(son-at-school))</div><div class="line">((START)</div><div class="line">  (EXECUTING LOOK-UP-NUMBER)</div><div class="line">  (EXECUTING TELEPHONE-SHOP)</div><div class="line">  (EXECUTING TELL-SHOP-PROBLEM)</div><div class="line">  (EXECUTING GIVE-SHOP-MONEY)</div><div class="line">  (EXECUTING SHOP-INSTALLS-BATTERY)</div><div class="line">  (EXECUTING DRIVE-SON-TO-SCHOOL))</div></div><!-- fragment --><p></em></p>
<p><em><code>&gt; (debug :gps)</code>=&gt; <code>(:GPS)</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">      &#39;(son-at-school))</div><div class="line">Goal: SON-AT-SCHOOL</div><div class="line">Consider: DRIVE-SON-TO-SCHOOL</div><div class="line">  Goal: SON-AT-HOME</div><div class="line">  Goal: CAR-WORKS</div><div class="line">  Consider: SHOP-INSTALLS-BATTERY</div><div class="line">    Goal: CAR-NEEDS-BATTERY</div><div class="line">    Goal: SHOP-KNOWS-PROBLEM</div><div class="line">    Consider: TELL-SHOP-PROBLEM</div><div class="line">      Goal: IN-COMMUNICATION-WITH-SHOP</div><div class="line">      Consider: TELEPHONE-SHOP</div><div class="line">        Goal: KNOW-PHONE-NUMBER</div><div class="line">        Consider: ASK-PHONE-NUMBER</div><div class="line">          Goal: IN-COMMUNICATION-WITH-SHOP</div><div class="line">        Consider: LOOK-UP-NUMBER</div><div class="line">          Goal: HAVE-PHONE-BOOK</div><div class="line">        Action: LOOK-UP-NUMBER</div><div class="line">      Action: TELEPHONE-SHOP</div><div class="line">    Action: TELL-SHOP-PROBLEM</div><div class="line">    Goal: SHOP-HAS-MONEY</div><div class="line">    Consider: GIVE-SHOP-MONEY</div><div class="line">      Goal: HAVE-MONEY</div><div class="line">    Action: GIVE-SHOP-MONEY</div><div class="line">  Action: SHOP-INSTALLS-BATTERY</div><div class="line">Action: DRIVE-SON-TO-SCHOOL</div><div class="line">((START)</div><div class="line">  (EXECUTING LOOK-UP-NUMBER)</div><div class="line">  (EXECUTING TELEPHONE-SHOP)</div><div class="line">  (EXECUTING TELL-SHOP-PROBLEM)</div><div class="line">  (EXECUTING GIVE-SHOP-MONEY)</div><div class="line">  (EXECUTING SHOP-INSTALLS-BATTERY)</div><div class="line">  (EXECUTING DRIVE-SON-TO-SCHOOL))</div></div><!-- fragment --><p></em></p>
<p><em><code>&gt; (undebug)</code>=&gt; <code>NIL</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-works)</div><div class="line">      &#39;(son-at-school))</div><div class="line">((START)</div><div class="line">  (EXECUTING DRIVE-SON-TO-SCHOOL))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы видим, что версия 2 также может справиться с тремя случаями, в которых Версия 1 ошиблась. В каждом случае программа избегает бесконечного цикла, а также избегает прыгать до того, как он посмотреть, нет ли какой опасности.</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">      &#39;(have-money son-at-school))</div><div class="line">NIL</div><div class="line">&gt; (gps &#39;(son-at-home car-needs-battery have-money have-phone-book)</div><div class="line">      &#39;(son-at-school have-money))</div><div class="line">NIL</div><div class="line">(gps &#39;(son-at-home car-needs-battery have-money)</div><div class="line">      &#39;(son-at-school) )</div><div class="line">NIL</div></div><!-- fragment --><p></em></p>
<p><em>Наконец, мы видим, что эта версия GPS также работает над тривиальными проблемами, не требующими никаких действий:</em></p>
<p><em>`&gt; (gps '(son-at-home) '(son-at-home))<code>=&gt;</code>((START))`</em></p>
<p><em></p><h2>4.12 новая пробленая область(проблемный домен): обезьяна и бананы</h2>
<p></em></p>
<p><em></em></p>
<p><em>Чтобы показать, что GPS действительно является общим, мы должны заставить его работать в разных областях. Начнем с "классической" задачи ИИ.<a href="#fn0020">3</a> Представьте себе следующий сценарий: голодная обезьяна стоит в дверях комнаты. В центре комнаты на веревке с потолка свисает гроздь бананов, до которых обезьяне не дотянуться. У двери стоит стул, достаточно легкий, чтобы обезьяна могла толкать его, и достаточно высокий, чтобы дотянуться почти до бананов. Чтобы все усложнить, предположим, что обезьяна держит игрушечный мяч и может держать только одну вещь одновременно.</em></p>
<p><em>Пытаясь представить этот сценарий, мы имеем некоторую гибкость в выборе того, что поместить в текущее состояние и что поместить с операторами. Теперь предположим, что мы определяем операторы следующим образом:</em></p>
<p><em></p><div class="fragment"><div class="line">(defparameter *banana-ops*</div><div class="line">  (list</div><div class="line">    (op</div><div class="line">      &#39;climb-on-chair       ;;забраться на стул</div><div class="line">      :preconds &#39;(chair-at-middle-room at-middle-room on-floor)</div><div class="line">      :add-list &#39;(at-bananas on-chair)</div><div class="line">      :del-list &#39;(at-middle-room on-floor))</div><div class="line">    (op </div><div class="line">      &#39;push-chair-from-door-to-middle-room ;;толкать стул от двери к середине комнаты</div><div class="line">      :preconds &#39;(chair-at-door at-door)</div><div class="line">      :add-list &#39;(chair-at-middle-room at-middle-room)</div><div class="line">      :del-list &#39;(chair-at-door at-door))</div><div class="line">    (op </div><div class="line">      &#39;walk-from-door-to-middle-room ;;идти от двери к середине комнаты</div><div class="line">      :preconds &#39;(at-door on-floor)</div><div class="line">      :add-list &#39;(at-middle-room)</div><div class="line">      :del-list &#39;(at-door))</div><div class="line">    (op </div><div class="line">      &#39;grasp-bananas   ;;схавтить банан</div><div class="line">      :preconds &#39;(at-bananas empty-handed)</div><div class="line">      :add-list &#39;(has-bananas)</div><div class="line">      :del-list &#39;(empty-handed))</div><div class="line">    (op </div><div class="line">      &#39;drop-ball        ;; бросить мяч</div><div class="line">      :preconds &#39;(has-ball)</div><div class="line">      :add-list &#39;(empty-handed)</div><div class="line">      :del-list &#39;(has-ball))</div><div class="line">    (op </div><div class="line">      &#39;eat-bananas      ;;съесть банан</div><div class="line">      :preconds &#39;(has-bananas)</div><div class="line">      :add-list &#39;(empty-handed not-hungry)</div><div class="line">      :del-list &#39;(has-bananas hungry))))</div></div><!-- fragment --><p></em></p>
<p><em>Используя эти операторы, мы могли бы поставить задачу стать не-голодными(not-hungry), учитывая начальное состояние нахождения у двери, стоя на полу, держа мяч, голодные и со стулом у двери. <code>GPS</code> может найти решение этой проблемы:</em></p>
<p><em><code>&gt; (use *banana-ops*)</code>=&gt; <code>6</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (GPS &#39;(at-door on-floor has-ball hungry chair-at-door)</div><div class="line">      &#39;(not-hungry))</div><div class="line">((START)</div><div class="line">  (EXECUTING PUSH-CHAIR-FROM-DOOR-TO-MIDDLE-ROOM)</div><div class="line">  (EXECUTING CLIMB-ON-CHAIR)</div><div class="line">  (EXECUTING DROP-BALL)</div><div class="line">  (EXECUTING GRASP-BANANAS)</div><div class="line">  (EXECUTING EAT-BANANAS))</div></div><!-- fragment --><p></em></p>
<p><em>Обратите внимание, что нам не нужно было вносить какие-либо изменения в программу <code>GPS</code>. Мы просто использовали другой набор операторов.</em></p>
<p><em></p><h2>4.13 Проблемная область(домен) Поиск в Лабиринте</h2>
<p></em></p>
<p><em></em></p>
<p><em>Теперь рассмотрим еще одну «классическую» проблему - поиск в лабиринте. Предположим, что здесь изображен конкретный лабиринт.</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-01.jpg" alt="u04-01"/>
</div>
<p></em></p>
<p><em>Намного проще определить некоторые функции, помогающие создавать операторы для этого домена, чем вводить все операторы напрямую. Следующий код определяет набор операторов для лабиринтов в целом и для этого лабиринта в частности:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun make-maze-ops (pair)</div><div class="line">  &quot;Make maze ops in both directions&quot;</div><div class="line">  (list (make-maze-op (first pair) (second pair))</div><div class="line">      (make-maze-op (second pair) (first pair))))</div><div class="line">(defun make-maze-op (here there)</div><div class="line">  &quot;Make an operator to move between two places&quot;</div><div class="line">  (op </div><div class="line">    `(move from ,here to ,there)</div><div class="line">    :preconds `((at ,here))</div><div class="line">    :add-list `((at ,there))</div><div class="line">    :del-list `((at ,here))))</div><div class="line">(defparameter *maze-ops*</div><div class="line">  (mappend #&#39;make-maze-ops</div><div class="line">    &#39;((1 2) (2 3) (3 4) (4 9) (9 14) (9 8) (8 7) (7 12) (12 13)</div><div class="line">      (12 11) (11 6) (11 16) (16 17) (17 22) (21 22) (22 23)</div><div class="line">      (23 18) (23 24) (24 19) (19 20) (20 15) (15 10) (10 5) (20 25))))</div></div><!-- fragment --><p></em></p>
<p><em>Обратите внимание на обозначение обратных кавычек <code>( ` )</code>. Она объясняется в <a href="B9780080571157500030.xhtml#s0020">Разделе 3.2</a>, <a href="B9780080571157500030.xhtml#p67">page 67</a>.</em></p>
<p><em>Теперь мы можем использовать этот список операторов для решения нескольких задач с этим лабиринтом. И мы могли бы легко создать еще один лабиринт, предоставив еще один список связей. Обратите внимание, что нет ничего, что говорило бы о том, что места в лабиринте расположены по схеме пять на пять - это всего лишь один из способов визуализации связности.</em></p>
<p><em><code>&gt; (use *maze-ops*)</code>=&gt; <code>48</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((at 1)) &#39;((at 25)))</div><div class="line">((START)</div><div class="line">  (EXECUTING-(MOVE-FROM-1 TO 2))</div><div class="line">  (EXECUTING-(MOVE-FROM-2 TO 3))</div><div class="line">  (EXECUTING-(MOVE-FROM-3 TO 4))</div><div class="line">  (EXECUTING-(MOVE-FROM-4 TO 9))</div><div class="line">  (EXECUTING-(MOVE-FROM-9 TO 8))</div><div class="line">  (EXECUTING-(MOVE-FROM-8 TO 7))</div><div class="line">  (EXECUTING-(MOVE-FROM-7 TO 12))</div><div class="line">  (EXECUTING-(MOVE-FROM-12 TO 11))</div><div class="line">  (EXECUTING-(MOVE-FROM-11 TO 16))</div><div class="line">  (EXECUTING-(MOVE-FROM-16 TO 17))</div><div class="line">  (EXECUTING-(MOVE-FROM-17 TO 22))</div><div class="line">  (EXECUTING-(MOVE-FROM-22 TO 23))</div><div class="line">  (EXECUTING-(MOVE-FROM-23 TO 24))</div><div class="line">  (EXECUTING-(MOVE-FROM-24 TO 19))</div><div class="line">  (EXECUTING-(MOVE-FROM-19 TO 20))</div><div class="line">  (EXECUTING-(MOVE-FROM-20 TO 25))</div><div class="line">  (AT 25))</div></div><!-- fragment --><p></em></p>
<p><em>Есть одна тонкая ошибка, на которую указывает домен лабиринта. Мы хотели, чтобы GPS возвращал список выполненных действий. Однако, чтобы учесть случай, когда цель может быть достигнута без каких-либо действий, я включил <code>(START)</code> в значение, возвращаемое GPS. Эти примеры включают формы <code>START</code> и <code>EXECUTING</code>, а также список формы (AT <em>n</em>) для некоторых <em>n</em>. Это ошибка. Если мы вернемся и посмотрим на функцию GPS, мы обнаружим, что она сообщает о результатах, удаляя все атомы из состояния, возвращенного <code>achieve-all</code>. Это «подмена понятий» - мы говорили об удалении атомов, когда на самом деле намеревались удалить все условия, кроме форм <code>(START)</code> и <code>(EXECUTING *action*)</code>. До сих пор все эти условия были атомами, поэтому этот подход работал. В области лабиринта введены условия вида (<code>AT</code> <em>n</em>), так что впервые возникла проблема. Мораль такова: когда программист использует подмены, говоря, что удобно, а не то, что на самом деле происходит, неизбежно возникают проблемы. На самом деле мы хотим не удалять атомы, а найти все элементы, обозначающие действия. Код ниже говорит о том, что мы имеем в виду:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun GPS (state goals &amp;optional (*ops* *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (find-all-if #&#39;action-p</div><div class="line">        (achieve-all (cons &#39;(start) state) goals nil)))</div><div class="line">(defun action-p (x)</div><div class="line">  &quot;Is x something that is (start) or (executing ...)?&quot;</div><div class="line">  (or (equal x &#39;(start)) (executing-p x)))</div></div><!-- fragment --><p></em></p>
<p><em>Домен решений лабиринтов также указывает на преимущество версии 2: она возвращает представление о предпринятых действиях, а не просто распечатывает их. Причина, по которой это является преимуществом, заключается в том, что мы можем захотеть использовать результаты для чего-то, а не просто смотреть на них. Предположим, нам нужна функция, которая дает нам путь через лабиринт в виде списка мест, которые нужно посетить по очереди. Мы могли бы сделать это, вызвав GPS в качестве подфункции, а затем использовать результаты:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun find-path (start end)</div><div class="line">  &quot;Search a maze for a path from start to end.&quot;</div><div class="line">  (let ((results (GPS `((at ,start)) `((at ,end)))))</div><div class="line">    (unless (null results)</div><div class="line">      (cons start (mapcar #&#39;destination</div><div class="line">              (remove &#39;(start) results</div><div class="line">                  :test #&#39;equal))))))</div><div class="line">(defun destination (action)</div><div class="line">  &quot;Find the Y in (executing (move from X to Y))&quot;</div><div class="line">  (fifth (second action)))</div></div><!-- fragment --><p></em></p>
<p><em>Функция <code>find-path</code> вызывает GPS для получения результатов - <code>results</code>. Если это <code>nil</code>, ответа нет, а если есть, то возьмите «остаток» - <code>rest</code> от <code>results</code> (другими словами, игнорируйте часть <code>(START)</code>). Выберите пункт назначения, <code>*y*</code> из каждой формы <code>(EXECUTING (MOVE FROM x TO y))</code> и не забудьте указать начальную точку.</em></p>
<p><em><code>&gt; (use *maze-ops*)</code>=&gt; <code>48</code></em></p>
<p><em><code>&gt; (find-path 1 25)</code>=&gt;</em></p>
<p><em></p><div class="fragment"><div class="line">(1 2 3 4 9 8 7 12 11 16 17 22 23 24 19 20 25)</div></div><!-- fragment --><p></em></p>
<p><em><code>&gt; (find-path 1 1)</code>=&gt; <code>(1)</code></em></p>
<p><em><code>&gt; (equal (find-path 1 25) (reverse (find-path 25 1)))</code>=&gt; <code>T</code></em></p>
<p><em></p><h2>4.14 Домен Мира Блоков(Blocks World)</h2>
<p></em></p>
<p><em></em></p>
<p><em>Еще одна область(домен), которая привлекает большое внимания в кругах ИИ, - это мир блоков. Представьте детский набор строительных блоков на столе. Проблема состоит в том, чтобы переместить блоки из их начальной конфигурации в некоторую целевую конфигурацию. Мы предполагаем, что каждый блок может иметь только один другой блок непосредственно поверх него, хотя они могут быть размещены на произвольной высоте. Единственное действие, которое можно предпринять в этом мире, - это переместить отдельный блок, на котором ничего нет, либо наверх другого блока, либо на стол, который представляет мир блоков. Мы создадим операторы для каждого возможного перемещения блока.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun make-block-ops (blocks)</div><div class="line">  (let ((ops nil))</div><div class="line">    (dolist (a blocks)</div><div class="line">      (dolist (b blocks)</div><div class="line">        (unless (equal a b)</div><div class="line">          (dolist (c blocks)</div><div class="line">            (unless (or (equal c a) (equal c b))</div><div class="line">              (push (move-op a b c) ops)))</div><div class="line">          (push (move-op a &#39;table b) ops)</div><div class="line">          (push (move-op a b &#39;table) ops))))</div><div class="line">    ops))</div><div class="line">(defun move-op (a b c)</div><div class="line">  &quot;Make an operator to move A from B to C.&quot;</div><div class="line">  (op </div><div class="line">      &#39;(move ,a from ,b to ,c)</div><div class="line">      :preconds &#39;((space on ,a) (space on ,c) (,a on ,b))</div><div class="line">      :add-list (move-ons a b c)</div><div class="line">      :del-list (move-ons a c b)))</div><div class="line">(defun move-ons (a b c)</div><div class="line">  (if (eq b &#39;table)</div><div class="line">      &#39;((,a on ,c))</div><div class="line">      &#39;((.a on ,c) (space on ,b))))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы опробуем эти операторы на некоторых задачах. Самая простая проблема - это положить однин блок на другой:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-02.jpg" alt="u04-02"/>
</div>
<p></em></p>
<p><em>`&gt; (use (make-block-ops '(a b)))<code>=&gt;</code>4`</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((a on table) (b on table) (space on a) (space on b)</div><div class="line">      (space on table))</div><div class="line">    &#39;((a on b) (b on table)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE A FROM TABLE TO B)))</div></div><!-- fragment --><p></em></p>
<p><em>Вот немного более сложная проблема: инвертирование стопки из двух блоков. На этот раз мы показываем результаты отладки.</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-03.jpg" alt="u04-03"/>
</div>
<p></em></p>
<p><em><code>&gt; (debug :gps)</code>=&gt; <code>(:GPS)</code></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((a on b) (b on table) (space on a) (space on table))</div><div class="line">      &#39;((b on a)))</div><div class="line">Goal: (B ON A)</div><div class="line">Consider: (MOVE B FROM TABLE TO A)</div><div class="line">  Goal: (SPACE ON B)</div><div class="line">  Consider: (MOVE A FROM B TO TABLE)</div><div class="line">    Goal: (SPACE ON A)</div><div class="line">    Goal: (SPACE ON TABLE)</div><div class="line">    Goal: (A ON B)</div><div class="line">  Action: (MOVE A FROM B TO TABLE)</div><div class="line">  Goal: (SPACE ON A)</div><div class="line">  Goal: (B ON TABLE)</div><div class="line">Action: (MOVE B FROM TABLE TO A)</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE A FROM B TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM TABLE TO A)))</div></div><!-- fragment --><p></em></p>
<p><em><code>&gt; (undebug)</code>=&gt; <code>NIL</code></em></p>
<p><em>Иногда имеет значение, в каком порядке вы пробуете конъюнкты. Например, вы не можете взять свой торт и съесть его, но вы можете сфотографировать свой торт и тоже съесть его, если вы сделаете снимок <em>перед</em> его поеданием. В мире блоков у нас есть:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-04.jpg" alt="u04-04"/>
</div>
<p></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (use (make-block-ops &#39;(a b c))) 18</div><div class="line">&gt; (gps &#39;((a on b) (b on c) (c on table) (space on a) (space on table))</div><div class="line">      &#39;((b on a) (c on b)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE A FROM B TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM C TO A))</div><div class="line">  (EXECUTING (MOVE C FROM TABLE TO B)))</div><div class="line">&gt; (gps &#39;((a on b) (b on c) (c on table) (space on a) (space on table))</div><div class="line">      &#39;((c on b) (b on a)))</div><div class="line">NIL</div></div><!-- fragment --><p></em></p>
<p><em>В первом случае башня была построена путем установки сначала B на A, а затем C на B. Во втором случае программа сначала получает башню с C на B, но портит эту цель, получая башню с B на A. Видим ситуацию "предпосылки порчи родственной цели", но программа ничего с этим не делает. Единственное, что мы могли бы сделать, - это попытаться изменить порядок конъюнктивных целей. То есть мы могли бы изменить <code>achieve-all</code> следующим образом:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun achieve-all (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, trying several orderings.&quot;</div><div class="line">  (some #&#39;(lambda (goals) (achieve-each state goals goal-stack))</div><div class="line">      (orderings goals)))</div><div class="line"></div><div class="line">(defun achieve-each (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, and make sure they still hold at the end.&quot;</div><div class="line">  (let ((current-state state))</div><div class="line">    (if (and (every #&#39;(lambda (g)</div><div class="line">            (setf current-state</div><div class="line">              (achieve current-state g goal-stack)))</div><div class="line">          goals)</div><div class="line">        (subsetp goals current-state :test #&#39;equal))</div><div class="line">      current-state)))</div><div class="line"></div><div class="line">(defun orderings (l)</div><div class="line">  (if (&gt; (length l) 1)</div><div class="line">      (list l (reverse l))</div><div class="line">      (list l)))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы можем представить цель в любом виде, и мы все равно получим ответ. Заметьте, что мы рассматриваем только два порядка: данный порядок и обратный порядок. Очевидно, что для множества целей из одного или двух конъюнктов это все упорядочения. В общем, если есть только одно взаимодействие в множестве целей, то один из этих двух порядков будет работать. Таким образом, мы исходим из того, что взаимодействия "предпосылки разрушающие родственную цель" редки, и что редко будет больше одного взаимодействия на множестве целей. Другой возможностью было бы рассмотреть все возможные перестановки целей, но это может занять много времени при большом множестве целей.</em></p>
<p><em>Еще одним соображением является эффективность решений. Рассмотрим простую задачу получения блока С на столе на следующей диаграмме:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-05.jpg" alt="u04-05"/>
</div>
<p></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((c on a) (a on table) (b on table)</div><div class="line">      (space on c) (space on b) (space on table))</div><div class="line">    &#39;((c on table)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE C FROM A TO B))</div><div class="line">  (EXECUTING (MOVE C FROM B TO TABLE)))</div></div><!-- fragment --><p></em></p>
<p><em>Решение правильное, но есть более простое решение, которое перемещает C непосредственно на стол. Более простое решение не было найдено из-за неудачного случая: случается, что <code>make-block-ops</code> определяет операторы так, что перемещение C с B на стол происходит раньше, чем перемещение C с A на стол. Итак, первый оператор опробован, и он успешен при условии, что C находится на B. Таким образом, двухэтапное решение найдено до того, как будет рассмотрено одноэтапное решение. В следующем примере выполняется четыре шага, когда это можно было бы сделать за два:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-06.jpg" alt="u04-06"/>
</div>
<p></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((c on a) (a on table) (b on table)</div><div class="line">      (space on c) (space on b) (space on table))</div><div class="line">    &#39;((c on table) (a on b)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE C FROM A TO B))</div><div class="line">  (EXECUTING (MOVE C FROM B TO TABLE))</div><div class="line">  (EXECUTING (MOVE A FROM TABLE TO C))</div><div class="line">  (EXECUTING (MOVE A FROM C TO B)))</div></div><!-- fragment --><p></em></p>
<p><em>Как мы можем найти более короткие решения? Одним из способов было бы провести полноценный поиск: сначала пробуются более короткие решения, временно забрасываются, когда что-то другое выглядит более перспективным, а затем пересматриваются позже. Этот подход рассматривается в <a href="B9780080571157500066.xhtml">главе 6</a>, используя общую функцию поиска. Менее радикальное решение состоит в том, чтобы сделать ограниченную перестановку порядка, в котором ищутся операторы: сначала пробуются те, у которых меньше невыполненных предварительных условий. В частности, это означает, что операторы со всеми заполненными предварительными условиями всегда будут опробованы раньше других операторов. Чтобы реализовать этот подход, мы изменим <code>achieve</code>:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun achieve (state goal goal-stack)</div><div class="line">  &quot;A goal is achieved if it already holds,</div><div class="line">  or if there is an appropriate op for it that is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Goal:~a&quot; goal)</div><div class="line">  (cond ((member-equal goal state) state)</div><div class="line">      ((member-equal goal goal-stack) nil)</div><div class="line">      (t (some #&#39;(lambda (op) (apply-op state goal op goal-stack))</div><div class="line">          (appropriate-ops goal state))))) ;***</div><div class="line"></div><div class="line">(defun appropriate-ops (goal state)</div><div class="line">  &quot;Return a list of appropriate operators,</div><div class="line">  sorted by the number of unfulfilled preconditions.&quot;</div><div class="line">  (sort (copy-list (find-all goal *ops* :test #&#39;appropriate-p)) #&#39;&lt;</div><div class="line">      :key #&#39;(lambda (op)</div><div class="line">          (count-if #&#39;(lambda (precond)</div><div class="line">              (not (member-equal precond state)))</div><div class="line">            (op-preconds op)))))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы получаем решения, которые хотели:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-07.jpg" alt="u04-07"/>
</div>
<p></em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;((c on a) (a on table) (b on table)</div><div class="line">      (space on c) (space on b) (space on table))</div><div class="line">    &#39;((c on table) (a on b)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE C FROM A TO TABLE))</div><div class="line">  (EXECUTING (MOVE A FROM TABLE TO B)))</div></div><!-- fragment --><p></em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-08.jpg" alt="u04-08"/>
</div>
<p></em></p>
<p><em></p><div class="fragment"><div class="line">(gps &#39;((a on b) (b on c) (c on table) (space on a) (space on table))</div><div class="line">      &#39;((b on a) (c on b)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE A FROM B TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM C TO A))</div><div class="line">  (EXECUTING (MOVE C FROM TABLE TO B)))</div><div class="line">&gt; (gps &#39;((a on b) (b on c) (c on table) (space on a) (space on table))</div><div class="line">      &#39;((c on b) (b on a)))</div><div class="line">((START)</div><div class="line">  (EXECUTING (MOVE A FROM B TO TABLE))</div><div class="line">  (EXECUTING (MOVE B FROM C TO A))</div><div class="line">  (EXECUTING (MOVE C FROM TABLE TO B)))</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Аномалия Сассмана</h3>
<p></em></p>
<p><em></em></p>
<p><em>Удивительно, но есть проблемы, которые не могут быть решены путем <em>произвольного</em> переупорядочения целей. Рассмотрим:</em></p>
<p><em></p><div class="image">
<img src="images/chapter4/u04-09.jpg" alt="u04-09"/>
</div>
<p></em></p>
<p><em>Это выглядит не слишком сложно, так что давайте посмотрим, как наш GPS справляется с этим:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (setf start &#39;((c on a) (a on table) (b on table) (space on c)</div><div class="line">        (space on b) (space on table)))</div><div class="line">((C ON A) (A ON TABLE) (B ON TABLE) (SPACE ON C)</div><div class="line">  (SPACE ON B) (SPACE ON TABLE))</div></div><!-- fragment --><p></em></p>
<p><em>`&gt; (gps start '((a on b) (b on c)))<code>=&gt;</code>NIL`</em></p>
<p><em>`&gt; (gps start '((b on c) (a on b)))<code>=&gt;</code>NIL`</em></p>
<p><em>Существует проблема "предпосылки повреждающей родственную цель" независимо от того, каким образом мы упорядочиваем конъюнкты! Другими словами, никакая комбинация планов для двух индивидуальных целей не может решить проблему соединения этих двух целей. Это удивительный факт, и этот пример стал известен как "аномалия Сассмана".<a href="#fn0025">4</a> мы вернемся к этой проблеме в <a href="B9780080571157500066.xhtml">главе 6</a>.</em></p>
<p><em></p><h2>4.15 Этап 5 Повторяем: Анализ версии 2</h2>
<p></em></p>
<p><em></em></p>
<p><em>Мы показали, что GPS можно расширять на несколько доменовis extensible to multiple domains. Главное, что нам не нужно было менять саму программу, чтобы новые домены заработали; мы просто изменили список операторов, переданных в GPS. Опыт в различных доменах подсказал, какие изменения можно внести, и мы показали, как внести некоторые изменения. ХОтя версия 2 является большим улучшением по сравнению с версией 1, она по прежнему оставляет желать лучшего. Теперь мы можем обнаружить несколько наиболее тревожных проблем.</em></p>
<p><em></p><h2>4.16 отсутствие присмотра за вами не является проблемой прыжка</h2>
<p></em></p>
<p><em></em></p>
<p><em>Мы решили проблему "прыжка, прежде чем посмотреть, безопасен ли он", введя переменные для хранения представления возможных будущих состояний, а не только одну переменную, представляющую текущее состояние. Это не позволяет GPS предпринять опрометчивые действия, но мы увидим, что даже со всеми стратегиями восстановления, представленными в последнем разделе, это не гарантирует, что решение будет найдено всякий раз, когда оно возможно.</em></p>
<p><em>Чтобы увидеть проблему, добавьте еще один оператор в начало списка <code>*school-ops*</code> и снова включите вывод отладочной информации:</em></p>
<p><em></p><div class="fragment"><div class="line">(use (push (op &#39;taxi-son-to-school</div><div class="line">        :preconds &#39;(son-at-home have-money)</div><div class="line">        :add-list &#39;(son-at-school)</div><div class="line">        :del-list &#39;(son-at-home have-money))</div><div class="line">      *school-ops*))</div><div class="line">(debug :gps)</div></div><!-- fragment --><p></em></p>
<p><em>Теперь рассмотрим проблему получения ситуации: ребенок в школе без использования денег:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (gps &#39;(son-at-home have-money car-works)</div><div class="line">      &#39;(son-at-school have-money))</div><div class="line">Goal: SON-AT-SCHOOL</div><div class="line">Consider: TAXI-SON-TO-SCHOOL</div><div class="line">  Goal: SON-AT-HOME</div><div class="line">  Goal: HAVE-MONEY</div><div class="line">Action: TAXI-SON-TO-SCHOOL</div><div class="line">Goal: HAVE-MONEY</div><div class="line">Goal: HAVE-MONEY</div><div class="line">Goal: SON-AT-SCHOOL</div><div class="line">Consider: TAXI-SON-TO-SCHOOL</div><div class="line">  Goal: SON-AT-HOME</div><div class="line">  Goal: HAVE-MONEY</div><div class="line">Action: TAXI-SON-TO-SCHOOL</div><div class="line">NIL</div></div><!-- fragment --><p></em></p>
<p><em>Первые пять строк выходных данных успепшно решают проблему: сын в школе - <code>son-at-school</code> с помщью действия <code>TAXI-SON-TO-SCHOOL</code>. Следующая строка показывает безуспешную попытку достичь цели: иметь деньги - <code>have-money</code>. Следующий шаг - попробовать в другом порядке. На этот раз сначала делается попытка получить деньги, она оказывается успешной. Затем, цель <code>son-at-school</code> снова достигается благодаря действию <code>TAXI-SON-TO-SCHOOL</code>. Но проверка на согласованность в <code>achieve-each</code> не удается, и в этом месте исправление не доступно. Цель не достигется, хотя есть верное решине: отвезти ребенка в школу.</em></p>
<p><em>Проблема в том, что <code>achieve</code> использует <code>some</code> для просмотра(поиска) применимых операторов - <code>appropriate-ops</code>. Таким образом, если есть какой-то подходящий оператор, <code>achieve</code> завершится успешно. Если есть только одна цель, это даст правильное решение. Однако, если есть несколько подцелей, как в этом случае, achieve все равно найдет только один способ достич первой цели. Если первое решение плохое, единственный выход - попытаться его исправить. В таких областях(доменах), как мир блоков и мир лабиринтов, исправление часто работает, потому что все шаги обратимы. Но в примере с такси никакое исправление плана не может вернуть деньги после того, как они были потрачены, поэтому весь план терпит неудачу.</em></p>
<p><em>Есть два пути обойти эту проблему. Первый подход - изучить все возможные решения, а не только первое решение, которое позволяет достичь каждой подцели. Язык Prolog, который будет обсуждаться в <a href="B978008057115750011X.xhtml">chapter 11</a>, именно этим и занимается. Второй подход состоит в том, чтобы achieve и <code>achieve-all</code> отслеживали список целей, которые необходимо <em>защищать/protected</em>. В примере с такси мы бы тривиально достигли цели <code>have-money</code>, а затем попытались бы достичь цели <code>son-at-school</code>, защищая цель <code>have-money</code>. Оператор будет уместен только в том случае, если он не удаляет никаких защищенных целей. Этот подход по прежнему требует какого то исправления или поиска по нескольким путям решения. Если бы мы попробовали только один порядок - достигающий <code>son-at-school</code>, а затем попытались бы защитить его, достигая при этом <code>have-money</code>- то мы бы не нашли решения. Планировщик WARPLAN Дэвида Уоррена хорошо использует идею защищенных целей.</em></p>
<p><em></p><h2>4.17 проблема отсутствия описательной мощности</h2>
<p></em></p>
<p><em></em></p>
<p><em>В домене лабиринтов было бы намного экономичнее иметь один оператор, который говорил бы, что мы можем перемещаться отсюда/here туда/there, если мы находимся "здесь/here" и если существует связь "отсюда/here" к "туда/there". Затем входные данные для конкретной задачи могут содержать список допустимых соединений и мы могли бы решить любой лабиринт с помощью этого единственного оператора. Точно так же мы определили оператор, в котором обезьяна толкает стул от двери к середине комнаты, но было бы лучше иметь оператор, с помощью которого обезьяна могла бы толкать стул из любого места в любое другое близлежащее место, или еще лучше - оператор которые толкает любой "толкаемый" объект из одного места в соседнее, если нет никаких препятствий. Вывод таков: мы хотели бы иметь переменные в операторах, чтобы можно было сказать что-то вроде:</em></p>
<p><em></p><div class="fragment"><div class="line">(op </div><div class="line">  &#39;(push X from A to B)</div><div class="line">  :preconds &#39;((monkey at A) (X at A) (pushable X) (path A B))</div><div class="line">  :add-list &#39;((monkey at B) (X at B))</div><div class="line">  :del-list &#39;((monkey at A) (X at A)))</div></div><!-- fragment --><p></em></p>
<p><em>Часто мы хотим охарактеризовать состояния в терминах чего-то более абстрактного, чем список условий. Например, при решении шахматной задачи цель состоит в том, чтобы поставить опоненту мат, ситуацию которую нельзя экономно описать в терминах таких примитивов, как <code>(black king on A 4)</code>, поэтому мы должны иметь возможность сформулировать какой-то вид ограничений на состояние цели, а не просто перечисления её компонентов. Мы могли бы захотеть достичь дизъюнкции(ИЛИ) или отритцания условий, тогда как текущий формализм допускает только коньюнкцию(И).</em></p>
<p><em>Во многих областях(доменах) также важно уметь формулировать проблемы, связанные со временем: мы хотим достичь <em>X</em> до наступления времени <em>T0</em>, и затем достичь <em>Y</em> до наступления времени <em>T2</em>, но не раньше <em>T1</em>. Планирование работы в производственном цехе или строительство дома - примеры планирования, в котором время играет важную роль.</em></p>
<p><em>Часто действия связаны с расходами и мы хотим найти решение с минимальными или почти минимальными затратами. Стоимость может быть такой же простой, как количество операторов, необходимых для решения - мы видели в домене мира блоков, что иногда оператор, который можно было применить немедленно, игнорировался, и вместо него выбирался оператор, которому требовалолсь выполнение нескольких предварительных условий. Или нас могло бы удовлетворить частичное решение, если полное решение невозможно или слишком дорого. Мы также можем принимать во внимание стоимость (или время) вычислений.</em></p>
<p><em></p><h2>4.18 Идеальная Информационная Проблема</h2>
<p></em></p>
<p><em></em></p>
<p><em>Все опереторы, которые мы видели до сих пор, дают однозначные результаты; они добавляют или удаляют определенные вещи из текущего состояния и GPS всегда точно знает, что с ними делать. В реальном мире, вещи редко бывают такими простыми. Возвращаясь к проблеме обогащения, можно сказать, что в лотерею играет один соответствующий оператор. Этот оператор использует несколько долларов и время от времени выплачивает крупную сумму. Но у нас нет способа представить выигрыш "только от времени". Точно так же у нас нет возможности представлять неожиданные трудности любого рода. В задаче про детский сад мы могли бы представить проблему с автомобильным аккумулятором, если бы GPS явно проверял, работает автомобиль или ему нужен аккумулятор, каждый раз, когда программа обдумывает оператор перемещения/driving. В реальном мире мы редко бываем так осторожны; мы садимся в машину и только тогда когда она не заводится, мы рассматриваем возможность разрядки аккумулятора.</em></p>
<p><em></p><h2>4.19 Проблема Взаимодействующих Целей</h2>
<p></em></p>
<p><em></em></p>
<p><em>Люди как правило преследуют несколько целей, а не работают только над одной. Я не только хочу отвести ребенка в сад, но я хочу, чтобы меня не сбила машина, чтобы успеть вовремя на работу, встретиться с друзьями, повеселиться, продолжить дышать и т.д. Я также должен самостоятельно определять цели, а не работать над набором заранее определенных целей, переданных мне кем-то. Некоторые цели я могу годами держать в тени, а затем работать над ними, когда представиться возможность. Никогда не бывает идеи достижения всех возможных целей. Скорее, это непрерывный процесс достижения одних целей, частичного достижения других и откладывания или отказа от третьих.</em></p>
<p><em>Помимо активных целей, люди также оседомлены о нежелательных ситуациях, которых они пытаются избежать. Например, предположим, что у меня есть цель навести друга в больнице. Для этого мне нужно идти в больницу. Один применимый оператор может: идти в больницу, в то время как другой может: пораниться и ждать пока скорая помощь не отвезет меня туда. Второй оператор достигает цели так же хорошо(а возможно и быстрее), но имеет нежелательный побочный эффект. Это можно решить либо с помощью понятия стоимости(цены) решения, как указано в последнем разделе, либо с помощью списка фоновых целей, которые пытаются защитить каждое решение.</em></p>
<p><em>Herb Simon ввел термин "удовлетворительный", чтобы описать стратигию достижения разумного числа целей в разумной степени при отказе от других целей или откладывании их на потом. GPS знает только успехи или неудачи, и поэтому не может максимизировать частичный успех.</em></p>
<p><em></p><h2>4.20 Конец GPS</h2>
<p></em></p>
<p><em></em></p>
<p><em>Эти последние четыре раздела дают представление об ограничениях GPS. Фактически, это вообще не средство решения общих проблем. Он <em>является</em> общим в том смысле, что алгоритм не привязан к определенной области(домену); мы можем изменить домен, изменяя операторы. Но GPS не может быть универсальным, поскольку не может решить многие интересные проблемы. Он сводиться к маленьким фокусам и играм.</em></p>
<p><em>Есть важная, но тонкая причина, по которой GPS была обречена на провал, причина, которая не получила признания в 1957, но сейчас она лежит в основе компьютерных наук. Сейчас признано, что есть проблемы, которые компьютеры не могут решить - не потому, что теоретически правильная программа не может быть написана, а потому, что выполнение программы займет слишком много времени. Можно показать, что большое количество проблем попадает в класс "NP-сложных" проблем. Вычисление решения этих проблем требует времени, которое экспотенциально растет по мере увеличения размера проблемы. Это свойство самих проблем, и оно выполняется каким бы умным не был программист. Экспотенциальный рост означает, что проблемы, которые могут быть решены за секунды, например для случая с пятью входами, могут занять триллионы лет, когда есть 100 входов. Покупка более быстрого компьютера не сильно поможет. В конце концов, если на решение проблемы на вашем компьютере потребуется триллион лет, покупка 1000 компьютеров каждый в 1000 раз быстрее вашего, не поможет: вам все равно придется ждать миллион лет. Для теоретика в области информатики обнаружение NP-трудности проблемы является самоцелью. Но для работника AI, это означает, что задается не тот вопрос. Многие проблемы являются NP-трудными, когда мы настаиваем на оптимальном решении, которое может быть не лучшим.</em></p>
<p><em>Входные данные для GPS - это по сути программа, а выполнение GPS - это выполнение этой программы. Если язык ввода GPS является достаточно общим, чтобы выразить любую программу, тогда возникнут проблемы, которые невозможно решить, либо потому, что они выполняются слишком долго, либо потому, что у нех нет решения. Современные программы решения проблем признают это фундаментальное ограничение и либо ограничивают класс проблем, которые они пытаются решить, либо рассматривают способы поиска приблизительных или частичных решений. Некоторые специалисты по решению проблем также контролируют собственное время выполнения и знают достаточно, чтобы отказаться, когда проблема слишком сложна.</em></p>
<p><em>Следующая цитата из статьи Дрю МакДермотта "Искуственный интеллект встречается с естественной глупостю" резюмирует нынешние представления о GPS. Помните об том в следующий раз, когда вам нужно будет назвать программу.</em></p>
<p><em></p><blockquote class="doxtable">
<p><em>Помните GPS? </em></p>
</blockquote>
<p>К настоящему времени "GPS" - это бесцветный термин, означающий особо глупую программу для решения головоломок. Но изначально оно означало "Решатель Общих Проблем", что вызывало у всех ненужное волнение и смятение. Она должна была называться *lfgns</em> - "Локальный поисковик в сети указанных характеристик."</p>
<p><em>Тем не менее, GPS оказался полезным средством изучения программирования в целом и программирования AI в частности. Что еще более важно, это был полезный инструмент для исследования "природы размышлений". Конечно, мы признаем, что Аристотель был более умным человеком, чем вы или я, но с помощью вычислительной модели разума в качестве ведущей метафоры и дальнейшей помощи рабочей компьютерной программы, помогающей исследовать эту метафору, мы были ведомы к более тщательному пониманию анализа средств и целей - по крайней мере, в рамках вычислительной модели. Мы должны сопротивляться искушению поверить в то, что все мышление следует этой модели.</em></p>
<p><em>Привлекательность AI можно рассматривать как разделение между средствами и целями. Завершением успешного проекта AI может быть программа, которая выполняет некоторые полезные задачи лучше, быстрее или дешевле, чем это могло быть ранее. По этим меркам GPS в большинстве случаев является ошибкой, поскольку он не решает многие проблемы особенно хорошо. Но средства для достижения этой цели включали исследование и формализацию процесса решения проблем. Таким образом, наша реконструкция GPS является успешной в той мере, в какой она помогает читателю лучше понять суть проблемы.</em></p>
<p><em></p><h2>4.21 история и ссылки</h2>
<p></em></p>
<p><em></em></p>
<p><em>Оригинальный GPS задокументирован в статье Ньюэлла и Саймона 1963 года и в их книге 1972 года "решение человеческих проблем", а также В книге Эрнста и Ньюэлла 1969 года. Реализация в этой главе основана на программе Stripes (Fikes and Nilsson 1971).</em></p>
<p><em>Есть и другие важные программы планирования. Программа Эрла Сакердоти Abstrips представляла собой модификацию Strips, которая позволяла осуществлять иерархическое планирование. Идея состояла в том, чтобы набросать скелетный план, который решает всю программу на абстрактном уровне, а затем заполнить детали. Планировщик Warplan Дэвида Уоррена освещен в Warren 1974a, b и в разделе Coelho and Cotta 1988. Система Nonlin Остина Тейта (Tate 1977) достигла большей эффективности, рассматривая план как частично упорядоченную последовательность операций, а не как строго упорядоченную последовательность ситуаций. Tweak Дэвида Чэпмена синтезирует и формализует современное состояние планирования по состоянию на 1987 год.</em></p>
<p><em>Все эти документы-и довольно много других важных документов по планированию-перепечатаны в Allen, Hendler, and Tate 1990.</em></p>
<p><em></p><h2>4.22 Упражнения</h2>
<p></em></p>
<p><em></em></p>
<p><em><b>Exercise 4.1 [m]</b> Можно реализовать dbg с помощью одного вызова format. Можете ли вы определить директивы format, чтобы сделать это?</em></p>
<p><em><b>Exercise 4.2 [m]</b> Напишите функцию, которая генерирует все перестановки ее входных данных..</em></p>
<p><em><b>Exercise 4.3 [h]</b> GPS не распознает ситуацию, когда цель случайно достигается как часть достижения другой цели. Рассмотрим цель - поедание десерта. Предположим, что есть два доступных оператора: съесть мороженое (которая требует наличия мороженого) и съесть торт (который требует наличия торта). Предположим, что мы можем купить торт, и что пекарня проводит акцию, когда она выдает бесплатное мороженое каждому клиенту, который покупает и ест торт. (1) Составьте список операторов для представления этой ситуации. (2) Дайте gps цель съесть десерт. Покажите, что, имея правильный список операторов, <code>gps</code> решит съесть мороженое, затем решит купить и съесть торт, чтобы получить бесплатное мороженое, а затем пойти вперед и съесть мороженое, даже если цель съесть десерт уже достигнута, поеданием торта. (3) исправьте gps так, чтобы он не проявлял этой проблемы.</em></p>
<p><em>Следующие упражнения направлены на решение проблем в версии 2 программы.</em></p>
<p><em><b>Exercise 4.4 [h]</b> <em>То, что вы не смотрите за собой, не является проблемой прыжка</em>. Напишите программу, которая отслеживает оставшиеся цели, чтобы она не застряла, рассматривая только одну возможную операцию, когда другие в конечном итоге приведут к цели. Подсказка: пусть achieve примет дополнительный аргумент, указывающий на цели, которые остаются достижимыми после достижения текущей цели. <code>achieve</code> должно быть успешным только в том случае, если оно может достичь текущей цели, а также <code>achieve-all</code> остальных целей.</em></p>
<p><em><b>Exercise 4.5 [d]</b> Напишите программу планирования, которая, как и Warplan Уоррена, отслеживает список целей, которые еще предстоит достичь, а также список целей, которые были достигнуты и не должны быть отменены. Программа никогда не должна отменять цель, которая была достигнута, но она должна допускать возможность переупорядочения шагов, которые уже были предприняты. Таким образом, программа решит аномалию Сассмана и подобные проблемы.</em></p>
<p><em><b>Exercise 4.6 [d]</b> <em>Отсутствие описательной проблемы власти</em>. Прочитайте <a href="B9780080571157500054.xhtml">главы 5</a> и <a href="B9780080571157500066.xhtml">6</a>, чтобы узнать о сопоставлении шаблонов. Напишите версию GPS, которая использует инструменты сопоставления образцов и, таким образом, допускает переменные в операторах. Применяйте его к доменам лабиринт и миру блоков. Ваша программа будет более эффективной, если, подобно программе Чепмена Tweak, вы допускаете возможность переменных, которые остаются несвязанными как можно дольше.</em></p>
<p><em><b>Exercise 4.7 [d]</b> Поразмышляйте над дизайном планировщика, который может решить проблемы <em>идеальной информации</em> и <em>взаимодействующих целей</em>.</em></p>
<p><em></p><h2>4.23 Ответы</h2>
<p></em></p>
<p><em></em></p>
<p><em><b>Answer 4.1</b> В этой версии форматная строка <code>"~&amp;~V@T~?"</code> разбивается следующим образом: <code>"~&amp;"</code> означает перейти к новой строке;<code>"~V@T"</code> означает вставить <code>(@T)</code> пробелы, но используйте следующий аргумент <code>(V)</code>, чтобы получить количество пробелов. Это <code>"~?"</code> - это оператор косвенности: используйте следующий аргумент в качестве строки формата, а следующий за ним аргумент - в качестве списка аргументов для строки формата.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun dbg-indent (id indent format-string &amp;rest args)</div><div class="line">  &quot;Print indented debugging info if (DEBUG ID) has been specified.&quot;</div><div class="line">  (when (member id *dbg-ids*)</div><div class="line">    (format *debug-io* &quot;~&amp;~V@T~?&quot; (* 2 indent) format-string args)))</div></div><!-- fragment --><p></em></p>
<p><em><b>Answer 4.2</b> Вот одно из решений. Искушенный программист Lisp также должен видеть это упражнение на <a href="B9780080571157500194.xhtml#p680">page 680</a>.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun permutations (bag)</div><div class="line">  &quot;Return a list of all the permutations of the input.&quot;</div><div class="line">  ;; If the input is nil, there is only one permutation:</div><div class="line">  ;; nil itself</div><div class="line">  (if (null bag)</div><div class="line">      &#39;(())</div><div class="line">      ;; Otherwise, take an element, e, out of the bag</div><div class="line">      ;; Generate all permutations of the remaining elements,</div><div class="line">      ;; And add e to the front of each of these.</div><div class="line">      ;; Do this for all possible e to generate all permutations,</div><div class="line">      (mapcan #&#39;(lambda (e)</div><div class="line">          (mapcar #&#39;(lambda (p) (cons e p))</div><div class="line">            (permutations</div><div class="line">              (remove e bag :count 1 :test #&#39;eq))))</div><div class="line">        bag)))</div></div><!-- fragment --> <hr/>
<p></em></p>
<p><em><a href="#xfn0010">1</a>Strips is the Stanford Research Institute Problem Solver, designed by <a href="B9780080571157500285.xhtml#bb0405">Richard Fikes and Nils Nilsson (1971)</a>.</em></p>
<p><em><a href="#xfn0015">2</a> Gerald Sussman, in his book <em>A Computer Model of Skill Acquisition,</em> uses the term "prerequisite clobbers brother goal" or PCBG. I prefer to be gender neutral, even at the risk of being labeled a historical revisionist.</em></p>
<p><em><a href="#xfn0020">3</a> Originally posed by <a href="B9780080571157500285.xhtml#bb0045">Saul Amarel (1968)</a>.</em></p>
<p><em><a href="#xfn0025">4</a> A footnote in Waldinger 1977 says, "This problem was proposed by Allen Brown.
Perhaps many children thought of it earlier but did not recognize that it was hard." The problem is named after Gerald Sussman because he popularized it in Sussman 1973. </em></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
