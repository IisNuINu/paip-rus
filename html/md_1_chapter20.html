<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 20</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 20 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Унифицированные(Объединенные) Грамматики</h2>
<p>Пролог был изобретен, потому что Ален Колмерауэр хотел формализм для описания грамматики французского языка. Его интуиция заключалась в том, что комбинация предложений Хорна и унификации привела к созданию языка, который был достаточно мощным, чтобы выразить виды ограничений, которые проявляются в естественных языках, но не столь мощным, как, например, полное исчисление предикатов. Этот недостаток мощности важен, потому что он обеспечивает эффективную реализацию Prolog и, следовательно, программ анализа языка, построенных на нем.</p>
<p>Конечно, Prolog эволюционировал и теперь используется во многих приложениях, помимо естественного языка, но основная интуиция Колмерауэра остается хорошей. В этой главе показано, как рассматривать грамматику как набор предложений логического программирования. Предложения(clauses) определяют, что является законным утверждением(заключением), а что нет, без какой-либо явной ссылки на процесс синтаксического анализа или генерации. Удивительно то, что предложения могут быть определены таким образом, чтобы получить очень эффективный синтаксический анализатор. Более того, одна и та же грамматика может использоваться как для синтаксического анализа, так и для генерации (по крайней мере, в некоторых случаях).</p>
<h2>20.1 Синтаксический анализ(parsing) как умозаключение(дедукция).</h2>
<p>Вот как мы могли бы выразить грамматическое правило "Утверждение(sentence) может состоять из фразы существительного(noun phrase), за которой следует глагольная фраза(verb phrase)" на Прологе:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s)</div></div><!-- fragment --> <pre class="fragment">  `(NP ?np)`

  `(VP ?vp)`

  `(concat ?np ?vp ?s))`
</pre><p>Переменные представляют собой строки слов. Как обычно, они будут реализованы в виде списков символов. Правило гласит, что данная строка слов <code>?s</code> является утверждением(sentence), если есть строка, которая представляет собой фразу существительного и другая явлюящаяся глагольной фразой, и если они могут быть объединены в форму <code>?s</code>. С логической точки зрения это нормально, и он будет работать как программа для генерации случайных утверждений. Однако это очень неэффективная программа для разбора утверждений. Она рассмотрит все возможные фразы существительных и глагольные фразы, независимо от введенных слов. Только когда она достигнет цели concat (определенной на <a href="B9780080571157500121.xhtml#p411">стр. 411</a>), она проверит, можно ли объединить две составляющие вместе, чтобы составить входную строку. Таким образом, лучший порядок вычисления для синтаксического анализа:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s)</div></div><!-- fragment --> <pre class="fragment">  `(concat ?np ?vp ?s)`

  `(NP ?np)`

  `(VP ?vp))`
</pre><p>В первой версии были угадываемые строки <code>NP</code> и <code>VP</code>, которые проверялись с помощью <code>concat</code>. В большинстве грамматик будет очень большое или бесконечное количество <code>NP</code> и <code>VP</code>. В этой второй версии есть угадываемые строки <code>concat</code>, которые должны проверяться <code>NP</code> и <code>VP</code>. Если в утверждении <em>n</em> слов, то <code>concat</code> может сделать только <em>n</em> + 1 предположений, что является значительным улучшением. Однако было бы еще лучше, если бы мы могли фактически заставить <code>concat</code> и <code>NP</code> работать вместе, чтобы сделать более ограниченное предположение, которое затем будет проверено <code>VP</code>.</p>
<p>Мы уже сталкивались с подобными проблемами. В Лиспе ответ - возвращает несколько значений. <code>NP</code> - это функция, которая принимает строку в качестве входных данных и возвращает два значения: индикатор успеха или неудачи и оставшуюся строку слов, которые еще не были проанализированы. Когда первое значение указывает на успех, тогда будет вызываться <code>VP</code> с оставшейся строкой в качестве ввода. В Прологе возвращаемые значения - это просто дополнительные аргументы. Таким образом, у каждого предиката будет два параметра: входная строка и остаточная строка. Следуя обычному соглашению Пролога, выходной параметр идет после входного. В этом подходе не требуются вызовы concat, не делаются дикие предположения, а функция обратного отслеживания Prolog заботится о необходимых предположениях:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?s0 ?sl)`

          `(VP ?sl ?s2))`
</pre><p>Это правило можно прочитать как "Строка от `*s*0` до `*s*2` является предложением, если существует `*s*1`, такое, что строка от `s0` до `*s*1`- это существительное, а строка от `*s*1` до `*s*2` - глагольная фраза."</p>
<p>Примером запроса будет <code>(?- (S (The boy ate the apple) ())).</code> С подходящими определениями <code>NP</code> и <code>VP</code> это будет успешным, со следующими привязками, удерживаемыми внутри <code>S</code>:</p>
<div class="fragment"><div class="line">?s0 = (The boy ate the apple)</div><div class="line">?sl =                 (ate the apple)</div><div class="line">?s2 =                                           ()</div></div><!-- fragment --><p>Другой способ чтения цели <code>(NP ?s0 ?sl)</code>, например, выглядит следующим образом: "`IS` the list `?s0` minus the list `?sl` a noun phrase?" В этом случае <code>?s0</code> минус <code>?sl</code> - это список <code>(The boy)</code>. Комбинация двух аргументов, списка ввода и списка вывода, часто называется <em>списком различий</em>, чтобы подчеркнуть эту интерпретацию. В более общем смысле комбинация входного параметра и выходного параметра называется <em>accumulator</em>(накопитель). Аккумуляторы, особенно списки различий, являются важным методом на протяжении всего логического программирования, а также используются в функциональном программировании, как мы видели на <a href="B9780080571157500030.xhtml#p63">стр. 63</a>.</p>
<p>В нашем правиле для <code>S</code> конкатенация списков различий была неявной. При желании мы могли бы определить версию concat для списков различий и вызвать ее явно:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s-in ?s-rem)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?np-in ?np-rem)`

          `(VP ?vp-in ?vp-rem)`

          `(concat ?np-in ?np-rem ?vp-in ?vp-rem ?s-in ?s-rem))`
</pre><div class="fragment"><div class="line">(&lt;- (concat ?a ?b ?b ?c ?a ?c))</div></div><!-- fragment --><p>Поскольку эта версия concat имеет другую арность, чем старая версия, они могут безопасно сосуществовать. В нем указано уравнение списка различий *(a - b) + (b - c) = (a - c)*.</p>
<p>В предыдущей главе мы заявили, что контекстно-свободная грамматика с фразовой структурой неудобна для выражения таких вещей, как согласие между подлежащим и сказуемым в утверждении. С помощью формализма грамматики, основанного на предложениях Хорна, которую мы здесь развиваем, мы можем добавить аргумент к предикатам NP и VP, чтобы представить согласие. На английском правило соглашения не имеет большого значения. Для всех глаголов, кроме <em>be,</em>, разница проявляется только в третьем лице единственного числа настоящего времени:</p>
<table class="doxtable">
<tr>
<th></th><th>Singular </th><th></th><th>Plural </th><th></th></tr>
<tr>
<td>first person </td><td>I </td><td>sleep </td><td>we </td><td>sleep </td></tr>
<tr>
<td>second person </td><td>you </td><td>sleep </td><td>you </td><td>sleep </td></tr>
<tr>
<td>third person </td><td>he/she </td><td>sleeps </td><td>they </td><td>sleep </td></tr>
</table>
<p>Таким образом, аргумент согласия будет принимать одно из двух значений <code>3sg</code> или <code>"3sg</code> для обозначения единственного числа от третьего лица или не от третьего лица единственного числа. Мы могли бы написать:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?agr ?s0 ?sl)`

          `(VP ?agr ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (NP 3sg (he . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (NP</code>"<code>3sg (they . ?s) ?s))</code></p>
<div class="fragment"><div class="line">(&lt;- (VP 3sg (sleeps . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (VP</code>"<code>3sg (sleep . ?s) ?s))</code></p>
<p>Эта грамматика разбирает только правильные предложения:</p>
<div class="fragment"><div class="line">&gt; (?- (S (He sleeps) ()))</div><div class="line">Yes.</div><div class="line">&gt; (?- (S (He sleep) ()))</div><div class="line">No.</div></div><!-- fragment --><p>Давайте расширим грамматику, чтобы разрешить как общие существительные(common nouns), так и местоимения(pronouns):</p>
<div class="fragment"><div class="line">(&lt;- (NP ?agr ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(Det ?agr ?s0 ?sl)`

          `(N ?agr ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (Det ?any (the . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (boy . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (girl . ?s) ?s))</div></div><!-- fragment --><p>Те же правила грамматики можно использовать как для создания предложений, так и для синтаксического анализа. Вот все возможные предложения в этой тривиальной грамматике:</p>
<div class="fragment"><div class="line">&gt; (?- (S ?words ()))</div><div class="line">?WORDS = (HE SLEEPS);</div><div class="line">?WORDS = (THEY SLEEP);</div><div class="line">?WORDS = (THE BOY SLEEPS);</div><div class="line">?WORDS = (THE GIRL SLEEPS);</div><div class="line">No.</div></div><!-- fragment --><p>Пока все, что у нас есть, - это распознаватель: предикат, который может отделять sentences(утверждения) от неутверждений. Но мы можем добавить к каждому предикату еще один аргумент, чтобы создать семантику. В результате получается не просто распознаватель, а настоящий парсер:</p>
<div class="fragment"><div class="line">(&lt;- (S (?pred ?subj) ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?agr ?subj ?s0 ?sl)`

            `(VP ?agr ?pred ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (NP 3sg (the male) (he . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (NP</code>"<code>3sg (some objects) (they . ?s) ?s))</code></p>
<div class="fragment"><div class="line">(&lt;- (NP ?agr (?det ?n) ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">            `(Det ?agr ?det ?s0 ?sl)`

            `(N ?agr ?n ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (VP 3sg sleep (sleeps . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (VP</code>"<code>3sg sleep (sleep . ?s) ?s))</code></p>
<div class="fragment"><div class="line">(&lt;- (Det ?any the (the . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (young male human) (boy . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (young female human) (girl . ?s) ?s))</div></div><!-- fragment --><p>Семантические переводы(преобразования) отдельных слов немного капризны. На самом деле, здесь не слишком важно, переводится ли <code>boy</code>(мальчик) как <code>(young male human)</code>(молодой человек-мужчина) или просто <code>boy</code>(мальчик). Есть два важных свойства семантического представления. Во-первых, оно должно быть однозначным. Представление <em>оранжевого</em> плода должно отличаться от <em>оранжевого</em> цвета (хотя представление плода вполне может ссылаться(устанавливать отношение) на цвет или наоборот). Во-вторых, оно должно выражать общие положения или позволять выразить их в другом месте. Таким образом, либо <em>sleep</em> и <em>sleeps</em> должны иметь одинаковое или похожее представление, либо должно существовать правило вывода, связывающее их. Точно так же, если представление <em>boy</em>(мальчика) не говорит об этом явно, но должно быть какое-то другое правило, согласно которому мальчик - это мужчина и человек.</p>
<p>Как только семантика отдельных слов определена, семантика категорий более высокого уровня (утверждений и фраз существительных) упрощается. В этой грамматике семантика утверждения - это применение сказуемого (глагольной фразы) к подлежащему (фразе существительного). Семантика составной фразы существительного - это применение определителя(determiner) к существительному.</p>
<p>Эта грамматика возвращает семантическую интерпретацию, но не строит синтаксическое дерево. Синтаксическая структура подразумевается в последовательности целей: <code>S</code> вызывает <code>NP</code> и <code>VP</code>, а <code>NP</code> может вызывать <code>Det</code> и <code>N</code>. Если мы хотим сделать это явным, мы можем предоставить еще один аргумент для каждого нетерминала:</p>
<div class="fragment"><div class="line">(&lt;- (S (?pred ?subj) (s ?np ?vp) ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?agr ?subj ?np ?s0 ?sl)`

            `(VP ?agr ?pred ?vp ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (NP 3sg (the male) (np he) (he . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (NP</code>"<code>3sg (some objects) (np they) (they . ?s) ?s))</code></p>
<div class="fragment"><div class="line">(&lt;- (NP ?agr (?det ?n) (np ?det-syn ?n-syn)?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">            `(Det ?agr ?det ?det-syn ?s0 ?sl)`

            `(N ?agr ?n ?n-syn ?sl ?s2))`
</pre><div class="fragment"><div class="line">(&lt;- (VP 3sg sleep (vp sleeps)(sleeps . ?s) ?s))</div></div><!-- fragment --><p><code>(&lt;- (VP</code>"<code>3sg sleep (vp sleep) (sleep . ?s) ?s))</code></p>
<div class="fragment"><div class="line">(&lt;- (Det ?any the (det the) (the . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (young male human) (n boy) (boy . ?s) ?s))</div><div class="line">(&lt;- (N 3sg (young female human) (n girl) (girl . ?s) ?s))</div></div><!-- fragment --><p>Эту грамматику все еще можно использовать для синтаксического анализа или генерации предложений или даже для перечисления всех триплетов синтаксиса / семантики / утверждений:</p>
<div class="fragment"><div class="line">;; Parsing:</div><div class="line">&gt; (?- (S ?sem ?syn (He sleeps) ()))</div><div class="line">?SEM = (SLEEP (THE MALE))</div><div class="line">?SYN = (S (NP HE) (VP SLEEPS)).</div><div class="line">;; Generating:</div><div class="line">&gt; (?- (S (sleep (the male)) ? ?words ()))</div><div class="line">?WORDS = (HE SLEEPS)</div><div class="line">;; Enumerating:</div><div class="line">&gt; (?- (S ?sem ?syn ?words ()))</div><div class="line">?SEM = (SLEEP (THE MALE))</div><div class="line">?SYN = (S (NP HE) (VP SLEEPS))</div><div class="line">?WORDS = (HE SLEEPS);</div><div class="line">?SEM = (SLEEP (SOME OBJECTS))</div><div class="line">?SYN = (S (NP THEY) (VP SLEEP))</div><div class="line">?WORDS = (THEY SLEEP);</div><div class="line">?SEM = (SLEEP (THE (YOUNG MALE HUMAN)))</div><div class="line">?SYN = (S (NP (DET THE) (N BOY)) (VP SLEEPS))</div><div class="line">?WORDS = (THE BOY SLEEPS);</div><div class="line">?SEM = (SLEEP (THE (YOUNG FEMALE HUMAN)))</div><div class="line">?SYN = (S (NP (DET THE) (N GIRL)) (VP SLEEPS))</div><div class="line">?WORDS = (THE GIRL SLEEPS);</div><div class="line">No.</div></div><!-- fragment --><h2>20.2 Грамматика с определенными предложениями</h2>
<p>Теперь у нас есть мощный и эффективный инструмент для разбора утверждений. Однако он становится очень запутанным инструментом - для каждой цели слишком много аргументов, и трудно сказать, какие аргументы представляют синтаксис, какие представляют семантику, какие представляют строки ввода/вывода и какие представляют другие функции, например согласование(agreement). Итак, мы сделаем обычный шаг, когда наш голый язык программирования становиться беспорядочным: определяем новый язык.</p>
<p>Edinburgh Prolog распознает утверждения(assertions), называемые правилами <em>грамматики с определенными предложениями</em> (DCG). Термин <em>определенное предложение</em> - это просто еще одно название предложений Пролога, поэтому DCG также называют "логическими грамматиками". Их также можно было назвать "грамматиками предложений Хорна" или "грамматиками Пролога".</p>
<p>Правила DCG - это предложения, основным функтором которых является стрелка, обычно записываемая &ndash;&gt;. Они компилируются в обычные предложения Пролога с дополнительными аргументами. В обычных правилах DCG автоматически добавляются только строковые аргументы. Но позже мы увидим, как это можно расширить для автоматического добавления других аргументов.</p>
<p>Мы реализуем правила DCG с помощью макроса <code>rule</code> и инфиксной стрелки. Таким образом, нам нужно выражение:</p>
<div class="fragment"><div class="line">(rule (S) --&gt; (NP) (VP))</div></div><!-- fragment --><p>развернуть в предложение:</p>
<div class="fragment"><div class="line">(&lt;- (S ?s0 ?s2)</div></div><!-- fragment --> <pre class="fragment">          `(NP ?s0 ?sl)`

          `(VP ?sl ?s2))`
</pre><p>Пока мы находимся в этом, мы также можем дать <code>rule</code> возможность работать с разными типами правил, каждое из которых представлено стрелкой разного типа. Вот макрос <code>rule</code>:</p>
<div class="fragment"><div class="line">(defmacro rule (head &amp;optional (arrow &#39;:-) &amp;body body)</div><div class="line">  &quot;Expand one of several types of logic rules into pure Prolog.&quot;</div><div class="line">  ;; This is data-driven, dispatching on the arrow</div><div class="line">  (funcall (get arrow &#39;rule-function) head body))</div></div><!-- fragment --><p>В качестве примера функции правила стрелка: - будет использоваться для представления обычных предложений Пролога. То есть форма (<code>rule</code>*head : - body*) будет эквивалентна (&lt;- <em>head body).</em></p>
<div class="fragment"><div class="line">(setf (get &#39;:- &#39;rule-function)</div><div class="line">      #&#39;(lambda (head body) `(&lt;- ,head .,body)))</div></div><!-- fragment --><p>Прежде чем писать функцию правила для правил DCG, необходимо рассмотреть еще две особенности формализма DCG. Во-первых, некоторые цели в теле правила могут быть обычными целями Пролога и, следовательно, не требуют дополнительной пары аргументов. В Edinburgh Prolog(Эдинбургском Прологе) такие цели заключены в фигурные скобки. Можно было бы написать:</p>
<div class="fragment"><div class="line">s(Sem) --&gt; np(Subj), vp(Pred),</div></div><!-- fragment --> <pre class="fragment">                                `{combi ne(Subj,Pred,Sem)}.`
</pre><p>где идея состоит в том, что <code>combine</code> не является грамматической составляющей, а скорее предикатом Пролога, который может производить некоторые вычисления с <code>Subj</code> и <code>Pred</code>, чтобы прийти к правильной семантике <code>Sem</code>. Мы будем отмечать такой тестовый предикат не скобками, а списком, возглавляемым ключевым словом <code>:test</code>, например:</p>
<div class="fragment"><div class="line">(rule (S ?sem) --&gt; (NP ?subj) (VP ?pred)</div></div><!-- fragment --> <pre class="fragment">  `(:test (combine ?subj ?pred ?sem)))`
</pre><p>Во-вторых, нам нужен способ введения отдельных слов в правой части, в отличие от категорий слов. В Прологе скобки используются для представления слова или списка слов с правой стороны:</p>
<div class="fragment"><div class="line">verb --&gt; [sleeps].</div></div><!-- fragment --><p>Мы будем использовать список с ключевым словом <code>:word:</code></p>
<div class="fragment"><div class="line">(rule (NP (the male) 3sg) --&gt; (:word he))</div><div class="line">(rule (VP sleeps 3sg) --&gt; (:word sleeps))</div></div><!-- fragment --><p>Следующие предикаты проверяют эти два особых случая. Обратите внимание, что cut(обрезка) также допускается как обычная цель.</p>
<div class="fragment"><div class="line">(defun dcg-normal-goal-p (x) (or (starts-with x :test) (eq x &#39;!)))</div><div class="line"></div><div class="line">(defun dcg-word-list-p (x) (starts-with x &#39;:word))</div></div><!-- fragment --><p>Наконец-то мы можем представить функцию правила для правил DCG. Функция <code>make-dcg</code> вставляет переменные для отслеживания строк, которые анализируются.</p>
<div class="fragment"><div class="line">(setf (get &#39;--&gt; &#39;rule-function) &#39;make-dcg)</div><div class="line"></div><div class="line">(defun make-dcg (head body)</div><div class="line">  (let ((n (count-if (complement #&#39;dcg-normal-goal-p) body)))</div><div class="line">    `(&lt;- (,@head ?s0 ,(symbol &#39;?s n))</div><div class="line">         .,(make-dcg-body body 0))))</div><div class="line"></div><div class="line">(defun make-dcg-body (body n)</div><div class="line">  &quot;Make the body of a Definite Clause Grammar (DCG) clause.</div><div class="line">  Add ?string-in and -out variables to each constituent.</div><div class="line">  Goals like (:test goal) are ordinary Prolog goals,</div><div class="line">  and goals like (:word hello) are literal words to be parsed.&quot;</div><div class="line">  (if (null body)</div><div class="line">      nil</div><div class="line">      (let ((goal (first body)))</div><div class="line">        (cond</div><div class="line">          ((eq goal &#39;!) (cons &#39;! (make-dcg-body (rest body) n)))</div><div class="line">          ((dcg-normal-goal-p goal)</div><div class="line">           (append (rest goal)</div><div class="line">                   (make-dcg-body (rest body) n)))</div><div class="line">          ((dcg-word-list-p goal)</div><div class="line">           (cons</div><div class="line">             `(= ,(symbol &#39;?s n)</div><div class="line">                 (,@(rest goal) .,(symbol &#39;?s (+ n 1))))</div><div class="line">             (make-dcg-body (rest body) (+ n 1))))</div><div class="line">          (t (cons</div><div class="line">               (append goal</div><div class="line">                       (list (symbol &#39;?s n)</div><div class="line">                             (symbol &#39;?s (+ n 1))))</div><div class="line">               (make-dcg-body (rest body) (+ n 1))))))))</div></div><!-- fragment --><p><b>Упражнение 20.1 [m]</b> <code>make-dcg</code> нарушает одно из основных правил макросов. Что он делает не так? Как бы вы это исправить?</p>
<h2>20.3 Простая грамматика в формате DCG</h2>
<p>Вот тривиальная грамматика из <a href="chapter20.xhtml#p688">страница 688</a> в формате DCG.</p>
<div class="fragment"><div class="line">(rule (S (?pred ?subj)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?subj)`

  `(VP ?agr ?pred))`
</pre><div class="fragment"><div class="line">(rule (NP ?agr (?det ?n)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Det ?agr ?det)`

  `(N ?agr ?n))`
</pre><div class="fragment"><div class="line">(rule (NP 3sg (the male))                   --&gt; (:word he))</div></div><!-- fragment --><p><code>(rule (NP</code>"<code>3sg (some objects)) --&gt; (:word they))</code></p>
<div class="fragment"><div class="line">(rule (VP 3sg sleep)                             --&gt; (:word sleeps))</div></div><!-- fragment --><p><code>(rule (VP</code>"<code>3sg sleep) --&gt; (:word sleep))</code></p>
<div class="fragment"><div class="line">(rule (Det ?any the)                             --&gt; (:word the))</div><div class="line">(rule (N 3sg (young male human))     --&gt; (:word boy))</div><div class="line">(rule (N 3sg (young female human)) --&gt; (:word girl))</div></div><!-- fragment --><p>Эта грамматика довольно ограничена, генерирует всего четыре предложения. Первый способ её расширения - разрешить глаголы с объектами: в дополнение к "The boy sleeps"(Мальчик спит) мы разрешим "The boy meets the girl"(Мальчик встречает девушку). Чтобы избежать создания некрасивых предложений, таких как "* The boy meets"(Мальчик встречает)<a href="#fn0015">1</a>, мы разделим категорию глаголов на две <em>подкатегории</em>: переходные глаголы, которые принимают объект, и непереходные глаголы, которые его не имеют.</p>
<p>Переходные глаголы усложняют смысловую трактовку утверждений. Мы хотели бы, чтобы интерпретация "Terry kisses Jean"(Терри целует Джин) была <code>(kiss Terry Jean)</code>. Интерпретация фразы существительного "Terry"(Терри) - это просто <code>Terry</code>, но тогда какой должна быть интерпретация глагольной фразы "kisses Jean"(целует Джин)? Чтобы соответствовать нашей модели применения предиката, она должна быть чем-то эквивалентной <code>(lambda (x) (kiss x Jean))</code>. Применительно к субъекту мы хотим получить упрощение:</p>
<p><code>((lambda (x) (kiss x Jean)) Terry)</code>=&gt; <code>(kiss Terry Jean)</code></p>
<p>Такое упрощение не выполняется Prolog(ом) автоматически, но мы можем написать для этого предикат. Мы назовем его <code>funcall</code>, потому что он похож на функцию Lisp с таким именем, хотя он обрабатывает только замену аргумента, а не полное вычисление тела. (Технически это операция лямбда-исчисления, известная как <em>бета-редукция.)</em> Предикат <code>funcall</code> обычно используется с двумя входными аргументами, функцией и ее аргументом и одним выходным аргументом, в результате чего происходит упрощение(сокращение):</p>
<div class="fragment"><div class="line">(&lt;- (funcall (lambda (?x) ?body) ?x ?body))</div></div><!-- fragment --><p>С этим мы могли бы написать наше правило для утверждений как:</p>
<div class="fragment"><div class="line">(rule (S ?sem) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?subj)`

  `(VP ?agr ?pred)`

  `(:test (funcall ?pred ?subj ?sem)))`
</pre><p>Фактически, альтернативой является компиляция вызова функции <code>funcall</code>. Вместо того чтобы семантическое представление <code>VP</code> было одним лямбда-выражением, мы можем представить его как два аргумента: входной аргумент, <code>?subj</code>, который действует как параметр для выходного аргумента,<code>?pred</code>, который принимает место тела лямбда-выражения. Явно манипулируя параметром и телом, мы можем исключить вызов <code>funcall</code>. Хитрость заключается в том, чтобы сделать параметр и субъект одним и тем же:</p>
<div class="fragment"><div class="line">(rule (S ?pred) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?subj)`

  `(VP ?agr ?subj ?pred))`
</pre><p>Один из способов прочтения этого правила: "Чтобы разобрать предложение, разобрать фразу существительного, за которой следует глагольная фраза.
Если у них есть разные признаки согласования, то они не работают, но в противном случае вставьте интерпретацию фразы существительного `?subj` в правильное место в интерпретации глагольной фразы `?pred` и верните `?pred` в качестве финального толкования утверждения".</p>
<p>Следующим шагом будет написание правил для глагольных фраз и глаголов. Переходные глаголы перечислены под предикатом <code>Verb/tr</code>, а непереходные глаголы перечислены как <code>Verb/intr</code>. Семантика времен (прошедшего(past) и настоящего(present)) игнорируется.</p>
<div class="fragment"><div class="line">(rule (VP ?agr ?subj ?pred) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/tr ?agr ?subj ?pred ?obj)`

  `(NP ?any-agr ?obj))`
</pre><div class="fragment"><div class="line">(rule (VP ?agr ?subj ?pred) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/intr ?agr ?subj ?pred))`
</pre><p><code>(rule (Verb/tr</code>"<code>3sg ?x (kiss ?x ?y) ?y) --&gt; (:word kiss))</code></p>
<div class="fragment"><div class="line">(rule (Verb/tr 3sg ?x (kiss ?x ?y) ?y) --&gt; (:word kisses))</div><div class="line">(rule (Verb/tr ?any ?x (kiss ?x ?y) ?y) --&gt; (:word kissed))</div></div><!-- fragment --><p><code>(rule (Verb/intr</code>"<code>3sg ?x (sleep ?x)) --&gt; (:word sleep))</code></p>
<div class="fragment"><div class="line">(rule (Verb/intr 3sg ?x (sleep ?x)) --&gt; (:word sleeps))</div><div class="line">(rule (Verb/intr ?any ?x (sleep ?x)) --&gt; (:word slept))</div></div><!-- fragment --><p>Вот правила для фраз существительных(noun phrases) и существительных(nouns):</p>
<div class="fragment"><div class="line">(rule (NP ?agr ?sem) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Name ?agr ?sem))`
</pre><div class="fragment"><div class="line">(rule (NP ?agr (?det-sem ?noun-sem)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Det ?agr ?det-sem)`

  `(Noun ?agr ?noun-sem))`
</pre><div class="fragment"><div class="line">(rule (Name 3sg Terry) --&gt; (:word Terry))</div><div class="line">(rule (Name 3sg Jean) --&gt; (:word Jean))</div><div class="line">(rule (Noun 3sg (young male human)) --&gt; (:word boy))</div><div class="line">(rule (Noun 3sg (young female human)) --&gt; (:word girl))</div></div><!-- fragment --><p><code>(rule (Noun</code>"<code>3sg (group (young male human))) --&gt; (:word boys))</code></p>
<p><code>(rule (Noun</code>"<code>3sg (group (young female human))) --&gt; (:word girls))</code></p>
<div class="fragment"><div class="line">(rule (Det ?any the) --&gt; (:word the))</div><div class="line">(rule (Det 3sg a) --&gt; (:word a))</div></div><!-- fragment --><p>Эта грамматика и лексика генерируют больше утверждений, хотя они все еще довольно ограничены. Вот некоторые примеры:</p>
<div class="fragment"><div class="line">&gt; (?- (S ?sem (The boys kiss a girl) ()))</div><div class="line">?SEM = (KISS (THE (GROUP (YOUNG MALE HUMAN)))</div></div><!-- fragment --> <pre class="fragment">                                          `(A (YOUNG FEMALE HUMAN))).`
</pre><div class="fragment"><div class="line">&gt; (?- (S ?sem (The girls kissed the girls) ()))</div><div class="line">?SEM = (KISS (THE (GROUP (YOUNG FEMALE HUMAN)))</div></div><!-- fragment --> <pre class="fragment">                                          `(THE (GROUP (YOUNG FEMALE HUMAN)))).`
</pre><div class="fragment"><div class="line">&gt; (?- (S ?sem (Terry kissed the girl) ()))</div><div class="line">?SEM = (KISS TERRY (THE (YOUNG FEMALE HUMAN))).</div><div class="line">&gt; (?- (S ?sem (The girls kisses the boys) ()))</div><div class="line">No.</div><div class="line">&gt; (?- (S ?sem (Terry kissed a girls) ()))</div><div class="line">No.</div><div class="line">&gt; (?- (S ?sem (Terry sleeps Jean) ()))</div><div class="line">No.</div></div><!-- fragment --><p>Первые три примера анализируются правильно, а последние три правильно отклоняются. Пытливый читатель может задаться вопросом, что же происходит в интерпретации утверждения вроде "The girls kissed the girls"(Девушки поцеловали девушек). Представляют ли субъект и объект одну и ту же группу девушек или разные группы? Все целуются со всеми, или поцелуев становится меньше? Пока мы не определим наше представление более тщательно, определенно сказать невозможно. В самом деле, кажется, что существует потенциальная проблема в представлении, поскольку предикат <code>kiss</code>(целовать) иногда имеет в качестве аргументов индивидов, а иногда и группы. Более тщательные представления "The girls kissed the girls" включают следующих кандидатов, использующих исчисление предикатов:</p>
<blockquote class="doxtable">
<p>&forall;<code>x</code>&forall;<code>y x</code> &isin; <code>girls</code> &and; <code>y</code> &isin; <code>girls =&gt; kiss(x,y)</code> </p>
</blockquote>
<blockquote class="doxtable">
<p>&forall;<code>x</code> &forall;<code>y x</code> &isin; <code>girls</code> &and; <code>y</code>&epsilon;<code>girls</code> &and; <code>x</code>&ne;<code>y =&gt; kiss(x,y)</code> </p>
</blockquote>
<blockquote class="doxtable">
<p>&forall;<code>x</code>&exist;<code>y,z x</code>&isin; <code>girls</code> &and; <code>y</code>&isin; <code>girls</code> &and; <code>z</code>&isin; <code>girls =&gt; kiss(x,y)</code> &and; <code>kiss(z,x)</code> </p>
</blockquote>
<blockquote class="doxtable">
<p>&forall;<code>x</code>&exist;<code>y x</code>&isin; <code>girls</code> &and; <code>y</code>&isin; <code>girls =&gt; kiss(x,y)</code>&or; <code>kiss(y,x)</code> </p>
</blockquote>
<p>Первая из них гласит, что каждая девушка целует каждую другую девушку. Второй говорит то же самое, за исключением того, что девушке не нужно целоваться. Третий говорит, что каждую девушку целует и целует хотя бы одна другая девушка, но не обязательно все они, а четвертый говорит, что каждый участвует хотя бы в одном поцелуе. Ни одна из этих интерпретаций ничего не говорит о том, кто такие "the girls"(девушки).</p>
<p>Ясно, что представления исчисления предикатов менее неоднозначны, чем представления, производимые текущей системой. С другой стороны, было бы неправильно выбирать одно из представлений произвольно, поскольку в разных контекстах "The girls kissed the girls"(девушки поцеловали девушек) могут означать разные вещи. Сохранение двусмысленности в сжатой форме полезно, если есть какой-то способ в конечном итоге восстановить правильное значение.</p>
<h2>20.4 Грамматика DCG с квантификаторами</h2>
<p>Проблема в представлении, которое мы использовали, становится более острой, когда мы рассматриваем другие детерминанты, такие как "every"(каждый). Рассмотрим утверждение "Every picture paints a story"(Каждая картина изображает историю). Предыдущий DCG, если дать правильный словарь, даст интерпретацию:</p>
<div class="fragment"><div class="line">(paints (every picture) (a story))</div></div><!-- fragment --><p>Это можно считать двусмысленным между следующими двумя значениями в форме исчисления предикатов:</p>
<p><code>&forall; x picture(x)</code>=&gt; <code>&exist; y story(y) &and; paint(x,y)</code></p>
<p><code>&exist; y story (y) &and; &forall; x picture(x)</code>=&gt; <code>paint(x,y)</code></p>
<p>Первый говорит, что для каждой картины есть история, которую она изображает. Второй говорит о том, что каждая картина изображает особую историю. Второе - необычное толкование этого предложения, но для "Every U.S.
citizen has a president"(У каждого U.S. гражданина есть президент", вторая интерпретация, пожалуй, предпочтительнее. В следующем разделе мы увидим, как создавать представления, которые можно преобразовать в любую интерпретацию. На данный момент это полезное упражнение, чтобы увидеть, как мы можем создать только первое представление выше, интерпретацию, которая обычно является правильной. Во-первых, нам нужно преобразовать его в Лисп:</p>
<div class="fragment"><div class="line">(all ?x (-&gt; (picture ?x) (exists ?y (and (story ?y) (paint ?x ?y)))))</div></div><!-- fragment --><p>Первый вопрос - как туда попадают формы <code>all</code> и <code>exists</code>. Они должны исходить от определителей "every"(каждый) и "a"(а). Кроме того, кажется, что за словом <code>all</code> следует стрелка импликации, <code>-&gt;</code>, а за словом <code>exists</code> следует конъюнкция <code>and</code>. Таким образом, у определителей будут преобразования, которые выглядят так:</p>
<div class="fragment"><div class="line">(rule (Det ?any ?x ?p ?q (the ?x (and ?p ?q)))     --&gt; (:word the))</div><div class="line">(rule (Det 3sg ?x ?p ?q (exists ?x (and ?p ?q))) --&gt; (:word a))</div><div class="line">(rule (Det 3sg ?x ?p ?q (all ?x (-&gt; ?p ?q)))         --&gt; (:word every))</div></div><!-- fragment --><p>После того, как мы приняли эти преобразования определителей, следует все остальное. В формулах, представляющих определители, есть две позиции, <code>?p</code> и <code>?q</code>. Первая будет заполнена предикатом, представляющим существительное, а последняя - предикатом, который применяется к фразе существительного в целом. Обратите внимание, что происходит любопытная вещь. Раньше при переводе в логическую форму руководствовались глаголом утверждения. С лингвистической точки зрения глагол выражает основное сказуемое, поэтому логический перевод глагола должен быть основной частью преобразования предложения. В лингвистических терминах мы говорим, что глагол является <em>главой</em> предложения.</p>
<p>С новыми преобразованиями для определителей мы фактически переворачиваем весь процесс с ног на голову. Теперь определитель субъекта(подлежащего) имеет вес всего утверждения. Интерпретация определителя является функцией двух аргументов; сначала она применяется к существительному, давая функцию одного аргумента, которая, в свою очередь, применяется к интерпретации глагольной фразы. Это первенство определителя противоречит интуиции, но прямо ведет к правильной интерпретации.</p>
<p>Переменные <code>?p</code> и <code>?q</code> можно рассматривать как слоты(позиции), которые необходимо заполнить в окончательной интерпретации, но переменная <code>?x</code> выполняет совершенно иную роль. В конце синтаксического разбора <code>?x</code> ничем не будет заполнен; он по-прежнему будет переменной. Но на него будут ссылаться выражения, заполняющие <code>?p</code> и <code>?q</code>. Мы говорим, что <code>?x</code> - это <em>метапеременная</em>, потому что это переменная в представлении, а не в реализации Пролога. Просто так случилось, что переменные Пролога можно использовать для реализации этих метапеременных.</p>
<p>Вот интерпретация каждого слова в нашем целевом предложении и для каждой промежуточной составляющей:</p>
<div class="fragment"><div class="line">Every                   = (all ?x (-&gt; ?pl ?ql))</div><div class="line">picture               = (picture ?x)</div><div class="line">paints                 = (paint ?x ?y)</div><div class="line">a                           = (exists ?y (and ?p2 ?q2))</div><div class="line">story                   = (story ?y)</div><div class="line">Every picture   = (all ?x (-&gt; (picture ?x) ?ql))</div><div class="line">a story               = (exists ?y (and (story ?y) ?q2))</div><div class="line">paints a story = (exists ?y (and (story ?y) (paint ?x ?y)))</div></div><!-- fragment --><p>Семантика существительного должна заполнить позицию в определителе <code>?p</code>, возможно, используя метапеременную <code>?x</code>. Три аргумента к предикату Noun(существительное) - это agreement(согласование), метапеременная <code>?x</code> и оператор контроля(assertion), который выполняет утверждение о фразе существительного <code>?x</code>:</p>
<div class="fragment"><div class="line">(rule (Noun 3sg ?x (picture ?x)) --&gt; (:word picture))</div><div class="line">(rule (Noun 3sg ?x (story ?x)) --&gt; (:word story))</div><div class="line">(rule (Noun 3sg ?x (and (young ?x) (male ?x) (human ?x))) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:word boy))`
</pre><p>Предикат NP изменен на четыре аргумента. Сначала согласование, затем метапеременная <code>?x</code>. Третий - это сказуемое(предикат), которое будет предоставляться извне с помощью глагольной фразы. Последний аргумент возвращает интерпретацию NP в целом. Как мы заявляли, это исходит от определителя:</p>
<div class="fragment"><div class="line">(rule (NP ?agr ?x ?pred ?pred) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Name ?agr ?name))`
</pre><div class="fragment"><div class="line">;(rule (NP ?agr ?x ?pred ?np) --&gt;</div><div class="line">; (Det ?agr ?x ?noun ?pred ?np)</div><div class="line">; (Noun ?agr ?x ?noun))</div></div><!-- fragment --><p>Правило для NP с определителем закомментировано, потому что на этом этапе удобно ввести расширенное правило, чтобы заменить его. Новое правило учитывает некоторые предложения отношений, такие как "the boy that paints a picture"(мальчик, который рисует картину):</p>
<div class="fragment"><div class="line">(rule (NP ?agr ?x ?pred ?np) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Det ?agr ?x ?noun&amp;rel ?pred ?np)`

  `(Noun ?agr ?x ?noun)`

  `(rel-clause ?agr ?x ?noun ?noun&amp;rel))`
</pre><div class="fragment"><div class="line">(rule (rel-clause ?agr ?x ?np ?np) --&gt; )</div><div class="line">(rule (rel-clause ?agr ?x ?np (and ?np ?rel)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:word that)`

  `(VP ?agr ?x ?rel))`
</pre><p>Новое правило не учитывает предложения отношений, в которых отсутствует объект, например "the picture that the boy paints"(рисунок, который рисует мальчик). Тем не менее, добавление предложений отношений означает, что теперь мы можем создать бесконечный язык, поскольку мы всегда можем ввести предложение отношений, которое введет новую фразу существительного, которая, в свою очередь, может вводить еще одно предложение отношения.</p>
<p>Правила для придаточных предложений(предложений отношений) несложны, но их трудно понять. Из четырех аргументов <code>rel-clause</code> первые два содержат согласованные признаки заглавного существительного и метапеременной, представляющей заглавное существительное(head noun). Последние два аргумента используются вместе как аккумулятор для предсказаний о метапеременной: третий аргумент содержит сделанные на данный момент предсказания, а четвертый будет содержать предсказания, включая предложение отношения. Итак, первое правило для <code>rel-clause</code> гласит, что если нет предложения с отношением, то то, что поступает в аккумулятор, совпадает с тем, что выходит. Второе правило гласит, что выходящее - это соединение того, что входит, и того, что указано в самом предложении отношения.</p>
<p>Глаголы применяются как к одной, так и к двум метапеременным, как и раньше. Таким образом, мы можем использовать определения <code>Verb/tr</code> и <code>Verb/intr</code> без изменений. Для разнообразия я добавил еще несколько глаголов:</p>
<p><code>(rule (Verb/tr</code>"<code>3sg ?x ?y (paint ?x ?y)) --&gt; (:word paint))</code></p>
<div class="fragment"><div class="line">(rule (Verb/tr 3sg ?x ?y (paint ?x ?y)) --&gt; (:word paints))</div><div class="line">(rule (Verb/tr ?any ?x ?y (paint ?x ?y)) --&gt; (:word painted))</div></div><!-- fragment --><p><code>(rule (Verb/intr</code>"<code>3sg ?x (sleep ?x)) --&gt; (:word sleep))</code></p>
<div class="fragment"><div class="line">(rule (Verb/intr 3sg ?x (sleep ?x)) --&gt; (:word sleeps))</div><div class="line">(rule (Verb/intr ?any ?x (sleep ?x)) --&gt; (:word slept))</div><div class="line">(rule (Verb/intr 3sg ?x (sells ?x)) --&gt; (:word sells))</div><div class="line">(rule (Verb/intr 3sg ?x (stinks ?x)) --&gt; (:word stinks))</div></div><!-- fragment --><p>Глагольные фразы и утверждения почти те же, что и раньше. Единственное отличие состоит в вызове <code>NP</code>, у которого теперь есть дополнительные аргументы:</p>
<div class="fragment"><div class="line">(rule (VP ?agr ?x ?vp) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/tr ?agr ?x ?obj ?verb)`

  `(NP ?any-agr ?obj ?verb ?vp))`
</pre><div class="fragment"><div class="line">(rule (VP ?agr ?x ?vp) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/intr ?agr ?x ?vp))`
</pre><div class="fragment"><div class="line">(rule (S ?np) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?x ?vp ?np)`

  `(VP ?agr ?x ?vp))`
</pre><p>С помощью этой грамматики мы получаем следующее соответствие между утверждениями и логическими формами:</p>
<div class="fragment"><div class="line">Every picture paints a story.</div><div class="line">(ALL ?3 (-&gt; (PICTURE ?3)</div></div><!-- fragment --> <pre class="fragment">                                      `(EXISTS ?14 (AND (STORY ?14) (PAINT ?3 ?14)))))`
</pre><div class="fragment"><div class="line">Every boy that paints a picture sleeps.</div><div class="line">(ALL ?3 (-&gt; (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))</div></div><!-- fragment --> <pre class="fragment">                                                        `(EXISTS ?19 (AND (PICTURE ?19)`

                                                                                                                    `(PAINT ?3 ?19))))`

                                `(SLEEP ?3)))`
</pre><div class="fragment"><div class="line">Every boy that sleeps paints a picture.</div><div class="line">(ALL ?3 (-&gt; (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))</div></div><!-- fragment --> <pre class="fragment">                                                            `(SLEEP ?3))`

                                    `(EXISTS ?22 (AND (PICTURE ?22) (PAINT ?3 ?22)))))`
</pre><div class="fragment"><div class="line">Every boy that paints a picture that sells</div><div class="line">paints a picture that stinks.</div><div class="line">(ALL ?3 (-&gt; (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))</div></div><!-- fragment --> <pre class="fragment">                                                        `(EXISTS ?19 (AND (AND (PICTURE ?19) (SELLS ?19))`

                                                                                                    `(PAINT ?3 ?19))))`

                                    `(EXISTS ?39 (AND (AND (PICTURE ?39) (STINKS ?39))`

                                                                                                `(PAINT ?3 ?39)))))`
</pre><h2>20.5 Сохранение неоднозначности области квантификатора</h2>
<p>Рассмотрим простое предложение "Every man loves a woman"(Каждый мужчина любит женщину). Это предложение является двусмысленным между следующими двумя интерпретациями:</p>
<div class="fragment"><div class="line">&amp;forall;m&amp;exist;w man(m) &amp;and; woman(w) &amp;and; loves(m,w)</div><div class="line">&amp;exist;w&amp;forall;m man(m) &amp;and; woman(w) &amp;and; loves(m,w)</div></div><!-- fragment --><p>Первая интерпретация состоит в том, что каждый мужчина любит какую-то женщину, возможно, свою жену. Вторая интерпретация заключается в том, что есть некая женщина, которую любит каждый мужчина - возможно, Натасья Кински. Значение предложения неоднозначно, но структура - нет; есть только один синтаксический анализ.</p>
<p>В последнем разделе мы представили синтаксический анализатор, который построит одну из двух интерпретаций. В этом разделе мы покажем, как построить единую интерпретацию, которая сохраняет неоднозначность, но может быть устранена постсинтаксическим процессом. Основная идея состоит в том, чтобы построить промежуточную логическую форму, которая оставляет область действия кванторов неопределенной. Затем эту промежуточную форму можно изменить, чтобы получить окончательную интерпретацию.</p>
<p>Напомним, вот интерпретация, которую мы получили бы для фразы "Every man loves a woman"(Каждый мужчина любит женщину), учитывая грамматику в предыдущем разделе:</p>
<div class="fragment"><div class="line">(all ?m (-&gt; (man ?m) (exists ?w) (and (woman ?w) (loves ?m ?w))))</div></div><!-- fragment --><p>Мы изменим грамматику, чтобы получить промежуточную форму:</p>
<div class="fragment"><div class="line">(and (all ?m (man ?m))</div></div><!-- fragment --> <pre class="fragment">              `(exists ?w (wowan ?w))`

              `(loves ?m ?w))`
</pre><p>Разница в том, что логические компоненты производятся небольшими порциями с квантификаторами без области действия. Типичное правило грамматики будет строить интерпретацию, соединяя составляющие с помощью <code>and</code>, а не вставляя части в слоты в других частях. Вот полная грамматика и достаточно большой лексикон в новом формате:</p>
<div class="fragment"><div class="line">(rule (S (and ?np ?vp)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?x ?np)`

  `(VP ?agr ?x ?vp))`
</pre><div class="fragment"><div class="line">(rule (VP ?agr ?x (and ?verb ?obj)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/tr ?agr ?x ?o ?verb)`

  `(NP ?any-agr ?o ?obj))`
</pre><div class="fragment"><div class="line">(rule (VP ?agr ?x ?verb) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/intr ?agr ?x ?verb))`
</pre><div class="fragment"><div class="line">(rule (NP ?agr ?name t) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Name ?agr ?name))`
</pre><div class="fragment"><div class="line">(rule (NP ?agr ?x ?det) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Det ?agr ?x (and ?noun ?rel) ?det)`

  `(Noun ?agr ?x ?noun)`

  `(rel-clause ?agr ?x ?rel))`
</pre><div class="fragment"><div class="line">(rule (rel-clause ?agr ?x t) --&gt; )</div><div class="line">(rule (rel-clause ?agr ?x ?rel) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:word that)`

  `(VP ?agr ?x ?rel))`
</pre><div class="fragment"><div class="line">(rule (Name 3sg Terry)                                       --&gt; (:word Terry))</div><div class="line">(rule (Name 3sg Jean)                                         --&gt; (:word Jean))</div><div class="line">(rule (Det 3sg ?x ?restr (all ?x ?restr)) --&gt; (:word every))</div><div class="line">(rule (Noun 3sg ?x (man ?x))                           --&gt; (:word man))</div><div class="line">(rule (Verb/tr 3sg ?x ?y (love ?x ?y))       --&gt; (:word loves))</div><div class="line">(rule (Verb/intr 3sg ?x (lives ?x))             --&gt; (:word lives))</div><div class="line">(rule (Det 3sg ?x ?res (exists ?x ?res))   --&gt; (:word a))</div><div class="line">(rule (Noun 3sg ?x (woman ?x))                       --&gt; (:word woman))</div></div><!-- fragment --><p>Это дает нам следующий синтаксический анализ фразы "Every man loves a woman"(Каждый мужчина любит женщину):</p>
<div class="fragment"><div class="line">(and (all ?4 (and (man ?4) t))</div></div><!-- fragment --> <pre class="fragment">            `(and (love ?4 ?12) (exists ?12 (and (woman ?12) t))))`
</pre><p>Если бы мы упростили это, исключив ts и joining ands, мы получили бы желаемое представление:</p>
<div class="fragment"><div class="line">(and (all ?m (man ?m))</div></div><!-- fragment --> <pre class="fragment">            `(exists ?w (wowan ?w))`

            `(loves ?m ?w))`
</pre><p>Оттуда мы могли бы использовать то, что мы знаем о синтаксисе, в дополнение к тому, что мы знаем о мужчинах, женщинах и любви, чтобы определить наиболее вероятную окончательную интерпретацию. Об этом мы поговорим в следующей главе.</p>
<h2>20.6 Зависимости на большом расстоянии</h2>
<p>До сих пор каждый синтаксический феномен, который мы рассматривали, был выражен в правиле, которое накладывает ограничения только на одном уровне. Например, нам пришлось наложить ограничение, согласно которому субъект согласован со своим глаголом, но это ограничение включало две непосредственные составляющие предложения, фразу существительного и глагольную фразу. Нам не нужно было выражать ограничение между, скажем, подлежащим(субьектом) и модификатором объекта глагола. Однако существуют лингвистические явления, требующие именно таких ограничений.</p>
<p>Наше правило для предложений выражающих отношения было очень простым: предлжение отношения(придаточное) состоит из слова "that", за которым следует утверждение без подлежащего(субъекта), как в "every man that loves a woman"(каждый мужчина, который любит женщину). Не все предложения отношений следуют этому шаблону. Также возможно сформировать предложение отношений, опуская объект встроенного утверждения: "every man that a woman loves &amp;blank;"(каждый мужчина, которого любит женщина ). В этом утверждении символ  указывает на разрыв/зазор/пробел, который понимается как заполнение заголовком полной фразы существительного, the man(мужчина). Это было названо <em>зависимостью заполнитель-разрыв</em>. Это также известно как <em>зависимость на большом расстоянии</em>, потому что разрыв может возникать произвольно далеко от заполнителя. Например, все следующие действительные фразы существительного:</p>
<p>The person that Lee likes </p>
<p>The person that Kim thinks Lee likes </p>
<p>The person that Jan says Kim thinks Lee likes </p>
<p>В каждом случае разрыв заполняется заглавным существительным - the person(человеком). Но между заглавным существительным и разрывом может стоять любое количество предложений выражающих отношения.</p>
<p>Такая же зависимость между заполнителем и разрывом имеет место в вопросах, которые начинаются со слов "who"(кто), "what"(что), "where"(где) и других вопросительных местоимений. Например, мы можем задать вопрос о теме(субъекте) утверждения, как в "Who likes Lee?"(Кому нравится Ли?), или о объекте, как в "Who does Kim like &amp;blank;?"(Кому нравится Ким ?).</p>
<p>Вот грамматика, которая охватывает предложения отношений с разрывами в субъектах или объектах. Правила для <code>S, VP,</code> и <code>NP</code> дополняются парой аргументов, представляющих аккумулятор для разрывов. Как и в списке различий, первый аргумент минус второй представляет наличие или отсутствие разрыва. Например, в первых двух правилах для фраз существительного два аргумента одинаковы: <code>?g0</code> и <code>?g0</code>. Это означает, что в правиле в целом нет разрывов, поскольку здесь не может быть разницы между двумя аргументами. В третьем правиле для NP первый аргумент имеет форму <code>(gap ...)</code>, а второй - <code>nogap</code>. Это означает, что правая часть правила, пустая составляющая, может быть проанализирована. как разрыв. (Обратите внимание, что если бы мы использовали истинностные списки различий, двумя аргументами были бы <code>((gap ...) ?g0)</code> и <code>?g0</code> Но поскольку мы имеем дело только с одним разрывом на правило, нам не нужны истинностные списки различий.)</p>
<p>Правило для <code>S</code> гласит, что фраза существительного с разрывом <code>?g0</code> минус <code>?gl</code>, за которой следует глагольная фраза с разрывом <code>?gl</code> минус <code>?g2</code>, составляет утверждение с разрывом <code>?g0</code> минус <code>?g2</code>. Правило для предложений с отношением находит предложение с разрывом где угодно; либо в субъекте, либо в глагольной фразе. Вот полная грамматика:</p>
<div class="fragment"><div class="line">(rule (S ?g0 ?g2 (and ?np ?vp)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?g0 ?gl ?agr ?x ?np)`

  `(VP ?gl ?g2 ?agr ?x ?vp))`
</pre><div class="fragment"><div class="line">(rule (VP ?g0 ?gl ?agr ?x (and ?obj ?verb)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/tr ?agr ?x ?o ?verb)`

  `(NP ?g0 ?gl ?any-agr ?o ?obj))`
</pre><div class="fragment"><div class="line">(rule (VP ?g0 ?g0 ?agr ?x ?verb) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Verb/intr ?agr ?x ?verb))`
</pre><div class="fragment"><div class="line">(rule (NP ?g0 ?g0 ?agr ?name t) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Name ?agr ?name))`
</pre><div class="fragment"><div class="line">(rule (NP ?g0 ?g0 ?agr ?x ?det) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Det ?agr ?x (and ?noun ?rel) ?det)`

  `(Noun ?agr ?x ?noun)`

  `(rel-clause ?agr ?x ?rel))`
</pre><div class="fragment"><div class="line">(rule (NP (gap NP ?agr ?x) nogap ?agr ?x t) --&gt; )</div><div class="line">(rule (rel-clause ?agr ?x t) --&gt; )</div><div class="line">(rule (rel-clause ?agr ?x ?rel) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:word that)`

  `(S (gap NP ?agr ?x) nogap ?rel))`
</pre><p>Вот несколько пар утверждение/синтаксический анализ, охватываемых этой грамматикой:</p>
<p><code>Every man that</code>  <code>loves a woman likes a person.</code></p>
<div class="fragment"><div class="line">(AND (ALL ?28 (AND (MAN ?28)</div></div><!-- fragment --> <pre class="fragment">        `(AND T (AND (LOVE ?28 ?30)`

              `(EXISTS ?30 (AND (WOMAN ?30)`

                          `T))))))`

  `(AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?28 ?39)))`
</pre><p><code>Every man that a woman loves</code>  <code>likes a person.</code></p>
<div class="fragment"><div class="line">(AND (ALL ?37 (AND (MAN ?37)</div></div><!-- fragment --> <pre class="fragment">        `(AND (EXISTS ?20 (AND (WOMAN ?20) T))`

            `(AND T (LOVE ?20 ?37)))))`

  `(AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?37 ?39)))`
</pre><p><code>Every man that loves a bird that</code>  <code>flies likes a person.</code></p>
<div class="fragment"><div class="line">(AND (ALL ?28 (AND (MAN ?28)</div></div><!-- fragment --> <pre class="fragment">        `(AND T (AND (EXISTS ?54`

              `(AND (BIRD ?54)`

                      `(AND T (FLY ?54))))`

            `(LOVE ?28 ?54)))))`

  `(AND (EXISTS ?60 (AND (PERSON ?60) T)) (LIKE ?28 ?60)))`
</pre><p>На самом деле есть ограничения на ситуации, в которых могут возникнуть разрывы. В частности, редко бывает разрыв в субъекте утверждения, за исключением случая предложения с отношением. В следующей главе мы увидим, как наложить дополнительные ограничения на разрывы.</p>
<h2>20.7 Дополнение правил DCG</h2>
<p>В предыдущем разделе мы увидели, как создать семантическое представление утверждения, объединив семантику компонентов. Одна из проблем с этим подходом состоит в том, что семантическая интерпретация часто имеет форму <code>(and (and t *a) b)*</code>, тогда как мы предпочитаем <code>(and *a b)*</code>. Есть два способа исправить эту проблему: либо мы добавляем шаг, который берет окончательную семантическую интерпретацию и упрощает ее, либо мы усложняем каждое отдельное правило, заставляя его генерировать упрощенную форму. Второй вариант был бы немного более эффективным, но был бы очень уродливым и подверженным ошибкам. Мы должны делать все возможное, чтобы правила были проще, а не усложнялись; в этом весь смысл формализма DCG. Это предполагает третий подход: изменить интерпретатор правила так, чтобы он автоматически генерировал семантическую интерпретацию как соединение составляющих, если в правиле явно не указано иное. В этом разделе показано, как дополнить правила DCG для автоматической обработки таких распространенных случаев.</p>
<p>Снова рассмотрим правило из <a href="#s0025">раздела 20.4</a>:</p>
<div class="fragment"><div class="line">(rule (S (and ?np ?vp)) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?x ?np)`

  `(VP ?agr ?x ?vp))`
</pre><p>Если бы мы изменили это правило, чтобы получить упрощенную семантическую интерпретацию, это выглядело бы следующим образом, где предикат <code>and*</code> упрощает список союзов до единого союза:</p>
<div class="fragment"><div class="line">(rule (S ?sem) --&gt;</div></div><!-- fragment --> <pre class="fragment">  `(np ?agr ?x ?np)`

  `(vp ?agr ?x ?vp)`

  `(:test (and*(?np ?vp) ?sem)))`
</pre><p>Многие правила будут иметь такую форму, поэтому мы принимаем простое соглашение: если последним аргументом составляющей в левой части правила является ключевое слово <code>:sem</code>, то мы построим семантику, заменив <code>:sem</code> с конъюнкцией, образованной путем объединения всех последних аргументов составляющих правую часть правила. Стрелка <code>A==&gt;</code> будет использоваться для правил, следующих этому соглашению, поэтому следующее правило эквивалентно приведенному выше:</p>
<div class="fragment"><div class="line">(rule (S :sem) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?x ?np)`

  `(VP ?agr ?x ?vp))`
</pre><p>Иногда полезно ввести дополнительную семантику, которая не исходит от одного из компонентов. Это можно указать с помощью элемента в правой части списка, начинающегося с <code>:sem</code>. Например, следующее правило добавляет к семантике тот факт, что <code>?x</code> является темой предложения:</p>
<div class="fragment"><div class="line">(rule (S :sem) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(NP ?agr ?x ?np)`

  `(VP ?agr ?x ?vp)`

  `(:sem (topic ?x)))`
</pre><p>Перед реализацией функции правила для стрелки <code>==&gt;</code> стоит подумать, есть ли другие способы упростить работу автора правил. Одна из возможностей - предоставить обозначения для описания примеров. Примеры помогают понять, для чего создано правило. Для правила <code>S</code> мы могли бы добавить такие примеры:</p>
<div class="fragment"><div class="line">(rule (S :sem) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:ex "John likes Mary" "He sleeps")`

  `(NP ?agr ?x ?np)`

  `(VP ?agr ?x ?vp))`
</pre><p>Эти примеры не только служат в качестве документации для правила, но также могут быть сохранены в <code>S</code> и впоследствии запускаться, когда мы хотим проверить, действительно ли <code>S</code> реализовано правильно.</p>
<p>Другая область, в которой составитель правил может использовать помощь, - это обработка леворекурсивных правил. Рассмотрим правило, согласно которому утверждение может состоять из двух утверждений, соединенных союзом:</p>
<div class="fragment"><div class="line">(rule (S (?conj ?sl ?s2)) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(:ex "John likes Mary and Mary likes John")`

  `(S ?sl)`

  `(Conj ?conj)`

  `(S ?s2))`
</pre><p>Хотя это правило является верным как декларативное утверждение, оно вызовет трудности при запуске стандартным процессом интерпретации DCG сверху вниз, сначала в глубину. Цель верхнего уровня для синтаксического анализа <code>S</code> немедленно приведет к подзадаче синтаксического анализа <code>S</code>, и результатом будет бесконечный цикл.</p>
<p>К счастью, мы знаем, как избежать такого бесконечного цикла: разделить предикат, вызывающий нарушение, <code>S</code> на два предиката: один, поддерживающий рекурсию, и другой, находящийся на более низком уровне. Мы будем называть предикат нижнего уровня <code>S-</code>. Таким образом, следующее правило гласит, что утверждение может состоять из двух утверждений, где первое не соединяется, а второе, возможно, соединено:</p>
<div class="fragment"><div class="line">(rule (S (?conj ?sl ?s2)) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(S_ ?sl)`

  `(Conj ?conj)`

  `(S ?s2))`
</pre><p>Нам также нужно правило, которое гласит, что возможно составное утверждение может состоять из несоединенного утрверждения:</p>
<div class="fragment"><div class="line">(rule (S ?sem) ==&gt; (S- ?sem))</div></div><!-- fragment --><p>Чтобы это сработало, нам нужно заменить любое упоминание <code>S</code> в левой части правила на <code>S-</code>. Ссылки на <code>S</code> в правой части правил остаются без изменений.</p>
<div class="fragment"><div class="line">(rule (S- ?sem) ==&gt;...)</div></div><!-- fragment --><p>Чтобы сделать все это автоматическим, мы предоставим макрос, <code>conj-rule</code>, который объявляет категорию как такую, которую можно объединить. Такое объявление автоматически сгенерирует рекурсивные и нерекурсивные правила для категории и обеспечит замену будущих ссылок на категорию в левой части правила на соответствующий предикат нижнего уровня.</p>
<p>Одна из проблем этого подхода заключается в том, что он требует синтаксического анализа с ветвлением вправо для нескольких соединенных фраз. То есть мы получим такие синтаксические выражения, как "spaghetti and (meatballs and salad)"(спагетти и (тефтели и салат)) not "(spaghetti and meatballs) and salad". Ясно, что это неправильное толкование этого утверждения. Тем не менее, можно утверждать, что лучше всего произвести один канонический синтаксический анализ, а затем позволить функциям семантической интерпретации позаботиться о переупорядочении синтаксического анализа в правильном порядке. Мы не будем пытаться разрешить этот спор, но предоставим механизм автоматического соединения в качестве инструмента, который может быть удобным, но не требует затрат для пользователя, который предпочитает другое решение.</p>
<p>Теперь мы готовы реализовать расширенный формализм правил DCG, который обрабатывает <code>:sem, :ex,</code> и автоматические объединения(конъюнкции). Функция <code>make-augmented-dcg</code>, сохраненная под стрелкой <code>==&gt;</code>, будет использоваться для реализации формализма:</p>
<div class="fragment"><div class="line">(setf (get &#39;==&gt; &#39;rule-function) &#39;make-augmented-dcg)</div><div class="line"></div><div class="line">(defun make-augmented-dcg (head body)</div><div class="line">  &quot;Build an augmented DCG rule that handles :sem, :ex,</div><div class="line">  and automatic conjunctiontive constituents.&quot;</div><div class="line">  (if (eq (last1 head) :sem)</div><div class="line">      ;; Handle :sem</div><div class="line">      (let* ((?sem (gensym &quot;?SEM&quot;)))</div><div class="line">        (make-augmented-dcg</div><div class="line">          `(,@(butlast head) ,?sem)</div><div class="line">          `(,@(remove :sem body :key #&#39;first-or-nil)</div><div class="line">            (:test ,(collect-sems body ?sem)))))</div><div class="line">      ;; Separate out examples from body</div><div class="line">      (multiple-value-bind (exs new-body)</div><div class="line">          (partition-if #&#39;(lambda (x) (starts-with x :ex)) body)</div><div class="line">        ;; Handle conjunctions</div><div class="line">        (let ((rule `(rule ,(handle-conj head) --&gt; ,@new-body)))</div><div class="line">          (if (null exs)</div><div class="line">              rule</div><div class="line">              `(progn (:ex ,head .,(mappend #&#39;rest exs))</div><div class="line">                      ,rule))))))</div></div><!-- fragment --><p>Сначала мы показываем код, который собирает вместе семантику каждой составляющей и объединяет их, когда указано <code>:sem</code>. Функция <code>collect-sems</code> выбирает семантику и обрабатывает тривиальные случаи, когда в правой части есть ноль или одна составляющая. Если их несколько, она вставляет вызов предиката <code>and*</code>.</p>
<div class="fragment"><div class="line">(defun collect-sems (body ?sem)</div><div class="line">  &quot;Get the semantics out of each constituent in body,</div><div class="line">  and combine them together into ?sem.&quot;</div><div class="line">  (let ((sems (loop for goal in body</div><div class="line">                    unless (or (dcg-normal-goal-p goal)</div><div class="line">                               (dcg-word-list-p goal)</div><div class="line">                               (starts-with goal :ex)</div><div class="line">                               (atom goal))</div><div class="line">                    collect (last1 goal))))</div><div class="line">    (case (length sems)</div><div class="line">      (0 `(= ,?sem t))</div><div class="line">      (1 `(= ,?sem ,(first sems)))</div><div class="line">      (t `(and* ,sems ,?sem)))))</div></div><!-- fragment --><p>Мы могли бы реализовать <code>and*</code> с предложениями Prolog, но немного эффективнее делать это непосредственно в Lisp. Вызов <code>conjuncts</code> собирает все конъюнкты, а затем мы добавляем and, если необходимо:</p>
<div class="fragment"><div class="line">(defun and*/2 (in out cont)</div><div class="line">  &quot;IN is a list of conjuncts that are conjoined into OUT.&quot;</div><div class="line">  ;; E.g.: (and* (t (and a b) t (and c d) t) ?x) ==&gt;</div><div class="line">  ;;        ?x = (and a b c d)</div><div class="line">  (if (unify! out (maybe-add &#39;and (conjuncts (cons &#39;and in)) t))</div><div class="line">      (funcall cont)))</div><div class="line"></div><div class="line">(defun conjuncts (exp)</div><div class="line">  &quot;Get all the conjuncts from an expression.&quot;</div><div class="line">  (deref exp)</div><div class="line">  (cond ((eq exp t) nil)</div><div class="line">        ((atom exp) (list exp))</div><div class="line">        ((eq (deref (first exp)) &#39;nil) nil)</div><div class="line">        ((eq (first exp) &#39;and)</div><div class="line">         (mappend #&#39;conjuncts (rest exp)))</div><div class="line">        (t (list exp))))</div></div><!-- fragment --><p>Следующий шаг - работа с примерами фраз. Код в <code>make-augmented-dcg</code> превращает примеры в выражения вида:</p>
<div class="fragment"><div class="line">(:ex (S ?sem) &quot;John likes Mary&quot; &quot;He sleeps&quot;)</div></div><!-- fragment --><p>Чтобы это работало, :ex должен быть макросом:</p>
<div class="fragment"><div class="line">(defmacro :ex ((category . args) &amp;body examples)</div><div class="line">  &quot;Add some example phrases, indexed under the category.&quot;</div><div class="line">  `(add-examples &#39;,category &#39;,args &#39;,examples))</div></div><!-- fragment --><p>`:ex вызывает add-examples, чтобы выполнить всю работу. Каждый пример хранится в хэш-таблице, индексируемой по категории. Каждый пример преобразуется в список из двух элементов: сама строка фразы примера и вызов соответствующего предиката со всеми предоставленными аргументами. Функция <code>add-examples</code> выполняет это преобразование и индексацию, а <code>run-examples</code> извлекает примеры, хранящиеся в категории, печатает каждую фразу и вызывает каждую цель. Вспомогательные функции <code>get-examples</code> и <code>clear-examples</code> предназначены для управления таблицей примеров, а <code>remove-punction, punctuation-p</code> и <code>string-&gt;list</code> используются для отображения строки в список. слов.</p>
<div class="fragment"><div class="line">(defvar *examples* (make-hash-table :test #&#39;eq))</div><div class="line">(defun get-exampl es (category) (gethash category *examples*))</div><div class="line">(defun clear-examples () (clrhash *examples*))</div><div class="line"></div><div class="line">(defun add-examples (category args examples)</div><div class="line">  &quot;Add these example strings to this category,</div><div class="line">  and when it comes time to run them, use the args.&quot;</div><div class="line">  (dolist (example examples)</div><div class="line">    (when (stringp example)</div><div class="line">      (let ((ex `(,example</div><div class="line">                  (,category ,@args</div><div class="line">                   ,(string-&gt;list</div><div class="line">                      (remove-punctuation example)) ()))))</div><div class="line">        (unless (member ex (get-examples category)</div><div class="line">                        :test #&#39;equal)</div><div class="line">          (setf (gethash category *examples*)</div><div class="line">                (nconc (get-examples category) (list ex))))))))</div><div class="line"></div><div class="line">(defun run-examples (&amp;optional category)</div><div class="line">  &quot;Run all the example phrases stored under a category.</div><div class="line">  With no category, run ALL the examples.&quot;</div><div class="line">  (prolog-compile-symbols)</div><div class="line">  (if (null category)</div><div class="line">      (maphash #&#39;(lambda (cat val)</div><div class="line">                   (declare (ignore val))</div><div class="line">                   (format t &quot;~2&amp;Examples of ~a:~&amp;&quot; cat)</div><div class="line">                   (run-examples cat))</div><div class="line">               *examples*)</div><div class="line">      (dolist (example (get-examples category))</div><div class="line">        (format t &quot;~2&amp;EXAMPLE: ~{~a~&amp;~9T~a~}&quot; example)</div><div class="line">        (top-level-prove (cdr example)))))</div><div class="line"></div><div class="line">(defun remove-punctuation (string)</div><div class="line">  &quot;Replace punctuation with spaces in string.&quot;</div><div class="line">  (substitute-if #\space #&#39;punctuation-p string))</div><div class="line"></div><div class="line">(defun string-&gt;list (string)</div><div class="line">  &quot;Convert a string to a list of words.&quot;</div><div class="line">  (read-from-string (concatenate &#39;string &quot;(&quot; string &quot;)&quot;)))</div><div class="line"></div><div class="line">(defun punctuation-p (char) (find char &quot;*_.,;:`!?#-()\\\&quot;&quot;))</div></div><!-- fragment --><p>Последняя часть нашего расширенного формализма DCG - это автоматическая обработка конъюнктивных составляющих. Мы уже организовали перевод символов категорий в левой части правил в соответствующую конъюнктивную категорию, как определено функцией <code>handle-conj</code>. Мы также хотим сгенерировать автоматически (или как можно проще) правила следующего вида:</p>
<div class="fragment"><div class="line">(rule (S (?conj ?sl ?s2)) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(S_ ?sl)`

  `(Conj ?conj)`

  `(S ?s2))`
</pre><div class="fragment"><div class="line">(rule (S ?sem) ==&gt; (S_ ?sem))</div></div><!-- fragment --><p>Но прежде чем создавать эти правила, давайте убедимся, что они именно то, что мы хотим. Рассмотрите возможность синтаксического анализа несоединенного утверждения с этими двумя правилами. Первое правило будет анализировать все утверждение как <code>S_</code>, а затем не сможет увидеть <code>Conj</code> и, следовательно, потерпит неудачу. Второе правило будет дублировать весь процесс синтаксического анализа, таким образом удваивая количество затрачиваемого времени. Если мы изменим порядок двух правил, мы сможем быстро анализировать несоединенные утверждения, но при этом нам придется возвращаться к соединенным утверждениям.</p>
<p>Ниже показан лучший подход. Единственное правило для <code>S</code> анализирует утверждение с помощью <code>S_</code>, а затем вызывает <code>Conj_S</code>, который может быть прочитан как "либо соединение, за которым следует утверждение, либо ничего". Если за первым утверждением ничего не следует, тогда мы просто используем семантику первого утверждения; если есть конъюнкция, мы должны сформировать комбинированную семантику. Я добавил ..., чтобы показать, где подходят аргументы предикату, кроме семантического аргумента.</p>
<div class="fragment"><div class="line">(rule (S ... ?s-combined) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(S_ ... ?seml)`

  `(Conj_S ?seml ?s-combined))`
</pre><div class="fragment"><div class="line">(rule (Conj_S ?seml (?conj ?seml ?sem2)) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Conj ?conj)`

  `(S ... ?sem2))`
</pre><div class="fragment"><div class="line">(rule (Conj_S ?seml ?seml) ==&gt;)</div></div><!-- fragment --><p>Теперь все, что нам нужно, это способ указать пользователю, что эти три правила желательны. Поскольку точный метод построения комбинированной семантики и, возможно, даже вызов <code>Conj</code> может варьироваться в зависимости от специфики определяемой грамматики, правила не могут быть сгенерированы полностью автоматически. Мы остановимся на макросе <code>conj-rule</code>, который очень похож на второе из трех приведенных выше правил, но расширяется во все три, плюс код, связывающий <code>S_</code> с <code>S</code>. Итак, пользователь наберет:</p>
<div class="fragment"><div class="line">(conj-rule (Conj_S ?seml (?conj ?seml ?sem2)) ==&gt;</div></div><!-- fragment --> <pre class="fragment">  `(Conj ?conj)`

  `(S ?a ?b ?c ?sem2))`
</pre><p>Вот определение макроса:</p>
<div class="fragment"><div class="line">(defmacro conj-rule ((conj-cat sem1 combined-sem) ==&gt;</div><div class="line">                     conj (cat . args))</div><div class="line">  &quot;Define this category as an automatic conjunction.&quot;</div><div class="line">  (assert (eq ==&gt; &#39;==&gt;))</div><div class="line">  `(progn</div><div class="line">     (setf (get &#39;,cat &#39;conj-cat) &#39;,(symbol cat &#39;_))</div><div class="line">     (rule (,cat ,@(butlast args) ?combined-sem) ==&gt;</div><div class="line">       (,(symbol cat &#39;_) ,@(butlast args) ,sem1)</div><div class="line">       (,conj-cat ,sem1 ?combined-sem))</div><div class="line">     (rule (,conj-cat ,sem1 ,combined-sem) ==&gt;</div><div class="line">       ,conj</div><div class="line">       (,cat ,@args))</div><div class="line">     (rule (,conj-cat ?sem1 ?sem1) ==&gt;)))</div></div><!-- fragment --><p>и здесь мы определяем <code>handle-conj</code> для подстановки <code>S-</code> для <code>S</code> в левой части правил:</p>
<div class="fragment"><div class="line">(defun handle-conj (head)</div><div class="line">  &quot;Replace (Cat ...) with (Cat_ ...) if Cat is declared</div><div class="line">  as a conjunctive category.&quot;</div><div class="line">  (if (and (listp head) (conj-category (predicate head)))</div><div class="line">      (cons (conj-category (predicate head)) (args head))</div><div class="line">      head))</div><div class="line"></div><div class="line">(defun conj-category (predicate)</div><div class="line">  &quot;If this is a conjunctive predicate, return the Cat_ symbol.&quot;</div><div class="line">  (get predicate &#39;conj-category))</div></div><!-- fragment --><h2>20.8 История и ссылки</h2>
<p>As we have mentioned, Alain Colmerauer invented Prolog to use in his grammar of French (1973). His <em>metamorphosis grammar</em> formalism was more expressive but much less efficient than the standard DCG formalism.</p>
<p>The grammar in <a href="#s0025">section 20.4</a> is essentially the same as the one presented in Fernando Pereira and David H. D. Warren's 1980 paper, which introduced the Definite Clause Grammar formalism as it is known today. The two developed a much more substantial grammar and used it in a very influential question-answering system called Chat-80 (<a href="B9780080571157500285.xhtml#bb1340">Warren and Pereira, 1982</a>). Pereira later teamed with Stuart Shieber on an excellent book covering logic grammars in more depth: <em>Prolog and Natural-Language Analysis</em> (1987). The book has many strong points, but unfortunately it does not present a grammar anywhere near as complete as the Chat-80 grammar.</p>
<p>The idea of a compositional semantics based on mathematical logic owes much to the work of the late linguist Richard Montague. The introduction by <a href="B9780080571157500285.xhtml#bb0335">Dowty, Wall, and Peters (1981)</a> and the collection by <a href="B9780080571157500285.xhtml#bb1235">Rich Thomason (1974)</a> cover Montague's approach.</p>
<p>The grammar in <a href="#s0030">section 20.5</a> is based loosely on Michael McCord's modular logic grammar, as presented in <a href="B9780080571157500285.xhtml#bb1295">Walker et al. 1990</a>.</p>
<p>It should be noted that logic grammars are by no means the only approach to natural language processing. <a href="B9780080571157500285.xhtml#bb1425">Woods (1970)</a> presents an approach based on the <em>augmented transition network</em>, or ATN. A transition network is like a context-free grammar. The <em>augmentation</em> is a way of manipulating features and semantic values. This is just like the extra arguments in DCGs, except that the basic operations are setting and testing variables rather than unification. So the choice between ATNs and DCGs is largely a matter of what programming approach you are most comfortable with: procedural for ATNs and declarative for DCGs. My feeling is that unification is a more suitable primitive than assignment, so I chose to present DCGs, even though this required bringing in Prolog's backtracking and unification mechanisms.</p>
<p>In either approach, the same linguistic problems must be addressed-agreement, long-distance dependencies, topicalization, quantifier-scope ambiguity, and so on. Comparing <a href="B9780080571157500285.xhtml#bb1425">Woods's (1970)</a> ATN grammar to <a href="B9780080571157500285.xhtml#bb0950">Pereira and Warren's (1980)</a> DCG grammar, the careful reader will see that the solutions have much in common. The analysis is more important than the notation, as it should be.</p>
<h2>20.9 Упражнения</h2>
<p><b>Exercise 20.2 [m]</b> Modify the grammar (from <a href="#s0025">section 20.4</a>, <a href="#s0030">20.5</a>, <a href="#s0035">or 20.6</a>) to allow for adjectives before a noun.</p>
<p><b>Exercise 20.3 [m]</b> Modify the grammar to allow for prepositional phrase modifiers on verb and noun phrases.</p>
<p><b>Exercise 20.4 [m]</b> Modify the grammar to allow for ditransitive verbs-verbs that take two objects, as in "give the dog a bone."</p>
<p><b>Exercise 20.5</b> Suppose we wanted to adopt the Prolog convention of writing DCG tests and words in brackets and braces, respectively. Write a function that will alter the readtable to work this way.</p>
<p><b>Exercise 20.6 [m]</b> Define a rule function for a new type of DCG rule that automatically builds up a syntactic parse of the input. For example, the two rules:</p>
<div class="fragment"><div class="line">(rule (s) =&gt; (np) (vp))</div><div class="line">(rule (np) =&gt; (:word he))</div></div><!-- fragment --><p>should be equivalent to:</p>
<div class="fragment"><div class="line">(rule (s (s ?1 ?2)) --&gt; (np ?1) (vp ?2))</div><div class="line">(rule (np (np he)) --&gt; (:word he))</div></div><!-- fragment --><p><b>Exercise 20.7 [m]</b> There are advantages and disadvantages to the approach that Prolog takes in dividing predicates into clauses. The advantage is that it is easy to add a new clause. The disadvantage is that it is hard to alter an existing clause. If you edit a clause and then evaluate it, the new clause will be added to the end of the clause list, when what you really wanted was for the new clause to take the place of the old one. To achieve that effect, you have to call <code>clear-predicate</code>, and then reload all the clauses, not just the one that has been changed.</p>
<p>Write a macro <code>named-rule</code> that is just like <code>rule</code>, except that it attaches names to clauses. When a named rule is reloaded, it replaces the old clause rather than adding a new one.</p>
<p><b>Exercise 20.8 [h]</b> Extend the DCG rule function to allow or goals in the right-hand side. To make this more useful, also allow <code>and</code> goals. For example:</p>
<div class="fragment"><div class="line">(rule (A) --&gt; (B) (or (C) (and (D) (E))) (F))</div></div><!-- fragment --><p>should compile into the equivalent of :</p>
<div class="fragment"><div class="line">(&lt;- (A ?S0 ?S4)</div></div><!-- fragment --> <pre class="fragment">  `(B ?S0 ?S1)`

  `(OR (AND (C ?S1 ?S2) (= ?S2 ?S3))`

`(AND (D ?S1 ?S2) (E ?S2 ?S3)))`

  `(F ?S3 ?S4))`
</pre><h2>20.10 Ответы</h2>
<p><b>Answer 20.1</b> It uses local variables <code>(?s0, ?sl ...)</code> that are not guaranteed to be unique. This is a problem if the grammar writer wants to use these symbols anywhere in his or her rules. The fix is to <code>gensym</code> symbols that are guaranteed to be unique.</p>
<h3>Answer 20.5</h3>
<p><code>(defun setup-braces Uoptional (on? t) (readtable *readtable*))</code> </p><pre class="fragment">  `"Make [a b] read as (:word a b) and {a b} as (:test a b c) if ON?
</pre><p> is true; otherwise revert {[]} to normal."` </p><pre class="fragment">  `if ON?
</pre><p> is true; otherwise revert {[]} to normal."` </p><pre class="fragment">  `(if (not on?)`

  `(map nil #'(lambda (c)`

          `(set-macro-character c (get-macro-character #\a)`

                    `t readtable))`

    `"{[]}")`

  `(progn`

    `(set-macro-character`

      `#\] (get-macro-character #\)) nil readtable)`

    `(set-macro-character`

      `#</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
