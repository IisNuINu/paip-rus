<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 10</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 10 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Проблемы эффективности на низком уровне</h2>
<blockquote class="doxtable">
<p>В мире всего два качества: эффективность и неэффективность; и только два типа людей: эффективные и неэффективные </p>
</blockquote>
<blockquote class="doxtable">
<p>-George Bernard Shaw </p>
</blockquote>
<blockquote class="doxtable">
<p>John Bull's Other Island (1904) </p>
</blockquote>
<p>Все методы повышения эффективности из предыдущей главы включали в себя довольно значительные изменения в алгоритме. Но что происходит, когда вы уже используете лучшие алгоритмы, которые только можно представить, а производительность по-прежнему остается проблемой? Один из ответов - найти, какие части программы используются наиболее часто, и провести микрооптимизацию этих частей. В этой главе рассматриваются следующие шесть методов оптимизации. Если все ваши программы работают достаточно быстро, можете пропустить эту главу. Но если вы хотите, чтобы ваши программы работали быстрее, описанные здесь методы могут привести к ускорению в 40 или более раз.</p>
<ul>
<li>Используйте декларации.</li>
<li>Избегайте обобщенных функций.</li>
<li>Избегайте сложных списков аргументов.</li>
<li>Предоставить макросы компилятора.</li>
<li>Избегайте ненужного consing-а(создания лишних списков).</li>
<li>Используйте правильные структуры данных.</li>
</ul>
<h2>10.1 Используйте декларации(объявления)</h2>
<p>На компьютерах общего назначения, на которых работает Lisp, много времени тратится на проверку типов. Вы можете повысить эффективность за счет надежности, объявив или пообещав, что определенные переменные всегда будут определенного типа. Например, рассмотрим следующую функцию для вычисления суммы квадратов последовательности чисел:</p>
<div class="fragment"><div class="line">(defun sum-squares (seq)</div><div class="line">  (let ((sum 0))</div><div class="line">    (dotimes (i (length seq))</div><div class="line">      (incf sum (square (elt seq i))))</div><div class="line">    sum))</div><div class="line">(defun square (x) (* x x))</div></div><!-- fragment --><p>Если эта функция будет использоваться только для суммирования векторов фиксированных чисел(fixnums), мы можем сделать её намного быстрее, добавив объявления:</p>
<div class="fragment"><div class="line">(defun sum-squares (vect)</div><div class="line">  (declare (type (simple-array fixnum *) vect)</div><div class="line">        (inline square) (optimize speed (safety 0)))</div><div class="line">  (let ((sum 0))</div><div class="line">    (declare (fixnum sum))</div><div class="line">    (dotimes (i (length vect))</div><div class="line">      (declare (fixnum i))</div><div class="line">      (incf sum (the fixnum (square (svref vect i)))))))</div><div class="line">    sum))</div></div><!-- fragment --><p>Объявление fixnum позволит компилятору напрямую использовать целочисленную арифметику, а не проверять тип каждого слагаемого. Специальная форма (<code>the fixnum</code> ...) - это обещание, что аргумент является фиксированным числом(fixnum). Объявление <code>(optimize speed (security 0))</code> сообщает компилятору, что функция должна быть как можно быстрее, возможно, за счет снижения безопасности кода (игнорируя типов и т. Д.). Другими величинами, которые можно оптимизировать, являются <code>compilation-speed, space</code>(скорость компиляции, пространство) и только в ANSI Common Lisp <code>debug</code> (простота отладки). Величинам может быть присвоено число от 0 до 3, определяющее, насколько они важны; 3 является важным и используется по умолчанию, если номер не указан.</p>
<p>Объявление (<code>inline square</code>) позволяет компилятору сгенерировать умножение, указанное в <code>square</code>, прямо в цикле, без явного вызова функции square. Компилятор создаст локальную переменную для (<code>svref vect i</code>) и не будет выполнять ссылочные дважды встроенные функции, не имея никаких проблем, связанных с макросами, как описано на <a href="B9780080571157500248.xhtml#p853">страница 853</a>. Однако есть один недостаток: когда вы переопределяете встраиваемую функцию, вам может потребоваться перекомпилировать все функции, которые ее вызывают.</p>
<p>Вы можете объявить функцию <code>inline</code>, когда она короткая, и поэтому накладные расходы на вызов функции будут составлять значительную часть общего времени выполнения. Вы не должны объявлять функцию <code>inline</code>, когда функция является рекурсивной, когда ее определение может измениться или когда определение функции длинное и вызывается из многих мест.</p>
<p>В рассматриваемом примере объявление функции встраиваемой, экономит накладные расходы на вызов функции. В некоторых случаях возможна дальнейшая оптимизация. Рассмотрим предикат <code>starts-with</code>:</p>
<div class="fragment"><div class="line">(defun starts-with (list x)</div><div class="line">  &quot;Is x a list whose first element is x?&quot;</div><div class="line">  (and (consp list) (eql (first list) x)))</div><div class="line">)</div></div><!-- fragment --><p>Предположим, у нас есть такой фрагмент кода:</p>
<div class="fragment"><div class="line">(if (consp list) (starts-with list x) ...)</div></div><!-- fragment --><p>Если <code>start-with</code> объявлен как <code>inline</code>, этот код расширится до:</p>
<div class="fragment"><div class="line">(if (consp list) (and (consp list) (eql (first list) x)) ...)</div></div><!-- fragment --><p>что многие компиляторы упростят до:</p>
<div class="fragment"><div class="line">(if (consp list) (eql (first list) x) ...)</div></div><!-- fragment --><p>Очень немногие компиляторы делают такое упрощение функций без подсказки, предоставляемой <code>inline</code>.</p>
<p>Помимо исключения проверки типов во время выполнения, объявления также позволяют компилятору выбирать наиболее эффективное представление объектов данных. Многие компиляторы поддерживают как <em>упакованные</em>(boxed), так и <em>распакованные</em>(unboxed) представления объектов данных. Упакованное представление содержит достаточно информации, чтобы определить тип объекта. Распакованное представление - это просто "сырые биты", с которыми компьютер может иметь дело напрямую. Рассмотрим следующую функцию, которая используется для очистки массива 1024 x 1024 чисел с плавающей запятой, устанавливая для каждого из них ноль:</p>
<div class="fragment"><div class="line">(defun clear-m-array (array)</div><div class="line">  (declare (optimize (speed 3) (safety 0)))</div><div class="line">  (declare (type (simple-array single-float (1024 1024)) array))</div><div class="line">  (dotimes (i 1024)</div><div class="line">    (dotimes (j 1024)</div><div class="line">      (setf (aref array i j) 0.0))))</div></div><!-- fragment --><p>В Allegro Common Lisp на Sun SPARCstation это компилируется в довольно хороший код, сравнимый с кодом, созданным компилятором C для эквивалентной программы C. Однако, если объявления не указаны, производительность будет примерно в 40 раз хуже.</p>
<p>Проблема в том, что без деклараций небезопасно хранить необработанное представление <code>0.0</code> с плавающей запятой в каждом месте массива. Вместо этого программа должна поместить в упаковку <code>0.0</code>, выделяя память для типизированного указателя на необработанные биты. Это делается внутри вложенных циклов, поэтому в результате каждый вызов версии <code>clear-m-array</code> без объявлений вызывает функцию упаковки floating-point-boxing 1048567 раз, выделяя миллион слов памяти. Излишне говорить, что этого следует избегать.</p>
<p>Не все компиляторы принимают во внимание все объявления; вы должны проверить, прежде чем тратить время на объявления, которые ваш компилятор может игнорировать. Функцию <code>disassemble</code> можно использовать, чтобы показать, во что компилируется функция. Например, рассмотрим тривиальную функцию сложения двух чисел. Вот с декларациями и без:</p>
<div class="fragment"><div class="line">(defun f (x y)</div><div class="line">  (declare (fixnum x y) (optimize (safety 0) (speed 3)))</div><div class="line">  (the fixnum (+ x y)))</div><div class="line">(defun g (x y) (+ x y))</div></div><!-- fragment --><p>Вот дизассемблированный код f из Allegro Common Lisp для процессора Motorola серии 68000:</p>
<div class="fragment"><div class="line">&gt; (disassemble &#39;f)</div><div class="line">;; disassembling #&lt;Function f @ #x83ef79  &gt;</div><div class="line">;; formals: x y</div><div class="line">;; code vector @ #x83ef44</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>link</code> </td><td><code>a6.#0</code> </td></tr>
<tr>
<td><code>4:</code> </td><td><code>move.l</code> </td><td><code>a2,-(a7)</code> </td></tr>
<tr>
<td><code>6:</code> </td><td><code>move.l</code> </td><td><code>a5,-(a7)</code> </td></tr>
<tr>
<td><code>8:</code> </td><td><code>move.l</code> </td><td><code>7(a2),a5</code> </td></tr>
<tr>
<td><code>12:</code> </td><td><code>move.l</code> </td><td><code>8(a6).d4 ; y</code> </td></tr>
<tr>
<td><code>16:</code> </td><td><code>add.l</code> </td><td><code>12(a6),d4 ; x</code> </td></tr>
<tr>
<td><code>20:</code> </td><td><code>move.l</code> </td><td><code>#1,d1</code> </td></tr>
<tr>
<td><code>22:</code> </td><td><code>move.l</code> </td><td><code>-8(a6),a5</code> </td></tr>
<tr>
<td><code>26:</code> </td><td><code>unlk</code> </td><td><code>a6</code> </td></tr>
<tr>
<td><code>28:</code> </td><td><code>rtd</code> </td><td><code>#8</code> </td></tr>
</table>
<p>На первый взгляд это может показаться устрашающим, но вам не нужно быть экспертом в ассемблере 68000, чтобы получить некоторое представление о том, что здесь происходит. Инструкции, помеченные 0-8 (метки в крайнем левом столбце), составляют типичную преамбулу функции для 68000. Они связывают подпрограммы и сохраняют новый объект функции и вектор констант в регистры. Поскольку f не использует констант, инструкции 6, 8 и 22 действительно не нужны и могут быть опущены. Инструкции 0,4 и 26 также можно опустить, если вам не нужно видеть эту функцию в трассировке стека во время отладки. В более поздних версиях компилятора эти инструкции отсутствуют.</p>
<p>В основе функции <code>f</code> лежит последовательность из двух инструкций 12-16. Инструкция 12 извлекает <code>y</code>, а 16 добавляет <code>y</code> к <code>x</code>, оставляя результат в <code>d4</code>, который является регистром <code>результата</code>. Инструкция 20 устанавливает регистр <code>dl</code>, <code>количество возвращаемых значений</code>, в 1.</p>
<p>Сравните это с кодом для <code>g</code>, который не имеет деклараций и компилируется с настройками скорости и безопасности по умолчанию:</p>
<div class="fragment"><div class="line">&gt; (disassemble &#39;g)</div><div class="line">;; disassembling #&lt;Function g @ #x83dbd1  &gt;</div><div class="line">;; formals: x y</div><div class="line">;; code vector @ #x83db64</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>add.l</code> </td><td><code>#8,31(a2)</code> </td><td></td></tr>
<tr>
<td><code>4:</code> </td><td><code>sub.w</code> </td><td><code>#2,dl</code> </td><td></td></tr>
<tr>
<td><code>6:</code> </td><td><code>beq.s</code> </td><td><code>12</code> </td><td></td></tr>
<tr>
<td><code>8:</code> </td><td><code>jmp</code> </td><td><code>16(a4)</code> </td><td><code>; wnaerr</code> </td></tr>
<tr>
<td><code>12:</code> </td><td><code>link</code> </td><td><code>a6,#0</code> </td><td></td></tr>
<tr>
<td><code>16:</code> </td><td><code>move.l</code> </td><td><code>a2,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>18:</code> </td><td><code>move.l</code> </td><td><code>a5,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>20:</code> </td><td><code>move.l</code> </td><td><code>7(a2),a5</code> </td><td></td></tr>
<tr>
<td><code>24:</code> </td><td><code>tst.b</code> </td><td><code>- 208(a4)</code> </td><td><code>; signal-hit</code> </td></tr>
<tr>
<td><code>28</code> </td><td><code>beq.s</code> </td><td><code>34</code> </td><td></td></tr>
<tr>
<td><code>30:</code> </td><td><code>jsr</code> </td><td><code>872(a4)</code> </td><td><code>; process-sig</code> </td></tr>
<tr>
<td><code>34:</code> </td><td><code>move.l</code> </td><td><code>8(a6),d4</code> </td><td><code>; y</code> </td></tr>
<tr>
<td><code>38:</code> </td><td><code>move.l</code> </td><td><code>12(a6),d0</code> </td><td><code>; x</code> </td></tr>
<tr>
<td><code>42:</code> </td><td><code>or.l</code> </td><td><code>d4,d0</code> </td><td></td></tr>
<tr>
<td><code>44:</code> </td><td><code>and.b</code> </td><td><code>#7,d0</code> </td><td></td></tr>
<tr>
<td><code>48:</code> </td><td><code>bne.s</code> </td><td><code>62</code> </td><td></td></tr>
<tr>
<td><code>50:</code> </td><td><code>add.l</code> </td><td><code>12(a6),d4 ;</code> </td><td><code>x</code> </td></tr>
<tr>
<td><code>54:</code> </td><td><code>bvc.s</code> </td><td><code>76</code> </td><td></td></tr>
<tr>
<td><code>56:</code> </td><td><code>jsr</code> </td><td><code>696(a4)</code> </td><td><code>; add-overflow</code> </td></tr>
<tr>
<td><code>60:</code> </td><td><code>bra.s</code> </td><td><code>76</code> </td><td></td></tr>
<tr>
<td><code>62:</code> </td><td><code>move.l</code> </td><td><code>12(a6),-(a7)</code> </td><td><code>; x</code> </td></tr>
<tr>
<td><code>66:</code> </td><td><code>move.l</code> </td><td><code>d4,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>68:</code> </td><td><code>move.l</code> </td><td><code>#2,d1</code> </td><td></td></tr>
<tr>
<td><code>70:</code> </td><td><code>move.l</code> </td><td><code>-304(a4),a0</code> </td><td><code>; + _2op</code> </td></tr>
<tr>
<td><code>74:</code> </td><td><code>jsr</code> </td><td><code>(a4)</code> </td><td></td></tr>
<tr>
<td><code>76:</code> </td><td><code>move.l</code> </td><td><code>#1,d1</code> </td><td></td></tr>
<tr>
<td><code>78:</code> </td><td><code>move.l</code> </td><td><code>-8(a6),a5</code> </td><td></td></tr>
<tr>
<td><code>82:</code> </td><td><code>unlk</code> </td><td><code>a6</code> </td><td></td></tr>
<tr>
<td><code>84:</code> </td><td><code>rtd</code> </td><td><code>#8</code> </td><td></td></tr>
</table>
<p>Посмотрите, сколько еще работы выполняется . Первые четыре инструкции гарантируют, что правильное количество аргументов было передано в <code>g</code>. В противном случае происходит переход к <code>wnaerr</code> (ошибка неправильного числа аргументов). Инструкции 12-20 имеют код загрузки аргумента, который был в 0-8 в <code>f</code>. На 24-30 выполняется проверка на наличие асинхронных сигналов, таких как нажатие пользователем клавиши прерывания. После загрузки <code>x</code> и <code>y</code> выполняется проверка типа (42-48). Если оба аргумента не являются фиксированными числами, то код в инструкциях 62-74 устанавливает вызов <code>+ _2op</code>, который обрабатывает приведение типов и сложение не фиксированных чисел. Если все идет хорошо, нам не нужно вызывать эту процедуру, а вместо этого выполнять сложение по инструкции 50. Но даже в этом случае мы не закончили - просто потому, что два аргумента были фиксированными числами, не означает, что результат будет. Инструкции 54-56 проверяют и при необходимости переходят к процедуре переполнения. Наконец, инструкции 76-84 возвращают окончательное значение, как и в <code>f</code>.</p>
<p>Некоторые некачественные компиляторы вообще игнорируют объявления. Другим компиляторам не нужны определенные объявления, потому что они могут полагаться на специальные инструкции в базовой архитектуре. На Lisp-машине и <code>f</code> и <code>g</code> компилируются в один и тот же код:</p>
<div class="fragment"><div class="line">6 PUSH    ARG|0`   ; X</div><div class="line">7 +       ARG|1`   ; Y</div><div class="line">8 RETURN  PDL-POP</div></div><!-- fragment --><p>В Lisp Machine есть микрокодированная инструкция +, которая одновременно выполняет добавление fixnum и проверяет аргументы, отличные от fixnum, переходя к подпрограмме, если любой из аргументов не является fixnum. Оборудование выполняет ту работу, которую компилятор должен делать на обычном процессоре. Это упрощает компилятор Lisp Machine, поэтому компиляция функции выполняется быстрее. Однако на современных конвейерных компьютерах с кэшем инструкций микрокодирование практически не дает никаких преимуществ. Текущая тенденция - от микрокода к компьютерам с сокращенным набором команд (RISC).</p>
<p>На большинстве компьютеров, скорее всего, будут полезны следующие объявления:</p>
<ul>
<li><code>fixnum и float</code>. Числа, объявленные как фиксированные числа или числа с плавающей запятой, могут обрабатываться непосредственно арифметическими инструкциями хост компьютера. В некоторых системах одного <code>float</code> недостаточно; вы должны сказать <code>single-float</code> или <code>double-float</code>. Другие числовые объявления, вероятно, будут проигнорированы. Например, объявление переменной как целого числа не сильно помогает компилятору, потому что bignums тоже являются целыми числами. Код для добавления bignums слишком сложен, чтобы вставлять его в строку, поэтому компилятор будет переходить к подпрограмме общего назначения (например, <code>+ _2op</code> в Allegro), той же подпрограмме, которую он использовал бы, если бы не было задано никаких объявлений.</li>
<li><code>list и array</code>. Многие системы Lisp предоставляют отдельные функции для версий списка и массива часто используемых функций работы с последовательностями. Например, <code>(delete x (the list 1))</code> компилируется в <code>(sys:delete-list-eql x 1)</code> на Lisp Machine TI Explorer. Другая функция, <code>sys:delete-vector</code>, используется для массивов, а обобщенная функция <code>delete</code> используется только тогда, когда компилятор не может определить тип последовательности. Поэтому, если вы знаете, что аргументом обобщенной функции является либо <code>список</code>, либо <code>массив</code>, объявите его как таковой.</li>
<li><code>simple-vector и simple-array</code> Простые векторы и массивы - это те, которые не имеют общей структуры с другими массивами, не имеют указателей заполнения и не регулируются(not adjustable). Во многих реализациях aref для <code>simple-vector</code> быстрее, чем для <code>vector</code>. И он, безусловно, намного быстрее, чем взятие <code>elt</code> последовательности неизвестного типа. Объявите свои массивы простыми(simple) (если они действительно таковы).</li>
<li><code>(array *type*)</code>. Часто бывает важно определить тип элементов массива. Например, <code>(array short-float)</code> может занимать только половину хранилища общего массива, и такое объявление обычно позволяет выполнять вычисления с использованием собственных инструкций ЦП с плавающей запятой вместо преобразования <code>в</code> и <code>из</code> Представление чисел с плавающей запятой в Common Lisp. Это очень важно, потому что преобразование обычно требует выделения памяти, а прямое вычисление - нет. Спецификаторы <code>(simple-array *type*)</code> и <code>(vector *type*)</code> должны использоваться вместо <code>(array *type*)</code>, когда это применимо. Очень распространенной ошибкой является объявление <code>(simple-vector *type*)</code>. Это ошибка, потому что Common Lisp ожидает <code>(simple-vector *size*)</code> - не спрашивайте меня, почему.</li>
<li><code>(array **dimensions*)</code>. Полная форма спецификатора типа массива или <code>simple-array</code> это <code>(array *type dimensions*)</code>. Так, например, <code>(array bit (* *))</code> представляет собой двумерный битовый массив, а <code>(array bit (1024 1024))</code> представляет собой массив размером 1024 x 1024 бит. Очень важно указать количество измерений, когда оно известно, и менее важно указать точный размер, хотя для многомерных массивов объявление размера более важно. Формат спецификатора векторного типа - <code>(vector *type size*)</code>.</li>
</ul>
<p>Обратите внимание, что некоторые из этих объявлений могут применяться одновременно. Например, в</p>
<div class="fragment"><div class="line">(position # \ . (the simple-string file-name))</div></div><!-- fragment --><p>переменная <code>filename</code> была объявлена как вектор, простой массив и последовательность типа <code>string-char</code>. Все три обявления полезны. Тип <code>simple-string</code> - это сокращение от <code>(simple-array string-char)</code>.</p>
<p>Это руководство применимо к большинству систем Common Lisp, но вам следует заглянуть в примечания по реализации для вашей конкретной системы, чтобы получить больше советов о том, как настроить ваш код.</p>
<h2>10.2 Избегайте Обобщенных Функций</h2>
<p>Common Lisp предоставляет функции с большой обобщенностью, но кто-то должен заплатить за эту обобщенность. Например, если вы напишете <code>(elt x 0)</code>, разные машинные инструкции будут выполняться в зависимости от того, является ли x списком, строкой или вектором. Без деклараций, проверки придется проводить во время выполнения. Вы можете либо предоставить объявления(декларации), как в <code>(elt (the list x) 0)</code>, либо использовать более конкретную(специализированную) функцию, такую как <code>(first x)</code> в случае списков, <code>(char x 0)</code> для строк , <code>(aref x 0)</code> для векторов и <code>(svref x 0)</code> для простых векторов. Конечно, обобщенные функции полезны - я написал <code>random-elt</code>, как показано ниже, для работы со списками, тогда как вместо этого я мог бы написать более эффективный <code>random-mem</code>. Выбор окупился, когда <code>Я</code> захотел, чтобы функция выбирала случайный символ из строки - <code>random-elt</code> выполняет свою работу без изменений, а <code>random-mem</code> - нет.</p>
<div class="fragment"><div class="line">(defun random-elt (s) (elt s (random (length s))))</div><div class="line">(defun random-mem (l) (nth (random (length (the list l))) l))</div></div><!-- fragment --><p>Этот пример был простым, но в более сложных случаях вы можете сделать свои функции работы с последовательностями более эффективными, если они будут явно проверять, являются ли их аргументы списками или векторами. См. Определение <code>map-into</code> на <a href="B9780080571157500248.xhtml#p857">страница 857</a>.</p>
<h2>10.3 Избегайте сложных списков аргументов</h2>
<p>Функции с аргументами ключевыми словами несут большие накладные расходы. Это также может быть верно для необязательных аргументов и аргументов <code>rest</code>, хотя обычно в меньшей степени. Давайте посмотрим на несколько простых примеров:</p>
<div class="fragment"><div class="line">(defun reg (a b c d) (list a b c d))</div><div class="line">(defun rst (abc &amp;rest d) (list* a b c d))</div><div class="line">(defun opt (&amp;optional a b (c 1) (d (sqrt a))) (list a b c d))</div><div class="line">(defun key (&amp;key a b (c 1) (d (sqrt a))) (list a b c d))</div></div><!-- fragment --><p>Мы можем видеть, во что они компилируются для TI Explorer, но помните, что ваш компилятор может быть совершенно другим.</p>
<p><code>&gt; (disassemble 'reg)</code></p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>8 PUSH</code> </td><td><code>ARG &lt;td&gt; 0</code> </td><td><code>; A</code> </td></tr>
<tr>
<td><code>9 PUSH</code> </td><td><code>ARG &lt;td&gt; 1</code> </td><td><code>; B</code> </td></tr>
<tr>
<td><code>10 PUSH</code> </td><td><code>ARG &lt;td&gt; 2</code> </td><td><code>; C</code> </td></tr>
<tr>
<td><code>11 PUSH</code> </td><td><code>ARG &lt;td&gt; 3</code> </td><td><code>; D</code> </td></tr>
<tr>
<td><code>12 TAIL-REC CALL-4</code> </td><td><code>FEF &lt;td&gt; 3</code> </td><td><code>; #'LIST</code> </td></tr>
</table>
<p><code>&gt; (disassemble 'rst)</code></p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>8 PUSH</code> </td><td><code>ARG &lt;td&gt; 0</code> </td><td><code>; A</code> </td></tr>
<tr>
<td><code>9 PUSH</code> </td><td><code>ARG &lt;td&gt; 1</code> </td><td><code>; B</code> </td></tr>
<tr>
<td><code>10 PUSH</code> </td><td><code>ARG &lt;td&gt; 2</code> </td><td><code>; C</code> </td></tr>
<tr>
<td><code>11 PUSH</code> </td><td><code>LOCAL &lt;td&gt; 0</code> </td><td><code>; D</code> </td></tr>
<tr>
<td><code>12 RETURN CALL-4</code> </td><td><code>FEF &lt;td&gt; 3</code> </td><td><code>; #'LIST*</code> </td></tr>
</table>
<p>При использовании обычного списка аргументов мы просто помещаем четыре переменные в стек аргументов и переходим к вызову функции list. (<a href="B9780080571157500224.xhtml">Глава 22</a> объясняет, почему хвосто-рекурсивный вызов является просто оператором ветвления.)</p>
<p>С аргументом rest все почти так же просто. Оказывается, на этой машине микрокод для вызывающей последовательности автоматически обрабатывает аргументы rest, сохраняя их в локальной переменной 0. Сравним с кодом использующим необязательные аргументамы:</p>
<div class="fragment"><div class="line">(defun opt (&amp;optional a b (c 1) (d (sqrt a))) (list a b c d))</div><div class="line">  &gt; (disassemble &#39;opt)</div></div><!-- fragment --><div class="fragment"><div class="line">24 DISPATCH        FEF|5 ; [0=&gt;25;1=&gt;25;2=&gt;25;3=&gt;27;ELSE=&gt;30]</div><div class="line">25 PUSH-NUMBER     1               </div><div class="line">26 POP             ARG|2 ; C     </div><div class="line">27 PUSH            ARG|0 ; A     </div><div class="line">28 PUSH CALL-1     FEF|3 ; #&#39;SQRT</div><div class="line">29 POP             ARG|3 ; D     </div><div class="line">30 PUSH            ARG|0 ; A     </div><div class="line">31 PUSH            ARG|1 ; B     </div><div class="line">32 PUSH            ARG|2 ; C     </div><div class="line">33 PUSH            ARG|3 ; D     </div><div class="line">34 TAIL-REC CALL-4 FEF|4 ; #&#39;LIST</div></div><!-- fragment --><p>Хотя этот язык ассемблера может быть труднее читать, оказывается, что необязательные аргументы обрабатываются очень эффективно. Вызывающая последовательность хранит количество необязательных аргументов наверху стека, а инструкция DISPATCH использует это для индексации в таблице, хранящейся в ячейке <code>FEF|5</code> (смещение на пять слов от начала функции). В результате в одной инструкции функция переходит в нужное место для инициализации любых неуказанных аргументов. Таким образом, функция с предоставленными необязательными аргументами принимает только на одну инструкцию (отправку/dispatch) больше, чем в "обычном" случае. К сожалению, аргументы ключевых слов так не работают:</p>
<div class="fragment"><div class="line">(defun key (&amp;key a b` (`c 1`) `(d (sqrt a))) (list a b c d))</div><div class="line">  &gt; (disassemble &#39;key)</div></div><!-- fragment --><div class="fragment"><div class="line">14 PUSH-NUMBER                1                             </div><div class="line">15 POP                        LOCAL|3 ; C                  </div><div class="line">16 PUSH                       FEF|3   ; SYS:-.KEYWORD-GARBAGE</div><div class="line">17 POP                        LOCAL|4                        </div><div class="line">18 TEST                       LOCAL|0</div><div class="line">19 BR-NULL                    24</div><div class="line">20 PUSH                       FEF|4   ; &#39;(:A :B :C :D)</div><div class="line">21 SET-NIL                    PDL-PUSH</div><div class="line">22 PUSH-LOC                   LOCAL|1 ; A</div><div class="line">23 (AUX) %STORE-KEY-WORD-ARGS             </div><div class="line">24 PUSH                       LOCAL|1 ; A</div><div class="line">25 PUSH                       LOCAL|2 ; B</div><div class="line">26 PUSH                       LOCAL|3 ; C</div><div class="line">27 PUSH                       |4         </div><div class="line">28 EQ                         FEF|3   ; SYS::KEYWORD-GARBAGE</div><div class="line">29 BR-NULL                    33                            </div><div class="line">30 PUSH                       LOCAL|1 ; A</div><div class="line">31 PUSH CALL-1                FEF|5   ; #&#39;SQRT</div><div class="line">32 RETURN CALL-4              FEF|6   ; #&#39;LIST</div><div class="line">33 PUSH                       LOCAL|4</div><div class="line">34 RETURN CALL-4              FEF|6   ; #&#39;LIST</div></div><!-- fragment --><p>Не важно уметь читать весь этот ассемблер. Дело в том, что существуют значительные накладные расходы, даже несмотря на то, что в этой архитектуре есть специальная инструкция <code>(STORE-KEY-WORD-ARGS)</code> для помощи при работе с аргументами ключевыми словами.</p>
<p>Теперь давайте посмотрим на результаты на другой системе, компиляторе Allegro для 68000. Во-первых, вот ассемблерный код для reg, чтобы дать вам представление о минимальной последовательности вызовов: <a href="# fn0015">1</a></p>
<div class="fragment"><div class="line">&gt; (disassemble &#39;reg)</div><div class="line">;; disassembling #&lt;Function reg @ #x83db59  &gt;</div><div class="line">;; formals: a b c d</div><div class="line">;; code vector @ #x83dblc</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>link</code> </td><td><code>a6,#0</code> </td><td></td></tr>
<tr>
<td><code>4:</code> </td><td><code>move.l</code> </td><td><code>a2,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>6:</code> </td><td><code>move.l</code> </td><td><code>a5,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>8:</code> </td><td><code>move.l</code> </td><td><code>7(a2),a5</code> </td><td></td></tr>
<tr>
<td><code>12:</code> </td><td><code>move.l</code> </td><td><code>20(a6),-(a7)</code> </td><td><code>; a</code> </td></tr>
<tr>
<td><code>16:</code> </td><td><code>move.l</code> </td><td><code>16(a6).-(a7)</code> </td><td><code>; b</code> </td></tr>
<tr>
<td><code>20:</code> </td><td><code>move.l</code> </td><td><code>12(a6),-(a7)</code> </td><td><code>; c</code> </td></tr>
<tr>
<td><code>24:</code> </td><td><code>move.l</code> </td><td><code>8(a6),-(a7)</code> </td><td><code>; d</code> </td></tr>
<tr>
<td><code>28:</code> </td><td><code>move.l</code> </td><td><code>#4,dl</code> </td><td></td></tr>
<tr>
<td><code>30:</code> </td><td><code>jsr</code> </td><td><code>848(a4)</code> </td><td><code>; list</code> </td></tr>
<tr>
<td><code>34:</code> </td><td><code>move.l</code> </td><td><code>- 8(a6),a5</code> </td><td></td></tr>
<tr>
<td><code>38:</code> </td><td><code>unlk</code> </td><td><code>a6</code> </td><td></td></tr>
<tr>
<td><code>40:</code> </td><td><code>rtd</code> </td><td><code>#10</code> </td><td></td></tr>
</table>
<p>Теперь мы видим, что аргументы <code>&amp;rest</code> занимают намного больше кода в этой системе:</p>
<div class="fragment"><div class="line">&gt; (disassemble &#39;rst)</div><div class="line">;; disassembling #&lt;Function rst @ #x83de89  &gt;</div><div class="line">;; formals: a b c &amp;rest d</div><div class="line">code vector @ #x83de34</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>sub.w</code> </td><td><code>#3,dl</code> </td><td></td></tr>
<tr>
<td><code>2:</code> </td><td><code>bge.s</code> </td><td><code>8</code> </td><td></td></tr>
<tr>
<td><code>4:</code> </td><td><code>jmp</code> </td><td><code>16(a4)</code> </td><td><code>; wnaerr</code> </td></tr>
<tr>
<td><code>8:</code> </td><td><code>move.l</code> </td><td><code>(a7)+,al</code> </td><td></td></tr>
<tr>
<td><code>10</code>: </td><td><code>move.l</code> </td><td><code>d3,-(a7)</code> </td><td><code>; nil</code> </td></tr>
<tr>
<td><code>12</code>: </td><td><code>sub.w</code> </td><td><code>#l,dl</code> </td><td></td></tr>
<tr>
<td><code>14:</code> </td><td><code>bit.s</code> </td><td><code>38</code> </td><td></td></tr>
<tr>
<td><code>16:</code> </td><td><code>move.l</code> </td><td><code>al, - 52(a4)</code> </td><td><code>; c_protected-retaddr</code> </td></tr>
<tr>
<td><code>20:</code> </td><td><code>jsr</code> </td><td><code>40(a4)</code> </td><td><code>; cons</code> </td></tr>
<tr>
<td><code>24:</code> </td><td><code>move.l</code> </td><td><code>d4,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>26:</code> </td><td><code>dbra</code> </td><td><code>dl,20</code> </td><td></td></tr>
<tr>
<td><code>30:</code> </td><td><code>move.l</code> </td><td><code>- 52(a4),al</code> </td><td><code>; c_protected-retaddr</code> </td></tr>
<tr>
<td><code>34:</code> </td><td><code>clr.l</code> </td><td><code>- 52(a4)</code> </td><td><code>; c_protected-retaddr</code> </td></tr>
<tr>
<td><code>38:</code> </td><td><code>move.l</code> </td><td><code>al,</code> </td><td><code>-(a7)</code> </td></tr>
<tr>
<td><code>40:</code> </td><td><code>link</code> </td><td><code>a6,#0</code> </td><td></td></tr>
<tr>
<td><code>44:</code> </td><td><code>move.l</code> </td><td><code>a2,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>46:</code> </td><td><code>move.l</code> </td><td><code>a5,-(a7)</code> </td><td></td></tr>
<tr>
<td><code>48:</code> </td><td><code>move.l</code> </td><td><code>7(a2),a5</code> </td><td></td></tr>
<tr>
<td><code>52:</code> </td><td><code>move.l</code> </td><td><code>- 332(a4),a0</code> </td><td><code>; list*</code> </td></tr>
<tr>
<td><code>56:</code> </td><td><code>move.l</code> </td><td><code>- 8(a6),a5</code> </td><td></td></tr>
<tr>
<td><code>60:</code> </td><td><code>unlk</code> </td><td><code>a6</code> </td><td></td></tr>
<tr>
<td><code>62</code>: </td><td><code>move.l</code> </td><td><code>#4,dl</code> </td><td></td></tr>
<tr>
<td><code>64</code> </td><td><code>jmp</code> </td><td><code>(a4)</code> </td><td></td></tr>
</table>
<p>Цикл от 20 до 26 строит список <code>&amp;rest</code> по одному cons за раз. Частично сложность состоит в том, что cons-ы могут инициировать сборку мусора в любое время, поэтому список должен быть построен в месте, о котором сборщик мусора будет знать. Функция с необязательными аргументами еще хуже, она принимает 34 инструкции (104 байта), а ключевые слова хуже всего, занимая 71 инструкцию (178 байтов) и включает цикл. Накладные расходы для необязательных аргументов пропорциональны количеству необязательных аргументов, в то время как для ключевых слов они пропорциональны произведению количества разрешенных параметров и количества фактически предоставленных аргументов.</p>
<p>Хорошим руководящим принципом для подражания является использование аргументов ключевого слова в первую очередь как интерфейс для редко используемых функций и предоставление версий этих функций без ключевых слов, которые можно использовать в местах, где важна эффективность. Рассмотрим:</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline key))</div><div class="line">(defun key (&amp;key a b (c 1) (d (sqrt a))) (*no-key a b c d))</div><div class="line">(defun *no-key (a b c d) (list a b c d))</div></div><!-- fragment --><p>Здесь функция <code>key</code> используется как интерфейс к функции <code>no-key</code>, которая выполняет реальную работу. Объявление inline должно позволить компилятору скомпилировать вызов <code>key</code> как вызов <code>no-key</code> с соответствующими аргументами:</p>
<div class="fragment"><div class="line">&gt; (disassemble #&#39;(lambda (x y) (key :b x :a y)))</div></div><!-- fragment --><div class="fragment"><div class="line">10 PUSH            ARG|1 ; Y</div><div class="line">11 PUSH            ARG|0 ; X</div><div class="line">12 PUSH-NUMBER     1        </div><div class="line">13 PUSH            ARG|1 ; Y</div><div class="line">14 PUSH CALL-1     FEF|3 ; #&#39;SORT</div><div class="line">15 TAIL-REC CALL-4 FEF|4 ; #&#39;NO-KEY</div></div><!-- fragment --><p>Накладные расходы возникают только тогда, когда ключевые слова неизвестны во время компиляции. В следующем примере компилятор вынужден вызывать <code>key</code>, а не <code>no-key</code>, потому что он не знает, каким будет ключевое слово <code>k</code> во время выполнения:</p>
<div class="fragment"><div class="line">&gt; (disassemble #&#39;(lambda (k x y) (key k x :a y)))</div></div><!-- fragment --><div class="fragment"><div class="line">10 PUSH             ARG|0  ; K     </div><div class="line">11 PUSH             ARG|1  ; X     </div><div class="line">12 PUSH             FEF|3  ; &#39;:A   </div><div class="line">13 PUSH             ARG|2  ; Y     </div><div class="line">14 TAIL-REC CALL-4  FEF|4  ; #&#39;KEY </div></div><!-- fragment --><p>Конечно, в этом простом примере я мог бы заменить <code>no-key</code> на <code>list</code>, но в целом это будет более сложная обработка. Если бы я также объявил <code>inline</code> <code>no-key</code>, то получил бы следующее:</p>
<div class="fragment"><div class="line">&gt; (disassemble #&#39;(lambda (x y) (key :b x :a y)))</div></div><!-- fragment --><div class="fragment"><div class="line">10 PUSH             ARG|1  ; Y</div><div class="line">11 PUSH             ARG|0  ; X</div><div class="line">12 PUSH-NUMBER      1         </div><div class="line">13 PUSH             ARG|1  ; Y</div><div class="line">14 PUSH CALL-1      FEF|3  ; #&#39;SORT</div><div class="line">15 TAIL-REC CALL-4  FEF|4  ; #&#39;LIST</div></div><!-- fragment --><p>Если хотите, вы можете определить макрос для автоматического определения интерфейса функции без ключевых слов:</p>
<div class="fragment"><div class="line">(defmacro defun* (fn-name arg-list &amp;rest body)</div></div><!-- fragment --><p><code>"Define two functions. one an interface to a &amp;keyword-less</code></p>
<p><code>version. Proclaim the interface function inline."</code></p>
<div class="fragment"><div class="line">  (if (and (member &#39;&amp;key arg-list)</div><div class="line">        (not (member &#39;&amp;rest arg-list)))</div><div class="line">      (let ((no-key-fn-name (symbol fn-name &#39;*no-key))</div><div class="line">        (args (mapcar #&#39;first-or-self</div><div class="line">              (set-difference</div><div class="line">                arg-list</div><div class="line">                lambda-list-keywords))))</div><div class="line">      &#39;(progn</div><div class="line">        (proclaim &#39;(inline ,fn-name))</div><div class="line">        (defun ,no-key-fn-name ,args</div><div class="line">          .,body)</div><div class="line">        (defun ,fn-name ,arg-list</div><div class="line">          (,no-key-fn-name .,args))))</div><div class="line">    &#39;(defun ,fn-name ,arg-list</div><div class="line">      .,body)))</div><div class="line">&gt;(macroexpand &#39;(defun* key (&amp;key a b (c 1) (d (sqrt a)))</div><div class="line">            (list a b c d)))</div><div class="line">(PROGN (PROCLAIM &#39;(INLINE KEY))</div><div class="line">    (DEFUN KEY*NO-KEY (A B C D) (LIST A B C D))</div><div class="line">    (DEFUN KEY (&amp;KEY A B (C 1) (D (SQRT A)))</div><div class="line">      (KEY*NO-KEY A B C D)))</div><div class="line">&gt;(macroexpand &#39;(defun* reg (a b c d) (list a b c d)))</div><div class="line">(DEFUN REG (A B C D) (LIST A B C D))</div></div><!-- fragment --><p>У этого подхода есть один недостаток: пользователь, который хочет объявить key встроенной или не встроенной, не получит ожидаемого результата. Пользователь должен знать, что key реализован с помощью <code>key*no-key</code>, и объявить <code>key*no-key</code> встроенной.</p>
<p>Альтернативой является просто объявить функцию, использующую <code>&amp;key</code>, встроенной. Роб Маклахлан приводит пример. В CMU Lisp функция <code>member</code> имеет следующее определение, объявленное встроенным:</p>
<div class="fragment"><div class="line">(defun member (item list &amp;key (key #&#39;identity)</div><div class="line">                (test #&#39;eql testp)(test-not nil notp))</div><div class="line">  (do ((list list (cdr list)))</div><div class="line">      ((null list) nil)</div><div class="line">    (let ((car (car list)))</div><div class="line">      (if (cond</div><div class="line">        (testp</div><div class="line">          (funcall test item</div><div class="line">                (funcall key car)))</div><div class="line">        (notp</div><div class="line">          (not</div><div class="line">      (funcall test-not item</div><div class="line">            (funcall key car))))</div><div class="line">    (t</div><div class="line">      (funcall test item</div><div class="line">            (funcall key car))))</div><div class="line">  (return list)))))</div></div><!-- fragment --><p>Вызов вида <code>(member</code> <a href="B9780080571157500017.xhtml">ch 1</a><code>:key #'first-letter :test #'char =)</code> заменяется эквивалентом следующего кода. К сожалению, не все компиляторы настолько умны с объявлениями inline.</p>
<div class="fragment"><div class="line">(do ((list list (cdr list)))</div><div class="line">      ((null list) nil)</div><div class="line">    (let ((car (car list)))</div><div class="line">      (if (char  = ch (first-letter car))</div><div class="line">        (return list))))</div></div><!-- fragment --><p>Эта глава посвящена эффективности и поэтому выступает против использования параметра ключевого слова в часто используемых функциях. Но если принять во внимание сопровождаемость, параметры ключевых слов выглядят предпочтительнее. Когда программа разрабатывается, и неясно, потребуются ли функции в конечном итоге дополнительные аргументы, параметры ключевых слов могут быть лучшим выбором.</p>
<p>10.4 Избегайте ненужного Consing(а)/построения временных списков</p>
<p>Может показаться, что функция <code>cons</code> выполняется довольно быстро, но, как и все функции, выделяющие новое хранилище, она имеет скрытую стоимость. Когда используется большой объем хранилища, в конечном итоге системе приходится тратить время на сборку мусора. Мы не упоминали об этом ранее, но на самом деле есть два важных показателя объема пространства, потребляемого программой: объем выделенного хранилища и объем используемого хранилища. Разница в том, что хранилище используется временно, но в конечном итоге освобождается. Lisp гарантирует, что неиспользуемое пространство в конечном итоге будет возвращено сборщиком мусора. Это происходит автоматически - программисту нет необходимости и он не может явно освобождать память. Проблема в том, что эффективность сборки мусора может сильно различаться. Сборка мусора особенно тревожна для систем реального времени, потому что это может произойти в любое время.</p>
<p>Противоядие от проблем с мусором - избегать ненужного копирования объектов в часто используемом коде. Попробуйте использовать деструктивные операции, такие как <code>nreverse, delete</code> и <code>nconc</code>, а не их неразрушающие аналоги (например, reverse, remove и append), когда это безопасно. Или используйте векторы вместо списков и повторно используйте значения, а не создавайте копии. Как обычно, такое повышение эффективности может привести к ошибкам, которые может быть трудно отладить. Однако наиболее распространенный вид ненужного копирования можно устранить простой реорганизацией вашего кода. Рассмотрим следующую версию <code>flatten</code>, которая возвращает список всех атомов во входных данных, сохраняя порядок. В отличие от версии в <a href="B9780080571157500054.xhtml">главе 5</a>, эта версия возвращает единственный список атомов без встроенных списков.</p>
<div class="fragment"><div class="line">(defun flatten (input)</div><div class="line">  &quot;Return a flat list of the atoms in the input.</div><div class="line">  Ex: (flatten &#39;((a) (b (c) d))) =&gt; (a b c d).&quot;</div><div class="line">  (cond ((null input) nil)</div><div class="line">      ((atom input) (list input))</div><div class="line">      (t (append (flatten (first input))</div><div class="line">            (flatten (rest input))))))</div></div><!-- fragment --><p>Это определение довольно простое, и нетрудно убедиться в его правильности. Однако каждый вызов <code>append</code> требует копирования первого аргумента, поэтому эта версия может cons(создавать) <em>O</em>(<em>n*2) ячеек при входе с *n</em> атомами. Проблема с этим подходом заключается в том, что он вычисляет список атомов в <code>first</code> и <code>rest</code> каждого подкомпонента ввода. Но подсписок <code>first</code> сам по себе не является частью окончательного ответа, поэтому мы должны вызвать <code>append</code>. Мы могли бы избежать генерации мусора, заменив <code>append</code> на <code>nconc</code>, но даже тогда мы все равно будем терять время. , потому что <code>nconc</code> придется сканировать каждый подсписок, чтобы найти его конец.</p>
<p>В приведенной ниже версии используется <em>аккумулятор</em> для отслеживания атомов, которые были собраны в rest, и для добавления атомов в <code>first</code> по одному с помощью cons, вместо того, чтобы создавать ненужные подсписки и добавлять их. Таким образом, не создается мусор, и ни один из подкомпонентов не проходится более одного раза.</p>
<div class="fragment"><div class="line">(defun flatten (input &amp;optional accumulator)</div><div class="line">  &quot;Return a flat list of the atoms in the input.</div><div class="line">  Ex: (flatten &#39;((a) (b (c) d))) =&gt; (a b c d).&quot;</div><div class="line">  (cond ((null input) accumulator)</div><div class="line">      ((atom input) (cons input accumulator))</div><div class="line">      (t (flatten (first input)</div><div class="line">            (flatten (rest input) accumulator)))))</div></div><!-- fragment --><p>Версия с аккумулятором может быть немного сложнее для понимания, но она намного эффективнее оригинальной версии. Опытные программисты на Лиспе достаточно хорошо умеют заменять вызовы <code>append</code> на аккумуляторы.</p>
<p>Некоторые из ранних машин Lisp имели ненадежную сборку мусора, поэтому пользователи просто отключили сборку мусора, использовали машину в течение нескольких дней и перезагружали, когда им не хватало места. Для большой системы виртуальной памяти это осуществимый подход, потому что виртуальная память - дешевый ресурс. Проблема в том, что реальная память по-прежнему является дорогим ресурсом. Когда каждая страница содержит в основном мусор и мало данных в реальном времени, система будет тратить много времени на подкачку и выгрузку данных. Алгоритмы сжатия мусора могут перемещать живые данные, упаковывая их на минимальное количество страниц.</p>
<p>Некоторые алгоритмы сборки мусора были оптимизированы, чтобы особенно хорошо справляться именно с этим случаем. Если в вашей системе есть <em>ephemeral</em> или <em>generational</em> сборщик мусора, вам не нужно так беспокоиться о недолговечных объектах. Вместо этого проблемы будут вызывать предметы среднего возраста. Другая проблема с такими системами возникает, когда объект в старом поколении изменяется, чтобы указывать на объект в новом поколении. Этого следует избегать, и может оказаться, что в таких случаях reverse на самом деле быстрее, чем nreverse. Чтобы решить, что лучше всего работает в вашей конкретной системе, разработайте несколько тестовых примеров и определите время их выполнения.</p>
<p>В качестве примера эффективного использования хранилища приведем версию <code>pat-match</code>, которая устраняет (почти) все consing. В исходной версии <code>pat-match</code>, используемой в ELIZA (<a href="B9780080571157500066.xhtml#p180">страница 180</a>), для представления списка привязки использовался список ассоциаций пар переменная/значение. В этой версии используются две последовательности: последовательность переменных и последовательность значений. Последовательности реализованы как векторы, а не списки. Как правило, векторы занимают вдвое меньше места, чем списки, для хранения той же информации, поскольку половина каждого списка просто указывает на следующий элемент.</p>
<p>В этом случае экономия намного больше, чем половина. Вместо того, чтобы создавать небольшие списки привязки для каждого частичного совпадения и добавлять к ним, когда совпадение расширяется, мы выделим достаточно большой вектор переменных и значений только один раз и будем использовать их снова и снова для каждого частичного совпадения и даже для каждого вызов <code>pat-match</code>. Для этого нам нужно знать, сколько переменных мы в настоящее время используем. Мы могли бы инициализировать счетчик переменных нулем и увеличивать его каждый раз, когда мы находим новую переменную в образце. Единственная трудность возникает, когда переменная счетчика превышает размер вектора. Мы могли бы просто отказаться и напечатать сообщение об ошибке, но есть более удобные альтернативы. Например, мы могли бы выделить больший вектор для переменных, скопировать существующие, а затем добавить новый.</p>
<p>Когда вектор создан, ему может быть присвоен <em>указатель заполнения</em>/*fill pointer*. Это переменная счетчик, но она концептуально хранится внутри вектора. Векторы с указателями заполнения действуют как нечто среднее между вектором и стеком. Вы можете помещать новые элементы в стек с помощью функций <code>vector-push</code> или <code>vector-push-extend</code>. Последний автоматически выделит больший вектор и при необходимости скопирует элементы. Вы можете удалить элементы с помощью <code>vector-pop</code>, или вы можете явно посмотреть на указатель заполнения с помощью <code>fill-pointer</code>, или изменить его с помощью <code>setf</code>. Вот несколько примеров (с <code>*print-array*</code>, установленным в t, чтобы мы могли видеть результаты):</p>
<p><code>&gt; (setf a (make-array 5 :fill-pointer 0))</code>=&gt; <code>#()</code></p>
<p><code>&gt; (vector-push 1 a)</code>=&gt; <code>0</code></p>
<p><code>&gt; (vector-push 2 a)</code>=&gt; <code>1</code></p>
<p><code>&gt; a</code>=&gt; <code>#(1 2)</code></p>
<p><code>&gt; (vector-pop a)</code>=&gt; <code>2</code></p>
<p><code>&gt; a</code>=&gt; <code>#(1)</code></p>
<p><code>&gt; (dotimes (i 10) (vector-push-extend 'x a))</code>=&gt; <code>NIL</code></p>
<p><code>&gt; a</code>=&gt; <code>#(1 XXXXXXXXXX)</code></p>
<p><code>&gt; (fill- pointer a)</code>=&gt; <code>11</code></p>
<p><code>&gt; (setf (fill-pointer a) 1)</code>=&gt; <code>1</code></p>
<p><code>&gt; a</code>=&gt; <code>#(1)</code></p>
<p><code>&gt; (find 'x a)</code>=&gt; <code>NIL NIL ;</code>*FIND can't find past the fill pointer*</p>
<p><code>&gt; (aref a 2)</code>=&gt; <code>X</code> ; <em>But AREF can see beyond the fill pointer</em></p>
<p>При использовании векторов с указателями заполнения в <code>pat-match</code> общее хранилище для списков привязки вдвое превышает количество переменных в самом большом образце. Я произвольно выбрал 10 в качестве максимального количества переменных, но даже это не является жестким пределом, потому что <code>vector-push-extend</code> может увеличить его. В любом случае, общий объем хранилища невелик, фиксирован по размеру и амортизируется по всем вызовам <code>pat-match</code>. Это только те функции, которые указывают на ответственное использование хранилища.</p>
<p>Однако при таком подходе есть серьезная опасность: с возвращаемым значением нужно обращаться осторожно. Новый <code>pat-match</code> возвращает значение <code>success</code>, когда она находит совпадение. <code>success</code> связан с cons переменных и векторов значений. Вызывающая процедура может свободно ими манипулировать, но только до следующего вызова <code>pat-match</code>. В это время содержимое двух векторов может измениться. Следовательно, если какой-либо вызывающей функции необходимо сохранить возвращаемое значение после другого вызова <code>pat-match</code>, она должна сделать копию возвращенного значения. Так что было бы не совсем правильно говорить, что эта версия <code>pat-match</code> устраняет все недоразумения. Она будет работать, когда в <code>vector-push-extend</code> закончится место или когда пользователю нужно сделать копию возвращенного значения.</p>
<p>Вот новое определение <code>pat-match</code>. Оно реализовано путем закрытия определения <code>pat-match</code> и двух его вспомогательных функций внутри <code>let</code>, которое устанавливает привязки <code>vars, vals</code> и <code>success</code> , но это не принципиально. Вместо этого эти три переменные могли быть реализованы как глобальные переменные. Обратите внимание, что она не поддерживает сегментные переменные или какие-либо другие опции, реализованные в <code>pat-match</code> <a href="B9780080571157500066.xhtml">глава 6</a>.</p>
<div class="fragment"><div class="line">(let* ((vars (make-array 10 :fill-pointer 0 :adjustable t))</div><div class="line">      (vals (make-array 10 :fill-pointer 0 :adjustable t))</div><div class="line">      (success (cons vars vals)))</div><div class="line">(defun efficient-pat-match (pattern input)</div><div class="line">  &quot;Match pattern against input.&quot;</div><div class="line">  (setf (fill-pointer vars) 0)</div><div class="line">  (setf (fill-pointer vals) 0)</div><div class="line">  (pat-match-1 pattern input))</div><div class="line">(defun pat-match-1 (pattern input)</div><div class="line">  (cond ((variable-p pattern) (match-var pattern input))</div><div class="line">      ((eql pattern input) success)</div><div class="line">      ((and (consp pattern) (consp input))</div><div class="line">        (and (pat-match-1 (first pattern) (first input))</div><div class="line">            (pat-match-1 (rest pattern) (rest input))))</div><div class="line">      (t fail)))</div><div class="line">(defun match-var (var input)</div><div class="line">  &quot;Match a single variable against input.&quot;</div><div class="line">  (let ((i (position var vars)))</div><div class="line">    (cond ((null i)</div><div class="line">          (vector-push-extend var vars)</div><div class="line">          (vector-push-extend input vals) success)</div><div class="line">      ((equal input (aref vals i)) success)</div><div class="line">      (t fail)))))</div></div><!-- fragment --><p>Пример её использования:</p>
<div class="fragment"><div class="line">&gt;(efficient-pat-match &#39;(?x + ?x = ?y . ?z)</div><div class="line">                &#39;(2 + 2 = (3 + 1) is true))</div><div class="line">(#(?X ?Y ?Z) . #(2 (3 + 1) (IS TRUE)))</div></div><!-- fragment --><p>Расширяемые векторы с указателями заполнения удобны и намного более эффективны, чем составление списков. Однако их использование связано с некоторыми накладными расходами, и для тех частей кода, которые должны быть наиболее эффективными, лучше всего придерживаться простых векторов. Следующая версия <code>effective-pat-match</code> явно управляет размером векторов и явно заменяет их новыми, когда размер превышен:</p>
<div class="fragment"><div class="line">(let* ((current-size 0)</div><div class="line">      (max-size 1)</div><div class="line">      (vars (make-array max-size))</div><div class="line">      (vals (make-array max-size))</div><div class="line">      (success (cons vars vals)))</div><div class="line">  (declare (simple-vector vars vals)</div><div class="line">          (fixnum current-size max-size))</div><div class="line">(defun efficient-pat-match (pattern input)</div><div class="line">  &quot;Match pattern against input.&quot;</div><div class="line">  (setf current-size 0)</div><div class="line">  (pat-match-1 pattern input))</div><div class="line">;; pat-match-1 is unchanged</div><div class="line">(defun match-var (var input)</div><div class="line">  &quot;Match a single variable against input.&quot;</div><div class="line">  (let ((i (position var vars)))</div><div class="line">    (cond</div><div class="line">      ((null i)</div><div class="line">        (when (= current-size max-size)</div><div class="line">          ;; Make new vectors when we run out of space</div><div class="line">          (setf max-size (* 2 max-size)</div><div class="line">              vars (replace (make-array max-size) vars)</div><div class="line">              vals (replace (make-array max-size) vals)</div><div class="line">              success (cons vars vals)))</div><div class="line">        ;; Store var and its value in vectors</div><div class="line">        (setf (aref vars current-size) var)</div><div class="line">        (setf (aref vals current-size) input)</div></div><!-- fragment --><p><code>(incf current-size)</code><code>success)</code></p>
<div class="fragment"><div class="line">((equal input (aref vals i)) success)</div><div class="line">(t fail)))))</div></div><!-- fragment --><p>В заключение, замена списков векторами часто может сэкономить мусор. Но когда вам необходимо использовать списки, стоит использовать такую версию cons, которая по возможности избегает лишних конструирований. Вот такая версия:</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline reuse-cons))</div><div class="line">(defun reuse-cons (x y x-y)</div><div class="line">  &quot;Return (cons x y), or just x-y if it is equal to (cons x y).&quot;</div><div class="line">  (if (and (eql x (car x-y)) (eql y (cdr x-y)))</div><div class="line">      x-y</div><div class="line">      (cons x y)))</div></div><!-- fragment --><p>Уловка основана на определении subst в <em>Common Lisp the Language</em> Стила. Вот определение версии <code>remove</code>, в которой используются <code>reuse-cons</code>:</p>
<div class="fragment"><div class="line">(defun remq (item list)</div><div class="line">  &quot;Like REMOVE, but uses EQ, and only works on lists.&quot;</div><div class="line">  (cond ((null list) nil )</div><div class="line">      ((eq item (first list)) (remq item (rest list)))</div><div class="line">      (t (reuse-cons (first list)</div><div class="line">                (remq item (rest list))</div><div class="line">                list))))</div></div><!-- fragment --><h3>Избегайте Consing(конструирования списков): уникальные списки</h3>
<p>Конечно, <code>reuse-cons</code> работает только тогда, когда у вас есть кандидаты на cons-ячейки. То есть (<code>reuse-cons a b c</code>) экономит место только тогда, когда <code>c</code> равно (или может быть) равно (<code>cons a b</code>). Для некоторых приложений полезно иметь версию <code>cons</code>, которая возвращает уникальную cons-ячейку без необходимости использовать <code>c</code> в качестве подсказки. Мы будем называть эту версию <code>ucons</code> для <code>уникальных cons</code>. ucons поддерживает двойную хеш-таблицу: <code>*uniq-cons-table*</code> - хеш-таблица, ключи которой являются началом (<code>cars</code>) cons-ячеек. Значение для каждого <code>car</code> - это другая хеш-таблица, ключи которой являются концом(<code>cdrs</code>) cons-ячеек. Значение каждого <code>cdr</code> во второй таблице - это исходная cons-ячейка. Таким образом, две разные cons-ячейки с одинаковыми <code>car</code> и <code>cdr</code> получат одно и то же значение. Вот реализация <code>ucons</code>:</p>
<div class="fragment"><div class="line">(defvar *uniq-cons-table* (make-hash-table :test #&#39;eq))</div><div class="line">(defun ucons (x y)</div></div><!-- fragment --><p><code>"Return a cons s.t.
(eq (ucons x y) (ucons x y)) is true."</code></p>
<div class="fragment"><div class="line">(let ((car-table (or (gethash x *uniq-cons-table*)</div><div class="line">              (setf (gethash x *uniq-cons-table*)</div><div class="line">                  (make-hash-table :test #&#39;eq)))))</div><div class="line">  (or (gethash y car-table)</div><div class="line">      (setf (gethash y car-table) (cons x y)))))</div></div><!-- fragment --><p><code>ucons</code>, в отличие от <code>cons</code>, является истинной функцией: она всегда будет возвращать одно и то же значение при тех же аргументах, где "same/тождественность" измеряется с помощью eq. Однако, если <code>ucons</code> заданы аргументы, которые равны, но не eq, она не вернет уникальный результат. Для этого нам понадобится функция unique. Она обладает тем свойством, что <code>(unique x)</code> эквивалентен <code>(unique y)</code> всякий раз, когда <code>x</code> и <code>y</code> равны(equal). <code>unique</code> использует хеш-таблицу для атомов в дополнение к двойной хеш-таблице для conses. Это необходимо, потому что строки и массивы могут быть равны(equal), не будучи eq. Помимо <code>unique</code>, для удобства мы также определяем <code>ulist</code> и <code>uappend</code>.</p>
<div class="fragment"><div class="line">(defvar *uniq-atom-table* (make-hash-table :test #&#39;equal))</div><div class="line">  (defun unique (exp)</div><div class="line">    &quot;Return a canonical representation that is EQUAL to exp,</div><div class="line">    such that (equal x y) implies (eq (unique x) (unique y)).&quot;</div><div class="line">    (typecase exp</div><div class="line">      (symbol exp)</div><div class="line">      (fixnum exp) ;; Remove if fixnums are not eq in your Lisp</div><div class="line">      (atom (or (gethash exp *uniq-atom-table*)</div><div class="line">                (setf (gethash exp *uniq-atom-table*) exp)))</div><div class="line">      (cons (unique-cons (car exp) (cdr exp)))))</div><div class="line">  (defun unique-cons (x y)</div></div><!-- fragment --><p><code>"Return a cons s.t. (eq (ucons x y) (ucons x2 y2)) is true</code></p>
<div class="fragment"><div class="line">  whenever (equal x x2) and (equal y y2) are true.&quot;</div><div class="line">  (ucons (unique x) (unique y)))</div><div class="line">(defun ulist (&amp;rest args)</div><div class="line">  &quot;A uni qui fied list.&quot;</div><div class="line">  (unique args))</div><div class="line">(defun uappend (x y)</div><div class="line">  &quot;A unique list equal to (append x y).&quot;</div><div class="line">  (if (null x)</div><div class="line">      (unique y)</div><div class="line">      (ucons (first x) (uappend (rest x) y))))</div></div><!-- fragment --><p>Приведенный выше код работает, но его можно улучшить. Проблема в том, что когда к дереву применяется <code>unique</code>, она всегда проходит по дереву вплоть до листьев. Функция <code>unique-cons</code> похожа на <code>ucons</code>, за исключением того, что <code>unique-cons</code> предполагает, что ее аргументы еще не уникальны. Мы можем изменить <code>unique-cons</code>, чтобы она сначала проверяла, уникальны ли её аргументы, просматривая соответствующие хэш-таблицы:</p>
<div class="fragment"><div class="line">(defun unique-cons (x y)</div></div><!-- fragment --><p><code>"Return a cons s.t. (eq (ucons x y) (ucons x2 y2)) is true</code></p>
<div class="fragment"><div class="line">whenever (equal x x2) and (equal y y2) are true.&quot;</div><div class="line">(let ((ux) (uy)) ; unique x and y</div><div class="line">  (let ((car-table</div><div class="line">        (or (gethash x *uniq-cons-table*)</div><div class="line">          (gethash (setf ux (unique x)) *uniq-cons-table*)</div><div class="line">          (setf (gethash ux *uniq-cons-table*)</div><div class="line">              (make-hash-table :test #&#39;eq)))))</div><div class="line">    (or (gethash y car-table)</div><div class="line">      (gethash (setf uy (unique y)) car-table)</div><div class="line">      (setf (gethash uy car-table)</div><div class="line">          (cons ux uy))))))</div></div><!-- fragment --><p>Еще одним преимуществом <code>unique</code> является то, что она помогает при индексации. Если списки уникальны, то они могут храниться в хэш-таблице <code>eq</code> вместо <code>equal</code> хэш-таблице. Это может привести к значительной экономии при больших размерах списков. Хеш-таблица <code>eq</code> для списков почти так же хороша, как список свойств для символов.</p>
<h3>Избегайте Consing: Множественные Значения</h3>
<p>Параметры и несколько значений также можно использовать для передачи значений, а не для создания списков. Например, вместо:</p>
<div class="fragment"><div class="line">(defstruct point &quot;A point in 3-D cartesian space.&quot; x y z)</div><div class="line">(defun scale-point (k  pt)</div><div class="line">  &quot;Multiply a point by a constant, K.&quot;</div><div class="line">  (make-point :x (* k (point-x pt))</div><div class="line">                  :y (* k (point-y pt))</div><div class="line">                  :z (* k (point-z pt))))</div></div><!-- fragment --><p>можно использовать следующий подход, который не генерирует структуры:</p>
<div class="fragment"><div class="line">(defun scale-point (k x y z)</div><div class="line">  &quot;Multiply the point (x,y,z) by a constant, K.&quot;</div><div class="line">  (values (* k x) (* k y) (* k z)))</div></div><!-- fragment --><h3>Избегайте Consing: ресурсы</h3>
<p>Иногда имеет смысл явно управлять хранением экземпляров некоторого типа данных. Пул этих экземпляров можно назвать <em>resource</em>. Явное управление ресурсом целесообразно, когда: (1) экземпляры создаются часто и нужны только временно; (2) легко(или просто возможно) убедиться, когда экземпляры больше не нужны; и (3) экземпляры представляют собой довольно большие структуры или для их инициализации требуется много времени, поэтому стоит использовать их повторно вместо создания новых. Условие (2) является ключевым: если вы освободите экземпляр, который все еще используется, этот экземпляр будет таинственным образом изменен, когда он будет перераспределен. И наоборот, если вам не удается освободить ненужные экземпляры, вы тратите ценное пространство памяти. (В этом случае считается, что схема управления памятью дает утечку.)</p>
<p>Прелесть использования встроенного в Lisp управления памятью заключается в том, что в нем никогда не будет утечки и никогда не освободит используемые структуры. Это устраняет два потенциальных источника ошибок. Штраф, который вы платите за эту гарантию, заключается в некоторой неэффективности общего управления памятью по сравнению с настраиваемой схемой управления, предоставляемой пользователем. Но будьте осторожны: современные методы сборки мусора сильно оптимизированы. В частности, так называемые <em>сборщики мусора</em> <em>generation scavenging</em> или <em>ephemeral</em> чаще обращаются к недавно выделенному хранилищу на том основании, что недавно созданные объекты с большей вероятностью станут мусором. Если вы храните мусор в своих собственных структурах данных, производительность может снизиться.</p>
<p>Имея в виду все эти предупреждения, вот код для управления ресурсами:</p>
<div class="fragment"><div class="line">(defmacro defresource (name &amp;key constructor (initial-copies 0)</div><div class="line">                       (size (max initial-copies 10)))</div><div class="line">  (let ((resource (symbol &#39;* (symbol name &#39;-resource*)))</div><div class="line">        (deallocate (symbol &#39;deallocate- name))</div><div class="line">        (allocate (symbol &#39;allocate- name)))</div><div class="line">    `(progn</div><div class="line">       (defparameter ,resource (make-array ,size :fill-pointer 0))</div><div class="line">       (defun ,allocate ()</div><div class="line">         &quot;Get an element from the resource pool, or make one.&quot;</div><div class="line">         (if (= (fill-pointer ,resource) 0)</div><div class="line">             ,constructor</div><div class="line">             (vector-pop ,resource)))</div><div class="line">       (defun ,deallocate (,name)</div><div class="line">         &quot;Place a no-longer-needed element back in the pool.&quot;</div><div class="line">         (vector-push-extend ,name ,resource))</div><div class="line">       ,(if (&gt; initial-copies 0)</div><div class="line">            `(mapc #&#39;,deallocate (loop repeat ,initial-copies</div><div class="line">                                       collect (,allocate))))</div><div class="line">       &#39;,name)))</div></div><!-- fragment --><p>Допустим, у нас есть некоторая структура, называемая буфером, которую мы постоянно создавали, а затем отбрасывали. Более того, предположим, что буферы - это довольно сложные объекты для создания, что мы знаем, что нам понадобится по крайней мере 10 из них за раз, и что нам, вероятно, никогда не понадобится больше 100 за раз. Мы можем использовать буферный ресурс следующим образом:</p>
<div class="fragment"><div class="line">(defresource buffer :constructor (make-buffer)</div><div class="line">            :size 100 : initial-copies 10)</div></div><!-- fragment --><p>Это расширяется до следующего кода:</p>
<div class="fragment"><div class="line">(let ((buffer-resource (make-array 100 :fill-pointer 0)))</div><div class="line">  (defun allocate-buffer ()</div><div class="line">    &quot;Get an element from the resource pool, or make one.&quot;</div><div class="line">    (if (= (fill-pointer buffer-resource) 0)</div><div class="line">      (make-buffer)</div><div class="line">      (vector-pop buffer-resource)))</div><div class="line">  (defun deallocate-buffer (buffer)</div><div class="line">    &quot;Place a no-longer-needed element back in the pool.&quot;</div><div class="line">    (vector-push-extend buffer buffer-resource))</div><div class="line">  (mapc #&#39;deallocate-buffer</div><div class="line">        (loop repeat 10 collect (allocate-buffer)))</div><div class="line">  &#39;buffer)</div></div><!-- fragment --><p>Затем мы могли бы использовать:</p>
<div class="fragment"><div class="line">(let ((b (allocate-buffer)))</div><div class="line">  ...</div><div class="line">  (process b)</div><div class="line">  ...</div><div class="line">  (deallocate-buffer b)))</div></div><!-- fragment --><p>Важно помнить, что это работает, только если буфер <code>b</code> действительно может быть освобожден. Если функция <code>process</code> где-то хранит указатель на <code>b</code>, то было бы ошибкой освобождать <code>b</code>, потому что последующее выделение может непредсказуемо изменить сохраненный буфер. Конечно, если процесс сохранил <em>копию</em> <code>b</code>, то все в порядке. Этот шаблон распределения и освобождения настолько распространен, что мы можем предоставить для него макрос:</p>
<div class="fragment"><div class="line">defmacro with-resource ((var resource &amp;optional protect) &amp;rest body)</div><div class="line">  &quot;Execute body with VAR bound to an instance of RESOURCE.&quot;</div><div class="line">  (let ((allocate (symbol &#39;allocate- resource))</div><div class="line">        (deallocate (symbol &#39;deallocate- resource)))</div><div class="line">    (if protect</div><div class="line">        `(let ((,var nil))</div><div class="line">           (unwind-protect (progn (setf ,var (,allocate)) ,@body)</div><div class="line">             (unless (null ,var) (,deallocate ,var))))</div><div class="line">        `(let ((,var (,allocate)))</div><div class="line">           ,@body</div><div class="line">           (,deallocate var)))))</div></div><!-- fragment --><p>Макрос позволяет использовать необязательный аргумент, который устанавливает среду защиты <code>unwind</code>-protect, так что буфер освобождается даже при аварийном выходе из тела. Следующие расширения должны прояснить это:</p>
<div class="fragment"><div class="line">&gt;(macroexpand &#39;(with-resource (b buffer)</div><div class="line">                &quot;...&quot; (process b) &quot;...&quot;))</div><div class="line">(let ((b (allocate-buffer)))</div><div class="line">  &quot;...&quot;</div><div class="line">  (process b)</div><div class="line">  &quot;...&quot;</div><div class="line">  (deallocate-buffer b))</div><div class="line">&gt; (macroexpand &#39;(with-resource (b buffer t)</div><div class="line">                &quot;...&quot; &quot;...&quot; (process b) &quot;...&quot;))</div><div class="line">(let ((b nil))</div><div class="line">  (unwind-protect</div><div class="line">      (progn (setf b (allocate-buffer))</div><div class="line">          &quot;...&quot;</div><div class="line">                (process b)</div><div class="line">                &quot;...&quot;)</div><div class="line">            (unless (null b)</div><div class="line">            (deallocate-buffer b))))</div></div><!-- fragment --><p>Альтернативой полным ресурсам является сохранение одного объекта данных. Такой подход проще, потому что нет необходимости индексировать вектор объектов, но его достаточно для некоторых приложений, таких как хвостовой рекурсивный вызов функции, которая использует только один объект за раз.</p>
<p>Другая возможность - сделать систему медленнее, но безопаснее, заставив функцию <code>deallocate</code> проверять, действительно ли ее аргумент является объектом правильного типа.</p>
<p>Имейте в виду, что использование ресурсов может поставить вас в противоречие со схемой управления хранилищем системы Lisp. В частности, вы должны быть обеспокоены производительностью подкачки в системах виртуальной памяти. Распространенная проблема - иметь только несколько живых объектов на каждой странице, что заставляет систему выполнять много страниц для выполнения любой работы. Компактные сборщики мусора могут собирать живые объекты на одной странице, но использование ресурсов может этому помешать.</p>
<h2>10.5 Используйте правильные структуры данных</h2>
<p>Важно реализовать ключевые типы данных с наиболее эффективной реализацией. Это может варьироваться от машины к машине, но есть несколько универсальных методов. Здесь мы рассматриваем три тематических исследования.</p>
<h3>Правильная структура данных: переменные</h3>
<p>В качестве примера рассмотрим реализацию переменных сопоставления с образцом. Мы видели из инструментария <code>simplify</code>, что <code>variable-p</code> была одной из наиболее часто используемых функций. При компиляции соответствующих выражений я отказался от всех вызовов <code>variable-p</code>, но предположим, что у нас есть приложение, которое требует использования переменных во время выполнения. Спецификация типа данных <code>variable</code> будет включать два оператора, распознаватель <code>variable-p</code> и конструктор <code>make-variable</code>, который дает новую, ранее не использовавшуюся переменную. (Это не было необходимо в схемах сопоставления, показанных до сих пор, но потребуется для унификации(объединения) с обратной цепочкой.) Одна реализация переменных - это символы, начинающиеся со знака #\?:</p>
<div class="fragment"><div class="line">(defun variable-p (x)</div><div class="line">  &quot;Is x a variable (a symbol beginning with &#39;?&#39;)?&quot;</div><div class="line">  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))</div><div class="line">(defun make-variable O &quot;Generate a new variable&quot; (gentemp &quot;?&quot;))</div></div><!-- fragment --><p>Мы могли бы попытаться ускорить процесс, изменив реализацию переменных как ключевых слов и сделав функции встраиваемыми(inline):</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline variable-p make-variable))</div><div class="line">(defun variable-p (x) &quot;Is x a variable?&quot; (keywordp x))</div><div class="line">(defun make-variable O (gentemp &quot;X&quot; #.(find-package &quot;KEYWORD&quot;)))</div></div><!-- fragment --><p>(Последовательность символьных знаков функции чтения ввода(reader) #. означает вычислить во время чтения, а не во время выполнения.) На моей машине эта реализация выполняется довольно быстро, и я принял ее как жизнеспособный компромис. Однако были рассмотрены и другие реализации. Одна заключался в том, чтобы иметь переменные как структуры и предоставлять макрос чтения и функцию печати:</p>
<div class="fragment"><div class="line">(defstruct (variable (:print-function print-variable)) name)</div><div class="line">(defvar *vars* (make-hash-table))</div><div class="line">(set-macro-character #\?</div><div class="line">  #&#39;(lambda (stream char)</div><div class="line">      ;; Find an old var, or make a new one with the given name</div><div class="line">      (declare (ignore char))</div><div class="line">      (let ((name (read stream t nil t)))</div><div class="line">        (or (gethash name *vars*)</div><div class="line">          (setf (gethash name *vars*) (make-variable :name name))))))</div><div class="line">(defun print-variable (var stream depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;?~a&quot; (var-name var)))</div></div><!-- fragment --><p>Оказалось, что на всех трех протестированных Лиспах структуры были медленнее, чем ключевые слова или символы. Другая альтернатива - иметь ? макрос чтения возвращающий cons(пару), первым элементом в которой является, скажем, <code>:var</code>. Для этого требуется специальная процедура вывода, чтобы преобразовать обратно в обозначение ? . Еще одна альтернатива, которая оказалась самой быстрой из всех, заключалась в реализации переменных как отрицательных целых чисел. Конечно, это означает, что пользователь не может использовать отрицательные целые числа где-либо еще в образцах, но это оказалось приемлемым для данного приложения. Мораль заключается в том, чтобы знать, какие функции хорошо реализованы в вашей конкретной реализации, и стараться изо всех сил использовать их в критических ситуациях, но придерживаться наиболее простой реализации в некритических разделах.</p>
<p>Lisp позволяет легко полагаться на списки, но следует избегать соблазна злоупотреблять списками; использовать их там, где более уместна другая структура данных. Например, если вам нужно получить доступ к элементам последовательности в произвольном порядке, то вектор более уместен, чем список. Если последовательность может расти, используйте регулируемый вектор(adjustable vector). Рассмотрим проблему сохранения информации о группе(множестве) людей и поиск этой группы. Наивная реализация может выглядеть так:</p>
<div class="fragment"><div class="line">(defvar *people* nil &quot;Will hold a list of people&quot;)</div><div class="line">(defstruct person name address id-number)</div><div class="line">(defun person-with-id (id)</div><div class="line">  (find id *people* :key #&#39;person-id-number))</div></div><!-- fragment --><p>В традиционном языке, таком как C, естественным решением является включение в структуру человека(person) указателя на следующего человека и создание цикла для отслеживания этих указателей. Конечно, мы можем сделать это и в Лиспе:</p>
<div class="fragment"><div class="line">(defstruct person name address id-number next)</div><div class="line">(defun person-with-id (id)</div><div class="line">  (loop for person = *people* then (person-next person)</div><div class="line">      until (null person)</div><div class="line">      do (when (eql id (person-id-number person))</div><div class="line">          (RETURN person))))</div></div><!-- fragment --><p>Это решение занимает меньше места и, вероятно, работает быстрее, поскольку требует меньшего количества обращений к памяти: по одному для каждого человека, а не по одному для каждого человека плюс один для каждой cons-ячейки. Так что за использование списков приходится платить небольшую цену. Но программисты на Лиспе считают, что цена того стоит из-за удобства и простоты кодирования и отладки, обеспечиваемых функциями общего назначения, такими как <code>find</code>.</p>
<p>В любом случае, если будет много людей, список определенно неправильная структура данных. К счастью, Lisp позволяет легко переключиться на более эффективные структуры данных, например:</p>
<div class="fragment"><div class="line">(defun person-with-id (id)</div><div class="line">  (gethash id *people*))</div></div><!-- fragment --><h3>Правильная структура данных: очереди</h3>
<p>Очередь(<em>queue</em>) - это структура данных, в которую можно добавлять элементы сзади и удалять их спереди. Это почти как стек, за исключением того, что в стеке элементы добавляются и удаляются с одного конца.</p>
<p>Списки можно использовать для реализации стеков, но существует проблема с использованием списков для реализации очередей: добавление элемента в конец требует обхода всего списка. Таким образом, сбор <em>n</em> элементов будет <em>O</em>(<em>n2</em>) вместо <em>O</em>(<em>n</em>).</p>
<p>Альтернативная реализация очередей - это cons(пара) двух указателей: один на список элементов очереди (содержимое) и один на последнюю cons-ячейку в списке. Первоначально оба указателя были бы nil. Эта реализация фактически существовала в BBN Lisp и UCI Lisp под именем функции <code>tconc</code>:</p>
<div class="fragment"><div class="line">;;; A queue is a (contents . last) pair</div><div class="line">(defun tconc (item q)</div><div class="line">  &quot;Insert item at the end of the queue.&quot;</div><div class="line">  (setf (cdr q)</div><div class="line">      (if (null (cdr q))</div><div class="line">          (setf (car q) (cons item nil))</div><div class="line">          (setf (rest (cdr q))</div><div class="line">              (cons item nil)))))</div></div><!-- fragment --><p>Реализация <code>tconc</code> имеет тот недостаток, что добавление первого элемента к содержимому отличается от добавления последующих элементов, поэтому для решения, какое действие следует предпринять, требуется оператор <code>if</code>. Приведенное ниже определение очередей позволяет избежать этого недостатка хитрым приемом. Во-первых, порядок двух полей меняется на обратный(reversed). <code>car</code> cons-ячейки - это последний элемент, а <code>cdr</code> - это содержимое. Во-вторых, пустая очередь - это cons-ячейка, где <code>cdr</code> (поле содержимого) равно nil, а <code>car</code> (указывающий на последнее поле) - это сама cons-ячейка(указывает на себя). В определениях ниже мы меняем имя <code>tconc</code> на более стандартное <code>enqueue</code>, а также предоставляем другие функции очереди:</p>
<div class="fragment"><div class="line">;;; A queue is a (last . contents) pair</div><div class="line">(proclaim &#39;(inline queue-contents make-queue enqueue dequeue</div><div class="line">                front empty-queue-p queue-nconc))</div><div class="line"></div><div class="line">(defun queue-contents (q) (cdr q))</div><div class="line"></div><div class="line">(defun make-queue ()</div><div class="line">  &quot;Build a new queue, with no elements.&quot;</div><div class="line">  (let ((q (cons nil nil)))</div><div class="line">    (setf (car q) q)))</div><div class="line"></div><div class="line">(defun enqueue (item q)</div><div class="line">  &quot;Insert item at the end of the queue.&quot;</div><div class="line">  (setf (car q)</div><div class="line">        (setf (rest (car q))</div><div class="line">              (cons item nil)))</div><div class="line">  q)</div><div class="line"></div><div class="line">(defun dequeue (q)</div><div class="line">  &quot;Remove an item from the front of the queue.&quot;</div><div class="line">  (pop (cdr q))</div><div class="line">  (if (null (cdr q)) (setf (car q) q))</div><div class="line">  q)</div><div class="line"></div><div class="line">(defun front (q) (first (queue-contents q)))</div><div class="line"></div><div class="line">(defun empty-queue-p (q) (null (queue-contents q)))</div><div class="line"></div><div class="line">(defun queue-nconc (q list)</div><div class="line">  &quot;Add the elements of LIST to the end of the queue.&quot;</div><div class="line">  (setf (car q)</div><div class="line">        (last (setf (rest (car q)) list))))</div></div><!-- fragment --><h3>Правильная структура данных: таблицы</h3>
<p><em>Таблица</em>(table) - это структура данных, в которую можно вставить ключ и связать его со значением, а затем использовать ключ для поиска значения. Таблицы могут выполнять другие операции, такие как подсчет количества ключей, очистка всех ключей или отображение функции для каждой пары ключ/значение.</p>
<p>Lisp предоставляет широкий выбор вариантов реализации таблиц. Список ассоциаций, пожалуй, самый простой: это просто список пар ключ/значение(alists). Подходит для небольших таблиц, до нескольких десятков пар. Хеш-таблица разработана так, чтобы быть эффективной для больших таблиц, но может иметь значительные накладные расходы для маленьких. Если ключи являются символами, можно использовать списки свойств(plists). Если ключи являются целыми числами в узком диапазоне (или могут быть отображены в них), тогда вектор может быть наиболее эффективным выбором.</p>
<p>Здесь мы реализуем альтернативную структуру данных, <em>trie</em>. trie реализует таблицу ключей, состоящую из конечной последовательности компонентов. Например, если бы мы реализовали словарь как trie, каждый ключ был бы словом, а каждая буква слова была бы компонентом. Значение ключа будет определением слова. Вверху словаря trie находится сильноветвящаяся(multiway) ветвь, по одному пути для каждой возможной первой буквы. У каждого узла второго уровня есть ветвь для каждой возможной второй буквы и так далее. Чтобы найти <em>n</em> -буквенное слово, требуется <em>n</em> операций чтения. Такая организация особенно хороша, когда информация хранится во вторичном хранилище, потому что одно чтение может привести к узлу со всеми его возможными ветвями.</p>
<p>Если ключи могут быть произвольными списковыми структурами, а не простой последовательностью букв, нам нужно упорядочить ключи, преобразовав их в простую последовательность. Один из способов сделать это использует тот факт, что любое дерево может быть записано как линейная последовательность атомов и cons-операций в префиксной форме. Таким образом, мы бы сделали следующее преобразование:</p>
<div class="fragment"><div class="line">(a (b c) d) =</div></div><!-- fragment --><p><code>(cons a (cons (cons b (cons c nil)) (cons d nil)))</code>=</p>
<div class="fragment"><div class="line">(cons a cons cons b cons c nil cons d nil)</div></div><!-- fragment --><p>В приведенной ниже реализации tries это преобразование выполняется на лету: четыре функции пользовательского уровня: <code>make-trie</code> для создания нового дерева, <code>put-trie</code> и <code>get-trie</code> для добавления и извлечения пары ключ/значение и <code>delete-trie</code> для их удаления.</p>
<p>Обратите внимание, что мы используем выделенное значение для пометки удаленных элементов, и что <code>get-trie</code> возвращает два значения: фактическое найденное значение и флаг, сообщающий, было что-то найдено или нет. Это согласуется с интерфейсом <code>gethash</code> и <code>find</code> и позволяет нам сохранять значения nil в trie. Это ненавязчивый выбор, потому что программист, решивший не хранить значения nil, может просто проигнорировать второе значение, и все будет работать правильно.</p>
<div class="fragment"><div class="line">(defstruct trie (value nil) (arcs nil))</div><div class="line">(defconstant trie-deleted &quot;deleted&quot;)</div><div class="line">(defun put-trie (key trie value)</div><div class="line">  &quot;Set the value of key in trie.&quot;</div><div class="line">  (setf (trie-value (find-trie key t trie)) value))</div><div class="line">(defun get-trie (key trie)</div><div class="line">  &quot;Return the value for a key in a trie, and t/nil if found.&quot;</div><div class="line">  (let* ((key-trie (find-trie key nil trie))</div><div class="line">        (val (if key-trie (trie-value key-trie))))</div><div class="line">    (if (or (null key-trie) (eq  val trie-deleted))</div><div class="line">        (values nil nil )</div><div class="line">        (values val t))))</div><div class="line">(defun delete-trie (key trie)</div><div class="line">  &quot;Remove a key from a trie.&quot;</div><div class="line">  (put-trie key trie trie-deleted))</div></div><!-- fragment --><p><code>(defun find-trie (key extend? trie)</code></p>
<div class="fragment"><div class="line">&quot;Find the trie node for this key.</div></div><!-- fragment --><p><code>If EXTEND? is true, make a new node if need be."</code></p>
<div class="fragment"><div class="line">(cond ((null trie) nil )</div><div class="line">      ((atom key)</div></div><!-- fragment --><p><code>(follow-arc key extend? trie))</code></p>
<div class="fragment"><div class="line">(t (find-trie</div><div class="line">      (cdr key) extend?</div><div class="line">      (find-trie</div><div class="line">        (car key) extend?</div><div class="line">      (find-trie</div></div><!-- fragment --><p><code>"." extend? trie))))))</code></p>
<p><code>(defun follow-arc (component extend? trie)</code></p>
<div class="fragment"><div class="line">&quot;Find the trie node for this component of the key.</div></div><!-- fragment --><p><code>If EXTEND? is true, make a new node if need be."</code></p>
<div class="fragment"><div class="line">(let ((arc (assoc component (trie-arcs trie))))</div><div class="line">  (cond ((not (null arc)) (cdr arc))</div><div class="line">        ((not extend?) nil)</div><div class="line">        (t (let ((new-trie (make-trie)))</div><div class="line">            (push (cons component new-trie)</div><div class="line">                (trie-arcs trie))</div><div class="line">            new-trie)))))</div></div><!-- fragment --><p>В реализации есть несколько тонкостей. Сначала мы проверяем удаленные записи с помощью сравнения <code>eq</code> с выделенным маркером, строкой <code>trie-deleted</code>. Никакой другой объект не будет <code>eq</code> к этой строке, кроме самого <code>trie-deleted</code>, так что это хороший тест. Мы также используем особый маркер - строку "." чтобы отметить cons-ячейки. Компоненты неявно сравниваются с этим маркером с помощью теста <code>eql</code> с помощью команды <code>associn follow-arc</code>. Сохранение идентичности этой строки имеет решающее значение; если, например, вы перекомпилировали определение <code>find-trie</code> (без изменения определения вообще), то вы больше не могли бы найти ключи, которые были проиндексированы в существующем дереве, потому что строка "." используемая <code>find-trie</code> будет отличаться от "." в существующем дереве.</p>
<p>В <em>Программирование искусственного интеллекта</em> (<a href="B9780080571157500285.xhtml#bb0180">Charniak et al. 1987</a>) обсуждаются варианты trie, в частности, в схеме индексирования. Если мы всегда используем правильные списки (без не-null <code>cdrs</code>), тогда возможно более эффективное кодирование. Как обычно, лучший тип индексирования зависит от индексируемых данных. Следует отметить, что Charniak et al. именует trie как <em>сетью дискриминации(распознавания?)</em>(discrimination net). В общем, этот термин относится к любому дереву с тестами в узлах.</p>
<p>Trie - это, конечно, разновидность дерева, но в некоторых случаях полезно преобразовать trie в ориентированный ациклический граф <em>dag</em>(directed acyclic graph). dag - это дерево, в котором некоторые поддеревья являются общими(разделяемыми). Представьте, что у вас есть программа коррекции орфографии со списком примерно из 50 000 слов. Вы можете поместить их в дерево, каждое слово со значением t. Но в этом дереве будет повторяться много поддеревьев. Например, для списка слов, содержащего <em>look</em>, <em>looks</em>, <em>looked</em> и <em>looking</em>, а также <em>show</em>, <em>shows</em>, <em>showed</em> и <em>showing</em>, будет повторение поддерева, содержащго -s, -*ed* и -*ing*. После того, как дерево построено, мы могли бы передать все дерево в unique, и она свернула бы общие поддеревья, сохранив память. Конечно, вы больше не сможете добавлять или удалять ключи из dag без риска непредвиденных побочных эффектов.</p>
<p>Этот процесс проводился для списка из 56 000 слов. Дерево занимало 3,2 Мбайта, а размер тега - 1.1 Mбайт. Это все еще считалось неприемлемым, поэтому было создано более компактное кодирование dag с использованием вектора размером 0,2 МБ. Кодирование одного и того же списка слов в хеш-таблице занимало вдвое больше места, даже при использовании специального формата для кодирования суффиксов.</p>
<p>Tries работают лучше всего, когда ни ключ индексации, ни ключ извлечения не содержат переменных. Они работают достаточно хорошо, когда переменные находятся ближе к концу последовательности. Попробуйте поискать образец <code>"yello?"</code> в словаре, где "?" символный знак обозначающий совпадение любой буквы. Следование веткам для <code>"yello"</code> быстро приводит к единственно возможному совпадению <code>"yellow"</code>. Напротив, выборка с образецом <code>"??llow» намного менее эффективна.
Функция поиска в таблице должна будет искать во всех 26 ветвях верхнего уровня, и для каждой из них рассматривать все возможные вторые буквы, а для каждого из них рассмотреть путь&lt;/tt&gt;"llow"`. Прежде чем прийти к полному набору совпадений, требуется немало поисков: bellow, billow, fallow, fellow, follow, hallow, hollow, mallow, mellow, pillow, sallow, tallow, wallow, willow и yellow</code></p>
<p><code>Мы вернемся к проблеме селективных сетей с переменными в <a href="B9780080571157500145.xhtml#s0040">раздел 14.8</a>, <a href="B9780080571157500145.xhtml#p472">страница 472</a>.</code></p>
<p><code></p><h2>10.6 Упражнения</h2>
<p></code></p>
<p><code></code></p>
<p><code><b>Exercise 10.1 [h]</b> Define the macro <code>deftable,</code> such that <code>(deftable person assoc</code>) will act much like a <code>defstruct-</code>it will define a set of functions for manipulating a table of people: <code>get-person, put-person, clear-person,</code> and <code>map-person.</code> The table should be implemented as an association list. Later on, you can change the representation of the table simply by changing the form to (<code>deftable person hash</code> ), without having to change anything else in your code. Other implementation options include property lists and vectors. <code>deftable</code> should also take three keyword arguments: <code>inline</code>, <code>size</code> and <code>test</code>. Here is a possible macroexpansion:</code></p>
<p><code>`&gt;(macroexpand '(deftableperson hash :-inline t :size 100))`=</code></p>
<p><code></p><div class="fragment"><div class="line">(progn</div><div class="line">(proclaim &#39;(inline get-person put-person map-person))</div><div class="line">(defparameter *person-table*</div><div class="line">  (make-hash-table :test #eql :size 100))</div><div class="line">(defun get-person (x &amp;optional default)</div><div class="line">  (gethash x *person-table* default))</div><div class="line">(defun put-person (x value)</div><div class="line">  (setf (gethash x *person-table*) value))</div><div class="line">(defun clear-person () (clrhash *person-table*))</div><div class="line">(defun map-person (fn) (maphash fn *person-table*))</div><div class="line">(defsetf get-person put-person)</div><div class="line">&#39;person)</div></div><!-- fragment --><p></code></p>
<p><code><b>Exercise 10.2 [m]</b> We can use the :<code>type</code> option to <code>defstruct</code> to define structures implemented as lists. However, often we have a two-field structure that we would like to implement as a cons cell rather than a two-element list, thereby cutting storage in half. Since <code>defstruct</code> does not allow this, define a new macro that does.</code></p>
<p><code><b>Exercise 10.3 [m]</b> Use <code>reuse - cons</code> to write a version of <code>flatten</code> (see <a href="B9780080571157500108.xhtml#p329">page 329</a>) that shares as much of its input with its output as possible.</code></p>
<p><code><b>Exercise 10.4 [h]</b> Consider the data type <em>set</em>. A set has two main operations: adjoin an element and test for membership. It is convenient to also add a map-over-elements operation. With these primitive operations it is possible to build up more complex operations like union and intersection.</code></p>
<p><code>As mentioned in <a href="B9780080571157500030.xhtml#s0095">section 3.9</a>, Common Lisp provides several implementations of sets. The simplest uses lists as the underlying representation, and provides the functions <code>adjoin, member, union, intersection</code>, and <code>set-difference</code>. Another uses bit vectors, and a similar one uses integers viewed as bit sequences. Analyze the time complexity of each implementation for each operation.</code></p>
<p><code>Next, show how <em>sorted lists</em> can be used to implement sets, and compare the operations on sorted lists to their counterparts on unsorted lists.</code></p>
<p><code></p><h2>10.7 Ответы</h2>
<p></code></p>
<p><code></code></p>
<p><code><b>Answer 10.2</b></code></p>
<p><code></p><div class="fragment"><div class="line">(defmacro def-cons-struct (cons car cdr &amp;optional inline?)</div><div class="line">  &quot;Define aliases for cons, car and cdr.&quot;</div></div><!-- fragment --><p></code></p>
<p><code>` '(progn (proclaim '(,(if inline? 'inline 'notinline)`</code></p>
<p><code></p><div class="fragment"><div class="line">        ,car ,cdr ,cons))</div><div class="line">(defun ,car (x) (car x))</div><div class="line">(defun ,cdr (x) (cdr x))</div><div class="line">(defsetf ,car (x) (val) &#39;(setf (car ,x) ,val))</div><div class="line">(defsetf ,cdr (x) (val) &#39;(setf (cdr ,x) ,val))</div><div class="line">(defun ,cons (x y) (cons x y))))</div></div><!-- fragment --><p></code></p>
<p><code><b>Answer 10.3</b></code></p>
<p><code></p><div class="fragment"><div class="line">(defun flatten (exp &amp;optional (so-far nil) last-cons)</div><div class="line">  &quot;Return a flat list of the atoms in the input.</div><div class="line">  Ex: (flatten &#39;((a) (b (c) d))) =&gt; (a b c d).&quot;</div><div class="line">  (cond ((null exp) so-far)</div><div class="line">        ((atom exp) (reuse-cons exp so-far last-cons))</div><div class="line">        (t (flatten (first exp)</div><div class="line">                  (flatten (rest exp) so-far exp)</div><div class="line">                  exp))))</div></div><!-- fragment --> <hr/>
<p></code></p>
<p><code><a href="#xfn0015">1</a> These are all done with safety 0 and speed 3. !!!(p) {:.ftnote1} </code></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
