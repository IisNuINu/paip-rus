<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 7</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 7 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>STUDENT: Решение Алгебраических Задач</h2>
<blockquote class="doxtable">
<p><em>[Это] превосходный пример</em> демонстрирующий силу использования значений(meaning) для решения лингвистических проблем. </p>
</blockquote>
<blockquote class="doxtable">
<p>-<a href="B9780080571157500285.xhtml#bb0845">Marvin Minsky (1968)</a> </p>
</blockquote>
<blockquote class="doxtable">
<p>MIT computer scientist </p>
</blockquote>
<p>STUDENT еще одна ранняя программа понимания языка, написанная Дэниелом Боброу в качестве исследовательского проекта на степень доктора философии 1964 г. Она была разработана для чтения и решения задач со словами, которые можно найти в школьных учебниках по алгебре. Пример:</p>
<blockquote class="doxtable">
<p>If the number of customers Tom gets is twice the square of 20% of the number of advertisements he runs, and the number of advertisements is 45, then what is the number of customers Tom gets? </p>
</blockquote>
<p>(Если количество клиентов, которых получает Том, вдвое больше квадрата 20% от количества рекламных объявлений, которые он запускает, а количество рекламных объявлений равно 45, то какое количество клиентов получает Том?)</p>
<p>STUDENT правильно ответит, что клиентов 162. Для этого STUDENT должен быть гораздо более искушеннее, чем ELIZA; он должен обрабатывать и "понимать" большую часть вводимой информации, а не просто концентрироваться на нескольких ключевых словах. И он должен вычислять ответ, а не просто заполнять пробелы. Однако мы увидим, что программа STUDENT использует немногим больше, чем методы сопоставления с образцом ELIZA для преобразования входных данных в набор алгебраических уравнений. Поэтому он должен знать достаточно алгебры, чтобы решать уравнения, но она не очень сложная.</p>
<p>Разрабатываемая нами версия STUDENT является почти полной реализацией оригинала. Однако помните, что хотя оригинал был последним по состоянию на 1964 год, ИИ добился определенного прогресса за четверть века, как это будет показано в последующих главах.</p>
<h2>7.1 Преобразование Английского в Уравнения</h2>
<p>Описание STUDENT такое:</p>
<ol type="1">
<li>Разбейте ввод на фразы, которые будут представлять собой уравнения. !!!(p) {:.numlist}</li>
<li>Разбейте каждую фразу на пару фраз по обе стороны от знака = !!!(p) {:.numlist}</li>
<li>Далее разбейте эти фразы на суммы и произведения и так далее, пока, наконец, мы не дойдем до конца с числами и переменными. (Под "переменной" здесь я имею в виду "математическую переменную", которая отличается от идеи "переменной используемой при сопоставлении с образцом", используемой в <code>pat-match</code> в <a href="B9780080571157500066.xhtml">главе 6</a>). !!!(p) {:.numlist}</li>
<li>Преобразуйте каждую английскую фразу в математическое выражение. Мы используем идею преобразователя на основе правил, разработанного для ELIZA. !!!(p) {:.numlist}</li>
<li>Решите полученные математические уравнения, найдя значение для каждой неизвестной переменной. !!!(p) {:.numlist}</li>
<li>Выведите значения всех переменных. !!!(p) {:.numlist}</li>
</ol>
<p>Например, у нас может быть образец формы (<code>If ?x then ?y</code>) с соответствующим ответом, в котором говорится, что <code>?x</code> и <code>?y</code> будут уравнениями или списками уравнений. Применив сопоставление входных данных указанных выше с образцом, <code>?y</code> будет иметь значение (<code>what is the number of customers Tomgets</code>/ сколько клиентов Tomgets). Другой образец формы (<code>?x is ?y</code>) мог бы иметь ответ, соответствующий равенству, где <code>?x</code> и <code>?y</code> - две стороны одного равенства. Затем мы могли бы создать математическую переменную для (<code>what</code>) и другую для (<code>the number of customers Tom gets</code>/количество клиентов, которых получает Том). Мы бы распознали эту более позднюю фразу как переменную, потому что нет никаких образцов, которые позволили бы разбить её дальше. Напротив, фраза (<code>twice the square of 20 per cent of the number of advertisements he runs</code>/вдвое больше квадрата 20 процентов от количества рекламных объявлений, которые он запускает) может соответствовать образцу формы (<code>twice ?x</code>) и преобразовываться в <code>(* 2 (the square of 20 per cent of the number of advertisements he runs))</code> и путем дальнейшего применения образцов формы (<code>the square of ?x</code>) и (<code>?x per cent of ?y</code>) мы могли бы прийти к окончательному ответу <code>(* 2 (expt (* (/ 20 100) n) 2))</code>, где <code>n</code> - переменная, генерируемая (<code>the number of advertisements he runs</code>/количество рекламных объявлений, которые он запускает).</p>
<p>Таким образом, нам нужно представить переменные, выражения, уравнения и наборы уравнений. Проще всего использовать то, что мы знаем: представить их так же, как это делает сам Лисп. Переменные будут символами, выражения и уравнения будут вложенными списками с префиксными операторами, а наборы уравнений будут списками уравнений. Имея это в виду, мы можем определить список правил <code>образец-ответ</code>, соответствующих типам утверждений, встречающихся в описаниях задач алгебры. Структура определений для правил повторется здесь, и добавляется структура выражений <code>exp</code>. <code>lhs</code> и <code>rhs</code> обозначают левую и правую стороны, соответственно. Обратите внимание, что конструктор <code>mkexp</code> определяется как конструктор, который строит выражения без использования аргументов ключеввых слов. Как правило, запись (<code>:constructor</code> <em>fn args</em>) создает функцию-конструктор с заданным именем и списком аргументов. <a href="# fn0015">1</a></p>
<div class="fragment"><div class="line">(defstruct (rule (:type list)) pattern response)</div><div class="line"></div><div class="line">(defstruct (exp (:type list)</div><div class="line">                (:constructor mkexp (lhs op rhs)))</div><div class="line">  op lhs rhs)</div><div class="line"></div><div class="line">(defun exp-p (x) (consp x))</div><div class="line">(defun exp-args (x) (rest x))</div></div><!-- fragment --><p>Мы проигнорировали запятые и точки в ELIZA, но они имеют решающее значение для STUDENT, поэтому мы должны сделать поправку на них. Проблема в том, что <code>","</code> в Лиспе обычно можно использовать только в конструкции обратных кавычек, а <code>"."</code> обычно можно использовать только как десятичную точку или в точечной паре. Специального значения этих символьных знаков для читателя(reader) Лиспа можно избежать, поставив перед символьным знаком обратную косую черту (\,) или окружив знак вертикальными полосами (| , |).</p>
<div class="fragment"><div class="line">(pat-match-abbrev &#39;?x* &#39;(?* ?x))</div><div class="line">(pat-match-abbrev &#39;?y* &#39;(?* ?y))</div><div class="line"></div><div class="line">(defparameter *student-rules* (mapcar #&#39;expand-pat-match-abbrev</div><div class="line">  &#39;(((?x* |.|)                  ?x)</div><div class="line">    ((?x* |.| ?y*)          (?x ?y))</div><div class="line">    ((if ?x* |,| then ?y*)  (?x ?y))</div><div class="line">    ((if ?x* then ?y*)      (?x ?y))</div><div class="line">    ((if ?x* |,| ?y*)       (?x ?y))</div><div class="line">    ((?x* |,| and ?y*)      (?x ?y))</div><div class="line">    ((find ?x* and ?y*)     ((= to-find-1 ?x) (= to-find-2 ?y)))</div><div class="line">    ((find ?x*)             (= to-find ?x))</div><div class="line">    ((?x* equals ?y*)       (= ?x ?y))</div><div class="line">    ((?x* same as ?y*)      (= ?x ?y))</div><div class="line">    ((?x* = ?y*)            (= ?x ?y))</div><div class="line">    ((?x* is equal to ?y*)  (= ?x ?y))</div><div class="line">    ((?x* is ?y*)           (= ?x ?y))</div><div class="line">    ((?x* - ?y*)            (- ?x ?y))</div><div class="line">    ((?x* minus ?y*)        (- ?x ?y))</div><div class="line">    ((difference between ?x* and ?y*)  (- ?y ?x))</div><div class="line">    ((difference ?x* and ?y*)          (- ?y ?x))</div><div class="line">    ((?x* + ?y*)            (+ ?x ?y))</div><div class="line">    ((?x* plus ?y*)         (+ ?x ?y))</div><div class="line">    ((sum ?x* and ?y*)      (+ ?x ?y))</div><div class="line">    ((product ?x* and ?y*)  (* ?x ?y))</div><div class="line">    ((?x* * ?y*)            (* ?x ?y))</div><div class="line">    ((?x* times ?y*)        (* ?x ?y))</div><div class="line">    ((?x* / ?y*)            (/ ?x ?y))</div><div class="line">    ((?x* per ?y*)          (/ ?x ?y))</div><div class="line">    ((?x* divided by ?y*)   (/ ?x ?y))</div><div class="line">    ((half ?x*)             (/ ?x 2))</div><div class="line">    ((one half ?x*)         (/ ?x 2))</div><div class="line">    ((twice ?x*)            (* 2 ?x))</div><div class="line">    ((square ?x*)           (* ?x ?x))</div><div class="line">    ((?x* % less than ?y*)  (* ?y (/ (- 100 ?x) 100)))</div><div class="line">    ((?x* % more than ?y*)  (* ?y (/ (+ 100 ?x) 100)))</div><div class="line">    ((?x* % ?y*)            (* (/ ?x 100) ?y)))))</div></div><!-- fragment --><p>Основной раздел STUDENTа будет искать по списку правил для ответа, как это делала ELIZA. Первое отклонение состоит в том, что перед тем, как мы подставим значения переменных <code>pat-match</code> в ответ, мы должны сначала рекурсивно преобразовать значение каждой переменной, используя тот же список правил образец-ответ. Другое отличие состоит в том, что после того, как мы закончим, мы не просто печатаем ответ; вместо этого мы должны решить систему уравнений и распечатать ответы. Краткое описание программы приведено на <a href="#f0010">рис. 7.1</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter7/f07-01.jpg" alt="f07-01"/>
</div>
 </td></tr>
<tr>
<td>Figure 7.1: Словарь для программы STUDENT </td></tr>
</table>
<p>(ed: this should be a markdown table)</p>
<p>Прежде чем внимательно взглянуть на программу, давайте попробуем рассмотреть пример задачи: "If z is 3, what is twice z?/Если z равно 3, сколько будет дважды z?" Применение правил к входу оставляет следующую трассу:</p>
<div class="fragment"><div class="line">Input: (If z is 3, what is twice z)</div><div class="line">Rule: ((if ?x |,| ?y)            (?x ?y))</div><div class="line">Binding: ((?x . (z is 3)) (?y . (what is twice z)))</div><div class="line">  Input: (z is 3)</div><div class="line">  Rule: ((?x is ?y)                  (= ?x ?y))</div><div class="line">  Result: (= z 3)</div><div class="line">  Input: (what is twice z ?)</div><div class="line">  Rule: ((?x is ?y)                  (= ?x ?y))</div><div class="line">  Binding:((?x . what) (?y . (twice z)))</div><div class="line">    Input: (twice z)</div><div class="line">    Rule: ((twice ?x)                (* 2 ?x))</div><div class="line">    Result: (* 2 z)</div><div class="line">  Result: (= what (* 2 z))</div><div class="line">Result: ((= z 3) (= what (* 2 z)))</div></div><!-- fragment --><p>Есть две незначительных сложности. Во-первых, мы договорились реализовать наборы уравнений в виде списков уравнений. В этом примере все сработало, и ответом был список из двух уравнений. Но если используются вложенные образцы, ответ может быть чем-то вроде <code>((= a 5) ((= b (+ a 1)) (= c (+ a b))))</code>, который не является списком уравнений. Функция <code>create-list-of-sizes</code> преобразует такой ответ в правильный список уравнений. Другая сложность - выбор имен переменных. Имея список таких слов, как (<code>the number of customers Tom gets</code>/количество клиентов, которых получает Том), мы хотим выбрать символ для их представления. Ниже мы увидим, что выбран символ <code>customers</code>/клиенты, но есть и другие возможности.</p>
<p>Вот основная функция для STUDENT. Сначала она удаляет слова, у которых нет содержимого, затем преобразует ввод в одно большое выражение с помощью <code>translate-to-expression</code> и разбивает его на отдельные уравнения с помощью <code>create-list-of-equations</code>. Наконец, функция <code>solve-equations</code> выполняет математические вычисления и выводит решение.</p>
<div class="fragment"><div class="line">(defun student (words)</div><div class="line">  &quot;Solve certain Algebra Word Problems.&quot;</div><div class="line">  (solve-equations</div><div class="line">    (create-list-of-equations</div><div class="line">      (translate-to-expression (remove-if #&#39;noise-word-p words)))))</div></div><!-- fragment --><p>Функция <code>translate-to-expression</code> - это преобразователь на основе правил. Он либо находит какое-то правило в <code>*student-rules*</code> для преобразования ввода, либо предполагает, что весь ввод представляет собой единственную переменную. Функция <code>translate-pair</code> принимает пару привязки переменная/значение и преобразует значение рекурсивным вызовом <code>translate-to-expression</code>.</p>
<div class="fragment"><div class="line">(defun translate-to-expression (words)</div><div class="line">  &quot;Translate an English phrase into an equation or expression.&quot;</div><div class="line">  (or (rule-based-translator</div><div class="line">        words *student-rules*</div><div class="line">        :rule-if #&#39;rule-pattern :rule-then #&#39;rule-response</div><div class="line">        :action #&#39;(lambda (bindings response)</div><div class="line">                    (sublis (mapcar #&#39;translate-pair bindings)</div><div class="line">                              response)))</div><div class="line">      (make-variable words)))</div><div class="line"></div><div class="line">(defun translate-pair (pair)</div><div class="line">  &quot;Translate the value part of the pair into an equation or expression.&quot;</div><div class="line">  (cons (binding-var pair)</div><div class="line">        (translate-to-expression (binding-val pair))))</div></div><!-- fragment --><p>Функция <code>create-list-of-equations</code> принимает одно выражение, содержащее встроенные уравнения(равенства), и разделяет их на список уравнений:</p>
<div class="fragment"><div class="line">(defun create-list-of-equations (exp)</div><div class="line">  &quot;Separate out equations embedded in nested parens.&quot;</div><div class="line">  (cond ((null exp) nil)</div><div class="line">        ((atom (first exp)) (list exp))</div><div class="line">        (t (append (create-list-of-equations (first exp))</div><div class="line">                   (create-list-of-equations (rest exp))))))</div></div><!-- fragment --><p>Наконец, функция <code>make-variable</code> создает переменную для представления списка слов. Мы делаем это, сначала удаляя все "зашумляющие слова" из ввода, а затем беря первый оставшийся символ. Так, например, "the distance John traveled/расстояние, пройденное Джоном" и "the distance traveled by John", будут представлены одной и той же переменной <code>distance</code>, что безусловно, является правильным решением. Однако "the distance Mary traveled" также будет представлено той же переменной, что, безусловно, является ошибкой. Для ((<code>the number of customers Tom gets</code>/количество клиентов, которых получает Том) переменной будет <code>customers</code>, так как <code>the</code>, <code>of</code> и <code>number</code> - все это зашумляющие слова. Она будет соответствовать (<code>the customers mentioned above</code>/клиенты, упомянутые выше) и (<code>the number of customers</code>/количество клиентов<code>), но не (</code>Tom's customers`/клиенты Тома). На данный момент мы примем решение, первое не шумовое слово, но обратите внимание, что в упражнении 7.3 требуется исправление.</p>
<div class="fragment"><div class="line">(defun make-variable (words)</div><div class="line">  &quot;Create a variable name based on the given list of words&quot;</div><div class="line">    ;; The list of words will already have noise words removed</div><div class="line">  (first words))</div><div class="line"></div><div class="line">(defun noise-word-p (word)</div><div class="line">  &quot;Is this a low-content word which can be safely ignored?&quot;</div><div class="line">  (member word &#39;(a an the this number of $)))</div></div><!-- fragment --><h2>7.2 Решение Алгебраических Уравнений</h2>
<p>Следующим шагом будет написание раздела решения уравнений для STUDENT. Это больше упражнение по элементарной алгебре, чем по ИИ, но это хороший пример задачи манипулирования символами и, следовательно, интересная проблема программирования.</p>
<p>Программа STUDENT упоминала функцию <code>solve-equations</code> передав ей один аргумент, список уравнений, которые необходимо решить. <code>solve-equations</code> печатает список уравнений, пытаясь решить их с помощью <code>solve</code> и печатает результат.</p>
<div class="fragment"><div class="line">(defun solve-equations (equations)</div><div class="line">  &quot;Print the equations and their solution&quot;</div><div class="line">  (print-equations &quot;The equations to be solved are:&quot; equations)</div><div class="line">  (print-equations &quot;The solution is:&quot; (solve equations nil)))</div></div><!-- fragment --><p>Настоящая работа выполняется методом solve, который имеет следующую спецификацию: (1) Ищет уравнение, в котором ровно одно вхождение неизвестного. (2) Преобразует это уравнение так, чтобы неизвестное было изолировано в левой части. Это можно сделать, если мы ограничим возможные операторы +, -, * и /. (3) Выполняет арифметические действия в правой части, получая числовое значение для неизвестного. (4) Подставляет числовое значение вместо неизвестного во все другие уравнения и запоминает полученные значения. Затем пробует решить получившуюся систему уравнений. (5) Если шаг (1) завершился неудачно - если нет уравнения с точно одним неизвестным - тогда просто возвращает известные значения и не пытайтется решить что-либо еще.</p>
<p>В функцию <code>solve</code> передается система уравнений вместе со списком известных пар переменная/значение. Изначально переменные неизвестны, поэтому этот список будет пустым. <code>solve</code> просматривает список уравнений в поисках уравнения с точно одним неизвестным. Если она может найти такое уравнение, она вызывает <code>isolate</code>, чтобы решить уравнение в терминах этого неизвестного. Затем <code>resolve</code> подставляет значение переменной по всему списку уравнений и рекурсивно вызывает себя в результирующем списке. Каждый раз, когда <code>resolve</code> вызывает себя, она удаляет одно уравнение из списка уравнений, которые нужно решить, и добавляет одно в список известных пар переменная/значение. Поскольку список уравнений всегда становится короче, <code>solve</code> в конечном итоге должно завершиться.</p>
<div class="fragment"><div class="line">(defun solve (equations known)</div><div class="line">  &quot;Solve a system of equations by constraint propagation.&quot;</div><div class="line">  ;; Try to solve for one equation, and substitute its value into</div><div class="line">  ;; the others. If that doesn&#39;t work, return what is known.</div><div class="line">  (or (some #&#39;(lambda (equation)</div><div class="line">                (let ((x (one-unknown equation)))</div><div class="line">                  (when x</div><div class="line">                    (let ((answer (solve-arithmetic</div><div class="line">           (isolate equation x))))</div><div class="line">                      (solve (subst (exp-rhs answer) (exp-lhs answer)</div><div class="line">                                    (remove equation equations))</div><div class="line">                             (cons answer known))))))</div><div class="line">            equations)</div><div class="line">      known))</div></div><!-- fragment --><p><code>isolate</code> передается уравнение, которое гарантированно содержит одно неизвестное. Она возвращает эквивалентное уравнение с неизвестным, изолированным в левой части. Следует рассмотреть пять случаев: когда неизвестное остается только слева, все готово. Второй случай - когда неизвестное находится где-нибудь с правой стороны. Поскольку '=' коммутативно, мы можем свести проблему к решению эквивалентного уравнения переставленными левой и правой частями.</p>
<p>Далее мы должны иметь дело со случаем, когда неизвестное находится в сложном выражении в левой части. Поскольку мы допускаем четыре оператора, а неизвестное может быть справа или слева, существует восемь возможностей. Если X обозначает выражение, содержащее неизвестное, а A и B обозначают выражения без неизвестных, то возможны их следующие решения:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td>(1) <code>X*A=B</code> =&gt; <code>X=B/A</code> </td><td>(5) <code>A*X=B</code> =&gt; <code>X=B/A</code> </td></tr>
<tr>
<td>(2) <code>X+A=B</code> =&gt; <code>X=B-A</code> </td><td>(6) <code>A+X=B</code> =&gt; <code>X=B-A</code> </td></tr>
<tr>
<td>(3) <code>X/A=B</code> =&gt; <code>X=B*A</code> </td><td>(7) <code>A/X=B</code> =&gt; <code>X=A/B</code> </td></tr>
<tr>
<td>(4) <code>X-A=B</code> =&gt; <code>X=B+A</code> </td><td>(8) <code>A-X=B</code> =&gt; <code>X=A-B</code> </td></tr>
</table>
<p>Возможности (1) - (4) обрабатываются случаем III, (5) и (6) случаем IV, и (7) и (8) случаем V. В каждом случае преобразование не дает нам окончательного ответа, поскольку X не обязательно должно быть неизвестным; это могло быть сложное выражение, связанное с неизвестным. Итак, мы должны снова вызвать isolate c полученным уравнением. Читатель должен попытаться проверить, что преобразования (1) - (8) действительны, и что случаи с III по V реализуют их правильно.</p>
<div class="fragment"><div class="line">(defun isolate (e x)</div><div class="line">  &quot;Isolate the lone x in e on the left hand side of e.&quot;</div><div class="line">  ;; This assumes there is exactly one x in e,</div><div class="line">  ;; and that e is an equation.</div><div class="line">  (cond ((eq (exp-lhs e) x)</div><div class="line">         ;; Case I: X = A -&gt; X = n</div><div class="line">         e)</div><div class="line">        ((in-exp x (exp-rhs e))</div><div class="line">         ;; Case II: A = f(X) -&gt; f(X) = A</div><div class="line">         (isolate (mkexp (exp-rhs e) &#39;= (exp-lhs e)) x))</div><div class="line">        ((in-exp x (exp-lhs (exp-lhs e)))</div><div class="line">         ;; Case III: f(X)*A = B -&gt; f(X) = B/A</div><div class="line">         (isolate (mkexp (exp-lhs (exp-lhs e)) &#39;=</div><div class="line">                         (mkexp (exp-rhs e)</div><div class="line">                                (inverse-op (exp-op (exp-lhs e)))</div><div class="line">                                (exp-rhs (exp-lhs e)))) x))</div><div class="line">        ((commutative-p (exp-op (exp-lhs e)))</div><div class="line">         ;; Case IV: A*f(X) = B -&gt; f(X) = B/A</div><div class="line">         (isolate (mkexp (exp-rhs (exp-lhs e)) &#39;=</div><div class="line">                         (mkexp (exp-rhs e)</div><div class="line">                                (inverse-op (exp-op (exp-lhs e)))</div><div class="line">                                (exp-lhs (exp-lhs e)))) x))</div><div class="line">        (t ;; Case V: A/f(X) = B -&gt; f(X) = A/B</div><div class="line">         (isolate (mkexp (exp-rhs (exp-lhs e)) &#39;=</div><div class="line">                         (mkexp (exp-lhs (exp-lhs e))</div><div class="line">                                (exp-op (exp-lhs e))</div><div class="line">                                (exp-rhs e))) x))))</div></div><!-- fragment --><p>Напомним, чтобы доказать правильность функции, мы должны доказать, что она то что она в конечном итоге завершается и дает правильный ответ. Для рекурсивной функции с несколькими альтернативными случаями мы должны показать, что каждая альтернатива действительна, а также что, каждая альтернатива каким-то образом приближается к концу (что любые рекурсивные вызовы включают 'более простые' аргументы). Для <code>isolate</code>, элементарная алгебра показывает, что каждый шаг верен, или по крайней мере, почти верен. Деление обоих частей уравнения на 0 не дает эквивалентного уравнения и мы никогда не проверяли этого. Также возможно, что подобные ошибки могут возникнуть во время вызова <code>eval</code>. Однако, мы предположим, что уравнение имеет единственное допустимое решение, тогда <code>isolate</code> выполняет только законные преобразования.</p>
<p>Труднее всего доказать, что <code>isolate</code> завершается. Случай I явно завершается, и все остальные вносят свой вклад в изоляцию неизвестного расположенного с левой стороны. Для любого уравнения, последовательность(sequence) будет первым из возможных вариантов использования случая II, за которым последует ряд рекурсивных вызовов использующих случаи от III до V. Количество вызовов ограничено числом подвыражений в уравнении, поскольку каждый последующий вызов эффективно удаляет выражение слева и помещает его справа. Следовательно, предполагая, что вход имеет конечный размер, мы должны в конечном итоге достичь рекуривного вызова для <code>isolate</code>, который будет использовать случай I и завершаться.</p>
<p>Когда <code>isolate</code> возвращается, правая часть должна состоять только из чисел и операторов. Мы могли бы легко написать функцию для вычисления такого выражения. Однако нам не нужно прилагать таких усилий, поскольку функция уже существует. Структура данных exp была тщательно выбрана, чтобы быть той же структурой (списками с префиксными функциям), какую использует и сам Lisp для своих собственных выражений. Таким образом, Lisp обнаружит, что правая часть является приемлемым выражением, которое может быть вычислено, если ввести его на верхнем уровне. Lisp вычисляет выражения, вызывая функцию <code>eval</code>, поэтому мы можем вызывать <code>eval</code> напрямую и получить возвращаемое из неё число. Функция <code>solve-arithmetic</code> возвращает уравнение вида (= <em>var number</em>).</p>
<p>Вспомогательные функции для <code>solve</code> показаны ниже. Большинство из них просты, но я отмечу некоторые из них. Функция <code>prefix-&gt;infix</code> принимает выражение в префиксной нотации и преобразует его в инфиксное выражение, полностью заключенное в скобки. В отличии от <code>isolate</code>, она предполагает, что выражения будут реализованы в виде списков. <code>prefix-&gt;infix</code> используется в <code>print-equations</code> для создания более читабельного вывода.</p>
<div class="fragment"><div class="line">(defun print-equations (header equations)</div><div class="line">  &quot;Print a list of equations.&quot;</div><div class="line">  (format t &quot;~%~a~{~%  ~{ ~a~}~}~%&quot; header</div><div class="line">          (mapcar #&#39;prefix-&gt;infix equations)))</div><div class="line"></div><div class="line">(defconstant operators-and-inverses</div><div class="line">  &#39;((+ -) (- +) (* /) (/ *) (= =)))</div><div class="line"></div><div class="line">(defun inverse-op (op)</div><div class="line">  (second (assoc op operators-and-inverses)))</div><div class="line"></div><div class="line">(defun unknown-p (exp)</div><div class="line">  (symbolp exp))</div><div class="line"></div><div class="line">(defun in-exp (x exp)</div><div class="line">  &quot;True if x appears anywhere in exp&quot;</div><div class="line">  (or (eq x exp)</div><div class="line">      (and (listp exp)</div><div class="line">           (or (in-exp x (exp-lhs exp)) (in-exp x (exp-rhs exp))))))</div><div class="line"></div><div class="line">(defun no-unknown (exp)</div><div class="line">  &quot;Returns true if there are no unknowns in exp.&quot;</div><div class="line">  (cond ((unknown-p exp) nil)</div><div class="line">        ((atom exp) t)</div><div class="line">        ((no-unknown (exp-lhs exp)) (no-unknown (exp-rhs exp)))</div><div class="line">        (t nil)))</div><div class="line"></div><div class="line">(defun one-unknown (exp)</div><div class="line">  &quot;Returns the single unknown in exp, if there is exactly one.&quot;</div><div class="line">  (cond ((unknown-p exp) exp)</div><div class="line">        ((atom exp) nil)</div><div class="line">        ((no-unknown (exp-lhs exp)) (one-unknown (exp-rhs exp)))</div><div class="line">        ((no-unknown (exp-rhs exp)) (one-unknown (exp-lhs exp)))</div><div class="line">        (t nil)))</div><div class="line"></div><div class="line">(defun commutative-p (op)</div><div class="line">  &quot;Is operator commutative?&quot;</div><div class="line">  (member op &#39;(+ * =)))</div><div class="line"></div><div class="line">(defun solve-arithmetic (equation)</div><div class="line">  &quot;Do the arithmetic for the right hand side.&quot;</div><div class="line">  ;; This assumes that the right hand side is in the right form.</div><div class="line">  (mkexp (exp-lhs equation) &#39;= (eval (exp-rhs equation))))</div><div class="line"></div><div class="line">(defun binary-exp-p (x)</div><div class="line">  (and (exp-p x) (= (length (exp-args x)) 2)))</div><div class="line"></div><div class="line">(defun prefix-&gt;infix (exp)</div><div class="line">  &quot;Translate prefix to infix expressions.&quot;</div><div class="line">  (if (atom exp) exp</div><div class="line">      (mapcar #&#39;prefix-&gt;infix</div><div class="line">              (if (binary-exp-p exp)</div><div class="line">                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))</div><div class="line">                  exp))))</div></div><!-- fragment --><p>Вот пример <code>solve-equations</code> в действии, с системой двух уравнений. Читатель должен пройти тарссировку, обнаруживая какой случай использовался при каждом вызове <code>isolate</code>, и проверяя правильность/точность каждого шага.</p>
<div class="fragment"><div class="line">&gt; (trace isolate solve)</div><div class="line">(isolate solve)</div><div class="line">&gt; (solve-equations &#39;((= (+  3 4) (* (- 5 (+  2 x)) 7))</div><div class="line">                            (= (+ (* 3 x) y) 12)))</div><div class="line">The equations to be solved are:</div><div class="line">      (3 + 4) = ((5 - (2 + X)) * 7)</div><div class="line">      ((3 * X) + Y) = 12</div><div class="line">(1 ENTER SOLVE: ((= (+  3 4) (* (- 5 (+  2 X)) 7))</div><div class="line">                            (= (+ (* 3 X) Y) 12)) NIL)</div><div class="line">    (1 ENTER ISOLATE: (= (+  3 4) (* (- 5 (+  2 X)) 7)) X)</div><div class="line">        (2 ENTER ISOLATE: (= (* (- 5 (+  2 X)) 7) (+  3 4)) X)</div><div class="line">            (3 ENTER ISOLATE: (= (- 5 (+  2 X)) (/ (+  3 4) 7)) X)</div><div class="line">                (4 ENTER ISOLATE: (= (+  2 X) (- 5 (/ (+  3 4) 7))) X)</div><div class="line">                    (5 ENTER ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)) X)</div><div class="line">                    (5 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))</div><div class="line">                (4 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))</div><div class="line">            (3 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))</div><div class="line">        (2 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))</div><div class="line">    (1 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))</div><div class="line">    (2 ENTER SOLVE: ((= (+ (* 3 2) Y) 12)) ((= X 2)))</div><div class="line">        (1 ENTER ISOLATE: (= (+ (* 3 2) Y) 12) Y)</div><div class="line">          (2 ENTER ISOLATE: (= Y (- 12 (* 3 2))) Y)</div><div class="line">          (2 EXIT ISOLATE: (= Y (- 12 (* 3 2))))</div><div class="line">        (1 EXIT ISOLATE: (= Y (- 12 (* 3 2))))</div><div class="line">        (3 ENTER SOLVE: NIL ((= Y 6) (= X 2)))</div><div class="line">        (3 EXIT SOLVE: ((= Y 6) (= X 2)))</div><div class="line">    (2 EXIT SOLVE: ((= Y 6) (= X 2)))</div><div class="line">(1 EXIT SOLVE: ((= Y 6) (= X 2)))</div><div class="line">The solution is:</div><div class="line">      Y = 6</div><div class="line">      X = 2</div><div class="line">NIL</div></div><!-- fragment --><p>Теперь давайте займемся строкой форматирования <code>"~%~a~{~% ~{ ~  a  ~}~}~*%"*</code> в <code>print-equations.</code> Она может показаться бессмысленной тарабарщиной, но на самом деле в ней есть определенный смысл. <code>format</code> обрабатывает строку, печатая каждый символьный знак, за исключением <code>"~"</code> указывающим на некоторые специальный действия форматирования, зависящие от следующего за ним знака. Комбинация <code>"~%"</code> печатает знак новой строки, а <code>"~a"</code> печатает следующий аргумент <code>format</code>, который еще не использовался. Таким образом четыре знака строки форматирования: <code>"~%~a"</code>, выводят знак новой строки, за которым следует аргумент <code>header</code>. Комбинация <code>"~{"</code> обрабатывает соответствующий аргумент как список, и обрабатывает каждый элемент списка в соответствии со спецификацией между <code>"~{"</code> и следующими <code>"~}"</code>. В данном случае, <code>equations</code> представлляет собой список уравнений, и каждое уравнение печатается с новой строки (<code>"~%"</code>) за которой следует два пробела, после чего следует обработка самого уравнения как списка, где каждый элемент печатается в формате <code>"~a"</code> с пробелом перед ним. Значение <code>t</code> указанное в качестве первого аргумента для <code>format</code> означает вывод на стандартный поток вывода; так же может быть указан другой выходной поток.</p>
<p>Одно из неприятных мелких упущений в Lisp заключается в том, что нет стандартного соглашения о том, где печатать знаки новой строки! В Си, например, самая первая строка кода в справочном руководстве выглядит так</p>
<div class="fragment"><div class="line">printf(&quot;hello, world\n&quot;);</div></div><!-- fragment --><p>Она ясно дает понять, что знак новой строки печатается <em>после</em> каждой линии. Это соглашение настолько укоренилось в мире UNIX, что некоторые UNIX программы будут уходить в бесконечный цикл, если последняя строка в файле не заканчивается знаком новой строки. В Лиспе, однако, функция <code>print</code> ставит знак новой строки <em>перед</em> печатаемым объектом и пробел после него. Некоторые программы на Лиспе переносят политику перехода на новую строку перед <code>format</code>, а другие используют политику перехода на новую строку после. Это становится проблемой только тогда, когда вы хотите объединить две программы, написанные под разными политиками. Как возникли две конкурирующие политики? В UNIX была только одна разумная политика, потому что весь ввод в интерпретатор UNIX (оболочку/shell) завершался знаками новой строки, поэтому небыло необходимости в предшествующем знаке новой строки. Однако в некоторых интерпетаторах Lisp ввод может быть завершен соответствующей правой круглой скобкой. В этом случае, требуется предшествующий знак новой строки, чтобы вывод не отображался в той же строке, что и ввод.</p>
<p><b>Упражнение 7.1 [m]</b> Реализуйте <code>print-equations</code> используя только примитивные функции печати, такие как <code>terpri</code> и <code>princ</code>, а также явные циклы.</p>
<h2>7.3 Примеры</h2>
<p>Теперь перейдем к примерам, взятым из диссертации Bobrow's. В первом примере, перед словом "then/что" необходимо вставить "what/затем", чтобы получить правильный ответ:</p>
<div class="fragment"><div class="line">&gt; (student &#39;(If the number of customers Tom gets is twice the square of</div><div class="line">            20 % of the number of advertisements he runs |,|</div><div class="line">            and the number of advertisements is 45 |,|</div><div class="line">            then what is the number of customers Tom gets ?))</div><div class="line">Решаемые уравнения:</div><div class="line">      CUSTOMERS = (2 * (((20 / 100) * ADVERTISEMENTS) *</div><div class="line">                      ((20 / 100) * ADVERTISEMENTS)))</div><div class="line">      ADVERTISEMENTS = 45</div><div class="line">      WHAT = CUSTOMERS</div><div class="line">Решение:</div><div class="line">      WHAT = 162</div><div class="line">      CUSTOMERS = 162</div><div class="line">      ADVERTISEMENTS = 45</div><div class="line">NIL</div></div><!-- fragment --><p>Обратите внимание, что наша программа печатает значения всех переменных, которые она может найти, в то время как программа Bobrow's выводила только те значения, которые явно были запрошены в тексте. Это пример того, что "больше значит меньше", т.е. напечатать все ответы может и впечатляюще, но на самом деле это легче сделать, чем решить, какие именно ответы следует распечатать. Следующий пример решен не правильно:</p>
<div class="fragment"><div class="line">&gt; (student &#39;(The daily cost of living for a group is the overhead cost plus</div><div class="line">            the running cost for each person times the number of people in</div><div class="line">            the group |.| This cost for one group equals $ 100 |,|</div><div class="line">            and the number of people in the group is 40 |.|</div><div class="line">            If the overhead cost is 10 times the running cost |,|</div><div class="line">            find the overhead and running cost for each person |.|))</div><div class="line">The equations to be solved are:</div><div class="line">      DAILY = (OVERHEAD + (RUNNING * PEOPLE))</div><div class="line">      COST = 100</div><div class="line">      PEOPLE = 40</div><div class="line">      OVERHEAD = (10 * RUNNING)</div><div class="line">      TO-FIND-1 = OVERHEAD</div><div class="line">      TO-FIND-2 = RUNNING</div><div class="line">The solution is:</div><div class="line">      PEOPLE = 40</div><div class="line">      COST = 100</div><div class="line">NIL</div></div><!-- fragment --><p>Этот пример указывает на два важных ограничения нашей версии student по сравнению с программой Bobrow's. Первая проблема заключается в именовании переменных. Фразы "the daily cost of living for a group(суточный прожиточный минимум для группы)" и "this cost(эта стоимость)" означают одно и тоже количество, но наша программа дает им имена <code>daily(день)</code> и <code>cost(стоимость)</code> соответственно. Программа Bobrow's обрабатывала названия, сначала рассматривая фразы как одинаковые, только если они идеально совпадали. Если результирущую систему уравнений нельзя было решить, она пыталась снова, на этот раз считая фразы с одинаковыми словами идентичными. (См. следующие упражнения.)</p>
<p>Другая проблема заключается в нашей функции <code>solve</code>. Предполагая, что мы правильно присвоили переменные, <code>solve</code> может свести набор уравнений к двум:</p>
<div class="fragment"><div class="line">100 = (OVERHEAD + (RUNNING * 40))</div><div class="line">OVERHEAD = (10 * RUNNING)</div></div><!-- fragment --><p>Это набор двух линейных уравнений с двумя неизвестными и имеет единственное решение при <code>RUNNING = 2, OVERHEAD = 20</code>. Но наша версия <code>solve</code> не смогла найти это решение, поскольку ищет уравнения с одним неизвестным. Вот еще один пример, с которым <code>student</code> хорошо справляется:</p>
<div class="fragment"><div class="line">&gt; (student &#39;(Fran&#39;s age divided by Robin&#39;s height is one half Kelly&#39;s IQ |.|</div><div class="line">            Kelly&#39;s IQ minus 80 is Robin&#39;s height |.|</div><div class="line">            If Robin is 4 feet tall |,| how old is Fran ?))</div><div class="line">The equations to be solved are:</div><div class="line">      (FRAN / ROBIN) = (KELLY / 2)</div><div class="line">      (KELLY - 80) = ROBIN</div><div class="line">      ROBIN = 4</div><div class="line">      HOW = FRAN</div><div class="line">The solution is:</div><div class="line">      HOW = 168</div><div class="line">      FRAN = 168</div><div class="line">      KELLY = 84</div><div class="line">      ROBIN = 4</div><div class="line">NIL</div></div><!-- fragment --><p>Но небольшое изменение приводит к проблеме:</p>
<div class="fragment"><div class="line">&gt; (student &#39;(Fran&#39;s age divided by Robin&#39;s height is one half Kelly&#39;s IQ |.|</div><div class="line">            Kelly&#39;s IQ minus 80 is Robin&#39;s height |.|</div><div class="line">            If Robin is 0 feet tall |,| how old is Fran ?))</div><div class="line">The equations to be solved are:</div><div class="line">      (FRAN / ROBIN) = (KELLY / 2)</div><div class="line">      (KELLY - 80) = ROBIN</div><div class="line">      ROBIN = 0</div><div class="line">      HOW = FRAN</div><div class="line">The solution is:</div><div class="line">      HOW = 0</div><div class="line">      FRAN = 0</div><div class="line">      KELLY = 80</div><div class="line">      ROBIN = 0</div><div class="line">NIL</div></div><!-- fragment --><p>У этой проблемы нет правильного решения, потому что она предполагает деление на 0 (Robin's height). Но <code>student</code> готов преобразовать первое уравенение в:</p>
<div class="fragment"><div class="line">FRAN = ROBIN * (KELLY / 2)</div></div><!-- fragment --><p>и затем подставить полученный <code>0</code> для <code>FRAN</code>. Хуже того, деление на ноль, может появиться внутри <code>eval</code>:</p>
<div class="fragment"><div class="line">&gt; (student &#39;(Fran&#39;s age times Robin&#39;s height is one half Kelly&#39;s IQ |.|</div><div class="line">            Kelly&#39;s IQ minus 80 is Robin&#39;s height |.|</div><div class="line">            If Robin is 0 feet tall |,| how old is Fran ?))</div><div class="line">The equations to be solved are:</div><div class="line">      (FRAN * ROBIN) = (KELLY / 2)</div><div class="line">      (KELLY - 80) = ROBIN</div><div class="line">      ROBIN = 0</div><div class="line">      HOW = FRAN</div><div class="line">&gt;&gt;Error: There was an attempt to divide a number by zero</div></div><!-- fragment --><p>Однако можно утверждать, что неприятные примеры с делением на ноль не встречаются в текстах по алгебре.</p>
<p>Таким образом, STUDENT ведет себя достаточно хорошо, делая гораздо больше, чем просто игрушечная программа ELIZA. STUDENT так же довольно эффективен; на моей машине для каждого из предыдущих примеров требуется меньше одной секунды. Однако, его все еще можно расширить, чтобы иметь более мощные возможности для решения уравнений. Другое дело - его лингвистический охват. Хотя можно добавлять новые шаблоны, она на самом деле являются лишь уловками и не отражают основную структуру английских предложений. Вот почему подход принятый в STUDENT был оставлен как тема для исследования.</p>
<h2>7.4 История и ссылки</h2>
<p>Bobrow's Ph.D. thesis contains a complete description of STUDENT. It is reprinted in <a href="B9780080571157500285.xhtml#bb0845">Minsky 1968</a>. Since then, there have been several systems that address the same task, with increased sophistication in both their mathematical and linguistic ability. <a href="B9780080571157500285.xhtml#bb1420">Wong (1981)</a> describes a system that uses its understanding of the problem to get a better linguistic analysis. <a href="B9780080571157500285.xhtml#bb1195">Sterling et al. (1982)</a> present a much more powerful equation solver, but it does not accept natural language input. Certainly Bobrow's language analysis techniques were not very sophisticated by today's measures. But that was largely the point: if you know that the language is describing an algebraic problem of a certain type, then you don't need to know very much linguistics to get the right answer most of the time.</p>
<h2>7.5 Упражнения</h2>
<p><b>Exercise 7.2 [h]</b> Ранее мы говорили, что наша программа не может решать пары линейных уравнений, например:</p>
<div class="fragment"><div class="line">100 = (OVERHEAD + (RUNNING * 40))</div><div class="line">OVERHEAD = (10 * RUNNING)</div></div><!-- fragment --><p>Первоначальная программа STUDENT могла решить эти уравнения. Напишите Write a routine to do so. You may assume there will be only two equations in two unknowns if you wish, or if you are more ambitious, you could solve a system of <em>n</em> linear equations with <em>n</em> unknowns.</p>
<p><b>Exercise 7.3 [h]</b> Реализуйте версию алгоритма именования переменных Боброу. Вместо того, чтобы брать первое слово каждого уравнения, создайте уникальный символ и свяжите с ним весь список слов. На первом проходе каждый неравный список слов будет считаться отдельной переменной. Если решение не достигнуто, списки слов, которые имеют общие слова, считайте одной и той же переменной, и попытка решения предпринимается снова. Например, входные данные, содержащие фразы "the rectangle's width"(ширина прямоугольника) и "the width of the rectangle"(ширина прямоугольника), могут присвоить этим двум фразам переменные <code>v1</code> и<code>v2</code>. Если попытка решить проблему не дает решения, программа должна понять, что <code>v1</code> и <code>v2</code> имеют общие слова "rectangle"(прямоугольник) и "width"(ширина), и добавить уравнение (<code>= v1 v2</code>) и повторить попытку. Поскольку переменные являются произвольными символами, процедура печати, вероятно, должна печатать фразы, связанные с каждой переменной, а не с саму переменную.</p>
<p><b>Exercise 7.4 [h]</b> Первоначальный STUDENT также имел набор «общеизвестных» уравнений, которые он мог использовать при необходимости. В основном это были факты о коэффициентах преобразования, например (<code>1 inch = 2.54 cm</code>), т.е. 1 дюйм = 2,54 см». Также были включены уравнения типа (<code>distance equal s rate times time</code>), т.е. расстояние равно скорости умноженной на время, которые можно было использовать для решения таких задач, как: If the distance from Anabru to Champaign is 10 miles and the time it takes Sandy to travel this distance is 2 hours, what is Sandy's rate of speed?"(Если расстояние от Анабру до Шампейна составляет 10 миль, а время, необходимое Сэнди, чтобы преодолеть это расстояние, составляет 2 часа, то какое скорость Сэнди?) Внесите изменения, чтобы включить эту возможность. Вероятно, это помогает только в сочетании с решением предыдущего упражнения.</p>
<p><b>Exercise 7.5 [h]</b> Измените <code>student</code> так, чтобы он печатал значения только тех переменных, которые запрашиваются в задаче. То есть, если дана задача "X равно 3. Y равно 4. Сколько X + Y?" Он не должен печатать значения для X и Y.</p>
<p><b>Exercise 7.6 [m]</b> Попробуйте STUDENT по следующим примерам. Убедитесь, что вы правильно обрабатываете специальные символы:</p>
<p>(a) The price of a radio is 69.70 dollars. If this price is 15% less than the marked The number of soldiers the Russians have is one half of the number of guns !!!(p) {:.numlist1}</p>
<p>(b) The number of soldiers the Russians have is one half of the number of guns they have. The number of guns they have is 7000. What is the number of soldiers they have? !!!(p) {:.numlist1}</p>
<p>(c) If the number of customers Tom gets is twice the square of 20 % of the number of advertisements he runs, and the number of advertisements is 45, and the profit Tom receives is 10 times the number of customers he gets, then what is the profit? !!!(p) {:.numlist1}</p>
<p>(d) The average score is 73. The maximum score is 97. What is the square of the difference between the average and the maximum? !!!(p) {:.numlist1}</p>
<p>(e) Tom is twice Mary's age, and Jane's age is half the difference between Mary and Tom. If Mary is 18 years old, how old is Jane? !!!(p) {:.numlist1}</p>
<p>(f) What is 4 + 5* 14/7? !!!(p) {:.numlist1}</p>
<p>(g) <em>x x b = c + d. b x c = x. x = b + b. b = 5.</em> !!!(p) {:.numlist1}</p>
<p><b>Exercise 7.7 [h]</b> Инфиксно-префиксные правила <code>Student</code> правильно учитывают приоритет операторов, но они не обрабатывают ассоциативность стандартным образом. Например, (<code>12 - 6 - 3</code>) переводится как (<code>- 12 (- 6 3)</code>) или <code>9</code>, когда обычное соглашение интерпретирует это как (<code>- (- 12 6) 3</code>) или «3». Исправьте ученика, чтобы он справился с этим соглашением.</p>
<p><b>Exercise 7.8 [d]</b> Найдите математически ориентированную область, достаточно ограниченную, чтобы STUDENT мог решать в ней задачи. Примером может служить химия растворов (расчет концентраций pH). Напишите необходимые <code>*student-rules*</code> и протестируйте полученную программу.</p>
<p><b>Exercise 7.9 [m]</b> Проанализируйте сложность <code>one-unknown</code> и внедрите более эффективную версию.</p>
<p><b>Exercise 7.10 [h]</b> Статья Боброу о STUDENT (1968) включает приложение, в котором абстрактно описываются все проблемы, которые может решить его система. Создайте аналогичную характеристику для этой версии программы.</p>
<h2>7.6 Ответы</h2>
<p><b>Answer 7.1</b></p>
<div class="fragment"><div class="line">(defun print-equations (header equations)</div><div class="line">    (terpri)</div><div class="line">    (princ header)</div><div class="line">    (dolist (equation equations)</div><div class="line">        (terpri)</div><div class="line">        (princ &quot; &quot;)</div><div class="line">        (dolist (x (prefix-&gt;infix equation))</div><div class="line">            (princ &quot; &quot;)</div><div class="line">            (princ x))))</div></div><!-- fragment --><p><b>Answer 7.9</b><code>one-unknown</code> очень неэффективен, потому что он ищет каждый подкомпонент выражения дважды. Например, рассмотрим уравнение:</p>
<p><code>(= (+ (+</code> x <code>2) (+ 3 4)) (+ (+ 5 6) (+ 7 8)))</code></p>
<p>Чтобы решить, есть ли у него одно неизвестное, <code>one-unknown</code> вызовет <code>no-unknown</code> в левой части, и, поскольку он не работает, вызовет его снова в правой части. Хотя нужно рассмотреть только восемь атомов, в конечном итоге он вызывает «<code>no-unknown 17</code> раз и <code>one-unknown 4</code> раза. В общем, для дерева глубины <em>n</em> выполняется примерно <em>2n</em> вызовов <code>no-unknown</code>. Это явно расточительно; нет необходимости смотреть на каждый компонент более одного раза.</p>
<p>В следующей версии используется вспомогательная функция, <code>find-one-unknown</code>, у которой есть аккумулирующий параметр ʻunknown<code>. Этот параметр может принимать три возможных значения: nil, что указывает на то, что ничего неизвестного не найдено; или единственное неизвестное, что было найдено до сих пор; или число 2, указывающее, что были обнаружены два неизвестных, и поэтому окончательный результат должен быть равен нулю. Функция</code>find-one-unknown` имеет четыре случая: (1) Если мы уже нашли два неизвестных, то верните 2, чтобы указать это. (2) Если входное выражение является неатомарным выражением, то сначала посмотрите на его левую часть на предмет неизвестных и передайте результат, найденный на этой стороне, в качестве аккумулятора для поиска правой части. (3) Если выражение неизвестно, и если это второе найденное выражение, вернуть <code>2</code>; в противном случае верните само неизвестное. (4) Если выражение представляет собой атом, который не является неизвестным, просто верните накопленный результат.</p>
<div class="fragment"><div class="line">(defun one-unknown (exp)</div><div class="line">    &quot;Returns the single unknown in exp, if there is exactly one.&quot;</div><div class="line">    (let ((answer (find-one-unknown exp nil)))</div><div class="line">        ;; If there were two unknowns, return nil;</div><div class="line">        ;; otherwise return the unknown (if there was one)</div><div class="line">        (if (eql answer 2)</div><div class="line">              nil</div><div class="line">              answer)))</div><div class="line">(defun find-one-unknown (exp unknown)</div><div class="line">    &quot;Assuming UNKNOWN is the unknown(s) found so far, decide</div><div class="line">    if there is exactly one unknown in the entire expression.&quot;</div><div class="line">    (cond ((eql unknown 2) 2)</div><div class="line">                ((exp-p exp)</div><div class="line">                    (find-one-unknown</div><div class="line">                        (exp-rhs exp)</div><div class="line">                        (find-one-unknown (exp-lhs exp) unknown)))</div><div class="line">                ((unknown-p exp)</div><div class="line">                    (if unknown</div><div class="line">                            2</div><div class="line">                            exp))</div><div class="line">                (t unknown)))</div></div><!-- fragment --> <hr/>
<p><a href="#xfn0015">1</a><a href="B9780080571157500108.xhtml#p316">Page 316</a> of <em>Common Lisp the Language</em> says, "Because a constructor of this type operates By Order of Arguments, it is sometimes known as a BOA constructor." !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
