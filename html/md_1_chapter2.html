<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Простая Лисп Программа</h2>
<blockquote class="doxtable">
<p><em>Убедитесь, что это произошло.</em> </p>
</blockquote>
<blockquote class="doxtable">
<p>(Человек уверен только в том, что он создает.) </p>
</blockquote>
<blockquote class="doxtable">
<p>-Giovanni Battista Vico (1668-1744) </p>
</blockquote>
<blockquote class="doxtable">
<p>Italian royal historiographer </p>
</blockquote>
<p>Вы никогда не станете хорошо владеть иностранным языком, изучая словари. Будет лучше, если вы будете слышать и говорить (или читать и писать) на языке, чтобы получить навыки. То же самое верно и для изучения компьютерных языков.</p>
<p>В этой главе показано, как объединить основные функции и специальные формы Lisp в целостную программу. Если вы научитесь этому, то освоить оставшийся словарный запас Lisp (как описано в главе 3) будет легко.</p>
<h2>2.1 Грамматика для подмножества английского языка</h2>
<p>Программа, которую мы разработаем в этой главе, генерирует случайные английские предложения. Вот простая грамматика для крошечной части английского языка:</p>
<blockquote class="doxtable">
<p><em>Sentence</em> =&gt; <em>Noun-Phrase + Verb-Phrase</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Noun-Phrase</em> =&gt; <em>Article + Noun</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Verb-Phrase</em> =&gt; <em>Verb + Noun-Phrase</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Article</em> =&gt; <em>the, a,...</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Noun</em> =&gt; <em>man, ball, woman, table...</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Verb</em> =&gt; <em>hit, took, saw, liked...</em> </p>
</blockquote>
<p>Чтобы быть техническим, это описание называется "контекстно-свободной грамматикой структуры фразы", а лежащая в ее основе парадигма называется "генеративным синтаксисом". Идея заключается в том, что в любом месте, где мы хотим предложение, мы можем создать noun phrase (именная фраза), за которым следует verb phrase(глагольная фраза). Везде, где была указана noun phrase (именная фраза), мы генерируем вместо нее article (артикль), за которым следует noun (существительное). Где бы ни была указан article (артикль), мы генерируем либо "the", либо "a", либо какой-то другой артикль. Формализм является "контекстно-свободным", потому что правила применяются везде, независимо от окружающих слов, а подход является "генеративным", потому что правила в целом определяют полный набор предложений в языке (а также, набор бессмысленностей). Ниже мы покажем вывод одного предложения с помощью этих правил:</p>
<ul>
<li>Чтобы получить предложение - <em>Sentence</em>, добавьте <em>Noun-Phrase</em> и <em>Verb-Phrase</em><ul>
<li>Чтобы получить именную фразу <em>Noun-Phrase</em>, добавьте артикль <em>Article</em> и существительное <em>Noun</em><ul>
<li>Выбираем *"the"* для артикля <em>Article</em></li>
<li>Выбираем *"man"* для существительного <em>Noun</em></li>
</ul>
</li>
<li>Результирующая именная фраза <em>Noun-Phrase</em> будет *"the man"*</li>
<li>Чтобы получить глагольную фразу <em>Verb-Phrase,</em> добавьте глагол <em>Verb</em> и именную фразу <em>Noun-Phrase</em><ul>
<li>Выбираем *"hit"* для глагола <em>Verb</em></li>
<li>Чтобы получить именную фразу <em>Noun-Phrase</em>, добвьте артикль <em>Article</em> и существительное <em>Noun</em><ul>
<li>Выбираем *"the"* для артикля <em>Article</em></li>
<li>Выбираем *"ball"* для существительного <em>Noun</em></li>
</ul>
</li>
<li>Результирующая именная фраза <em>Noun-Phrase</em> будет *"the ball"*</li>
</ul>
</li>
<li>Результирующая глагольная фраза <em>Verb-Phrase</em> будет *"hit the ball"*</li>
</ul>
</li>
<li>Результирующее предложение <em>Sentence</em> будет *"The man hit the ball"*</li>
</ul>
<h2>2.2 Простое Решение</h2>
<p>Мы разработаем программу, которая генерирует случайные предложения из грамматики структуры фразы. Самый простой подход заключается в представлении каждого грамматического правила отдельной функцией Lisp:</p>
<div class="fragment"><div class="line">(defun sentence ()    (append (noun-phrase) (verb-phrase)))</div><div class="line">(defun noun-phrase () (append (Article) (Noun)))</div><div class="line">(defun verb-phrase () (append (Verb) (noun-phrase)))</div><div class="line">(defun Article ()     (one-of &#39;(the a)))</div><div class="line">(defun Noun ()        (one-of &#39;(man ball woman table)))</div><div class="line">(defun Verb ()        (one-of &#39;(hit took saw liked)))</div></div><!-- fragment --><p>Каждое из этих определений функций имеет пустой список параметров <code>()</code>. Это означает, что функции не принимают аргументов. Это необычно, потому что, строго говоря, функция без аргументов всегда будет возвращать одно и то же, поэтому мы можем использовать константу вместо неё. Однако эти функции используют функцию <code>random</code> (как мы вскоре увидим) и, таким образом, могут возвращать различные результаты даже без аргументов. Таким образом, они не являются функциями в математическом смысле, но они все еще называются функциями в Lisp, потому что они возвращают значение.</p>
<p>Теперь остается только определить функцию "один из" - <code>one-of</code>. Она принимает список возможных вариантов в качестве аргумента, выбирает один из них наугад и возвращает одноэлементный список выбранного элемента. Эта последняя часть предназначена для того, чтобы все функции в грамматике возвращали список слов, пусть даже и одноэлементный. Таким образом, мы можем свободно применять <code>append</code> к любой категории.</p>
<div class="fragment"><div class="line">(defun one-of (set)</div><div class="line">  &quot;Выбирает один элемент набора и составляет из него список.&quot;</div><div class="line">  (list (random-elt set)))</div><div class="line"></div><div class="line">(defun random-elt (choices)</div><div class="line">  &quot;Выбирает элемент из списка наугад&quot;</div><div class="line">  (elt choices (random (length choices))))</div></div><!-- fragment --><p>Здесь используются две новые функции: <code>elt</code> и <code>random</code>. <code>elt</code> выбирает элемент из списка. Первый аргумент - это список, а второй - позиция в списке. Путаница заключается в том, что позиции начинаются с 0, поэтому <code>(elt choices 0)</code> является первым элементом списка, а <code>(elt choices 1)</code> - вторым. Считайте, что номера позиций говорят вам, как далеко вы находитесь от начала списка. Выражение <code>(random n)</code> возвращает целое число от 0 до n-1, так что <code>(random 4)</code> вернет либо 0, либо 1, либо 2, либо 3.</p>
<p>Теперь мы можем протестировать программу, создав несколько случайных предложений, а также фразу существительного(noun) и глагола(verb):</p>
<div class="fragment"><div class="line">&gt; (sentence) =&gt; (THE WOMAN HIT THE BALL)</div><div class="line"></div><div class="line">&gt; (sentence) =&gt; (THE WOMAN HIT THE MAN)</div><div class="line"></div><div class="line">&gt; (sentence) =&gt;(THE BALL SAW THE WOMAN)</div><div class="line"></div><div class="line">&gt; (sentence) =&gt; (THE BALL SAW THE TABLE)</div><div class="line"></div><div class="line">&gt; (noun-phrase) =&gt; (THE MAN)</div><div class="line"></div><div class="line">&gt; (verb-phrase) =&gt; (LIKED THE WOMAN)</div><div class="line"></div><div class="line">&gt; (trace sentence noun-phrase verb-phrase article noun verb) =&gt;</div><div class="line">(SENTENCE NOUN-PHRASE VERB-PHRASE ARTICLE NOUN VERB)</div><div class="line"></div><div class="line">&gt; (sentence) =&gt;</div><div class="line">(1 ENTER SENTENCE)</div><div class="line">  (1 ENTER NOUN-PHRASE)</div><div class="line">    (1 ENTER ARTICLE)</div><div class="line">    (1 EXIT ARTICLE: (THE))</div><div class="line">    (1 ENTER NOUN)</div><div class="line">    (1 EXIT NOUN: (MAN))</div><div class="line">  (1 EXIT NOUN-PHRASE: (THE MAN))</div><div class="line">  (1 ENTER VERB-PHRASE)</div><div class="line">    (1 ENTER VERB)</div><div class="line">    (1 EXIT VERB: (HIT))</div><div class="line">    (1 ENTER NOUN-PHRASE)</div><div class="line">      (1 ENTER ARTICLE)</div><div class="line">      (1 EXIT ARTICLE: (THE))</div><div class="line">      (1 ENTER NOUN)</div><div class="line">      (1 EXIT NOUN: (BALL))</div><div class="line">    (1 EXIT NOUN-PHRASE: (THE BALL))</div><div class="line">  (1 EXIT VERB-PHRASE: (HIT THE BALL))</div><div class="line">(1 EXIT SENTENCE: (THE MAN HIT THE BALL))</div><div class="line">(THE MAN HIT THE BALL)</div></div><!-- fragment --><p>Программа работает нормально, и трассировка выглядит точно так же, как пример деривации выше, но определения Lisp немного сложнее читать, чем исходные грамматические правила. Эта проблема будет усугубляться по мере рассмотрения более сложных правил. Предположим, мы хотим, чтобы noun phrases(именые фразы) были изменены неопределенным числом прилагательных(adjectives) и неопределенным числом предложных фраз(prepositional phrases). В грамматической нотации у нас могут быть следующие правила:</p>
<blockquote class="doxtable">
<p>*Noun-Phrase =&gt; Article + Adj* + Noun + PP* </p>
</blockquote>
<blockquote class="doxtable">
<p>Adj* =&gt; 0&amp;#x0338;, Adj + Adj* </p>
</blockquote>
<blockquote class="doxtable">
<p>PP* =&gt; 0&amp;#x0338;, PP + PP* </p>
</blockquote>
<blockquote class="doxtable">
<p>PP =&gt; Prep + Noun-Phrase </p>
</blockquote>
<blockquote class="doxtable">
<p>Adj =&gt; big, little, blue, green, ... </p>
</blockquote>
<blockquote class="doxtable">
<p>Prep =&gt; to, in, by, with, ...* </p>
</blockquote>
<p>В этой нотации 0&amp;#x0338; указывает на выбор пустоты, запятая указывает на выбор нескольких альтернатив, а звездочка не является чем-то особенным-как и в Lisp, это просто часть имени символа. Однако здесь используется соглашение, что имена, заканчивающиеся звездочкой, обозначают ноль или более повторений основного имени. То есть, <em>PP*</em> означает ноль или более повторений <em>PP</em>.  Это обозначение известно как "звезда Клина" (произносится как "clean-E") в честь математика Стивена Коула Клина.<a href="#fn02-1">1</a></p>
<p>Проблема в том, что правила для <em>Adj*</em> и <em>PP*</em> содержат варианты выбора, которые мы должны были бы представить как своего рода условия в Lisp. Например:</p>
<div class="fragment"><div class="line">(defun Adj* ()</div><div class="line">  (if (= (random 2) 0)</div><div class="line">      nil</div><div class="line">      (append (Adj) (Adj*))))</div><div class="line"></div><div class="line">(defun PP* ()</div><div class="line">  (if (random-elt &#39;(t nil))</div><div class="line">      (append (PP) (PP*))</div><div class="line">      nil))</div><div class="line"></div><div class="line">(defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))</div><div class="line">(defun PP () (append (Prep) (noun-phrase)))</div><div class="line">(defun Adj () (one-of &#39;(big little blue green adiabatic)))</div><div class="line">(defun Prep () (one-of &#39;(to in by with on)))</div></div><!-- fragment --><p>Я выбрал две различные реализации для <code>Adj*</code> и <code>PP*</code>; любой подход будет работать в любой функции. Однако мы должны быть осторожны; вот два подхода, которые не сработают:</p>
<div class="fragment"><div class="line">(defun Adj* ()</div><div class="line">  &quot;Warning - incorrect definition of Adjectives.&quot;</div><div class="line">  (one-of &#39;(nil (append (Adj) (Adj*)))))</div><div class="line">(defun Adj* ()</div><div class="line">  &quot;Warning - incorrect definition of Adjectives.&quot;</div><div class="line">  (one-of (list nil (append (Adj) (Adj*)))))</div></div><!-- fragment --><p>Первое определение неверно, потому что оно может возвращать буквальное выражение <code>((append (Adj) (Adj*)))</code>, а не список слов, как ожидается. Второе определение вызвало бы бесконечную рекурсию, потому что вычисление значения <code>(Adj*)</code> всегда включает рекурсивный вызов <code>(Adj*)</code>. Дело в том, что то, что начиналось как простые функции, теперь становится довольно сложным. Чтобы понять их, нам нужно знать многие соглашения Lisp - <code>defun, (), case, if</code>, <code>quote</code> и правила порядка вычисления-когда в идеале реализация грамматического правила должна использовать только <em>лингвистические</em> соглашения. Если бы мы хотели разработать более широкую грамматику, проблема могла бы стать еще хуже, потому что автор правил мог бы все больше и больше зависеть от Lisp.</p>
<h2>2.3 Решение, Основанное На Правилах</h2>
<p>Альтернативная реализация этой программы сосредоточилась бы на упрощении написания грамматических правил и позже беспокоилась бы о том, как они будут обработаны. Давайте еще раз посмотрим на исходные грамматические правила:</p>
<blockquote class="doxtable">
<p>*Sentence =&gt; Noun-Phrase + Verb-Phrase </p>
</blockquote>
<blockquote class="doxtable">
<p>Noun-Phrase =&gt; Article + Noun </p>
</blockquote>
<blockquote class="doxtable">
<p>Verb-Phrase =&gt; Verb + Noun-Phrase </p>
</blockquote>
<blockquote class="doxtable">
<p>Article =&gt; the, a, ... </p>
</blockquote>
<blockquote class="doxtable">
<p>Noun =&gt; man, ball, woman, table... </p>
</blockquote>
<blockquote class="doxtable">
<p>Verb =&gt; hit, took, saw, liked...* </p>
</blockquote>
<p>Каждое правило состоит из Стрелки с символом на левой стороне и еще чего-то на правой стороне. Сложность заключается в том, что правые стороны могут быть двух видов: объединенный список символов, как в "Noun-Phrase =&gt; Article+Noun", или список альтернативных слов, как в "Noun =&gt; man, ball, ..." Мы можем учесть эти возможности, решив, что каждое правило будет иметь список возможностей в правой части, и что объединенный список, <em>например</em> "Article+Noun", будет представлен как список Lisp, <em>например</em> "(Article Noun)". Затем список правил можно представить следующим образом:</p>
<div class="fragment"><div class="line">(defparameter *simple-grammar*</div><div class="line">  &#39;((sentence -&gt; (noun-phrase verb-phrase))</div><div class="line">    (noun-phrase -&gt; (Article Noun))</div><div class="line">    (verb-phrase -&gt; (Verb noun-phrase))</div><div class="line">    (Article -&gt; the a)</div><div class="line">    (Noun -&gt; man ball woman table)</div><div class="line">    (Verb -&gt; hit took saw liked))</div><div class="line">  &quot;A grammar for a trivial subset of English.&quot;)</div><div class="line"></div><div class="line">(defvar *grammar* *simple-grammar*</div><div class="line">  &quot;The grammar used by generate.  Initially, this is</div><div class="line">  *simple-grammar*, but we can switch to other grammars.&quot;)</div></div><!-- fragment --><p>Обратите внимание, что Лисп-версия правил близко имитирует исходную версию. В частности, я включаю символ "-&gt;", хотя он не служит никакой реальной цели; он чисто декоративный.</p>
<p>Специальные формы <code>defvar</code> и <code>defparameter</code> вводят специальные переменные и присваивают им значение; разница заключается в том, что <em>переменная</em> такая как <code>*grammar*</code>, регулярно изменяется в ходе выполнения программы. С другой стороны, <em>параметр</em>, такой как <code>*simple-grammar*</code>, обычно остается постоянным. Изменение параметра считается <em>изменением программы</em>, а не изменением выполняемым <em>самой программой</em>.</p>
<p>После того, как список правил был определен, он может использоваться, чтобы найти возможные перезаписи данного символа-category. Функция <code>assoc</code> предназначена именно для такого рода задач. Она принимает два аргумента, "key"(ключ) и список списков, и возвращает первый элемент списка списков, который начинается с переданного ключа. Если его нет, она возвращает <code>nil</code>. Вот вам пример:</p>
<div class="fragment"><div class="line">&gt; (assoc &#39;noun *grammar*) =&gt; (NOUN -&gt; MAN BALL WOMAN TABLE)</div></div><!-- fragment --><p>Хотя правила довольно просто реализованы в виде списков, хорошей идеей является наложение уровня абстракции путем определения функций для работы с правилами. Нам понадобятся три функции: одна для получения правой части правила, одна для левой части и одна для поиска всех возможных переписываний (правых частей) для категории(category).</p>
<div class="fragment"><div class="line">(defun rule-lhs (rule)</div><div class="line">  &quot;The left hand side of a rule.&quot;</div><div class="line">  (first rule))</div><div class="line"></div><div class="line">(defun rule-rhs (rule)</div><div class="line">  &quot;The right hand side of a rule.&quot;</div><div class="line">  (rest (rest rule)))</div><div class="line"></div><div class="line">(defun rewrites (category)</div><div class="line">  &quot;Возвращает список возможных перезаписей для данной категории.&quot;</div><div class="line">  (rule-rhs (assoc category *grammar*)))</div></div><!-- fragment --><p>Определение этих функций облегчит чтение программ, которые их используют, а также облегчит изменение представления правил, если мы когда-либо решим это сделать.</p>
<p>Теперь мы готовы рассмотреть главную проблему: определить функцию, которая будет генерировать предложения (или именные фразы/noun phrases, или любую другую категорию). Мы будем называть эту функцию <code>generate</code>. Ей придется разбираться с тремя случаями: (1) в простейшем случае <code>generate</code> передается символ, с которым связан набор правил перезаписи. Мы выбираем одно из них наугад, а затем генерируем из него.(второе условие в программе) (2) Если символ не имеет возможных правил перезаписи, он должен быть терминальным символом-словом, а не грамматической категорией,-и мы оставляем его в покое.(третье условие в программе - по умолчанию) На самом деле, мы возвращаем список с этим входным словом, потому что, как и в предыдущей программе, мы хотим, чтобы все результаты были списками слов. (3) в некоторых случаях, когда символ присутствует в rewrites(т.е. является нетерминальным символом/категорией), мы выберем один из списка символов ему соответствующих и попытаемся сгенерировать уже из этого символа.(второе условие в программе) Таким образом, <code>generate</code> также должна принимать список в качестве входных данных, и в этом случае она должна выполнить генерацию для каждого элемента списка (первое условие в программе), а затем соединить(append) их все вместе. Итак, первое предложение в <code>generate</code> обрабатывает этот случай, в то время как второе предложение обрабатывает (1) и третье предложение - обрабатывает (2). Обратите внимание, что мы использовали функцию <code>mappend</code> из раздела 1.7 (стр. 18).</p>
<div class="fragment"><div class="line">(defun generate (phrase)</div><div class="line">  &quot;Generate a random sentence or phrase&quot;</div><div class="line">  (cond ((listp phrase)</div><div class="line">         (mappend #&#39;generate phrase))</div><div class="line">        ((rewrites phrase)</div><div class="line">         (generate (random-elt (rewrites phrase))))</div><div class="line">        (t (list phrase))))</div></div><!-- fragment --><p>Как и многие программы в этой книге, эта функция коротка, но насыщена информацией: Искусство программирования включает в себя знание того, что писать, а также того, чего <em>не</em> писать.</p>
<p>Этот стиль программирования называется программирование управляемое данными (<em>data-driven</em> programming), потому что данные (список перезаписей, связанных с категорией) управляют тем, что программа делает дальше. Это естественный и простой в использовании стиль программирования в Lisp, приводящий к сжатым и расширяемым программам, потому что всегда можно добавить новый фрагмент данных с новой ассоциацией без необходимости изменять исходную программу.</p>
<p>Вот несколько примеров использования функции <code>generate</code>:</p>
<div class="fragment"><div class="line">&gt; (generate &#39;sentence) =&gt; (THE TABLE SAW THE BALL)</div><div class="line"></div><div class="line">&gt; (generate &#39;sentence) =&gt; (THE WOMAN HIT A TABLE)</div><div class="line"></div><div class="line">&gt; (generate &#39;noun-phrase) =&gt; (THE MAN)</div><div class="line"></div><div class="line">&gt; (generate &#39;verb-phrase) (TOOK A TABLE)</div></div><!-- fragment --><p>Существует множество возможных способов написать <code>generate</code>. Следующая версия использует <code>if</code> вместо `<code>cond</code>:</p>
<div class="fragment"><div class="line">(defun generate (phrase)</div><div class="line">  &quot;Generate a random sentence or phrase&quot;</div><div class="line">  (if (listp phrase)</div><div class="line">      (mappend #&#39;generate phrase)</div><div class="line">      (let ((choices (rewrites phrase)))</div><div class="line">        (if (null choices)</div><div class="line">            (list phrase)</div><div class="line">            (generate (random-elt choices))))))</div></div><!-- fragment --><p>В этой версии используется специальная форма <code>let</code>, которая вводит новую переменную (в данном случае <code>choices</code>), а также связывает переменную со значением. В этом случае введение переменной избавляет нас от вызова функции <code>rewrites</code> дважды, как это было сделано в версии <code>generate</code> с <code>cond</code>. Общая форма формы <code>let</code> такова::</p>
<div class="fragment"><div class="line">`(let` ((*var value*)...)</div><div class="line">    *body-containing-vars*)</div></div><!-- fragment --><p><code>let</code> - это наиболее распространенный способ введения переменных, которые не являются параметрами функций. Нужно сопротивляться искушению использовать переменную, не вводя ее:</p>
<div class="fragment"><div class="line">(defun generate (phrase)</div><div class="line">  (setf choices ...)         ;; wrong!</div><div class="line">  ... choices ...)</div></div><!-- fragment --><p> Это неверно, потому что символ <code>choices</code> теперь относится к специальной или глобальной переменной, которая может быть разделяться или изменяться другими функциями. Таким образом, эта версия функции <code>generate</code> ненадежна, поскольку нет никакой гарантии, что <code>choices</code> сохранит то же самое значение с момента его установки(связывания/присваивания) до момента, когда на него снова ссылаются(когда его будут использовать). С помощью <code>let</code> мы вводим совершенно новую переменную, к которой никто другой не может получить доступ; поэтому она гарантированно сохраняет правильное значение.</p>
<p>&amp;#9635; <b>Упражнение 2.1 [м]</b> написать версию <code>generate</code>, которая использует <code>cond</code> но избегает вызова называть <code>rewrites</code> дважды.</p>
<p>&amp;#9635; <b>Упражнение 2.2 [m]</b> напишите версию <code>generate</code>, которая явно различает терминальные символы (те, которые не имеют правил перезаписи) и нетерминальные символы.</p>
<h2>2.4 два пути следования</h2>
<p>Две версии предыдущей программы представляют собой два альтернативных подхода, которые возникают снова и снова при разработке программ: (1) Использовать наиболее простое отображение описания проблемы непосредственно в код Lisp. (2) Использовать наиболее естественную нотацию, доступную для решения проблемы, а затем позаботиться о написании интерпретатора для этой нотации.</p>
<p>Подход (2) предполагает дополнительный шаг и, таким образом, больше работы для небольших проблем. Однако программы, использующие этот подход, часто легче модифицировать и расширять. Это особенно верно в области, где есть много данных для учета. Грамматика естественного языка является одной из таких областей-на самом деле, большинство проблем ИИ соответствуют этому описанию. Идея подхода (2) состоит в том, чтобы работать с проблемой как можно больше в ее собственных терминах и минимизировать ту часть решения, которая написана непосредственно на Лиспе.</p>
<p>К счастью, в Lisp очень легко создавать новые нотации - фактически, новые языки программирования. Таким образом, Lisp стимулирует создание более надежных программ. На протяжении всей этой книги мы будем помнить об этих двух подходах. Читатель может заметить, что в большинстве случаев мы выбираем второй.</p>
<h2>2.5 изменение грамматики без изменения программы</h2>
<p>Мы покажем полезность подхода (2), определив новую грамматику, которая включает прилагательные (adjectives), предложные фразы(prepositional phrases), имена собственные (proper names) и местоимения (pronouns). Затем мы можем применить функцию <code>generate</code> без изменений к этой новой грамматике.</p>
<div class="fragment"><div class="line">(defparameter *bigger-grammar*</div><div class="line">  &#39;((sentence -&gt; (noun-phrase verb-phrase))</div><div class="line">    (noun-phrase -&gt; (Article Adj* Noun PP*) (Name) (Pronoun))</div><div class="line">    (verb-phrase -&gt; (Verb noun-phrase PP*))</div><div class="line">    (PP* -&gt; () (PP PP*))</div><div class="line">    (Adj* -&gt; () (Adj Adj*))</div><div class="line">    (PP -&gt; (Prep noun-phrase))</div><div class="line">    (Prep -&gt; to in by with on)</div><div class="line">    (Adj -&gt; big little blue green adiabatic)</div><div class="line">    (Article -&gt; the a)</div><div class="line">    (Name -&gt; Pat Kim Lee Terry Robin)</div><div class="line">    (Noun -&gt; man ball woman table)</div><div class="line">    (Verb -&gt; hit took saw liked)</div><div class="line">    (Pronoun -&gt; he she it these those that)))</div><div class="line"></div><div class="line">(setf *grammar* *bigger-grammar*)</div><div class="line"></div><div class="line">&gt; (generate &#39;sentence)</div><div class="line">(A TABLE ON A TABLE IN THE BLUE ADIABATIC MAN SAW ROBIN</div><div class="line"> WITH A LITTLE WOMAN)</div><div class="line"></div><div class="line">&gt; (generate &#39;sentence)</div><div class="line">(TERRY SAW A ADIABATIC TABLE ON THE GREEN BALL BY THAT WITH KIM</div><div class="line"> IN THESE BY A GREEN WOMAN BY A LITTLE ADIABATIC TABLE IN ROBIN</div><div class="line"> ON LEE)</div><div class="line"></div><div class="line">&gt; (generate &#39;sentence)</div><div class="line">(THE GREEN TABLE HIT IT WITH HE)</div></div><!-- fragment --><p>Обратите внимание на проблему с согласованием падежей для местоимений: программа генерирует "с ним/with he,", хотя правильной грамматической формой является "with him" . Также ясно, что программа не отличает разумный вывод от глупого.</p>
<h2>2.6 использование одних и тех же данных для нескольких программ</h2>
<p>Еще одно преимущество представления информации в декларативной форме - в виде правил или фактов, а не в виде функций Lisp - заключается в том, что ее легче использовать для различных целей. Предположим, нам нужна функция, которая генерировала бы не только список слов в предложении, но и представление полного синтаксиса предложения. Например, вместо списка <code>(a woman took a ball)</code> мы хотим получить вложенный список:</p>
<div class="fragment"><div class="line">(SENTENCE (NOUN-PHRASE (ARTICLE A) (NOUN WOMAN))</div><div class="line">          (VERB-PHRASE (VERB TOOK)</div><div class="line">                       (NOUN-PHRASE (ARTICLE A) (NOUN BALL))))</div></div><!-- fragment --><p>Это соответствует дереву, которое лингвисты рисуют, как показано на рис. 2.1.</p>
<div class="image">
<img src="images/chapter2/f02-01.jpg" alt="Figure 2.1: Sentence Parse Tree"/>
</div>
<p> <b>Рис. 2.1: Дерево Синтаксического Анализа Предложений</b></p>
<p>Используя подход (1) "простых функций", мы застряли бы; нам пришлось бы переписывать каждую функцию, чтобы создать дополнительную структуру. С помощью подхода (2) "новая нотация" мы могли бы сохранить грамматику такой, какая она есть, и просто написать одну новую функцию: версию <code>generate</code>, которая создает вложенные списки. Эти два изменения заключаются в том, чтобы <code>cons</code>(создать список) из категории в передней части каждой перезаписи, а затем не выполнять <code>append</code> для всех результатов, а просто перечислить их с помощью <code>mapcar</code>:</p>
<div class="fragment"><div class="line">(defun generate-tree (phrase)</div><div class="line">  &quot;Generate a random sentence or phrase,</div><div class="line">  with a complete parse tree.&quot;</div><div class="line">  (cond ((listp phrase)</div><div class="line">         (mapcar #&#39;generate-tree phrase))</div><div class="line">        ((rewrites phrase)</div><div class="line">         (cons phrase</div><div class="line">               (generate-tree (random-elt (rewrites phrase)))))</div><div class="line">        (t (list phrase))))</div></div><!-- fragment --><p>Вот несколько примеров:</p>
<div class="fragment"><div class="line">&gt; (generate-tree &#39;Sentence)</div><div class="line">(SENTENCE (NOUN-PHRASE (ARTICLE A)</div><div class="line">                       (ADJ*)</div><div class="line">                       (NOUN WOMAN)</div><div class="line">                       (PP*))</div><div class="line">      (VERB-PHRASE (VERB HIT)</div><div class="line">                       (NOUN-PHRASE (PRONOUN HE))</div><div class="line">                       (PP*)))</div><div class="line"></div><div class="line">&gt; (generate-tree &#39;Sentence)</div><div class="line">(SENTENCE (NOUN-PHRASE (ARTICLE A)</div><div class="line">                       (NOUN WOMAN))</div><div class="line">          (VERB-PHRASE (VERB TOOK)</div><div class="line">                       (NOUN-PHRASE (ARTICLE A) (NOUN BALL))))</div></div><!-- fragment --><p>В качестве еще одного примера подхода "одини-данные/несколько-программы" мы можем разработать функцию для генерации всех возможных перезаписей фразы. Функция <code>generate-all</code> возвращает список фраз, а не только одну, и мы определяем вспомогательную функцию <code>combine-all</code> для управления комбинацией результатов. Кроме того, есть четыре случая вместо трех, потому что мы должны явно проверить на nil. Тем не менее, полная программа довольно проста:</p>
<div class="fragment"><div class="line">(defun generate-all (phrase)</div><div class="line">  &quot;Generate a list of all possible expansions of this phrase.&quot;</div><div class="line">  (cond ((null phrase) (list nil))</div><div class="line">        ((listp phrase)</div><div class="line">         (combine-all (generate-all (first phrase))</div><div class="line">                      (generate-all (rest phrase))))</div><div class="line">        ((rewrites phrase)</div><div class="line">         (mappend #&#39;generate-all (rewrites phrase)))</div><div class="line">        (t (list (list phrase)))))</div><div class="line"></div><div class="line">(defun combine-all (xlist ylist)</div><div class="line">  &quot;Return a list of lists formed by appending a y to an x.</div><div class="line">  E.g., (combine-all &#39;((a) (b)) &#39;((1) (2)))</div><div class="line">  -&gt; ((A 1) (B 1) (A 2) (B 2)).&quot;</div><div class="line">  (mappend #&#39;(lambda (y)</div><div class="line">               (mapcar #&#39;(lambda (x) (append x y)) xlist))</div><div class="line">           ylist))</div></div><!-- fragment --><p>Теперь мы можем использовать <code>generate-all</code> для проверки нашей оригинальной маленькой грамматики. Обратите внимание, что серьезным недостатком <code>generate-all</code> является то, что он не может иметь дело с рекурсивными грамматическими правилами, такими как 'Adj* =&gt; Adj + Adj*', которые появляются в <code>*bigger-grammar*</code>, поскольку они приводят к бесконечному выводу. Но она прекрасно работает для конечных языков, таких как язык, порожденный <code>*simple-grammar*</code>:</p>
<div class="fragment"><div class="line">&gt; (generate-all &#39;Article)</div><div class="line"></div><div class="line">((THE) (A))</div><div class="line"></div><div class="line">&gt; (generate-all &#39;Noun)</div><div class="line"></div><div class="line">((MAN) (BALL) (WOMAN) (TABLE))</div><div class="line"></div><div class="line">&gt; (generate-all &#39;noun-phrase)</div><div class="line">((A MAN) (A BALL) (A WOMAN) (A TABLE)</div><div class="line"> (THE MAN) (THE BALL) (THE WOMAN) (THE TABLE))</div><div class="line"></div><div class="line">&gt; (length (generate-all &#39;sentence))</div><div class="line">256</div></div><!-- fragment --><p>Есть 256 предложений, потому что каждое предложение в этом языке имеет форму артикль-существительное-глагол-артикль-существительное(Article-Noun-Verb-Article-Noun), и есть два артикля, четыре существительных и четыре глагола (2 х 4 х 4 х 2 х 4 = 256).</p>
<h2>2.7 Упражнения</h2>
<p>&amp;#9635; <b>Exercise 2.3 [h]</b> Напишите тривиальную грамматику для какого-нибудь другого языка. Это может быть естественный язык, отличный от английского, или, возможно, подмножество компьютерного языка.</p>
<p>&amp;#9635; <b>Exercise 2.4 [m]</b> Один из способов определения функции <code>combine-all</code> заключается в том, что она вычисляет перекрестное произведение функции <code>append</code> по списку аргументов. Напишите функцию более высокого порядка <code>cross-product</code> и определите <code>combine-all</code> в ее терминах.</p>
<p>Мораль заключается в том, чтобы сделать свой код как можно более общим, потому что вы никогда не знаете, что вы можете сделать с ним дальше.</p>
<h2>2.8 Ответы</h2>
<h3>Answer 2.1</h3>
<div class="fragment"><div class="line">(defun generate (phrase)</div><div class="line">&quot;Generate a random sentence or phrase&quot;</div><div class="line">(let ((choices nil))</div><div class="line">  (cond ((listp phrase)</div><div class="line">      (mappend #&#39;generate phrase))</div><div class="line">     ((setf choices (rewrites phrase))</div><div class="line">      (generate (random-elt choices)))</div><div class="line">     (t (list phrase)))))</div></div><!-- fragment --><h3>Answer 2.2</h3>
<div class="fragment"><div class="line">(defun generate (phrase)</div><div class="line">  &quot;Generate a random sentence or phrase&quot;</div><div class="line">  (cond ((listp phrase)</div><div class="line">         (mappend #&#39;generate phrase))</div><div class="line">        ((non-terminal-p phrase)</div><div class="line">         (generate (random-elt (rewrites phrase))))</div><div class="line">        (t (list phrase))))</div><div class="line"></div><div class="line">(defun non-terminal-p (category)</div><div class="line">  &quot;True if this is a category in the grammar.&quot;</div><div class="line">  (not (null (rewrites category))))</div></div><!-- fragment --><h3>Answer 2.4</h3>
<div class="fragment"><div class="line">(defun cross-product (fn xlist ylist)</div><div class="line">  &quot;Return a list of all (fn x y) values.&quot;</div><div class="line">  (mappend #&#39;(lambda (y)</div><div class="line">               (mapcar #&#39;(lambda (x) (funcall fn x y))</div><div class="line">                       xlist))</div><div class="line">           ylist))</div><div class="line"></div><div class="line">(defun combine-all (xlist ylist)</div><div class="line">  &quot;Return a list of lists formed by appending a y to an x&quot;</div><div class="line">  (cross-product #&#39;append xlist ylist))</div></div><!-- fragment --><p>Теперь мы можем использовать <code>cross-product</code> и другими способами:</p>
<div class="fragment"><div class="line">&gt; (cross-product #&#39;+ &#39;(1 2 3) &#39;(10 20 30))</div><div class="line">(11 12 13</div><div class="line"> 21 22 23</div><div class="line"> 31 32 33)</div><div class="line"></div><div class="line">&gt; (cross-product #&#39;list &#39;(a b c d e f g h)</div><div class="line">                        &#39;(1 2 3 4 5 6 7 8))</div><div class="line">((A 1) (B 1) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)</div><div class="line"> (A 2) (B 2) (C 2) (D 2) (E 2) (F 2) (G 2) (H 2)</div><div class="line"> (A 3) (B 3) (C 3) (D 3) (E 3) (F 3) (G 3) (H 3)</div><div class="line"> (A 4) (B 4) (C 4) (D 4) (E 4) (F 4) (G 4) (H 4)</div><div class="line"> (A 5) (B 5) (C 5) (D 5) (E 5) (F 5) (G 5) (H 5)</div><div class="line"> (A 6) (B 6) (C 6) (D 6) (E 6) (F 6) (G 6) (H 6)</div><div class="line"> (A 7) (B 7) (C 7) (D 7) (E 7) (F 7) (G 7) (H 7)</div><div class="line"> (A 8) (B 8) (C 8) (D 8) (E 8) (F 8) (G 8) (H 8))</div></div><!-- fragment --> <hr/>
<p>  <a href="#tfn02-1">1</a> Вскоре мы увидим обозначение "Kleene plus", где <em>PP+* обозначает одно или несколько повторений *PP</em>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
