<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 23</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 23 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Компиляция Lisp</h2>
<p>Во многих учебниках показаны простые интерпретаторы Лиспа, потому что они просты в написании и потому, что полезно знать, как работает интерпретатор. К сожалению, не так много учебников показывают, как писать компилятор, хотя по тем же двум причинам. Самый простой компилятор не должен быть намного сложнее интерпретатора.</p>
<p>Одна вещь, которая делает компилятор более сложным, заключается в том, что мы должны описывать вывод компилятора: набор инструкций машины, для которой мы компилируем. На данный момент давайте предположим, что это машина на основе стека. Последовательность вызова на этом компьютере для вызова функции с <em>n</em> аргументами состоит в том, чтобы поместить <em>n</em> аргументов в стек, а затем поместить туда функцию, которая будет вызвана. Инструкция <code>"CALL *n*"</code> сохраняет точку возврата в стеке и переходит к первой инструкции вызываемой функции. По соглашению, первая инструкция функции всегда будет <code>"ARGS *n*"</code>, которая выталкивает <em>n</em> аргументов из стека, помещая их в окружающую среду новой функции, где к ним могут получить доступ инструкции <code>LVAR</code> и <code>LSET</code>. Функция должна возвращаться с инструкцией <code>RETURN</code>, которая сбрасывает счетчик программы и окружение до точки исходной инструкции <code>CALL</code>.</p>
<p>Кроме того, наша машина имеет три инструкции <code>JUMP</code>; одна, переходящая безусловно, и две, которые выполняют переход в зависимости от того, является ли вершина стека нулевой или ненулевой. Также есть инструкция для удаления ненужных значений из стека, а также для доступа и изменения глобальных переменных. Набор команд показан на <a href="#f0010">рисунке 23.1</a>. Словарь для программы компилятора приведен на <a href="# f0015">рисунке 23.2</a>. Краткое описание более сложной версии компилятора приведено на <a href="#p795">страница 795</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter23/f23-01.jpg" alt="f23-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 23.1: Набор Инструкций для гипотетической Стековой Машины </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter23/f23-02.jpg" alt="f23-02"/>
</div>
 </td></tr>
<tr>
<td>Figure 23.2: Glossary for the Scheme Compiler </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<p>Например, процедура</p>
<div class="fragment"><div class="line">(lambda () (if (= x y) (f (g x)) (h x y (h 1 2))))</div></div><!-- fragment --><p>должна скомпилироваться в следующие инструкции:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>=</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>G</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>JUMP</code> </td><td><code>L2</code> </td></tr>
<tr>
<td><code>L1:</code> </td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>3</code> </td></tr>
<tr>
<td><code>L2:</code> </td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Первая версия компилятора Scheme довольно проста. Он имитирует структуру вычислителя(evaluator) Scheme. Разница в том, что каждый случай генерирует код, а не вычисляет подвыражения:</p>
<div class="fragment"><div class="line">(defun comp (x env)</div><div class="line">  &quot;Compile the expression x into a list of instructions&quot;</div><div class="line">  (cond</div><div class="line">    ((symbolp x) (gen-var x env))</div><div class="line">    ((atom x) (gen &#39;CONST x))</div><div class="line">    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))</div><div class="line">    ((case (first x)</div><div class="line">       (QUOTE  (gen &#39;CONST (second x)))</div><div class="line">       (BEGIN  (comp-begin (rest x) env))</div><div class="line">       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))</div><div class="line">       (IF     (comp-if (second x) (third x) (fourth x) env))</div><div class="line">       (LAMBDA (gen &#39;FN (comp-lambda (second x) (rest (rest x)) env)))</div><div class="line">       ;; Procedure application:</div><div class="line">       ;; Compile args, then fn, then the call</div><div class="line">       (t      (seq (mappend #&#39;(lambda (y) (comp y env)) (rest x))</div><div class="line">                    (comp (first x) env)</div><div class="line">                              (gen &#39;call (length (rest x)))))))))</div></div><!-- fragment --><p>Компилятор <code>comp</code> имеет те же девять вариантов - фактически ту же самую структуру - что и интерпретатор <code>interp</code> из <a href="B9780080571157500224.xhtml">главы 22</a>. Каждый случай немного сложнее, поэтому три основных случая были разделены на отдельные функции: <code>comp-begin</code>, <code>comp-if</code> и <code>comp-lambda</code>. Выражение <code>begin</code> компилируется путем компиляции каждого аргумента по очереди, но обязательно выталкивает каждое значение, кроме последнего, из стека после его вычисления. Последний элемент в <code>begin</code> остается в стеке как значение всего выражения. Обратите внимание, что функция <code>gen</code> генерирует одну инструкцию (фактически список из одной инструкции), а <code>seq</code> создает последовательность инструкций из двух или более подпоследовательностей.</p>
<div class="fragment"><div class="line">(defun comp-begin (exps env)</div><div class="line">  &quot;Compile a sequence of expressions, popping all but the last.&quot;</div><div class="line">  (cond ((null exps) (gen &#39;CONST nil))</div><div class="line">        ((length=1 exps) (comp (first exps) env))</div><div class="line">        (t (seq (comp (first exps) env)</div><div class="line">                (gen &#39;POP)</div><div class="line">                (comp-begin (rest exps) env)))))</div></div><!-- fragment --><p>Выражение <code>if</code> компилируется путем компиляции предиката, части then(затем) и части иначе(else), а также путем вставки соответствующих инструкций ветвления.</p>
<div class="fragment"><div class="line">(defun comp-if (pred then else env)</div><div class="line">  &quot;Compile a conditional expression.&quot;</div><div class="line">  (let ((L1 (gen-label))</div><div class="line">        (L2 (gen-label)))</div><div class="line">    (seq (comp pred env) (gen &#39;FJUMP L1)</div><div class="line">         (comp then env) (gen &#39;JUMP L2)</div><div class="line">         (list L1) (comp else env)</div><div class="line">         (list L2))))</div></div><!-- fragment --><p>Наконец, <code>lambda</code>- выражение компилируется путем компиляции тела, окружая его одной инструкцией для установки аргументов и другой для возврата из функции, а затем сохраняя полученный скомпилированный код вместе с окружающей средой(environment). Тип данных <code>fn</code> реализован в виде структуры со слотами для тела кода, списка аргументов и имени функции (только для целей печати).</p>
<div class="fragment"><div class="line">(defstruct (fn (:print-function print-fn))</div><div class="line">  code (env nil) (name nil) (args nil))</div><div class="line"></div><div class="line">(defun comp-lambda (args body env)</div><div class="line">  &quot;Compile a lambda form into a closure with compiled code.&quot;</div><div class="line">  (assert (and (listp args) (every #&#39;symbolp args)) ()</div><div class="line">          &quot;Lambda arglist must be a list of symbols, not ~a&quot; args)</div><div class="line">  ;; For now, no &amp;rest parameters.</div><div class="line">  ;; The next version will support Scheme&#39;s version of &amp;rest</div><div class="line">  (make-fn</div><div class="line">    :env env :args args</div><div class="line">    :code (seq (gen &#39;ARGS (length args))</div><div class="line">               (comp-begin body (cons args env))</div><div class="line">               (gen &#39;RETURN))))</div></div><!-- fragment --><p>Преимущество компиляции перед интерпретацией состоит в том, что многое можно решить во время компиляции. Например, компилятор может определить, относится ли ссылка к глобальной переменной или к лексической переменной, и если это ссылка на лексическую переменную, где именно эта лексическая переменная хранится. Это вычисление выполняется компилятором только один раз, но оно должно выполняться каждый раз, когда выражение встречается в интерпретаторе. Точно так же компилятор может подсчитать количество аргументов раз и навсегда, в то время как интерпретатор должен пройти цикл, подсчитывая количество аргументов и проверяя конец аргументов после интерпретации каждого из них.</p>
<p>Еще одно преимущество состоит в том, что компилятор может быть более надежным. Например, в <code>comp-lambda</code> мы проверяем, что список параметров лямбда-выражения является списком, содержащим только символы. Было бы слишком дорого делать такие проверки в интерпретаторе, но в компиляторе стоит проверить один раз во время компиляции на наличие условий ошибки, а не повторно проверять во время выполнения.</p>
<p>Прежде чем мы покажем остальную часть компилятора, вот полезный интерфейс верхнего уровня для <code>comp</code>:</p>
<div class="fragment"><div class="line">(defvar *label-num* 0)</div><div class="line"></div><div class="line">(defun compiler (x)</div><div class="line">  &quot;Compile an expression as if it were in a parameterless lambda.&quot;</div><div class="line">  (setf *label-num* 0)</div><div class="line">  (comp-lambda &#39;() (list x) nil))</div><div class="line"></div><div class="line">(defun comp-show (x)</div><div class="line">  &quot;Compile an expression and show the resulting code&quot;</div><div class="line">   (show-fn (compiler x))</div><div class="line">  (values))</div></div><!-- fragment --><p>Теперь вот код для генерации отдельных инструкций и последовательностей инструкций. Последовательность инструкций - это просто список, но мы предоставляем функцию <code>seq</code> вместо того, чтобы напрямую использовать <code>append</code> для целей абстракции данных. label - это просто атом.</p>
<div class="fragment"><div class="line">(defun gen (opcode &amp;rest args)</div><div class="line">  &quot;Return a one-element list of the specified instruction.&quot;</div><div class="line">  (list (cons opcode args)))</div><div class="line"></div><div class="line">(defun seq (&amp;rest code)</div><div class="line">  &quot;Return a sequence of instructions&quot;</div><div class="line">  (apply #&#39;append code))</div><div class="line"></div><div class="line">(defun gen-label (&amp;optional (label &#39;L))</div><div class="line">  &quot;Generate a label (a symbol of the form Lnnn)&quot;</div><div class="line">  (intern (format nil &quot;~a~d&quot; label (incf *label-num*))))</div></div><!-- fragment --><p>Окружающие среды теперь представлены в виде списков кадров(frames), где каждый кадр представляет собой последовательность переменных. На локальные переменные ссылаются не по их имени, а по двум целым числам: индекс в списке фреймов и индекс в отдельном фрейме. Как обычно, индексы отсчитываются от нуля. Например, данный код:</p>
<div class="fragment"><div class="line">(let ((a 2.0)</div><div class="line">          (b 2.1))</div><div class="line">  (let ((c 1.0)</div><div class="line">            (d 1.1))</div><div class="line">    (let ((e 0.0)</div><div class="line">          (f 0.1))</div><div class="line">      (+ a b c d e f))))</div></div><!-- fragment --><p>самая внутренняя окружающая среда - это <code>((e f) (c d) (a b))</code>. Функция <code>in-env-p</code> проверяет, появляется ли переменная в среде. Если бы эта среда была названа <code>env</code>, то <code>(in-env-p 'f env)</code> вернула бы <code>(0 1)</code>, а `(in-env-p' x env)<code>вернула бы</code>nil`.</p>
<div class="fragment"><div class="line">(defun gen-var (var env)</div><div class="line">  &quot;Generate an instruction to reference a variable&#39;s value.&quot;</div><div class="line">  (let ((p (in-env-p var env)))</div><div class="line">    (if p</div><div class="line">        (gen &#39;LVAR (first p) (second p) &quot;;&quot; var)</div><div class="line">        (gen &#39;GVAR var))))</div><div class="line"></div><div class="line">(defun gen-set (var env)</div><div class="line">  &quot;Generate an instruction to set a variable to top-of-stack.&quot;</div><div class="line">  (let ((p (in-env-p var env)))</div><div class="line">    (if p</div><div class="line">        (gen &#39;LSET (first p) (second p) &quot;;&quot; var)</div><div class="line">        (gen &#39;GSET var))))(def-scheme-macro define (name &amp;rest body)</div><div class="line">  (if (atom name)</div><div class="line">      `(name! (set! ,name . ,body) &#39;,name)</div><div class="line">      (scheme-macro-expand</div><div class="line">         `(define ,(first name)</div><div class="line">            (lambda ,(rest name) . ,body)))))</div></div><!-- fragment --><p>Наконец, у нас есть несколько вспомогательных функций для распечатки результатов, для различения меток и инструкций и для определения индекса переменной в среде. Функции Scheme теперь реализованы в виде структур, которые должны иметь поле для кода и поле для окружающей среды. Кроме того, мы предоставляем поле для имени функции и для списка аргументов; они используются только для целей отладки. Мы примем соглашение, согласно которому макрос <code>define</code> устанавливает поле имени функции, вызывая <code>name</code>! (которая не является частью стандартной схемы).</p>
<div class="fragment"><div class="line">(defun name! (fn name)</div><div class="line">  &quot;Set the name field of fn, if it is an un-named fn.&quot;</div><div class="line">  (when (and (fn-p fn) (null (fn-name fn)))</div><div class="line">    (setf (fn-name fn) name))</div><div class="line">  name)</div><div class="line"></div><div class="line">;; This should also go in init-scheme-interp:</div><div class="line">(set-global-var! &#39;name! #&#39;name!)</div><div class="line"></div><div class="line">(defun print-fn (fn &amp;optional (stream *standard-output*) depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;{~a}&quot; (or (fn-name fn) &#39;??)))</div><div class="line"></div><div class="line">(defun show-fn (fn &amp;optional (stream *standard-output*) (depth 0))</div><div class="line">  &quot;Print all the instructions in a function.</div><div class="line">  If the argument is not a function, just princ it,</div><div class="line">  but in a column at least 8 spaces wide.&quot;</div><div class="line">  (if (not (fn-p fn))</div><div class="line">      (format stream &quot;~8a&quot; fn)</div><div class="line">      (progn</div><div class="line">        (fresh-line)</div><div class="line">        (incf depth 8)</div><div class="line">        (dolist (instr (fn-code fn))</div><div class="line">          (if (label-p instr)</div><div class="line">              (format stream &quot;~a:&quot; instr)</div><div class="line">              (progn</div><div class="line">                (format stream &quot;~VT&quot; depth)</div><div class="line">                (dolist (arg instr)</div><div class="line">                  (show-fn arg stream depth))</div><div class="line">                (fresh-line)))))))</div><div class="line"></div><div class="line">(defun label-p (x) &quot;Is x a label?&quot; (atom x))</div><div class="line"></div><div class="line">(defun in-env-p (symbol env)</div><div class="line">  &quot;If symbol is in the environment, return its index numbers.&quot;</div><div class="line">  (let ((frame (find symbol env :test #&#39;find)))</div><div class="line">    (if frame (list (position frame env) (position symbol frame)))))</div></div><!-- fragment --><p>Теперь мы готовы показать компилятор в работе:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(if (= x y) (f (g x)) (h x y (h 1 2))))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>=</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>G</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>JUMP</code> </td><td><code>L2</code> </td></tr>
<tr>
<td><code>L1:</code> </td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>3</code> </td></tr>
<tr>
<td><code>L2:</code> </td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Этот пример должен дать читателю представление о коде, созданном компилятором.</p>
<p>Другая причина, по которой компилятор имеет преимущество перед интерпретатором, заключается в том, что компилятор может позволить себе потратить некоторое время на попытки найти более эффективное кодирование выражения, в то время как для интерпретатора накладные расходы на поиск более эффективной интерпретации обычно сводят на нет любое полученное преимущество. . Вот несколько мест, где компилятор мог бы работать лучше, чем интерпретатор (хотя наш компилятор в настоящее время этого не делает):</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin &quot;doc&quot; (write x) y))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>doc</code> </td></tr>
<tr>
<td></td><td><code>POP</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>WRITE</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>POP</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>В этом примере генерируется код, который помещает константу <code>"doc"</code> в стек, а затем немедленно удаляет ее. Если у нас есть компилятор, отслеживающий, какие выражения компилируются "для значения" - поскольку y - это значение выражения выше - и какие компилируются только "для эффекта", то мы можем вообще избежать генерации кода для ссылки на константы или переменные для эффекта. Вот еще пример:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (+ (* a x) (f x)) x))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>A</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>*</code> </td></tr>
<tr>
<td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>+</code> </td></tr>
<tr>
<td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td><code>POP</code> </td><td></td></tr>
<tr>
<td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>RETURN</code> </td><td></td></tr>
</table>
<p>В этом выражении, если мы можем быть уверены, что + и * относятся к обычным арифметическим функциям, то мы можем скомпилировать его, как если бы это было <code>(begin (f x) x)</code>. Более того, разумно предположить, что + и * будут инструкциями на нашей машине, которые можно выполнить непосредственно, а не вызывать функцию. Многие компиляторы тратят значительную часть своего времени на оптимизацию арифметических операций, принимая во внимание ассоциативность, коммутативность, распределительность и другие свойства.</p>
<p>Помимо арифметики, компиляторы часто проводят экспертизу в условных выражениях. Рассмотреть следующее:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(if (and p q) x y))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>P</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L3</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Q</code> </td></tr>
<tr>
<td></td><td><code>JUMP</code> </td><td><code>L4</code> </td></tr>
<tr>
<td><code>L3:</code> </td><td><code>GVAR</code> </td><td><code>NIL</code> </td></tr>
<tr>
<td><code>L4:</code> </td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>JUMP</code> </td><td><code>L2</code> </td></tr>
<tr>
<td><code>L1:</code> </td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td><code>L2:</code> </td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Обратите внимание, что <code>(and p q)</code> макро-расширяется до <code>(if p q nil)</code>. Полученный скомпилированный код корректен, но неэффективен. Во-первых, существует безусловный переход к <code>L4</code>, который обозначает условный переход к <code>L1</code>. Это можно было бы заменить условным переходом к <code>L1</code>. Во-вторых, на <code>L3</code> мы загружаем <code>NIL</code>, а затем переходим при nil к <code>L1</code>. Эти две инструкции могут быть заменены безусловным переходом к <code>L1</code>. В-третьих, <code>FJUMP</code> к <code>L3</code> можно заменить на <code>FJUMP</code> к <code>L1</code>, так как теперь мы знаем, что код в <code>L3</code> безоговорочно переходит к <code>L1</code>.</p>
<p>Наконец, некоторые компиляторы, особенно компиляторы Lisp, проводят экспертизу вызова функций. Рассмотреть следующее:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(f (g x y)))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>G</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>1</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Здесь мы вызываем <code>g</code> и когда <code>g</code> возвращается мы вызываем <code>f</code> , а когда <code>f</code> возвращаеся мы вернемся из этой функции. Но это последнее возвращение является расточительным; мы помещаем адрес возврата в стек, а затем убираем его и возвращаемся к следующему адресу возврата. Альтернативный протокол вызова функции включает в себя помещение в стек адреса возврата перед вызовом <code>g</code>, но затем не помещать в стек адрес возврата перед вызовом <code>f;</code> когда <code>f</code> возвращается, он вернется непосредственно к вызывающей функции, какой бы она ни была.</p>
<p>Такая оптимизация выглядит небольшим выигрышем; мы в основном исключаем единственную инструкцию. Фактически, последствия этого нового протокола огромны: теперь мы можем вызывать рекурсивную функцию до произвольной глубины без увеличения стека вообще - до тех пор, пока рекурсивный вызов является последним оператором в функции (или в ветви функция, когда есть условные выражения). Функция, которая подчиняется этому ограничению на свои рекурсивные вызовы, известна как <em>правильная хвосто- рекурсивная</em> функция. Эта тема обсуждалась в <a href="B9780080571157500224.xhtml#s0020">разделе 22.3.</a></p>
<p>До сих пор все примеры касались только глобальных переменных. Вот пример использования локальных переменных:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;((lambda (x) ((lambda (y z) (f x y z)) 3 x)) 4))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td><code>ARGS</code> </td><td><code>0</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>CONST</code> </td><td><code>4</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>3</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td>; </td><td><code>X</code> </td><td></td></tr>
<tr>
<td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>ARGS</code> </td><td><code>2</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>LVAR</code> </td><td><code>1</code> </td><td><code>0</code> </td><td>; </td><td><code>X</code> </td></tr>
<tr>
<td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td>; </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>1</code> </td><td><code>;</code> </td><td><code>Z</code> </td></tr>
<tr>
<td></td><td></td><td><code>GVAR</code> </td><td><code>F</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>CALL</code> </td><td><code>3</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CALL</code> </td><td><code>2</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>CALL</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>RETURN</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>Код имеет отступ для отображения вложенных функций. Функция верхнего уровня загружает константу 4 и анонимную функцию и вызывает функцию. Эта функция загружает константу 3 и локальную переменную <code>x</code>, которая является первым (0-м) элементом в верхнем (0-м) кадре. Затем он вызывает функцию с двойной вложенностью для этих двух аргументов. Эта функция загружает <code>x, y</code>, и <code>z: x</code> теперь является 0-м элементом следующего (первого) кадра, а <code>y</code> и <code>z</code> являются 0-м и 1-м элементами верхнего кадра. Со всеми аргументами, наконец, вызывается функция <code>f</code>. Обратите внимание, что никакие продолжения не сохраняются - <code>f</code> может возвращаться непосредственно вызывающей эту функцию стороне.</p>
<p>Однако все эти явные манипуляции с окружением неэффективны; в этом случае мы могли бы скомпилировать все, просто поместив 4, 3 и 4 в стек и вызвав <code>f</code>.</p>
<h2>23.1 Правильный хвосто-рекурсивный компилятор Лиспа</h2>
<p>В этом разделе мы описываем новую версию компилятора, сначала показывая примеры его вывода, а затем исследуя сам компилятор, который кратко описан на <a href="#f0020">рис. 23.3</a>. В новой версии компилятора также используется другая последовательность вызова функций с использованием двух новых инструкций, <code>CALLJ</code> и <code>SAVE</code>. Как следует из названия, <code>SAVE</code> сохраняет адрес возврата в стеке. Инструкция <code>CALLJ</code> больше ничего не сохраняет; её можно рассматривать как безусловный переход - отсюда и буква <code>J</code> в её названии.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter23/f23-03.jpg" alt="f23-03"/>
</div>
 </td></tr>
<tr>
<td>Figure 23.3: Glossary of the Scheme Compiler, Second Version </td></tr>
</table>
<p>*(ed: should be a markdown table)*</p>
<p>Сначала мы посмотрим, как работают вызовы вложенных функций:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(f (g x)))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>G</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
</table>
<p>Точка продолжения <code>K1</code> сохраняется, чтобы g мог вернуться к ней, но тогда продолжение для f не сохраняется, поэтому f возвращается к любому продолжению, находящемуся в стеке. Таким образом, нет необходимости в явной инструкции <code>RETURN</code>. Последний <code>CALL</code> подобен безусловному переходу.</p>
<p>В следующем примере показано, что все функции, кроме последней <code>(f)</code>, нуждаются в точке продолжения:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(f (g (h x) (h y))))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K2</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K2:</code> </td><td><code>SAVE</code> </td><td><code>K3</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>H</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K3:</code> </td><td><code>GVAR</code> </td><td><code>G</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>2</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
</table>
<p>Этот код сначала вычисляет <code>(h x)</code> и возвращается к <code>K2</code>. Затем он вычисляет <code>(h y)</code> и возвращается к <code>K3</code>. Затем он вызывает <code>g</code> для этих двух значений и возвращается к <code>K1</code> перед переходом к <code>f</code>. Поскольку все, что возвращает <code>f</code>, также будет окончательным значением функции, которую мы компилируем, нет необходимости сохранять точку продолжения для возврата <code>f</code>.</p>
<p>В следующем примере мы видим, что ненужные константы и переменные в выражениях <code>begin</code> игнорируются:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin &quot;doc&quot; x (f x) y))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>POP</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Одним из основных недостатков первой версии компилятора является то, что она могла передавать данные, но на самом деле она не могла ничего <em>делать</em> с объектами данных. Мы исправляем эту проблему, дополнив машину инструкциями для выполнения арифметических и других примитивных операций. Ненужные примитивные операции, такие как переменные, константы и арифметические операции, игнорируются, когда они находятся в нефинальной позиции в пределах <code>begin</code>. Сравните два следующих выражения:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (+ (* a x) (f x)) x))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>POP</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>| `&gt; (comp-show '(begin (+ (* a x) (f x))))` |</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>A</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>*</code> </td><td></td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>+</code> </td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Первая версия компилятора была контекстно-свободной в том смысле, что она эквивалентно компилировала все эквивалентные выражения, независимо от того, где они появились. Компилятор с правильной хвостовой рекурсией должен быть контекстно-зависимым: он должен компилировать вызов, который является конечным значением функции, иначе, чем вызов, который используется в качестве промежуточного значения или значение которого игнорируется. В первой версии компилятора <code>comp-lambda</code> отвечал за генерацию инструкции <code>RETURN</code>, и весь код в конечном итоге достигал этой инструкции. Чтобы убедиться, что <code>RETURN</code> был достигнут, код для двух ветвей выражения <code>if</code> должен был воссоединиться в конце.</p>
<p>В компиляторе с хвостовой рекурсией каждый фрагмент кода отвечает за вставку собственной инструкции <code>RETURN</code> или неявный возврат путем вызова другой функции без сохранения точки продолжения.</p>
<p>Мы отслеживаем эти возможности с помощью двух флагов. Параметр <code>val?</code> истинен, когда выражение, которое мы компилируем, возвращает значение, которое используется в другом месте. Параметр <code>more?</code> является ложным, когда выражение представляет окончательное значение, и истинным, когда необходимо еще вычислять. Таким образом, есть три возможности:</p>
<table class="doxtable">
<tr>
<th><code>val?</code> </th><th><code>more?</code> </th><th>example: the <code>X</code> in:  </th></tr>
<tr>
<td>true </td><td>true </td><td><code>(if X y z)</code>*or*<code>(f X y)</code> </td></tr>
<tr>
<td>true </td><td>false </td><td><code>(if p X z)</code>*or*<code>(begin y X)</code> </td></tr>
<tr>
<td>false </td><td>true </td><td><code>(begin X y)</code> </td></tr>
<tr>
<td>false </td><td>false </td><td><em>impossible</em> </td></tr>
</table>
<p>Код для компилятора, использующего эти соглашения, следующий:</p>
<div class="fragment"><div class="line">(defun comp (x env)</div><div class="line">  &quot;Compile the expression x into a list of instructions&quot;</div><div class="line">  (cond</div><div class="line">    ((symbolp x) (gen-var x env))</div><div class="line">    ((atom x) (gen &#39;CONST x))</div><div class="line">    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))</div><div class="line">    ((case (first x)</div><div class="line">       (QUOTE  (gen &#39;CONST (second x)))</div><div class="line">       (BEGIN  (comp-begin (rest x) env))</div><div class="line">       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))</div><div class="line">       (IF     (comp-if (second x) (third x) (fourth x) env))</div><div class="line">       (LAMBDA (gen &#39;FN (comp-lambda (second x) (rest (rest x)) env)))</div><div class="line">       ;; Procedure application:</div><div class="line">       ;; Compile args, then fn, then the call</div><div class="line">       (t      (seq (mappend #&#39;(lambda (y) (comp y env)) (rest x))</div><div class="line">                    (comp (first x) env)</div><div class="line">                              (gen &#39;call (length (rest x)))))))))</div></div><!-- fragment --><p>Здесь мы добавили еще один случай: <code>t</code> и <code>nil</code> компилируются непосредственно в примитивные инструкции, а не полагаются на их привязку как глобальные переменные. (В реальной Scheme логические значения - это <code># t</code> и <code>#f</code>, которые не нужно заключать в кавычки, пустой список - это <code>()</code>, который должен быть заключен в кавычки, а <code>t</code> и <code>nil</code> - обычные символы. без особого значения.)</p>
<p>Я также добавил проверку на ошибки количества аргументов, передаваемых в <code>quote</code>, <code>set!</code> и <code>if</code>. Обратите внимание, что в компиляторе разумно выполнять больше проверок ошибок, чем в интерпретаторе, поскольку проверка должна выполняться только один раз, а не каждый раз. Функция проверки аргументов следующая:</p>
<div class="fragment"><div class="line">(defun arg-count (form min &amp;optional (max min))</div><div class="line">  &quot;Report an error if form has wrong number of args.&quot;</div><div class="line">  (let ((n-args (length (rest form))))</div><div class="line">    (assert (&lt;= min n-args max) (form)</div><div class="line">      &quot;Wrong number of arguments for ~a in ~a:</div><div class="line">       ~d supplied, ~d~@[ to ~d~] expected&quot;</div><div class="line">      (first form) form n-args min (if (/= min max) max))))</div></div><!-- fragment --><p><b>Exercise 23.1 [m]</b> Измените компилятор, чтобы проверить наличие дополнительных ошибок времени компиляции, совершенных следующим ошибочным выражением:</p>
<div class="fragment"><div class="line">(cdr (+ (list x y) &#39;y (3 x) (car 3 x)))</div></div><!-- fragment --><p>Хвостово-рекурсивный компилятор по-прежнему имеет девять известных случаев, но я ввел <code>comp-var</code>, <code>comp-const</code>, <code>comp-if</code> и <code>comp-funcall</code>, чтобы справиться с повышенной сложностью, вызванной параметрами <code>var?</code> и <code>more?</code>.</p>
<p>Давайте рассмотрим функции <code>comp-</code> по очереди. Во-первых, <code>comp-begin</code> и <code>comp-list</code> просто обрабатывают и передают дополнительные параметры. <code>comp-list</code> будет использоваться в <code>comp-funcall</code>, новой функции, которая будет введена для компиляции применения процедуры.</p>
<div class="fragment"><div class="line">(defun comp-begin (exps env val? more?)</div><div class="line">  &quot;Compile a sequence of expressions,</div><div class="line">  returning the last one as the value.&quot;</div><div class="line">  (cond ((null exps) (comp-const nil val? more?))</div><div class="line">        ((length=1 exps) (comp (first exps) env val? more?))</div><div class="line">        (t (seq (comp (first exps) env nil t)</div><div class="line">                (comp-begin (rest exps) env val? more?)))))</div><div class="line"></div><div class="line">(defun comp-list (exps env)</div><div class="line">  &quot;Compile a list, leaving them all on the stack.&quot;</div><div class="line">  (if (null exps) nil</div><div class="line">      (seq (comp (first exps) env t t)</div><div class="line">           (comp-list (rest exps) env))))</div></div><!-- fragment --><p>Затем есть две тривиальные функции для компиляции доступа к переменным и константам. Если значение не требуется, они не производят никаких инструкций вообще. Если больше ничего не нужно делать, то эти функции должны генерировать инструкцию возврата. Это изменение по сравнению с предыдущей версией <code>comp</code>, где вызывающий генерировал инструкцию возврата. Обратите внимание, что я расширил машину, чтобы включить инструкции для наиболее распространенных констант: t, nil и некоторых небольших целых чисел.</p>
<div class="fragment"><div class="line">(defun comp-const (x val? more?)</div><div class="line">  &quot;Compile a constant expression.&quot;</div><div class="line">  (if val? (seq (if (member x &#39;(t nil -1 0 1 2))</div><div class="line">                    (gen x)</div><div class="line">                    (gen &#39;CONST x))</div><div class="line">                (unless more? (gen &#39;RETURN)))))</div><div class="line"></div><div class="line">(defun comp-var (x env val? more?)</div><div class="line">  &quot;Compile a variable reference.&quot;</div><div class="line">  (if val? (seq (gen-var x env) (unless more? (gen &#39;RETURN)))))</div></div><!-- fragment --><p>Оставшиеся две функции более сложны. Сначала рассмотрим <code>comp-if</code>. Вместо того чтобы слепо генерировать код для предиката и обеих ветвей, мы рассмотрим некоторые частные случаи(case). Во-первых, ясно, что <code>(if t x y)</code> можно свести к <code>x</code> и <code>(if nil x y)</code> можно свести к <code>y</code>. Возможно, не так очевидно, что <code>(if p x x)</code> может быть сведено к <code>(begin p x)</code>, или что сравнение equality на равенство между двумя ветвями должно выполняться на объектном коде, а не на исходном коде. Когда эти тривиальные частные случаи были рассмотрены, у нас осталось еще три случая: <code>(if р х nil), (if p nil y)</code> и <code>(if p x y)</code>. Шаблон меток и переходов для каждого из них различен.</p>
<div class="fragment"><div class="line">(defun comp-if (pred then else env val? more?)</div><div class="line">  &quot;Compile a conditional (IF) expression.&quot;</div><div class="line">  (cond</div><div class="line">    ((null pred)          ; (if nil x y) ==&gt; y</div><div class="line">     (comp else env val? more?))</div><div class="line">    ((constantp pred)     ; (if t x y) ==&gt; x</div><div class="line">     (comp then env val? more?))</div><div class="line">    ((and (listp pred)    ; (if (not p) x y) ==&gt; (if p y x)</div><div class="line">          (length=1 (rest pred))</div><div class="line">          (primitive-p (first pred) env 1)</div><div class="line">          (eq (prim-opcode (primitive-p (first pred) env 1)) &#39;not))</div><div class="line">     (comp-if (second pred) else then env val? more?))</div><div class="line">    (t (let ((pcode (comp pred env t t))</div><div class="line">             (tcode (comp then env val? more?))</div><div class="line">             (ecode (comp else env val? more?)))</div><div class="line">         (cond</div><div class="line">           ((equal tcode ecode) ; (if p x x) ==&gt; (begin p x)</div><div class="line">            (seq (comp pred env nil t) ecode))</div><div class="line">           ((null tcode)  ; (if p nil y) ==&gt; p (TJUMP L2) y L2:</div><div class="line">            (let ((L2 (gen-label)))</div><div class="line">              (seq pcode (gen &#39;TJUMP L2) ecode (list L2)</div><div class="line">                   (unless more? (gen &#39;RETURN)))))</div><div class="line">           ((null ecode)  ; (if p x) ==&gt; p (FJUMP L1) x L1:</div><div class="line">            (let ((L1 (gen-label)))</div><div class="line">              (seq pcode (gen &#39;FJUMP L1) tcode (list L1)</div><div class="line">                   (unless more? (gen &#39;RETURN)))))</div><div class="line">           (t             ; (if p x y) ==&gt; p (FJUMP L1) x L1: y</div><div class="line">                          ; or p (FJUMP L1) x (JUMP L2) L1: y L2:</div><div class="line">            (let ((L1 (gen-label))</div><div class="line">                  (L2 (if more? (gen-label))))</div><div class="line">              (seq pcode (gen &#39;FJUMP L1) tcode</div><div class="line">                   (if more? (gen &#39;JUMP L2))</div><div class="line">                   (list L1) ecode (if more? (list L2))))))))))</div></div><!-- fragment --><p>Вот несколько примеров выражений типа <code>if</code>. Во-первых, очень простой пример:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(if p (+ x y) (* x y)))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>P</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>+</code> </td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
<tr>
<td><code>L1 :</code> </td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>*</code> </td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Каждая ветвь имеет свою собственную инструкцию <code>RETURN</code>. Но обратите внимание, что генерируемый код чувствителен к его контексту. Например, если мы поместим одно и то же выражение в выражение <code>begin</code>, мы получим нечто совершенно другое:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (if p (+ x y) (* x y)) z))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Z</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Здесь происходит то, что <code>(+ x y)</code> и <code>(* x y)</code>, скомпилированные в контексте, где значение игнорируется, оба повторяются в не генерируемом коде. Таким образом, <code>if</code> выражение сводится к <code>(if p nil nil)</code>, который компирируется как <code>(begin p nil)</code>, который также не генерирует никакого кода, когда не вычисляется для значения, поэтому окончательный код просто ссылается на <code>z</code>. Компилятор может выполнить эту оптимизацию только потому, что он знает, что <code>+</code> и <code>*</code> -это операции без побочных эффектов. Рассмотрим, что происходит, когда мы заменяем + на <code>f</code>:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (if p (f x) (* x x)) z))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>P</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L2</code> </td></tr>
<tr>
<td></td><td><code>SAVE</code> </td><td><code>K1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
<tr>
<td><code>K1:</code> </td><td><code>POP</code> </td><td></td></tr>
<tr>
<td><code>L2:</code> </td><td><code>GVAR</code> </td><td><code>Z</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Здесь мы имеем вызов <code>(f x)</code> если <code>p</code> равно истине (а затем выбросывающий возвращенное значение), но нам не нужно вычислять <code>(* x x)</code>, когда <code>p</code> ложно</p>
<p>Эти примеры непреднамеренно выявили некоторую структуру <code>comp-funcall</code>, которая обрабатывает пять случаев. Во-первых, она знает некоторые примитивные функции, которые имеют соответствующие инструкции, и компилирует эти инструкции встраиваемыми, когда необходимы их значения. Если значения не нужны, то функция может быть проигнорирована, и только аргументы могут быть скомпилированы. Это предполагает истинные функции без каких-либо побочных эффектов. Если есть примитивные операции с побочными эффектами, они тоже могут быть скомпилированы встроенно, но эта операция никогда не может быть проигнорирована. Следующий случай - это когда функция является лямбда-выражением без аргументов. Мы можем просто скомпилировать тело лямбда-выражения, как если бы это было выражение <code>begin</code>. Непримитивные функции требуют вызова функции. Есть два случая: когда нужно скомпилировать больше, мы должны сохранить точку продолжения, и когда мы компилируем конечное значение функции, мы можем просто ответвляться(переходить) на вызываемую функцию. Все это выглядит примерно так:</p>
<div class="fragment"><div class="line">(defun comp-funcall (f args env val? more?)</div><div class="line">  &quot;Compile an application of a function to arguments.&quot;</div><div class="line">  (let ((prim (primitive-p f env (length args))))</div><div class="line">    (cond</div><div class="line">      (prim  ; function compilable to a primitive instruction</div><div class="line">       (if (and (not val?) (not (prim-side-effects prim)))</div><div class="line">           ;; Side-effect free primitive when value unused</div><div class="line">           (comp-begin args env nil more?)</div><div class="line">           ;; Primitive with value or call needed</div><div class="line">           (seq (comp-list args env)</div><div class="line">                (gen (prim-opcode prim))</div><div class="line">                (unless val? (gen &#39;POP))</div><div class="line">                (unless more? (gen &#39;RETURN)))))</div><div class="line">      ((and (starts-with f &#39;lambda) (null (second f)))</div><div class="line">       ;; ((lambda () body)) =&gt; (begin body)</div><div class="line">       (assert (null args) () &quot;Too many arguments supplied&quot;)</div><div class="line">       (comp-begin (rest2 f) env val? more?))</div><div class="line">      (more? ; Need to save the continuation point</div><div class="line">       (let ((k (gen-label &#39;k)))</div><div class="line">         (seq (gen &#39;SAVE k)</div><div class="line">              (comp-list args env)</div><div class="line">              (comp f env t t)</div><div class="line">              (gen &#39;CALLJ (length args))</div><div class="line">              (list k)</div><div class="line">              (if (not val?) (gen &#39;POP)))))</div><div class="line">      (t     ; function call as rename plus goto</div><div class="line">       (seq (comp-list args env)</div><div class="line">            (comp f env t t)</div><div class="line">            (gen &#39;CALLJ (length args)))))))</div></div><!-- fragment --><p>Поддержка примитивов проста. Тип данных <code>prim</code> имеет пять слотов. Первый содержит имя символа, глобально связанного с примитивной операцией. Второй, <code>n-args</code>, - это число аргументов, требующихся примитиву. Мы должны учитывать количество аргументов для каждой функции, потому что мы хотим, чтобы <code>(+ x y)</code> компилировалась в примитивную инструкцию сложения, в то время как <code>(+ x y z)</code> нет. Вместо этого она будет компилироваться в вызов функции +. Слот <code>opcode</code> дает код операции, который используется для реализации примитива. Поле <code>always</code> истинно, если примитив всегда возвращает не-nil значение, <code>ложно</code>, если оно всегда возвращает nil, и nil в противном случае. Оно используется в упражнении 23.6. Наконец, поле <code>side-effects</code> указывает, есть ли у функции какие-либо побочные эффекты, такие как выполнение ввода-вывода или изменение значения объекта.</p>
<div class="fragment"><div class="line">(defstruct (prim (:type list))</div><div class="line">  symbol n-args opcode always side-effects)</div><div class="line"></div><div class="line">(defparameter *primitive-fns*</div><div class="line">  &#39;((+ 2 + true nil) (- 2 - true nil) (* 2 * true nil) (/ 2 / true nil)</div><div class="line">    (&lt; 2 &lt; nil nil) (&gt; 2 &gt; nil nil) (&lt;= 2 &lt;= nil nil) (&gt;= 2 &gt;= nil nil)</div><div class="line">    (/= 2 /= nil nil) (= 2 = nil nil)</div><div class="line">    (eq? 2 eq nil nil) (equal? 2 equal nil nil) (eqv? 2 eql nil nil)</div><div class="line">    (not 1 not nil nil) (null? 1 not nil nil) (cons 2 cons true nil)</div><div class="line">    (car 1 car nil nil) (cdr 1 cdr nil nil)  (cadr 1 cadr nil nil)</div><div class="line">    (list 1 list1 true nil) (list 2 list2 true nil) (list 3 list3 true nil)</div><div class="line">    (read 0 read nil t) (write 1 write nil t) (display 1 display nil t)</div><div class="line">    (newline 0 newline nil t) (compiler 1 compiler t nil)</div><div class="line">    (name! 2 name! true t) (random 1 random true nil)))</div><div class="line"></div><div class="line">(defun primitive-p (f env n-args)</div><div class="line">  &quot;F is a primitive if it is in the table, and is not shadowed</div><div class="line">  by something in the environment, and has the right number of args.&quot;</div><div class="line">  (and (not (in-env-p f env))</div><div class="line">       (find f *primitive-fns*</div><div class="line">             :test #&#39;(lambda (f prim)</div><div class="line">                       (and (eq f (prim-symbol prim))</div><div class="line">                            (= n-args (prim-n-args prim)))))))</div><div class="line"></div><div class="line">(defun list1 (x) (list x))</div><div class="line">(defun list2 (x y) (list x y))</div><div class="line">(defun list3 (x y z) (list x y z))</div><div class="line">(defun display (x) (princ x))</div><div class="line">(defun newline () (terpri))</div></div><!-- fragment --><p>Эти оптимизации работают только в том случае, если символы постоянно привязаны к глобальным значениям, приведенным здесь. Мы можем обеспечить это, изменив <code>gen-set</code>, чтобы сохранить их как константы:</p>
<div class="fragment"><div class="line">(defun gen-set (var env)</div><div class="line">  &quot;Generate an instruction to set a variable to top-of-stack.&quot;</div><div class="line">  (let ((p (in-env-p var env)))</div><div class="line">    (if p</div><div class="line">        (gen &#39;LSET (first p) (second p) &quot;;&quot; var)</div><div class="line">        (if (assoc var *primitive-fns*)</div><div class="line">            (error &quot;Can&#39;t alter the constant ~a&quot; var)</div><div class="line">            (gen &#39;GSET var)))))</div></div><!-- fragment --><p>Теперь выражение типа <code>(+ x 1)</code> будет правильно скомпилировано с использованием инструкции +, а не вызова подпрограммы, и выражение типа <code>(set ! + *)</code> будет помечено как ошибка, если + является глобальной переменной, но разрешено, если он был локально привязан. Однако нам все еще нужно уметь обрабатывать такие выражения, как <code>(set! add +)</code>, а затем <code>(add x y)</code>. Таким образом, нам нужен некоторый объект функции, к которому + будет глобально привязан, даже если компилятор обычно оптимизирует ссылки на эту функцию. Функция <code>init-scheme-comp</code> заботится об этом требовании:</p>
<div class="fragment"><div class="line">(defun init-scheme-comp ()</div><div class="line">  &quot;Initialize the primitive functions.&quot;</div><div class="line">  (dolist (prim *primitive-fns*)</div><div class="line">     (setf (get (prim-symbol prim) &#39;global-val)</div><div class="line">           (new-fn :env nil :name (prim-symbol prim)</div><div class="line">                   :code (seq (gen &#39;PRIM (prim-symbol prim))</div><div class="line">                              (gen &#39;RETURN))))))</div></div><!-- fragment --><p>Нужно внести еще одно изменение - переписать <code>comp-lambda</code>. Нам все еще нужно извлечь аргументы из стека, но мы больше не генерируем инструкцию <code>RETURN</code>, так как это делается <code>comp-begin</code>, если это необходимо. На этом этапе мы предоставим hook для подсматривающего(peephole) оптимизатора, который будет представлен в <a href="#s0025">разделе 23.4</a>, и для ассемблера, чтобы преобразовать язык ассемблера в машинный код, <code>new-fn</code> предоставляет этот интерфейс, но пока <code>new-fn</code> действует точно так же, как <code>make-fn</code>.</p>
<p>Мы также должны учитывать возможность rest аргументов в лямбда-списке. Новая функция, <code>gen-rgs</code>, генерирует единственную инструкцию для загрузки аргументов стека. Она вводит новую инструкцию, <code>ARGS</code>., в абстрактную машину. Эта инструкция работает точно так же, как <code>ARGS</code>, за исключением того, что она также сохраняет все оставшиеся в стеке аргументы в список и сохраняет этот список как значение аргумента rest. С этим нововведением новая версия <code>comp-lambda</code> выглядит следующим образом:</p>
<div class="fragment"><div class="line">(defun comp-lambda (args body env)</div><div class="line">  &quot;Compile a lambda form into a closure with compiled code.&quot;</div><div class="line">  (new-fn :env env :args args</div><div class="line">          :code (seq (gen-args args 0)</div><div class="line">                     (comp-begin body</div><div class="line">                                 (cons (make-true-list args) env)</div><div class="line">                                 t nil))))</div><div class="line"></div><div class="line">(defun gen-args (args n-so-far)</div><div class="line">  &quot;Generate an instruction to load the arguments.&quot;</div><div class="line">  (cond ((null args) (gen &#39;ARGS n-so-far))</div><div class="line">        ((symbolp args) (gen &#39;ARGS. n-so-far))</div><div class="line">        ((and (consp args) (symbolp (first args)))</div><div class="line">         (gen-args (rest args) (+ n-so-far 1)))</div><div class="line">        (t (error &quot;Illegal argument list&quot;))))</div><div class="line"></div><div class="line">(defun make-true-list (dotted-list)</div><div class="line">  &quot;Convert a possibly dotted list into a true, non-dotted list.&quot;</div><div class="line">  (cond ((null dotted-list) nil)</div><div class="line">        ((atom dotted-list) (list dotted-list))</div><div class="line">        (t (cons (first dotted-list)</div><div class="line">                 (make-true-list (rest dotted-list))))))</div><div class="line"></div><div class="line">(defun new-fn (&amp;key code env name args)</div><div class="line">  &quot;Build a new function.&quot;</div><div class="line">  (assemble (make-fn :env env :name name :args args</div><div class="line">                     :code (optimize code))))</div></div><!-- fragment --><p><code>new-fn</code> включает вызовы ассемблера и оптимизатора для генерации фактического машинного кода. На данный момент обе функции будут идентичными:</p>
<div class="fragment"><div class="line">(defun optimize (code) code)</div><div class="line">(defun assemble (fn) fn)</div></div><!-- fragment --><p>Вот еще несколько примеров работы компилятора:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(if (null? (car l)) (f (+ (* a x) b)) (g (/ x 2))))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>L</code> </td><td></td></tr>
<tr>
<td></td><td><code>CAR</code> </td><td></td><td></td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>X</code> </td><td></td></tr>
<tr>
<td></td><td><code>2</code> </td><td></td><td></td></tr>
<tr>
<td></td><td>/ </td><td></td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>G</code> </td><td></td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td><td></td></tr>
<tr>
<td><code>L1:</code> </td><td><code>GVAR</code> </td><td><code>A</code> </td><td></td></tr>
<tr>
<td></td><td></td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td></td><td><code>*</code> </td><td></td></tr>
<tr>
<td></td><td></td><td><code>GVAR</code> </td><td><code>B</code> </td></tr>
<tr>
<td></td><td></td><td><code>+</code> </td><td></td></tr>
<tr>
<td></td><td></td><td><code>GVAR</code> </td><td><code>F</code> </td></tr>
<tr>
<td></td><td></td><td><code>CALLJ</code> </td><td><code>1</code> </td></tr>
</table>
<p>В этом коде нет необходимости сохранять какие-либо точки продолжения, поскольку единственные вызовы непримитивных функций происходят как конечные значения двух ветвей функции.</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(define (lastl l)</div></div><!-- fragment --><p><code>(if (null? (cdr l)) (car l)</code></p>
<div class="fragment"><div class="line">(last1 (cdr l)))))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td><td></td></tr>
<tr>
<td></td><td><code>CDR</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td><td></td></tr>
<tr>
<td></td><td><code>CDR</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>LAST1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CALLJ</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>L1:</code> </td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td></tr>
<tr>
<td></td><td></td><td><code>CAR</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>GSET</code> </td><td><code>LAST1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>LAST1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>NAME!</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>Функция верхнего уровня просто присваивает вложенную функцию глобальной переменной <code>last1</code>. Поскольку <code>last1</code> является хвосто-рекурсивной, она имеет только одну точку возврата для случая завершения и просто вызывает себя без сохранения продолжений до тех пор, пока этот случай не будет выполнен.</p>
<p>Сравните это с приведенным ниже не хвосто-рекурсивным определением <code>length</code>. Она не является хвостово-рекурсивной, потому что перед рекурсивным вызовом <code>length</code> она должна сохранить точку продолжения, <code>K1</code>, чтобы знать, куда вернуться, чтобы добавить 1.</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(define (length l)</div></div><!-- fragment --><p><code>(if (null? l) 0 (+ 1 (length (cdr l))))))</code></p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>ARGS</code> </td><td><code>1</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td></tr>
<tr>
<td></td><td></td><td><code>FJUMP</code> </td><td><code>L2</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>SAVE</code> </td><td><code>K1</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td></tr>
<tr>
<td></td><td></td><td><code>CDR</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>GVAR</code> </td><td><code>LENGTH</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>CALLJ</code> </td><td><code>1</code> </td><td></td><td></td><td></td></tr>
<tr>
<td><code>K1:</code> </td><td></td><td><code>+</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td><code>L2</code> </td><td></td><td><code>0</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>GSET</code> </td><td><code>LENGTH</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>LENGTH</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>NAME!</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>Конечно, можно написать <code>length</code> в хвостовой рекурсивной манере:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(define (length l)</div><div class="line">                            (letrec ((len (lambda (l n)</div></div><!-- fragment --><p><code>(if (null? l) n</code></p>
<div class="fragment"><div class="line">                                    (len (rest l) (+ n l))))))</div><div class="line">(len l 0))))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>ARGS</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>NIL</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>ARGS</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>FN</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>ARGS</code> </td><td><code>2</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>FJUMP</code> </td><td><code>L2</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>SAVE</code> </td><td><code>K1</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>GVAR</code> </td><td><code>REST</code> </td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>CALLJ</code> </td><td><code>1</code> </td><td></td><td></td><td></td></tr>
<tr>
<td><code>K1:</code> </td><td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>1</code> </td><td><code>;</code> </td><td><code>N</code> </td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>1</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>+</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>1</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>LEN</code> </td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>CALLJ</code> </td><td><code>2</code> </td><td></td><td></td><td></td></tr>
<tr>
<td><code>L2:</code> </td><td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>1</code> </td><td><code>;</code> </td><td><code>N</code> </td></tr>
<tr>
<td></td><td></td><td></td><td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>LSET</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>LEN</code> </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>POP</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>1</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>L</code> </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>0</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>LVAR</code> </td><td><code>0</code> </td><td><code>0</code> </td><td><code>;</code> </td><td><code>LEN</code> </td><td></td></tr>
<tr>
<td></td><td></td><td></td><td><code>CALLJ</code> </td><td><code>2</code> </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td><code>CALLJ</code> </td><td><code>1</code> </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>GSET</code> </td><td><code>LENGTH</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>CONST</code> </td><td><code>LENGTH</code> </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>NAME!</code> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>Давайте еще раз рассмотрим пример с вложенными условными обозначениями:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(if (not (and p q (not r))) x y))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>P</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L3</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Q</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>R</code> </td></tr>
<tr>
<td></td><td><code>NOT</code> </td><td></td></tr>
<tr>
<td></td><td><code>JUMP</code> </td><td><code>L2</code> </td></tr>
<tr>
<td><code>L1:</code> </td><td><code>NIL</code> </td><td></td></tr>
<tr>
<td><code>L2:</code> </td><td><code>JUMP</code> </td><td><code>L4</code> </td></tr>
<tr>
<td><code>L3:</code> </td><td><code>NIL</code> </td><td></td></tr>
<tr>
<td><code>L4:</code> </td><td><code>FJUMP</code> </td><td><code>L5</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
<tr>
<td><code>L5:</code> </td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Здесь проблема заключается в множественном <code>JUMP</code> и в нераспознавании отрицания. Если <code>p</code> ложно, то выражение <code>and</code> ложно, а весь предикат истинен, поэтому мы должны вернуть <code>x</code>. Код делает на самом деле возврат <code>х</code>, но сначала он прыгает на <code>L3</code>, загружает <code>NIL</code>, а затем делает <code>FJUMP</code>, который всегда будет прыгать на <code>L5</code>. Другие ветви обладают аналогичной неэффективностью. Достаточно умный компилятор должен уметь генерировать следующий код:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td></td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>P</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Q</code> </td></tr>
<tr>
<td></td><td><code>FJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>R</code> </td></tr>
<tr>
<td></td><td><code>TJUMP</code> </td><td><code>L1</code> </td></tr>
<tr>
<td></td><td><code>GVAR</code> </td><td><code>Y</code> </td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
<tr>
<td><code>L1:</code> </td><td><code>GVAR X</code> </td><td></td></tr>
<tr>
<td></td><td><code>RETURN</code> </td><td></td></tr>
</table>
<h2>23.2 Введение Call/cc</h2>
<p>Теперь, когда базовый компилятор работает, мы можем подумать о том, как реализовать <code>call/cc</code> в нашем компиляторе. Во-первых, помните, что <code>call/cc</code> - это нормальная(обычная) функция, а не специальная форма. Таким образом, мы могли бы определить её как примитивную, на манер <code>car</code> и <code>cons</code>. Однако примитивы в том виде, в каком они были определены, могут видеть только свои аргументы, а <code>call/cc</code> должна будет видеть стек времени выполнения, чтобы сохранить текущее продолжение. Один из вариантов - установить <code>call/cc</code> как обычную Непримитивную функцию Scheme, но написать ее тело в ассемблерном коде самостоятельно. Нам нужно ввести одну новую инструкцию, <code>CC</code>, которая помещает в стек функцию (к которой мы также должны написать ассемблерный код вручную), которая сохраняет текущее продолжение (стек) в своей среде окружения и при вызове извлекает это продолжение и устанавливает его, возвращая стеку это значение. Для этого требуется еще одна инструкция, <code>SET-CC</code>. Подробности этой и всех других инструкций раскрываются в следующем разделе.</p>
<h2>23.3 Абстрактная Машина</h2>
<p>До сих пор мы определяли набор команд мифической абстрактной машины и генерировали ассемблерный код для этого набора команд. Теперь пришло время фактически выполнить ассемблерный код и, следовательно, иметь полезный компилятор. Есть несколько путей, которые мы могли бы использовать: мы могли бы реализовать машину в аппаратном, программном обеспечении или микрокоде, или мы могли бы перевести ассемблерный код для нашей абстрактной машины в ассемблерный код какой-либо существующей машины. Каждый из этих подходов уже применялся в прошлом.</p>
<p><b>Железо.</b> *Если абстрактная машина достаточно проста, она может быть реализована непосредственно в аппаратном обеспечении. Чипы Scheme-79 и Scheme-81 (<a href="B9780080571157500285.xhtml#bb1180">Стилл и Sussman 1980</a>; <a href="B9780080571157500285.xhtml#bb0070">Batali et al. 1982</a>) были СБИС-реализациями машины, разработанной специально для запуска Scheme.(B9780080571157500285.xhtml::bb1180);</p>
<p><b>Макроассемблер.</b> в подходе трансляции или макроассемблера каждая инструкция на абстрактном машинном языке переводится в одну или несколько инструкций в наборе команд целевого компьютера. Это может быть сделано либо непосредственно, либо путем генерации кода сборки и передачи его ассемблеру целевого компьютера. В общем случае это приведет к расширению кода, поскольку целевой компьютер, вероятно, не будет обеспечивать прямую поддержку типов данных схемы. Таким образом, в то время как в нашей абстрактной машине мы могли бы написать одну инструкцию для сложения, с машинным кодом нам, возможно, придется выполнить серию инструкций, чтобы проверить тип аргументов, сделать целочисленное сложение, если они оба являются целыми числами, сложение с плавающей запятой, если они оба являются числами с плавающей запятой, и так далее. Возможно, нам также придется проверить результат на переполнение и, возможно, преобразовать его в представление bignum. Компиляторы, генерирующие машинный код, часто включают более сложный анализ потока данных, чтобы знать, когда такие проверки необходимы, а когда их можно пропустить.</p>
<p><b>Микрокод.</b> проект MIT Lisp Machine, в отличие от чипов Scheme, фактически привел к рабочим машинам. Одним из важных решений было использование микрокода вместо одиночного чипа. Это позволило легко изменить систему по мере накопления опыта, а также по мере изменения языка хоста с ZetaLisp на Common Lisp. Наиболее важной архитектурной особенностью Lisp машины было включение битов тегов в каждое слово для указания типов данных. Также важным был микрокод для реализации некоторых часто используемых универсальных операций. Например, в Lisp машине Symbolics 3600 микрокод для сложения одновременно выполнял сложение целого числа, сложение с плавающей запятой и проверку битов тега. Если оба аргумента оказывались либо целыми числами, либо числами с плавающей запятой, то принимался соответствующий результат. В противном случае был подан сигнал о ловушке, и выполнялся вход в процедуру конверсии. Этот подход делает компилятор относительно простым, но тенденция в архитектуре уходит от высоко микрокодированных процессоров к более простым (RISC) процессорам.</p>
<p><b>Программное обеспечение.</b> Мы можем устранить многие из этих проблем с помощью технологии, известной как <em>сбокра байт-кода.</em> Здесь мы переводим инструкции в вектор байтов, а затем интерпретируем байты с помощью интерпретатора байт-кода. Это дает нам (почти) машину, которую мы хотим; это решает проблему расширения кода, но это может быть медленнее, чем компиляция в нативный кода(код хост машины), потому что интерпретатор байт-кода написан в программном обеспечении, а не аппаратном или микрокоде.</p>
<p>Каждый код операции представляет собой один байт (у нас есть менее 256 кодов операций, так что это будет работать). Инструкции с аргументами принимают свои аргументы в следующих байтах потока команд. Так, например, инструкция <code>CALL</code> занимает два байта: один для кода операции и один для количества аргументов. Это означает, что мы установили ограничение в 256 аргументов для вызова функции. Инструкция <code>LVAR</code> будет занимать три байта: один для кода операции, один для смещения кадра и один для смещения внутри кадра. Опять же, мы установили 256 в качестве ограничения на уровень вложенности и переменные на кадр. Эти ограничения кажутся достаточно высокими для любого кода, написанного человеком, но помните, что не только люди пишут код. Вполне возможно, что какой-то сложный макрос может расшириться до чего-то с более чем 256 переменными, поэтому полная реализация будет иметь некоторый способ учета этого. Инструкции <code>GVAR</code> и <code>CONST</code> должны ссылаться на произвольный объект; либо мы можем выделить достаточно байтов, чтобы поместить указатель на этот объект, либо мы можем добавить поле <code>constants</code> в структуру <code>fn</code> и следовать инструкциям с однобайтовым индексом в этот вектор констант. Этот последний подход более распространен.</p>
<p>Теперь мы можем обрабатывать ветви, изменяя счетчик программы на индекс в кодовом векторе. (Ограничение функций до 256 байт кода кажется суровым; двухбайтовая метка позволяет использовать 65536 байт кода для каждой функции.) Таким образом, код более компактен, ветвление эффективно, а диспетчеризация может быть быстрой, потому что код операции-это маленькое целое число, и мы можем использовать таблицу ветвей, чтобы перейти к нужному фрагменту кода для каждой инструкции.</p>
<p>Другим источником неэффективности является реализация стека в виде списка и создание новых ячеек каждый раз, когда что-то добавляется в стек. Альтернативой является реализация стека в виде вектора с указателем заполнения. Таким образом, push не требует никакого консинга(создания списка), а только изменения указателя (и проверки на переполнение). Однако эта проверка имеет смысл, поскольку позволяет обнаружить бесконечные циклы в коде пользователя.</p>
<p>Далее следует ассемблер, который генерирует последовательность инструкций (в виде вектора). Это компромисс между байтовыми кодами и форматом языка ассемблера. Во - первых, нам нужны некоторые функции доступа, чтобы добраться до частей инструкции:</p>
<div class="fragment"><div class="line">(defun opcode (instr) (if (label-p instr) :label (first instr)))</div><div class="line">(defun args (instr) (if (listp instr) (rest instr)))</div><div class="line">(defun arg1 (instr) (if (listp instr) (second instr)))</div><div class="line">(defun arg2 (instr) (if (listp instr) (third instr)))</div><div class="line">(defun arg3 (instr) (if (listp instr) (fourth instr)))</div><div class="line"></div><div class="line">(defsetf arg1 (instr) (val) `(setf (second ,instr) ,val))</div></div><!-- fragment --><p>Теперь мы пишем ассемблер, который уже интегрирован в компилятор с хуком в <code>new-fn</code>.</p>
<div class="fragment"><div class="line">(defun assemble (fn)</div><div class="line">  &quot;Turn a list of instructions into a vector.&quot;</div><div class="line">  (multiple-value-bind (length labels)</div><div class="line">      (asm-first-pass (fn-code fn))</div><div class="line">    (setf (fn-code fn)</div><div class="line">          (asm-second-pass (fn-code fn)</div><div class="line">                           length labels))</div><div class="line">    fn))</div><div class="line"></div><div class="line">(defun asm-first-pass (code)</div><div class="line">  &quot;Return the labels and the total code length.&quot;</div><div class="line">  (let ((length 0)</div><div class="line">        (labels nil))</div><div class="line">    (dolist (instr code)</div><div class="line">      (if (label-p instr)</div><div class="line">          (push (cons instr length) labels)</div><div class="line">          (incf length)))</div><div class="line">    (values length labels)))</div><div class="line"></div><div class="line">(defun asm-second-pass (code length labels)</div><div class="line">  &quot;Put code into code-vector, adjusting for labels.&quot;</div><div class="line">  (let ((addr 0)</div><div class="line">        (code-vector (make-array length)))</div><div class="line">    (dolist (instr code)</div><div class="line">      (unless (label-p instr)</div><div class="line">        (if (is instr &#39;(JUMP TJUMP FJUMP SAVE))</div><div class="line">            (setf (arg1 instr)</div><div class="line">                  (cdr (assoc (arg1 instr) labels))))</div><div class="line">        (setf (aref code-vector addr) instr)</div><div class="line">        (incf addr)))</div><div class="line">    code-vector))</div></div><!-- fragment --><p>Если мы хотим иметь возможность смотреть на ассемблерный код, нам нужна новая функция печати:</p>
<div class="fragment"><div class="line">(defun show-fn (fn &amp;optional (stream *standard-output*) (indent 2))</div><div class="line">  &quot;Print all the instructions in a function.</div><div class="line">  If the argument is not a function, just princ it,</div><div class="line">  but in a column at least 8 spaces wide.&quot;</div><div class="line">  ;; This version handles code that has been assembled into a vector</div><div class="line">  (if (not (fn-p fn))</div><div class="line">      (format stream &quot;~8a&quot; fn)</div><div class="line">      (progn</div><div class="line">        (fresh-line)</div><div class="line">        (dotimes (i (length (fn-code fn)))</div><div class="line">          (let ((instr (elt (fn-code fn) i)))</div><div class="line">            (if (label-p instr)</div><div class="line">                (format stream &quot;~a:&quot; instr)</div><div class="line">                (progn</div><div class="line">                  (format stream &quot;~VT~2d: &quot; indent i)</div><div class="line">                  (dolist (arg instr)</div><div class="line">                    (show-fn arg stream (+ indent 8)))</div><div class="line">                  (fresh-line))))))))</div><div class="line"></div><div class="line">(defstruct ret-addr fn pc env)</div><div class="line"></div><div class="line">(defun is (instr op)</div><div class="line">  &quot;True if instr&#39;s opcode is OP, or one of OP when OP is a list.&quot;</div><div class="line">  (if (listp op)</div><div class="line">      (member (opcode instr) op)</div><div class="line">      (eq (opcode instr) op)))</div><div class="line"></div><div class="line">(defun top (stack) (first stack))</div><div class="line"></div><div class="line">(defun machine (f)</div><div class="line">  &quot;Run the abstract machine on the code for f.&quot;</div><div class="line">  (let* ((code (fn-code f))</div><div class="line">         (pc 0)</div><div class="line">         (env nil)</div><div class="line">         (stack nil)</div><div class="line">         (n-args 0)</div><div class="line">         (instr nil))</div><div class="line">    (loop</div><div class="line">       (setf instr (elt code pc))</div><div class="line">       (incf pc)</div><div class="line">       (case (opcode instr)</div><div class="line"></div><div class="line">         ;; Variable/stack manipulation instructions:</div><div class="line">         (LVAR   (push (elt (elt env (arg1 instr)) (arg2 instr))</div><div class="line">                       stack))</div><div class="line">         (LSET   (setf (elt (elt env (arg1 instr)) (arg2 instr))</div><div class="line">                       (top stack)))</div><div class="line">         (GVAR   (push (get (arg1 instr) &#39;global-val) stack))</div><div class="line">         (GSET   (setf (get (arg1 instr) &#39;global-val) (top stack)))</div><div class="line">         (POP    (pop stack))</div><div class="line">         (CONST  (push (arg1 instr) stack))</div><div class="line"></div><div class="line">         ;; Branching instructions:</div><div class="line">         (JUMP   (setf pc (arg1 instr)))</div><div class="line">         (FJUMP  (if (null (pop stack)) (setf pc (arg1 instr))))</div><div class="line">         (TJUMP  (if (pop stack) (setf pc (arg1 instr))))</div><div class="line"></div><div class="line">         ;; Function call/return instructions:</div><div class="line">         (SAVE   (push (make-ret-addr :pc (arg1 instr)</div><div class="line">                                      :fn f :env env)</div><div class="line">                       stack))</div><div class="line">         (RETURN ;; return value is top of stack; ret-addr is second</div><div class="line">          (setf f (ret-addr-fn (second stack))</div><div class="line">                code (fn-code f)</div><div class="line">                env (ret-addr-env (second stack))</div><div class="line">                pc (ret-addr-pc (second stack)))</div><div class="line">          ;; Get rid of the ret-addr, but keep the value</div><div class="line">          (setf stack (cons (first stack) (rest2 stack))))</div><div class="line">         (CALLJ  (pop env)                 ; discard the top frame</div><div class="line">                 (setf f  (pop stack)</div><div class="line">                       code (fn-code f)</div><div class="line">                       env (fn-env f)</div><div class="line">                       pc 0</div><div class="line">                       n-args (arg1 instr)))</div><div class="line">         (ARGS   (assert (= n-args (arg1 instr)) ()</div><div class="line">                         &quot;Wrong number of arguments:~</div><div class="line">                         ~d expected, ~d supplied&quot;</div><div class="line">                         (arg1 instr) n-args)</div><div class="line">                 (push (make-array (arg1 instr)) env)</div><div class="line">                 (loop for i from (- n-args 1) downto 0 do</div><div class="line">                       (setf (elt (first env) i) (pop stack))))</div><div class="line">         (ARGS.  (assert (&gt;= n-args (arg1 instr)) ()</div><div class="line">                         &quot;Wrong number of arguments:~</div><div class="line">                         ~d or more expected, ~d supplied&quot;</div><div class="line">                         (arg1 instr) n-args)</div><div class="line">                 (push (make-array (+ 1 (arg1 instr))) env)</div><div class="line">                 (loop repeat (- n-args (arg1 instr)) do</div><div class="line">                       (push (pop stack) (elt (first env) (arg1 instr))))</div><div class="line">                 (loop for i from (- (arg1 instr) 1) downto 0 do</div><div class="line">                       (setf (elt (first env) i) (pop stack))))</div><div class="line">         (FN     (push (make-fn :code (fn-code (arg1 instr))</div><div class="line">                                :env env) stack))</div><div class="line">         (PRIM   (push (apply (arg1 instr)</div><div class="line">                              (loop with args = nil repeat n-args</div><div class="line">                                    do (push (pop stack) args)</div><div class="line">                                    finally (return args)))</div><div class="line">                       stack))</div><div class="line"></div><div class="line">         ;; Continuation instructions:</div><div class="line">         (SET-CC (setf stack (top stack)))</div><div class="line">         (CC     (push (make-fn</div><div class="line">                         :env (list (vector stack))</div><div class="line">                         :code &#39;((ARGS 1) (LVAR 1 0 &quot;;&quot; stack) (SET-CC)</div><div class="line">                                 (LVAR 0 0) (RETURN)))</div><div class="line">                       stack))</div><div class="line"></div><div class="line">         ;; Nullary operations:</div><div class="line">         ((SCHEME-READ NEWLINE) ; *** fix, gat, 11/9/92</div><div class="line">          (push (funcall (opcode instr)) stack))</div><div class="line"></div><div class="line">         ;; Unary operations:</div><div class="line">         ((CAR CDR CADR NOT LIST1 COMPILER DISPLAY WRITE RANDOM)</div><div class="line">          (push (funcall (opcode instr) (pop stack)) stack))</div><div class="line"></div><div class="line">         ;; Binary operations:</div><div class="line">         ((+ - * / &lt; &gt; &lt;= &gt;= /= = CONS LIST2 NAME! EQ EQUAL EQL)</div><div class="line">          (setf stack (cons (funcall (opcode instr) (second stack)</div><div class="line">                                     (first stack))</div><div class="line">                            (rest2 stack))))</div><div class="line"></div><div class="line">         ;; Ternary operations:</div><div class="line">         (LIST3</div><div class="line">          (setf stack (cons (funcall (opcode instr) (third stack)</div><div class="line">                                     (second stack) (first stack))</div><div class="line">                            (rest3 stack))))</div><div class="line"></div><div class="line">         ;; Constants:</div><div class="line">         ((T NIL -1 0 1 2)</div><div class="line">          (push (opcode instr) stack))</div><div class="line"></div><div class="line">         ;; Other:</div><div class="line">         ((HALT) (RETURN (top stack)))</div><div class="line">         (otherwise (error &quot;Unknown opcode: ~a&quot; instr))))))</div><div class="line"></div><div class="line">(defun init-scheme-comp ()</div><div class="line">  &quot;Initialize values (including call/cc) for the Scheme compiler.&quot;</div><div class="line">  (set-global-var! &#39;exit</div><div class="line">    (new-fn :name &#39;exit :args &#39;(val) :code &#39;((HALT))))</div><div class="line">  (set-global-var! &#39;call/cc</div><div class="line">    (new-fn :name &#39;call/cc :args &#39;(f)</div><div class="line">            :code &#39;((ARGS 1) (CC) (LVAR 0 0 &quot;;&quot; f)</div><div class="line">            (CALLJ 1)))) ; *** Bug fix, gat, 11/9/92</div><div class="line">  (dolist (prim *primitive-fns*)</div><div class="line">     (setf (get (prim-symbol prim) &#39;global-val)</div><div class="line">           (new-fn :env nil :name (prim-symbol prim)</div><div class="line">                   :code (seq (gen &#39;PRIM (prim-symbol prim))</div><div class="line">                              (gen &#39;RETURN))))))</div></div><!-- fragment --><p>Вот верхний уровень Scheme. Обратите внимание, что он написан на самой Scheme; мы компилируем определение цикла read-eval-print, <a href="#fn0010">1</a> загружаем его в машину, а затем начинаем выполнять. Существует также интерфейс для компиляции и выполнения единичного выражения <code>comp-go</code>.</p>
<div class="fragment"><div class="line">(defconstant scheme-top-level</div><div class="line">  &#39;(begin (define (scheme)</div><div class="line">            (newline)</div><div class="line">            (display &quot;=&gt; &quot;)</div><div class="line">            (write ((compiler (read))))</div><div class="line">            (scheme))</div><div class="line">          (scheme)))</div><div class="line"></div><div class="line">(defun scheme ()</div><div class="line">  &quot;A compiled Scheme read-eval-print loop&quot;</div><div class="line">  (init-scheme-comp)</div><div class="line">  (machine (compiler scheme-top-level)))</div><div class="line"></div><div class="line">(defun comp-go (exp)</div><div class="line">  &quot;Compile and execute the expression.&quot;</div><div class="line">  (machine (compiler `(exit ,exp))))</div></div><!-- fragment --><p><b>Exercise 23.2 [m]</b> Эта реализация машины расточительна в своем представлении сред окружения. Например, рассмотрим, что происходит в хвостово-рекурсивной функции. Каждая инструкция <code>ARG</code> строит новый фрейм и помещает его в окружение. Затем каждый <code>CALL</code> извлекает последний кадр из окружающей среды. Таким образом, хотя стек не растет с хвостовыми рекурсивными вызовами, куча определенно растет. В конце концов, нам придется собрать(убрать мусор) все эти неиспользуемые кадры (и ячейки cons, используемые для составления списков из них). Как мы могли бы избежать или ограничить эту сборку мусора?</p>
<h2>23.4 Подглядывающий(Peephole) Опримизатор</h2>
<p>В этом разделе мы исследуем простую технику, которая будет генерировать немного лучший код в тех случаях, когда компилятор дает неэффективные последовательности инструкций. Идея состоит в том, чтобы посмотреть на короткие последовательности инструкций для заранее определенных шаблонов и заменить их эквивалентными, но более эффективными инструкциями.</p>
<p>В следующем примере <code>comp-if</code> уже произвел некоторую оптимизацию на уровне исходного кода, например устранил вызов <code>(f x)</code>.</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (if (if t 1 (f x)) (set! x 2)) x))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td>1: </td><td>1 </td><td></td></tr>
<tr>
<td><code>2:</code> </td><td><code>FJUMP</code> </td><td><code>6</code> </td></tr>
<tr>
<td><code>3:</code> </td><td><code>2</code> </td><td></td></tr>
<tr>
<td><code>4:</code> </td><td><code>GSET</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>5:</code> </td><td><code>POP</code> </td><td></td></tr>
<tr>
<td><code>6:</code> </td><td><code>GVAR</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>7:</code> </td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Но сгенерированный код можно было бы сделать намного лучше. Это можно было бы сделать с помощью дополнительных оптимизаций исходного уровня для преобразования выражения в `(set! x 2)'. В качестве альтернативы это можно было бы также сделать, рассмотрев предыдущую последовательность инструкций и трансформировав локальные неэффективности. Оптимизатор, представленный в этом разделе, способен генерировать следующий код:</p>
<div class="fragment"><div class="line">&gt; (comp-show &#39;(begin (if (if t 1 (f x)) (set! x 2)) x))</div></div><!-- fragment --><table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td><code>0:</code> </td><td><code>ARGS</code> </td><td><code>0</code> </td></tr>
<tr>
<td>1: </td><td>2 </td><td></td></tr>
<tr>
<td><code>2:</code> </td><td><code>GSET</code> </td><td><code>X</code> </td></tr>
<tr>
<td><code>3:</code> </td><td><code>RETURN</code> </td><td></td></tr>
</table>
<p>Функция <code>optimize</code> реализована как функция управляемая данными, которая просматривает код операции каждой инструкции и производит оптимизацию на основе последующих инструкций. Чтобы быть более конкретным, <code>optimize</code> берет список инструкций языка ассемблера и просматривает каждую инструкцию по порядку, пытаясь применить оптимизацию. Если какие-либо изменения вообще будут внесены, то <code>оптимизация</code> будет вызвана снова во всем списке команд, потому что дальнейшие изменения могут быть вызваны первым раундом изменений.</p>
<div class="fragment"><div class="line">(defun optimize (code)</div><div class="line">  &quot;Perform peephole optimization on assembly code.&quot;</div><div class="line">  (let ((any-change nil))</div><div class="line">    ;; Optimize each tail</div><div class="line">    (loop for code-tail on code do</div><div class="line">          (setf any-change (or (optimize-1 code-tail code)</div><div class="line">                               any-change)))</div><div class="line">    ;; If any changes were made, call optimize again</div><div class="line">    (if any-change</div><div class="line">        (optimize code)</div><div class="line">        code)))</div></div><!-- fragment --><p>Функция <code>optimize-1</code> отвечает за каждую отдельную попытку оптимизации. Ей передаются два аргумента: список инструкций, начинающихся с текущей и идущих до конца списка, и список всех инструкций. Второй аргумент используется редко. Вся идея подглядывающего(peephole) оптимизатора состоит в том, что он должен смотреть только на несколько инструкций, следующих за текущей. <code>optimize-1</code> управляется данными, основанными на коде операции первой инструкции. Обратите внимание, что функции оптимизатора выполняют свою работу путем деструктивного изменения последовательности команд, а не путем сохранения и возврата новой последовательности.</p>
<div class="fragment"><div class="line">(defun optimize-1 (code all-code)</div><div class="line">  &quot;Perform peephole optimization on a tail of the assembly code.</div><div class="line">  If a change is made, return true.&quot;</div><div class="line">  ;; Data-driven by the opcode of the first instruction</div><div class="line">  (let* ((instr (first code))</div><div class="line">         (optimizer (get-optimizer (opcode instr))))</div><div class="line">    (when optimizer</div><div class="line">      (funcall optimizer instr code all-code))))</div></div><!-- fragment --><p>Нам нужна таблица, чтобы связать отдельные функции оптимизатора с кодами операций. Поскольку коды операций включают в себя числа, а также символы, хэш-таблица <code>eql</code> является подходящим выбором:</p>
<div class="fragment"><div class="line">(let ((optimizers (make-hash-table :test #&#39;eql)))</div><div class="line"></div><div class="line">  (defun get-optimizer (opcode)</div><div class="line">    &quot;Get the assembly language optimizer for this opcode.&quot;</div><div class="line">    (gethash opcode optimizers))</div><div class="line"></div><div class="line">  (defun put-optimizer (opcode fn)</div><div class="line">    &quot;Store an assembly language optimizer for this opcode.&quot;</div><div class="line">    (setf (gethash opcode optimizers) fn)))</div></div><!-- fragment --><p>Теперь мы могли бы построить таблицу с помощью <code>put-optimizer</code>, но стоит определить макрос, чтобы сделать это немного аккуратнее:</p>
<div class="fragment"><div class="line">(defmacro def-optimizer (opcodes args &amp;body body)</div><div class="line">  &quot;Define assembly language optimizers for these opcodes.&quot;</div><div class="line">  (assert (and (listp opcodes) (listp args) (= (length args) 3)))</div><div class="line">  `(dolist (op &#39;,opcodes)</div><div class="line">     (put-optimizer op #&#39;(lambda ,args .,body))))</div></div><!-- fragment --><p>Прежде чем показать пример функции оптимизатора, мы представим три вспомогательные функции. <code>gen1</code> генерирует одну инструкцию, <code>target</code> находит кодовую последовательность, к которой ветвится команда перехода, а <code>next-instr</code> находит следующую фактическую инструкцию в последовательности, пропуская метки.</p>
<div class="fragment"><div class="line">(defun gen1 (&amp;rest args) &quot;Generate a single instruction&quot; args)</div><div class="line">(defun target (instr code) (second (member (arg1 instr) code)))</div><div class="line">(defun next-instr (code) (find-if (complement #&#39;label-p) code))</div></div><!-- fragment --><p>Вот шесть функций оптимизатора, которые реализуют несколько важных оптимизаций подглядывающего оптимизатора.</p>
<div class="fragment"><div class="line">(def-optimizer (:LABEL) (instr code all-code)</div><div class="line">  ;; ... L ... =&gt; ... ... ;if no reference to L</div><div class="line">  (when (not (find instr all-code :key #&#39;arg1))</div><div class="line">    (setf (first code) (second code)</div><div class="line">          (rest code) (rest2 code))</div><div class="line">    t))</div><div class="line"></div><div class="line">(def-optimizer (GSET LSET) (instr code all-code)</div><div class="line">  ;; ex: (begin (set! x y) (if x z))</div><div class="line">  ;; (SET X) (POP) (VAR X) ==&gt; (SET X)</div><div class="line">  (when (and (is (second code) &#39;POP)</div><div class="line">             (is (third code) &#39;(GVAR LVAR))</div><div class="line">             (eq (arg1 instr) (arg1 (third code))))</div><div class="line">    (setf (rest code) (nthcdr 3 code))</div><div class="line">    t))</div><div class="line"></div><div class="line">(def-optimizer (JUMP CALL CALLJ RETURN) (instr code all-code)</div><div class="line">  ;; (JUMP L1) ...dead code... L2 ==&gt; (JUMP L1) L2</div><div class="line">  (setf (rest code) (member-if #&#39;label-p (rest code)))</div><div class="line">  ;; (JUMP L1) ... L1 (JUMP L2) ==&gt; (JUMP L2)  ... L1 (JUMP L2)</div><div class="line">  (when (and (is instr &#39;JUMP)</div><div class="line">             (is (target instr code) &#39;(JUMP RETURN))</div><div class="line">    (setf (first code) (copy-list (target instr code)))</div><div class="line">    t)))</div><div class="line"></div><div class="line">(def-optimizer (TJUMP FJUMP) (instr code all-code)</div><div class="line">  ;; (FJUMP L1) ... L1 (JUMP L2) ==&gt; (FJUMP L2) ... L1 (JUMP L2)</div><div class="line">  (when (is (target instr code) &#39;JUMP)</div><div class="line">    (setf (second instr) (arg1 (target instr code)))</div><div class="line">    t))</div><div class="line"></div><div class="line">(def-optimizer (T -1 0 1 2) (instr code all-code)</div><div class="line">  (case (opcode (second code))</div><div class="line">    (NOT ;; (T) (NOT) ==&gt; NIL</div><div class="line">     (setf (first code) (gen1 &#39;NIL)</div><div class="line">           (rest code) (rest2 code))</div><div class="line">     t)</div><div class="line">    (FJUMP ;; (T) (FJUMP L) ... =&gt; ...</div><div class="line">     (setf (first code) (third code)</div><div class="line">           (rest code) (rest3 code))</div><div class="line">     t)</div><div class="line">    (TJUMP ;; (T) (TJUMP L) ... =&gt; (JUMP L) ...</div><div class="line">     (setf (first code) (gen1 &#39;JUMP (arg1 (next-instr code))))</div><div class="line">     t)))</div><div class="line"></div><div class="line">(def-optimizer (NIL) (instr code all-code)</div><div class="line">  (case (opcode (second code))</div><div class="line">    (NOT ;; (NIL) (NOT) ==&gt; T</div><div class="line">     (setf (first code) (gen1 &#39;T)</div><div class="line">           (rest code) (rest2 code))</div><div class="line">     t)</div><div class="line">    (TJUMP ;; (NIL) (TJUMP L) ... =&gt; ...</div><div class="line">     (setf (first code) (third code)</div><div class="line">             (rest code) (rest3 code))</div><div class="line">     t)</div><div class="line">    (FJUMP ;; (NIL) (FJUMP L) ==&gt; (JUMP L)</div><div class="line">     (setf (first code) (gen1 &#39;JUMP (arg1 (next-instr code))))</div><div class="line">     t)))</div></div><!-- fragment --><h2>23.5 Языки с отличными лексическими соглашениями</h2>
<p>В этой главе показано, как вычислять язык с Лисп-подобным синтаксисом, написав цикл read-eval-print, где нужно заменить только <code>eval</code>. В этом разделе мы увидим, как сделать часть <code>read</code> немного более общей. Мы все еще читаем Лисп-подобный синтаксис, но лексические соглашения могут немного отличаться.</p>
<p>Функция Lisp <code>read</code> управляется объектом, называемым <em>readtable</em>, который хранится в специальной переменной <code>*readtable*.</code> Эта таблица связывает некоторые действия с каждым из возможных символьных знаков, которые могут быть прочитаны. Например, запись в таблице чтения(readtable) для символа <code>#\(</code>, будет содержать указания для чтения списка. Запись для <code>#\;</code> будет содержать указания игнорировать каждый символьный знак до конца строки.</p>
<p>Поскольку readtable хранится в специальной переменной, можно полностью изменить способ чтения, просто динамически повторно привязав эту переменную.</p>
<p>Новая функция <code>scheme-read</code> временно изменяет таблицу чтения на новую, Scheme readtable. Она также принимает необязательный аргумент, поток для чтения, и возвращает специальный маркер в конце файла. Это можно проверить с помощью предиката <code>eof-object?</code>. Обратите внимание, что после установки <code>scheme-read</code> в качестве Scheme значения <code>symbol-read</code> нам больше ничего не нужно делать - <code>scheme-read</code> всегда будет вызываться при необходимости (верхним уровнем Scheme и любой пользовательской программой Scheme).</p>
<div class="fragment"><div class="line">(defconstant eof &quot;EoF&quot;)</div><div class="line">(defun eof-object? (x) (eq x eof))</div><div class="line">(defvar *scheme-readtable* (copy-readtable))</div><div class="line"></div><div class="line">(defun scheme-read (&amp;optional (stream *standard-input*))</div><div class="line">  (let ((*readtable* *scheme-readtable*))</div><div class="line">    (read stream nil eof)))</div></div><!-- fragment --><p>Смысл наличия специальной константы <code>eof</code> заключается в том, что она не может быть использована. Пользователь не может ввести последовательность знаков, которая будет читаться как что-то от <code>eq</code> до <code>eof</code>. В Common Lisp, но не в Scheme, есть escape механизм, который делает <code>eof</code> поддающимся подделке. Пользователь может ввести <code>#.eof</code>, чтобы получить эффект конца файла. Это похоже на соглашение <code>^D</code> в системах UNIX, и это может быть довольно удобно.</p>
<p>До сих пор readtable Scheme является просто копией стандартной readtable. Следующим шагом в реализации <code>scheme-read</code> является изменение <code>*scheme-readtable*</code>, добавление макросов чтения для любых необходимых символьных знаков. Здесь мы определяем макросы для <code>#t</code> и <code>#f</code> (истинных и ложных значений), для <code>#d</code>(десятичные числа) и для обратной кавычки макроса чтения (так называемый quasiquote в Scheme). Обратите внимание, что знаки обратной кавычки и запятой определяются как макросы чтения, но <code>@</code> в <code>,@</code> обрабатывается чтением следующего символьного знака, а не макросом чтения для <code>@</code></p>
<p>```lisp (set-dispatch-macro-character ## # #'(lambda (&amp;rest ignore) t) <em>scheme-readtable</em>)</p>
<p>(set-dispatch-macro-character ## # #'(lambda (&amp;rest ignore) nil) <em>scheme-readtable</em>)</p>
<p>(set-dispatch-macro-character ## # ;; In both Common Lisp and Scheme, ;; #x, #o and #b are hexidecimal, octal, and binary, ;; e.g. #xff = #o377 = #b11111111 = 255 ;; In Scheme only, #d255 is decimal 255. #'(lambda (stream &amp;rest ignore) (let ((<em>read-base</em> 10)) (scheme-read stream))) <em>scheme-readtable</em>)</p>
<p>(set-macro-character #` #'(lambda (s ignore) (list 'quasiquote (scheme-read s))) nil <em>scheme-readtable</em>)</p>
<p>(set-macro-character #\, #'(lambda (stream ignore) (let ((ch (read-char stream))) (if (char= ch #@) (list 'unquote-splicing (read stream)) (progn (unread-char ch stream) (list 'unquote (read stream)))))) nil <em>scheme-readtable</em>) </p><div class="fragment"><div class="line">Наконец, мы устанавливаем  `scheme-read` и `eof-object?` как примитивы:</div><div class="line"></div><div class="line">```lisp</div><div class="line">(defparameter *primitive-fns*</div><div class="line">  &#39;((+ 2 + true) (- 2 - true) (* 2 * true) (/ 2 / true)</div><div class="line">    (&lt; 2 &lt;) (&gt; 2 &gt;) (&lt;= 2 &lt;=) (&gt;= 2 &gt;=) (/= 2 /=) (= 2 =)</div><div class="line">    (eq? 2 eq) (equal? 2 equal) (eqv? 2 eql)</div><div class="line">    (not 1 not) (null? 1 not)</div><div class="line">    (car 1 car) (cdr 1 cdr)  (cadr 1 cadr) (cons 2 cons true)</div><div class="line">    (list 1 list1 true) (list 2 list2 true) (list 3 list3 true)</div><div class="line">    (read 0 scheme-read nil t) (eof-object? 1 eof-object?) ;***</div><div class="line">    (write 1 write nil t) (display 1 display nil t)</div><div class="line">    (newline 0 newline nil t) (compiler 1 compiler t)</div><div class="line">    (name! 2 name! true t) (random 1 random true nil)))</div></div><!-- fragment --><p>Здесь мы тестируем <code>scheme-read</code>. Знаки, выделенные курсивом, были напечатаны в ответ на <code>scheme-read</code>.</p>
<div class="fragment"><div class="line">&gt; (scheme-read) #*t*</div><div class="line">T</div><div class="line">&gt; (scheme-read) #f</div><div class="line">NIL</div><div class="line">&gt; (scheme-read) *&#39;(a,b,@cd)*</div><div class="line">(QUASIQUOTE (A (UNQUOTE B) (UNQUOTE-SPLICING C) D))</div></div><!-- fragment --><p>Последний шаг состоит в том, чтобы сделать quasiquote макрокомандой, которая расширяется в надлежащую последовательность вызовов <code>cons</code>, <code>list</code> и <code>append</code>. Внимательный читатель будет отслеживать разницу между формой, возвращаемой <code>scheme-read</code> (нечто, начинающееся с <code>quasiquote</code>), расширением этой формы с помощью макроса Scheme <code>quasiquote</code> (который реализуется с помощью функции Common Lisp <code>quasi-q</code>) и окончательного вычисления расширения. В среде, где <code>b</code> привязано к числу 2, а <code>c</code> привязано к списку <code>(c1 c2)</code>, мы могли бы иметь:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td>Typed: </td><td>`'(a ,b ,<code>d</code>)<code> &lt;tr&gt;&lt;td&gt; Read: &lt;td&gt;</code>(quasiquote (a (unquote b) (unquote-splicing c) d))<code> &lt;tr&gt;&lt;td&gt; Expanded: &lt;td&gt;</code>(cons 'a (cons b (append c '(d))))<code> &lt;tr&gt;&lt;td&gt; Evaluated: &lt;td&gt;</code>(a 2 c1 c2 d)` </td></tr>
</table>
<p>Реализация макроса <code>quasiquote</code> очень похожа на макрокоманду, приведенную в книге Charniak et al.'s <code>Программирование искусственного интеллекта</code>. Я добавил поддержку векторов. В <code>comb-quasiquote</code> я добавляю трюк с повторным использованием старой cons-ячейки <code>x</code> вместо создания ячейки списка(cons) для <code>left</code> и <code>right</code>, когда это возможно. Однако реализация по-прежнему тратит впустую cons-ячейки - более эффективная версия будет передавать обратно несколько значений, а не использовать <code>quote</code> в списке, только чтобы затем снова удалить его.</p>
<div class="fragment"><div class="line">(setf (scheme-macro &#39;quasiquote) &#39;quasi-q)</div><div class="line"></div><div class="line">(defun quasi-q (x)</div><div class="line">  &quot;Expand a quasiquote form into append, list, and cons calls.&quot;</div><div class="line">  (cond</div><div class="line">    ((vectorp x)</div><div class="line">     (list &#39;apply &#39;vector (quasi-q (coerce x &#39;list))))</div><div class="line">    ((atom x)</div><div class="line">     (if (constantp x) x (list &#39;quote x)))</div><div class="line">    ((starts-with x &#39;unquote)</div><div class="line">     (assert (and (rest x) (null (rest2 x))))</div><div class="line">     (second x))</div><div class="line">    ((starts-with x &#39;quasiquote)</div><div class="line">     (assert (and (rest x) (null (rest2 x))))</div><div class="line">     (quasi-q (quasi-q (second x))))</div><div class="line">    ((starts-with (first x) &#39;unquote-splicing)</div><div class="line">     (if (null (rest x))</div><div class="line">         (second (first x))</div><div class="line">         (list &#39;append (second (first x)) (quasi-q (rest x)))))</div><div class="line">    (t (combine-quasiquote (quasi-q (car x))</div><div class="line">                           (quasi-q (cdr x))</div><div class="line">                           x))))</div><div class="line"></div><div class="line">(defun combine-quasiquote (left right x)</div><div class="line">  &quot;Combine left and right (car and cdr), possibly re-using x.&quot;</div><div class="line">  (cond ((and (constantp left) (constantp right))</div><div class="line">         (if (and (eql (eval left) (first x))</div><div class="line">                  (eql (eval right) (rest x)))</div><div class="line">             (list &#39;quote x)</div><div class="line">             (list &#39;quote (cons (eval left) (eval right)))))</div><div class="line">        ((null right) (list &#39;list left))</div><div class="line">        ((starts-with right &#39;list)</div><div class="line">         (list* &#39;list left (rest right)))</div><div class="line">        (t (list &#39;cons left right))))</div></div><!-- fragment --><p>На самом деле, есть большая проблема с макросом <code>quasiquote</code>, или, точнее, во всем подходе к макрорасширению, основанному на текстовой подстановке. Предположим, нам нужна функция, которая работала бы так:</p>
<div class="fragment"><div class="line">(extrema &#39;(3 1 10 5 20 2))</div><div class="line">((max 20) (min 1))</div></div><!-- fragment --><p>Мы могли бы написать функцию Scheme:</p>
<div class="fragment"><div class="line">(define (extrema list)</div></div><!-- fragment --><p><code>;; Given a list of numbers. return an a-list</code></p>
<div class="fragment"><div class="line">;; with max and min values</div><div class="line">&#39;((max ,(apply max list)) (min ,(apply min list))))</div></div><!-- fragment --><p>После расширения quasiquote определение <code>extrema</code> будет таким:</p>
<div class="fragment"><div class="line">(define extrema</div><div class="line">      (lambda (list)</div><div class="line">          (list (list &#39;max (apply max list))</div><div class="line">                      (list &#39;min (apply min list)))))</div></div><!-- fragment --><p>Проблема в том, что <code>list</code> является аргументом функции <code>extrema</code>, и этот аргумент затеняет глобальное определение <code>list</code> как функции. Таким образом, функция выйдет из строя. Один из способов обойти эту дилемму - сделать так, чтобы макрорасширение использовало глобальное значение <code>list</code>, а не сам символ <code>list</code>. Другими словами, замените <code>'list'</code> в <code>quasi-q</code> на (<code>get-global-var 'list</code>). Тогда расширение можно использовать даже в среде, где <code>list</code> привязан локально. Однако следует быть осторожным: если будет предпринята эта тактика, то нужно изменить <code>comp-funcall</code>, чтобы распознавать константы функций и делать правильные вещи в отношении примитивов.</p>
<p>Именно такие проблемы заставили разработчиков Scheme признать, что они не знают, как лучше всего определять макросы, поэтому в Scheme нет стандартного механизма определения макросов. Такие проблемы редко возникают в Common Lisp, потому что функции и переменные имеют разные пространства имен и потому что определения локальных функций (с <code>flet</code> или<code>labels</code>) широко не используются. Те, кто действительно определяет локальные функции, обычно не используют уже установленные имена, такие как <code>list</code> и <code>append</code>.</p>
<h2>23.6 История и Ссылки</h2>
<p>Guy Steele's 1978 MIT master's thesis on the language Scheme, rewritten as Steele 1983, describes an innovative and influential compiler for Scheme, called RABBIT. <a href="#fn0015">2</a> A good article on an "industrial-strength" Scheme compiler based on this approach is described in <a href="B9780080571157500285.xhtml#bb0675">Kranz et al.'s 1986</a> paper on ORBIT, the compiler for the T dialect of Scheme.</p>
<p>Abelson and Sussman's <em>Structure and Interpretation of Computer Programs</em> (1985) contains an excellent chapter on compilation, using slightly different techniques and compiling into a somewhat more confusing machine language. Another good text is <a href="B9780080571157500285.xhtml#bb0040">John Allen's <em>Anatomy of Lisp</em> (1978)</a>. It presents a very clear, simple compiler, although it is for an older, dynamically scoped dialect of Lisp and it does not address tail-recursion or <code>call/cc</code>.</p>
<p>The peephole optimizer described here is based on the one in <a href="B9780080571157500285.xhtml#bb0780">Masinter and Deutsch 1980</a>.</p>
<h2>23.7 Упражнения</h2>
<p><b>Exercise 23.3 [h]</b> Scheme's syntax for numbers is slightly different from Common Lisp's. In particular, complex numbers are written like <code>3+4i</code> rather than <code>#c(3 4)</code>. How could you make <code>scheme-read</code> account for this?</p>
<p><b>Exercise 23.4 [m]</b> Is it possible to make the core Scheme language even smaller, by eliminating any of the five special forms <code>(quote, begin, set!, if, lambda)</code> and replacing them with macros?</p>
<p><b>Exercise 23.5 [m]</b> Add the ability to recognize internal defines (see <a href="B9780080571157500224.xhtml#p779">page 779</a>).</p>
<p><b>Exercise 23.6 [h]</b> In <code>comp-if</code> we included a special case for <code>(if t x y)</code> and <code>(if nil x y)</code>. But there are other cases where we know the value of the predicate. For example, <code>(if (*a b) x y)</code> can also reduce to <code>x</code>. Arrange for these optimizations to be made. Note the <code>prim-always</code> field of the <code>prim structure</code> has been provided for this purpose.</p>
<p><b>Exercise 23.7 [m]</b> Consider the following version of the quicksort algorithm for sorting a vector:</p>
<div class="fragment"><div class="line">(define (sort-vector vector test)</div><div class="line">      (define (sort lo hi)</div><div class="line">              (if (&gt;= lo hi)</div><div class="line">                        vector</div><div class="line">                        (let ((pivot (partition vector lo hi test)))</div><div class="line">                                (sort lo pivot)</div><div class="line">                        (sort (+ pivot 1) hi))))</div><div class="line">      (sort 0 (- (vector-length vector 1))))</div></div><!-- fragment --><p>Here the function <code>partition</code> takes a vector, two indices into the vector, and a comparison function, <code>test</code>. It modifies the vector and returns an index, <code>pivot</code>, such that all elements of the vector below <code>pivot</code> are less than all elements at <code>pivot</code> or above.</p>
<p>It is well known that quicksort takes time proportional to <em>n</em> log <em>n</em> to sort a vector of <em>n</em> elements, if the pivots are chosen well. With poor pivot choices, it can take time proportional to *n*2.</p>
<p>The question is, what is the space required by quicksort? Besides the vector itself, how much additional storage must be temporarily allocated to sort a vector?</p>
<p>Now consider the following modified version of quicksort. What time and space complexity does it have?</p>
<div class="fragment"><div class="line">(define (sort-vector vector test)</div><div class="line">      (define (sort lo hi)</div><div class="line">          (if (&gt;= lo hi)</div><div class="line">                  vector</div><div class="line">                  (let ((pivot (partition vector lo hi)))</div><div class="line">                        (if (&gt; (- hi pivot) (- pivot lo))</div><div class="line">                                  (begin (sort lo pivot)</div><div class="line">                                                      (sort (+ pivot 1) hi))</div><div class="line">                                  (begin (sort (+ pivot 1) hi)</div><div class="line">                                                      (sort lo pivot))))))</div><div class="line">      (sort 0 (- (vector-length vector 1))))</div></div><!-- fragment --><p>The next three exercises describe extensions that are not part of the Scheme standard.</p>
<p><b>Exercise 23.8 [h]</b> The set! special form is defined only when its first argument is a symbol. Extend <code>set!</code> to work like <code>setf</code> when the first argument is a list. That is, <code>(set! (car x) y)</code> should expand into something like <code>((setter car) y x)</code>, where <code>(setter car)</code> evaluates to the primitive procedure <code>set-car!</code>. You will need to add some new primitive functions, and you should also provide a way for the user to define new <code>set!</code> procedures. One way to do that would be with a <code>setter</code> function for <code>set!</code>, for example:</p>
<p><code>(set! (setter third)</code></p>
<p><code>(lambda (val list) (set-car! (cdr (cdr list)) val)))</code></p>
<p><b>Exercise 23.9 [m]</b> It is a curious asymmetry of Scheme that there is a special notation for lambda expressions within <code>define</code> expressions, but not within <code>let</code>. Thus, we see the following:</p>
<p><code>(define square (lambda (x) (* x x)))</code>*;is the same as*</p>
<div class="fragment"><div class="line">(define (square x) (* x x))</div></div><!-- fragment --><p><code>(let ((square (lambda (x) (* x x)))) ...) ;</code>*is not the same as*</p>
<p><code>(let (((square x) (* x x))) ...) ;</code>* &lt;= illegal!*</p>
<p>Do you think this last expression should be legal? If so, modify the macros for <code>let, let*</code>, and <code>letrec</code> to allow the new syntax. If not, explain why it should not be included in the language.</p>
<p><b>Exercise 23.10 [m]</b> Scheme does not define <code>funcall</code>, because the normal function-call syntax does the work of funcall. This suggests two problems. (1) Is it possible to define <code>funcall</code> in Scheme? Show a definition or explain why there can't be one. Would you ever have reason to use <code>funcall</code> in a Scheme program? (2) Scheme does define <code>apply</code>, as there is no syntax for an application. One might want to extend the syntax to make <code>(+ . numbers)</code> equivalent to <code>(apply + numbers)</code>. Would this bea good idea?</p>
<p><b>Exercise 23.11 [d]</b> Write a compiler that translates Scheme to Common Lisp. This will involve changing the names of some procedures and special forms, figuring out a way to map Scheme's single name space into Common Lisp's distinct function and variable name spaces, and dealing with Scheme's continuations. One possibility is to translate a <code>call/cc</code> into a <code>catch</code> and <code>throw</code>, and disallow dynamic continuations.</p>
<h2>23.8 Ответы</h2>
<p><b>Answer 23.2</b> We can save frames by making a resource for frames, as was done on page 337. Unfortunately, we can't just use the def resource macro as is, because we need a separate resource for each size frame. Thus, a two-dimensional array or a vector of vectors is necessary. Furthermore, one must be careful in determining when a frame is no longer needed, and when it has been saved and may be used again. Some compilers will generate a special calling sequence for a tail-recursive call where the environment can be used as is, without discarding and then creating a new frame for the arguments. Some compilers have varied and advanced representations for environments. An environment may never be represented explicitly as a list of frames; instead it may be represented implicitly as a series of values in registers.</p>
<p><b>Answer 23.3</b> We could read in Scheme expressions as before, and then convert any symbols that looked like complex numbers into numbers. The following routines do this without consing.</p>
<div class="fragment"><div class="line">(defun scheme-read (&amp;optional (stream *standard-input*))</div><div class="line">  (let ((*readtable* *scheme-readtable*))</div><div class="line">    (convert-numbers (read stream nil eof))))</div><div class="line"></div><div class="line">(defun convert-numbers (x)</div><div class="line">  &quot;Replace symbols that look like Scheme numbers with their values.&quot;</div><div class="line">  ;; Don&#39;t copy structure, make changes in place.</div><div class="line">  (typecase x</div><div class="line">    (cons   (setf (car x) (convert-numbers (car x)))</div><div class="line">            (setf (cdr x) (convert-numbers (cdr x)))</div><div class="line">        x) ; *** Bug fix, gat, 11/9/92</div><div class="line">    (symbol (or (convert-number x) x))</div><div class="line">    (vector (dotimes (i (length x))</div><div class="line">              (setf (aref x i) (convert-numbers (aref x i))))</div><div class="line">        x) ; *** Bug fix, gat, 11/9/92</div><div class="line">    (t x)))</div><div class="line"></div><div class="line">(defun convert-number (symbol)</div><div class="line">  &quot;If str looks like a complex number, return the number.&quot;</div><div class="line">  (let* ((str (symbol-name symbol))</div><div class="line">         (pos (position-if #&#39;sign-p str))</div><div class="line">         (end (- (length str) 1)))</div><div class="line">    (when (and pos (char-equal (char str end) #\i))</div><div class="line">      (let ((re (read-from-string str nil nil :start 0 :end pos))</div><div class="line">            (im (read-from-string str nil nil :start pos :end end)))</div><div class="line">        (when (and (numberp re) (numberp im))</div><div class="line">          (complex re im))))))</div><div class="line"></div><div class="line">(defun sign-p (char) (find char &quot;+-&quot;))</div></div><!-- fragment --><p>Actually, that's not quite good enough, because a Scheme complex number can have multiple signs in it, as in `3. 4e- 5+6. 7e+8i<code>, and it need not have two numbers, as in</code>3i<code>or</code>4+i<code>or just</code>+ i<code>. The other problem is that complex numbers can only have a lowercase</code>i<code>, but read does not distinguish between the symbols</code>3+4i<code>and</code>3+4I`.</p>
<p><b>Answer 23.4</b> Yes, it is possible to implement <code>begin</code> as a macro:</p>
<div class="fragment"><div class="line">(setf (scheme-macro &#39;begin)</div><div class="line">                #&#39;(lambda (&amp;rest exps) &#39;((lambda () .,exps))))</div></div><!-- fragment --><p>With some work we could also eliminate quote. Instead of <code>'x</code>, we could use <code>(string-&gt;symbol "X" )</code>, and instead of `'(1 2)<code>, wecoulduse something like</code>(list 1 2)`. The problem is in knowing when to reuse the same list. Consider:</p>
<div class="fragment"><div class="line">=&gt; (define (one-two) &#39;(1 2))</div><div class="line">ONE-TWO</div></div><!-- fragment --><p><code>=&gt; (eq? (one-two) (one-two))</code></p>
<div class="fragment"><div class="line">T</div></div><!-- fragment --><p>`=&gt; (eq? '(1 2) '(1 2))`</p>
<div class="fragment"><div class="line">NIL</div></div><!-- fragment --><p>A clever memoized macro for quote could handle this, but it would be less efficient than having <code>quote</code> as a special form. In short, what's the point?</p>
<p>It is also (nearly) possible to replace <code>if</code> with alternate code. The idea is to replace:</p>
<p><code>(if</code>*test then-part else-part*)</p>
<p>with</p>
<p>(<em>test</em><code>(delay</code>*then-part*) <code>(delay</code>*else-part*))</p>
<p>Now if we are assured that any <em>test</em> returns either <code>#t</code> or <code>#f</code>, then we can make the following definitions:</p>
<div class="fragment"><div class="line">(define #t (lambda (then-part else-part) (force then-part)))</div><div class="line">(define #f (lambda (then-part else-part) (force else-part)))</div></div><!-- fragment --><p>The only problem with this is that any value, not just <code>#t</code>, counts as true.</p>
<p>This seems to be a common phenomenon in Scheme compilers: translating everything into a few very general constructs, and then recognizing special cases of these constructs and compiling them specially. This has the disadvantage (compared to explicit use of many special forms) that compilation may be slower, because all macros have to be expanded first, and then special cases have to be recognized. It has the advantage that the optimizations will be applied even when the user did not have a special construct in mind. Common Lisp attempts to get the advantages of both by allowing implementations to play loose with what they implement as macros and as special forms.</p>
<p><b>Answer 23.6</b> We define the predicate <code>always</code> and install it in two places in <code>comp-if</code> :</p>
<div class="fragment"><div class="line">(defun always (pred env)</div><div class="line">      &quot;Does predicate always evaluate to true or false?&quot;</div><div class="line">      (cond ((eq pred t) &#39;true)</div><div class="line">                        ((eq pred nil) &#39;false)</div><div class="line">                        ((symbolp pred) nil)</div><div class="line">                        ((atom pred) &#39;true)</div><div class="line">                        ((scheme-macro (first pred))</div><div class="line">                          (always (scheme-macro-expand pred) env))</div><div class="line">                        ((case (first pred)</div><div class="line">                                (QUOTE (if (null (second pred)) &#39;false &#39;true))</div><div class="line">                                (BEGIN (if (null (rest pred)) &#39;false</div><div class="line">                                                                    (always (last1 pred) env)))</div></div><!-- fragment --><p><code>(SET! (always (third pred) env))</code></p>
<div class="fragment"><div class="line">(IF (let ((test (always (second pred)) env)</div><div class="line">    (then (always (third pred)) env)</div><div class="line">    (else (always (fourth pred)) env))</div><div class="line">                        (cond ((eq test &#39;true) then)</div><div class="line">                                                            ((eq test &#39;false) else)</div><div class="line">                                                            ((eq then else) then))))</div><div class="line">(LAMBDA &#39;true)</div><div class="line">(t (let ((prim (primitive-p (first pred) env</div><div class="line">                                      (length (rest pred)))))</div><div class="line">              (if prim (prim-always prim))))))))</div></div><!-- fragment --><p><code>(defun comp-if (pred then else env val? more?)</code></p>
<div class="fragment"><div class="line">(case (always pred env)</div><div class="line">    (true ; (if nil x y) = =&gt; y ; ***</div></div><!-- fragment --><p><code>(comp then env val? more?)) ; ***</code></p>
<div class="fragment"><div class="line">(false ; (if t x y) = =&gt; x ; ***</div></div><!-- fragment --><p><code>(comp else env val? more?)) ; ***</code></p>
<div class="fragment"><div class="line">(otherwise</div><div class="line">    (let ((pcode (comp pred env t t))</div></div><!-- fragment --><p><code>(tcode (comp then env val? more?))</code></p>
<p><code>(ecode (comp else env val? more?)))</code></p>
<div class="fragment"><div class="line">(cond</div><div class="line">    ((and (listp pred) ; (if (not p) x y) ==&gt; (if p y x)</div><div class="line">                      (length=1 (rest pred))</div><div class="line">                      (primitive-p (first pred) env 1)</div><div class="line">                      (eq (prim-opcode (primitive-p (first pred) env 1))</div><div class="line">                                    &#39;not))</div></div><!-- fragment --><p><code>(comp-if (second pred) else then env val? more?))</code></p>
<div class="fragment"><div class="line">((equal tcode ecode) ; (if p x x) ==&gt; (begin p x)</div><div class="line">  (seq (comp pred env nil t) ecode))</div><div class="line">((null tcode) ; (if p nil y) ==&gt; p (TJUMP L2) y L2:</div><div class="line">  (let ((L2 (gen-label)))</div><div class="line">          (seq pcode (gen &#39;TJUMP L2) ecode (list L2)</div></div><!-- fragment --><p><code>(unless more? (gen 'RETURN)))))</code></p>
<div class="fragment"><div class="line">((null ecode) ; (if p x) ==&gt; p (FJUMP L1) x L1:</div><div class="line">(let ((L1 (gen-label)))</div><div class="line">        (seq pcode (gen TJUMP L1) tcode (list L1)</div></div><!-- fragment --><p><code>(unless more? (gen 'RETURN)))))</code></p>
<div class="fragment"><div class="line">(t                                                             ; (if p x y) ==&gt; p (FJUMP L1) x L1: y</div><div class="line">                                                                  ; or p (FJUMP L1) x (JUMP L2) L1: y L2:</div><div class="line">(let ((L1 (gen-label))</div></div><!-- fragment --><p><code>(L2 (if more? (gen-label))))</code></p>
<div class="fragment"><div class="line">(seq pcode (gen &#39;FJUMP L1) tcode</div></div><!-- fragment --><p><code>(if more? (gen 'JUMP L2))</code></p>
<p><code>(list L1) ecode (if more? (list L2))))))))))</code></p>
<p>Development note: originally, I had coded <code>always</code> as a predicate that took a Boolean value as input and returned true if the expression always had that value. Thus, you had to ask first if the predicate was always true, and then if it was always false. Then I realized this was duplicating much effort, and that the duplication was exponential, not just linear: for a triply-nested conditional I would have to do eight times the work, not twice the work. Thus I switched to the above formulation, where <code>always</code> is a three-valued function, returning <code>true</code>, <code>false</code>, or <code>nil</code> for none-of-the-above. But to demonstrate that the right solution doesn't always appear the first time, I give my original definition as well:</p>
<div class="fragment"><div class="line">(defun always (boolean pred env)</div><div class="line">      &quot;Does predicate always evaluate to boolean in env?&quot;</div><div class="line">      (if (atom pred)</div><div class="line">          (and (constantp pred) (equiv boolean pred))</div><div class="line">          (case (first pred)</div><div class="line">                (QUOTE (equiv boolean pred))</div><div class="line">                (BEGIN (if (null (rest pred)) (equiv boolean nil)</div><div class="line">                                                    (always boolean (last1 pred) env)))</div></div><!-- fragment --><p><code>(SET! (always boolean (third pred) env))</code></p>
<div class="fragment"><div class="line">                (IF (or (and (always t (second pred) env)</div><div class="line">                                                      (always boolean (third pred) env))</div><div class="line">                                          (and (always nil (second pred) env)</div><div class="line">                                                      (always boolean (fourth pred) env))</div><div class="line">                                          (and (always boolean (third pred) env)</div><div class="line">                                                      (always boolean (fourth pred) env))))</div><div class="line">                (LAMBDA (equiv boolean t))</div><div class="line">                (t (let ((prim (primitive-p (first pred) env</div><div class="line">                                                                                          (length (rest pred)))))</div><div class="line">                        (and prim</div><div class="line">                                        (eq (prim-always prim)</div><div class="line">                                                    (if boolean &#39;true &#39;false))))))))</div><div class="line">(defun equiv (x y) &quot;Boolean equivalence&quot; (eq (not x) (not y)))</div></div><!-- fragment --><p><b>Answer 23.7</b> The original version requires <em>O</em>(<em>n</em>) stack space for poorly chosen pivots. Assuming a properly tail-recursive compiler, the modified version will never require more than <em>O</em>(log <em>n</em>) space, because at each step at least half of the vector is being sorted tail-recursively.</p>
<p><b>Answer 23.10</b> (1) <code>(defun (funcall fn . args) (apply fn args))</code> (2) Suppose you changed the piece of code <code>(+ . numbers)</code> to <code>(+ . (map sqrt numbers))</code>. The latter is the same expression as (+ <code>map sqrt numbers),</code> which is not the intended resuit at all. So there would be an arbitrary restriction: the last argument in an apply form would have to be an atom. This kind of restriction goes against the grain of Scheme. </p><hr/>
<p><a href="#xfn0010">1</a> Strictly speaking, this is a read-compile-funcall-write loop. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0015">2</a> At the time, the MacLisp compiler dealt with something called "lisp assembly code" or LAP. The function to input LAP was called <code>lapin</code>. Those who know French will get the pun. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
