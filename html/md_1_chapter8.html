<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 8</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 8 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Символьная Математика: Программа Упрощения</h2>
<blockquote class="doxtable">
<p><em>Наша жизнь испорчена деталями....</em> </p>
</blockquote>
<blockquote class="doxtable">
<p><em>Упрощай, упрощай.</em> </p>
</blockquote>
<blockquote class="doxtable">
<p>-Henry David Thoreau, <em>Walden</em> (1854) </p>
</blockquote>
<p>"Символьная математика" относится к числовой математике так же, как алгебра к арифметике: она имеет дело с переменными и выражениями, а не только с числами. Первоначально компьютеры были разработаны в первую очередь для решения арифметических задач: для суммирования длинных числовых столбцов, для умножения многозначных чисел, для решения систем линейных уравнений и для расчета траекторий баллистики. Ободренные успехом в этих областях, люди надеялись, что компьютеры можно будет использовать и для решения более сложных задач; дифференцировать или интегрировать математическое выражение и получить другое выражение в качестве ответа, а не просто число. Несколько программ были разработаны в этом направлении в 1960-х и 1970-х годах. Они использовались в основном профессиональными математиками и физиками, имеющими доступ к большим мэйнфреймам. Недавно такие программы, как MATHLAB, DERIVE и MATHEMATICA, предоставили эти возможности среднему пользователю персонального компьютера.</p>
<p>Интересно взглянуть на историю символической алгебры, которая началась в 1963 году с SAINT, программы Джеймса Слэгла по символьному интегрированию. Первоначально SAINT был провозглашен триумфом AI. Он использовал общие методы решения проблем, аналогичные GPS, для поиска решений сложных проблем. Программа преодолела проблему интеграции, выбрав один из известных ей методов и выполняла откат назад, когда какой-либо подход не удавался. Поведение SAINT при решении таких задач изначально было подобно (а в конечном итоге намного лучше) результативности студентов-математиков.</p>
<p>Со временем ИИ-компонент символьной интеграции начал исчезать. Джоиль Мозес реализовал преемника SAINT назвав его SIN. Он использовал многие из тех же самых методов, но вместо того, чтобы полагаться на поиск, чтобы найти правильную комбинацию методов, он имел дополнительные математические знания, которые заставляли программу выбирать правильную технику на каждом шаге, без какого-либо обеспечения возвратов назад и альтернативных попыток. SIN решал больше проблем и был гораздо быстрее SAINT, хотя и не был совершенным: он все еще иногда делал неправильный выбор и мог не решить проблему, которую ему задали.</p>
<p>К 1970 году математик Р.Риш и другие разработали алгоритмы неопределенного интегрирования любого выражения, включающего алгебраические, логарифмические или экспоненциальные расширения рациональных функций. Другими словами, для "нормальной" функции алгоритм Риша вернет либо неопределенный интеграл функции, либо указание на то, что интеграл в замкнутой форме невозможен в терминах элементарных функций. Эта работа положила конец эпохе рассмотрения интегрирования как проблемы поиска.</p>
<p>SIN был дополнительно доработан, объединен с частями алгоритма Риша и включен в развивающуюся программу MACSYMA <a href="#fn0010">1</a>. По большей части усовершенствование MACSYMA состояло из включения новых алгоритмов. Лишь немногие эвристики выживают. Сегодня MACSYMA больше не считается программой ИИ. Её ежедневно используют ученые и математики, в то время как ELIZA и STUDENT теперь являются лишь историческими сносками.</p>
<p>С помощью ELIZA и STUDENT мы смогли разработать миниатюрные программы, которые дублировали большинство функций оригинала. Мы даже не будем пытаться разработать программу, достойную названия MACSYMA; вместо этого мы довольствуемся скромной программой для символического упрощения, которую мы будем называть (просто) <code>simplifier</code>. Затем мы расширим <code>simplifier</code>, чтобы выполнять дифференцирование и некоторые задачи интегрирования. Идея состоит в том, что при таком выражении, как (2-1)*x* + 0, мы хотим, чтобы программа вычисляла упрощенную форму <em>x</em>.</p>
<p>Согласно <em>Математическому словарю</em> (Джеймс и Джеймс, 1949), слово "упрощенный" - это "вероятно, самый неопределенный термин, серьезно используемый в математике". Проблема в том, что "упрощение" относится к тому, что вы хотите использовать для следующего выражения. Что проще: <em>x</em> 2 + 3 <em>x</em> + 2 или (<em>x</em> + 1) (<em>x</em> + 2)? Первое упрощает интегрирование или дифференцирование, второе - поиск корней. Мы ограничимся "очевидными" упрощениями. Например, <em>x</em> почти всегда предпочтительнее 1 <em>x</em> + 0.</p>
<h2>8.1 Преобразование инфиксной в префиксную нотацию</h2>
<p>Мы представим упрощения в виде списка правил, очень похожих на правила для STUDENT и ELIZA. Но поскольку каждое правило упрощения представляет собой алгебраическое уравнение, мы будем хранить каждое из них как exp, а не как <code>rule</code>. Чтобы сделать вещи более понятными, мы будем писать каждое выражение в инфиксной форме, но хранить их в префиксной форме, ожидаемой <code>exp</code>. Для этого требуется функция <code>infix-&gt;prefix</code> для преобразования инфиксных выражений в префиксную нотацию. У нас есть выбор, насколько общими мы хотим, чтобы наша инфиксная нотация была. Рассмотрим:</p>
<div class="fragment"><div class="line">(((a * (x ^ 2)) + (b * x)) + c)</div><div class="line">(a * x ^ 2 + b * x + c)</div><div class="line">(a x ^ 2 + b x + c)</div><div class="line">a x^2 + b*x+c</div></div><!-- fragment --><p>Первый инфиксный, заключенный в круглые скобки, второй использует приоритет операторов (умножение связывает сильнее, чем сложение, и поэтому выполняется первым), а третий использует неявное умножение, а также приоритет операторов. Четвертый требует наличия лексического анализатора, чтобы разбивать символы Лиспа на части.</p>
<p>Предположим, мы хотим обработать только случай, при котором выражение полностью заключено в круглые скобки. Чтобы написать <code>infix-&gt;prefix</code>, можно сначала взглянуть на <code>prefix-&gt;infix</code> (на <a href="B9780080571157500078.xhtml#p228">стр. 228</a>), попытавшись приспособить его к нашим новым целям. При этом внимательный читатель может обнаружить сюрприз: <code>infix-&gt;prefix</code> и <code>prefix-&gt;infix</code> на самом деле являются одной и той же функцией! Обе оставляют атомы без изменений, и обе преобразуют трехэлементные списки, меняя местами <code>exp-op</code> и <code>exp-lhs</code>. Обе применяются рекурсивно к (возможно, измененному) входному списку. Как только мы обнаружим этот факт, возникнет соблазн не писать <code>infix-&gt;prefix</code>, а вместо этого просто вызвать <code>prefix-&gt;infix</code>. Избегайте этого искушения любой ценой. Вместо этого определите <code>infix-&gt;prefix</code>, как показано ниже. Предназначение вашего кода будет более ясным:</p>
<div class="fragment"><div class="line">(defun infix-&gt;prefix (infix-exp)</div><div class="line">  &quot;Convert fully parenthesized infix-exp to a prefix expression&quot;</div><div class="line">  ;; Don&#39;t use this version for non-fully parenthesized exps!</div></div><!-- fragment --><p><code>(prefix-&gt;infix infix-exp))</code></p>
<p>Как мы видели выше, полностью заключенная в круглые скобки инфиксная запись может быть довольно уродливой, со всеми этими дополнительными круглыми скобками, поэтому вместо этого мы будем использовать приоритет операторов. Есть несколько способов сделать это, но самый простой способ продолжить - использовать наш ранее определенный инструмент <code>rule-based-translator</code> и его подинструмент <code>pat-match</code>. Обратите внимание, что третье предложение <code>infix-&gt;prefix</code>, то, которое вызывает <code>rule-based-translator</code>, необычно тем, что состоит из одного выражения. Большинство условных предложений имеют два выражения: тест и результат, но такие, как это, означают: "Вычислить тест и, если результат не равен nil, вернуть вычисленное значение.
В противном случае переходите к следующему предложению".</p>
<div class="fragment"><div class="line">(defun infix-&gt;prefix (exp)</div><div class="line">  &quot;Translate an infix expression into prefix notation.&quot;</div><div class="line">  ;; Note we cannot do implicit multiplication in this system</div><div class="line">  (cond ((atom exp) exp)</div><div class="line">        ((= (length exp) 1) (infix-&gt;prefix (first exp)))</div><div class="line">        ((rule-based-translator exp *infix-&gt;prefix-rules*</div><div class="line">           :rule-if #&#39;rule-pattern :rule-then #&#39;rule-response</div><div class="line">           :action</div><div class="line">           #&#39;(lambda (bindings response)</div><div class="line">               (sublis (mapcar</div><div class="line">                         #&#39;(lambda (pair)</div><div class="line">                             (cons (first pair)</div><div class="line">                                   (infix-&gt;prefix (rest pair))))</div><div class="line">                         bindings)</div><div class="line">                       response))))</div><div class="line">        ((symbolp (first exp))</div><div class="line">         (list (first exp) (infix-&gt;prefix (rest exp))))</div><div class="line">        (t (error &quot;Illegal exp&quot;))))</div></div><!-- fragment --><p>Поскольку в этой главе мы занимаемся математикой, мы принимаем математическое соглашение об использовании некоторых однобуквенных переменных и переопределим <code>variable-p</code> так, чтобы переменные представляли собой только символы от <code>m</code> до <code>z</code>.</p>
<div class="fragment"><div class="line">(defun variable-p (exp)</div><div class="line">  &quot;Variables are the symbols M through Z.&quot;</div><div class="line">  ;; put x,y,z first to find them a little faster</div><div class="line">  (member exp &#39;(x y z m n o p q r s t u v w)))</div><div class="line"></div><div class="line">;; Define x+ and y+ as a sequence:</div><div class="line">(pat-match-abbrev &#39;x+ &#39;(?+ x))</div><div class="line">(pat-match-abbrev &#39;y+ &#39;(?+ y))</div><div class="line"></div><div class="line">(defun rule-pattern (rule) (first rule))</div><div class="line">(defun rule-response (rule) (second rule))</div><div class="line"></div><div class="line">(defparameter *infix-&gt;prefix-rules*</div><div class="line">  (mapcar #&#39;expand-pat-match-abbrev</div><div class="line">    &#39;(((x+ = y+) (= x y))</div><div class="line">      ((- x+)    (- x))</div><div class="line">      ((+ x+)    (+ x))</div><div class="line">      ((x+ + y+) (+ x y))</div><div class="line">      ((x+ - y+) (- x y))</div><div class="line">      ((x+ * y+) (* x y))</div><div class="line">      ((x+ / y+) (/ x y))</div><div class="line">      ((x+ ^ y+) (^ x y)))))</div><div class="line">  &quot;A list of rules, ordered by precedence.&quot;)</div></div><!-- fragment --><h2>8.2 Правила Упрощения</h2>
<p>Теперь мы готовы определить правила упрощения. Мы используем определение типа данных rule и exp (<a href="B9780080571157500078.xhtml#p221">стр. 221</a>) и <code>prefix-&gt;infix</code> (<a href="B9780080571157500078.xhtml#p228">page 228</a>) из STUDENT. Они повторяются здесь:</p>
<div class="fragment"><div class="line">(defstruct (rule (:type list)) pattern response)</div><div class="line">(defstruct (exp (:type list)</div><div class="line">                (:constructor mkexp (lhs op rhs)))</div><div class="line">  op lhs rhs)</div><div class="line"></div><div class="line">(defun exp-p (x) (consp x))</div><div class="line">(defun exp-args (x) (rest x))</div><div class="line"></div><div class="line">(defun prefix-&gt;infix (exp)</div><div class="line">  &quot;Translate prefix to infix expressions.&quot;</div><div class="line">  (if (atom exp) exp</div><div class="line">      (mapcar #&#39;prefix-&gt;infix</div><div class="line">              (if (binary-exp-p exp)</div><div class="line">                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))</div><div class="line">                  exp))))</div><div class="line"></div><div class="line">(defun binary-exp-p (x)</div><div class="line">  (and (exp-p x) (= (length (exp-args x)) 2)))</div></div><!-- fragment --><p>Мы также снова используем <code>rule-based-translator</code> (<a href="B9780080571157500066.xhtml#p188">page 188</a>), на этот раз со списком правил упрощения. Разумный список правил упрощения показан ниже. Этот список охватывает четыре арифметических оператора: сложение, вычитание, умножение и деление, а также возведение в степень(exp), обозначаемый символом "^"</p>
<p>Опять же, важно отметить, что правила упорядочены, и что более поздние правила будут применяться только тогда, когда более ранние правила не совпадают. Так, например, 0/0 упрощается до <code>undefined</code>, а не до 1 или 0, потому что правило для 0 / 0 предшествует другим правилам. См. <a href="#st0045">Упражнение 8.8</a> для более полной обработки этого.</p>
<div class="fragment"><div class="line">(setf *simplification-rules* (mapcar #&#39;simp-rule &#39;(</div><div class="line">  (x + 0  = x)</div><div class="line">  (0 + x  = x)</div><div class="line">  (x + x  = 2 * x)</div><div class="line">  (x - 0  = x)</div><div class="line">  (0 - x  = - x)</div><div class="line">  (x - x  = 0)</div><div class="line">  (- - x  = x)</div><div class="line">  (x * 1  = x)</div><div class="line">  (1 * x  = x)</div><div class="line">  (x * 0  = 0)</div><div class="line">  (0 * x  = 0)</div><div class="line">  (x * x  = x ^ 2)</div><div class="line">  (x / 0  = undefined)</div><div class="line">  (0 / x  = 0)</div><div class="line">  (x / 1  = x)</div><div class="line">  (x / x  = 1)</div><div class="line">  (0 ^ 0  = undefined)</div><div class="line">  (x ^ 0  = 1)</div><div class="line">  (0 ^ x  = 0)</div><div class="line">  (1 ^ x  = 1)</div><div class="line">  (x ^ 1  = x)</div><div class="line">  (x ^ -1 = 1 / x)</div><div class="line">  (x * (y / x) = y)</div><div class="line">  ((y / x) * x = y)</div><div class="line">  ((y * x) / x = y)</div><div class="line">  ((x * y) / x = y)</div><div class="line">  (x + - x = 0)</div><div class="line">  ((- x) + x = 0)</div><div class="line">  (x + y - x = y)</div><div class="line">  )))</div><div class="line"></div><div class="line">(defun ^ (x y) &quot;Exponentiation&quot; (expt x y))</div></div><!-- fragment --><p>Теперь мы готовы приступить к написанию упростителя. Основная функция, <code>simpleifier</code>, будет многократно печатать приглашение-подсказку, читать ввод и печатать его в упрощенной форме. Ввод и вывод находятся в инфиксном виде, а вычисления - в префиксном, поэтому нам нужно их соответственно преобразовать; функция simp делает это, а функция <code>simpleify</code> заботится о единственном префиксном выражении. Это кратко показано на <a href="#f0010">рис. 8.1</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter8/f08-01.jpg" alt="f08-01"/>
</div>
 </td></tr>
<tr>
<td>Figure 8.1: Словарь для Simplifier </td></tr>
</table>
<p>(ed: this should be a markdown table)</p>
<p>Вот программа:</p>
<div class="fragment"><div class="line">(defun simplifier ()</div><div class="line">  &quot;Read a mathematical expression, simplify it, and print the result.&quot;</div><div class="line">  (loop</div><div class="line">    (print &#39;simplifier&gt;)</div><div class="line">    (print (simp (read)))))</div><div class="line"></div><div class="line">(defun simp (inf) (prefix-&gt;infix (simplify (infix-&gt;prefix inf))))</div><div class="line"></div><div class="line">(defun simplify (exp)</div><div class="line">  &quot;Simplify an expression by first simplifying its components.&quot;</div><div class="line">  (if (atom exp) exp</div><div class="line">      (simplify-exp (mapcar #&#39;simplify exp))))</div><div class="line"></div><div class="line">;;; simplify-exp is redefined below</div><div class="line">(defun simplify-exp (exp)</div><div class="line">  &quot;Simplify using a rule, or by doing arithmetic.&quot;</div><div class="line">  (cond ((rule-based-translator exp *simplification-rules*</div><div class="line">           :rule-if #&#39;exp-lhs :rule-then #&#39;exp-rhs</div><div class="line">           :action #&#39;(lambda (bindings response)</div><div class="line">                       (simplify (sublis bindings response)))))</div><div class="line">        ((evaluable exp) (eval exp))</div><div class="line">        (t exp)))</div><div class="line"></div><div class="line">(defun evaluable (exp)</div><div class="line">  &quot;Is this an arithmetic expression that can be evaluated?&quot;</div><div class="line">  (and (every #&#39;numberp (exp-args exp))</div><div class="line">       (or (member (exp-op exp) &#39;(+ - * /))</div><div class="line">           (and (eq (exp-op exp) &#39;^)</div><div class="line">                (integerp (second (exp-args exp)))))))</div></div><!-- fragment --><p>Функция <code>simpleify</code> гарантирует, что любое составное выражение будет упрощено, если сначала упростить аргументы, а затем вызвать <code>simpleify-exp</code>. Эта последняя функция выполняет поиск по правилам упрощения, подобно <code>use-eliza-rules</code> и <code>translate-to-expression</code>. Когда она находит совпадение, <code>simpleify-exp</code> заменяет правильные значения переменных и вызывает <code>simplify</code> для результата, <code>simplify-exp</code> также имеет возможность вызвать <code>eval</code>, чтобы упростить арифметическое выражение до числа. Как и в STUDENT, именно ради этого eval мы и требуем, чтобы выражения были представлены в виде списков в префиксной нотации. Числовое вычисление выполняется <em>после</em> проверки правил, чтобы правила могли перехватывать выражения вроде (/ 1 0) и упрощать их до ʻundefined`. Если бы мы сначала выполнили числовое вычисление, эти выражения выдали бы ошибку при передаче в eval. Поскольку Common Lisp поддерживает рациональные числа (дроби) произвольной точности, мы гарантируем, что не будет ошибки округления, если только входные данные явно не включают неточные (с плавающей запятой) числа. Обратите внимание, что мы разрешаем вычисления с участием четырех арифметических операторов, но возведение в степень разрешено только в том случае, если показатель степени является целым числом. Это потому, что выражения типа (^ 4 1/2) не гарантируют возврата 2 (точный квадратный корень из 4); ответ может быть 2.0 (неточное число). Другая проблема заключается в том, что - 2 также является квадратным корнем из 4, и в некоторых случаях это правильный вариант.</p>
<p>На следующей трассировке показаны некоторые примеры работы упрощателя. Сначала мы покажем, что его можно использовать как калькулятор; затем мы показываем более сложные задачи.</p>
<div class="fragment"><div class="line">&gt;(simplifier)</div><div class="line">SIMPLIFIER  &gt; (2 + 2)</div><div class="line">4</div><div class="line">SIMPLIFIER  &gt; (5 * 20 + 30 + 7)</div><div class="line">137</div><div class="line">SIMPLIFIER  &gt; (5 * x - (4 + 1) * x)</div><div class="line">0</div><div class="line">SIMPLIFIER  &gt; (y / z * (5 * x - (4 + 1) * x))</div><div class="line">0</div><div class="line">SIMPLIFIER  &gt; ((4-3) * x + (y / y - 1) * z)</div><div class="line">X</div><div class="line">SIMPLIFIER  &gt; (1 * f(x) + 0)</div><div class="line">(F X)</div><div class="line">SIMPLIFIER  &gt; (3 * 2 * X)</div><div class="line">(3 * (2 * X))</div><div class="line">SIMPLIFIER  &gt; [Abort]</div><div class="line">&gt;</div></div><!-- fragment --><p>Здесь мы завершили цикл нажатием клавиши прерывания на терминале. (Детали этого механизма варьируются от одной реализации Common Lisp к другой). Simplifier, похоже, работает довольно хорошо, хотя в последнем примере он ошибся: <code>(3 * (2 * X))</code>, а должно упроститься до <code>(6 * X)</code>. В следующем разделе мы исправим эту проблему.</p>
<h2>8.3 Ассоциативность и коммутативность</h2>
<p>Мы могли бы легко добавить правило, чтобы переписать <code>(3 * (2 * X))</code> как <code>((3 * 2) * X)</code> и затем <code>(6 * X)</code>. Проблема в том, что это правило также перепишет <code>(X * (2 * 3))</code> как <code>((X * 2) * 3)</code>, если только у нас не будет способа ограничить применение правила только тогда, когда оно будет группировать числа вместе. К счастью, <code>pat-match</code> действительно предоставляет именно такую возможность, использованием образца <code>?is</code>. Мы могли бы написать это правило:</p>
<div class="fragment"><div class="line">(((?is n numberp) * ((?is m numberp) * x)) = ((n * m) * x))</div></div><!-- fragment --><p>Оно преобразует <code>(3 * (2 * x))</code> в <code>((3 * 2) * x)</code> и следовательно, в <code>(6 * x)</code>. К сожалению, проблема не так проста. Мы также хотим упростить <code>((2 * x) * (y * 3))</code> до <code>(6 * (x * y))</code>. Мы можем сделать улучшить работу по группировке чисел вместе, приняв три соглашения. Во-первых, первыми ставить числа в продукциях: измените <code>x * 3</code> на <code>3 * x</code>. Во-вторых, совмещать числа во внешнем выражении с числом во внутреннем выражении: измените <code>3 *(5 * x)</code> на <code>(3 * 5)* x</code>. В-третьих, по возможности уберать числа из внутренних выражений: измените <code>(3 * x) *y</code> на <code>3 * (x * y)</code>. Мы принимаем аналогичные соглашения для сложения, за исключением того, что мы предпочитаем ставить числа последними: <code>x + 1</code> вместо <code>1 + x</code>.</p>
<div class="fragment"><div class="line">;; Define n and m as numbers; s as a non-number:</div><div class="line">(pat-match-abbrev &#39;n &#39;(?is n numberp))</div><div class="line">(pat-match-abbrev &#39;m &#39;(?is m numberp))</div><div class="line">(pat-match-abbrev &#39;s &#39;(?is s not-numberp))</div><div class="line"></div><div class="line">(defun not-numberp (x) (not (numberp x)))</div><div class="line"></div><div class="line">(defun simp-rule (rule)</div><div class="line">  &quot;Transform a rule into proper format.&quot;</div><div class="line">  (let ((exp (infix-&gt;prefix rule)))</div><div class="line">    (mkexp (expand-pat-match-abbrev (exp-lhs exp))</div><div class="line">     (exp-op exp) (exp-rhs exp))))</div><div class="line"></div><div class="line">(setf *simplification-rules*</div><div class="line"> (append *simplification-rules* (mapcar #&#39;simp-rule</div><div class="line">  &#39;((s * n = n * s)</div><div class="line">    (n * (m * x) = (n * m) * x)</div><div class="line">    (x * (n * y) = n * (x * y))</div><div class="line">    ((n * x) * y = n * (x * y))</div><div class="line">    (n + s = s + n)</div><div class="line">    ((x + m) + n = x + n + m)</div><div class="line">    (x + (y + n) = (x + y) + n)</div><div class="line">    ((x + n) + y = (x + y) + n)))))</div></div><!-- fragment --><p>С новыми правилами мы готовы попробовать еще раз. На некоторые вопросы мы получаем только правильные ответы:</p>
<div class="fragment"><div class="line">&gt; (simplifier)</div><div class="line">SIMPLIFIER  &gt; (3 * 2 * x)</div><div class="line">(6 * X)</div><div class="line">SIMPLIFIER  &gt; (2 * x * x * 3)</div><div class="line">(6 * (X ^ 2))</div><div class="line">SIMPLIFIER  &gt; (2 * x * 3 * y * 4 * z * 5 * 6)</div><div class="line">(720 * (X * (Y * Z)))</div><div class="line">SIMPLIFIER  &gt; (3 + x + 4 + x)</div><div class="line">((2 * X) + 7)</div><div class="line">SIMPLIFIER  &gt; (2 * x * 3 * x * 4 * (l / x) * 5 * 6)</div><div class="line">(720 * X)</div></div><!-- fragment --><p>К сожалению, есть и другие проблемы, которые не упрощаются должным образом:</p>
<div class="fragment"><div class="line">SIMPLIFIER  &gt; (3 + x + 4 - x)</div><div class="line">((X + (4 - X)) + 3)</div><div class="line">SIMPLIFIER  &gt; (x + y + y + x)</div><div class="line">(X + (Y + (Y + X)))</div><div class="line">SIMPLIFIER  &gt; (3 * x + 4 * x)</div><div class="line">((3 * X) + (4 * X))</div></div><!-- fragment --><p>Мы вернемся к этим проблемам в <a href="#s0030">разделе 8.5</a>.</p>
<p><b>Exercise 8.1</b> Убедитесь, что набор правил, только что введенный, действительно реализует желаемые соглашения, и что соглашения имеют надлежащий эффект и всегда заканчиваются. В качестве примера потенциальной проблемы, что произойдет, если мы используем правило <code>(x * n = n * x)</code> вместо правила <code>(s * n = n * s)?</code></p>
<h2>8.4 Логарифмы, Тригонометические функции и Дифференцирование.</h2>
<p>В предыдущем разделе мы ограничились простыми арифметическими функциями, чтобы не пугать тех, кто немного недоверчив к сложной математике. В этом разделе мы немного добавим к математической сложности, не изменяя саму программу ни на йоту. Таким образом, математически застенчивые могут спокойно перейти к следующему разделу, не чувствуя, что они упускают что-то интересное.</p>
<p>Мы начнем с представления некоторых элементарных свойств логарифмических и тригонометрических функций. Новые правила аналогичны правилам "нулей и единиц", которые нам нужны для арифметических операторов, за исключением того, что здесь важны константы <code>e</code> и <code>pi</code> (<em>e</em> = 2.71828... и <em>&pi;</em> = 3.14159...), в дополнение к 0 и 1. Мы также вводим некоторые правила, относящиеся к логарифмам и экспонентам, а также к суммам и разностям логорифмов. Правила предполагают, что комплексные числа не допускаются. Если бы это было так, log <em>ex</em> (и даже <em>xy</em>) имел бы несколько значений, и было бы неправильно произвольно выбирать одно из этих значений.</p>
<div class="fragment"><div class="line">(setf *simplification-rules*</div><div class="line"> (append *simplification-rules* (mapcar #&#39;simp-rule &#39;(</div><div class="line">  (log 1         = 0)</div><div class="line">  (log 0         = undefined)</div><div class="line">  (log e         = 1)</div><div class="line">  (sin 0         = 0)</div><div class="line">  (sin pi        = 0)</div><div class="line">  (cos 0         = 1)</div><div class="line">  (cos pi        = -1)</div><div class="line">  (sin(pi / 2)   = 1)</div><div class="line">  (cos(pi / 2)   = 0)</div><div class="line">  (log (e ^ x)   = x)</div><div class="line">  (e ^ (log x)   = x)</div><div class="line">  ((x ^ y) * (x ^ z) = x ^ (y + z))</div><div class="line">  ((x ^ y) / (x ^ z) = x ^ (y - z))</div><div class="line">  (log x + log y = log(x * y))</div><div class="line">  (log x - log y = log(x / y))</div><div class="line">  ((sin x) ^ 2 + (cos x) ^ 2 = 1)</div><div class="line">  ))))</div></div><!-- fragment --><p>Теперь мы хотели бы пойти еще дальше и расширить систему, чтобы справиться с дифференцированием. Это любимая проблема, и она имеет историческое значение: летом 1958 года Джон Маккарти решил исследовать дифференцирование как интересную проблему символических вычислений, которую было трудно выразить на примитивных языках программирования того времени. Это исследование привело его к пониманию важности функциональных аргументов и рекурсивных функций в области символьных вычислений. Например, Маккарти изобрел то, что мы теперь называем <code>mapcar</code>, чтобы выразить идею о том, что производная суммы является суммой производной функции, примененной к каждому аргументу. Дальнейшая работа привела Маккарти к публикации в октябре 1958 года Записки MIT AI Lab No. 1: "Алгебраический язык для манипулирования символическими выражениями", который определил предшественника Lisp.</p>
<p>В работе Маккарти и во многих последующих текстах вы можете увидеть программы символического дифференцирования с процедурой упрощения, выполняемой в конце, чтобы сделать вывод более читаемым. Здесь мы используем противоположный подход: процедура упрощения является центральной, а дифференцирование рассматривается как просто еще один оператор со своим собственным набором правил упрощения. Нам потребуется новое правило преобразования infix-to-prefix(инфикса в префикс). В то же время мы добавим правило для неопределенного интегрирования, хотя мы еще не будем писать правил упрощения для интегрирования. Вот новые обозначения:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th><th></th></tr>
<tr>
<td>math </td><td>infix </td><td>prefix </td></tr>
<tr>
<td><em>dy</em>/*dx* </td><td><code>d y / d x</code> </td><td><code>(d y x)</code> </td></tr>
<tr>
<td><em>&int; ydx</em> </td><td><code>Int y d x</code> </td><td><code>(int y x)</code> </td></tr>
</table>
<p>А вот и необходимые правила перехода infix-to-prefix(от инфикса к префиксу):</p>
<div class="fragment"><div class="line">(defparameter *infix-&gt;prefix-rules*</div><div class="line">      (mapcar #&#39;expand-pat-match-abbrev</div><div class="line">          &#39;(((x+ = y+) (= x y))</div><div class="line">          ((- x+) (- x))</div><div class="line">          ((+ x+) (+ x))</div><div class="line">          ((x+ + y+) (+ x y))</div><div class="line">          ((x+ - y+) (- x y))</div><div class="line">          ((d y+ / d x) (d y x))        ;*** New rule</div><div class="line">          ((Int y+ d x) (int y x))    ;*** New rule</div><div class="line">          ((x+ * y+) (* x y))</div><div class="line">          ((x+ / y+) (/ x y))</div><div class="line">          ((x+ ^ y+) (^ x y)))))</div></div><!-- fragment --><p>Поскольку новое правило для дифференцирования стоит раньше правила для деления, не будет никакой путаницы с дифференциалом, интерпретируемым как частное. С другой стороны, существует потенциальная проблема с интегралами, которые содержат <code>d</code> в качестве переменной. Пользователь всегда может избежать этой проблемы, используя (<code>d</code>) вместо <code>d</code> внутри интеграла.</p>
<p>Теперь мы дополняем правила упрощения, копируя таблицу дифференцирования из справочника:</p>
<div class="fragment"><div class="line">(setf *simplification-rules*</div><div class="line"> (append *simplification-rules* (mapcar #&#39;simp-rule &#39;(</div><div class="line">  (d x / d x       = 1)</div><div class="line">  (d (u + v) / d x = (d u / d x) + (d v / d x))</div><div class="line">  (d (u - v) / d x = (d u / d x) - (d v / d x))</div><div class="line">  (d (- u) / d x   = - (d u / d x))</div><div class="line">  (d (u * v) / d x = u * (d v / d x) + v * (d u / d x))</div><div class="line">  (d (u / v) / d x = (v * (d u / d x) - u * (d v / d x))</div><div class="line">                     / v ^ 2) ; [This corrects an error in the first printing]</div><div class="line">  (d (u ^ n) / d x = n * u ^ (n - 1) * (d u / d x))</div><div class="line">  (d (u ^ v) / d x = v * u ^ (v - 1) * (d u / d x)</div><div class="line">                   + u ^ v * (log u) * (d v / d x))</div><div class="line">  (d (log u) / d x = (d u / d x) / u)</div><div class="line">  (d (sin u) / d x = (cos u) * (d u / d x))</div><div class="line">  (d (cos u) / d x = - (sin u) * (d u / d x))</div><div class="line">  (d (e ^ u) / d x = (e ^ u) * (d u / d x))</div><div class="line">  (d u / d x       = 0)))))</div></div><!-- fragment --><p>Мы добавили правило по умолчанию <code>(d u / d x = 0)</code>; оно должно применяться только тогда, когда выражение <code>u</code> свободно от переменной <code>x</code> (то есть когда u не является функцией <code>x</code>). Мы могли бы использовать <code>?if</code>, чтобы проверить это, но вместо этого мы полагаемся на то, что дифференцирование ограничено списком операторов, описанных здесь - так что, до тех пор, пока мы не введем никаких новых операторов, ответ всегда будет правильным. Обратите внимание, что есть два правила для возведения в степень, одно для случая, когда показатель степени является числом, и одно, когда это не так. В этом не было строгой необходимости, поскольку второе правило охватывает оба случая, но именно так правила были записаны в таблице дифференциалов, с которой я консультировался, поэтому я оставил оба правила.</p>
<div class="fragment"><div class="line">SIMPLIFIER  &gt; (d (x + x) / d x)</div><div class="line">2</div><div class="line">SIMPLIFIER  &gt; (d (a * x ^ 2 + b * x + c) / d x)</div><div class="line">((2 * (A * X)) + B)</div><div class="line">SIMPLIFIER  &gt; (d ((a * x ^ 2 + b * x + c) / x) / d x)</div><div class="line">((((A * (X ^ 2)) + ((B * X) + C)) - (X * ((2 * (A * X)) + B)))</div><div class="line">/ (X ^ 2))</div><div class="line">SIMPLIFIER  &gt; (log ((d (x + x) / d x) / 2))</div><div class="line">0</div><div class="line">SIMPLIFIER  &gt; (log(x + x) - log x)</div><div class="line">(LOG 2)</div><div class="line">SIMPLIFIER  &gt; (x ^ cos pi)</div><div class="line">(1 / X)</div><div class="line">SIMPLIFIER  &gt; (d (3 * x + (cos x) / x) / d x)</div><div class="line">((((COS X) - (X * (- (SIN X)))) / (X ^ 2)) + 3)</div><div class="line">SIMPLIFIER  &gt; (d ((cos x) / x) / d x)</div><div class="line">(((COS X) - (X * (- (SIN X)))) / (X ^ 2))</div><div class="line">SIMPLIFIER  &gt; (d (3 * x ^ 2 + 2 * x + 1) / d x)</div><div class="line">((6 * X) + 2)</div><div class="line">SIMPLIFIER  &gt; (sin(x + x) ^ 2 + cos(d x ^ 2 / d x) ^ 2)</div><div class="line">1</div><div class="line">SIMPLIFIER  &gt; (sin(x + x) * sin(d x ^ 2 / d x) +</div><div class="line">      cos(2 * x) * cos(x * d 2 * y / d y))</div><div class="line">1</div></div><!-- fragment --><p>Программа хорошо справляется с проблемами дифференцирования и, по-видимому, умна в использовании тождества sin^2*x* + cos^2*x* = 1.</p>
<h2>8.5 Пределы применения подходов основанных на правилах</h2>
<p>В этом разделе мы вернемся к некоторым примерам, которые создают проблемы для упрощателя. Вот простой пример</p>
<p><code>SIMPLIFIER &gt; (x + y + y + x)</code>=&gt; <code>(X + (Y + (Y + X)))</code></p>
<p>Мы бы предпочли <code>2 * (x + y)</code>. Проблема в том, что, хотя мы приложили много усилий, чтобы сгруппировать числа вместе, не было никаких усилий, чтобы сгруппировать не-числа. Мы могли бы написать правила вида:</p>
<div class="fragment"><div class="line">(y + (y + x) = (2 * y) + x)</div><div class="line">(y + (x + y) = (2 * y) + x)</div></div><!-- fragment --><p>Они будут работать для рассматриваемого примера, но они не будут работать для `(x + y + z + y + x)'. Для этого нам понадобится больше правил:</p>
<div class="fragment"><div class="line">(y + (z + (y + x)) = (2 * y) + x + z)</div><div class="line">(y + (z + (x + y)) = (2 * y) + x + z)</div><div class="line">(y + ((y + x) + z) = (2 * y) + x + z)</div><div class="line">(y + ((x + y) + z) = (2 * y) + x + z)</div></div><!-- fragment --><p>Чтобы справиться со всеми случаями, нам понадобится бесконечное число правил. Язык сопоставления с образцом недостаточно силен, чтобы выразить это кратко. Могло бы помочь, если бы вложенные суммы (и произведения) были невложенными; то есть, если бы мы позволили + принять произвольное число аргументов вместо только одного. Как только аргументы сгруппированы вместе, мы можем отсортировать их так, чтобы, скажем, все <code>ys</code> появлялись перед <code>z</code> и после <code>x</code>. Тогда подобные термины можно было бы сгруппировать вместе. Но мы должны быть осторожны. Рассмотрим следующие примеры:</p>
<div class="fragment"><div class="line">SIMPLIFIER  &gt; (3 * x + 4 * x)</div><div class="line">((3 * X) + (4 * X))</div><div class="line">SIMPLIFIER  &gt; (3 * x + y + x + 4 * x)</div><div class="line">((3 * X) + (Y + (X + (4 * X))))</div></div><!-- fragment --><p>Мы бы хотели, чтобы <code>(3 * x)</code> сортировался в то же место, что и <code>x</code> и <code>(4 * x)</code>, чтобы все они могли быть объединены в <code>(8 * x)</code>. В <a href="B9780080571157500157.xhtml">главе 15</a> мы разрабатываем новую версию программы, которая решает эту проблему.</p>
<h2>8.6 Интегрирование</h2>
<p>До сих пор алгебраические манипуляции были простыми. Существует прямой алгоритм вычисления производной каждого выражения. Когда мы рассматриваем интегралы или первообразные <a href="# fn0015">2</a>, картина намного сложнее. Как вы, возможно, помните из исчисления для первокурсников, вычисление интегралов - это настоящее искусство. В этом разделе мы пытаемся увидеть, как далеко мы можем зайти, кодируя лишь некоторые из множества приемов, доступных изучающему математику.</p>
<p>Первый шаг - признать, что записей в таблице упрощения будет недостаточно. Вместо этого нам понадобится алгоритм для вычисления или "упрощения" интегралов. Мы добавим новый случай в <code>simpleify-exp</code>, чтобы проверить каждый оператор, чтобы увидеть, связана ли с ним функция упрощения. Эти функции упрощения будут связаны с операторами через функции <code>set-simp-fn</code> и <code>simp-fn</code>. Если у оператора есть функция упрощения, то эта функция будет вызываться вместо обращения к правилам упрощения. Функция упрощения может решить не обрабатывать выражение в конце концов, возвращая nil, и в этом случае мы продолжим использовать другие методы упрощения.</p>
<div class="fragment"><div class="line">(defun simp-fn (op) (get op &#39;simp-fn))</div><div class="line">(defun set-simp-fn (op fn) (setf (get op &#39;simp-fn) fn))</div><div class="line"></div><div class="line">(defun simplify-exp (exp)</div><div class="line">  &quot;Simplify using a rule, or by doing arithmetic,</div><div class="line">  or by using the simp function supplied for this operator.&quot;</div><div class="line">  (cond ((simplify-by-fn exp))                             ;***</div><div class="line">        ((rule-based-translator exp *simplification-rules*</div><div class="line">           :rule-if #&#39;exp-lhs :rule-then #&#39;exp-rhs</div><div class="line">           :action #&#39;(lambda (bindings response)</div><div class="line">                       (simplify (sublis bindings response)))))</div><div class="line">        ((evaluable exp) (eval exp))</div><div class="line">        (t exp)))</div><div class="line"></div><div class="line">(defun simplify-by-fn (exp)</div><div class="line">  &quot;If there is a simplification fn for this exp,</div><div class="line">  and if applying it gives a non-null result,</div><div class="line">  then simplify the result and return that.&quot;</div><div class="line">  (let* ((fn (simp-fn (exp-op exp)))</div><div class="line">         (result (if fn (funcall fn exp))))</div><div class="line">    (if (null result)</div><div class="line">        nil</div><div class="line">        (simplify result))))</div></div><!-- fragment --><p>На уроках математического анализа первокурсникам преподаются различные методы интегрирования. К счастью, одина техника - метод разделения переменных - может быть использован для решения большинства проблем, которые возникают на уровне математики первокурсников, возможно, 90% задач, заданных при проверке. Основное правило:</p>
<p>&int;fxdx=&int;fududxdx.</p>
<div class="image">
<img src="images/chapter8/si1_e.gif" alt="si1_e"/>
</div>
<p>В качестве примера рассмотрим <em>&int; x</em> sin(&lt;em&gt;x*2) *dx. Используя подстановку <em>u</em> = <em>x*2, мы можем дифференцировать, чтобы получить *du</em>/*dx* = 2*x*. Затем, применяя основное правило, мы получаем:</p>
<p>&int;xsinx2dx=12&int;sinududxdx=12&int;sinudu.</p>
<div class="image">
<img src="images/chapter8/si2_e.gif" alt="si2_e"/>
</div>
<p>Предположим, что у нас есть таблица интегралов, включающая правило <em>&int;</em> sin(<em>x</em>) <em>dx</em> = - cos(<em>x</em>). Тогда мы сможем получить окончательный ответ:</p>
<p>-12cosx2.</p>
<div class="image">
<img src="images/chapter8/si3_e.gif" alt="si3_e"/>
</div>
<p>Если абстрагироваться от этого примера, общий алгоритм интегрирования выражения <em>y</em> относительно <em>x</em> следующий:</p>
<ol type="1">
<li>Выберите коэффициент <em>y</em>, называя его <em>f</em>(<em>u</em>). !!!(p) {:.numlist}</li>
<li>Вычислить производную <em>du</em>/*dx*. !!!(p) {:.numlist}</li>
<li>Разделите <em>y</em> на <em>f</em>(<em>u</em>) x <em>du</em>/*dx*, получив коэффициэнт <em>k</em>. !!!(p) {:.numlist}</li>
<li>Если <em>k</em> является константой (по отношению к <em>x</em>), то результат будет <em>k &int; f</em>(<em>u</em>)*du*. !!!(p) {:.numlist}</li>
</ol>
<p>Этот алгоритм недетерминирован, так как может быть много факторов <em>y</em>. В нашем примере <em>f</em>(<em>u</em>) = sin(&lt;em&gt;x*2), *u = <em>x*2, and *du</em>/*dx* = 2*x*. Итак, k=12 !!!(span) {:.hiddenClass} </p><div class="image">
<img src="images/chapter8/si4_e.gif" alt="si4_e"/>
</div>
<p>, и ответ будет -12cosx2 !!!(span) {:.hiddenClass} </p><div class="image">
<img src="images/chapter8/si5_e.gif" alt="si5_e"/>
</div>
<p>.</p>
<p>Первый шаг в реализации этой техники - убедиться, что разделение выполнено правильно. Нам нужно иметь возможность выбирать множители <em>y</em>, разделять выражения, а затем определять, свободны ли частные(коэффициэнты) от <em>x</em>. Это делает функция <code>factorize</code>. Она хранит список факторов и текущее произведение постоянных факторов и дополняет их с каждым вызовом локальной функции <code>fac</code>.</p>
<div class="fragment"><div class="line">(defun factorize (exp)</div><div class="line">  &quot;Return a list of the factors of exp^n,</div><div class="line">  where each factor is of the form (^ y n).&quot;</div><div class="line">  (let ((factors nil)</div><div class="line">        (constant 1))</div><div class="line">    (labels</div><div class="line">      ((fac (x n)</div><div class="line">         (cond</div><div class="line">           ((numberp x)</div><div class="line">            (setf constant (* constant (expt x n))))</div><div class="line">           ((starts-with x &#39;*)</div><div class="line">            (fac (exp-lhs x) n)</div><div class="line">            (fac (exp-rhs x) n))</div><div class="line">           ((starts-with x &#39;/)</div><div class="line">            (fac (exp-lhs x) n)</div><div class="line">            (fac (exp-rhs x) (- n)))</div><div class="line">           ((and (starts-with x &#39;-) (length=1 (exp-args x)))</div><div class="line">            (setf constant (- constant))</div><div class="line">            (fac (exp-lhs x) n))</div><div class="line">           ((and (starts-with x &#39;^) (numberp (exp-rhs x)))</div><div class="line">            (fac (exp-lhs x) (* n (exp-rhs x))))</div><div class="line">           (t (let ((factor (find x factors :key #&#39;exp-lhs</div><div class="line">                                  :test #&#39;equal)))</div><div class="line">                (if factor</div><div class="line">                    (incf (exp-rhs factor) n)</div><div class="line">                    (push `(^ ,x ,n) factors)))))))</div><div class="line">      ;; Body of factorize:</div><div class="line">      (fac exp 1)</div><div class="line">      (case constant</div><div class="line">        (0 &#39;((^ 0 1)))</div><div class="line">        (1 factors)</div><div class="line">        (t `((^ ,constant 1) .,factors))))))</div></div><!-- fragment --><p><code>factorize</code> отображает выражение в список факторов, но нам также нужно <code>unfactorize</code>, чтобы превратить список обратно в выражение:</p>
<div class="fragment"><div class="line">(defun unfactorize (factors)</div><div class="line">  &quot;Convert a list of factors back into prefix form.&quot;</div><div class="line">  (cond ((null factors) 1)</div><div class="line">        ((length=1 factors) (first factors))</div><div class="line">        (t `(* ,(first factors) ,(unfactorize (rest factors))))))</div></div><!-- fragment --><p>Метод разделения на производные(метод разделения переменных) требует разделения двух выражений. Мы делаем это путем факторизации каждого выражения, а затем отмены деления на коэффициенты(факторы). Могут быть случаи, когда, например, два множителя в числителе можно перемножить, чтобы отменить множитель в знаменателе, но такая возможность не рассматривается. Оказывается, что большинство задач по математике первокурсников не требуют такой сложности.</p>
<div class="fragment"><div class="line">(defun divide-factors (numer denom)</div><div class="line">  &quot;Divide a list of factors by another, producing a third.&quot;</div><div class="line">  (let ((result (mapcar #&#39;copy-list numer)))</div><div class="line">    (dolist (d denom)</div><div class="line">      (let ((factor (find (exp-lhs d) result :key #&#39;exp-lhs</div><div class="line">                          :test #&#39;equal)))</div><div class="line">        (if factor</div><div class="line">            (decf (exp-rhs factor) (exp-rhs d))</div><div class="line">            (push `(^ ,(exp-lhs d) ,(- (exp-rhs d))) result))))</div><div class="line">    (delete 0 result :key #&#39;exp-rhs)))</div></div><!-- fragment --><p>Наконец, предикат <code>free-of</code> возвращает истину, если в выражении нет вхождений определенной переменной.</p>
<div class="fragment"><div class="line">(defun free-of (exp var)</div><div class="line">  &quot;True if expression has no occurrence of var.&quot;</div><div class="line">  (not (find-anywhere var exp)))</div><div class="line"></div><div class="line">(defun find-anywhere (item tree)</div><div class="line">  &quot;Does item occur anywhere in tree?  If so, return it.&quot;</div><div class="line">  (cond ((eql item tree) tree)</div><div class="line">        ((atom tree) nil)</div><div class="line">        ((find-anywhere item (first tree)))</div><div class="line">        ((find-anywhere item (rest tree)))))</div></div><!-- fragment --><p>В <code>factorize</code> мы использовали вспомогательную функцию <code>length=1</code>. Вызов функции <code>(length=l x)</code> быстрее, чем <code>(= (length x) 1)</code>, потому что последняя должна вычислять длину всего списока, в то время как первая просто должна смотреть, есть ли в списке элемент <code>rest</code> или нет.</p>
<div class="fragment"><div class="line">(defun length=l (x)</div><div class="line">  &quot;Is X a list of length 1?&quot;</div><div class="line">  (and (consp x) (null (rest x))))</div></div><!-- fragment --><p>Учитывая эти предварительные сведения, функция <code>integrate</code> довольно проста. Начнем с нескольких простых случаев интегрирования сумм и постоянных выражений. Затем мы факторизируем выражение и разбиваем список факторов на два: список постоянных факторов и список факторов, содержащий <em>x</em>. (Это делается с помощью <code>partition-if</code>, комбинации <code>remove-if</code> и <code>remove-if-not</code>.) Наконец, мы вызываем <code>deriv-divides</code>, давая ему шанс с каждым из факторов. Если ни один из них не сработает, мы возвращаем выражение, указывающее, что интеграл неизвестен.</p>
<div class="fragment"><div class="line">(defun integrate (exp x)</div><div class="line">  ;; First try some trivial cases</div><div class="line">  (cond</div><div class="line">    ((free-of exp x) `(* ,exp x))          ; Int c dx = c*x</div><div class="line">    ((starts-with exp &#39;+)                  ; Int f + g  =</div><div class="line">     `(+ ,(integrate (exp-lhs exp) x)      ;   Int f + Int g</div><div class="line">         ,(integrate (exp-rhs exp) x)))</div><div class="line">    ((starts-with exp &#39;-)</div><div class="line">     (ecase (length (exp-args exp))</div><div class="line">       (1 (integrate (exp-lhs exp) x))     ; Int - f = - Int f</div><div class="line">       (2 `(- ,(integrate (exp-lhs exp) x) ; Int f - g  =</div><div class="line">              ,(integrate (exp-rhs exp) x)))))  ; Int f - Int g</div><div class="line">    ;; Now move the constant factors to the left of the integral</div><div class="line">    ((multiple-value-bind (const-factors x-factors)</div><div class="line">         (partition-if #&#39;(lambda (factor) (free-of factor x))</div><div class="line">                       (factorize exp))</div><div class="line">       (identity ;simplify</div><div class="line">         `(* ,(unfactorize const-factors)</div><div class="line">             ;; And try to integrate:</div><div class="line">             ,(cond ((null x-factors) x)</div><div class="line">                    ((some #&#39;(lambda (factor)</div><div class="line">                               (deriv-divides factor x-factors x))</div><div class="line">                           x-factors))</div><div class="line">                    ;; &lt;other methods here&gt;</div><div class="line">                    (t `(int? ,(unfactorize x-factors) ,x)))))))))</div></div><!-- fragment --><div class="fragment"><div class="line">(defun partition-if (pred list)</div><div class="line">  &quot;Return 2 values: elements of list that satisfy pred,</div><div class="line">  and elements that don&#39;t.&quot;</div><div class="line">  (let ((yes-list nil)</div><div class="line">        (no-list nil))</div><div class="line">    (dolist (item list)</div><div class="line">      (if (funcall pred item)</div><div class="line">          (push item yes-list)</div><div class="line">          (push item no-list)))</div><div class="line">    (values (nreverse yes-list) (nreverse no-list))))</div></div><!-- fragment --><p>Обратите внимание, в integrate отмечено место, где можно было бы добавить другие методы. Мы будем реализовывать только метод разделения переменных(derivative-divides). Оказывается, эта функция немного сложнее, чем простой четырехэтапный алгоритм, описанный ранее:</p>
<div class="fragment"><div class="line">(defun deriv-divides (factor factors x)</div><div class="line">  (assert (starts-with factor &#39;^))</div><div class="line">  (let* ((u (exp-lhs factor))              ; factor = u^n</div><div class="line">         (n (exp-rhs factor))</div><div class="line">         (k (divide-factors</div><div class="line">              factors (factorize `(* ,factor ,(deriv u x))))))</div><div class="line">    (cond ((free-of k x)</div><div class="line">           ;; Int k*u^n*du/dx dx = k*Int u^n du</div><div class="line">           ;;                    = k*u^(n+1)/(n+1) for n/=1</div><div class="line">           ;;                    = k*log(u) for n=1</div><div class="line">           (if (= n -1)</div><div class="line">               `(* ,(unfactorize k) (log ,u))</div><div class="line">               `(/ (* ,(unfactorize k) (^ ,u ,(+ n 1)))</div><div class="line">                   ,(+ n 1))))</div><div class="line">          ((and (= n 1) (in-integral-table? u))</div><div class="line">           ;; Int y&#39;*f(y) dx = Int f(y) dy</div><div class="line">           (let ((k2 (divide-factors</div><div class="line">                       factors</div><div class="line">                       (factorize `(* ,u ,(deriv (exp-lhs u) x))))))</div><div class="line">             (if (free-of k2 x)</div><div class="line">                 `(* ,(integrate-from-table (exp-op u) (exp-lhs u))</div><div class="line">                     ,(unfactorize k2))))))))</div></div><!-- fragment --><p>Есть три случая. В любом случае, все множители имеют вид <code>(^ u n)</code>, поэтому мы разделяем множитель на основание <code>u</code> и показатель степени <code>n</code>. Если <em>u</em> или <em>un</em> равномерно делит исходное выражение (здесь представлено как множители), то у нас есть ответ. Но нам нужно проверить экспоненту, потому что <em>&int; undu</em> равен <em>u**n</em>+1/(<em>n</em> + 1) для <em>n</em>&ne; - 1, но это log(<em>u</em>) для <em>n</em> = - 1. Но следует рассмотреть третий случай. Фактор может быть чем-то вроде <code>(^ (sin (^ x 2)) 1)</code>, и в этом случае мы должны учитывать <em>f</em>(<em>u</em>) = sin(*x*2). Этот случай обрабатывается с помощью таблицы интегрирования. Нам не нужна таблица производных, потому что мы можем просто использовать для этого simplifier.</p>
<div class="fragment"><div class="line">(defun deriv (y x) (simplify `(d ,y ,x)))</div><div class="line"></div><div class="line">(defun integration-table (rules)</div><div class="line">  (dolist (i-rule rules)</div><div class="line">    ;; changed infix-&gt;prefix to simp-rule - norvig Jun 11 1996</div><div class="line">    (let ((rule (simp-rule i-rule)))</div><div class="line">      (setf (get (exp-op (exp-lhs (exp-lhs rule))) &#39;int)</div><div class="line">            rule))))</div><div class="line"></div><div class="line">(defun in-integral-table? (exp)</div><div class="line">  (and (exp-p exp) (get (exp-op exp) &#39;int)))</div><div class="line"></div><div class="line">(defun integrate-from-table (op arg)</div><div class="line">  (let ((rule (get op &#39;int)))</div><div class="line">    (subst arg (exp-lhs (exp-lhs (exp-lhs rule))) (exp-rhs rule))))</div><div class="line"></div><div class="line">(integration-table</div><div class="line">  &#39;((Int log(x) d x = x * log(x) - x)</div><div class="line">    (Int exp(x) d x = exp(x))</div><div class="line">    (Int sin(x) d x = - cos(x))</div><div class="line">    (Int cos(x) d x = sin(x))</div><div class="line">    (Int tan(x) d x = - log(cos(x)))</div><div class="line">    (Int sinh(x) d x = cosh(x))</div><div class="line">    (Int cosh(x) d x = sinh(x))</div><div class="line">    (Int tanh(x) d x = log(cosh(x)))</div><div class="line">    ))</div></div><!-- fragment --><p>Последний шаг - установить integrate как функцию упрощения для оператора Int. Очевидный способ сделать это:</p>
<div class="fragment"><div class="line">(set-simp-fn &#39;Int &#39;integrate)</div></div><!-- fragment --><p>К сожалению, это не совсем так. Проблема в том, что integrate ожидает два аргумента, соответствующих двум аргументам *<code>y</code>* и *<code>x</code>* в (Int <em>y x</em>)<code>. Но соглашение для функций упрощения заключается в передаче им одного аргумента, состоящего из всего выражения</code>(Int <em>y x</em>)<code>. Мы могли бы вернуться и отредактировать</code>simpleify-exp`, чтобы изменить соглашение, но вместо этого я предпочёл сделать преобразование следующим образом:</p>
<div class="fragment"><div class="line">(set-simp-fn &#39;Int #&#39;(lambda (exp)</div><div class="line">          (integrate (exp-lhs exp) (exp-rhs exp))))</div></div><!-- fragment --><p>Вот несколько примеров, взятых из <a href="#c0040">глав 8</a> и <a href="B9780080571157500091.xhtml">9</a> из <em>Calculus</em> (<a href="B9780080571157500285.xhtml#bb0750">Loomis 1974</a>):</p>
<div class="fragment"><div class="line">SIMPLIFIER  &gt; (Int x * sin(x ^ 2) d x)</div><div class="line">(1/2 * (- (COS (X ^ 2))))</div><div class="line">SIMPLIFIER  &gt; (Int ((3 * x ^ 3) - 1 / (3 * x ^ 3)) d x)</div><div class="line">((3 * ((X ^ 4) / 4)) - (1/3 * ((X ^ -2) / -2)))</div><div class="line">SIMPLIFIER  &gt; (Int (3 * x + 2) ^ -2/3 d x)</div><div class="line">(((3 * X) + 2) ^ 1/3)</div><div class="line">SIMPLIFIER  &gt; (Int sin(x) ^ 2 * cos(x) d x)</div><div class="line">(((SIN X) ^ 3) / 3)</div><div class="line">SIMPLIFIER  &gt; (Int sin(x) / (1 + cos(x)) d x)</div><div class="line">(-1 * (LOG ((COS X) + 1)))</div><div class="line">SIMPLIFIER  &gt; (Int (2 * x + 1) / (x ^ 2 + x - 1) d x)</div><div class="line">(LOG ((X ^ 2) + (X - 1)))</div><div class="line">SIMPLIFIER  &gt; (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)</div><div class="line">(8 * ((1/3 * (((X ^ 3) + 2) ^ -2)) / -2))</div></div><!-- fragment --><p>Все ответы верны, хотя последний можно было бы сделать проще. Один из быстрых способов упростить такое выражение - это разложить на множители(факторизовать) и дефакторизовать, а затем снова упростить:</p>
<div class="fragment"><div class="line">(set-simp-fn &#39;Int</div><div class="line">    #&#39;(lambda (exp)</div><div class="line">      (unfactorize</div><div class="line">        (factorize</div><div class="line">          (integrate (exp-lhs exp) (exp-rhs exp))))))</div></div><!-- fragment --><p>С этим изменением мы получаем:</p>
<div class="fragment"><div class="line">SIMPLIFIER  &gt; (Int 8 * x ^ 2 / (x ^ 3 + 2) ^ 3 d x)</div><div class="line">(-4/3 * (((X ^ 3) + 2) ^ -2))</div></div><!-- fragment --><h2>8.7 История и ссылки</h2>
<p>A brief history is given in the introduction to this chapter. An interesting point is that the history of Lisp and of symbolic algebraic manipulation are deeply intertwined. It is not too gross an exaggeration to say that Lisp was invented by John McCarthy to express the symbolic differentiation algorithm. And the development of the first high-quality Lisp system, MacLisp, was driven largely by the needs of MACSYMA, one of the first large Lisp systems. See <a href="B9780080571157500285.xhtml#bb0790">McCarthy 1958</a> for early Lisp history and the differentiation algorithm, and <a href="B9780080571157500285.xhtml#bb0775">Martin and Fateman 1971</a> and <a href="B9780080571157500285.xhtml#bb0875">Moses (1975)</a> for more details on MACSYMA. A comprehensive book on computer algebra systems is <a href="B9780080571157500285.xhtml#bb0270">Davenport 1988</a>. It covers the MACSYMA and REDUCE systems as well as the algorithms behind those systems.</p>
<p>Because symbolic differentiation is historically important, it is presented in a number of text books, from the original Lisp 1.5 Primer (<a href="B9780080571157500285.xhtml#bb1370">Weissman 1967</a>) and Allen's influential <a href="B9780080571157500285.xhtml#bb0040"><em>Anatomy of Lisp</em> (1978)</a> to recent texts like <a href="B9780080571157500285.xhtml#bb0135">Brooks 1985</a>, <a href="B9780080571157500285.xhtml#bb0530">Hennessey 1989</a>, and <a href="B9780080571157500285.xhtml#bb1220">Tanimoto 1990</a>. Many of these books use rules or data-driven programming, but each treats differentiation as the main task, with simplification as a separate problem. None of them use the approach taken here, where differentiation is just another kind of simplification.</p>
<p>The symbolic integration programs SAINT and SIN are covered in <a href="B9780080571157500285.xhtml#bb1115">Slagle 1963</a> and <a href="B9780080571157500285.xhtml#bb0870">Moses 1967</a>, respectively. The mathematical solution to the problem of integration in closed term is addressed in <a href="B9780080571157500285.xhtml#bb0985">Risch 1969</a>, but be warned; this paper is not for the mathematically naive, and it has no hints on programming the algorithm. A better reference is <a href="B9780080571157500285.xhtml#bb0270">Davenport et al. 1988</a>.</p>
<p>In this book, techniques for improving the efficiency of algebraic manipulation are covered in <a href="B9780080571157500091.xhtml#s0035">sections 9.6</a> and <a href="B9780080571157500108.xhtml#s0025">10.4</a>. <a href="B9780080571157500157.xhtml">Chapter 15</a> presents a reimplementation that does not use pattern-matching, and is closer to the techniques used in MACSYMA.</p>
<h2>8.8 Exercises</h2>
<p><b>Exercise 8.2 [s]</b> Some notations use the operator ** instead of ^ to indicate exponentiation. <code>Fix infix-&gt;prefix</code> so that either notation is allowed.</p>
<p><b>Exercise 8.3 [m]</b> Can the system as is deal with imaginary numbers? What are some of the difficulties?</p>
<p><b>Exercise 8.4 [h]</b> There are some simple expressions involving sums that are not handled by the <code>integrate</code> function. The function can integrate <em>a*x *x*2 + *b*x *x</em> + <em>c</em> but not 5 x (<em>a*x *x*2 + *b*x *x</em> + <em>c</em>). Similarly, it can integrate <em>x*4 + 2 x *x*3 + *x*2 but not (*x*2 + *x</em>)2, and it can do <em>x*3 + *x*2 + *x</em> + 1 but not (<em>x*2 + 1) x (*x</em> + 1). Modify <code>integrate</code> so that it expands out products (or small exponents) of sums. You will probably want to try the usual techniques first, and do the expansion only when that fails.</p>
<p><b>Exercise 8.5 [d]</b> Another very general integration technique is called integration by parts. It is based on the rule:</p>
<p>&int;udv=uv-&int;vdu</p>
<div class="image">
<img src="images/chapter8/si6_e.gif" alt="si6_e"/>
</div>
<p>So, for example, given</p>
<p>&int;xcosxdx</p>
<div class="image">
<img src="images/chapter8/si7_e.gif" alt="si7_e"/>
</div>
<p>we can take <em>u</em> = <em>x</em>, <em>dv</em> = cos <em>xdx</em>. Then we can determine <em>v</em> = sin <em>x</em> by integration, and come up with the solution:</p>
<p>&int;xcosxdx=xsinx-&int;sinxx1dx=xsinx+cosx</p>
<div class="image">
<img src="images/chapter8/si8_e.gif" alt="si8_e"/>
</div>
<p>It is easy to program an integration by parts routine. The hard part is to program the control component. Integration by parts involves a recursive call to <code>integrate</code>, and of all the possible ways of breaking up the original expression into a <em>u</em> and a <em>dv</em>, few, if any, will lead to a successful integration. One simple control rule is to allow integration by parts only at the top level, not at the recursive level. Implement this approach.</p>
<p><b>Exercise 8.6 [d]</b> A more complicated approach is to try to decide which ways of breaking up the original expression are promising and which are not. Derive some heuristics for making this division, and reimplement <code>integrate</code> to include a search component, using the search tools of <a href="B9780080571157500066.xhtml">chapter 6</a>.</p>
<p>Look in a calculus textbook to see how <em>&int;</em> sin2*xdx* is evaluated by two integrations by parts and a division. Implement this technique as well.</p>
<p><b>Exercise 8.7 [m]</b> Write simplification rules for predicate calculus expressions. For example,</p>
<div class="fragment"><div class="line">(true and x = x)</div><div class="line">(false and x = false)</div><div class="line">(true or x = true)</div><div class="line">(false or x = false)</div></div><!-- fragment --><p><b>Exercise 8.8 [m]</b> The simplification rule <code>(x / 0 = undefined)</code> is necessary to avoid problems with division by zero, but the treatment of <code>undefined</code> is inadequate. For example, the expression <code>((0 / 0) - (0 / 0))</code> will simplify to zero, when it should simplify to <code>undefined</code>. Add rules to propagate <code>undefined</code> values and prevent them from being simplified away.</p>
<p><b>Exercise 8.9 [d]</b> Extend the method used to handle <code>undefined</code> to handle <code>+ infinity</code> and <code>-infinity</code> as well. </p><hr/>
<p><a href="#xfn0010">1</a>MACSYMA is the Project MAC SYMbolic MAthematics program. Project MAC is the MIT research organization that was the precursor of MIT's Laboratory for Computer Science. MAC stood either for Machine-Aided Cognition or Multiple-Access Computer, according to one of their annual reports. The cynical have claimed that MAC really stood for Man Against Computer. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0015">2</a> The term antiderivative is more correct, because of branch point problems. !!!(p) {:.ftnote1}</p>
<p>Part III Tools and Techniques !!!(p) {:.parttitle} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
