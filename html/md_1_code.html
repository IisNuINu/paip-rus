<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Code highlighting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Code highlighting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here I'm testing the code highlighing functionality</p>
<div class="fragment"><div class="line">;;; -*- Mode: Lisp; Syntax: Common-Lisp; -*-</div><div class="line">;;; Code from Paradigms of Artificial Intelligence Programming</div><div class="line">;;; Copyright (c) 1991 Peter Norvig</div><div class="line"></div><div class="line">;;;; File gps.lisp: Final version of GPS</div><div class="line"></div><div class="line">(requires &quot;gps1&quot;)</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun executing-p (x)</div><div class="line">  &quot;Is x of the form: (executing ...) ?&quot;</div><div class="line">  (starts-with x &#39;executing))</div><div class="line"></div><div class="line">(defun starts-with (list x)</div><div class="line">  &quot;Is this a list whose first element is x?&quot;</div><div class="line">  (and (consp list) (eql (first list) x)))</div><div class="line"></div><div class="line">(defun convert-op (op)</div><div class="line">  &quot;Make op conform to the (EXECUTING op) convention.&quot;</div><div class="line">  (unless (some #&#39;executing-p (op-add-list op))</div><div class="line">    (push (list &#39;executing (op-action op)) (op-add-list op)))</div><div class="line">  op)</div><div class="line"></div><div class="line">(defun op (action &amp;key preconds add-list del-list)</div><div class="line">  &quot;Make a new operator that obeys the (EXECUTING op) convention.&quot;</div><div class="line">  (convert-op</div><div class="line">    (make-op :action action :preconds preconds</div><div class="line">             :add-list add-list :del-list del-list)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(mapc #&#39;convert-op *school-ops*)</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defvar *ops* nil &quot;A list of available operators.&quot;)</div><div class="line"></div><div class="line">(defstruct op &quot;An operation&quot;</div><div class="line">  (action nil) (preconds nil) (add-list nil) (del-list nil))</div><div class="line"></div><div class="line">(defun GPS (state goals &amp;optional (*ops* *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (remove-if #&#39;atom (achieve-all (cons &#39;(start) state) goals nil)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun achieve-all (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, and make sure they still hold at the end.&quot;</div><div class="line">  (let ((current-state state))</div><div class="line">    (if (and (every #&#39;(lambda (g)</div><div class="line">                        (setf current-state</div><div class="line">                              (achieve current-state g goal-stack)))</div><div class="line">                    goals)</div><div class="line">             (subsetp goals current-state :test #&#39;equal))</div><div class="line">        current-state)))</div><div class="line"></div><div class="line">(defun achieve (state goal goal-stack)</div><div class="line">  &quot;A goal is achieved if it already holds,</div><div class="line">  or if there is an appropriate op for it that is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Goal: ~a&quot; goal)</div><div class="line">  (cond ((member-equal goal state) state)</div><div class="line">        ((member-equal goal goal-stack) nil)</div><div class="line">        (t (some #&#39;(lambda (op) (apply-op state goal op goal-stack))</div><div class="line">                 (find-all goal *ops* :test #&#39;appropriate-p)))))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun member-equal (item list)</div><div class="line">  (member item list :test #&#39;equal))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun apply-op (state goal op goal-stack)</div><div class="line">  &quot;Return a new, transformed state if op is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Consider: ~a&quot; (op-action op))</div><div class="line">  (let ((state2 (achieve-all state (op-preconds op) </div><div class="line">                             (cons goal goal-stack))))</div><div class="line">    (unless (null state2)</div><div class="line">      ;; Return an updated state</div><div class="line">      (dbg-indent :gps (length goal-stack) &quot;Action: ~a&quot; (op-action op))</div><div class="line">      (append (remove-if #&#39;(lambda (x) </div><div class="line">                             (member-equal x (op-del-list op)))</div><div class="line">                         state2)</div><div class="line">              (op-add-list op)))))</div><div class="line"></div><div class="line">(defun appropriate-p (goal op)</div><div class="line">  &quot;An op is appropriate to a goal if it is in its add list.&quot;</div><div class="line">  (member-equal goal (op-add-list op)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun use (oplist)</div><div class="line">  &quot;Use oplist as the default list of operators.&quot;</div><div class="line">  ;; Return something useful, but not too verbose: </div><div class="line">  ;; the number of operators.</div><div class="line">  (length (setf *ops* oplist)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defparameter *banana-ops*</div><div class="line">  (list</div><div class="line">    (op &#39;climb-on-chair</div><div class="line">        :preconds &#39;(chair-at-middle-room at-middle-room on-floor)</div><div class="line">        :add-list &#39;(at-bananas on-chair)</div><div class="line">        :del-list &#39;(at-middle-room on-floor))</div><div class="line">    (op &#39;push-chair-from-door-to-middle-room</div><div class="line">        :preconds &#39;(chair-at-door at-door)</div><div class="line">        :add-list &#39;(chair-at-middle-room at-middle-room)</div><div class="line">        :del-list &#39;(chair-at-door at-door))</div><div class="line">    (op &#39;walk-from-door-to-middle-room</div><div class="line">        :preconds &#39;(at-door on-floor)</div><div class="line">        :add-list &#39;(at-middle-room)</div><div class="line">        :del-list &#39;(at-door))</div><div class="line">    (op &#39;grasp-bananas</div><div class="line">        :preconds &#39;(at-bananas empty-handed)</div><div class="line">        :add-list &#39;(has-bananas)</div><div class="line">        :del-list &#39;(empty-handed))</div><div class="line">    (op &#39;drop-ball</div><div class="line">        :preconds &#39;(has-ball)</div><div class="line">        :add-list &#39;(empty-handed)</div><div class="line">        :del-list &#39;(has-ball))</div><div class="line">    (op &#39;eat-bananas</div><div class="line">        :preconds &#39;(has-bananas)</div><div class="line">        :add-list &#39;(empty-handed not-hungry)</div><div class="line">        :del-list &#39;(has-bananas hungry))))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun make-maze-ops (pair)</div><div class="line">  &quot;Make maze ops in both directions&quot;</div><div class="line">  (list (make-maze-op (first pair) (second pair))</div><div class="line">        (make-maze-op (second pair) (first pair))))</div><div class="line"></div><div class="line">(defun make-maze-op (here there)</div><div class="line">  &quot;Make an operator to move between two places&quot;</div><div class="line">  (op `(move from ,here to ,there)</div><div class="line">      :preconds `((at ,here))</div><div class="line">      :add-list `((at ,there))</div><div class="line">      :del-list `((at ,here))))</div><div class="line"></div><div class="line">(defparameter *maze-ops*</div><div class="line">  (mappend #&#39;make-maze-ops</div><div class="line">     &#39;((1 2) (2 3) (3 4) (4 9) (9 14) (9 8) (8 7) (7 12) (12 13)</div><div class="line">       (12 11) (11 6) (11 16) (16 17) (17 22) (21 22) (22 23)</div><div class="line">       (23 18) (23 24) (24 19) (19 20) (20 15) (15 10) (10 5) (20 25))))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun GPS (state goals &amp;optional (*ops* *ops*))</div><div class="line">  &quot;General Problem Solver: from state, achieve goals using *ops*.&quot;</div><div class="line">  (find-all-if #&#39;action-p</div><div class="line">               (achieve-all (cons &#39;(start) state) goals nil)))</div><div class="line"></div><div class="line">(defun action-p (x)</div><div class="line">  &quot;Is x something that is (start) or (executing ...)?&quot;</div><div class="line">  (or (equal x &#39;(start)) (executing-p x)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun find-path (start end)</div><div class="line">  &quot;Search a maze for a path from start to end.&quot;</div><div class="line">  (let ((results (GPS `((at ,start)) `((at ,end)))))</div><div class="line">    (unless (null results)</div><div class="line">      (cons start (mapcar #&#39;destination</div><div class="line">                          (remove &#39;(start) results</div><div class="line">                                  :test #&#39;equal))))))</div><div class="line"></div><div class="line">(defun destination (action)</div><div class="line">  &quot;Find the Y in (executing (move from X to Y))&quot;</div><div class="line">  (fifth (second action)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun make-block-ops (blocks)</div><div class="line">  (let ((ops nil))</div><div class="line">    (dolist (a blocks)</div><div class="line">      (dolist (b blocks)</div><div class="line">        (unless (equal a b)</div><div class="line">          (dolist (c blocks)</div><div class="line">            (unless (or (equal c a) (equal c b))</div><div class="line">              (push (move-op a b c) ops)))</div><div class="line">          (push (move-op a &#39;table b) ops)</div><div class="line">          (push (move-op a b &#39;table) ops))))</div><div class="line">    ops))</div><div class="line"></div><div class="line">(defun move-op (a b c)</div><div class="line">  &quot;Make an operator to move A from B to C.&quot;</div><div class="line">  (op `(move ,a from ,b to ,c)</div><div class="line">      :preconds `((space on ,a) (space on ,c) (,a on ,b))</div><div class="line">      :add-list (move-ons a b c)</div><div class="line">      :del-list (move-ons a c b)))</div><div class="line"></div><div class="line">(defun move-ons (a b c)</div><div class="line">  (if (eq b &#39;table)</div><div class="line">      `((,a on ,c))</div><div class="line">      `((,a on ,c) (space on ,b))))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun achieve-all (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, trying several orderings.&quot;</div><div class="line">  (some #&#39;(lambda (goals) (achieve-each state goals goal-stack))</div><div class="line">        (orderings goals)))</div><div class="line"></div><div class="line">(defun achieve-each (state goals goal-stack)</div><div class="line">  &quot;Achieve each goal, and make sure they still hold at the end.&quot;</div><div class="line">  (let ((current-state state))</div><div class="line">    (if (and (every #&#39;(lambda (g)</div><div class="line">                        (setf current-state</div><div class="line">                              (achieve current-state g goal-stack)))</div><div class="line">                    goals)</div><div class="line">             (subsetp goals current-state :test #&#39;equal))</div><div class="line">        current-state)))</div><div class="line"></div><div class="line">(defun orderings (l) </div><div class="line">  (if (&gt; (length l) 1)</div><div class="line">      (list l (reverse l))</div><div class="line">      (list l)))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun achieve (state goal goal-stack)</div><div class="line">  &quot;A goal is achieved if it already holds,</div><div class="line">  or if there is an appropriate op for it that is applicable.&quot;</div><div class="line">  (dbg-indent :gps (length goal-stack) &quot;Goal: ~a&quot; goal)</div><div class="line">  (cond ((member-equal goal state) state)</div><div class="line">        ((member-equal goal goal-stack) nil)</div><div class="line">        (t (some #&#39;(lambda (op) (apply-op state goal op goal-stack))</div><div class="line">                 (appropriate-ops goal state))))) ;***</div><div class="line"></div><div class="line">(defun appropriate-ops (goal state)</div><div class="line">  &quot;Return a list of appropriate operators, </div><div class="line">  sorted by the number of unfulfilled preconditions.&quot;</div><div class="line">  (sort (copy-list (find-all goal *ops* :test #&#39;appropriate-p)) #&#39;&lt;</div><div class="line">        :key #&#39;(lambda (op) </div><div class="line">                 (count-if #&#39;(lambda (precond)</div><div class="line">                               (not (member-equal precond state)))</div><div class="line">                           (op-preconds op)))))</div><div class="line"></div><div class="line">;;; ==============================</div><div class="line"></div><div class="line">(defun permutations (bag)</div><div class="line">  &quot;Return a list of all the permutations of the input.&quot;</div><div class="line">  ;; If the input is nil, there is only one permutation:</div><div class="line">  ;; nil itself</div><div class="line">  (if (null bag)</div><div class="line">      &#39;(())</div><div class="line">      ;; Otherwise, take an element, e, out of the bag.</div><div class="line">      ;; Generate all permutations of the remaining elements,</div><div class="line">      ;; And add e to the front of each of these.</div><div class="line">      ;; Do this for all possible e to generate all permutations.</div><div class="line">      (mapcan #&#39;(lambda (e)</div><div class="line">                  (mapcar #&#39;(lambda (p) (cons e p))</div><div class="line">                          (permutations</div><div class="line">                            (remove e bag :count 1 :test #&#39;eq))))</div><div class="line">              bag)))</div><div class="line"></div><div class="line">;;; ==============================</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
