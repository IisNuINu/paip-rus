<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 14</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 14 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Представление знаний и рассуждения</h2>
<blockquote class="doxtable">
<p>Само знание - сила. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Francis Bacon (1561-1626) </p>
</blockquote>
<blockquote class="doxtable">
<p>Сила заключается в знании. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Edward Feigenbaum </p>
</blockquote>
<blockquote class="doxtable">
<p>Stanford University Heuristic Programming Project </p>
</blockquote>
<blockquote class="doxtable">
<p>Знание есть Знание, и наоборот. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Tee shirt </p>
</blockquote>
<blockquote class="doxtable">
<p>Stanford University Heuristic Programming Project </p>
</blockquote>
<p>В 1960-х годах большая часть ИИ была сосредоточена на методах поиска. В частности, много работы было связано с <em>доказательством теорем:</em> формулированием проблемы в виде небольшого набора аксиом и поиском доказательства проблем. Неявное предположение заключалось в том, что сила заключена в механизме вывода - если бы мы могли просто найти правильную технику поиска, тогда все наши проблемы были бы решены, и все наши теоремы были бы доказаны.</p>
<p>Начиная с 1970-х годов это начало меняться. Подход к доказательству теорем не оправдал своих ожиданий. Работники ИИ постепенно начали понимать, что они не собираются решать NP-сложные проблемы, изобретая умный алгоритм вывода. Общие механизмы логического вывода, которые работали на игрушечных примерах, просто не масштабировались, когда размер проблемы достигал тысяч (а иногда и десятков).</p>
<p>Альтернативой был подход <em>экспертной системы</em>. Ключом к решению сложных проблем было усвоение особых правил, позволяющих разбить проблему на более простые. Согласно Фейгенбауму, урок, извлеченный из экспертных систем, таких как MYCIN (который мы увидим в <a href="B9780080571157500169.xhtml">главе 16</a>), заключается в том, что выбор механизма вывода не так важен, как наличие правильных знаний. С этой точки зрения не имеет большого значения, использует ли MYCIN прямую или обратную цепочку, или использует ли он факторы достоверности, вероятности или теорию нечетких множеств. Важно то, что мы знаем, что псевдомонады - это грамотрицательные палочковидные организмы, которые могут инфицировать пациентов с ослабленной иммунной системой. Другими словами, ключевая проблема - получение и представление знаний.</p>
<p>Хотя подход экспертной системы имел некоторые успехи, он также имел недостатки, и исследователи были заинтересованы в изучении ограничений этой новой технологии и понимании того, как именно она работает. Многих беспокоило то, что значение знаний, используемых в некоторых системах, никогда не было четко определено. Например, означает ли утверждение <code>(color apple red)</code>-цвет яблока красный, что конкретное яблоко красное, все яблоки красные или что некоторые/большинство яблок красные? Область <em>представления знаний</em> сосредоточена на обеспечении четкой семантики для таких представлений, а также предоставлении алгоритмов для манипулирования знаниями. Большое внимание уделялось поиску компромисса между <em>выразительностью</em> и <em>эффективностью</em>. Эффективный язык - это такой язык, для которого можно быстро ответить на все запросы (или, по крайней мере, на средний запрос). Если мы хотим гарантировать быстрое получение ответов на запросы, мы должны ограничить то, что может быть выражено на языке.</p>
<p>В конце 1980-х годов ряд результатов поставил под сомнение надежды найти эффективный язык с хоть сколько-нибудь разумной степенью выразительности. Используя математические методы, основанные на анализе наихудшего случая, было показано, что даже кажущиеся тривиальными языки были <em>трудноразрешимыми</em> - в худшем случае требовалось экспоненциальное количество времени, чтобы ответить на простой запрос.</p>
<p>Таким образом, в 1990-х годах акцент сместился на <em>представление знаний и рассуждения</em>, область, которая охватывает как выразительность, так и эффективность языков, но признает, что средний случай более важен, чем наихудший случай. Никакие знания не помогут решить неразрешимую проблему в худшем случае, но на практике худший случай случается редко.</p>
<h2>14.1 A Таксономия языков представления</h2>
<p>Исследователи искусственного интеллекта исследовали сотни языков представления знаний, пытаясь найти удобные, выразительные и эффективные языки. Языки можно разделить на четыре группы, в зависимости от того, какова основная единица представления. Вот четыре категории с некоторыми примерами:</p>
<ul>
<li><em>Логические формулы</em> (Prolog)</li>
<li><em>Сети</em> (семантические сети, концептуальные графы)</li>
<li><em>Объекты</em> (скрипты, фреймы)</li>
<li><em>Процедуры</em> (Лисп, производственные системы)</li>
</ul>
<p>Мы уже имели дело с <em>логическими</em> языками, такими как Prolog.</p>
<p><em>Сетевые</em> языки можно рассматривать как синтаксическую вариацию логических языков. Связь <em>L</em> между узлами <em>A</em> и <em>B</em> - это просто еще один способ выражения логической связи <em>L(A, B).</em> Разница в том, что сетевые языки относятся к своим ссылкам более серьезно: они предназначены для возможности быть реализованы непосредственно с помощью указателей в компьютере, а вывод выполняется путем обхода этих указателей. Таким образом, размещение ссылки <em>L</em> между <em>A</em> и <em>B</em> не только утверждает, что <em>L(A, B)</em> истинно, но также говорит кое-что о том, как следует искать в базе знаний.</p>
<p><em>Объектно-ориентированные</em> языки также можно рассматривать как синтаксические варианты исчисления предикатов. Вот утверждение на типичном языке фреймов для заполнения слотов:</p>
<div class="fragment"><div class="line">(a person</div><div class="line">  (name = Jan)</div><div class="line">  (age = 32))</div></div><!-- fragment --><p>Это эквивалентно логической формуле:</p>
<p>&exist;p: person(p) &and; name(p,Jan) &and; age(p,32)</p>
<p>Фреймовое обозначение имеет то преимущество, что, по мнению некоторых, его легче читать. Однако фреймовое обозначение менее выразительно. Невозможно сказать, что человека зовут Ян или Джон, или что ему не 34 года. Конечно, в исчислении предикатов такие утверждения можно легко сделать.</p>
<p>Наконец, <em>процедурные</em> языки должны быть противопоставлены языкам представления: процедурные языки вычисляют ответы без явного представления знаний.</p>
<p>Существуют также гибридные языки представления, которые используют разные методы для кодирования разных видов знаний. В семействе языков KL-ONE используются, например, как логические формулы, так и объекты, объединенные в сеть. Многие фреймовые языки допускают <em>процедурное присоединение</em> - метод, который использует произвольные процедуры для вычисления значений для выражений, которые неудобно или невозможно выразить на самом языке фреймов.</p>
<h2>14.2 Исчисление предикатов и его проблемы</h2>
<p>До сих пор многие из наших представлений были основаны на исчислении предикатов, системе обозначений, занимающей особое место в ИИ: она служит универсальным стандартом, по которому определяются и вычисляются другие представления. В предыдущем разделе был приведен пример выражения из фреймового языка. Язык фреймов может иметь много достоинств с точки зрения простоты использования синтаксиса или эффективности внутреннего представления данных. Однако, чтобы понять, что означают выражения в языке, должно быть четкое определение. Чаще всего это определение дается в терминах исчисления предикатов.</p>
<p>Представление исчисления предикатов предполагает универсум индивидов с отношениями и функциями этих индивидов, а также предложения, сформированные путем комбинирования отношений с логическими связками <code>and</code>(и), <code>or</code>(или) и <code>not</code>(не). Философы и психологи будут спорить о том, насколько уместно исчисление предикатов в качестве модели человеческого мышления, но одно ясно: исчисления предикатов достаточно, чтобы представить все, что может быть представлено в цифровом компьютере. Это легко показать: если в памяти компьютера есть <em>n</em> битов, а уравнение <em>bi</em> = 1 означает, что бит <em>i</em> включен(on), тогда все состояние компьютера представимо конъюнкцией, например:</p>
<p>b0=0&and;b1=0&and;b2=1...&and;bn=0</p>
<div class="image">
<img src="images/chapter14/si1_e.gif" alt="si1_e"/>
</div>
<p>Как только мы можем представить состояние компьютера, становится возможным представить любую компьютерную программу в исчислении предикатов как набор аксиом, отображающих одно состояние на другое. Таким образом, показано, что исчисление предикатов является <em>достаточным</em> языком для представления всего, что происходит внутри компьютера - его можно использовать как инструмент для анализа любой программы извне.</p>
<p>Это не доказывает, что исчисление предикатов является <em>подходящим</em> инструментом для всех приложений. Есть веские причины, по которым мы можем захотеть представить знания в форме, которая сильно отличается от исчисления предикатов, и манипулировать знаниями с помощью процедур, которые сильно отличаются от логического вывода. Но мы по-прежнему должны суметь описать нашу систему в терминах аксиом исчисления предикатов и доказать теоремы о ней. Делать меньше - значит быть небрежным. Например, мы можем захотеть манипулировать числами внутри компьютера, используя арифметические инструкции, встроенные в ЦП, а не манипулируя аксиомами исчисления предикатов, но когда мы пишем процедуру извлечения квадратного корня, она лучше удовлетворяет аксиоме:</p>
<p>x=y=&gt;yxy=x</p>
<div class="image">
<img src="images/chapter14/si2_e.gif" alt="si2_e"/>
</div>
<p>Исчисление предикатов также служит другой цели: как инструмент, который может использоваться программой, а не <em>в</em> программе. Все программы должны манипулировать данными, а некоторые программы будут манипулировать данными, которые, как считается, находятся в нотации исчисления предикатов. Именно этим использованием мы и займемся.</p>
<p>Исчисление предикатов позволяет легко начать записывать факты о предметной области. Но самая простая версия исчисления предикатов страдает рядом серьезных ограничений:</p>
<ul>
<li><em>Разрешимость</em> - с учетом набора аксиом и цели может оказаться, что ни цель, ни ее отрицание не могут быть выведены из аксиом.</li>
<li><em>Последовательность</em> - даже если цель доказуема, поиск доказательства с использованием доступных механизмов вывода может занять слишком много времени.</li>
<li><em>Неопределенность</em> - может быть неудобно иметь дело с отношениями, которые в определенной степени вероятны, но не известны как однозначно истинные или ложные.</li>
<li><em>Монотонность</em> - в чистом исчислении предикатов, как только теорема доказана, она верна навсегда. Но мы хотели бы получить способ вывести предварительные теоремы, основанные на предположениях, и иметь возможность отказаться от них, когда предположения оказываются ложными.</li>
<li><em>Непротиворечивость</em> - чистое исчисление предикатов не допускает противоречий. Если случайно выведены и <em>P</em>, и &not; <em>P</em>, то может быть доказана <em>любая</em> теорема. Фактически, одно противоречие портит всю базу данных.</li>
<li><em>Всеведение</em> - бывает трудно отличить доказуемое от того, что следует доказать. Это может привести к необоснованному предположению, что агент верит во все последствия известных ему фактов.</li>
<li><em>Выразительность</em> - исчисление предикатов первого порядка затрудняет разговоры о некоторых вещах, таких как отношения и предложения самого языка.</li>
</ul>
<p>Сегодня преобладает мнение, что лучше всего решать эти проблемы с помощью двойной атаки, которая находится как внутри, так и вне исчисления предикатов. Считается хорошей идеей изобрести новые обозначения для решения проблем - как для удобства, так и для облегчения работы специалистов по рассуждению, которые более эффективны, чем средство доказательства теорем общего назначения. Однако также важно скрупулезно определить значение новой нотации в терминах знакомой нотации исчисления предикатов. Как выразился Дрю Макдермотт: "Никаких обозначений без обозначений!"(No notation without denotation!) (1978).</p>
<p>В этой главе мы покажем, как новые обозначения (и их соответствующие значения) могут быть использованы для расширения существующей системы представлений и рассуждений. В качестве языка для расширения выбран Пролог. Это не означает одобрения Пролога как языка окончательного представления знаний. Скорее, он предназначен исключительно для того, чтобы дать нам ясную и знакомую основу для построения.</p>
<h2>14.3 Логический язык: пролог</h2>
<p>Пролог был предложен как ответ на проблему программирования в логике. Почему он не принят в качестве универсального языка представления? Вероятно потому, что Пролог - это компромисс между языком представления и языком программирования. При наличии двух логически эквивалентных спецификаций одна может быть эффективной программой на Прологе, а другая - нет. Знаменитое уравнение Ковальского "*algorithm = logic + control"* (алгоритм = логика + управление) выражает пределы одной только логики: <em>логика = алгоритм - управление.</em> Многие задачи (особенно в ИИ) имеют большие или бесконечные пространства поиска, и если Прологу не дается какой-либо совет по как найти это место, ответ не найдется за разумный промежуток времени.</p>
<p>Проблемы Пролога делятся на три класса. Во-первых, чтобы сделать язык эффективным, его выразительность была ограничена. Невозможно утверждать, что человека зовут Ян или Джон в Прологе (хотя можно <em>спросить</em>, является ли имя человека одним из таких). Точно так же нельзя утверждать, что факт ложен; Пролог не делает различий между ложным и неизвестным. Во-вторых, механизм вывода Пролога не является ни надежным, ни полным. Поскольку он не проверяет круговую унификацию, он может давать неправильные ответы, а поскольку он ищет в глубину, он может пропустить правильные ответы. В-третьих, в Prolog нет хорошего способа добавления управляющей информации к базовой логике, что делает его неэффективным для решения определенных проблем.</p>
<h2>14.4 Проблемы с выразительностью Пролога</h2>
<p>Если Пролог занимается логическим программированием, это не полная знакомая нам логика предикатов. Основная проблема заключается в том, что Пролог не может выражать определенные виды неопределенных фактов. Он может отражать определенные факты: столица Род-Айленда - Провиденс. Он может представлять собой соединение(conjunctions) фактов: столица Род-Айленда - Провиденс, и столица Калифорнии - Сакраменто. Но он не может представлять собой разобщение(disjunctions) или отрицание(negations): что столица Калифорнии <em>не</em> Лос-Анджелес или что столица Нью-Йорка <em>либо</em> Нью-Йорк, <em>либо</em> Олбани. Мы могли бы попробовать это:</p>
<div class="fragment"><div class="line">(&lt;- (not (capital LA CA)))</div><div class="line">(&lt;- (or (capital Albany NY) (capital NYC NY)))</div></div><!-- fragment --><p>но заметьте, что эти последние два факта касаются отношения <code>не</code>(not) и <code>или</code>(or), а не отношения <code>capital</code>(столица). Таким образом, они не будут рассматриваться, когда мы зададим вопрос о <code>столице</code>(capital). К счастью, утверждение "Either NYC or Albany is the capital of NY"(Либо Нью-Йорк, либо Олбани является столицей штата Нью-Йорк) можно перефразировать как два утверждения: "Albany is the capital of NY if NYC is not"(Олбани является столицей Нью-Йорка, если Нью-Йорк не является) и "NYC is the capital of NY if Albany is not:"(Нью-Йорк является столицей Нью-Йорка, если Олбани не является):</p>
<div class="fragment"><div class="line">(&lt;- (capital Albany NY) (not (capital NYC NY)))</div><div class="line">(&lt;- (capital NYC NY) (not (capital Albany NY)))</div></div><!-- fragment --><p>К сожалению, не(not) Пролог отличается от логического <code>не</code>(not). Когда Prolog отвечает "no" на запрос, это означает, что запрос не может быть доказан на основе известных фактов. Если все известно, то запрос должен быть ложным, но если есть факты, которые неизвестны, запрос действительно может быть истинным. В этом нет ничего удивительного; мы не можем ожидать, что программа предложит ответы, используя знания, которых у неё нет. Но в этом случае возникают проблемы. Учитывая предыдущие два предложения и запрос <code>(capital ?c NY)</code>, Prolog перейдет в бесконечный цикл. Если мы удалим первое предложение, Пролог потерпит неудачу, при доказательстве, что Олбани является столицей, и, следовательно, придет к выводу, что это Нью-Йорк. Если убрать второй пункт, будет сделан противоположный вывод.</p>
<p>Проблема в том, что Пролог приравнивает "не доказано" к "ложному". Пролог делает то, что называется <em>предположением о закрытом мире</em> - он предполагает, что знает все, что истинно. Предположение о закрытом мире является разумным для большинства программ, потому что программист знает всю необходимую информацию. Но для представления знаний в целом нам нужна система, которая не делает предположение о замкнутом мире и имеет три способа ответить на запрос: "да"(yes), "нет"(no) или "неизвестно"(unknown). В этом примере мы не сможем сделать вывод о том, что столица Нью-Йорка является или не является Нью-Йорком, поэтому мы не сможем сделать никаких выводов об Олбани.</p>
<p>В качестве другого примера рассмотрим предложения:</p>
<div class="fragment"><div class="line">(&lt;- (damned) (do))</div><div class="line">(&lt;- (damned) (not (do)))</div></div><!-- fragment --><p>С этими правилами запрос <code>(? (damned))</code> следует логически ответить "yes"(да). Более того, должна быть возможность сделать вывод <code>(damned)</code>(проклятый) даже без расследования, доказуемо ли <code>(do)</code>. Пролог сначала пытается доказать <code>(do)</code>(делать). Если это удается, то <code>(damned)</code> доказано. В любом случае, Prolog затем снова пытается доказать <code>(do)</code>, и на этот раз, если доказательство не удастся, то <code>(damned)</code> доказано. Таким образом, Prolog выполняет одно и то же доказательство дважды, когда в этом нет необходимости. Введение отрицания разрушает простую схему вычисления Пролога. Теперь уже недостаточно рассматривать по одному предложению за раз. Скорее, несколько предложений должны рассматриваться вместе, если мы хотим получить все правильные ответы.</p>
<p>Роберт <a href="B9780080571157500285.xhtml#bb0865">Мур, 1982</a> дает хороший пример силы дизъюнктивного мышления. Его проблема касалась трех цветных блоков, но мы обновим ее для трех стран. Предположим, что некая восточноевропейская страна <em>E</em> только что решила, останется ли она под коммунистическим правлением или станет демократией, но мы не знаем результата этого решения. <em>E</em> находится между демократией <em>D</em> и коммунистической страной <em>C</em>:</p>
<div class="image">
<img src="images/chapter14/u14-02.jpg" alt="u14-02"/>
</div>
<p>Возникает вопрос: есть ли коммунистическая страна рядом с демократией? Мур отмечает, что ответ - "да", но для того, чтобы это обнаружить, необходимо рассуждать по конкретным случаям. Если <em>E</em> - демократия, то это рядом с <em>C</em>, и ответ - да. Но если <em>E</em> коммунистическая, то она стоит рядом с <em>D</em>, и ответ все равно положительный. Поскольку это единственные две возможности, в любом случае ответ должен быть положительным. Логические рассуждения дают нам правильный ответ, а Пролог - нет. Мы можем описать проблему с помощью следующих семи утверждений и одного запроса, но Пролог не может иметь дело с или в окончательном утверждении.</p>
<div class="fragment"><div class="line">(&lt;- (next-to D E))    (&lt;- (next-to E D))</div><div class="line">(&lt;- (next-to E C))    (&lt;- (next-to C E))</div><div class="line">(&lt;- (democracy D))    (&lt;- (communist C))</div><div class="line">(&lt;- (or (democracy E)  (communist E)))</div><div class="line">(?- (next-to ?A ?B) (democracy ?A) (communist ?B))</div></div><!-- fragment --><p>Мы увидели, что Пролог не очень хорош для представления дизъюнкций и отрицаний. Ему также трудно представить экзистенциальные элементы. Рассмотрим следующее утверждение на английском языке, logic и Prolog:</p>
<p>Jan likes everyone.(Яну все нравятся).</p>
<p>&forall; <em>x</em> person(<em>x</em>) =&gt; likes(Jan,<em>x</em>)</p>
<div class="fragment"><div class="line">(&lt;- (likes Jan ?x) (person ?x))</div></div><!-- fragment --><p>Перевод Пролога точен. Но нет хорошего перевода для фразы "Jan likes someone"(Ян любит кого-то). Ближайшее, что мы можем получить:</p>
<p>Jan likes someone.(Ян любит кого-то)</p>
<p>&exist; <em>x</em> person(x) =&gt; likes(Jan,x)</p>
<div class="fragment"><div class="line">(&lt;- (likes Jan pl))</div><div class="line">(&lt;- (person pl))</div></div><!-- fragment --><p>Здесь мы изобрели новый символ <code>p1</code>, чтобы представить неизвестного человека, который нравится Яну, и заявили, что <code>p1</code> - это человек. Обратите внимание, что <code>p1</code> - это константа, а не переменная. Такое использование константы для представления определенной, но неизвестной сущности называется <em>константой Сколема</em> в честь логика Торальфа Сколема (1887-1963). Смысл в том, что <code>p1</code> может быть равно какому-то(любому) другому человеку, о котором мы знаем. Если мы выясним, что Адриан - это человек, который нравится Яну, то по логике мы можем просто добавить утверждение p1 = Adrian. Но это не работает в Prolog, потому что Prolog неявно использует <em>предположение об уникальности имени</em> - все атомы представляют отдельных людей.</p>
<p>Константа Сколема - это просто частный случай <em>функции Сколема</em> - неизвестной сущности, которая зависит от одной или нескольких переменных. Например, чтобы представить "Всем кто-то нравится"(Everyone likes someone) мы могли бы использовать:</p>
<p>Everyone likes someone.(Всем кто-то нравится).</p>
<p>&forall;<em>y</em>&exist; <em>x</em> person (<em>x</em>) =&gt; likes (<em>y, x</em>)</p>
<div class="fragment"><div class="line">(&lt;- (likes ?y (p2 ?y)))</div><div class="line">(&lt;- (person (p2 ?y)))</div></div><!-- fragment --><p>Здесь <code>p2</code> - функция Сколема, которая зависит от переменной <code>?y</code>. Другими словами, всем нравится какой-то человек(everyone likes some person), но не обязательно один и тот же человек.</p>
<h2>14.5 Проблемы с выразительностью исчисления предикатов</h2>
<p>В предыдущем разделе мы видели, что Prolog променял выразительность в пользу эффективности. В этом разделе исследуются пределы выразительности исчисления предикатов.</p>
<p>Предположим, мы хотим утверждать, что львы, тигры и медведи - это разные животные. В исчислении предикатов или в Прологе мы могли бы написать импликацию для каждого случая:</p>
<div class="fragment"><div class="line">(&lt;- (animal ?x) (lion ?x))</div><div class="line">(&lt;- (animal ?x) (tiger ?x))</div><div class="line">(&lt;- (animal ?x) (bear ?x))</div></div><!-- fragment --><p>Эти выводы позволяют нам доказать, что любой известный лев, тигр или медведь на самом деле является животным. Однако они не позволяют нам ответить на вопрос "Какие бывают виды животных?" Нетрудно представить расширение Prolog таким образом, чтобы запрос</p>
<div class="fragment"><div class="line">(?- (&lt;- (animal ?x) ?proposition))</div></div><!-- fragment --><p>было бы законным. Однако оказывается, что это неверный Пролог, и это даже не действительное исчисление предикатов первого порядка (first-order predicate calculus или FOPC). В FOPC переменные должны меняться над константами языка, а не над отношениями или предложениями. Исчисление предикатов более высокого порядка снимает это ограничение, но имеет более сложную теорию доказательств.</p>
<p>Непонятно даже, какими должны быть значения <code>?proposition</code> в запросе выше. Несомненно, <code>(lion ?x)</code> будет правильным ответом, но то же самое будет с `<code>(animal ?x), (or (tiger ?x) (bear ?x))</code> и бесконечным количеством других предложений. Возможно, нам следует иметь два типа запросов: один спрашивает о "видах"("kinds"), а другой спрашивает о утверждениях(propositions).</p>
<p>Есть и другие вопросы, которые мы могли бы задать об отношениях. Так же, как полезно объявлять типы параметров функции Lisp, может быть полезно объявить типы параметров отношения, а затем запросить эти типы. Например, мы можем сказать, что между человеком и объектом существует отношение <code>likes</code>(нравится).</p>
<p>В общем, предложение в исчислении предикатов, в котором в качестве термина используется отношение или предложение, называется предложением более высокого порядка(higher-order sentence). Когда мы начинаем разрешать выражения более высокого порядка, возникают некоторые довольно тонкие проблемы. Разрешение предложениям в исчислении говорить об истинности других предложений может привести к парадоксу: истинно ли предложение "This sentence is false"(Это предложение ложно)?</p>
<p>Исчисление предикатов определяется в терминах вселенной индивидов, их свойств и отношений. Таким образом, оно хорошо подходит для модели мира, которая выбирает людей и классифицирует их: человек здесь, здание там, тротуар между ними. Но насколько хорошо работает исчисление предикатов в мире непрерывных субстанций? Представьте себе водоем, состоящий из неопределенного числа составляющих, которые все являются водой, при этом часть воды испаряется в воздух и поднимается, образуя облака. Совершенно не очевидно, как здесь определять индивидуумов. Однако Патрик Хейз показал, что когда сделан правильный выбор, исчисление предикатов может достаточно хорошо описать такую ситуацию. Детали в Hayes 1985.</p>
<p>Исчисление предикатов очень хорошо подходит для четких математических категорий: a; является треугольником тогда и только тогда, когда <em>x</em> - многоугольник с тремя сторонами. К сожалению, большинство категорий, с которыми люди сталкиваются в повседневной жизни, не определены так строго. Категория <em>друг</em>(friend) относится к тем, к кому вы испытываете в основном положительные чувства, кому вы обычно можете доверять, и так далее. Это "определение" не является набором необходимых и достаточных условий, а, скорее, представляет собой неограниченный список плохо определенных качеств, которые сильно коррелируют с категорией <em>друг</em>. У нас есть прототип того, каким должен быть идеальный друг, но нет четких границ, отделяющих <em>друга</em>, скажем, от <em>знакомого</em>. в контексте вашей семейной жизни.</p>
<p>Существуют версии исчисления предикатов, которые допускают такие кванторы, как "most"(большинство) в дополнение к "for all"(для всех) и "there exists"(существует), и были попытки определить прототипы и измерить расстояния от них. Однако единого мнения о подходе к этой проблеме нет.</p>
<h2>14.6 Проблемы с полнотой</h2>
<p>Поскольку Prolog выполняет поиск в глубину, он может попасть в одну ветвь области поиска и никогда не исследовать другие ветки. Эта проблема может проявиться, например, при попытке определить коммутативное отношение, например <code>sibling</code>(брат/сестра):</p>
<div class="fragment"><div class="line">(&lt;- (sibling lee kim))</div><div class="line">(&lt;- (sibling ?x ?y) (sibling ?y ?x))</div></div><!-- fragment --><p>С помощью этих пунктов мы надеемся сделать вывод, что Ли(Lee) является братом Ким(Kim), а Ким - Ли. Давай посмотрим что происходит:</p>
<div class="fragment"><div class="line">&gt; (?- (sibling ?x ?y))</div><div class="line">?X = LEE</div><div class="line">?Y = KIM;</div><div class="line">?X = KIM</div><div class="line">?Y = LEE;</div><div class="line">?X = LEE</div><div class="line">?Y = KIM;</div><div class="line">?X = KIM</div><div class="line">?Y = LEE.</div><div class="line">No.</div></div><!-- fragment --><p>Мы получаем ожидаемые выводы, но они выводятся неоднократно, потому что коммутативное предложение для братьев и сестер применяется снова и снова. Это раздражает, но не критично. Намного хуже, когда мы спрашиваем <code>(?- (sibling fred ?x))</code>. Этот запрос повторяется вечно. К счастью, этот конкретный пример можно легко исправить: просто введите два предиката, один для фактов уровня базы данных, а другой на уровне аксиом и запросов:</p>
<div class="fragment"><div class="line">(&lt;- (sibling-fact lee kim))</div><div class="line">(&lt;- (sibling ?x ?y) (sibling-fact ?x ?y))</div><div class="line">(&lt;- (sibling ?x ?y) (sibling-fact ?y ?x))</div></div><!-- fragment --><p>Еще одно исправление - изменить интерпретатор так, чтобы он падал при обнаружении повторяющейся цели. Это был подход, использованный в GPS. Однако, даже если мы исключим повторяющиеся цели, Prolog все равно может застрять в одной ветви поиска в глубину. Рассмотрим пример:</p>
<div class="fragment"><div class="line">(&lt;- (natural 0))</div><div class="line">(&lt;- (natural (1  + ?n)) (natural ?n))</div></div><!-- fragment --><p>Эти правила определяют натуральные числа (неотрицательные целые числа). Мы можем использовать правила либо для подтверждения запросов типа <code>(natural (1 + (1 + (1 + 0))))</code>, либо для генерации натуральных чисел, как в запросе <code>(natural ?n)</code>. Пока все нормально. Но предположим, что мы хотим определить все целые числа. Один из подходов был бы таким:</p>
<div class="fragment"><div class="line">(&lt;- (integer 0))</div><div class="line">(&lt;- (integer ?n) (integer (1  + ?n)))</div><div class="line">(&lt;- (integer (1  + ?n)) (integer ?n))</div></div><!-- fragment --><p>Эти правила говорят, что 0 - это целое число, а любое <em>n</em> - целое, если <em>n</em> + 1 целое, и <em>n</em> + 1 - если <em>n</em> целое. Хотя эти правила верны в логическом смысле, они не работают как программа на Прологе. Запрос <code>(integer *x*)</code> приведет к бесконечной серии постоянно растущих запросов: <code>(integer (1 + *x*)), (integer (1 + (1 + *x*)))</code> и т.д. Каждая цель отличается, поэтому никакая проверка не может остановить рекурсию.</p>
<p>В зависимости от вашей интерпретации бесконечных деревьев эта проверка может или не может вызвать проблемы в Прологе. Большинство систем Prolog не выполняют проверку встречаемости(occurs check). Причина в том, что объединение переменной с некоторым значением является в Прологе эквивалентом присвоения значения переменной, и программисты ожидают, что такая базовая операция будет быстрой. Если проверка встречаемости отключена, это действительно будет быстро. При включенной проверке требуется время, пропорциональное размеру значения, что считается неприемлемым.</p>
<p>Если проверка встречаемости отключена, программист получает преимущество быстрой унификации, но может столкнуться с проблемами с круговыми структурами. Обратите внимание на следующие предложения:</p>
<div class="fragment"><div class="line">(&lt;- (parent ?x (mother-of ?x)))</div><div class="line">(&lt;- (parent ?x (father-of ?x)))</div></div><!-- fragment --><p>В этих предложениях говорится, что для любого человека мать этого человека и отец этого человека являются родителями этого человека. Теперь давайте спросим, есть ли человек, который является своим собственным родителем:</p>
<p><code>&gt; (? (parent ?y ?y))</code></p>
<div class="fragment"><div class="line">?Y = [Abort]</div></div><!-- fragment --><p>Система нашла ответ, где <code>?y = (mother-of ?y)</code>. Однако ответ не может быть напечатан, потому что <code>deref</code> (или <code>subst-bindings</code> в интерпретаторе) переходит в бесконечное число циклов пытаясь выяснить, что такое <code>?y</code>`. Без печати не было бы бесконечного цикла:</p>
<div class="fragment"><div class="line">(&lt;- (self-parent) (parent ?y ?y))</div></div><!-- fragment --><p><code>&gt; (? (self-parent))</code></p>
<div class="fragment"><div class="line">Yes;</div><div class="line">Yes;</div><div class="line">No.</div></div><!-- fragment --><p>Запрос <code>self-parent</code> завершается успешно дважды: один раз с предложением mother и один раз с предложением father(отца). Правильно ли поступил здесь Prolog? Это зависит от вашей интерпретации бесконечных циклических деревьев. Если вы принимаете их как допустимые объекты, то ответ будет однозначным. Если вы этого не сделаете, то пропуск проверки встречаемости делает Prolog <em>ненадежным:</em> он может давать неправильные ответы.</p>
<p>Та же проблема возникает, если мы спросим, есть ли какие-нибудь группы, которые включают себя в качестве членов. Запрос <code>(member ?set ?set)</code> будет успешным, но мы не сможем распечатать значение <code>?set</code>.</p>
<h2>14.7 Проблемы с эффективностью: индексирование</h2>
<p>Наш компилятор пролога предназначен для обработки "программоподобных" предикатов - предикатов с небольшим количеством правил, возможно, со сложными телами. Компилятор гораздо хуже справляется с "табличноподобными" предикатами - предикатами с большим количеством простых фактов. Рассмотрим предикат 'pb`, который кодирует факты телефонной книги в виде:</p>
<div class="fragment"><div class="line">(pb (name Jan Doe) (num 415 555 1212))</div></div><!-- fragment --><p>Предположим, у нас есть несколько тысяч таких записей. Типичный запрос к этой базе данных:</p>
<div class="fragment"><div class="line">(pb (name Jan Doe) ?num)</div></div><!-- fragment --><p>Было бы неэффективно искать факты линейно, сопоставляя каждый из них с запросом. Также было бы неэффективно перекомпилировать весь предикат <code>pb/2</code> каждый раз, когда добавляется новая запись. Но это именно то, что делает наш компилятор.</p>
<p>Решения трех проблем - выразительности, полноты и индексации - будут рассмотрены в обратном порядке, так что самая сложная - выразительность - будет последней.</p>
<h2>14.8 Решение проблемы индексации</h2>
<p>Лучшее решение проблемы телефонной книги - это индексировать каждую запись телефонной книги в некоторой таблице, которая упрощает добавление, удаление и извлечение записей. Этим мы и займемся в этом разделе. Мы разработаем расширение структуры данных trie или дерева дискриминации, построенное в <a href="B9780080571157500108.xhtml#s0030">раздел 10.5</a> (<a href="B9780080571157500108.xhtml#p344">страница 344</a>).</p>
<p>Создание дерева дискриминации(различения) для фактов Пролога осложняется наличием переменных как в фактах, так и в запросе. Либо факты с переменными в них нужно будет проиндексировать в нескольких местах, либо запросы с переменными придется искать в нескольких местах, либо и то, и другое. Мы также должны решить, будет ли само дерево дискриминации обрабатывать привязку переменных или будет просто возвращать совпадения кандидатов, которые затем проверяются каким-либо другим процессом. Непонятно, что хранить в дереве дискриминации: копии фактов, функции, которым можно передавать продолжения, или что-то еще. По мере продолжения работы появятся новые варианты дизайна.</p>
<p>Трудно сделать выбор дизайна, когда мы не знаем точно, как будет использоваться система. Мы не знаем, как будут выглядеть типичные факты или типичные запросы. Поэтому мы разработаем довольно абстрактный инструмент, забыв на время, что он будет использоваться для индексации фактов Пролога.</p>
<p>Мы рассмотрим проблему дерева дискриминации, в котором и ключи, и запросы являются структурами предикатов с подстановочными знаками. Подстановочный знак - это переменная, но с пониманием того, что привязки переменной нет; каждый экземпляр переменной может соответствовать чему угодно. Структура предиката - это список, первым элементом которого является неизменяемый символ. Дерево дискриминации поддерживает три операции:</p>
<ul>
<li><code>index</code>-добавить в дерево пару ключ/значение</li>
<li><code>fetch</code>-найти все значения, которые потенциально соответствуют заданному ключу</li>
<li><code>unindex</code>-удалить все пары ключ/значение, соответствующие заданному ключу</li>
</ul>
<p>Чтобы оценить проблемы, нам нужен пример. Предположим, у нас есть следующие шесть ключей для индексации. Для простоты значение каждого ключа будет самим ключом:</p>
<div class="fragment"><div class="line">1 (p a b)</div><div class="line">2 (p a c)</div><div class="line">3 (p a ?x)</div><div class="line">4 (p b c)</div><div class="line">5 (p b (f c))</div><div class="line">6 (p a (f . ?x))</div></div><!-- fragment --><p>Теперь предположим, что запрос <code>(p ?y c)</code>. Это должно соответствовать ключам 2, 3 и 4. Как мы можем эффективно получить этот набор? Одна из идей - перечислить пары ключ/значение под каждым атомом, который они содержат. Таким образом, все шесть будут перечислены под атомом <code>p</code>, а 2, 4 и 5 будут перечислены под атомом c. Проверка унификации может исключить 5, но нам все равно не хватит 3. Ключ 3 (и каждый ключ с переменной в нем) потенциально может содержать атом c. Таким образом, чтобы получить правильные ответы при таком подходе, нам нужно будет проиндексировать каждый ключ, который содержит переменную под каждым атомом, что не является привлекательной ситуацией.</p>
<p>Альтернативой является создание индексов на основе как атомов, так и их положения(позиции). Итак, теперь мы будем извлекать все ключи, у которых есть c во второй позиции аргумента: 2 и 4, плюс ключи, у которых есть переменная в качестве второго аргумента: 3. Этот подход работает намного лучше, по крайней мере, для показанного примера. Чтобы создать индекс, мы, по сути, накладываем структуру списка всех ключей друг на друга, чтобы получить одно большое дерево дискриминации. В каждой позиции в дереве мы создаем индекс ключей, которые имеют либо атом, либо переменную в этой позиции. <a href="# f0010">Рисунок 14.1</a> показывает дерево дискриминации для шести ключей.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter14/f14-01.jpg" alt="f14-01"/>
</div>
 </td></tr>
<tr>
<td>Figure 14.1: Discrimination Tree with Six Keys </td></tr>
</table>
<p>Рассмотрим запрос <code>(p ?y c)</code>. В качестве индекса можно использовать либо <code>p</code>, либо <code>c</code>. <code>p</code> в позиции предиката возвращает все шесть ключей. Но c во второй позиции аргумента возвращает только три ключа: 2 и 4, которые индексируются под самой c, и 3, которые индексируются под переменной в этой позиции.</p>
<p>Теперь рассмотрим запрос <code>(p ?y (f ?z))</code>. Опять же, <code>p</code> служит индексом для всех шести ключей. <code>f</code> служит индексом только для трех ключей: 5 и 6, которые индексируются непосредственно под f в этой позиции, и 3, который индексируется под переменной в позиции вдоль пути, ведущего к f. Как правило, необходимо учитывать все ключи, проиндексированные под переменными по пути.</p>
<p>Механизм извлечения может перегружать извлечиние. Учитывая запрос <code>(p a (f ?x))</code>, атом <code>p</code> снова получит все шесть ключей, атом a получит 1, 2, 3 и 6, а f снова получит 5, 6 и 3. Таким образом, <code>f</code> извлекает самый короткий список и, следовательно, он будет использоваться для определения окончательного результата. Но ключ 5 - это <code>(p b (f c))</code>, что не соответствует запросу <code>(pa (f ?x))</code>.</p>
<p>Мы могли бы устранить эту проблему, пересекая все списки вместо того, чтобы просто выбирать самый короткий список. Возможно, возможно выполнить пересечение с использованием битовых векторов, но, вероятно, делать это слишком медленно и расточительно, по использованному пространству, с помощью списков. Даже если бы мы действительно пересечем ключи, мы все равно выполняли бы повторное извлечение по двум причинам. Во-первых, мы не используем nil в качестве индекса, поэтому мы игнорируем разницу между <code>(f ?x)</code> и <code>(f . ?x)</code>. Во-вторых, мы используем семантику подстановочных знаков(wild-card), поэтому запрос <code>(p ?x ?x)</code> извлечет все шесть ключей, тогда как он должен получить только три. Из-за этих проблем мы делаем выбор дизайна: сначала мы создадим функцию извлечения базы данных, которая извлекает потенциальные совпадения, а затем позаботимся о процессе унификации, который устранит несоответствия.</p>
<p>Мы готовы к более полному уточнению стратегии индексации:</p>
<ul>
<li>Значение будет проиндексировано под каждым непеременным атомом ключа, отличным от nil, с отдельным индексом для каждой позиции. Например, с учетом предыдущей базы данных атом a в позиции первого аргумента будет индексировать значения 1,2,3 и 6, а атом b во второй позиции аргумента будет индексировать значения 4 и 5. Атом p в позиции предиката будет индексировать все шесть значений.</li>
<li>Кроме того, мы будем поддерживать отдельный индекс для переменных в каждой позиции. Например, значение 3 будет сохранено под индексом "переменная во второй позиции аргумента".</li>
<li>"Позиция" не относится исключительно к линейной позиции в списке верхнего уровня. Например, значение 5 будет индексировано под атомом f в позиции caaddr.</li>
<li>Отсюда следует, что ключ с <em>n</em> атомами будет индексироваться <em>n</em> разными способами.</li>
</ul>
<p>Стратегия поиска такова:</p>
<ul>
<li>Для каждого непеременного атома, отличного от nil, в ключе поиска сгенерируйте список возможных совпадений. Выберите самый короткий из таких списков.</li>
<li>Каждый список возможных совпадений должен быть дополнен значениями, индексированными под переменной в каждой позиции "выше/над". Например, <code>f</code> в позиции <code>caaddr</code> извлекает значение 5, но он также должен извлекать значение 3, потому что третий ключ имеет переменную в позиции <code>caddr</code>, а <code>caddr</code> находится "выше/над" <code>caaddr.</code></li>
<li>Дерево дискриминации может возвращать значения, которые не являются допустимыми совпадениями. Цель дерева дискриминации - уменьшить количество значений, с которыми нам придется объединяться, а не определять точный набор совпадений.</li>
</ul>
<p>Важно, чтобы функция поиска выполнялась быстро. Если она медленна, мы могли бы точно сопоставить каждый ключ в таблице линейно. Поэтому мы позаботимся о том, чтобы каждую часть реализовать эффективно. Обратите внимание, что нам нужно будет сравнить длину списков, чтобы выбрать самый короткий вариант. Конечно, сравнивать длины с помощью <code>length</code> тривиально, но <code>length</code> требует обхода всего списка. Мы можем добиться большего, если явно сохраним длину списка. Список с его длиной будет называться <code>nlist</code>. Он будет реализован как cons-ячейка, содержащая количество элементов и список самих элементов. Альтернативой было бы использование расширяемых векторов с указателями заполнения(заполннености).</p>
<div class="fragment"><div class="line">;; An nlist is implemented as a (count . elements) pair:</div><div class="line">(defun make-empty-nlist ()</div><div class="line">  &quot;Create a new, empty nlist.&quot;</div><div class="line">  (cons 0 nil))</div><div class="line"></div><div class="line">(defun nlist-n (x) &quot;The number of elements in an nlist.&quot; (car x))</div><div class="line">(defun nlist-list (x) &quot;The elements in an nlist.&quot; (cdr x))</div><div class="line"></div><div class="line">(defun nlist-push (item nlist)</div><div class="line">  &quot;Add a new element to an nlist.&quot;</div><div class="line">  (incf (car nlist))</div><div class="line">  (push item (cdr nlist))</div><div class="line">  nlist)</div></div><!-- fragment --><p>Теперь нам нужно место для хранения этих nlists. Мы построим базу данных из узлов дерева дискриминации, называемых узлами dtree. Каждый узел dtree имеет поле для хранения индекса переменной, индексов атомов и указателей на два подузла, один для <code>first(первого)</code> и один для <code>rest(остальных)</code>. Мы реализуем dtrees как векторы для повышения эффективности и потому, что нам никогда не понадобится предикат dtree-p.</p>
<div class="fragment"><div class="line">(defstruct (dtree (:type vector))</div><div class="line">  (first nil) (rest nil) (atoms nil) (var (make-empty-nlist)))</div></div><!-- fragment --><p>Для каждого предиката будет храниться отдельное dtree. Поскольку предикаты должны быть символами, можно сохранить деревья dtrees в списке свойств предиката. В большинстве реализаций это будет быстрее, чем альтернативы, такие как хеш-таблицы.</p>
<div class="fragment"><div class="line">;; Not all Lisps handle the closure properly, so change the local PREDICATES</div><div class="line">;; to a global *predicates* - norvig Jun 11 1996</div><div class="line">(defvar *predicates* nil)</div><div class="line"></div><div class="line">(defun get-dtree (predicate)</div><div class="line">  &quot;Fetch (or make) the dtree for this predicate.&quot;</div><div class="line">  (cond ((get predicate &#39;dtree))</div><div class="line">    (t (push predicate *predicates*)</div><div class="line">       (setf (get predicate &#39;dtree) (make-dtree)))))</div><div class="line"></div><div class="line">(defun clear-dtrees ()</div><div class="line">  &quot;Remove all the dtrees for all the predicates.&quot;</div><div class="line">  (dolist (predicate *predicates*)</div><div class="line">    (setf (get predicate &#39;dtree) nil))</div><div class="line">  (setf *predicates* nil))</div></div><!-- fragment --><p>Функция index принимает отношение как ключ и сохраняет его в dtree для предиката отношения. Она вызывает dtree-index, чтобы выполнить всю работу по сохранению значения под соответствующими индексами для ключа в соответствующем узле dtree.</p>
<p>Индексы атомов хранятся в списке ассоциаций(a-list). Списки свойств не будут работать, потому что они производят поиск с помощью eq, а атомы могут быть числами, которые не обязательно являются <code>eq</code>. Списки ассоциаций по умолчанию производят поиск с использованием <code>eql</code>. Альтернативой может быть использование хеш-таблиц для индекса или даже использование схемы, по которой начинается работа со списков ассоциаций и переключается на хеш-таблицу, когда количество записей становится большим. Я использую <code>lookup</code>, чтобы найти значение ключа в списке свойств. Эта функция и ее метод <code>setf</code> определены на <a href="B978008057115750025X.xhtml#p896">стр. 896</a>.</p>
<div class="fragment"><div class="line">(defun index (key)</div><div class="line">  &quot;Store key in a dtree node.  Key must be (predicate . args);</div><div class="line">  it is stored in the predicate&#39;s dtree.&quot;</div><div class="line">  (dtree-index key key (get-dtree (predicate key))))</div><div class="line"></div><div class="line">(defun dtree-index (key value dtree)</div><div class="line">  &quot;Index value under all atoms of key in dtree.&quot;</div><div class="line">  (cond</div><div class="line">    ((consp key)               ; index on both first and rest</div><div class="line">     (dtree-index (first key) value</div><div class="line">                  (or (dtree-first dtree)</div><div class="line">                      (setf (dtree-first dtree) (make-dtree))))</div><div class="line">     (dtree-index (rest key) value</div><div class="line">                  (or (dtree-rest dtree)</div><div class="line">                      (setf (dtree-rest dtree) (make-dtree)))))</div><div class="line">    ((null key))               ; don&#39;t index on nil</div><div class="line">    ((variable-p key)          ; index a variable</div><div class="line">     (nlist-push value (dtree-var dtree)))</div><div class="line">    (t ;; Make sure there is an nlist for this atom, and add to it</div><div class="line">     (nlist-push value (lookup-atom key dtree)))))</div><div class="line"></div><div class="line">(defun lookup-atom (atom dtree)</div><div class="line">  &quot;Return (or create) the nlist for this atom in dtree.&quot;</div><div class="line">  (or (lookup atom (dtree-atoms dtree))</div><div class="line">      (let ((new (make-empty-nlist)))</div><div class="line">        (push (cons atom new) (dtree-atoms dtree))</div><div class="line">        new)))</div></div><!-- fragment --><p>Теперь мы определяем функцию для проверки процедуры индексирования. Сравните вывод с <a href="#f0010">рис. 14.1</a>.</p>
<div class="fragment"><div class="line">(defun test-index ()</div><div class="line">  (let ((props &#39;((p a b) (p a c) (p a ?x) (p b c)</div><div class="line">                 (p b (f c)) (p a (f . ?x)))))</div><div class="line">    (clear-dtrees)</div><div class="line">    (mapc #&#39;index props)</div><div class="line">    (write (list props (get-dtree &#39;p))</div><div class="line">           :circle t :array t :pretty t)</div><div class="line">    (values)))</div><div class="line"></div><div class="line">&gt; (test-index)</div><div class="line">((#1=(P A B)</div><div class="line">  #2=(P A C)</div><div class="line">  #3=(P A ?X)</div><div class="line">  #4=(P B C)</div><div class="line">  #5=(P B (F C))</div><div class="line">  #6=(P A (F . ?X)))</div><div class="line">  #(#(NIL NIL (P (6 #6# #5# #4# #3# #2# #1#)) (0))</div><div class="line">  #(#(NIL NIL (B (2 #5# #4#) A (4 #6# #3# #2# #1#)) (0))</div><div class="line">    #(#(#(NIL NIL (F (2 #6# #5#)) (0))</div><div class="line">      #(#(NIL NIL (C (1 #5#)) (0))</div><div class="line">        #(NIL NIL NIL (0)) NIL (1 #6#))</div><div class="line">      (C (2 #4# #2#) B (1 #1#))</div><div class="line">      (1 #3#))</div><div class="line">    #(NIL NIL NIL (0))</div><div class="line">    NIL (0))</div><div class="line">  NIL (0))</div><div class="line">  NIL (0)))</div></div><!-- fragment --><p>Следующим шагом будет получение совпадений из базы данных dtree. Функция <code>fetch</code> принимает запрос, который должен быть допустимым отношением, в качестве аргумента и возвращает список возможных совпадений. Она вызывает <code>dtree-fetch</code> для выполнения работы:</p>
<div class="fragment"><div class="line">(defun fetch (query)</div><div class="line">  &quot;Return a list of buckets potentially matching the query,</div><div class="line">  which must be a relation of form (predicate . args).&quot;</div><div class="line">  (dtree-fetch query (get-dtree (predicate query))</div><div class="line">               nil 0 nil most-positive-fixnum))</div></div><!-- fragment --><p><code>dtree-fetch</code>, конечно, должна передавать запрос и dtree, но ей также передаются четыре дополнительных аргумента. Во-первых, мы должны накапливать совпадения, индексированные по переменным, когда мы ищем в dtree. Таким образом, два аргумента используются для передачи фактических совпадений и подсчета их общего количества. Во-вторых, мы хотим, чтобы <code>dtree-fetch</code> возвращала самый короткий из возможных индексов, поэтому мы передаем ей самый короткий ответ, найденный на данный момент, и размер самого короткого ответа. Таким образом, по мере того, как она продвигается вниз по дереву, накапливая значения, индексированные по переменным, она может постоянно сравнивать размер развивающегося ответа с лучшим ответом, найденным на данный момент.</p>
<p>Мы могли бы использовать nlists для передачи пар счет/значения, но nlists поддерживают только операцию push, когда добавляется один новый элемент. Нам нужно объединить списки значений, поступающих из индексов переменных, со значениями, индексированными под атомом. Добавление(append) стоит дорого, поэтому вместо этого мы составляем список списков и сохраняем счетчик в отдельной переменной. Когда мы закончим, <code>dtree-fetch</code> и, следовательно, <code>fetch</code> возвращают несколько значений, в результате чего получается список списков и общее количество.</p>
<p>В <code>dtree-fetch</code> следует рассмотреть четыре случая. Если dtree имеет значение null, или образец запроса является null, либо переменная, то ничего не будет проиндексировано, поэтому мы должны просто вернуть лучший ответ, найденный на данный момент. В противном случае мы привязываем var-n и var-list к количеству и списку списков совпадений переменных, найденных на данный момент, в том числе на текущем узле. Если счетчик <code>var-n</code> больше, чем лучший до сих пор, то продолжать нет смысла, и мы возвращаем лучший найденный ответ. В противном случае мы смотрим на образец запроса. Если это атом, мы используем <code>dtree-atom-fetch</code> для возврата либо текущего индекса (вместе с накопленным индексом переменной), либо накопленного лучшего ответа, в зависимости от того, какой из них короче. Если запрос является cons, то мы используем <code>dtree-fetch</code> для первой части cons, давая новый лучший ответ, который передается при вызове <code>dtree-fetch</code> для остатка(rest) cons.</p>
<div class="fragment"><div class="line">(defun dtree-fetch (pat dtree var-list-in var-n-in best-list best-n)</div><div class="line">  &quot;Return two values: a list-of-lists of possible matches to pat,</div><div class="line">  and the number of elements in the list-of-lists.&quot;</div><div class="line">  (if (or (null dtree) (null pat) (variable-p pat))</div><div class="line">      (values best-list best-n)</div><div class="line">      (let* ((var-nlist (dtree-var dtree))</div><div class="line">             (var-n (+ var-n-in (nlist-n var-nlist)))</div><div class="line">             (var-list (if (null (nlist-list var-nlist))</div><div class="line">                           var-list-in</div><div class="line">                           (cons (nlist-list var-nlist)</div><div class="line">                                 var-list-in))))</div><div class="line">        (cond</div><div class="line">          ((&gt;= var-n best-n) (values best-list best-n))</div><div class="line">          ((atom pat) (dtree-atom-fetch pat dtree var-list var-n</div><div class="line">                                        best-list best-n))</div><div class="line">          (t (multiple-value-bind (list1 n1)</div><div class="line">                 (dtree-fetch (first pat) (dtree-first dtree)</div><div class="line">                              var-list var-n best-list best-n)</div><div class="line">               (dtree-fetch (rest pat) (dtree-rest dtree)</div><div class="line">                            var-list var-n list1 n1)))))))</div><div class="line"></div><div class="line">(defun dtree-atom-fetch (atom dtree var-list var-n best-list best-n)</div><div class="line">  &quot;Return the answers indexed at this atom (along with the vars),</div><div class="line">  or return the previous best answer, if it is better.&quot;</div><div class="line">  (let ((atom-nlist (lookup atom (dtree-atoms dtree))))</div><div class="line">    (cond</div><div class="line">      ((or (null atom-nlist) (null (nlist-list atom-nlist)))</div><div class="line">       (values var-list var-n))</div><div class="line">      ((and atom-nlist (&lt; (incf var-n (nlist-n atom-nlist)) best-n))</div><div class="line">       (values (cons (nlist-list atom-nlist) var-list) var-n))</div><div class="line">      (t (values best-list best-n)))))</div></div><!-- fragment --><p>Здесь мы видим вызов <code>fetch</code> в базе данных, созданной <code>test-index</code>. Она возвращает два значения: список-списков фактов и общее количество фактов - три.</p>
<div class="fragment"><div class="line">(fetch &#39;(p ? c))</div><div class="line">(((P B C) (P A C))</div><div class="line">  ((P A ?X)))</div><div class="line">3</div></div><!-- fragment --><p>А теперь остановимся и посмотрим, чего мы достигли. Функции <code>fetch и dtree-fetch</code> выполняют свой контракт на возврат потенциальных совпадений. Однако нам все еще нужно интегрировать функциональность dtree с Prolog. Нам нужно просмотреть потенциальные совпадения и определить, какие из кандидатов действительно совпадают. Для простоты мы будем использовать версию <code>unify</code> со списками привязки, определенными в <a href="B978008057115750011X.xhtml#s0020">разделе 11.2</a>. (Также можно создать более эффективную версию, которая использует компилятор и деструктивную функцию <code>unify!</code>.)</p>
<p>Функция <code>mapc-retrieve</code> вызывает <code>fetch</code>, чтобы получить список списков потенциальных совпадений, а затем вызывает <code>unify</code>, чтобы проверить, является ли совпадение истинным. Если совпадение истинно, она вызывает предоставленную функцию со списком привязки, который представляет объединение в качестве аргумента, <code>mapc-retrieve</code> объявляетсяс <code>inline</code>, так что переданные ему функции также могут быть скомпилированы на месте.</p>
<div class="fragment"><div class="line">(proclaim &#39;(inline mapc-retrieve))</div><div class="line"></div><div class="line">(defun mapc-retrieve (fn query)</div><div class="line">  &quot;For every fact that matches the query,</div><div class="line">  apply the function to the binding list.&quot;</div><div class="line">  (dolist (bucket (fetch query))</div><div class="line">    (dolist (answer bucket)</div><div class="line">      (let ((bindings (unify query answer)))</div><div class="line">        (unless (eq bindings fail)</div><div class="line">          (funcall fn bindings))))))</div></div><!-- fragment --><p>Есть много способов использовать этот retriever(извлекатель). Функция <code>retrieve</code> возвращает список совпадающих списков привязки, а <code>retrieve-matches</code> заменяет каждый список привязки в исходном запросе, так что результат является списком выражений, которые объединяются с запросом.</p>
<div class="fragment"><div class="line">(defun retrieve (query)</div><div class="line">  &quot;Find all facts that match query.  Return a list of bindings.&quot;</div><div class="line">  (let ((answers nil))</div><div class="line">    (mapc-retrieve #&#39;(lambda (bindings) (push bindings answers))</div><div class="line">                   query)</div><div class="line">    answers))</div><div class="line"></div><div class="line">(defun retrieve-matches (query)</div><div class="line">  &quot;Find all facts that match query.</div><div class="line">  Return a list of expressions that match the query.&quot;</div><div class="line">  (mapcar #&#39;(lambda (bindings) (subst-bindings bindings query))</div><div class="line">          (retrieve query)))</div></div><!-- fragment --><p>Следует учитывать еще одну сложность. Напомним, что в нашем исходном интерпретаторе Пролога функция <code>verify</code> должна была переименовывать переменные в каждом предложении при получении их из базы данных. Это должно было гарантировать отсутствие конфликта между переменными в запросе и переменными в предложении. Мы могли бы сделать это в <code>retrieve</code>. Однако, если мы предположим, что выражения, проиндексированные в деревьях дискриминации, похожи на таблицы, а не на правила и, следовательно, не рекурсивны, тогда мы можем переименовать переменные только один раз, когда они вводятся в базу данных. Это делается путем изменения <code>index</code>:</p>
<div class="fragment"><div class="line">(defun index (key)</div></div><!-- fragment --><p><code>"Store key in a dtree node. Key must be (predicate . args);</code></p>
<div class="fragment"><div class="line">it is stored in the predicate&#39;s dtree.&quot;</div><div class="line">(dtree-index key (rename-variables key) ; store unique vars</div><div class="line">        (get-dtree (predicate key))))</div></div><!-- fragment --><p>С новым <code>index</code> и после вызова <code>test-index</code> для перестройки базы данных мы готовы протестировать механизм извлечения:</p>
<div class="fragment"><div class="line">&gt; (fetch &#39;(p ?x c))</div><div class="line">(((P B C) (P A C))</div><div class="line">  ((P A ?X3408)))</div><div class="line">3</div><div class="line">&gt; (retrieve &#39;(p ?x c))</div><div class="line">(((?X3408 . C) (?X . A))</div><div class="line">  ((?X . A))</div><div class="line">  ((?X . B)))</div><div class="line">&gt; (retrieve-matches &#39;(p ?x c))</div><div class="line">((P A C) (P A C) (P B C))</div><div class="line">&gt; (retrieve-matches &#39;(p ?x (?fn c)))</div><div class="line">((P A (?FN C)) (P A (F C)) (P B (F C)))</div></div><!-- fragment --><p>На самом деле, по возможности лучше использовать <code>mapc-retrieve</code>, поскольку она не требует ответов, как это делают <code>retrieve</code> и <code>retrieve-matches</code>. Макрос <code>query-bind</code> предоставляется как удобный интерфейс для <code>mapc-retrieve</code>. Макрос принимает в качестве аргументов список переменных для связывания, запрос и одну или несколько форм для применения к каждому полученному ответу. В этом списке форм переменные будут привязаны к значениям, удовлетворяющим запросу. Синтаксис был выбран таким же, как у <code>multiple-value-bind</code>. Здесь мы видим типичное использование <code>query-bind</code>, его результат и его макрорасширение:</p>
<div class="fragment"><div class="line">&gt; (query-bind (?x ?fn) &#39;(p ?x (?fn c))</div></div><!-- fragment --><p><code>(format t "~&amp;P holds between ~a and ~a of c." ?x ?fn))</code>=&gt;</p>
<div class="fragment"><div class="line">P holds between B and F of c.</div><div class="line">P holds between A and F of c.</div><div class="line">P holds between A and ?FN of c.</div><div class="line">NIL</div><div class="line">= (mapc-retrieve</div><div class="line">  #&#39;(lambda (#:bindings6369)</div><div class="line">    (let ((?x (subst-bindings #:bindings6369 *?x))</div><div class="line">            (?fn (subst-bindings #:bindings6369 *?fn)))</div><div class="line">      (format t &quot;~&amp;P holds between ~a and ~a of c.&quot; ?x ?fn)))</div><div class="line">  &#39;(p ?x (?fn c)))</div></div><!-- fragment --><p>Вот реализация:</p>
<div class="fragment"><div class="line">(defmacro query-bind (variables query &amp;body body)</div><div class="line">  &quot;Execute the body for each match to the query.</div><div class="line">  Within the body, bind each variable.&quot;</div><div class="line">  (let* ((bindings (gensym &quot;BINDINGS&quot;))</div><div class="line">         (vars-and-vals</div><div class="line">           (mapcar</div><div class="line">             #&#39;(lambda (var)</div><div class="line">                 (list var `(subst-bindings ,bindings &#39;,var)))</div><div class="line">             variables)))</div><div class="line">    `(mapc-retrieve</div><div class="line">       #&#39;(lambda (,bindings)</div><div class="line">           (let ,vars-and-vals</div><div class="line">             ,@body))</div><div class="line">       ,query)))</div></div><!-- fragment --><h2>14.9 Решение проблемы полноты</h2>
<p>Мы видели в <a href="B9780080571157500066.xhtml">главе 6</a>, что итеративное углубление - это эффективный способ охватить пространство поиска без попадания в бесконечный цикл. Итеративное углубление также можно использовать для направления поиска в Прологе. Оно гарантирует, что в конечном итоге будут найдены все верные ответы, но не превратит бесконечное пространство поиска в конечное.</p>
<p>В интерпретаторе итеративное углубление реализуется путем передачи дополнительного аргумента для <code>prove</code> и <code>prove-all</code>, чтобы указать оставшуюся глубину для поиска. Когда этот аргумент равен нулю, поиск прекращается, и доказательство падает. На следующей итерации границы будут увеличены, и доказательство может быть успешным. Если поиск никогда не завершается границами глубины, то нет причин переходить к следующей итерации, потому что все доказательства уже найдены. Специальная переменная <code>*search-cut-off*</code> отслеживает это.</p>
<div class="fragment"><div class="line">(defvar *search-cut-off* nil &quot;Has the search been stopped?&quot;)</div><div class="line"></div><div class="line">(defun prove-all (goals bindings depth)</div><div class="line">  &quot;Find a solution to the conjunction of goals.&quot;</div><div class="line">  ;; This version just passes the depth on to PROVE.</div><div class="line">  (cond ((eq bindings fail) fail)</div><div class="line">        ((null goals) bindings)</div><div class="line">        (t (prove (first goals) bindings (rest goals) depth))))</div><div class="line"></div><div class="line">(defun prove (goal bindings other-goals depth)</div><div class="line">  &quot;Return a list of possible solutions to goal.&quot;</div><div class="line">  ;; Check if the depth bound has been exceeded</div><div class="line">  (if (= depth 0)                            ;***</div><div class="line">      (progn (setf *search-cut-off* t)       ;***</div><div class="line">             fail)                           ;***</div><div class="line">      (let ((clauses (get-clauses (predicate goal))))</div><div class="line">        (if (listp clauses)</div><div class="line">            (some</div><div class="line">              #&#39;(lambda (clause)</div><div class="line">                  (let ((new-clause (rename-variables clause)))</div><div class="line">                    (prove-all</div><div class="line">                      (append (clause-body new-clause) other-goals)</div><div class="line">                      (unify goal (clause-head new-clause) bindings)</div><div class="line">                      (- depth 1))))          ;***</div><div class="line">              clauses)</div><div class="line">            ;; The predicate&#39;s &quot;clauses&quot; can be an atom:</div><div class="line">            ;; a primitive function to call</div><div class="line">            (funcall clauses (rest goal) bindings</div><div class="line">                     other-goals depth)))))   ;***</div></div><!-- fragment --><p><code>prove</code> и <code>prove-all</code> теперь реализуют ограничение поиска, но нам нужно что-то, чтобы контролировать итеративное углубление поиска. Сначала мы определяем параметры для управления итерацией: один для начальной глубины, один для максимальной глубины и один для приращения между итерациями. Установка начального значения и значения приращения в единицу приведет к тому, что результаты будут выводиться в строгом порядке в ширину, но будут дублировать больше усилий, чем немного большее значение.</p>
<div class="fragment"><div class="line">(defparameter *depth-start* 5</div><div class="line">  &quot;The depth of the first round of iterative search.&quot;)</div><div class="line">(defparameter *depth-incr* 5</div><div class="line">  &quot;Increase each iteration of the search by this amount.&quot;)</div><div class="line">(defparameter *depth-max* most-positive-fixnum</div><div class="line">  &quot;The deepest we will ever search.&quot;)</div></div><!-- fragment --><p>Новая версия <code>top-level-prove</code> будет использоваться для управления итерацией. Он вызывает <code>prove-all</code> для всех глубин от начальной до максимальной, увеличиваясь с шагом. Однако он переходит к следующей итерации, только если поиск был прекращен в какой-то момент на предыдущей итерации.</p>
<div class="fragment"><div class="line">(defun top-level-prove (goals)</div><div class="line">  (let ((all-goals</div><div class="line">          `(,@goals (show-prolog-vars ,@(variables-in goals)))))</div><div class="line">    (loop for depth from *depth-start* to *depth-max* by *depth-incr*</div><div class="line">          while (let ((*search-cut-off* nil))</div><div class="line">                  (prove-all all-goals no-bindings depth)</div><div class="line">                  *search-cut-off*)))</div><div class="line">  (format t &quot;~&amp;No.&quot;)</div><div class="line">  (values))</div></div><!-- fragment --><p>Есть еще одно осложнение. Когда мы увеличиваем глубину поиска, мы можем найти новые доказательства s, но мы также найдем все старые доказательства, которые были найдены на предыдущей итерации. Мы можем изменить <code>show-prolog-vars</code>, чтобы печатать только те доказательства, которые были найдены с глубиной меньше, чем приращение, то есть те, которые не были найдены на предыдущей итерации.</p>
<div class="fragment"><div class="line">(defun show-prolog-vars (vars bindings other-goals depth)</div><div class="line">  &quot;Print each variable with its binding.</div><div class="line">  Then ask the user if more solutions are desired.&quot;</div><div class="line">  (if (&gt; depth *depth-incr*)</div><div class="line">      fail</div><div class="line">      (progn</div><div class="line">        (if (null vars)</div><div class="line">            (format t &quot;~&amp;Yes&quot;)</div><div class="line">            (dolist (var vars)</div><div class="line">              (format t &quot;~&amp;~a = ~a&quot; var</div><div class="line">                      (subst-bindings bindings var))))</div><div class="line">        (if (continue-p)</div><div class="line">            fail</div><div class="line">            (prove-all other-goals bindings depth)))))</div></div><!-- fragment --><p>Чтобы проверить, что это работает, попробуйте установить для <code>*depth-max*</code> значение 5 и выполнить следующие утверждения и запросы. Бесконечный цикл избегается, и первые четыре решения найдены.</p>
<div class="fragment"><div class="line">(&lt;- (natural 0))</div><div class="line">(&lt;- (natural (1  + ?n)) (natural ?n))</div><div class="line">&gt; (?- (natural ?n))</div><div class="line">?N = 0;</div><div class="line">?N = (1  + 0);</div><div class="line">?N = (1  + (1  + 0));</div><div class="line">?N = (1  + (1  + (1  + 0)));</div><div class="line">No.</div></div><!-- fragment --><h2>14.10 Решения проблем выразительности</h2>
<p>В этом разделе мы представляем решения трех описанных выше ограничений:</p>
<ul>
<li>Обработка (ограниченных) предсказаний более высокого порядка.</li>
<li>Введение синтаксиса на основе фреймов.</li>
<li>Поддержка возможных миров, отрицания и дизъюнкции.</li>
</ul>
<p>Мы также представляем способ присоединения функций к предикатам для выполнения прямой цепочки и обнаружения ошибок, а также обсуждаем способы расширения унификации для обработки констант Сколема и других проблем.</p>
<h3>Предсказания высшего порядка</h3>
<p>Сначала мы займемся проблемой ответов на вопросы типа "What kinds of animais are there?"(Какие виды животных существуют?). Как это ни парадоксально, ключом к большей выразительности в этом случае является изобретение нового, более ограниченного языка и требование, чтобы все утверждения и запросы делались на этом языке. Таким образом, запросы, которые были бы более высокого порядка на исходном языке, становятся первого порядка на ограниченном языке.</p>
<p>Язык допускает три типа объектов: <em>категории, отношения</em> и <em>индивиды.</em> Категория(category) соответствует одноместному предикату, отношение(relation) к двухместному предикату и индивидуум(individual) константному или нулевому предикату. Выражения на языке должны иметь один из пяти примитивных операторов: <code>sub, rel, ind, val</code> и <code>and</code>. Они имеют следующую форму:</p>
<p><code>(sub</code>*subcategory super category*)</p>
<p><code>(rel</code>*relation domain-category range-category*)</p>
<p><code>(ind</code>*individual category*)</p>
<p><code>(val</code>*relation individual value*)</p>
<p><code>(and</code>*assertion...*)</p>
<p>В следующей таблице приведены некоторые примеры, а также их перевод на английский язык:</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>(sub dog animal)</code> </td><td>Dog is a kind of animal. </td></tr>
<tr>
<td><code>(rel birthday animal date)</code> </td><td>The birthday relation holds between each animal and some date. </td></tr>
<tr>
<td><code>(ind fido dog)</code> </td><td>The individual Fido is categorized as a dog. </td></tr>
<tr>
<td><code>(val birthday fido july-1)</code> </td><td>The birthday of Fido is July-1. </td></tr>
<tr>
<td><code>(and *AB*)</code> </td><td>Both <em>A</em> and <em>B</em> are true. </td></tr>
</table>
<p>Для тех, кто чувствует себя более комфортно с исчислением предикатов, следующая таблица дает формальное определение каждого примитива. Наиболее сложное определение для rel. Форма (rel <em>R A B</em>) означает, что каждое <em>R</em> выполняется между индивидуумом из <em>A</em> и индивидуумом из <em>B</em> и, кроме того, что каждый индивидуум из <em>A</em> участвует по крайней мере в одном отношении <em>R</em>.</p>
<table class="doxtable">
<tr>
<th>[]() </th><th></th></tr>
<tr>
<td><code>(sub</code>*AB*) </td><td>&forall;<em>x:A</em>(<em>x</em>)  <em>B</em>(<em>x</em>) </td></tr>
<tr>
<td><code>(rel</code>*RAB*) </td><td>&forall;<em>x,y</em> : <em>R</em>(<em>x,y</em>)  <em>A</em>(<em>x</em>) A <em>B</em>(<em>y</em>) *^*&forall;<em>xA</em>(<em>x</em>)  &exist;<em>y</em> : <em>R</em>(<em>x, y</em>) </td></tr>
<tr>
<td><code>(ind</code>*IC)* </td><td><em>C</em>(<em>I</em>) </td></tr>
<tr>
<td><code>(val</code>*RIV*) </td><td><em>R</em>(<em>I, V</em>) </td></tr>
<tr>
<td><code>(and</code>*P Q...*) </td><td><em>P ^ Q...</em> </td></tr>
</table>
<p>Неудивительно, что запросы в языке имеют ту же форму, что и утверждения, за исключением того, что они могут содержать переменные, а также константы. Таким образом, чтобы узнать, какие существуют виды животных, используйте запрос <code>(sub ?kind animal)</code>. Чтобы узнать, какие есть отдельные(индивидуальные) животные, используйте запрос <code>(ind ?x animal)</code>. Чтобы узнать, какие существуют отдельные животные, каких видов, используйте:</p>
<div class="fragment"><div class="line">(and (sub ?kind animal) (ind ?x ?kind))</div></div><!-- fragment --><p>Реализация этого нового языка может быть основана непосредственно на предыдущей реализации dtrees. Каждое утверждение хранится как факт в dtree, за исключением того, что компоненты утверждения и хранятся отдельно. Функция <code>add-fact</code> делает следующее:</p>
<div class="fragment"><div class="line">(defun add-fact (fact)</div><div class="line">  &quot;Add the fact to the data base.&quot;</div><div class="line">  (if (eq (predicate fact) &#39;and)</div><div class="line">      (mapc #&#39;add-fact (args fact))</div><div class="line">      (index fact)))</div></div><!-- fragment --><p>Запросы к этой новой базе данных состоят из запросов к dtree, как и раньше, но с особым случаем для конъюнктивных (and/и) запросов. По идее, функция для этого, <code>retrieve-fact</code>, должна быть такой же простой, как следующая:</p>
<div class="fragment"><div class="line">(defun retrieve-fact (query)</div></div><!-- fragment --><p><code>"Find all facts that match query. Return a list of bindings.</code></p>
<p><code>Warning!! this version is incomplete."</code></p>
<div class="fragment"><div class="line">(if (eq (predicate query) &#39;and)</div><div class="line">  (retrieve-conjunction (args query))</div><div class="line">  (retrieve query bindings)))</div></div><!-- fragment --><p>К сожалению, есть некоторые сложности. Подумайте о том, что должно быть сделано в <code>retrieve-conjunction</code>. Ему передается список конъюнктов, и он должен возвращать список списков привязок, где каждый список привязок удовлетворяет запросу. Например, чтобы узнать, какие люди родились 1 июля, мы могли бы использовать запрос:</p>
<div class="fragment"><div class="line">(and (val birthday ?p july-1) (ind ?p person))</div></div><!-- fragment --><p><code>retrieve-conjunction</code> может решить эту проблему, сначала вызвав <code>retrieve-fact</code> на <code>(val birthday ?p july-1)</code>. Как только это будет сделано, останется только один конъюнкт, но в целом их может быть несколько, поэтому нам нужно рекурсивно вызвать <code>retrieve-conjunction</code> с двумя аргументами: оставшиеся конъюнкты и результат, который <code>retrieve-fact</code> дал для первого решения. Так как <code>retrieve-fact</code> возвращает список списков привязки, будет проще, если <code>retrieve-conjunction</code> примет такой список в качестве второго аргумента. Более того, когда придет время вызвать <code>retrieve-fact</code> для второго конъюнкта, мы захотим уважать привязки, установленные первым конъюнктом. Таким образом, <code>retrieve-fact</code> должно принимать список привязки в качестве второго аргумента. Таким образом, мы имеем:</p>
<div class="fragment"><div class="line">(defun retrieve-fact (query &amp;optional (bindings no-bindings))</div><div class="line">  &quot;Find all facts that match query.  Return a list of bindings.&quot;</div><div class="line">  (if (eq (predicate query) &#39;and)</div><div class="line">      (retrieve-conjunction (args query) (list bindings))</div><div class="line">      (retrieve query bindings)))</div><div class="line"></div><div class="line">(defun retrieve-conjunction (conjuncts bindings-lists)</div><div class="line">  &quot;Return a list of binding lists satisfying the conjuncts.&quot;</div><div class="line">  (mapcan</div><div class="line">    #&#39;(lambda (bindings)</div><div class="line">        (cond ((eq bindings fail) nil)</div><div class="line">              ((null conjuncts) (list bindings))</div><div class="line">              (t (retrieve-conjunction</div><div class="line">                   (rest conjuncts)</div><div class="line">                   (retrieve-fact</div><div class="line">                     (subst-bindings bindings (first conjuncts))</div><div class="line">                     bindings)))))</div><div class="line">    bindings-lists))</div></div><!-- fragment --><p>Обратите внимание, что <code>retrieve</code> и, следовательно, <code>mapc-retrieve</code> теперь также должны принимать список привязки. Изменения в них показаны ниже. В каждом случае дополнительный аргумент делается необязательным, так чтобы ранее написанные функции, вызывающие эти функции без передачи дополнительного аргумента, все равно работали.</p>
<div class="fragment"><div class="line">(defun mapc-retrieve (fn query &amp;optional (bindings no-bindings))</div><div class="line">  &quot;For every fact that matches the query,</div><div class="line">  apply the function to the binding list.&quot;</div><div class="line">  (dolist (bucket (fetch query))</div><div class="line">    (dolist (answer bucket)</div><div class="line">      (let ((new-bindings (unify query answer bindings)))</div><div class="line">        (unless (eq new-bindings fail)</div><div class="line">          (funcall fn new-bindings))))))</div><div class="line"></div><div class="line">(defun retrieve (query &amp;optional (bindings no-bindings))</div><div class="line">  &quot;Find all facts that match query.  Return a list of bindings.&quot;</div><div class="line">  (let ((answers nil))</div><div class="line">    (mapc-retrieve #&#39;(lambda (bindings) (push bindings answers))</div><div class="line">                   query bindings)</div><div class="line">    answers))</div></div><!-- fragment --><p>Теперь <code>add-fact</code> и <code>retrieve-fact</code> - это все, что нам нужно для реализации языка. Вот краткий пример, в котором <code>add-fact</code> используется для добавления фактов о медведях(bears) и собаках(dogs), как отдельных индивидумах, так и видах:</p>
<p>`&gt; (add-fact '(sub dog animal))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(sub bear animal))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(ind Fido dog))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(ind Yogi bear))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(val color Yogi brown))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(val color Fido golden))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(val latin-name bear ursidae))<code>=&gt;</code>T`</p>
<p>`&gt; (add-fact '(val latin-name dog canis-familiaris))<code>=&gt;</code>T`</p>
<p>Теперь с помощью<code>retrieve-fact</code> можно ответить на три вопроса: Какие виды животных существуют? Каковы латинские названия каждого вида животных? и Какого цвета каждый медведь?</p>
<div class="fragment"><div class="line">&gt; (retrieve-fact &#39;(sub ?kind animal))</div><div class="line">(((?KIND . DOG))</div><div class="line">((?KIND . BEAR)))</div><div class="line">&gt; (retrieve-fact &#39;(and (sub ?kind animal)</div><div class="line">          (val latin-name ?kind ?latin)))</div><div class="line">(((?LATIN . CANIS-FAMILIARIS) (?KIND . DOG))</div><div class="line">  ((?LATIN . URSIDAE) (?KIND . BEAR)))</div><div class="line">&gt; (retrieve-fact &#39;(and (ind ?x bear) (val color ?x ?c)))</div><div class="line">(((?C . BROWN) (?X . YOGI)))</div></div><!-- fragment --><h3>Улучшения</h3>
<p>В эту систему можно внести несколько улучшений. Одно из направлений - давать разные ответы на вопросы. Следующие две функции похожи на <code>retrieve-matches</code> в том, что они возвращают списки решений, соответствующих запросу, а не списки возможных привязок:</p>
<div class="fragment"><div class="line">(defun retrieve-bagof (query)</div><div class="line">  &quot;Find all facts that match query.</div><div class="line">  Return a list of queries with bindings filled in.&quot;</div><div class="line">  (mapcar #&#39;(lambda (bindings) (subst-bindings bindings query))</div><div class="line">          (retrieve-fact query)))</div><div class="line"></div><div class="line">(defun retrieve-setof (query)</div><div class="line">  &quot;Find all facts that match query.</div><div class="line">  Return a list of unique queries with bindings filled in.&quot;</div><div class="line">  (remove-duplicates (retrieve-bagof query) :test #&#39;equal))</div></div><!-- fragment --><p>Еще одно направление - улучшить проверку ошибок. Текущая система не жалуется, если факт или запрос неправильно сформулированы. Она также полагается на то, что пользователь вводит все факты, даже те, которые могут быть получены автоматически из семантики существующих фактов. Например, семантика <code>sub</code> подразумевает, что если <code>(sub bear animal)</code> и <code>(sub polar-bear bear)</code> истинны, то <code>(sub polar-bear animal)</code> также должно быть истинным. С подобным подтекстом можно справиться двумя способами. Типичный подход Пролога заключается в написании правил, которые выводят дополнительные <code>sub</code> факты путем обратной цепочки. Тогда каждый запрос должен будет проверять, есть ли правила для выполнения. Альтернативой является использование подхода <em>forward-chaining</em>(прямой цепочки), которая кэширует каждый новый <code>sub</code> факт, добавляя его в базу данных. Последний вариант требует больше места для хранения, но поскольку он позволяет избежать повторного вывода одних и тех же фактов снова и снова, он обычно выполняется быстрее.</p>
<p>Следующая версия <code>add-fact</code> выполняет проверку ошибок и автоматически кэширует факты, которые могут быть получены из существующих фактов. Обе эти вещи выполняются набором функций, прикрепленных к примитивным операторам. Это сделано в стиле, управляемом данными, чтобы упростить добавление новых примитивов, если в этом возникнет необходимость.</p>
<p>Функция <code>add-fact</code> проверяет, что каждый аргумент примитивного отношения является неизменяемым атомом, а также вызывает <code>fact-present-p</code>, чтобы проверить, присутствует ли уже факт в базе данных. Если нет, она индексирует факт и вызывает <code>run-attached-fn</code> для дополнительной проверки и кэширования:</p>
<div class="fragment"><div class="line">(defparameter *primitives* &#39;(and sub ind rel val))</div><div class="line">(defun add-fact (fact)</div><div class="line">  &quot;Add the fact to the data base.&quot;</div><div class="line">  (cond ((eq (predicate fact) &#39;and)</div><div class="line">      (mapc #&#39;add-fact (args fact)))</div><div class="line">    ((or (not (every #&#39;atom (args fact)))</div><div class="line">        (some #&#39;variable-p (args fact))</div><div class="line">        (not (member (predicate fact) *primitives*)))</div><div class="line">      (error &quot;Ill-formed fact: ~a&quot; fact))</div><div class="line">    ((not (fact-present-p fact))</div><div class="line">      (index fact)</div><div class="line">      (run-attached-fn fact)))</div><div class="line">  t)</div><div class="line">(defun fact-present-p (fact)</div><div class="line">  &quot;Is this fact present in the data base?&quot;</div><div class="line">  (retrieve fact))</div></div><!-- fragment --><p>Присоединенные функции хранятся в списке свойств оператора под индикатором <code>attached-fn:</code></p>
<div class="fragment"><div class="line">(defun run-attached-fn (fact)</div><div class="line">  &quot;Run the function associated with the predicate of this fact.&quot;</div><div class="line">  (apply (get (predicate fact) &#39;attached-fn) (args fact)))</div><div class="line"></div><div class="line">(defmacro def-attached-fn (pred args &amp;body body)</div><div class="line">  &quot;Define the attached function for a primitive.&quot;</div><div class="line">  `(setf (get &#39;,pred &#39;attached-fn)</div><div class="line">         #&#39;(lambda ,args .,body)))</div></div><!-- fragment --><p>Прилагаемые функции для <code>ind</code> и <code>va</code>l довольно просты. Если мы знаем <code>(sub bear animal)</code>(животное-медведь), тогда, когда утверждается <code>(ind Yogi animal)</code>(инд.медведь-йоги), мы должны также утверждать <code>(ind Yogi animal)</code>(инд.животное-йоги). Точно так же значения в утверждении <code>val</code> должны быть индивидуумами категорий в утверждении отношения <code>rel</code>. То есть, если <code>(rel birthday animal date)</code> является фактом и добавляется <code>(val birthday Lee july-1)</code>, то мы можем заключить <code>(ind Lee animal)</code> и <code>(ind july-1 date)</code>. Следующие функции добавляют соответствующие факты:</p>
<div class="fragment"><div class="line">(def-attached-fn ind (individual category)</div><div class="line">  ;; Cache facts about inherited categories</div><div class="line">  (query-bind (?super) `(sub ,category ?super)</div><div class="line">    (add-fact `(ind ,individual ,?super))))</div><div class="line"></div><div class="line">(def-attached-fn val (relation ind1 ind2)</div><div class="line">  ;; Make sure the individuals are the right kinds</div><div class="line">  (query-bind (?cat1 ?cat2) `(rel ,relation ?cat1 ?cat2)</div><div class="line">    (add-fact `(ind ,ind1 ,?cat1))</div><div class="line">    (add-fact `(ind ,ind2 ,?cat2))))</div></div><!-- fragment --><p>Присоединенная функция для rel просто запускает присоединенную функцию для любого индивидуума данного отношения. Обычно все утверждения <code>rel</code> делаются перед утверждениями <code>ind</code>, так что это не будет иметь никакого эффекта. Но мы хотим быть уверены в том, что база данных остается последовательной, даже если факты утверждаются в необычном порядке.</p>
<div class="fragment"><div class="line">(def-attached-fn rel (relation cat1 cat2)</div><div class="line">  ;; Run attached function for any IND&#39;s of this relation</div><div class="line">  (query-bind (?a ?b) `(ind ,relation ?a ?b)</div><div class="line">    (run-attached-fn `(ind ,relation ,?a ,?b))))</div></div><!-- fragment --><p>Самая сложная присоединенная функция - для <code>sub</code>. Добавление такого факта, как <code>(sub bear animal)</code>(животное-медведь), приводит к следующему:</p>
<ul>
<li>Все суперкатегории <code>animal</code>(животных) (например, <code>living-thing</code>-живые существа) становятся суперкатегориями всех подкатегорий <code>bear</code>-медведей (таких как <code>polar-bear</code>-белый медведь).</li>
<li>Само <code>animal</code>-животное становится суперкатегорией всех подкатегорий <code>bear</code>-медведей.</li>
<li>bear-медведь сам становится подкатегорией всех суперкатегорий <code>animal</code>-животных.</li>
<li>Все особи(individuals) медведя становятся особями(individuals) <code>animal</code>-животного и его суперкатегорий.</li>
</ul>
<p>Следующий код выполняет эти четыре задачи. Он делает это с помощью четырех вызовов <code>index-new-fact</code>, который используется вместо <code>add-fact</code>, потому что нам не нужно запускать присоединенную функцию для новых фактов. Однако нам необходимо убедиться, что мы не индексируем один и тот же факт дважды.</p>
<div class="fragment"><div class="line">(def-attached-fn sub (subcat supercat)</div><div class="line">  ;; Cache SUB facts</div><div class="line">  (query-bind (?super-super) `(sub ,supercat ?super-super)</div><div class="line">    (index-new-fact `(sub ,subcat ,?super-super))</div><div class="line">    (query-bind (?sub-sub) `(sub ?sub-sub ,subcat)</div><div class="line">      (index-new-fact `(sub ,?sub-sub ,?super-super))))</div><div class="line">  (query-bind (?sub-sub) `(sub ?sub-sub ,subcat)</div><div class="line">    (index-new-fact `(sub ,?sub-sub ,supercat)))</div><div class="line">  ;; Cache IND facts</div><div class="line">  (query-bind (?super-super) `(sub ,subcat ?super-super)</div><div class="line">    (query-bind (?sub-sub) `(sub ?sub-sub ,supercat)</div><div class="line">      (query-bind (?ind) `(ind ?ind ,?sub-sub)</div><div class="line">        (index-new-fact `(ind ,?ind ,?super-super))))))</div><div class="line"></div><div class="line">(defun index-new-fact (fact)</div><div class="line">  &quot;Index the fact in the data base unless it is already there.&quot;</div><div class="line">  (unless (fact-present-p fact)</div><div class="line">    (index fact)))</div></div><!-- fragment --><p>Следующая функция проверяет прикрепленные функции. Она показывает, что добавление единственного факта <code>(sub bear animal)</code> - (животное-медведь) в данную базу данных приводит к добавлению 18 новых фактов.</p>
<div class="fragment"><div class="line">(defun test-bears ()</div><div class="line">  (clear-dtrees)</div><div class="line">  (mapc #&#39;add-fact</div><div class="line">      &#39;((sub animal living-thing)</div><div class="line">        (sub living-thing thing) (sub polar-bear bear)</div><div class="line">        (sub grizzly bear) (ind Yogi bear) (ind Lars polar-bear)</div><div class="line">        (ind Helga grizzly)))</div><div class="line">  (trace index)</div><div class="line">  (add-fact &#39;(sub bear animal))</div><div class="line">  (untrace index))</div><div class="line">&gt;(test-bears)</div><div class="line">(1 ENTER INDEX: (SUB BEAR ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB BEAR THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB GRIZZLY THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB POLAR-BEAR THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB BEAR LIVING-THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB GRIZZLY LIVING-THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB POLAR-BEAR LIVING-THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB GRIZZLY ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (SUB POLAR-BEAR ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND LARS LIVING-THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND HELGA LIVING-THING)</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND YOGI LIVING-THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND LARS THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND HELGA THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND YOGI THING))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND LARS ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND HELGA ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(1 ENTER INDEX: (IND YOGI ANIMAL))</div><div class="line">(1 EXIT INDEX: T)</div><div class="line">(INDEX)</div></div><!-- fragment --><h3>Фреймовый язык</h3>
<p>Еще одно направление, которое мы можем выбрать, - это предоставить альтернативный синтаксис, который будет легче читать и писать. Многие языки представления основаны на идее <em>фреймов</em>-frames, и их синтаксис отражает это. Фрейм - это объект со слотами. Мы продолжим использовать ту же базу данных в том же формате, но мы предоставим альтернативный синтаксис, который рассматривает индивидуумов и категории как фреймы, а отношения как слоты.</p>
<p>Вот пример синтаксиса фрейма для индивидуумов, в котором используется оператор a. Обратите внимание, что это более компактно, чем эквивалентная запись с использованием примитивов.</p>
<div class="fragment"><div class="line">(a person (name Joe) (age 27)) =</div><div class="line">(and (ind person1 person)</div><div class="line">  (val name person1 Joe)</div><div class="line">  (val age person1 27))</div></div><!-- fragment --><p>Синтаксис также позволяет отображать вложенные выражения как значения слотов. Обратите внимание, что константа Сколема <code>person1</code> была сгенерирована автоматически; альтернативой является предоставление константы для индивидуума после названия категории. Например, следующее говорит, что Джо - человек 27 лет, лучший друг которого - 28-летний человек по имени Фрэн, и лучший друг - Джо:</p>
<div class="fragment"><div class="line">(a person p1 (name Joe) (age 27)</div><div class="line">  (best-friend (a person (name Fran) (age 28)</div><div class="line">          (best-friend pl)))) =</div><div class="line">(and (ind p1 person) (val name p1 joe) (val age p1 27)</div><div class="line">  (ind person2 person) (val name person2 fran)</div><div class="line">  (val age person2 28) (val best-friend person2 pl)</div><div class="line">  (val best-friend p1 person2))</div></div><!-- fragment --><p>В синтаксисе фрейма для категорий используется оператор <code>each</code>-каждый. Например:</p>
<div class="fragment"><div class="line">(each person (isa animal) (name person-name) (age integer)) =</div><div class="line">(and (sub person animal)</div><div class="line">  (rel name person person-name)</div><div class="line">  (rel age person integer))</div></div><!-- fragment --><p>Синтаксис запросов такой же, как и для утверждений, за исключением того, что вместо констант Сколема используются переменные. Это верно даже тогда, когда константы Сколема генерируются автоматически, как в следующем запросе:</p>
<div class="fragment"><div class="line">(a person (age 27)) = (AND (IND ?3 PERSON) (VAL AGE ?3 27))</div></div><!-- fragment --><p>Для поддержки фреймовой нотации мы определяем макросы <code>a</code> и <code>each</code> для выполнения утверждений и <code>??</code> для выполнения запросов.</p>
<div class="fragment"><div class="line">(defmacro a (&amp;rest args)</div><div class="line">  &quot;Define a new individual and assert facts about it in the data base.&quot;</div><div class="line">  &#39;(add-fact &#39;,(translate-exp (cons &#39;a args))))</div><div class="line">(defmacro each (&amp;rest args)</div><div class="line">  &quot;Define a new category and assert facts about it in the data base.&quot;</div><div class="line">  &#39;(add-fact &#39;,(transiate-exp (cons &#39;each args))))</div></div><!-- fragment --><p><code>(defmacro ?? (&amp;rest queries)</code></p>
<div class="fragment"><div class="line">&quot;Return a list of answers satisfying the query or queries.&quot;</div><div class="line">&#39;(retrieve-setof</div><div class="line">  &#39;.(translate-exp (maybe-add &#39;and (replace-?-vars queries))</div><div class="line">        :query)))</div></div><!-- fragment --><p>Все три этих макроса вызывают <code>translate-exp</code> для преобразования синтаксиса фрейма в примитивный синтаксис (?синтаксис примитивов). Обратите внимание, что выражение <code>a</code> или <code>each</code> вычисляет конъюнкцию примитивных отношений, но оно также вычисляет <em>term</em> - термин, когда он используется как вложенное значение слота. Это можно было бы сделать, возвращая несколько значений, но проще построить <code>transiate-exp</code> как набор локальных функций, которые конструируют факты и помещают их в локальную переменную <code>conjuncts</code>. В конце список <code>conjuncts</code>-конъюнктов возвращается как значение translation-преобразования. Локальные функции <code>transiate-a</code> и <code>transiate-each</code> возвращают атом, который представляет термин, который они преобразуют. Локальная функция <code>translate</code> преобразует/транслирует любые выражения, <code>transiate-siot</code> обрабатывает слот, а <code>collect-fact</code> отвечает за добавление факта в список conjuncts-конъюнктов. Необязательный аргумент <code>query-mode-p</code> сообщает, что делать, если индивидуум не указан в выражении <code>a</code>. Если <code>query-mode-p</code> истинен, индивидуум будет представлен переменной; в противном случае это будет константа Сколема.</p>
<div class="fragment"><div class="line">(defun translate-exp (exp &amp;optional query-mode-p)</div><div class="line">  &quot;Translate exp into a conjunction of the four primitives.&quot;</div><div class="line">  (let ((conjuncts nil))</div><div class="line">    (labels</div><div class="line">      ((collect-fact (&amp;rest terms) (push terms conjuncts))</div><div class="line">        (translate (exp)</div><div class="line">          ;; Figure out what kind of expression this is</div><div class="line">          (cond</div><div class="line">            ((atom exp) exp)</div><div class="line">            ((eq (first exp) &#39;a) (translate-a (rest exp)))</div><div class="line">            ((eq (first exp) &#39;each) (translate-each (rest exp)))</div><div class="line">            (t (apply #&#39;collect-fact exp) exp)))</div><div class="line">        (translate-a (args)</div><div class="line">          ;; translate (A category [ind] (rel filler)*)</div><div class="line">          (let* ((category (pop args))</div><div class="line">              (self (cond ((and args (atom (first args)))</div><div class="line">                  (pop args))</div><div class="line">                (query-mode-p (gentemp &quot;?&quot;))</div><div class="line">                (t (gentemp (string category))))))</div><div class="line">            (collect-fact &#39;ind self category)</div><div class="line">            (dolist (slot args)</div><div class="line">              (translate-slot &#39;val self slot))</div><div class="line">            self))</div><div class="line">        (translate-each (args)</div><div class="line">          ;; translate (EACH category [(isa cat*)] (slot cat)*)</div><div class="line">          (let* ((category (pop args)))</div><div class="line">            (when (eq (predicate (first args)) &#39;isa)</div><div class="line">              (dolist (super (rest (pop args)))</div><div class="line">                (collect-fact &#39;sub category super)))</div><div class="line">            (dolist (slot args)</div><div class="line">              (translate-slot &#39;rel category slot))</div><div class="line">            category))</div><div class="line">        (translate-slot (primitive self slot)</div><div class="line">          ;; translate (relation value) into a REL or SUB</div><div class="line">          (assert (= (length slot) 2))</div><div class="line">          (collect-fact primitive (first slot) self</div><div class="line">                  (translate (second slot)))))</div><div class="line">      ;; Body of translate-exp:</div><div class="line">      (translate exp) ;; Build up the list of conjuncts</div><div class="line">      (maybe-add &#39;and (nreverse conjuncts)))))</div></div><!-- fragment --><p>Вспомогательные функции <code>might-add</code> и <code>replace-?-vars</code> показаны ниже:</p>
<div class="fragment"><div class="line">(defun maybe-add (op exps &amp;optional if-nil)</div><div class="line">  &quot;For example, (maybe-add &#39;and exps t) returns</div><div class="line">  t if exps is nil, (first exps) if there is only one,</div><div class="line">  and (and expl exp2...) if there are several exps.&quot;</div><div class="line">  (cond ((null exps) if-nil)</div><div class="line">    ((length=1 exps) (first exps))</div><div class="line">    (t (cons op exps))))</div><div class="line">(defun length=1 (x)</div><div class="line">  &quot;Is x a list of length 1?&quot;</div><div class="line">  (and (consp x) (null (cdr x))))</div><div class="line">(defun replace-?-vars (exp)</div><div class="line">  &quot;Replace each ? in exp with a temporary var: ?123&quot;</div><div class="line">  (cond ((eq exp &#39;?) (gentemp &quot;?&quot;))</div><div class="line">    ((atom exp) exp)</div><div class="line">    (t (reuse-cons (replace-?-vars (first exp))</div><div class="line">          (replace-?-vars (rest exp))</div><div class="line">          exp))))</div></div><!-- fragment --><h3>Возможные миры: правда, отрицание и разъединение(Disjunction)</h3>
<p>В этом разделе мы обращаемся к четырем проблемам: различение <code>unknown</code>-неизвестного от <code>false</code>-ложного, представление negations-отрицаний, представление disjunctions-дизъюнкций и представление нескольких возможных состояний дел. Оказывается, все четыре проблемы можно решить, введя два новых метода: возможные миры и отрицательные предикаты. Решение не является полностью общим, но его можно использовать в самых разных приложениях.</p>
<p>Есть два основных способа отличить неизвестное от ложного. Первая возможность - сохранить значение истинности - <code>true</code>(истина) или <code>false</code>(ложь) - вместе с каждым proposition(предложением/утверждением). Вторая возможность состоит в том, чтобы включить значение истинности как часть утверждения. На эту тему есть несколько синтаксических вариаций. В следующей таблице показаны возможности утверждений "Jan likes Dean is true"(Ян нравится Дин - это правда) и "Jan likes Ian is false:"(Ян нравится Иан - это ложь):</p>
<table class="doxtable">
<tr>
<th>Approach </th><th>True Prop. </th><th>False Prop.  </th></tr>
<tr>
<td>1) </td><td><code>(likes Jan Dean) -- true</code> </td><td><code>(likes Jan Ian) -- false</code> </td></tr>
<tr>
<td>(2a) </td><td><code>(likes true Jan Dean)</code> </td><td><code>(likes false Jan Ian)</code> </td></tr>
<tr>
<td>(2b) </td><td><code>(likes Jan Dean)</code> </td><td><code>(not (likes Jan Dean))</code> </td></tr>
<tr>
<td>(2c) </td><td><code>(likes Jan Dean)</code> </td><td><code>(~ likes Jan Dean)</code> </td></tr>
</table>
<p>Разница между (1) и (2) проявляется, когда мы хотим сделать запрос. С помощью (1) мы делаем единственный запрос <code>(likes Jan Dean)</code>-(любит Ян Дин) (или, возможно, <code>(likes Jan ?x))</code> - (любит Ян ?x))`, и ответы скажут нам, кого Ян любит, а кого не любит. С помощью (2) мы делаем один запрос, чтобы выяснить, какие отношения likes-симпатии/любви истинны, и другой, чтобы выяснить, какие из них ложны. При любом подходе, если нет ответов, то ответ действительно неизвестен.</p>
<p>Подход (1) лучше подходит для приложений, где большинство запросов имеют форму "Верно это высказывание или ложно?" Но приложения, которые включают правила обратной цепочки, не такие. Типичное правило обратной цепочки гласит: "Сделайте вывод, что X истинно, если Y истинно". Таким образом, большинство запросов будут иметь тип "Верно ли Y?"("Is Y true?") Поэтому предпочтительнее какой-либо вариант подхода (2).</p>
<p>Представление истинного и ложного открывает двери для множества возможных расширений. Во-первых, мы могли бы добавить несколько значений истинности помимо простых "true"-истина и "false"-ложь. Это могут быть символьные значения, такие как "probably-true"/вероятно-истинно или "false-by-default"/ложно-по-умолчанию, или они могут быть числовыми значениями, представляющими вероятности или факторы достоверности.</p>
<p>Во-вторых, мы могли бы ввести идею <em>возможных миров</em>. То есть истинность утверждения может быть неизвестна в текущем мире, но истинна, если мы предполагаем <em>p</em>, и ложно, если мы предполагаем <em>q</em>. В возможных мирах, оно обрабатывается путем вызова текущего мира <em>W</em>, а затем создания нового мира <em>W*1, который похож на *W</em>, за исключением того, что <em>p</em> истинно, а <em>W</em> 2 - просто как <em>W</em>, за исключением того, что <em>q</em> истинно. Рассуждая в разных мирах, мы можем делать прогнозы о будущем, разрешать неоднозначности в отношении текущего состояния и рассуждать по конкретным случаям.</p>
<p>Например, возможные миры позволяют нам решить проблему Мура коммунизм/демократия (<a href="#p466">страница 466</a>). Мы создаем два новых возможных мира: в одном <em>E</em> демократическая, а в другом - коммунистическая. В любом мире легко сделать вывод, что есть демократия рядом с коммунистической страной. Уловка состоит в том, чтобы понять, что два мира образуют раздел, и что, следовательно, утверждение справедливо и в исходном "реальном" мире. Это требует взаимодействия между основанными на Прологе тактическими рассуждениями, происходящими в мире, и основанными на планировании стратегическими рассуждениями, которые решают, какие миры рассматривать.</p>
<p>Мы также могли бы добавить <em>систему поддержания истины * (или TMS-*truth maintenance system</em>), чтобы отслеживать предположения или обоснования, которые приводят к тому, что каждый факт считается истинным. Система поддержания истины может уменьшить необходимость откатываться в поисках глобального решения. Хотя системы поддержания истины являются важной частью программирования ИИ, они не будут рассматриваться в этой книге.</p>
<p>В этом разделе мы расширяем возможность dtree (<a href="#s0045">раздел 14.8</a>) для обработки значений истинности и возможных миров. При таком большом количестве вариантов сложно выбрать дизайн. Мы выберем довольно простую систему, которая по простоте и скорости близка к Prolog, но при необходимости предлагает дополнительные функции. Мы примем подход (2c) к значениям истинности, используя отрицательные предикаты. Например, отрицательный предикат <code>likes</code>-любит, это <code>~likes</code>, что произносится как "не любит".</p>
<p>Мы также обеспечим минимальную поддержку возможных миров. Предположим, что всегда существует текущий мир, <em>W</em> и что есть способ создать альтернативные миры и изменить текущий мир на альтернативный. Утверждения и запросы всегда будут относиться к текущему миру. Каждый факт индексируется содержащимися в нем атомами, как и раньше. Разница в том, что факты также индексируются текущим миром. Чтобы поддержать это, нам нужно изменить понятие нумерованного списка или <code>nlist</code>, чтобы включить нумерованный список ассоциаций, или <code>nalist</code>. Ниже приводится <code>nalist</code>, показывающий шесть фактов, проиндексированных в трех разных мирах: <code>W0, Wl</code> и <code>W2</code>:</p>
<div class="fragment"><div class="line">(6 (W0 #1# #2# #3#) (Wl #4#) (W2 #5# #6#))</div></div><!-- fragment --><p>Процедура выборки останется неизменной, но обработка после выборки должна будет отсортировать nalist-ы, чтобы найти только факты в текущем мире. <code>fetch</code> также мог бы выполнять эту работу, но аргументация состоит в том, что большинство фактов будет проиндексировано в "реальном мире", и только несколько фактов будут существовать в альтернативных, гипотетических мирах. Следовательно, мы должны отложить усилия по сортировке ответов, чтобы исключить эти ответы в неправильном мире - может оказаться, что первого полученного ответа будет достаточно, и тогда было бы напрасной тратой пройти и исключить другие ответы. Следующие изменения в <code>index</code> и <code>dtree-index</code> добавляют поддержку миров:</p>
<div class="fragment"><div class="line">(defvar *world* &#39;W0 &quot;The current world used by index and fetch.&quot;)</div><div class="line">(defun index (key &amp;optional (world *world*))</div></div><!-- fragment --><p><code>"Store key in a dtree node. Key must be (predicate . args);</code></p>
<div class="fragment"><div class="line">  it is stored in the dtree, indexed by the world.&quot;</div><div class="line">  (dtree-index key key world (get-dtree (predicate key))))</div><div class="line">(defun dtree-index (key value world dtree)</div><div class="line">  &quot;Index value under all atoms of key in dtree.&quot;</div><div class="line">  (cond</div><div class="line">    ((consp key)    ; index on both first and rest</div><div class="line">      (dtree-index (first key) value world</div><div class="line">            (or (dtree-first dtree)</div><div class="line">              (setf (dtree-first dtree) (make-dtree))))</div><div class="line">      (dtree-index (rest key) value world</div><div class="line">            (or (dtree-rest dtree)</div><div class="line">              (setf (dtree-rest dtree) (make-dtree)))))</div><div class="line">    ((null key))    ; don&#39;t index on nil</div><div class="line">    ((variable-p key)    ; index a variable</div><div class="line">      (nalist-push world value (dtree-var dtree)))</div></div><!-- fragment --><p><code>(t ;; Make sure there is an nlist for this atom. and add to it</code></p>
<div class="fragment"><div class="line">(nalist-push world value (lookup-atom key dtree)))))</div></div><!-- fragment --><p>Новая функция <code>nalist-push</code> добавляет значение в nalist, либо путем вставки значения в существующий список ключей, либо путем добавления нового списка ключей/значений:</p>
<div class="fragment"><div class="line">(defun nalist-push (key val nalist)</div><div class="line">  &quot;Index val under key in a numbered al ist.&quot;</div><div class="line">  ;; An nalist is of the form (count (key val*)*)</div><div class="line">  ;; Ex: (6 (nums 12 3) (letters a b c))</div><div class="line">  (incf (car nalist))</div><div class="line">  (let ((pair (assoc key (cdr nalist))))</div><div class="line">    (if pair</div><div class="line">      (push val (cdr pair))</div><div class="line">      (push (list key val) (cdr nalist)))))</div></div><!-- fragment --><p>Далее <code>fetch</code> используется в той же базе данных, созданной <code>test-index</code>, проиндексированной в мире <code>W0</code>. На этот раз результат - это список ассоциативных списков миров/значений. Счетчик 3 такой же, как и раньше.</p>
<div class="fragment"><div class="line">&gt;(fetch &#39;(p ?x c))</div><div class="line">(((W0 (P B C) (P A C)))</div><div class="line">  ((W0 (P A ?X))))</div><div class="line">3</div></div><!-- fragment --><p>До сих пор миры представлялись как символы, подразумевая, что разные символы представляют совершенно разные миры. Это не делает миры очень простыми в использовании. Мы хотели бы иметь возможность использовать миры для исследования альтернатив - создания нового гипотетического мира, делать некоторые предположения (утверждая их как факты в гипотетическом мире) и смотреть, что можно извлечь из этого мира. Было бы утомительно копировать все факты из реального мира в каждый гипотетический мир.</p>
<p>Альтернативой является установление иерархии наследования между мирами. Тогда факт считается истинным, если он индексируется в текущем мире или в любом мире, который наследуется от текущего мира.</p>
<p>Для поддержки наследования мы реализуем миры как структуры с полем имени и полем для списка родителей, от которых наследуется мир. Поиск в решетке наследования может оказаться дорогостоящим, поэтому мы будем делать это только один раз, каждый раз, когда пользователь меняет миры, и отмечать все текущие миры, устанавливая или отключая поле <code>current</code>. Вот определение структуры world - мир:</p>
<div class="fragment"><div class="line">(defstruct (world (:print-function print-world))</div><div class="line">  name parents current)</div></div><!-- fragment --><p>Нам понадобится способ перейти от названия мира к его структуре. Предполагая, что имена являются символами, мы можем сохранить структуру в списке свойств имени. Функция <code>get-world</code> получает структуру для имени или создает новую и сохраняет ее. <code>get-world</code> также может передавать мир вместо имени, и в этом случае он просто возвращает мир. Мы также включаем определение исходного мира по умолчанию.</p>
<div class="fragment"><div class="line">(defun get-world (name &amp;optional current (parents (list *world*)))</div><div class="line">  &quot;Look up or create the world with this name.</div><div class="line">  If the world is new, give it the list of parents.&quot;</div><div class="line">  (cond ((world-p name) name) ; ok if it already is a world</div><div class="line">      ((get name &#39;world))</div><div class="line">      (t (setf (get name &#39;world)</div><div class="line">          (make-world :name name :parents parents</div><div class="line">            :current current)))))</div><div class="line">(defvar *world* (get-world &#39;W0 nil nil)</div><div class="line">  &quot;The current world used by index and fetch.&quot;)</div></div><!-- fragment --><p>Функция <code>use-world</code> используется для переключения в новый мир. Сначала она делает текущий мир и всех его родителей устаревшими, а затем делает новый выбранный мир и всех его родителей текущими. Функция <code>use-new-world</code> более эффективна в общем случае, когда вы хотите создать новый мир, унаследованный от текущего мира. Она не должна выключать какие-либо миры; она просто создает новый мир и делает его актуальным.</p>
<div class="fragment"><div class="line">(defun use-world (world)</div><div class="line">  &quot;Make this world current.&quot;</div><div class="line">  ;; If passed a name, look up the world it names</div><div class="line">  (setf world (get-world world))</div><div class="line">  (unless (eq world *world*)</div><div class="line">    ;; Turn the old world(s) off and the new one(s) on,</div><div class="line">    ;; unless we are already using the new world</div><div class="line">    (set-world-current *world* nil)</div><div class="line">    (set-world-current world t)</div><div class="line">    (setf *world* world)))</div><div class="line">(defun use-new-world ()</div><div class="line">  &quot;Make up a new world and use it.</div><div class="line">  The world inherits from the current world.&quot;</div><div class="line">  (setf *wor1d* (get-world (gensym &quot;W&quot;)))</div><div class="line">  (setf (world-current *world*) t)</div><div class="line">  *world*)</div><div class="line">(defun set-world-current (world on/off)</div><div class="line">  &quot;Set the current field of world and its parents on or off.&quot;</div><div class="line">  ;; nil is off, anything else is on.</div><div class="line">  (setf (world-current world) on/off)</div><div class="line">  (dolist (parent (world-parents world))</div><div class="line">    (set-world-current parent on/off)))</div></div><!-- fragment --><p>Мы также добавляем функцию печати для миров, которая просто печатает название мира.</p>
<div class="fragment"><div class="line">(defun print-world (world &amp;optional (stream t) depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (prin1 (world-name world) stream))</div></div><!-- fragment --><p>Формат базы данных dtree был изменен и теперь включает миры, поэтому нам нужны новые функции поиска, для поиска в этом новом формате. Здесь функции <code>mapc-retrieve, retrieve</code> и <code>retrieve-bagof</code> изменены, чтобы дать новые версии, которые обрабатывают миры. Чтобы отразить это изменение, все новые функции имеют имена, заканчивающиеся на -<code>in-world</code>:</p>
<div class="fragment"><div class="line">(defun mapc-retrieve-in-world (fn query)</div><div class="line">  &quot;For every fact in the current world that matches the query,</div><div class="line">  apply the function to the binding list.&quot;</div><div class="line">  (dolist (bucket (fetch query))</div><div class="line">    (dolist (world/entries bucket)</div><div class="line">      (when (world-current (first world/entries))</div><div class="line">        (dolist (answer (rest world/entries))</div><div class="line">          (let ((bindings (unify query answer)))</div><div class="line">            (unless (eq bindings fall)</div><div class="line">              (funcall fn bindings))))))))</div><div class="line">(defun retrieve-in-world (query)</div></div><!-- fragment --><p><code>"Найти все факты, соответствующие запросу.
Вернуть список привязок."</code></p>
<div class="fragment"><div class="line">  (let ((answers nil))</div><div class="line">    (mapc-retrieve-in-world</div><div class="line">      #&#39;(lambda (bindings) (push bindings answers))</div><div class="line">      query)</div><div class="line">    answers))</div><div class="line">(defun retrieve-bagof-in-world (query)</div><div class="line">  &quot;Find all facts in the current world that match query.</div><div class="line">  Return a list of queries with bindings filled in.&quot;</div><div class="line">  (mapcar #&#39;(lambda (bindings) (subst-bindings bindings query))</div><div class="line">          (retrieve-in-world query)))</div></div><!-- fragment --><p>Теперь посмотрим, как работают эти миры. Во-первых, в <code>W0</code> мы видим, что факты из <code>test-index</code> все еще находятся в базе данных:</p>
<div class="fragment"><div class="line">&gt; *world* =&gt; W0</div></div><!-- fragment --><p>`&gt; (retrieve-bagof-in-world '(p ?z c))`=&gt;</p>
<div class="fragment"><div class="line">((P A C) (P A C) (P B C))</div></div><!-- fragment --><p>Теперь мы создаем и используем новый мир, унаследованный от <code>W0</code>. В этот новый мир добавлены два новых факта:</p>
<p><code>&gt; (use-new-world)</code>=&gt; <code>W7031</code></p>
<p>`&gt; (index '(p new c))<code>=&gt;</code>T`</p>
<p>`&gt; (index '(~p b b))<code>=&gt;</code>T`</p>
<p>Мы видим, что в этом мире доступны два новых факта:</p>
<p>`&gt; (retrieve-bagof-in-world '(p ?z c))`=&gt;</p>
<div class="fragment"><div class="line">((P A C) (P A C) (P B C) (P NEW C))</div></div><!-- fragment --><p>`&gt; (retrieve-bagof-in-world '(~p ?x ?y))`=&gt;</p>
<div class="fragment"><div class="line">((~P B B))</div></div><!-- fragment --><p>Теперь мы создаем другой мир как альтернативу текущему, сначала переключаясь обратно на исходный <code>W0</code>, затем создавая новый мир, а затем добавляя некоторые факты:</p>
<p><code>&gt; (use-world 'W0)</code>=&gt; <code>W0</code></p>
<p><code>&gt; (use-new-world)</code>=&gt; <code>W7173</code></p>
<p>`&gt; (index '(p newest c))<code>=&gt;</code>T`</p>
<p>`&gt; (index '(~p c newest))<code>=&gt;</code>T`</p>
<p>Здесь мы видим, что факты, введенные в <code>W7031</code>, недоступны, но факты в новом мире и в <code>W0</code> следующие:</p>
<p>`&gt; (retrieve-bagof-in-world '(p ?z c))`=&gt;</p>
<div class="fragment"><div class="line">((P A C) (P A C) (P B C) (P NEWEST C))</div></div><!-- fragment --><p>`&gt; (retrieve-bagof-in-world '(~p ?x ?y))`=&gt;</p>
<div class="fragment"><div class="line">((~P C NEWEST))</div></div><!-- fragment --><h3>Унификация(Объединение), равенство, типы и константы Сколема</h3>
<p>Урок головоломки "Зебра" в <a href="B978008057115750011X.xhtml#s0040">раздел 11.4</a> заключался в том, что унификацию можно использовать для уменьшения потребности в обратном отслеживании(backtracking), потому что неустановленная логическая переменная или частично конкретизированный термин может означать целый ряд возможных решений. Однако это преимущество может быстро исчезнуть, когда представление заставляет решателя проблемы перечислять возможные решения, а не рассматривать весь диапазон решений как одно. Например, рассмотрим следующий запрос на языке фреймов и его расширение на примитивы:</p>
<div class="fragment"><div class="line">(a person (name Fran))</div><div class="line">= (and (ind ?p person) (val name ?p fran))</div></div><!-- fragment --><p>Чтобы ответить на этот запрос, нужно перечислить всех индивидов <code>?p</code> типа <code>person</code>, а затем проверить слот <code>name</code> каждого такого человека. Было бы более эффективно, если бы <code>(ind ?p person)</code> действовал не как перечисление, а как ограничение на возможные значения <code>?p</code>. Это было бы возможно, если бы мы изменили определение переменных (и функции объединения) так, чтобы каждая переменная имела связанный с ней тип. Фактически, есть по крайней мере три источника информации, которые были реализованы как ограничения на термины переменных:</p>
<ul>
<li>Тип или категория термина.</li>
<li>Состав или размер термина, рассматриваемого как набор или список</li>
<li>В остальном этот срок равен или не равен.</li>
</ul>
<p>Обратите внимание, что при хорошем решении проблемы равенства мы можем решить проблему констант Сколема. Идея состоит в том, что обычная константа объединяется сама с собой, но не другой регулярной константой. С другой стороны, константа Сколема потенциально может объединяться с любой другой константой (обычной или Сколемской). Механизм равенства используется для отслеживания возможных привязок каждой переменной Сколема.</p>
<h2>14.11 История и Ссылки</h2>
<p><a href="B9780080571157500285.xhtml#bb0115">Brachman and Levesque (1985)</a> collect thirty of the key papers in knowledge representation. Included are some early approaches to semantic network based (<a href="B9780080571157500285.xhtml#bb0965">Quillian 1967</a>) and logic-based (<a href="B9780080571157500285.xhtml#bb0805">McCarthy 1968</a>) representation. Two thoughtful critiques of the ad hoc use of representations without defining their meaning are by <a href="B9780080571157500285.xhtml#bb1430">Woods (1975)</a> and <a href="B9780080571157500285.xhtml#bb0820">McDermott (1978)</a>. It is interesting to contrast the latter with <a href="B9780080571157500285.xhtml#bb0825">McDermott 1987</a>, which argues that logic by itself is not sufficient to solve the problems of AI. This argument should not be surprising to those who remember the slogan <em>logic = algorithm - control.</em></p>
<p><a href="B9780080571157500285.xhtml#bb0455">Genesereth and Nilsson's textbook (1987)</a> cover the predicate-calculus-based approach to knowledge representation and AI in general. <a href="B9780080571157500285.xhtml#bb0275">Ernest Davis (1990)</a> presents a good overview of the field that includes specialized representations for time, space, qualitative physics, propositional attitudes, and the interaction between agents.</p>
<p>Many representation languages focus on the problem of defining descriptions for categories of objects. These have come to be known as <em>term-subsumption languages.</em> Examples include KL-ONE (<a href="B9780080571157500285.xhtml#bb1060">Schmolze and Lipkis 1983</a>) and KRYPTON (<a href="B9780080571157500285.xhtml#bb0120">Brachman, Fikes, and Levesque 1983</a>). See <a href="B9780080571157500285.xhtml#bb0685">Lakoff 1987</a> for much more on the problem of categories and prototypes.</p>
<p>Hector <a href="B9780080571157500285.xhtml#bb0720">Levesque (1986)</a> points out that the areas Prolog has difficulty with-disjunction, negation, and existentials-all involve a degree of vagueness. In his term, they lack <em>vividness.</em> A vivid proposition is one that could be represented directly in a picture: the car is blue; she has a martini in her left hand; Albany is the capital of New York. Nonvivid propositions cannot be so represented: the car is not blue; she has a martini in one hand; either Albany or New York City is the capital of New York. There is interest in separating vivid from nonvivid reasoning, but no current systems are actually built this way.</p>
<p>The possible world approach of <a href="#s0055">section 14.10</a> was used in the MRS system (<a href="B9780080571157500285.xhtml#bb1020">Russell 1985</a>). More recent knowledge representation systems tend to use truth maintenance systems instead of possible worlds. This approach was pioneered by <a href="B9780080571157500285.xhtml#bb0340">Doyle (1979)</a> and <a href="B9780080571157500285.xhtml#bb0785">McAllester (1982)</a>. Doyle tried to change the name to "reason maintenance,' in (1983), but it was too late. The version in widest used today is the assumption-based truth maintenance system, or ATMS, developed by de Kleer (1986a,b,c). <a href="B9780080571157500285.xhtml#bb0180">Charniak et al. (1987)</a> present a complete Common Lisp implementation of a McAllester-styleTMS.</p>
<p>There is little communication between the logic programming and knowledge representation communities, even though they cover overlapping territory. <a href="B9780080571157500285.xhtml#bb0250">Colmerauer (1990)</a> and <a href="B9780080571157500285.xhtml#bb0230">Cohen (1990)</a> describe Logic Programming languages that address some of the issues covered in this chapter. Key papers in equality reasoning include Galler and Fisher 1974, <a href="B9780080571157500285.xhtml#bb0645">Kornfeld 1983</a>,<a href="#fn0015">1</a> Jaffar, Lassez, and Maher 1984, and <a href="B9780080571157500285.xhtml#bb1265">van Emden and Yukawa 1987</a>. <a href="B9780080571157500285.xhtml#bb0550">H&ouml;lldobler's book (1987)</a> includes an overview of the area. Papers on extending unification in ways other than equality include <a href="B9780080571157500285.xhtml#bb0025">A&iuml;t-Kaci et al. 1987</a> and <a href="B9780080571157500285.xhtml#bb1125">Staples and Robinson 1988</a>. Finally, papers on extending Prolog to cover disjunction and negation (i.e., non-Horn clauses) include <a href="B9780080571157500285.xhtml#bb0755">Loveland 1987</a>, <a href="B9780080571157500285.xhtml#bb0960">Plaisted 1988</a>, and <a href="B9780080571157500285.xhtml#bb1200">Stickel 1988</a>.</p>
<h2>14.12 Упражнения</h2>
<p><b>Exercise 14.1 [m]</b> Arrange to store dtrees in a hash table rather than on the property list of predicates.</p>
<p><b>Exercise 14.2 [m]</b> Arrange to store the <code>dtree-atoms</code> in a hash table rather than in an association list.</p>
<p><b>Exercise 14.3 [m]</b> Change the <code>dtree</code> code so that <code>nil</code> is used as an atom index. Time the performance on an application and see if the change helps or hurts.</p>
<p><b>Exercise 14.4 [m]</b> Consider the query <code>(p a b c d e f g)</code>. If the index under a returns only one or two keys, then it is probably a waste of time for <code>dtree-fetch</code> to consider the other keys in the hope of finding a smaller bucket. It is certainly a waste if there are no keys at all indexed under <code>a</code>. Make appropriate changes to <code>dtree-fetch</code>.</p>
<p><b>Exercise 14.5 [h]</b> Arrange to delete elements from a <code>dtree</code>.</p>
<p><b>Exercise 14.6 [h]</b> Implement iterative-deepening search in the Prolog compiler. You will have to change each function to accept the depth as an extra argument, and compile in checks for reaching the maximum depth.</p>
<p><b>Exercise 14.7 [d]</b> Integrate the Prolog compiler with the dtree data base. Use the dtrees for predicates with a large number of clauses, and make sure that each predicate that is implemented as a dtree has a Prolog primitive accessing the dtree.</p>
<p><b>Exercise 14.8 [d]</b> Add support for possible worlds to the Prolog compiler with dtrees. This support has already been provided for dtrees, but you will have to provide it for ordinary Prolog rules.</p>
<p><b>Exercise 14.9 [h]</b> Integrate the language described in <a href="#s0055">section 14.10</a> and the frame syntax from <a href="#s0055">section 14.10</a> with the extended Prolog compiler from the previous exercise.</p>
<p><b>Exercise 14.10 [d]</b> Build a strategie reasoner that decides when to create a possible world and does reasoning by cases over these worlds. Use it to solve Moore 's problem (<a href="#p466">page 466</a>).</p>
<h2>14.13 Ответы</h2>
<p><b>Answer 14.1</b></p>
<div class="fragment"><div class="line">(let ((dtrees (make-hash-table :test #&#39;eq)))</div><div class="line">  (defun get-dtree (predicate)</div><div class="line">    &quot;Fetch (or make) the dtree for this predicate.&quot;</div><div class="line">    (setf (gethash predicate dtrees)</div><div class="line">        (or (gethash predicate dtrees)</div><div class="line">          (make-dtree))))</div><div class="line">  (defun clear-dtrees ()</div><div class="line">  &quot;Remove all the dtrees for all the predicates.&quot;</div><div class="line">  (clrhash dtrees)))</div></div><!-- fragment --><p><b>Answer 14.5</b> Hint: here is the code for <code>nlist-delete</code>. Now figure out how to find all the nlists that an item is indexed under.</p>
<div class="fragment"><div class="line">(defun nlist-delete (item nlist)</div><div class="line">  &quot;Remove an element from an nlist.</div><div class="line">  Assumes that item is present exactly once.&quot;</div><div class="line">  (decf (car nlist))</div><div class="line">  (setf (cdr nlist) (delete item (cdr nlist) :count 1))</div><div class="line">  nlist)</div></div><!-- fragment --> <hr/>
<p><a href="#xfn0015">1</a> A commentary on this paper appears in <a href="B9780080571157500285.xhtml#bb0360">Elcock and Hoddinott 1986</a>. !!!(p) {:.ftnote1}</p>
<p>Part IV Advanced AI Programs !!!(p) {:.parttitle} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
