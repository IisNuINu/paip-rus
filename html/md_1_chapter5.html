<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 5 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Элиза: Диалог с машиной</h2>
<blockquote class="doxtable">
<p><em>Говорят, что объяснять - значит оправдываться.</em> </p>
</blockquote>
<blockquote class="doxtable">
<p>-Joseph Weizenbaum </p>
</blockquote>
<blockquote class="doxtable">
<p>MIT computer scientist </p>
</blockquote>
<p>В этой главе и в остатках части I рассмотриваются еще три хорошо известные программы искусственного интеллекта 1960-х годов. ELIZA провела беседу с пользователем, в которой она имитировала психотерапевта. STUDENT решал словесные задачи, подобные тем, что встречаются в школьных учебниках алгебры, а MACSYMA решала множество символических математических задач, включая дифференциальное и интегральное исчисление. Мы разработаем версии первых двух программ, которые дублируют большинство основных функций, но для третьей мы будем реализовывать только крошечную часть возможностей исходной программы.</p>
<p>Все три программы интенсивно используют технику, называемую сопоставлением образцов. Часть I служит для того, чтобы показать универсальность, а также ограничения - этой техники.</p>
<p>Из трех программ первые две обрабатывают входные данные на простом английском языке, и последние две решают нетривиальные задачи в математике, поэтому есть некоторые основания для описания их как "интеллектуальных"."
С другой стороны, мы увидим, что этот интеллект в значительной степени является иллюзией, и что Элиза, в частности, была на самом деле предназначена для демонстрации этой иллюзии, а не для того, чтобы быть "серьезной" программой ИИ.</p>
<p>ELIZA была одной из первых программ, в которой был возможен ввод и вывод на английском языке. Программа была названа в честь героини <em>Пигмалиона</em>, которую научил говорить по-английски преданный своему делу учитель. Главный разработчик ELIZA, профессор Массачусетского технологического института Джозеф Вайценбаум, опубликовал статью об ELIZA в январском выпуске журнала <em>Communications of the Association for Computing Machinery</em> за 1966 год. Введение к этой статье полностью воспроизводится здесь:</p>
<blockquote class="doxtable">
<p><em>Говорят, что объяснять - значит растолковывать начиная из далека. </em></p>
</blockquote>
<p>Эта максима нигде не выполняется так хорошо, как в области компьютерного программирования, особенно в том, что называется эвристическим программированием и искусственным интеллектом. Ибо в этих сферах машины заставляют вести себя чудесными способами, часто достаточными, чтобы ослепить даже самого опытного наблюдателя. Но как только конкретная программа разоблачается, когда ее внутренняя работа объясняется на языке, достаточно ясном, чтобы вызвать понимание, ее магия рассыпается; он предстает как простой набор процедур, каждая из которых вполне понятна. Наблюдатель говорит себе: «Я мог бы написать это». С этой мыслью он перемещает рассматриваемую программу с полки, помеченной как «интеллектуальная», на полку, предназначенную для антикварных вещей, подходящую для обсуждения только с людьми менее просвещенными, чем он.</p>
<p><em></p><blockquote class="doxtable">
<p>*Цель этой статьи - вызвать именно такую переоценку программы, которая вот-вот будет "объяснена". Немногие программы когда-либо нуждались в этом больше. * </p>
</blockquote>
<p></em></p>
<p><em>Позвольте мне мимоходом заметить, что главная цель этой книги-заставить читателя сказать себе: "я мог бы написать это". Есть надежда, что в некоторых случаях это произойдет потому, что читатель что-то приобрел, а не только потому, что программы, о которых идет речь, потеряли свою способность ослеплять.</em></p>
<p><em>Давайте начнем наше исследование ELIZA с примера диалога из статьи Вейценбаума. ELIZA была создана для того, чтобы обучаться с помощью различных сценариев или моделей взаимодействия. На самом деле там было несколько сценариев, в том числе на немецком и валлийском языках. Но единственный сценарий, который в какой-то степени использовался, был на английском, и это заставило ELIZA подражать психоаналитику Роджера(какое то направление в психиатрии). Роджерианцы "недирективны" -они пытаются позволить пациенту раскрыть себя. Элизе легко следовать этому сценарию, потому что она предполагает пассивность и реакцию, а не добровольное предоставление новой информации. В следующем списке ввод данных Пользователя осуществляется в смешанном регистре, а ответ Элизы-заглавными буквами:</em></p>
<p><em></p><div class="fragment"><div class="line">Men are all alike.</div><div class="line">IN WHAT WAY</div><div class="line">They&#39;re always bugging us about something or another.</div><div class="line">CAN YOU BE MORE SPECIFIC</div><div class="line">Well, my boyfriend made me come here.</div><div class="line">YOUR BOYFRIEND MADE YOU COME HERE</div><div class="line">He says I&#39;m depressed much of the time.</div><div class="line">I AM SORRY TO HEAR YOU ARE DEPRESSED</div><div class="line">It&#39;s true. I am unhappy.</div><div class="line">DO YOU THINK COMING HERE WILL HELP YOU NOT TO BE UNHAPPY</div><div class="line">I need some help, that much seems certain.</div><div class="line">WHAT WOULD IT MEAN TO YOU IF YOU GOT SOME HELP</div><div class="line">Perhaps I could learn to get along with my mother.</div><div class="line">TELL ME MORE ABOUT YOUR FAMILY</div></div><!-- fragment --><p></em></p>
<p><em>Это кажется весьма впечатляющим; программа разумно реагирует на различные входные данные и, похоже, демонстрирует истинное «понимание». Но, как объясняет Вайценбаум, эта видимость является иллюзией, и программа решила сложную задачу понимания, тщательно распознавая, преобразовывая и повторяя части входных данных. Процедура заключается в поиске определенных шаблонов(образцов) на основе ключевого слова или слов во входных данных. Например, всякий раз, когда программа видит слова "alike"(похожий) или "same"(такой же), она печатает сообщение с вопросом о сходстве, в данном случае "`IN WHAT WAY.`"(каким образом). Другие шаблоны более сложны. В предпоследнем обмене ELIZA сначала выбрасывает все, что стоит после запятой, а затем использует шаблон, который ищет ввод в форме "I need X"(Мне нужен X) и преобразует его в вывод "What would it mean to you if you got X"(Что бы это значило для вас, если бы вы получили X), где X - фраза "some help"(некоторая помощь), в данном случае. Большое преимущество этого подхода заключается в том, что ответ будет иметь смысл для различных входов: "I need a vacation"(мне нужен отпуск) будет вызывать "What would it mean to you if you got a vacation."(что бы это значило для вас, если бы вы получили отпуск). Это будет работать автоматически, без необходимости сообщать программе разницу между "some help"(некоторой помощью) и "a vacation."(отпуском). Недостатком является то, что программа иногда будет делать глупые ответы: "I need this like a hole in the head"(мне это нужно, как дырка в голове), - вызовет ответ: "What would it mean to you if you got this like a hole in the head"(что бы это значило для вас, если бы вы получили это, как дырку в голове). На самом деле, программа имеет смысл только в том случае, если она получает информацию от кого-то, кто имеет смысл - и кто-то, кто благосклонно интерпретирует ее ответы. Когда ей говорили: "I need gibble plix zzq"(мне нужен гиббл пликс ЗЗК), Элиза отвечала: "What would it mean to you if you got gibble plix zzq"(что бы это значило для тебя, если бы ты получил гиббл пликс ЗЗК), не подозревая, что что-то не так. Другой пример оригинальной программы ELIZA состоит в том, что она взаимодействует с другой программой, PARRY, которая была написана доктором Кеннетом Колби для имитации параноидального поведения. Далее следует часть разговора, с Элизой снова заглавными буквами и PARRY в смешанном регистре:</em></p>
<p><em></p><div class="fragment"><div class="line">I don&#39;t understand your motives.</div><div class="line">WHY DON&#39;T YOU UNDERSTAND MY MOTIVES?</div><div class="line">Shouldn&#39;t I be?</div><div class="line">WHY DO YOU SAY THAT JUST NOW?</div><div class="line">That&#39;s just the way it is.</div><div class="line">SUPPOSE THAT&#39;S JUST THE WAY IT WERE NOT.</div><div class="line">So?</div><div class="line">I AM NOT SURE I UNDERSTAND YOU FULLY.</div><div class="line">You harp on the same questions too much.</div><div class="line">WHAT DOES THAT SIMILARITY SUGGEST TO YOU?</div><div class="line">I don&#39;t get you.</div><div class="line">DO YOU WISH THAT YOU DID GET I?</div></div><!-- fragment --><p></em></p>
<p><em>Это говорит о том, что ни ELIZA, ни PARRY не имели глубокого понимания диалога. Когда человек берет на себя большую часть бремени ведения разговора, эти программы могут быть убедительными, но когда человека выводят из разговора, обнаруживаются слабые места программ.</em></p>
<p><em></p><h2>5.1 Описание и Спецификация Элизы(ELIZA)</h2>
<p></em></p>
<p><em> Теперь, когда у нас есть представление о том, на что похожа ELIZA, мы можем начать описание и спецификацию программы и, в конечном итоге, перейти к реализации и отладке.</em></p>
<p><em>Алгоритм ELIZA можно описать просто как: (1) прочитать ввод, (2) найти образец, который соответствует вводу, (3) преобразовать ввод в ответ и (4) распечатать ответ. Эти четыре шага повторяются для каждого ввода.</em></p>
<p><em>Спецификация и реализация шагов (1) и (4) тривиальны: для (1) используйте встроенную функцию <code>read</code>, чтобы прочитать список слов, и для (4) используйте <code>print</code>, чтобы распечатать список слов в ответе.</em></p>
<p><em>Конечно, у этой спецификации есть некоторые недостатки. Пользователь должен будет ввести реальный список, используя круглые скобки, и пользователь не может использовать символы, специальные для <code>read</code>, такие как кавычки, запятые и точки. Так что наш ввод не будет таким неограниченным, как в примере диалога, но это небольшая плата за удобство аккуратного решения половины проблемы.</em></p>
<p><em></p><h2>5.2 Сопоставление с образцом</h2>
<p></em></p>
<p><em> Самая сложная часть состоит в шагах (2) и (3) - это идея сопоставления с образцом и преобразования. Есть четыре вещи, о которых нужно позаботиться: общие образец и ответ, а также конкретные ввод и преобразование этого ввода. Поскольку мы согласились представить входные данные в виде списка, имеет смысл, чтобы и другие компоненты тоже были списками. Например, у нас может быть:</em></p>
<p><em></p><div class="fragment"><div class="line">Образец: (i need a X)</div><div class="line">Ответ: (what would it mean to you if you got a X ?)</div><div class="line"></div><div class="line">Ввод: (i need a vacation)</div><div class="line">Преобразование: (what would it mean to you if you got a vacation ?)</div></div><!-- fragment --><p></em></p>
<p><em>Средство сопоставления с образцом должно сопоставить литералы <code>i</code> с <code>i</code>, <code>need</code> с <code>need</code> и <code>a</code> с <code>a</code>, а также сопоставить переменную <code>X</code> с <code>vacation</code>. Это предполагает, что есть способ узнать, что <code>X</code> является переменной, а <code>need</code> - нет. Затем мы должны заменить в ответе для <code>X</code> на <code>vacation</code>, чтобы получить окончательное преобразование.</em></p>
<p><em>Игнорируя на мгновение проблему преобразования шаблона в ответ, мы можем увидеть, что это понятие сопоставления с образцом является просто обобщением функции Лиспа <code>equal</code>. Ниже мы показываем функцию <code>simple-equal</code>, которая похожа на встроенную функцию <code>equal</code>, <sup><a href="#chapter5-fn1">1</a></sup> и функцию <code>pat-match</code>, которая является её расширением для обработки переменных сопоставления с образцом:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun simple-equal (x y)</div><div class="line">   &quot;Are x and y equal?  (Don&#39;t check inside strings.)&quot;</div><div class="line">   (if (or (atom x) (atom y))</div><div class="line">       (eql x y)</div><div class="line">       (and (simple-equal (first x) (first y))</div><div class="line">        (simple-equal (rest x) (rest y)))))</div><div class="line"></div><div class="line">(defun pat-match (pattern input)</div><div class="line">  &quot;Does pattern match input? Any variable can match anything.&quot;</div><div class="line">  (if (variable-p pattern)</div><div class="line">      t</div><div class="line">      (if (or (atom pattern) (atom input))</div><div class="line">      (eql pattern input)</div><div class="line">          (and (pat-match (first pattern) (first input))</div><div class="line">           (pat-match (rest pattern) (rest input))))))</div></div><!-- fragment --><p></em></p>
<p><em>&amp;#9635; <b>Exercise 5.1 [s]</b> Было бы неплохо заменить complex и form в <code>pat-match</code> на более простую <code>(every #'pat-match pattern input)?</code></em></p>
<p><em>Прежде чем мы продолжим, нам нужно определиться с реализацией для переменных сопоставления с образцом. Мы могли бы, например, сказать, что только определенный набор символов, таких как {X, Y, Z}, является переменными. В качестве альтернативы мы могли бы определить структуру типа <code>variable</code>, но тогда нам пришлось бы вводить что-то подробное, например <code>(make-variable :name 'X )</code>, каждый раз, когда нам это нужно. Другой вариант - использовать символы, но отличать переменные от констант по имени символа. Например, в Прологе переменные начинаются с заглавных букв, а константы - со строчных. Но Common Lisp нечувствителен к регистру, так что это не сработает. Вместо этого в программах ИИ на основе Лиспа существует традиция, когда переменные представляют собой символы, начинающиеся с знака вопроса.</em></p>
<p><em>До сих пор мы рассматривали символы как атомы - т.е. объекты без внутренней структуры. Но все всегда сложнее, чем кажется на первый взгляд, оказывается в Лиспе, как и в физике, даже атомы имеют компоненты. В частности, символы имеют имена, которые являются строками и доступны через функцию <code>symbol-name</code>. Строки, в свою очередь, имеют элементы, которые являются символьными знаками, доступными через функцию <code>char</code>. Символьный знак '?' обозначается самовычисляемой escape-последовательностью <code>#\?</code>. Итак, предикат <code>variable-p</code> может быть определен следующим образом, и теперь у нас есть полный сопоставитель с образцом:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun variable-p (x)</div><div class="line">  &quot;Is X a variable (a symbol beginning with &#39;?&#39;)?&quot;</div><div class="line">  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))</div><div class="line"></div><div class="line">&gt; (pat-match &#39;(I need a ?X) &#39;(I need a vacation))</div><div class="line">T</div><div class="line"></div><div class="line">&gt; (pat-match &#39;(I need a ?X) &#39; (I really need a vacation))</div><div class="line">NIL</div></div><!-- fragment --><p></em></p>
<p><em>В каждом случае мы получаем правильный ответ, но не получаем никаких указаний на то, что такое <code>?X</code>, поэтому мы не можем подставить его в ответ. Нам нужно изменить <code>pat-match</code>, чтобы она возвращала какую-то таблицу переменных и соответствующих им значений. Сделав этот выбор, опытный программист на Common Lisp может сэкономить время, проявив гибкость: он сразу распознает, когда существует функция, которая сможет выполнить большую часть поставленной задачи. Мы хотим подставлять значения для переменных во всем ответе. Предупрежденный программист может обратиться к указателю этой книги или справочному руководству Common Lisp и найти функции <code>substitute</code>, <code>subst</code> и <code>sublis</code>. Все они заменяют старое выражение новым выражением внутри выражения. Оказывается, что <code>sublis</code> является наиболее подходящим, потому что она единственная, которая позволяет нам делать несколько замен одновременно. <code>sublis</code> принимает два аргумента, первый - это список пар старый-новый, а второй - выражение, в котором должны быть сделаны замены. Для каждой из пар <code>car</code> заменяется на <code>cdr</code>. Другими словами, мы должны сформировать каждую пару так: <code>(cons old new)</code>. (Такой список пар известен как <em>список ассоциаций/ассоциативный список</em> или <em>a-list</em>, потому что он связывает ключи со значениями. См. Раздел 3.6.) В терминах приведенного выше примера мы бы использовали:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (sublis &#39;((?X . vacation))</div><div class="line">          &#39;(what would it mean to you if you got a ?X ?))</div><div class="line">(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)</div></div><!-- fragment --><p></em></p>
<p><em>Теперь нам нужно сделать так, чтобы <code>pat-match</code> возвращал a-list, а не просто T в случае успеха. Вот первая попытка:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun pat-match (pattern input)</div><div class="line">   &quot;Does pattern match input? WARNING: buggy version.&quot;</div><div class="line">   (if (variable-p pattern)</div><div class="line">       (list (cons pattern input))</div><div class="line">       (if (or (atom pattern) (atom input))</div><div class="line">       (eql pattern input)</div><div class="line">       (append (pat-match (first pattern) (first input))</div><div class="line">           (pat-match (rest pattern) (rest input))))))</div></div><!-- fragment --><p></em></p>
<p><em>Эта реализация выглядит разумной: она возвращает a-list из одного элемента, если образец является переменной, и соединяет(append) ассоциативные списки, если образец и вход являются списками. Однако есть несколько проблем. Во-первых, тест <code>(eql pattern input)</code> может вернуть <code>T</code>, который не является списком, поэтому <code>append</code> будет жаловаться. Во-вторых, тот же тест может вернуть nil, что должно указывать на сбой, но он будет рассматриваться просто как список и будет добавлен к остальной части ответа. В-третьих, мы не различаем случай, когда совпадение не удается и возвращается nil, и случай, когда все совпадает, но нет переменных, поэтому он возвращается nil - нулевой a-list. (Это проблема полупредиката, обсуждаемая на стр. 127.) В-четвертых, мы хотим, чтобы привязки переменных согласовывались - если <code>?X</code> используется дважды в образце, мы не хотим, чтобы он совпадал с двумя разными значениями во входных данных. Наконец, для <code>pat-match</code> неэффективно проверять и <code>first</code> и <code>rest</code> списков, даже если соответствующие части <code>first</code> не совпадают. (Разве не удивительно, что в семистрочной функции может быть пять ошибок?)</em></p>
<p><em>Мы можем решить эти проблемы, договорившись о двух основных соглашениях. Во-первых, очень удобно сделать <code>pat-match</code> истинным предикатом, поэтому мы согласимся, что он возвращает <code>nil</code> только для обозначения неудачи. Это означает, что для представления пустого списка привязок нам понадобится значение, отличное от nil. Во-вторых, если мы собираемся быть последовательными в отношении значений переменных, то первое(<code>first</code>) должно будет знать, что делают остальные(<code>rest</code>). Мы можем добиться этого, передав список привязок в качестве третьего аргумента функции <code>pat-match</code>. Мы сделаем его необязательным аргументом, потому что хотим иметь возможность просто сказать <code>(pat-match a b)</code>.</em></p>
<p><em>Чтобы абстрагироваться от этих решений реализации, мы определяем константы <code>fail</code> и <code>no-bindings</code> для представления двух проблемных возвращаемых значений. Специальная форма defconstant используется для обозначения того, что эти значения не изменятся. (Принято давать специальные имена переменных, начинающиеся и заканчивающиеся звездочками, но это соглашение обычно не соблюдается для констант. Причина в том, что звездочки кричат: "Осторожно!
Я могу быть изменен чем-то за пределами этой лексической области." Константы, конечно, не будут изменены.)</em></p>
<p><em></p><div class="fragment"><div class="line">(defconstant fail nil &quot;Indicates pat-match failure&quot;)</div><div class="line"></div><div class="line">(defconstant no-bindings &#39;((t . t))</div><div class="line">  &quot;Indicates pat-match success, with no variables.&quot;)</div></div><!-- fragment --><p></em></p>
<p><em>Затем мы абстрагируемся от <code>assoc</code>, введя следующие четыре функции:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun get-binding (var bindings)</div><div class="line">  &quot;Find a (variable . value) pair in a binding list.&quot;</div><div class="line">  (assoc var bindings))</div><div class="line"></div><div class="line">(defun binding-val (binding)</div><div class="line">  &quot;Get the value part of a single binding.&quot;</div><div class="line">  (cdr binding))</div><div class="line"></div><div class="line">(defun lookup (var bindings)</div><div class="line">  &quot;Get the value part (for var) from a binding list.&quot;</div><div class="line">  (binding-val (get-binding var bindings)))</div><div class="line"></div><div class="line">(defun extend-bindings (var val bindings)</div><div class="line">  &quot;Add a (var . value) pair to a binding list.&quot;</div><div class="line">  (cons (cons var val) bindings))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь, когда определены переменные и привязки, реализация <code>pat-match</code> очень проста. Она состоит из пяти случаев. Во-первых, если список привязки - <code>fail</code>, то сопоставление не удачно (потому что какое-то предыдущее сопоставление должно было быть неудачным). Если образец представляет собой единственную переменную, то совпадение возвращает все, что возвращает <code>match-variable</code>; либо существующий список привязки, либо расширенный, либо <code>fail</code>. Затем, если и образец, и входные данные являются списками, мы сначала рекурсивно вызываем <code>pat-match</code> для первого элемента каждого списка. Она возвращает список привязки (или <code>fail</code>), который мы используем для сопоставления с оставшимися списками. Это единственный случай, когда вызывается нетривиальная функция, поэтому неплохо неформально доказать, что функция завершится: каждый из двух рекурсивных вызовов уменьшает размер как образца, так и ввода, а <code>pat-match</code> проверяет случай атомарных образцов и входных данных, поэтому функция в целом должна в конечном итоге вернуть ответ (если и образец, и входные данные не имеют бесконечного размера). Если ни один из этих четырех случаев неуспешен, то совпадение считается неудачным.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun pat-match (pattern input &amp;optional (bindings no-bindings))</div><div class="line">   &quot;Match pattern against input in the context of the bindings&quot;</div><div class="line">   (cond ((eq bindings fail) fail)</div><div class="line">     ((variable-p pattern)</div><div class="line">      (match-variable pattern input bindings))</div><div class="line">     ((eql pattern input) bindings)</div><div class="line">     ((and (consp pattern) (consp input))</div><div class="line">      (pat-match (rest pattern) (rest input)</div><div class="line">             (pat-match (first pattern) (first input)</div><div class="line">                bindings)))</div><div class="line">     (t fail)))</div><div class="line"></div><div class="line">(defun match-variable (var input bindings)</div><div class="line">  &quot;Does VAR match input? Uses (or updates) and returns bindings.&quot;</div><div class="line">  (let ((binding (get-binding var bindings)))</div><div class="line">    (cond ((not binding) (extend-bindings var input bindings))</div><div class="line">      ((equal input (binding-val binding)) bindings)</div><div class="line">      (t fail))))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы можем протестировать <code>pat-match</code> и посмотреть, как это работает:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (pat-match &#39;(i need a ?X) &#39;(i need a vacation))</div><div class="line">((?X . VACATION) (T . T))</div></div><!-- fragment --><p></em></p>
<p><em>Ответ представляет собой список привязок переменных в виде точечных пар; каждый элемент списка представляет собой пару (<code>variable . value</code>). <code>(T. T)</code> является признаком <code>no-bindings</code>. Он не наносит реального вреда, но мы можем устранить это, немного усложнив <code>extend-bindings</code>:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun extend-bindings (var val bindings)</div><div class="line">   &quot;Add a (var . value) pair to a binding list. &quot;</div><div class="line">   (cons (cons var val)</div><div class="line">     ;; Once we add a &quot;real&quot; binding,</div><div class="line">     ;; we can get rid of the dummy no-bindings</div><div class="line">     (if (eq bindings no-bindings)</div><div class="line">         nil</div><div class="line">         bindings)))</div><div class="line"></div><div class="line">&gt; (sublis (pat-match &#39; (i need a ?X) &#39; (i need a vacation))</div><div class="line">          &#39;(what would it mean to you if you got a ?X ?))</div><div class="line">(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)</div><div class="line"></div><div class="line">&gt; (pat-match &#39; (i need a ?X) &#39; (i really need a vacation))</div><div class="line">NIL</div><div class="line"></div><div class="line">&gt; (pat-match &#39; (this is easy) &#39; (this is easy))</div><div class="line">((T . T))</div><div class="line"></div><div class="line">&gt; (pat-match &#39; (?X is ?X) &#39; ((2 + 2) is 4))</div><div class="line">NIL</div><div class="line"></div><div class="line">&gt; (pat-match &#39; (?X is ?X) &#39; ((2 + 2) is (2 + 2)))</div><div class="line">((?X 2 + 2))</div><div class="line"></div><div class="line">&gt; (pat-match &#39; (?P need . ?X) &#39; (i need a long vacation))</div><div class="line">((?X A LONG VACATION) (?P . I ))</div></div><!-- fragment --><p></em></p>
<p><em>Важное замечание: точка в конце шаблона, говорит о том, что последняя переменная может соответствовать всей оставшейся части ввода.</em></p>
<p><em>Обратите внимание на различие между <code>NIL</code> и <code>((T . T))</code>. Последнее означает, что совпадение прошло успешно, но привязок для возврата нет. Также запомните, что <code>(?X 2 + 2)</code> означает то же самое, что <code>(?X . (2 + 2))</code>.</em></p>
<p><em>Более мощная реализация <code>pat-match</code> дается в главе 6. Еще одна реализация приведена в разделе 10.4. Она более эффективна, но более громоздка в использовании.</em></p>
<p><em></p><h2>5.3 Сопоставление с сегментным образцом</h2>
<p></em></p>
<p><em> В образце <code>(?P need . ?X)</code> переменная <code>?X</code> соответствует остальной части входного списка(остатку), независимо от его длины. И в этом её отличие от <code>?P</code>, которая может соответствовать только одному элементу, а именно первому элементу ввода. Для многих приложений сопоставление с образцом это обычное дело; мы хотим сопоставить только соответствующие элементы. Однако ELIZA несколько отличается тем, что она учитывает переменные в любой позиции, которые могут соответствовать последовательности элементов во входных данных. Мы будем называть такие переменные <em>сегментными переменными</em>. Нам понадобится обозначение, чтобы отличать сегментные переменные от обычных переменных. Возможны два класса обозначений: либо мы используем атомы для представления сегментных переменных и различаем их по определенному правилу написания (как мы это делали, чтобы отличать переменные от констант), либо мы используем неатомарную конструкцию. Мы выберем последний вариант, используем список вида (<code>?*</code> <em>Variable</em>) для обозначения сегментных переменных. Символ <code>?*</code> выбран потому, что он объединяет понятие переменной с обозначением Kleenestar. Итак, поведение, которое мы хотим от <code>pat-match</code>, таково:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (pat-match &#39;((?* ?p) need (?* ?x))</div><div class="line">             &#39;(Mr Hulot and I need a vacation))</div><div class="line">((?P MR HULOT AND I) (?X A VACATION))</div></div><!-- fragment --><p></em></p>
<p><em>Другими словами, когда и образец, и ввод являются списками, а первый элемент образца является сегментной переменной, тогда переменная будет сопоставлена некоторой начальной части ввода, а остальная часть образца будет сопоставлена остатку ввода. Мы можем обновить <code>pat-match</code>, чтобы учесть это, добавив единственное условие cond. Также легко определить предикат для проверки сегментных переменных:</em></p>
<p><em></p><div class="fragment"><div class="line"> (defun pat-match (pattern input &amp;optional (bindings no-bindings))</div><div class="line">   &quot;Match pattern against input in the context of the bindings&quot;</div><div class="line">   (cond ((eq bindings fail) fail)</div><div class="line">     ((variable-p pattern)</div><div class="line">      (match-variable pattern input bindings))</div><div class="line">     ((eql pattern input) bindings)</div><div class="line">     ((segment-pattern-p pattern)                ; ***</div><div class="line">      (segment-match pattern input bindings))    ; ***</div><div class="line">     ((and (consp pattern) (consp input))</div><div class="line">      (pat-match (rest pattern) (rest input)</div><div class="line">             (pat-match (first pattern) (first input)</div><div class="line">                bindings)))</div><div class="line">     (t fail)))</div><div class="line"></div><div class="line">(defun segment-pattern-p (pattern)</div><div class="line">  &quot;Is this a segment matching pattern: ((?* var) . pat)&quot;</div><div class="line">  (and (consp pattern)</div><div class="line">       (starts-with (first pattern) &#39;?*)))</div></div><!-- fragment --><p></em></p>
<p><em>При написании <code>segment-match</code> важный вопрос состоит в том, какой части ввода должна соответствовать сегментная переменная. Один из ответов - посмотреть на следующий элемент образца (тот, который стоит после переменной сегмента) и посмотреть, в какой позиции он встречается во входных данных. Если этого не происходит, весь образец никогда не может совпасть, и мы должны - потерпеть неудачу (<code>fail</code>). Если это происходит, назовем его позицию(позицию совпадения) <code>pos</code>. Тогда мы сопоставляем переменную с начальной частью ввода, вплоть до позиции <code>pos</code>. Но сначала мы должны посмотреть, соответствует ли оставшаяся часть образца оставшейся части ввода. Это делается рекурсивным вызовом <code>pat-match</code>. Пусть результат этого рекурсивного вызова будет называться <code>b2</code>. Если <code>b2</code> успешно, то мы идем дальше и сопоставляем сегментную переменную с начальной подпоследовательностью.</em></p>
<p><em>Возникает сложность - когда <code>b2</code> неудача. Мы не хотим полностью сдаваться, потому что может случиться так, что если сегментная переменная соответствует более длинной подпоследовательности ввода, тогда остальная часть образца будет соответствовать оставшейся части ввода. Итак, мы хотим снова попробовать <code>segment-match</code>, но заставить его учитывать более длительное совпадение для переменной. Это делается путем введения необязательного параметра <code>start</code>, который изначально равен 0 и увеличивается с каждой ошибкой. Обратите внимание, что это правило исключает возможность любой вид переменных после сегментной переменной. (Позже мы снимем это ограничение.)</em></p>
<p><em></p><div class="fragment"><div class="line">(defun segment-match (pattern input bindings &amp;optional (start 0))</div><div class="line">   &quot;Match the segment pattern ((?* var) . pat) against input.&quot;</div><div class="line">   (let ((var (second (first pattern)))</div><div class="line">     (pat (rest pattern)))</div><div class="line">     (if (null pat)</div><div class="line">     (match-variable var input bindings)</div><div class="line">     ;; We assume that pat starts with a constant</div><div class="line">     ;; In other words, a pattern can&#39;t have 2 consecutive vars</div><div class="line">     (let ((pos (position (first pat) input</div><div class="line">                  :start start :test #&#39;equal)))</div><div class="line">       (if (null pos)</div><div class="line">           fail</div><div class="line">           (let ((b2 (pat-match pat (subseq input pos) bindings)))</div><div class="line">         ;; If this match failed, try another longer one</div><div class="line">         ;; If it worked, check that the variables match</div><div class="line">         (if (eq b2 fail)</div><div class="line">             (segment-match pattern input bindings (+ pos 1))</div><div class="line">             (match-variable var (subseq input 0 pos) b2))))))))</div></div><!-- fragment --><p></em></p>
<p><em>Ниже приведены некоторые примеры сопоставления сегментов:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (pat-match &#39;((?* ?p) need (?* ?x))</div><div class="line">       &#39;(Mr Hulot and I need a vacation))</div><div class="line">((?P MR HULOT AND I) (?X A VACATION))</div><div class="line"></div><div class="line">&gt; (pat-match &#39;((?* ?x) is a (?* ?y)) &#39;(what he is is a fool))</div><div class="line">((?X WHAT HE IS) (?Y FOOL))</div></div><!-- fragment --><p></em></p>
<p><em>Первый из этих примеров показывает довольно простой случай: <code>?p</code> соответствует всему, до need, а <code>?x</code> соответствует остальному. В следующем примере рассматривается более сложный случай. Первый <code>?x</code> соответствует всему, вплоть до первого <code>is</code> (это позиция 2, поскольку счет начинается с 0 в Common Lisp). Но тогда образец a не соответствует <code>is</code> из входных данных, <code>segment-match</code> пытается начать снова с начальной позиции 3. На этот раз все работает; <code>is</code> соответствует <code>is</code>, <code>a</code> соответствует <code>a</code> и <code>(?* ?y)</code> соответствует <code>fool</code>.</em></p>
<p><em>К сожалению, эта версия <code>segment-match</code> не находит многие соответствия, как это должно быть. Рассмотрим следующий пример:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (pat-match &#39;((?* ?x) a b (?* ?x)) &#39;(1 2 a b a b 1 2 a b)) â NIL</div></div><!-- fragment --><p></em></p>
<p><em>Функция терпит неудачу, потому что <code>?x</code> сопоставляется с подпоследовательностью <code>(1 2)</code>, и тогда оставшийся образец успешно соответствует оставшемуся входу, но окончательный вызов <code>match-variable</code> завершается неудачей, потому что <code>?x</code> имеет два различных значения. Исправление состоит в том, чтобы вызвать <code>match-variable</code> перед проверкой, не является ли <code>b2</code> неудачей, так что мы обязательно попробуем <code>segment-match</code> снова с более длинным соответствием независимо от причины сбоя.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun segment-match (pattern input bindings &amp;optional (start 0))</div><div class="line">   &quot;Match the segment pattern ((?* var) . pat) against input.&quot;</div><div class="line">   (let ((var (second (first pattern)))</div><div class="line">     (pat (rest pattern)))</div><div class="line">     (if (null pat)</div><div class="line">     (match-variable var input bindings)</div><div class="line">     ;; We assume that pat starts with a constant</div><div class="line">     ;; In other words, a pattern can&#39;t have 2 consecutive vars</div><div class="line">     (let ((pos (position (first pat) input</div><div class="line">                  :start start :test #&#39;equal)))</div><div class="line">       (if (null pos)</div><div class="line">           fail</div><div class="line">           (let ((b2 (pat-match</div><div class="line">              pat (subseq input pos)</div><div class="line">              (match-variable var (subseq input 0 pos)</div><div class="line">                      bindings))))</div><div class="line">         ;; If this match failed, try another longer one</div><div class="line">         (if (eq b2 fail)</div><div class="line">             (segment-match pattern input bindings (+ pos 1))</div><div class="line">             b2)))))))</div></div><!-- fragment --><p></em></p>
<p><em>Теперь мы видим, что поиск соответствия идет до конца:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (pat-match &#39;((?* ?x) a b (?* ?x)) &#39;(1 2 a b a b 1 2 a b))</div><div class="line">((?X 1 2 A B))</div></div><!-- fragment --><p></em></p>
<p><em>Обратите внимание, что эта версия <code>segment-match</code> сначала пытается найти самое короткое совпадение. Также можно было бы сначала попробовать самое длинное соответствие.</em></p>
<p><em></p><h2>5.4 Программа Элиза: Преобразователь на основе правил</h2>
<p></em></p>
<p><em> Теперь, когда у нас есть работающий сопоставитель с образцом, нам нужно сопоставить несколько образцов. Более того, мы хотим, чтобы образцы были связаны с ответами. Мы можем сделать это, придумав структуру данных, называемую <code>rule</code>(правило), которая состоит из образца и одного или нескольких связанных ответов. Это правила в том смысле, что они утверждают: "Если вы видите A, то ответьте B или C, выбранными наугад". Мы выберем простейшую возможную реализацию правил: в виде списков, где первый элемент - это образец, а остаток - список ответов:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun rule-pattern (rule) (first rule))</div><div class="line"></div><div class="line">(defun rule-responses (rule) (rest rule))</div></div><!-- fragment --><p></em></p>
<p><em>Вот пример правила:</em></p>
<p><em></p><div class="fragment"><div class="line">(((?* ?x) I want (?* ?y))</div><div class="line"> (What would it mean if you got ?y)</div><div class="line"> (Why do you want ?y)</div><div class="line"> (Suppose you got ?y soon))</div></div><!-- fragment --><p></em></p>
<p><em>При применении к входным данным: <code>(I want to test this program)</code>, т.е. <code>(я хочу протестировать эту программу)</code> это правило (при интерпретации программой ELIZA) выбирает ответ случайным образом, подставляет в <code>?y</code> значение и отвечает, скажем: <code>(why do you want to test this program)</code>, т.е <code>(почему вы хотите протестировать эту программу)</code>.</em></p>
<p><em>Теперь, когда мы знаем, что будет делать отдельное правило, нам нужно решить, как обрабатывать набор правил. Если мы хотим, чтобы ELIZA представляла интерес, у нее должно быть множество ответов. Таким образом, к одному и тому же входу могут применяться несколько правил. Одна из возможностей - выбрать случайным образом правило из набора правил, имеющих образцы, соответствующие входным данным.</em></p>
<p><em>Другой вариант - просто принять первое подходящее правило. Это означает, что правила формируют упорядоченный список, а не неупорядоченное множество. Умный составитель правил для ELIZA может воспользоваться этим упорядочиванием и сделать так, чтобы наиболее конкретные правила были на первом месте, в то время как более расплывчатые правила находились ближе к концу списка.</em></p>
<p><em>В исходной ELIZA была система, в которой каждому правилу был присвоен номер приоритета. Выбралось правило сопоставления с наивысшим приоритетом. Обратите внимание, что упорядочение правил дает тот же эффект, что и номер приоритета для каждого правила: первое правило неявно имеет наивысший приоритет, второе правило - следующее наивысшее и т. Д.</em></p>
<p><em>Вот краткий список правил, выбранных из исходной статьи Вайценбаума, но с обновленной формой правил до той формы, которую мы используем. Ответ к упражнению 5.18 содержит более длинный список правил.</em></p>
<p><em></p><div class="fragment"><div class="line">(defparameter *eliza-rules*</div><div class="line">  &#39;((((?* ?x) hello (?* ?y))</div><div class="line">     (How do you do.  Please state your problem.))</div><div class="line">    (((?* ?x) I want (?* ?y))</div><div class="line">     (What would i t mean if you got ?y)</div><div class="line">     (Why do you want ?y) (Suppose you got ?y soon))</div><div class="line">    (((?* ?x) if (?* ?y))</div><div class="line">     (Do you really think i t s l i k e l y that ?y) (Do you wish that ?y)</div><div class="line">     (What do you think about ?y) (Really-- if ?y))</div><div class="line">    (((?* ?x) no (?* ?y))</div><div class="line">     (Why not?) (You are being a bit negative)</div><div class="line">     (Are you saying &quot;NO&quot; just to be negative?))</div><div class="line">    (((?* ?x) I was (?* ?y))</div><div class="line">     (Were you really ?) (Perhaps I already knew you were ?y)</div><div class="line">     (Why do you t e l l me you were ?y now?))</div><div class="line">    (((?* ?x) I feel (?* ?y))</div><div class="line">     (Do you often feel ?y ?))</div><div class="line">    (((?* ?x) I felt (?* ?y))</div><div class="line">     (What other feelings do you have?))))</div></div><!-- fragment --><p></em></p>
<p><em>Наконец, мы готовы дать собственно определение ELIZA. Как мы говорили ранее, основная программа должна быть циклом, который считывает ввод, преобразует его и печатает результат. Преобразование выполняется в первую очередь путем нахождения некоторого правила, образец которого соответствует входу, а затем подстановки переменных в ответ правила. Программа представлена на рисунке 5.1.</em></p>
<p><em>Рисунок 5.1: Глоссарий программы ELIZA</em></p>
<p><em></p><table class="doxtable">
<tr>
<th>Символ </th><th>Использование  </th></tr>
<tr>
<td></td><td><b>Функция верхнего уровня</b> </td></tr>
<tr>
<td><code>eliza</code> </td><td>Отвечает на ввод пользователя, используя правила сопоставления с образцом. </td></tr>
<tr>
<td></td><td><b>Специальные переменные</b> </td></tr>
<tr>
<td><code>*eliza-rules*</code> </td><td>Список правил преобразования. </td></tr>
<tr>
<td></td><td><b>Типы данных</b> </td></tr>
<tr>
<td><code>rule</code> </td><td>Связь образцов со списком ответов.. </td></tr>
<tr>
<td></td><td><b>Функции</b> </td></tr>
<tr>
<td><code>eliza</code> </td><td>Отвечает на ввод пользователя, используя правила сопоставления с образцом. </td></tr>
<tr>
<td><code>use-eliza-rules</code> </td><td>Ищет какое-либо правило, с помощью которого можно преобразовать ввод. </td></tr>
<tr>
<td><code>switch-viewpoint</code> </td><td>Меняет я(I) на ты(you) и наоборот, и т.д. </td></tr>
<tr>
<td><code>flatten</code> </td><td>складывает элементы в список. </td></tr>
<tr>
<td></td><td><b>Выбранные функции Common Lisp</b> </td></tr>
<tr>
<td><code>sublis</code> </td><td>производит замену элементов в дереве. </td></tr>
<tr>
<td></td><td><b>Ранее определенные функции</b> </td></tr>
<tr>
<td><code>random-elt</code> </td><td>Выберает случайный элемент из списка. (p. 36) </td></tr>
<tr>
<td><code>pat-match</code> </td><td>Сопоставляет образец с вводом, (p. 160) </td></tr>
<tr>
<td><code>mappend</code> </td><td>Складывает вместе результаты mapcar. </td></tr>
</table>
<p>Есть несколько мелких осложнений. Мы печатаем приглашение, чтобы сообщить пользователю что ждем ввода. Мы используем функцию <code>flatten</code>, чтобы гарантировать, что на выходе не будет вложенных списков после подстановки переменных. Важный трюк - изменить ввод, заменив "ты"(you) на "я"(i) и так далее, поскольку эти термины относятся к говорящему. Вот полная программа:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun eliza ()</div><div class="line">  &quot;Respond to user input using pattern matching rules.&quot;</div><div class="line">  (loop</div><div class="line">   (print &#39;eliza&gt;)</div><div class="line">   (write (flatten (use-eliza-rules (read))) :pretty t)))</div><div class="line"></div><div class="line"> (defun use-eliza-rules (input)</div><div class="line">   &quot;Find some rule with which to transform the input.&quot;</div><div class="line">   (some #&#39;(lambda (rule)</div><div class="line">         (let ((result (pat-match (rule-pattern rule) input)))</div><div class="line">           (if (not (eq result fail))</div><div class="line">           (sublis (switch-viewpoint result)</div><div class="line">               (random-elt (rule-responses rule))))))</div><div class="line">     *eliza-rules*))</div><div class="line"></div><div class="line">(defun switch-viewpoint (words)</div><div class="line">  &quot;Change I to you and vice versa, and so on.&quot;</div><div class="line">  (sublis &#39;((I . you) (you . I) (me . you) (am . are))</div><div class="line">          words))</div></div><!-- fragment --><p></em></p>
<p><em>Обратите внимание на использование <code>write</code> с ключевым словом <code>:pretty</code> true. В некоторых случаях это даст лучший формат вывода. Программа использует ранее определенные <code>random-elt</code> и <code>flatten</code>, которые определены здесь с помощью <code>mappend</code> и <code>mklist</code>, функций, которые определены в диалекте InterLisp, но не в Common Lisp.</em></p>
<p><em></p><div class="fragment"><div class="line">(defun flatten (the-list)</div><div class="line">  &quot;Append together elements (or lists) in the list.&quot;</div><div class="line">  (mappend #&#39;mklist the-list))</div><div class="line"></div><div class="line">(defun mklist (x)</div><div class="line">  &quot;Return x if it is a list, otherwise (x).&quot;</div><div class="line">  (if (listp x)</div><div class="line">      x</div><div class="line">    (list x)))</div><div class="line"></div><div class="line">(defun mappend (fn the-list)</div><div class="line">  &quot;Apply fn to each element of list and append the result.&quot;</div><div class="line">  (apply #&#39;append (mapcar fn the-list)))</div><div class="line"></div><div class="line">(defun random-elt (choices)</div><div class="line">  &quot;Choose an element from a list at random.&quot;</div><div class="line">  (elt choices (random (length choices))))</div></div><!-- fragment --><p></em></p>
<p><em>В реальной программе ELIZA было несколько усложнений, которых нет в этой версии. Во-первых, был метод псевдонима для связывания нескольких слов с одним и тем же образцо; и "mother"(мать), и "father"(отец) могут быть связаны с образцом "family"(семья). Был также механизм синонимов, который относился к "don't"(не надо) и "do not" или "everybody"(всем) и "everyone". В случае ввода нескольких фраз, разделенных запятыми, каждая фраза обрабатывалась отдельно и выбирался ответ с наивысшим приоритетом. Кроме того, исходная ELIZA имела механизм "памяти". Когда ни один образец не совпадал с вводом, он говорил что-то вроде "Tell me more about X"(Расскажите мне больше о X), где X - некоторый ввод, сделанный ранее. Наконец, в нашей версии меньше правил. Несмотря на недостатки нашей версии, она может иногда задерживать конец разговора, как показано ниже:</em></p>
<p><em></p><div class="fragment"><div class="line">&gt; (eliza)</div><div class="line">ELIZA&gt; (hello there)</div><div class="line">(HOW DO YOU DO. PLEASE STATE YOUR PROBLEM.)</div><div class="line">ELIZA&gt; (i want to test this program)</div><div class="line">(WHAT WOULD IT MEAN IF YOU GOT TO TEST THIS PROGRAM)</div><div class="line">ELIZA&gt; (i could see if it works)</div><div class="line">(DO YOU REALLY THINK ITS LIKELY THAT IT WORKS)</div><div class="line">ELIZA&gt; (no not really)</div><div class="line">(ARE YOU SAYING &quot;NO&quot; JUST TO BE NEGATIVE?)</div><div class="line">ELIZA&gt; (no)</div><div class="line">(ARE YOU SAYING &quot;NO&quot; JUST TO BE NEGATIVE?)</div><div class="line">ELIZA&gt; (forget it-- i was wondering how general the program i s)</div><div class="line">(WHY DO YOU TELL ME YOU WERE WONDERING HOW GENERAL THE PROGRAM I S NOW?)</div><div class="line">ELIZA&gt; (i felt like it)</div><div class="line">(WHAT OTHER FEELINGS DO YOU HAVE?)</div><div class="line">ELIZA&gt; (i feel this is enough)</div><div class="line">(DO YOU OFTEN FEEL THIS IS ENOUGH ?)</div><div class="line">ELIZA&gt; [Abort]</div></div><!-- fragment --><p></em></p>
<p><em>В конце концов, это важна техника, а не программа. ELIZA была "объяснена", и ее по праву следует переместить на полку с любопытными вещами. Сопоставление с образцом в целом остается важной техникой, и мы еще не раз увидим ее в следующих главах. Понятие преобразователя, основанного на правилах, также важно. Проблема понимания английского (и других языков) остается важной частью ИИ. Понятно, что проблема понимания английского не решается ELIZA. В части V мы снова обратимся к этой проблеме, используя более сложные методы.</em></p>
<p><em></p><h2>5.5 История и ссылки</h2>
<p></em></p>
<p><em> Как упоминалось выше, исходная статья, описывающая ELIZA, описана в Weizenbaum 1966. Другой диалоговой системой, использующей аналогичные методы сопоставления с образцом, является система PARRY Кеннета Колби (1975). Эта программа достаточно хорошо смоделировала разговор параноика, чтобы обмануть нескольких профессиональных психологов. Хотя методы сопоставления с образцом были простыми, модель убеждений, поддерживаемая системой, была намного сложнее, чем ELIZA. Колби предположил, что диалоговые программы, такие как ELIZA, дополненные какой-то моделью убеждений, такой как PARRY, могут быть полезными инструментами при лечении психически больных людей. По словам Колби, было бы недорого и эффективно заставить пациентов общаться с помощью специально разработанной программы, которая могла бы обрабатывать простые случаи и предупреждать врачей о пациентах, которым требуется дополнительная помощь. В книге Вайценбаума «Компьютерная мощь и человеческий разум» (1976) обсуждаются ELIZA и PARRY и очень критически рассматривается предложение Колби. О других интересных ранних работах по диалоговым системам, моделирующим убеждения, сообщили Аллан Коллинз (1978) и Джейми Карбонелл (1981).</em></p>
<p><em></p><h2>5.6 Упражнения</h2>
<p></em></p>
<p><em> &amp;#9635; <b>Exercise 5.2 [m]</b> Поэкспериментируйте с этой версией ELIZA. Покажите некоторые обмены сообщениями, где она работает хорошо, а где нет. Попытайтесь охарактеризовать разницу. Какие сбои можно исправить, изменив набор правил, какие - изменив функцию <code>pat-match</code> (и язык образцов, который она определяет), а какие требуют изменения самой программы <code>eliza</code>?</em></p>
<p><em>&amp;#9635; <b>Exercise 5.3 [h]</b> Определите новый набор правил, которые заставят ELIZA давать стереотипные ответы на некоторые ситуации, отличные от отношений между врачом и пациентом. Или напишите свод правил на другом языке, кроме английского. Протестируйте и отладьте свой новый набор правил.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.4 [s]</b> Мы упоминали, что наша версия ELIZA не может обрабатывать запятые или двойные кавычки во входных данных. Однако, похоже, она обрабатывает апостроф как во вводе, так и в шаблонах. Объясните.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.5 [h]</b> Измените механизм ввода для обработки запятых и других знаков препинания. Также сделайте так, чтобы пользователю не приходилось вводить круглые скобки вокруг всего входного выражения. (Подсказка: это можно сделать только с помощью некоторых функций Lisp, которые мы еще не видели. Посмотрите на <code>read-line</code> и <code>read-from-string</code>.)</em></p>
<p><em>&amp;#9635; <b>Exercise 5.6 [m]</b> Измените ELIZA, чтобы иметь явный выход. Также организуйте так, чтобы вывод не печатался в круглых скобках.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.7 [m]</b> Добавьте "механизм памяти", о котором говорилось ранее, в ELIZA. Также добавьте способ определения синонимов, таких как "everyone" и "everybody".</em></p>
<p><em>&amp;#9635; <b>Exercise 5.8 [h]</b> Оказывается, ни одно из правил в данном скрипте не использует переменную более одного раза - нет правила вида <code>(?X ... ?X)</code>. Напишите средство сопоставления образцов, которое только добавляет привязки, но никогда не проверяет переменные на соответствие предыдущим привязкам. Используйте специальную форму <code>time</code>, чтобы сравнить вашу функцию с текущей версией.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.9 [h]</b> Книга Уинстона и Хорна <em>Lisp</em> предоставляет хорошую программу сопоставления с образцом. Сравните их реализацию с этой. Одно отличие состоит в том, что они обрабатывают случай, когда первый элемент шаблона является сегментной переменной со следующим кодом (переведенным в нашу нотацию):</em></p>
<p><em></p><div class="fragment"><div class="line">(or (pat-match (rest pattern) (rest input) bindings)</div><div class="line">  (pat-match pattern (rest input) bindings))</div></div><!-- fragment --><p></em></p>
<p><em>Это говорит о том, что сегментная переменная соответствует либо путем сопоставления первого элемента ввода, либо путем сопоставления более чем первого элемента. Это намного проще, чем наш подход с использованием <code>position</code>, отчасти потому, что они не обновляют список привязок. Можете ли вы изменить их код для обработки привязок и включить его в нашу версию <code>pat-match</code>? Все еще проще? Это более или менее эффективно?</em></p>
<p><em>&amp;#9635; <b>Exercise 5.10</b> Что не так в следующем определении <code>simple-equal</code>?</em></p>
<p><em></p><div class="fragment"><div class="line">(defun simple-equal (x y)</div><div class="line">  &quot;Test if two lists or atoms are equal.&quot;</div><div class="line">  ;; Warning - incorrect</div><div class="line">  (or (eql x y)</div><div class="line">      (and (listp x) (listp y)</div><div class="line">     (simple-equal (first x) (first y))</div><div class="line">     (simple-equal (rest x) (rest y)))))</div></div><!-- fragment --><p></em></p>
<p><em>&amp;#9635; <b>Exercise 5.11 [m]</b> Оцените преимущества замены <code>no-bindings</code> на <code>nil</code> и <code>fail</code> на что-то еще.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.12 [m]</b> Взвесьте преимущества того, что <code>pat-match</code> возвращает множественное значение: первое будет истинным для совпадения и ложным при неудаче, а второе будет списком привязок.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.13 [m]</b> Предположим, что есть вызов <code>segment-match</code>, где переменная уже имеет привязку.</em></p>
<p><em>Текущее определение будет продолжать делать рекурсивные вызовы <code>segment-match</code>, по одному для каждой возможной совпадающей позиции. Но это глупо - если переменная уже связана, есть только одна последовательность, с которой её можно сопоставить. Измените определение так, чтобы оно отображало только эту последовательность.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.14 [m]</b> Определите версию <code>mappend</code>, которая, как и <code>mapcar</code>, принимает любое количество аргументов списков.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.15 [m]</b> Приведите неформальное доказательство того, что <code>segment-match</code> всегда заканчивается.</em></p>
<p><em>&amp;#9635; <b>Exercise 5.16 [s]</b> Вопрос с подвохом: в Лиспе есть объект, который при передаче в <code>variable-p</code> приводит к ошибке. Что это за объект?</em></p>
<p><em>&amp;#9635; <b>Exercise 5.17 [m]</b> Текущая версия ELIZA принимает входные данные, преобразует их в соответствии с первым применимым правилом и выводит результат. Можно также представить себе систему, в которой ввод может быть преобразован несколько раз, прежде чем будет напечатан окончательный вывод. Будет ли такая система более мощной? Если да, то каким образом?</em></p>
<p><em>&amp;#9635; <b>Exercise 5.18 [h]</b> Прочтите оригинальную статью Вайценбаума об ELIZA и перенесите его список правил в обозначения, используемые в этой главе.</em></p>
<p><em></p><h2>5.7 Answers</h2>
<p></em></p>
<p><em> </p><h3>Answer 5.1</h3>
<p></em></p>
<p><em> Нет. Если либо образец, либо входные данные были короче, но соответствовали каждому существующему элементу, выражение every неправильно вернуло бы true.</em></p>
<p><em></p><div class="fragment"><div class="line">(every #&#39;pat-match &#39;(a b c) &#39;(a)) â T</div></div><!-- fragment --><p></em></p>
<p><em>Более того, если образец или входные данные были списком с точкой, то результат every был бы undefined - некоторые реализации могут сигнализировать об ошибке, а другие могут просто игнорировать выражение после точки.</em></p>
<p><em></p><div class="fragment"><div class="line">(every #&#39;pat-match &#39;(a b . c) &#39;(a b . d)) â T, NIL, or error.</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Answer 5.4</h3>
<p></em></p>
<p><em> Выражение <code>don't</code> может выглядеть как отдельное слово, но для читателя(read) Lisp оно состоит из двух элементов <code>don</code> и <code>'t</code> или <code>(quote t )</code>. Если эти элементы используются последовательно, они будут сопоставляться правильно, но они не будут печататься правильно - перед кавычкой будет пробел. Фактически, аргумент <code>: pretty t</code> для <code>write</code> определен в первую очередь для того, чтобы заставить <code>(quote t)</code> печатать как <code>'t</code> (См. Стр. 559 книги Стила <em>Common Lisp the Language</em>, 2-е издание).</em></p>
<p><em></p><h3>Answer 5.5</h3>
<p></em></p>
<p><em> OОдин из способов сделать это - прочитать всю строку текста с помощью <code>read-line</code>, а не <code>read</code>. Затем замените любой символ пунктуации в этой строке пробелами. Наконец, заключите строку в круглые скобки и прочтите ее как список:</em></p>
<p><em></p><div class="fragment"><div class="line">(defun read-line-no-punct ()</div><div class="line">  &quot;Read an input line, ignoring punctuation.&quot;</div><div class="line">  (read-from-string</div><div class="line">   (concatenate &#39;string &quot;(&quot; (substitute-if #\space #&#39;punctuation-p</div><div class="line">             (read-line))</div><div class="line">    &quot;)&quot;)))</div><div class="line"></div><div class="line">(defun punctuation-p (char) (find char &quot;.,;:&#39;!?#-()\\\&quot;&quot;))</div></div><!-- fragment --><p></em></p>
<p><em>Это также можно сделать, изменив таблицу для чтения, как в разделе 23.5, с. 821.</em></p>
<p><em></p><h3>Answer 5.6</h3>
<p></em></p>
<p><em></em></p>
<p><em></p><div class="fragment"><div class="line"> (defun eliza ()</div><div class="line">   &quot;Respond to user input using pattern matching rules.&quot;</div><div class="line">   (loop</div><div class="line">      (print &#39;eliza&gt;)</div><div class="line">      (let* ((input (read-line-no-punct))</div><div class="line">          (response (flatten (use-eliza-rules input))))</div><div class="line">       (print-with-spaces response)</div><div class="line">       (if (equal response &#39;(good bye)) (RETURN)))))</div><div class="line"></div><div class="line">(defun print-with-spaces (list)</div><div class="line">  (mapc #&#39;(lambda (x) (prin1 x) (princ &quot; &quot;)) list))</div></div><!-- fragment --><p></em></p>
<p><em>***<code>or</code>***</em></p>
<p><em></p><div class="fragment"><div class="line">(defun print-with-spaces (list)</div><div class="line">  (format t &quot;~{~a ~}&quot; list))</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Answer 5.10</h3>
<p></em></p>
<p><em> Подсказка: подумайте `(simple-equal '() '(nil . nil))`.</em></p>
<p><em></p><h3>Answer 5.14</h3>
<p></em></p>
<p><em></em></p>
<p><em></p><div class="fragment"><div class="line">(defun mappend (fn &amp;rest list)</div><div class="line">  &quot;Apply fn to each element of lists and append the results.&quot;</div><div class="line">  (apply #&#39;append (apply #&#39;mapcar fn lists)))</div></div><!-- fragment --><p></em></p>
<p><em></p><h3>Answer 5.16</h3>
<p></em></p>
<p><em> Это должен быть символ, потому что для несимволов <code>variable-p</code> просто возвращает nil. Получение <code>symbol-name</code> для символа - это просто доступ к слоту, поэтому она не может вызвать ошибку. Остается только <code>elt</code>; если имя символа - пустая строка, то доступ к нулевому элементу пустой строки является ошибкой. В самом деле, есть символ, имя которого - пустая строка: символ.</em></p>
<p><em></p><h3>Answer 5.17</h3>
<p></em></p>
<p><em> Среди прочего, для обработки сокращений может использоваться система рекурсивного преобразования. То есть такую форму, как "don't"(не делать), можно преобразовать в "do not", а затем снова обработать. Таким образом, другие правила должны работать только с входными данными, совпадающими с "do not".</em></p>
<p><em></p><h3>Answer 5.18</h3>
<p></em></p>
<p><em> Ниже приводится большая часть правил Вайценбаума:</em></p>
<p><em></p><div class="fragment"><div class="line">(defparameter *eliza-rules*</div><div class="line">  &#39;((((?* ?x) hello (?* ?y))</div><div class="line">     (How do you do. Please state your problem.))</div><div class="line">    (((?* ?x) computer (?* ?y))</div><div class="line">     (Do computers worry you?) (What do you think about machines?)</div><div class="line">     (Why do you mention computers?)</div><div class="line">     (What do you think machines have to do with your problem?))</div><div class="line">    (((?* ?x) name (?* ?y))</div><div class="line">     (I am not interested in names))</div><div class="line">    (((?* ?x) sorry (?* ?y))</div><div class="line">     (Please don&#39;t apologize) (Apologies are not necessary)</div><div class="line">     (What feelings do you have when you apologize))</div><div class="line">    (((?* ?x) I remember (?* ?y))</div><div class="line">     (Do you often think of ?y)</div><div class="line">     (Does thinking of ?y bring anything else to mind?)</div><div class="line">     (What else do you remember) (Why do you recall ?y right now?)</div><div class="line">     (What in the present situation reminds you of ?y)</div><div class="line">     (What i s the connection between me and ?y))</div><div class="line">    (((?* ?x) do you remember (?* ?y))</div><div class="line">     (Did you think I would forget ?y ?)</div><div class="line">     (Why do you think I should recall ?y now)</div><div class="line">     (What about ?y) (You mentioned ?y))</div><div class="line">    (((?* ?x) if (?* ?y))</div><div class="line">     (Do you really think its likely that ?y) (Do you wish that ?y)</div><div class="line">     (What do you think about ?y) (Really-- if ?y))</div><div class="line">    (((?* ?x) I dreamt (?* ?y))</div><div class="line">     (Really-- ?y) (Have you ever fantasized ?y while you were awake?)</div><div class="line">     (Have you dreamt ?y before?))</div><div class="line">    (((?* ?x) dream about (?* ?y))</div><div class="line">     (How do you feel about ?y in reality?))</div><div class="line">    (((?* ?x) dream (?* ?y))</div><div class="line">     (What does this dream suggest to you?) (Do you dream often?)</div><div class="line">     (What persons appear in your dreams?)</div><div class="line">     (Don&#39;t you believe that dream has to do with your problem?))</div><div class="line">    (((?* ?x) my mother (?* ?y))</div><div class="line">     (Who else in your family ?y) (Tell me more about your family))</div><div class="line">    (((?* ?x) my father (?* ?y))</div><div class="line">     (Your father) (Does he influence you strongly?)</div><div class="line">     (What else comes to mind when you think of your father?))</div><div class="line">    (((?* ?x) I want (?* ?y))</div><div class="line">     (What would it mean if you got ?y)</div><div class="line">     (Why do you want ?y) (Suppose you got ?y soon))</div><div class="line">    (((?* ?x) I am glad (?* ?y))</div><div class="line">     (How have I helped you to be ?y) (What makes you happy just now)</div><div class="line">     (Can you explain why you are suddenly ?y))</div><div class="line">    (((?* ?x) I am sad (?* ?y))</div><div class="line">     (I am sorry to hear you are depressed)</div><div class="line">     (I &#39;m sure i t &#39; s not pleasant to be sad))</div><div class="line">    (((?* ?x) are like (?* ?y))</div><div class="line">     (What resemblance do you see between ?x and ?y))</div><div class="line">    (((?* ?x) i s like (?* ?y))</div><div class="line">     (In what way is it that ?x is like ?y)</div><div class="line">     (What resemblance do you see?)</div><div class="line">     (Could there really be some connection?) (How?))</div><div class="line">    (((?* ?x) alike (?* ?y))</div><div class="line">     (In what way?) (What s i m i l a r i t i e s are there?))</div><div class="line">    (((?* ?x) same (?* ?y))</div><div class="line">     (What other connections do you see?))</div><div class="line">    (((?* ?x) I was (?* ?y))</div><div class="line">     (Were you really ?) (Perhaps I already knew you were ?y)</div><div class="line">     (Why do you tell me you were ?y now?))</div><div class="line">    (((?* ?x) was I (?* ?y))</div><div class="line">     (What if you were ?y ?) (Do you think you were ?y)</div><div class="line">     (What would it mean if you were ?y))</div><div class="line">    (((?* ?x) I am (?* ?y))</div><div class="line">     (In what way are you ?y) (Do you want to be ?y ?))</div><div class="line">    (((?* ?x) am I (?* ?y))</div><div class="line">     (Do you believe you are ?y) (Would you want to be ?y)</div><div class="line">     (You wish I would tell you you are ?y)</div><div class="line">     (What would it mean if you were ?y))</div><div class="line">    (((?* ?x) am (?* ?y))</div><div class="line">     (Why do you say &quot;AM?&quot;) (I don&#39;t understand that))</div><div class="line">    (((?* ?x) are you (?* ?y))</div><div class="line">     (Why are you interested in whether I am ?y or not?)</div><div class="line">     (Would you prefer if I weren&#39;t ?y)</div><div class="line">     (Perhaps I am ?y in your fantasies))</div><div class="line">    (((?* ?x) you are (?* ?y))</div><div class="line">     (What makes you think I am ?y ?))</div><div class="line">    (((?* ?x) because (?* ?y))</div><div class="line">     (Is that the real reason?) (What other reasons might there be?)</div><div class="line">     (Does that reason seem to explain anything else?))</div><div class="line">    (((?* ?x) were you (?* ?y))</div><div class="line">     (Perhaps I was ?y) (What do you think?) (What if I had been ?y))</div><div class="line">    (((?* ?x) I can&#39;t (?* ?y))</div><div class="line">     (Maybe you could ?y now) (What if you could ?y ?))</div><div class="line">    (((?* ?x) I feel (?* ?y))</div><div class="line">     (Do you often feel ?y ?))</div><div class="line">    (((?* ?x) I felt (?* ?y))</div><div class="line">     (What other feelings do you have?))</div><div class="line">    (((?* ?x) I (?* ?y) you (?* ?z))</div><div class="line">     (Perhaps in your fantasy we ?y each other))</div><div class="line">    (((?* ?x) why don&#39;t you (?* ?y))</div><div class="line">     (Should you ?y yourself?)</div><div class="line">     (Do you believe I don&#39;t ?y) (Perhaps I will ?y in good time))</div><div class="line">    (((?* ?x) yes (?* ?y))</div><div class="line">     (You seem quite positive) (You are sure) (I understand))</div><div class="line">    (((?* ?x) no (?* ?y))</div><div class="line">     (Why not?) (You are being a bit negative)</div><div class="line">     (Are you saying &quot;NO&quot; just to be negative?))</div><div class="line">    (((?* ?x) someone (?* ?y))</div><div class="line">     (Can you be more specific?))</div><div class="line">    (((?* ?x) everyone (?* ?y))</div><div class="line">     (surely not everyone) (Can you think of anyone in particular?)</div><div class="line">     (Who for example?) (You are thinking of a special person))</div><div class="line">    (((?* ?x) always (?* ?y))</div><div class="line">     (Can you think of a specific example) (When?)</div><div class="line">     (What incident are you thinking of?) (Really-- always))</div><div class="line">    (((?* ?x) what (?* ?y))</div><div class="line">     (Why do you ask?) (Does that question interest you?)</div><div class="line">     (What is it you really want to know?) (What do you think?)</div><div class="line">     (What comes to your mind when you ask that?))</div><div class="line">    (((?* ?x) perhaps (?* ?y))</div><div class="line">     (You do not seem quite certain))</div><div class="line">    (((?* ?x) are (?* ?y))</div><div class="line">     (Did you think they might not be ?y)</div><div class="line">     (Possibly they are ?y))</div><div class="line">    (((?* ?x))</div><div class="line">     (Very interesting) (I am not sure I understand you fully)</div><div class="line">     (What does that suggest to you?) (Please continue) (Go on)</div><div class="line">     (Do you feel strongly about discussing such things?))))</div></div><!-- fragment --> <hr/>
<p></em></p>
<p><em><a class="anchor" id="chapter5-fn1"></a>1: Разница в том, что <code>simple-equal</code> не обрабатывает строки. </em></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
