<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Предисловие</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Предисловие </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p><b>paradigm</b> <em>n</em> <b>1</b> пример или образец; <em>esp</em> выдающийся ясный или типичный пример.. -*Словарь английского языка Лонгмана*, 1984 </p>
</blockquote>
<p>Эта книга посвящена трем смежным темам: области искусственного интеллекта, или ИИ; навыкам компьютерного программирования; и языку программирования Common Lisp. Внимательные читатели этой книги могут рассчитывать на понимание основных вопросов и техник ИИ, понимание некоторых важных программ ИИ, а также умение читать, изменять и создавать программы с использованием Common Lisp. Приведенные в этой книге примеры призваны служить наглядными примерами хорошего стиля программирования - парадигмы программирования. Это также парадигмы исследования ИИ - исторически значимые программы, использующие широко применяемые методы для решения важных проблем.</p>
<p>Подобно тому, как гуманитарное образование включает в себя курс «великих книг» культуры, эта книга, на одном уровне, представляет собой курс «великих программ», определяющих культуру ИИ.<a href="#fnpreface-1">1</a></p>
<p>На другом уровне эта книга представляет собой высокотехнологичный сборник знаний, которые вам понадобятся для того, чтобы пройти путь от новичка в программировании на Lisp и стать экспертом. Части I и II разработаны, чтобы помочь новичку набрать скорость, но даже начинающему может быть трудно даже с этим материалом. К счастью, для начинающего доступно как минимум пять хороших текстов; см. страницу xiii для моих рекомендаций.</p>
<p>Слишком часто преподавание компьютерного программирования состоит из объяснения синтаксиса выбранного языка, показа студенту программы из 10 строк, а затем поросьбы к студенту писать программы. В этой книге мы используем подход, согласно которому лучший способ научиться писать - это читать (и, наоборот, хороший способ улучшить навыки чтения - это писать). После краткого введения в Lisp, мы сразу начинаем со сложных программ и просим читателя понять и внести небольшие изменения в эти программы.</p>
<p>Предпосылка этой книги в том, что вы можете написать что-то полезное и интересное только тогда, когда вы понимаете как то, что хорошо писать, и то как сказать что-то интересное. Это относится как к написанию программ, так и к написанию прозы. Как Керниган и Плаугер написали на обложке <em>Software Tools in Pascal:</em></p>
<blockquote class="doxtable">
<p>Хорошее программирование не учится на общих принципах, но только знакомясь с тем, как важные программы можно сделать чистыми, легко читаемыми, простыми в обслуживании и модификации, разработанными человеком, эффективными и надежными, с применением здравого смысла и хороших методов программирования. </p>
</blockquote>
<p>Тщательное изучение и имитация хороших программ приводит к лучшему написанию.</p>
<p>У гордого мастера часто возникает желание показать только законченную работу, без каких-либо указаний на фальстарты и ошибки, которые являются неудачной, но неизбежной частью творческого процесса. К сожалению, это нежелание раскрывать этот процесс является препятствием для обучения; студент математики, который видит красивое 10-строчное доказательство в учебнике, может удивляться его краткости, но не научится создавать такое доказательство. Эта книга пытается показать весь процесс программирования "всю его поднаготную суть". Каждая глава начинается с простой версии программы, которая работает на некоторых примерах, но не на других. В каждой главе показано, как можно анализировать эти сбои для создания все более сложных версий базовой программы. Таким образом, читатель может не только оценить конечный результат, но и увидеть, как учиться на ошибках и улучшать изначально неполный дизайн. Кроме того, читатель, который находит конкретную главу, слишком трудной, может перейти к следующей главе, получив некоторое представление о проблемной области и не перегружаясь деталями.</p>
<p>Эта книга представляет собой совокупность знаний, широко известных как «методы программирования ИИ», но следует признать, что в этой совокупности знаний нет четких границ. Безусловно, никто не может быть хорошим программистом ИИ, не будучи сначала хорошим программистом. Таким образом, в этой книге представлены темы (особенно в частях III и V), которые сами по себе не являются ИИ, но являются важной предпосылкой для любого практикующего ИИ.</p>
<h2>Почему Lisp? Почему Common Lisp?</h2>
<p>Lisp - один из старейших языков программирования, широко используемых сегодня. Существует много версий Lisp, каждая из которых имеет общие функции, но отличается по деталям. В этой книге мы используем версию Common Lisp, которая является наиболее распространенным стандартом. Лисп был выбран по трем причинам.</p>
<p>Во-первых, Lisp - самый популярный язык для программирования ИИ, особенно в США. Если вы собираетесь изучать язык, это может быть язык с растущей литературой, а не мертвый язык.</p>
<p>Во-вторых, Lisp позволяет легко фиксировать соответствующие обобщения при определении новых объектов. В частности, Lisp позволяет легко определять новые языки, специально предназначенные для рассматриваемой проблемы. Это особенно удобно в приложениях ИИ, которые часто манипулируют сложной информацией, которая легче всего представляется в какой-то новой форме. Lisp - один из немногих языков, который обеспечивает полную гибкость в определении и манипулировании программами и данными. Все языки программирования по определению предоставляют средства для определения программ, но многие другие языки ограничивают способы использования программ, ограничивают диапазон программ, которые могут быть определены, или требуют от программиста явного указания несущественных деталей.</p>
<p>В-третьих, Lisp позволяет очень быстро разработать рабочую программу. Программы на Лисп лаконичны и не загромождены деталями низкого уровня. Common Lisp предлагает необычайно большое количество полезных предопределенных объектов, включая более 700 функций. Среда программирования (например, средства отладки, инкрементные компиляторы, интегрированные редакторы и интерфейсы для оконных систем), которые окружают системы Lisp, обычно очень хороши. А динамическая, интерактивная природа Lisp позволяет легко экспериментировать и изменять программу во время ее разработки.</p>
<p>Следует отметить, что в Европе и Японии Пролог был так же популярен, как Лисп для работы с ИИ. Prolog разделяет большинство преимуществ Lisp с точки зрения гибкости и краткости. В последнее время Лисп приобрел популярность во всем мире, а Пролог становится все более известным в Соединенных Штатах. В результате средний работник ИИ сегодня, вероятно, будет двуязычным. В этой книге представлены ключевые идеи, лежащие в основе Пролога в главах 11 и 12, и используются эти идеи в последующих главах, в частности 20 и 21.</p>
<p>Диалект Lisp, известный как Scheme, также набирает популярность, но в основном для обучения и экспериментирования с дизайном и методами языка программирования, а не для написания больших программ ИИ. Scheme представлена в главах 22 и 23. Другие диалекты Lisp, такие как Franz Lisp, MacLisp, InterLisp, ZetaLisp и Standard Lisp, теперь считаются устаревшими. Единственный новый диалект Lisp, который был предложен в последнее время, это EuLisp, европейский Lisp. Несколько диалектов Лисп живут как встроенные языки расширения. Например, текстовый редактор Gnu Emacs использует elisp, а пакет автоматизированного проектирования AutoCad использует AutoLisp, производный от Xlisp. В будущем вполне вероятно, что Scheme станет популярным языком расширения, поскольку он небольшой, но мощный и имеет официально утвержденное стандартное определение.</p>
<p>Существует миф о том, что Лисп (и Пролог) являются языками «специального назначения», в то время как такие языки, как Паскаль и С, являются «универсальными». На самом деле, как раз наоборот. Pascal и C - специальные языки для управления регистрами и памятью компьютера в стиле фон Неймана. Большая часть их синтаксиса посвящена арифметическим и логическим выражениям, и, хотя они предоставляют некоторые средства для формирования структур данных, у них плохие механизмы для процедурной или управляющей абстракции. Кроме того, они предназначены для ориентированного на состояние стиля программирования: вычисления результата путем изменения значения(состояния) переменных с помощью операторов присваивания.</p>
<p>Лисп, с другой стороны, не имеет специального синтаксиса для арифметики. Сложение и умножение не более базисны, чем операции со списками, такие как добавление, или строковые операции, такие как преобразование в верхний регистр. Но Lisp предоставляет все, что вам нужно для программирования в целом: определение структур данных, функций и средств их объединения.</p>
<p>В Лиспе возможен доминирующий в присваивании, ориентированный на состояния стиль программирования, но кроме того, в Лиспе поддерживаются объектно-ориентированные, основанные на правилах и функциональные стили. Эта гибкость проистекает из двух ключевых особенностей Lisp: во-первых, Lisp обладает мощными <em>macro</em> средствами, которые можно использовать для расширения базового языка. Когда были изобретены новые стили программирования, другие языки вымерли; Lisp просто включил новые стили, определив некоторые новые макросы. Функционирование макросов в Лиспе возможно постольку, поскольку программы на Лиспе имеют вид простой структуры данных: списка. В первые дни, когда Лисп еще интерпретировался, большинство манипуляций с программами осуществлялось через эту структуру данных. В настоящее время Lisp чаще компилируется, чем интерпретируется, и программисты больше полагаются на второе замечательное и гибкое средство Lisp: <em>функцию(function)</em>. Конечно, другие языки имеют функции, но Lisp уникален тем, что позволяет создавать новые функции во время работы программы.</p>
<p>Гибкость Lisp позволяет ему адаптироваться при изменении стилей программирования, но, что более важно, Lisp может адаптироваться к вашей конкретной проблеме программирования. В других языках вы приспосабливаете свою проблему к языку; с помощью Lisp вы расширяете язык, чтобы он соответствовал вашей проблеме.</p>
<p>Благодаря своей гибкости Lisp успешно зарекомендовал себя как высокоуровневый язык для быстрого прототипирования в таких областях, как искусственный интеллект, графика и пользовательские интерфейсы. Lisp также был доминирующим языком для исследовательского программирования, где проблемы настолько сложны, что в начале проекта нет ясного видения решения. Большая часть ИИ подпадает под это определение.</p>
<p>Размер Common Lisp может быть как преимуществом, так и недостатком, в зависимости от вашего мировоззрения. В замечательной книге Дэвида Турецки (1989) для начинающих программистов акцент делается на простоте. Он предпочитает писать некоторые программы немного менее сжато, а не вводить новую эзотерическую функцию (он приводит в качестве примера "pushnew"). Такой подход вполне подходит для начинающих, но эта книга выходит далеко за рамки уровня новичка. Это означает ознакомление читателя с новыми особенностями языка, когда они уместны. В большинстве случаев новые функции описываются по мере их появления, но иногда объяснение деталей низкоуровневой функции отвлекает от объяснения работы программы. Принимая привилегию считаться "взрослым", читатель также берет на себя ответственность - поиска незнакомых терминов в соответствующем справочном источнике.</p>
<h2>Набросок книги</h2>
<p>Эта книга состоит из пяти частей</p>
<p>**Часть I ** представляет язык программирования Common Lisp.</p>
<p>Глава 1 дает краткое введение в виде небольших примеров, которые демонстрируют новые особенности Lisp. Она может быть безопасно пропущена или пролистана опытным программистом.</p>
<p>Глава 2 - это более расширенный пример, показывающий, как примитивы Lisp могут быть собраны вместе, чтобы сформировать программу. Она должна быть тщательно изучена новичком, и даже опытный программисту требуется просмотреть ее, чтобы почувствовать мой стиль программирования.</p>
<p>Глава 3 содержит обзор примитивов Lisp. Её можно просмотреть при первом чтении и использовать в качестве ссылки всякий раз, когда в тексте упоминается незнакомая функция.</p>
<p>Часть I была намеренно краткой, чтобы было больше места для представления реальных программ искусственного интеллекта. К сожалению, это означает, что для прояснения некоторых более эзотерических особенностей языка может потребоваться другой текст или справочник (или онлайновая справка). Мои рекомендации по текстам приведены на странице xiii.</p>
<p>Читатель может также обратиться к главе 25, которая предлагает некоторые советы по отладке и устранению неполадок.</p>
<p><b>Часть II</b> охватывает четыре ранних программы искусственного интеллекта, которые используют основанные на правилах методы сопоставления с образцом. Начав с относительно простых версий программ, а затем улучшая их и переходя к более сложным программам, читатель может постепенно приобрести все более продвинутые навыки программирования.</p>
<p>Глава 4 представляет собой реконструкцию GPS(General Problem Solver), общего решателя проблем. Реализация осуществляется в соответствии с подходом STRIPS.</p>
<p>Глава 5 описывает ELIZA, программу, имитирующую человеческий диалог. Далее следует глава, которая обобщает некоторые методы, используемые в GPS и ELIZA, и делает их доступными в качестве инструментов для использования в последующих программах.</p>
<p>Глава 7 охватывает STUDENT, программу, которая решает проблемы алгебры на уровне высшей школы.</p>
<p>Глава 8 разрабатывает небольшое подмножество программы MACSYMA для выполнения символьной алгебры, включая дифференциальное и интегральное исчисление. Его могут пропустить те, кто уклоняется от тяжелой математики.</p>
<p><b>Часть III</b> на мгновение отвлекается от ИИ, чтобы представить некоторые общие инструменты для более эффективного программирования. Читатель, освоивший материал этой части,может считаться продвинутым программистом Lisp.</p>
<p>Глава 9 - это детальное исследование методов повышения эффективности, сосредоточенное на кэшировании, индексировании, компиляции и задержке вычислений. Глава 10 охватывает вопросы эффективности более низкого уровня, таких как использование деклараций, предотвращение генерации мусора и выбор правильной структуры данных.</p>
<p>Глава 11 представляет язык пролог. Цель состоит в том, чтобы показать, как написать интерпретатор для другого языка, и представить важные особенности пролога, чтобы их можно было использовать там, где это уместно. Глава 12 показывает, как компилятор для Пролога может быть в 20-200 раз быстрее интерпретатора.</p>
<p>Глава 13 вводит объектно-ориентированное программирование в целом, а затем исследует Common Lisp Object System (CLOS).</p>
<p>Глава 14 обсуждаются преимущества и ограничения как логико-ориентированного, так и объектно-ориентированного программирования, а также разрабатывается формализм представления знаний с использованием всех методов части III.</p>
<p><b>Часть IV</b> охватывает некоторые продвинутые программы искусственного интеллекта.</p>
<p>Глава 15 использует методы части III, чтобы придумать гораздо более эффективную реализацию MACSYMA. Он использует идею канонической формы и заменяет очень общий подход к правилу перезаписи рядом более конкретных функций.</p>
<p>Глава 16 охватывает оболочку экспертной системы EMYCIN, систему основанной на правилах обратной цепочки, основанную на факторах определенности. Также кратко рассматривается медицинская экспертная система MYCIN.</p>
<p>Глава 17 описывает алгоритм Уолта маркировки линий для многогранников (с использованием меток Хаффмана-Клоуса). Обсуждаются различные подходы к распространению ограничений и обратному отслеживанию.</p>
<p>Глава 18 представляет программу, которая играет превосходную игру Отелло. Используемая методика альфа-бета-поиска подходит для широкого спектра игр с участием двух человек.</p>
<p>Глава 19 - это введение в обработку естественного языка. Он охватывает контекстно-свободную грамматику, анализ сверху вниз и снизу вверх, анализ диаграмм, а также некоторые семантические интерпретации и предпочтения.</p>
<p>Глава 20 расширяет лингвистический охват предыдущей главы и вводит логические грамматики, используя компилятор Prolog, разработанный в главе 11.</p>
<p>Глава 21 представляет собой довольно полную грамматику английского языка с использованием логического грамматического формализма. Обсуждаются проблемы перехода от простой идеи к реалистичной, всеобъемлющей программе.</p>
<p><b>Часть V</b> включает материал, который является периферийным для ИИ, но важен для любого серьезного программиста Lisp.</p>
<p>Глава 22 представлен диалект Лиспа - Scheme. Разрабатывается простой интерпретатор Scheme, затем правильный интерпертатор обрабатывающий хвостовую рекурсию, затем интерпретатор, который явно манипулирует продолжениями и поддерживает <code>call/cc</code>. Глава 23 представляет собой компилятор Scheme.</p>
<p>Глава 24 представлены функции, уникальные для американского Национального института стандартов (ANSI) Common Lisp. Они включают в себя макрос <code>loop</code>, а также обработку ошибок, красивую печать, ряды и последовательности, а также 9 пакетов(package) .</p>
<p>Глава 25 - это руководство по устранению неполадок и отладке Лисп-программ</p>
<p>В библиографии перечислено более 200 источников, а также имеется исчерпывающий указатель. Кроме того, в приложении представлен каталог общедоступных Лисп-программ.</p>
<h2>Как пользоваться этой книгой</h2>
<p>Предполагаемая аудитория этой книги широка: любой, кто хочет стать продвинутым программистом Lisp, и любой, кто хочет стать продвинутым практиком ИИ. В книге есть несколько рекомендуемых путей:</p>
<ul>
<li><em>Во вводном курсе ИИ:</em> сосредоточьтесь на частях I и II и, по крайней мере, на одном примере из части IV.</li>
<li><em>В продвинутом курсе программирования ИИ:</em> сосредоточьтесь на частях I, II и IV, пропуская главы, которые представляют меньший интерес, и добавляя столько частей III, сколько позволяет время.</li>
<li><em>В продвинутом курсе языков программирования:</em> сосредоточьтесь на частях I и V, с выборками из части III. Обложка главы 11 и 13 если подобный материал не представлен другим текстом.</li>
<li><em>Для профессионального программиста Lisp:</em> прочитайте как можно больше из книги и часто возвращайтесь к ней. Часть III и глава 25 особенно важны.</li>
</ul>
<h2>Дополнительные тексты и справочники</h2>
<p>The definitive reference source is Steele's <em>Common Lisp the Language</em>. From 1984 to 1990, this unambiguously defined the language Common Lisp. However, in 1990 the picture became more complicated by the publication of <em>Common Lisp the Language</em>, 2d edition. This book, also by Steele, contains the recommendations of ANSI subcommittee X3J13, whose charter is to define a standard for Lisp. These recommendations include many minor changes and clarifications, as well as brand new material on object-oriented programming, error condition handling, and the loop macro. The new material doubles the size of the book from 465 to 1029 pages.</p>
<p>Until the ANSI recommendations are formally accepted, Common Lisp users are in the unfortunate situation of having two distinct and incompatible standards: "original" Common Lisp and ANSI Common Lisp. Most of the code in this book is compliant with both standards. The most significant use of an ANSI function is the <code>loop</code> macro. The ANSI <code>map-into</code>, <code>complement</code>, and <code>reduce</code> functions are also used, although rarely. Definitions for all these functions are included, so even those using an "original" Common Lisp system can still run all the code in the book.</p>
<p>While <em>Common Lisp the Language</em> is the definitive standard, it is sometimes terse and can be difficult for a beginner. <em>Common Lisp: the Reference</em>, published by Franz Inc., offers complete coverage of the language with many helpful examples. <em>Common LISPcraft</em>, by Robert Wilensky, and <em>Artificial Intelligence Programming</em>, by Charniak et al., also include brief summaries of the Common Lisp functions. They are not as comprehensive, but that can be a blessing, because it can lead the reader more directly to the functions that are important (at least in the eyes of the author).</p>
<p>Хорошей идеей, будет чтение этой книги с компьютером под рукой, чтобы попробовать примеры и экспериментировать с вашими собственными примерами. Компьютер-это также удобно, потому что Lisp является самодокументирующимся, с помощью функции <code>apropos</code>, <code>describe</code> и <code>documentation</code>. Многие реализации также предоставляют более обширную документацию с помощью какой-то команды <code>help</code> или меню.</p>
<p>The five introductory Lisp textbooks I recommend are listed below. The first is more elementary than the others.</p>
<ul>
<li><em>Common Lisp: A Gentle Introduction to Symbolic Computation</em> by David Touretzky. Most appropriate for beginners, including those who are not computer scientists.</li>
<li><em>A Programmer's Guide to Common Lisp</em> by Deborah G. Tatar. Appropriate for those with experience in another programming language, but none in Lisp.</li>
<li><em>Common LISPcraft</em> by Robert Wilensky. More comprehensive and faster paced, but still useful as an introduction as well as a reference.</li>
<li><em>Common Lisp</em> by Wade L. Hennessey. Somewhat hit-and-miss in terms of the topics it covers, but with an enlightened discussion of implementation and efficiency issues that do not appear in the other texts.</li>
<li><em>LISP</em> (3d edition) by Patrick H. Winston and Bertold Horn. Covers the most ground in terms of programming advice, but not as comprehensive as a reference. May be difficult for beginners. Includes some AI examples.</li>
</ul>
<p>While it may be distracting for the beginner to be continually looking at some reference source, the alternative-to have this book explain every new function in complete detail as it is introduced-would be even more distracting. It would interrupt the description of the AI programs, which is what this book is all about.</p>
<p>There are a few texts that show how to write AI programs and tools, but none that go into the depth of this book. Nevertheless, the expert AI programmer will want to be familiar with all the following texts, listed in rough order of increasing sophistication:</p>
<ul>
<li><em>LISP</em> (3d edition). (See above.)</li>
<li><em>Programming Paradigms in Lisp</em> by Rajeev Sangal. Presents the different styles of programming that Lisp accommodates, illustrating them with some useful AI tools.</li>
<li><em>Programming for Artificial Intelligence</em> by Wolfgang Kreutzer and Bruce McKenzie. Covers some of the basics of rule-based and pattern-matching systems well, but covers Lisp, Prolog, and Smalltalk, and thus has no time left for details in any of the languages.</li>
<li><em>Artificial Intelligence Programming</em> (2d edition) by Eugene Charniak, Christopher Riesbeck, Drew McDermott, and James Meehan. Contains 150 pages of Lisp overview, followed by an advanced discussion of AI tools, but no actual AI programs.</li>
<li><em>AI in Practice: Examples in Pop-11</em> by Allan Ramsey and Rosalind Barrett. Advanced, high-quality implementations of five AI programs, unfortunately using a language that has not gained popularity.</li>
</ul>
<p>The current text combines the virtues of the last two entries: it presents both actual AI programs and the tools necessary to build them. Furthermore, the presentation is in an incremental fashion, with simple versions presented first for clarity, followed by more sophisticated versions for completeness.</p>
<h2>Замечание об Упражнениях</h2>
<p>Примеры упражнений приведены повсюду. Читатели могут проверить свой уровень понимания, добросовестно выполняя упражнения. Упражнения оцениваются по шкале [s], [m], [h], [d], которая может быть интерпретирована либо как уровень сложности, либо как ожидаемое время, необходимое для выполнения упражнения:</p>
<table class="doxtable">
<tr>
<th>Код </th><th>Сложность </th><th>Время вып.  </th></tr>
<tr>
<td>[s] </td><td>Simple </td><td>Seconds </td></tr>
<tr>
<td>[m] </td><td>Medium </td><td>Minutes </td></tr>
<tr>
<td>[h] </td><td>Hard </td><td>Hours </td></tr>
<tr>
<td>[d] </td><td>Difficult </td><td>Days </td></tr>
</table>
<p>Время выполнения упражнения измеряется с точки зрения того, что концепции были хорошо поняты. Если читателю неясны лежащие в основе концепции, то для понимания проблемы [m] может потребоваться несколько часов обзора. Ответы на упражнения можно найти в отдельном разделе в конце каждой главы.</p>
<h2>Благодарности</h2>
<p>A great many people contributed to this book. First of all I would like to thank my students at USC and Berkeley, as well as James Martin's students at Colorado and Michael Pazzani's students at Irvine, who course-tested earlier versions of this book. Useful suggestions, corrections, and additions were made by:</p>
<p>Nina Amenta (Berkeley), Ray S. Babcock and John Paxton (Montana State), Bryan A. Bentz (BBN), Mary P. Boelk (Johnson Controls), Michael Braverman (Berkeley), R. Chandrasekar and M. Sasikumar (National Centre for Software Technology, Bombay), Mike Clancy (Berkeley), Michael Covington (Georgia), Bruce D'Ambrosio (Oregon State), Piew Datta (Irvine), Shawn Dettrey (USC), J. A. Durieux (AI Engineering BV, Amsterdam), Joseph Faletti (ETS), Paul Fuqua (Texas Instruments), Robert Goldman (Tulane), Marty Hall (Johns Hopkins), Marti Hearst (Berkeley), Jim Hendler (Maryland), Phil Laird (NASA), Raymond Lang (Tulane), David D. Loeffler (MCC), George Luger (New Mexico), Rob MacLachlan (CMU), Barry Margolin (Thinking Machines), James Mayfield (UMBC), Sanjay Manchandi (Arizona), Robert McCartney (Connecticut), James Meehan (DEC), Andrew L. Ressler, Robert S. Rist (University of Technology, Sydney), Paul Snively (Apple), Peter Van Roy (Berkeley), David Gumby Wallace (Cygnus), and Jeff Wu (Colorado).</p>
<p>Sam Dooley and Eric Wefald both wrote Othello-playing programs without which I would not have written chapter 18. Eric also showed me Aristotle's quotes on means-ends analysis. Tragically, Eric died in August 1989. He is sorely missed by his friends and colleagues. Richard Fateman made suggestions for chapter 8, convinced me to write chapter 15, and, with help from Peter Klier, wrote a substantial program from which I adapted some code for that chapter. Charley Cox (Franz Inc.), Jamie Zawinski (Lucid Inc.), and Paul Fuqua (Texas Instruments) explained the inner workings of their respective companies' compilers. Mike Harrison, Paul Hilfinger, Marc Luria, Ethan Munson, and Stephan Slade helped with LATEX. Narciso Jarimillo tested all the code and separated it into the files that are available to the reader (see page 897).</p>
<p>During the writing of this book I was supported by a grant from the Defense Advanced Research Projects Agency (DoD), Arpa Order No. 4871, monitored by Space and Naval Warfare Systems Command under Contract N00039-84-C-0089. Special thanks to DARPA and to Robert Wilensky and the rest of my colleagues and students at Berkeley for providing a stimulating environment for research, programming, and writing.</p>
<p>Finally, thanks to Mike Morgan and Yonie Overton for overseeing the production of the book and encouraging me to finish on time. </p><hr/>
<p><a href="#tfnpreface-1">1</a> This does not imply that the programs chosen are the best of all AI programs-just that they are representative. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
