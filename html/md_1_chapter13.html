<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 13</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 13 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Объектно-Ориентированное Программирование</h2>
<p>Программы в этой книге охватывают широкий круг задач. Вполне естественно, что для решения этих проблем был введен широкий спектр стилей программирования. Еще не рассмотренный стиль, завоевавший популярность в последние годы, называется объектно-ориентированным программированием. Чтобы понять, что влечет за собой объектно-ориентированное программирование, нам нужно поместить его в контекст других стилей.</p>
<p>Исторически первые компьютерные программы были написаны в стиле <em>императивного программирования</em>. Программа была построена как последовательность инструкций, каждая из которых выполняет какое-либо действие: изменение значения ячейки памяти, печать результата и т. д. Ассемблер - пример императивного языка.</p>
<p>По мере роста опыта (и амбиций) программисты искали способы контролировать сложность программ. Изобретение подпрограмм обозначило стиль <em>алгоритмического</em> или <em>процедурного программирования</em>, подкласса императивного стиля. Подпрограммы полезны по двум причинам: разбиение проблемы на маленькие части упрощает понимание каждой части, а также дает возможность повторно использовать части. Примерами процедурных языков являются FORTRAN, C, Pascal и Lisp с <code>setf</code>.</p>
<p>Подпрограммы по-прежнему зависят от глобального состояния, поэтому они не являются полностью отдельными частями. Использование большого количества глобальных переменных подвергалось критике как фактор, затрудняющий разработку и сопровождение больших программ. Чтобы устранить эту проблему, придуман стиль <em>функционального программирования</em> требующий, чтобы функции обращались только к переданным им параметрам и всегда возвращали один и тот же результат для тех же входных данных. Функциональные программы имеют то преимущество, что они математически чисты - их свойства легко доказать. Однако некоторые приложения более естественно воспринимаются как выполняющие действия, а не вычисляющие функциональные значения, и поэтому их неестественно программировать в функциональном стиле. Примерами функциональных языков являются FP и Lisp без <code>setf</code>.</p>
<p>В отличие от императивных языков есть <em>декларативные</em> языки, которые пытаются выразить "что делать", а не "как это сделать". Один из типов декларативного программирования - это программирование <em>основанное на правилах</em>, где набор правил определяет, как преобразовать проблему в решение. Примерами систем на основе правил являются ELIZA и STUDENT.</p>
<p>Важным видом декларативного программирования является <em>логическое программирование</em>, в котором аксиомы используются для описания ограничений, а вычисления выполняются путем конструктивного доказательства цели. Примером логичесого языка является Пролог.</p>
<p><em>Объектно-ориентированное программирование</em> - еще один способ решить проблему глобального состояния. Вместо того, чтобы запрещать глобальное состояние (как это делает функциональное программирование), объектно-ориентированное программирование разбивает непослушную массу глобального состояния и инкапсулирует его на небольшие управляемые части или объекты. В этой главе рассматривается объектно-ориентированный подход.</p>
<h2>13.1 Объектно-Ориентированное Программирование(Object-Oriented Programming)</h2>
<p>Объектно-ориентированное программирование переворачивает мир вычислений на свою сторону: вместо того, чтобы рассматривать программу в первую очередь как набор действий, которые манипулируют объектами, она рассматривается как набор объектов, которыми управляют действия. Состояние каждого объекта и действия, которые управляют этим состоянием, определяются раз и навсегда при создании объекта. Это может привести к появлению модульных и надежных систем, которые легко использовать и расширять. Это также может сделать системы более близкими к "реальному миру", который нам, людям, легче воспринимается как состоящий из объектов, а не действий. Примерами объектно-ориентированных языков являются Simula, C++ и CLOS - объектная система Common Lisp. Эта глава сначала представит объектно-ориентированное программирование в целом, а затем сконцентрируется на объектной системе Common Lisp.</p>
<p>Многие люди продвигают объектно-ориентированное программирование как решение проблемы разработки программного обеспечения, но трудно заставить людей прийти к единому мнению о том, что такое объектная ориентация. <a href="B9780080571157500285.xhtml#bb1355">Питер Вегнер, 1987</a> предлагает следующую формулу в качестве определения:</p>
<p><em>Object-orientation = Objects + Classes + Inheritance</em> (Объектно ориентированное = Объекты + Классы + Наследование)</p>
<p>Вкратце, <em>объекты</em> - это модули, которые инкапсулируют некоторые данные и операции с этими данными. Идея <em>сокрытия информации</em> - изоляции представления этих данных от операций вне объекта - является важной частью этой концепции. <em>Классы</em> - это группы похожих объектов с одинаковым поведением. Объекты называются экземплярами классов. <em>Наследование</em> - это средство определения новых классов как вариантов существующих классов. Новый класс наследует поведение родительского класса, и программисту нужно только указать, чем новый класс отличается.</p>
<p>Объектно-ориентированный стиль приносит с собой новый словарь, который кратко изложен в следующем глоссарии. Каждый термин будет объяснен более подробно, когда он появится.</p>
<p><em>Класс(class):</em> Группа похожих объектов с одинаковым поведением.</p>
<p><em>переменная класса(class variable):</em> Переменная, совместно используемая всеми членами класса.</p>
<p>*делегирование(delegation): * Передача сообщения от объекта одному из его компонентов.</p>
<p><em>Обобщенная функция(generic function):</em> Функция, которая принимает различные типы или классы аргументов.</p>
<p>*наследование(inheritance): * средство определения новых классов как вариантов существующих классов.</p>
<p><em>Экземпляр(instance):</em> Экземпляр класса - это объект.</p>
<p><em>экземпляр переменной(instance variable):</em> Переменная, заключенная в объект.</p>
<p><em>Сообщение(message):</em> Имя действия. Эквивалентно обобщенной функции.</p>
<p><em>Метод(method):</em> Средство обработки сообщения для определенного класса.</p>
<p><em>Мультиметод(multimethod):</em> Метод, зависящий от нескольких аргументов.</p>
<p><em>Множественное наследование(multiple inheritance):</em> Наследование от более чем одного родительского класса.</p>
<p><em>Объект(object):</em> Инкапсуляция локального состояния и поведения.</p>
<h2>13.2 Объекты</h2>
<p>Объектно-ориентированное программирование, по определению, связано с <em>объектами</em>. Любые данные, которые могут быть сохранены в памяти компьютера, можно рассматривать как объект. Таким образом, число 3, атом x и строка <code>"hello"</code> - это всё объекты. Обычно, как мы увидим, термин <em>объект</em> используется для обозначения более сложного объекта.</p>
<p>Конечно, всё программирование связано с объектами и процедурами, работающими с этими объектами. Написание программы для решения конкретной проблемы обязательно потребует написания определений как для объектов, так и для процедур. Что отличает объектно-ориентированное программирование, так это то, что основной способ декомпозиции проблемы на модули основан на объектах, а не на процедурах. Разницу лучше всего увидеть на примере. Вот простая программа для создания банковских счетов и отслеживания снятия средств, депозитов и накопления процентов. Во-первых, программа написана в традиционном процедурном стиле:</p>
<div class="fragment"><div class="line">(defstruct account</div><div class="line">  (name &quot;&quot;) (balance 0.00) (interest-rate .06))</div><div class="line"></div><div class="line">(defun account-withdraw (account amt)</div><div class="line">  &quot;Make a withdrawal from this account.&quot;</div><div class="line">  (if (&lt;= amt (account-balance account))</div><div class="line">      (decf (account-balance account) amt)</div><div class="line">      &#39;insufficient-funds))</div><div class="line"></div><div class="line">(defun account-deposit (account amt)</div><div class="line">  &quot;Make a deposit to this account.&quot;</div><div class="line">  (incf (account-balance account) amt))</div><div class="line"></div><div class="line">(defun account-interest (account)</div><div class="line">  &quot;Accumulate interest in this account.&quot;</div><div class="line">  (incf (account-balance account)</div><div class="line">        (* (account-interest-rate account)</div><div class="line">           (account-balance account))))</div></div><!-- fragment --><p>Мы можем создавать новые банковские счета с помощью <code>make-account</code> и изменять их с помощью <code>account-withdraw, account-deposit</code> и <code>account-interest</code>. Это простая проблема, и этого простого решения достаточно. Проблемы возникают, когда мы меняем спецификацию проблемы или когда мы предполагаем, что эта реализация может быть случайно использована по ошибке. Например, предположим, что программист смотрит на структуру <code>account</code> и решает использовать <code>(decf (account-balance account)</code>) напрямую вместо того, чтобы использовать функцию <code>account-remove</code>. Это могло привести к отрицательному сальдо счетов, чего не планировалось. Или предположим, что мы хотим создать новый тип учетной записи, в которой одновременно может быть снята только определенная максимальная сумма. Невозможно гарантировать, что <code>account-withdraw</code> не будет применяться к этой новой ограниченной учетной записи.</p>
<p>Проблема в том, что после создания счета(account) мы не можем контролировать, какие действия к нему будут применены. Объектно-ориентированный стиль предназначен для обеспечения такого контроля. Вот та же программа, написанная в объектно-ориентированном стиле (с использованием простого Lisp):</p>
<div class="fragment"><div class="line">(defun new-account (name &amp;optional (balance 0.00)</div><div class="line">                    (interest-rate .06))</div><div class="line">  &quot;Create a new account that knows the following messages:&quot;</div><div class="line">  #&#39;(lambda (message)</div><div class="line">      (case message</div><div class="line">        (withdraw #&#39;(lambda (amt)</div><div class="line">                      (if (&lt;= amt balance)</div><div class="line">                          (decf balance amt)</div><div class="line">                          &#39;insufficient-funds)))</div><div class="line">        (deposit  #&#39;(lambda (amt) (incf balance amt)))</div><div class="line">        (balance  #&#39;(lambda () balance))</div><div class="line">        (name     #&#39;(lambda () name))</div><div class="line">        (interest #&#39;(lambda ()</div><div class="line">                      (incf balance</div><div class="line">                            (* interest-rate balance)))))))</div></div><!-- fragment --><p>Функция <code>new-account</code> создает объекты счета, которые реализованы как замыкания, которые инкапсулируют три переменные: имя, баланс и процентную ставку счета. Объект счет(account) также инкапсулирует функции для обработки пяти сообщений, на которые объект может ответить. Объект account может делать только одно: получать сообщение и возвращать соответствующую функцию для выполнения этого сообщения. Например, если вы передадите сообщение объекту account <code>withdraw</code>, он вернет функцию, которая при применении к одному аргументу (сумме для снятия) выполнит действие по снятию средств. Эта функция называется <em>методом</em>, реализующим сообщение. Преимущество этого подхода в том, что объекты account полностью инкапсулированы; информация, соответствующая имени, балансу и процентной ставке, доступна только через пять сообщений. У нас есть гарантия, что никакой другой код не сможет манипулировать информацией в account каким-либо иным образом. <a href="#fn0015">1</a></p>
<p>Функция <code>get-method</code> находит метод, реализующий сообщение для данного объекта. Функция <code>send</code> получает метод и применяет его к списку аргументов. Название <code>send</code> происходит от объектно-ориентированной системы Flavors, которая обсуждается в разделе истории.(<a href="#p456">page 456</a>).</p>
<div class="fragment"><div class="line">(defun get-method (object message)</div><div class="line">  &quot;Return the method that implements message for this object.&quot;</div><div class="line">  (funcall object message))</div><div class="line"></div><div class="line">(defun send (object message &amp;rest args)</div><div class="line">  &quot;Get the function to implement the message,</div><div class="line">  and apply the function to the args.&quot;</div><div class="line">  (apply (get-method object message) args))</div></div><!-- fragment --><p>Вот пример использования <code>new-account</code> и <code>send</code>:</p>
<p><code>&gt; (setf acct (new-account "J.
Random Customer" 1000.00))</code>=&gt;</p>
<div class="fragment"><div class="line">#&lt;CLOSURE 23652465&gt;</div><div class="line">&gt; (send acct &#39;withdraw 500.00) =&gt; 500.0</div><div class="line">&gt; (send acct &#39;deposit 123.45) =&gt; 623.45</div></div><!-- fragment --><p><code>&gt; (send acct 'name) =&gt; "J.
Random Customer"</code></p>
<div class="fragment"><div class="line">&gt; (send acct &#39;balance) =&gt; 623.45</div></div><!-- fragment --><h2>13.3 Обобщенные функции</h2>
<p>Синтаксис send неудобен, так как он отличается от обычного синтаксиса вызова функций Lisp и не подходит для других инструментов Lisp. Например, мы могли бы сказать (<code>mapcar 'balance accounts</code>), но в сообщениях мы должны написать это как:</p>
<div class="fragment"><div class="line">(mapcar #&#39;(lambda (acct) (send acct &#39;balance)) accounts)</div></div><!-- fragment --><p>Мы можем решить эту проблему, определив <em>обобщенные</em> функции, которые находят правильный метод для выполнения сообщения. Например, мы могли бы определить:</p>
<div class="fragment"><div class="line">(defun withdraw (object &amp;rest args)</div><div class="line">  &quot;Define withdraw as a generic function on objects.&quot;</div><div class="line">  (apply (get-method object &#39;withdraw) args))</div></div><!-- fragment --><p>а затем написать <code>(withdraw acct x)</code> вместо <code>(send acct 'withdraw x)</code>. Функция <code>withdraw</code> является обобщенной, потому что она работает не только с объектами account, но также работает с любым другим классом объектов, которые обрабатывают сообщение <code>withdraw</code>. Например, у нас может быть совершенно не связанный класс, <code>army</code>, который также реализует метод <code>withdraw</code>. Затем мы могли бы сказать <code>(send 5th-army 'withdraw)</code> или <code>(withdraw 5th-army)</code> и выполнить правильный метод. Таким образом, объектно-ориентированное программирование устраняет многие проблемы, связанные с конфликтами имен, которые возникают в обычных программах.</p>
<p>Многие встроенные функции Common Lisp можно считать обобщенными, поскольку они работают с разными типами данных. Например, sqrt выполняет одно действие при передаче целого числа и совсем другое при передаче мнимого числа. Функции работы с последовательностями (например, find или delete) работают со списками, векторами или строками. Эти функции не реализованы, как <code>withdraw</code>, но они по-прежнему действуют как обобщенные функции.<a href="#fn0020">2</a></p>
<h2>13.4 Классы</h2>
<p>Можно писать макросы, чтобы упростить чтение и запись в объектно-ориентированном стиле. Макрос <code>define-class</code> определяет класс со связанными с ним методами обработки сообщений. Он также определяет обобщенную функцию для каждого сообщения. Наконец, он позволяет программисту различать переменные, которые связаны с каждым объектом, и переменные, которые связаны с классом и являются общими для всех членов класса. Например, вы можете захотеть, чтобы все экземпляры класса <code>account</code> имели одинаковую процентную ставку, но не хотели бы, чтобы у них был одинаковый баланс.</p>
<div class="fragment"><div class="line">(defmacro define-class (class inst-vars class-vars &amp;body methods)</div><div class="line">  &quot;Define a class for object-oriented programming.&quot;</div><div class="line">  ;; Define constructor and generic functions for methods</div><div class="line">  `(let ,class-vars</div><div class="line">     (mapcar #&#39;ensure-generic-fn &#39;,(mapcar #&#39;first methods))</div><div class="line">     (defun ,class ,inst-vars</div><div class="line">       #&#39;(lambda (message)</div><div class="line">           (case message</div><div class="line">             ,@(mapcar #&#39;make-clause methods))))))</div><div class="line"></div><div class="line">(defun make-clause (clause)</div><div class="line">  &quot;Translate a message from define-class into a case clause.&quot;</div><div class="line">  `(,(first clause) #&#39;(lambda ,(second clause) .,(rest2 clause))))</div><div class="line"></div><div class="line">(defun ensure-generic-fn (message)</div><div class="line">  &quot;Define an object-oriented dispatch function for a message,</div><div class="line">  unless it has already been defined as one.&quot;</div><div class="line">  (unless (generic-fn-p message)</div><div class="line">    (let ((fn #&#39;(lambda (object &amp;rest args)</div><div class="line">                  (apply (get-method object message) args))))</div><div class="line">      (setf (symbol-function message) fn)</div><div class="line">      (setf (get message &#39;generic-fn) fn))))</div><div class="line"></div><div class="line">(defun generic-fn-p (fn-name)</div><div class="line">  &quot;Is this a generic function?&quot;</div><div class="line">  (and (fboundp fn-name)</div><div class="line">       (eq (get fn-name &#39;generic-fn) (symbol-function fn-name))))</div></div><!-- fragment --><p>Теперь мы определяем класс account с помощью этого макроса. Мы делаем процентную ставку - <code>interest-rate</code> переменной класса, которая используется всеми экземплярами account:</p>
<div class="fragment"><div class="line">(define-class account (name &amp;optional (balance 0.00))</div></div><!-- fragment --> <pre class="fragment">            `((interest-rate .06))`
</pre><p><code>(withdraw (amt) (if (&lt;= amt balance)</code> </p><pre class="fragment">                  `(decf balance amt)`

                  `'insufficient-funds))`
</pre><p><code>(deposit (amt) (incf balance amt))</code></p>
<p><code>(balance () balance)</code></p>
<p><code>(name () name)</code></p>
<p><code>(interest () (incf balance (* interest-rate balance))))</code></p>
<p>Здесь мы используем обобщенные функции, определенные этим макросом:</p>
<p><code>&gt; (setf acct2 (account "A.
User" 2000.00)) =&gt; #&lt;CLOSURE 24003064&gt;</code></p>
<div class="fragment"><div class="line">&gt; (deposit acct2 42.00) =&gt; 2042.0</div><div class="line">&gt; (interest acct2) =&gt; 2164.52</div><div class="line">&gt; (balance acct2) =&gt; 2164.52</div><div class="line">&gt; (balance acct) =&gt; 623.45</div></div><!-- fragment --><p>В этой последней строке обобщенная функция <code>balance</code> применяется к <code>acct</code>, объекту, который был создан до того, как мы даже определили класс account и функцию <code>balance</code>. Но <code>balance</code> по-прежнему правильно работает с этим объектом, потому что он подчиняется протоколу передачи сообщений.</p>
<h2>13.5 Делегирование</h2>
<p>Предположим, мы хотим создать account нового типа, в котором для каждого действия требуется пароль. Мы можем определить новый класс <code>password-account</code>, который имеет два предложения сообщений. Первое предложение позволяет изменить пароль (если у вас есть исходный пароль), а второе - предложение <code>otherwise</code>, которое проверяет заданный пароль и, если он правильный, передает остальные аргументы account, который защищен паролем.</p>
<p>Определение <code>password-account</code> использует внутренние детали <code>define-class</code> двумя способами: оно использует тот факт, что <code>otherwise</code> может использоваться как универсальное предложение в форме <code>case</code>, и он использует тот факт, что диспетчерская переменная называется <code>message</code>. Обычно полагаться на подробности реализации макроса - не лучшая идея, и вскоре мы увидим более чистые способы определения классов. Но пока работает и этот простой подход:</p>
<div class="fragment"><div class="line">(define-class password-account (password acct) ()</div></div><!-- fragment --><p><code>(change-password (pass new-pass)</code> </p><pre class="fragment">        `(if (equal pass password)`

          `(setf password new-pass)`

          `'wrong-password))`
</pre><p><code>(otherwise (pass &amp;rest args)</code> </p><pre class="fragment">        `(if (equal pass password)`

          `(apply message acct args)`

          `'wrong-password)))`
</pre><p>Теперь мы видим, как класс <code>password-account</code> может использоваться для защиты существующего account:</p>
<div class="fragment"><div class="line">(setf acct3 (password-account &quot;secret&quot; acct2)) =&gt; #&lt;CLOSURE 33427277&gt;</div><div class="line">&gt; (balance acct3 &quot;secret&quot;) =&gt; 2164.52</div><div class="line">&gt; (withdraw acct3 &quot;guess&quot; 2000.00) =&gt; WRONG-PASSWORD</div><div class="line">&gt; (withdraw acct3 &quot;secret&quot; 2000.00) =&gt; 164.52</div></div><!-- fragment --><p>А теперь попробуем еще один пример. Предположим, мы хотим иметь новый класс счетов - account, у которого в любое время может быть снята только ограниченная сумма денег. Мы могли бы определить класс <code>limited-account</code>:</p>
<div class="fragment"><div class="line">(define-class limited-account (limit acct) ()</div></div><!-- fragment --><p><code>(withdraw (amt)</code> </p><pre class="fragment">        `(if (&gt; amt limit)`

              `'over-limit`

              `(withdraw acct amt)))`
</pre><p><code>(otherwise (&amp;rest args)</code> </p><pre class="fragment">        `(apply message acct args)))`
</pre><p>Это определение переопределяет сообщение <code>withdraw</code>, чтобы проверить, превышен ли лимит перед передачей сообщения, и использует предложение <code>withdraw</code> просто для передачи всех других сообщений без изменений. В следующем примере мы настраиваем account с паролем и лимитом:</p>
<div class="fragment"><div class="line">&gt; (setf acct4 (password-account &quot;pass&quot;</div></div><!-- fragment --> <pre class="fragment">          `(limited-account 100.00`

            `(account "A.
</pre><p> Thrifty Spender" 500.00))))`=&gt;</p>
<div class="fragment"><div class="line">#&lt;CLOSURE 34136775&gt;</div><div class="line">&gt; (withdraw acct4 &quot;pass&quot; 200.00) =&gt; OVER-LIMIT</div><div class="line">&gt; (withdraw acct4 &quot;pass&quot; 20.00) =&gt; 480.0</div><div class="line">&gt; (withdraw acct4 &quot;guess&quot; 20.00) =&gt; WRONG-PASSWORD</div></div><!-- fragment --><p>Обратите внимание, что такие функции, как <code>withdraw</code>, по-прежнему являются простыми обобщенными функциями, которые просто находят правильный метод и применяют его к аргументам. Хитрость в том, что каждый класс определяет свой способ обработки сообщения withdraw. Вызов <code>withdraw</code> с acct4 в качестве аргумента приводит к следующему потоку управления. Сначала метод класса <code>password-account</code> проверяет правильность пароля. Если это так, он вызывает метод из класса <code>limited-account</code>. Если лимит не превышен, мы, наконец, вызываем метод из класса <code>account</code>, который уменьшает баланс. Передача управления/контроля методу компонента называется <em>делегированием</em>.</p>
<p>Преимущество объектно-ориентированного стиля состоит в том, что мы можем ввести новый класс, написав одно локализованное определение, не требующее изменения какого-либо существующего кода. Если бы мы написали это в традиционном процедурном стиле, мы бы получили следующие функции:</p>
<div class="fragment"><div class="line">(defun withdraw (acct amt &amp;optional pass)</div></div><!-- fragment --><p><code>(cond ((and (typep acct 'password-account)</code> </p><pre class="fragment">          `(not (equal pass (account-password acct))))`

      `'wrong-password)`

      `((and (typep acct 'limited-account)`

          `(&gt; amt (account-limit account)))`

      `'over-limit)`

      `((&gt; amt balance)`

      `'insufficient-funds)`

      `(t (decf balance amt))))`
</pre><p>В этом нет ничего плохого, как в индивидуальной функции. Проблема в том, что, когда банк решает предложить новый тип счета(account), нам придется изменить эту функцию вместе со всеми другими функциями, реализующими действия. "Определение" нового счета(account) разрознено, а не локализовано, и изменение набора существующих функций обычно более подвержено ошибкам, чем написание нового определения класса.</p>
<h2>13.6 Наследование</h2>
<p>В следующей таблице типы данных (классы) перечислены по горизонтальной оси, а функции (сообщения) перечислены сверху в вниз по вертикальной оси. Полная программа должна заполнить все поля, но вопрос в том, как организовать процесс их заполнения. В традиционном процедурном стиле мы пишем определения функций, которые заполняют строку за раз. В объектно-ориентированном стиле мы пишем определения классов, которые заполняют столбец за раз. Третий стиль, <em>управляемый данными</em> или <em>обобщенный</em> стиль, заполняет только одно поле за раз.</p>
<table class="doxtable">
<tr>
<th></th><th><code>account limited-account</code> </th><th><code>password-account</code> </th><th><code>...</code>  </th></tr>
<tr>
<td><code>name</code> </td><td></td><td><em>object</em> </td><td></td></tr>
<tr>
<td><code>deposit</code> </td><td></td><td><em>oriented</em> </td><td></td></tr>
<tr>
<td><code>withdraw</code> </td><td><em>function oriented</em> </td><td></td><td></td></tr>
<tr>
<td><code>balance</code> </td><td></td><td></td><td></td></tr>
<tr>
<td><code>interest</code> </td><td><em>generic</em> </td><td></td><td></td></tr>
<tr>
<td><code>...</code> </td><td></td><td></td><td></td></tr>
</table>
<p>В этой таблице нет определенной организации ни для одной из осей; и сообщения, и классы перечислены в случайном порядке. Это игнорирует тот факт, что классы организованы иерархически: как limited-account, так и password-account являются подклассами account. Это подразумевается в определении классов, потому что и <code>limited-account</code> и <code>password-account</code> содержат счета в качестве компонентов и делегируют сообщения этим компонентам. Но было бы проще сделать эту связь явной.</p>
<p>Механизм <code>defstruct</code> допускает именно такое явное наследование. Если бы мы определили <code>account</code> как структуру, то мы могли бы определить <code>limited-account</code> с помощью:</p>
<div class="fragment"><div class="line">(defstruct (limited-account (:include account)) limit)</div></div><!-- fragment --><p>Для обеспечения возможности наследования классов необходимы две вещи. Во-первых, мы должны изменить <code>define-class</code> так, чтобы он принимал имя класса для наследования в качестве второго аргумента. Это будет сигналом того, что новый класс унаследует все переменные экземпляра, переменные класса и методы от родительского класса. Новый класс, конечно, может определять новые переменные и методы или может затенять родительские переменные и методы. В приведенной ниже форме мы определяем <code>limited-account</code> как подкласс <code>account</code>, который добавляет новую переменную экземпляра <code>limit</code> и переопределяет метод <code>withdraw</code>, чтобы он проверял суммы, превышающие лимит. Если сумма приемлема, то он использует функцию <code>call-next-method</code> (еще не определенную), чтобы получить метод <code>withdraw</code> для родительского класса <code>account</code>.</p>
<div class="fragment"><div class="line">(define-class limited-account account (limit) ()</div></div><!-- fragment --><p><code>(withdraw (amt)</code> </p><pre class="fragment">          `(if (&gt; amt limit)`

              `'over-limit`

              `(call-next-method))))`
</pre><p>Если наследование - это хорошо, то множественное наследование еще лучше. Например, предполагая, что мы определили классы <code>limited-account</code> и <code>password-account</code>, очень удобно определить следующий класс, который наследуется от них обоих:</p>
<div class="fragment"><div class="line">(define-class limited-account-with-password</div></div><!-- fragment --> <pre class="fragment">                  `(password-account limited-account))`
</pre><p>Обратите внимание, что этот новый класс не добавляет новых переменных или методов. Все, что он делает, это объединяет функциональность двух родительских классов в один.</p>
<p><b>Exercise 13.1 [d]</b> Определите версию <code>define-class</code>, которая обрабатывает наследование и <code>call-next-method</code></p>
<p><b>Exercise 13.2 [d]</b> Определите версию <code>define-class</code>, которая обрабатывает множественное наследование.</p>
<h2>13.7 CLOS: Common Lisp Object System - Объектная Система Common Lisp</h2>
<p>До сих пор мы разрабатывали объектно-ориентированную систему программирования с использованием макроса, <code>define-class</code> и протокола для реализации объектов как замыканий. Было много предложений по добавлению объектно-ориентированных функций в Lisp, некоторые из них похожи на наш подход, некоторые совсем другие. Недавно был одобрен один подход, который стал официальной частью Common Lisp, поэтому мы откажемся от нашего специального подхода и посвятим оставшуюся часть этой главы CLOS, объектной системе Common Lisp. Соответствие между нашей системой и CLOS резюмируется здесь:</p>
<table class="doxtable">
<tr>
<th>our system </th><th>CLOS  </th></tr>
<tr>
<td><code>define-class</code> </td><td><code>defclass</code> </td></tr>
<tr>
<td>*<code>methods defined in class</code>* </td><td><code>defmethod</code> </td></tr>
<tr>
<td>*<code>class-name</code>* </td><td><code>make-instance</code> </td></tr>
<tr>
<td><code>call-next-method</code> </td><td><code>call-next-method</code> </td></tr>
<tr>
<td><code>ensure-generic-fn</code> </td><td><code>ensure-generic-function</code> </td></tr>
</table>
<p>Как и большинство объектно-ориентированных систем, CLOS в первую очередь занимается определением классов и методов для них, а также созданием экземпляров этих классов. В CLOS макрос <code>defclass</code> определяет класс, <code>defmethod</code> определяет метод, а <code>make-instance</code> создает экземпляр класса - как объект. Общая форма макроса <code>defclass</code>:</p>
<p>(<code>defclass</code>*class-name* (<em>superclass...</em>) (<em>slot-specifier...</em>) <em>optional-class-option...</em>)</p>
<p>Опции классов используются редко. <code>defclass</code> может использоваться для определения класса <code>account</code>:</p>
<div class="fragment"><div class="line">(defclass account ()</div></div><!-- fragment --><p><code>((name :initarg :name ireader name)</code> </p><pre class="fragment">`(balance :initarg :balance :initform 0.00 :accessor balance)`

`(interest-rate :allocation :class :initform .06`

          `:reader interest-rate)))`
</pre><p>В определении учетной записи мы видим, что список суперклассов пуст, потому что account не наследуется ни от каких классов. Есть три спецификатора слотов: для слотов <code>name</code>, <code>balance</code> и <code>interest-rate</code>. За каждым именем слота могут следовать необязательные пары ключевое слово/значение, определяющие, как используется слот. В слоте <code>name</code> есть опция <code>:initarg</code>, которая говорит, что имя может быть указано при создании новой учетной записи с помощью <code>make-instance</code>. Слот <code>:reader</code> создает метод с именем <code>name</code> для получения текущего значения слота.</p>
<p>Слот баланса - balance имеет три опции: еще один <code>: initarg</code>, говорящий о том, что баланс может быть указан при создании новой учетной записи; <code>: initform</code>, который говорит, что если баланс не указан, по умолчанию он равен <code>0.00</code> и <code>: accessor</code>, который создает метод для получения значения слота так же, как <code>:reader</code>, а также создает метод обновления слота с помощью <code>setf</code>.</p>
<p>В слоте (процентная ставка)<code>interest-rate</code> есть опция <code>:initform</code> для присвоения ему значения по умолчанию и опция <code>:allocation</code>, указывающая, что этот слот является частью класса, а не каждого экземпляра класса.</p>
<p>Здесь мы видим создание объекта и применение к нему автоматически определенных методов.</p>
<div class="fragment"><div class="line">&gt; (setf al (make-instance &#39;account :balance 5000.00</div></div><!-- fragment --> <pre class="fragment">                      `:name "Fred")) =&gt; #&lt;ACCOUNT 26726272&gt;`
</pre><div class="fragment"><div class="line">&gt; (name al) =&gt; &quot;Fred&quot;</div><div class="line">&gt; (balance al) =&gt; 5000.0</div><div class="line">&gt; (interest-rate al) =&gt; 0.06</div></div><!-- fragment --><p>CLOS отличается от большинства объектно-ориентированных систем тем, что методы определяются отдельно от классов. Чтобы определить метод (помимо тех, которые автоматически определяются параметрами <code>:reader</code>, <code>:writer</code> или <code>:accessor</code>), мы используем макрос <code>defmethod</code>. По форме он похож на defun:</p>
<p><code>(defmethod</code>*method-name* (<em>parameter...</em>) <em>body...</em>)</p>
<p>Обязательные параметры для <code>defmethod</code> могут иметь форму (<em>var class</em>), что означает, что это метод, который применяется только когда аргументы являются экземплярами этого класса. Вот способ вывода средств(withdrawing) со счета. Обратите внимание, что CLOS не имеет понятия переменной экземпляра(instance variable), только слот экземпляра(instance slot). Поэтому мы должны использовать метод (<code>balance acct</code>), а не переменную экземпляра <code>balance</code>:</p>
<div class="fragment"><div class="line">(defmethod withdraw ((acct account) amt)</div></div><!-- fragment --><p><code>(if (&lt; amt (balance acct))</code></p>
<p><code>(decf (balance acct) amt)</code></p>
<p><code>'insufficient-funds))</code></p>
<p>С помощью CLOS легко определить <code>limited-account</code> как подкласс <code>account</code> и определить метод <code>withdraw</code> для <code>limited-accounts</code>:</p>
<div class="fragment"><div class="line">(defclass limited-account (account)</div></div><!-- fragment --><p><code>((limit :initarg :limit :reader limit)))</code></p>
<div class="fragment"><div class="line">(defmethod withdraw ((acct limited-account) amt)</div></div><!-- fragment --><p><code>(if (&gt; amt (limit acct))</code> </p><pre class="fragment">    `'over-limit`

    `(call-next-method)))`
</pre><p>Обратите внимание на использование <code>call-next-method</code> для вызова метода <code>withdraw</code> для класса <code>account</code>. Также обратите внимание, что все другие методы для счетов(account) автоматически работают с экземплярами класса <code>limited-account</code>, поскольку он определен как наследованик от <code>account</code>. В следующем примере мы показываем, что метод <code>name</code> наследуется, а метод <code>withdraw</code> для <code>limited-account</code> вызывается первым, а метод <code>withdraw</code> для account вызывается функцией <code>call-next-method</code>:</p>
<div class="fragment"><div class="line">&gt; (setf a2 (make-instance &#39;limited-account</div></div><!-- fragment --> <pre class="fragment">                    `:name "A.
</pre><p> Thrifty Spender"` </p><pre class="fragment">                    `:balance 500.00 :limit 100.00))`=&gt;
</pre><div class="fragment"><div class="line">#&lt;LIMITED-ACCOUNT 24155343&gt;</div></div><!-- fragment --><p><code>&gt; (name a2) =&gt; "A.
Thrifty Spender"</code></p>
<div class="fragment"><div class="line">&gt; (withdraw a2 200.00) =&gt; OVER-LIMIT</div><div class="line">&gt; (withdraw a2 20.00) =&gt; 480.0</div></div><!-- fragment --><p>В общем, для данного сообщения может быть несколько методов. В этом случае все подходящие методы собираются вместе и сортируются, в первую очередь ставяться наиболее конкретные/специфичные. Затем вызывается наиболее конкретный метод. Вот почему сначала вызывается метод для <code>limited-account</code>, а не метод для <code>account.</code>. Функция <code>call-next-method</code> может использоваться в теле метода для вызова следующего наиболее конкретного метода.</p>
<p>Полная история на самом деле даже сложнее, чем эта. В качестве одного из примеров усложнения рассмотрим класс <code>audited-account</code>, который распечатывает и отслеживает все депозиты и снятие средств. Его можно определить следующим образом, используя новую функциональность CLOS, методы <code>:before</code> и <code>:after</code>:</p>
<div class="fragment"><div class="line">(defclass audited-account (account)</div></div><!-- fragment --><p><code>((audit-trail :initform nil :accessor audit-trail)))</code></p>
<div class="fragment"><div class="line">(defmethod withdraw :before ((acct audited-account) amt)</div></div><!-- fragment --><p>`(push (print '(withdrawing ,amt))`</p>
<p><code>(audit-trail acct)))</code></p>
<div class="fragment"><div class="line">(defmethod withdraw :after ((acct audited-account) amt)</div></div><!-- fragment --><p>`(push (print '(withdrawal (,amt) done))`</p>
<p><code>(audit-trail acct)))</code></p>
<p>Теперь вызов функции <code>withdraw</code> с <code>audited-account</code> в качестве первого аргумента дает три применимых метода: основной метод из <code>account</code> и методы <code>:before</code> и <code>:after</code>. В общем, таких методов может быть несколько. В этом случае все методы <code>:before</code> вызываются по порядку, сначала наиболее конкретные. Затем вызывается наиболее конкретный первичный метод. Он может выбрать вызов <code>cal1-next-method</code> для доступа к другим методам. (Для метода :<code>before</code> или :<code>after</code> использование метода <code>call-next-method</code> является ошибкой.) Наконец, вызываются все методы :<code>after</code>, наименее специфичные в первую очередь.</p>
<p>Значения из методов <code>:before</code> и <code>:after</code> игнорируются, и возвращается значение из основного метода. Вот пример:</p>
<div class="fragment"><div class="line">&gt; (setf a3 (make-instance &#39;audited-account :balance 1000.00))</div><div class="line">#&lt;AUDITED-ACCOUNT 33555607&gt;</div><div class="line">&gt; (withdraw a3 100.00)</div><div class="line">(WITHDRAWING 100.0)</div><div class="line">(WITHDRAWAL (100.0) DONE)</div><div class="line">900.0</div><div class="line">&gt; (audit-trail a3)</div><div class="line">((WITHDRAWAL (100.0) DONE) (WITHDRAWING 100.0))</div><div class="line">&gt; (setf (audit-trail a3) nil)</div><div class="line">NIL</div></div><!-- fragment --><p>Последнее взаимодействие показывает самый большой недостаток CLOS: он не может инкапсулировать информацию. Чтобы сделать <code>audit-trail</code> доступным для методов <code>withdraw</code>, мы должны были предоставить ему методы доступа. Мы хотели бы инкапсулировать функцию записи для <code>audit-trail</code>, чтобы ее можно было использовать только с <code>депозитом</code> и <code>withdraw</code>. Но как только функция записи определена, ее можно использовать где угодно, поэтому недобросовестный посторонний может уничтожить журнал аудита(<code>audit-trail</code>), установив для него значение nil или что-то еще.</p>
<h2>13.8 A CLOS Example: Searching Tools</h2>
<p>CLOS является наиболее подходящим, когда есть несколько типов, которые разделяют связанное поведение. Хорошим примером приложения, которое соответствует этому описанию, является набор инструментов для поиска, определенных в <a href="B9780080571157500066.xhtml#s0025">разделе 6.4</a>. Там мы определили функции для поиска в ширину(breadth-first), в глубину(depth-first) и поиска первого лучшего(best-first), а также по дереву или графу. Мы также определили функции для поиска в определенных доменах(областях), таких как планирование маршрута между городами.</p>
<p>Если бы мы писали инструменты в простом, процедурном стиле, мы получили бы десятки похожих функций. Вместо этого мы использовали функции высшего порядка для управления сложностью. В этом разделе мы увидим как CLOS можно использовать для уменьшения сложности немного другим способом.</p>
<p>Начнем мы с определения класса поисковых задач. Задачи будут классифицироваться в соответствии с их предметной областью (планирование маршрутов и т.д.), их топологией (дерево или граф) и их стратегией поиска(в ширину(breadth-first) или в глубину(depth-first) и т.д.). Каждая комбинация этих признаков приводит к новому классу задач. Это позволяет пользователю легко добавлять новый класс для представления нового домена(области) или новой стратегии поиска. Базовый класс поисковых задач - <code>problem</code>, содержит переменную существующую в одном экземпляре для хранения неисследованных состояний задачи.</p>
<div class="fragment"><div class="line">(defclass problem ()</div></div><!-- fragment --><p><code>((states :initarg :states :accessor problem-states)))</code></p>
<p>Функция поиска - searcher аналогична функции <code>tree-search</code> из <a href="B9780080571157500066.xhtml#s0025">раздела 6.4</a>. Основное отличие состоит в том, что searcher использует обобщенные функции вместо передачи функциональных аргументов.</p>
<div class="fragment"><div class="line">(defmethod searcher ((prob problem))</div></div><!-- fragment --><p><code>"Find a state that solves the search problem."</code></p>
<p><code>(cond ((no-states-p prob) fail)</code></p>
<p><code>((goal-p prob) (current-state prob))</code></p>
<p><code>(t (let ((current (pop-state prob)))</code> </p><pre class="fragment">      `(setf (problem-states prob)`

          `(problem-combiner`

            `prob`

            `(problem-successors prob current)`

            `(problem-states prob))))`

    `(searcher prob))))`
</pre><p>searcher не предполагает, что состояния проблемы организованы в виде списка; скорее он использует обобщенную функцию <code>no-states-p</code> для проверки наличия каких-либо состояний, <code>pop-state</code> для удаления и возврата первого состояния и <code>current-state</code> для доступа к первому состоянию. Для базового класса <code>problem</code>, мы фактически реализуем состояния в виде списка, но другой класс задач(проблем) может использовать другое представление.</p>
<div class="fragment"><div class="line">(defmethod current-state ((prob problem))</div></div><!-- fragment --><p><code>"The current state is the first of the possible states."</code></p>
<p><code>(first (problem-states prob)))</code></p>
<div class="fragment"><div class="line">(defmethod pop-state ((prob problem))</div></div><!-- fragment --><p><code>"Remove and return the current state."</code></p>
<p><code>(pop (problem-states prob)))</code></p>
<div class="fragment"><div class="line">(defmethod no-states-p ((prob problem))</div></div><!-- fragment --><p><code>"Are there any more unexplored states?"</code></p>
<p><code>(null (problem-states prob)))</code></p>
<p>В <code>tree-search</code> мы включили оператор для вывода отладочной информации. Мы можем сделать это и здесь, но мы можем скрыть это в отдельном методе, чтобы не загромождать основное определение <code>searcher</code>. Это метод <code>:before</code>, поскольку мы ходтим увидеть вывод перед выполнением операции.</p>
<div class="fragment"><div class="line">(defmethod searcher :before ((prob problem))</div></div><!-- fragment --><p><code>(dbg 'search ";; Search: ~a" (problem-states prob)))</code></p>
<p>Обобщенные функции, которе еще предстоит определить, это <code>goal-p, problem-combiner,</code> и <code>problem-successors</code>. Сначала мы обратимся к <code>goal-p</code>, осознавая, что для многих проблем мы будем скать состояние, которое соответствует, в смысле - <code>eql</code> указанному состоянию цели. Мы определяем класс <code>eql-problem</code> для ссылки на такие проблемы, и указываем <code>goal-p</code> для этого класса. Обратите внимание, что мы позволяем указывать цель при создании проблемы, но не изменять цель:</p>
<div class="fragment"><div class="line">(defclass eql-problem (problem)</div></div><!-- fragment --><p><code>((goal rinitarg :goal :reader problem-goal)))</code></p>
<div class="fragment"><div class="line">(defmethod goal-p ((prob eql-problem))</div></div><!-- fragment --><p><code>(eql (current-state prob) (problem-goal prob)))</code></p>
<p>Теперь мы готовы определить две стратегии: поиск в глубину(depth-first) и поиск в ширину(breadth-first). Мы определяем классы задач для каждой стратегии и указываем функцию <code>problem-combiner</code>:</p>
<div class="fragment"><div class="line">(defclass dfs-problem (problem) ()</div></div><!-- fragment --><p><code>(:documentation "Depth-first search problem."))</code></p>
<div class="fragment"><div class="line">(defclass bfs-problem (problem) ()</div></div><!-- fragment --><p><code>(:documentation "Breadth-first search problem."))</code></p>
<div class="fragment"><div class="line">(defmethod problem-combiner ((prob dfs-problem) new old)</div></div><!-- fragment --><p><code>"Depth-first search looks at new states first."</code></p>
<p><code>(append new old))</code></p>
<div class="fragment"><div class="line">(defmethod problem-combiner ((prob bfs-problem) new old)</div></div><!-- fragment --><p><code>"Depth-first search looks at old states first."</code></p>
<p><code>(append old new))</code></p>
<p>Хотя этого кода будет достаточно длял наших целей, он далеко не идеален, поскольку разрушает барьер, скрывающей информацию. Он обрабатывает набор старых состояний как список, который используется по умолчанию для класса <code>problem</code>, но это не обзяательно является реализацией, которую будет использовать каждый класс. Было бы проще(чище) определить обобщенные функции <code>add-states-to-end</code> и <code>add-states-to-front</code>, а затем определить с их помощью <code>append</code> в классе по умолчанию. Но Лисп предоставляет такие удобные примитивы для работы со списками, что трудно избежать соблазна использовать их напрямую.</p>
<p>Конечно, пользователь определяющий новую реализацию для <code>problem-states</code> может просто переопределить <code>problem-combiner</code> для нарушающих классов, но это именно то, чего объектно-ориентированное программирование призвано избегать: указание однойо асбтрации (состояний/states) не долна нас заставлять что-либо менять в другой абстракции (стратегии поиска).</p>
<p>Последний шаг - это определение класса, представляющего определенный домен(область), и определение <code>problem-successors</code> для этого домена. В качестве первого примера рассмотрим простой поиск по бинарному дереву из <a href="B9780080571157500066.xhtml#s0025">раздела 6.4</a>. Естественно, он будет представлен в виде класса:</p>
<div class="fragment"><div class="line">(defclass binary-tree-problem (problem) ())</div><div class="line">(defmethod problem-successors ((prob binary-tree-problem) state)</div></div><!-- fragment --><p><code>(let ((n (* 2 state)))</code> </p><pre class="fragment">`(list n (+ n 1))))`
</pre><p>Теперь предположим мы хотим решить проблему определенную в виде бинарного дерева (binary-tree problem) с помощью поиска в ширину, ища конкретную цель. Просто создадим класс, который сочетает в <code>binary-tree-problem, eql-problem</code> и <code>bfs-problem,</code> создадим экземпляр этого класса и вызовем <code>searcher</code> для этого экземпляра:</p>
<div class="fragment"><div class="line">(defclass binary-tree-eql-bfs-problem</div></div><!-- fragment --> <pre class="fragment">        `(binary-tree-problem eql-problem bfs-problem) ())`
</pre><div class="fragment"><div class="line">&gt; (setf pl (make-instance &#39;binary-tree-eql-bfs-problem</div></div><!-- fragment --> <pre class="fragment">                      `:states '(1) :goal 12))`
</pre><div class="fragment"><div class="line">#&lt;BINARY-TREE-EQL-BFS-PROBLEM 26725536&gt;</div><div class="line">&gt; (searcher pl)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (2 3)</div><div class="line">;; Search: (3 4 5)</div><div class="line">;; Search: (4 5 6 7)</div><div class="line">;; Search: (5 6 7 8 9)</div><div class="line">;; Search: (6 7 8 9 10 11)</div><div class="line">;; Search: (7 8 9 10 11 12 13)</div><div class="line">;; Search: (8 9 10 11 12 13 14 15)</div><div class="line">;; Search: (9 10 11 12 13 14 15 16 17)</div><div class="line">;; Search: (10 11 12 13 14 15 16 17 18 19)</div><div class="line">;; Search: (11 12 13 14 15 16 17 18 19 20 21)</div><div class="line">;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)</div><div class="line">12</div></div><!-- fragment --><h3>Поиск первого лучшего(Best-First)</h3>
<p>Должно быть ясно, как продолжить определение поиска первый лучший(best-first): определить класс для представления задачи поиска первого лучшего, а затем определить необходимые методы для этого класса. Так как стратегия поиска влияет только на порядок в котором исследуются состояния, единственный необходимый метод - это <code>problem-combiner</code>.</p>
<div class="fragment"><div class="line">(defclass best-problem (problem) ()</div></div><!-- fragment --><p><code>(:documentation "A Best-first search problem."))</code></p>
<div class="fragment"><div class="line">(defmethod problem-combiner ((prob best-problem) new old)</div></div><!-- fragment --><p><code>"Best-first search sorts new and old according to cost-fn."</code></p>
<p>`(sort (append new old) #'&lt;` </p><pre class="fragment">      `:key #'(lambda (state) (cost-fn prob state))))`
</pre><p>Здесь вводится новая функция <code>cost-fn</code>; естественно, это будет обобщенная функция. Ниже приводится <code>cost-fn</code>, которая подходит для любой <code>eql-problem</code> имеющей дело с числами, но ожидается что большинство доменов(областей) будут сами определять эту функцию.</p>
<div class="fragment"><div class="line">(defmethod cost-fn ((prob eql-problem) state)</div></div><!-- fragment --><p><code>(abs (- state (problem-goal prob))))</code></p>
<p>Поиск по лучу - это модификация поиска первый лучший(best-first), где все состояния, кроме b лучших состояний, отбрасываются на каждой итерации. Задача поиска по лучу представлена классом, в котором переменная экземпляра <code>beam-width</code> содержит параметр <em>b</em>. Если он nil, то выполняется полный поиск первого лучшего(best-first). Поиск по лучу реализуется методом <code>:around</code> над <code>problem-combiner</code>. Он вызывает следующий метод, чтобы получить список состояний, полученных с помощью поиска первого лучшего(best-first), а затем извлекает <em>b</em> первых элементов.</p>
<div class="fragment"><div class="line">(defclass beam-problem (problem)</div></div><!-- fragment --><p><code>((beam-width :initarg :beam-width :initform nil</code> </p><pre class="fragment">            `:reader problem-beam-width)))`
</pre><div class="fragment"><div class="line">(defmethod problem-combiner :around ((prob beam-problem) new old)</div></div><!-- fragment --><p><code>(let ((combined (call-next-method)))</code> </p><pre class="fragment">`(subseq combined 0 (min (problem-beam-width prob)`

                    `(length combined)))))`
</pre><p>Теперь мы применяем поиск по лучу к задаче бинарного дерева(binary-tree problem). Как обычно, мы должны создать другой класс, чтобы представить этот тип проблемы:</p>
<div class="fragment"><div class="line">(defclass binary-tree-eql-best-beam-problem</div></div><!-- fragment --><p><code>(binary-tree-problem eql-problem best-problem beam-problem)</code></p>
<p><code>())</code></p>
<div class="fragment"><div class="line">&gt; (setf p3 (make-instance &#39;binary-tree-eql-best-beam-problem</div></div><!-- fragment --> <pre class="fragment">                      `:states '(1) :goal 12 :beam-width 3))`
</pre><div class="fragment"><div class="line">#&lt;BINARY-TREE-EQL-BEST-BEAM-PROBLEM 27523251&gt;</div><div class="line">&gt; (searcher p3)</div><div class="line">;; Search: (1)</div><div class="line">;; Search: (3 2)</div><div class="line">;; Search: (7 6 2)</div><div class="line">;; Search: (14 15 6)</div><div class="line">;; Search: (15 6 28)</div><div class="line">;; Search: (6 28 30)</div><div class="line">;; Search: (12 13 28)</div><div class="line">12</div></div><!-- fragment --><p>Пока аргументы в пользу CLOS неубедительны. Код в этом разделе дублирует функциональность кода из <a href="B9780080571157500066.xhtml#s0025">раздела 6.4</a>, но код CLOS имеет тенденцию быть более многословным, и несколько беспокоит то, что нам пришлось составлять так много длинных имен классов. Однако, такая многословность прибодит к гибкости и код CLOS проще расширить, добавив н овые специализированные классы. Полезно проводить различие между системным программистом и прикладным программистом. Системный программист предоставит библиотеку классов, подобную <code>dfs-problem</code> и обобщенных функций, таких как <code>searcher</code>. Затем прикладной программист просто выбирает из библиотеки то, что нужно. Из следующего мы видим, что выбрать правильный код для определения поисковика(searcher) планирования поездки не так уж и сложно. Сравните его с определением <code>trip</code> со страници 198, чтобы увидеть предпочтете ли вы CLOS в этом случае. Основное отличие состоит в том, что здесь мы говорим, что функция стоимости это <code>air-distance</code>, а преемники(successors) являются соседями - <code>neighbors</code> по определению методов; в <code>trip</code> мы сделали это, передав их в виде параметров. Последнее немного более кратко, но первое может быть более понятным, тем более что количество параметров растет.</p>
<div class="fragment"><div class="line">(defclass trip-problem (binary-tree-eql-best-beam-problem)</div></div><!-- fragment --><p><code>((beam-width :initform 1)))</code></p>
<div class="fragment"><div class="line">(defmethod cost-fn ((prob trip-problem) city)</div></div><!-- fragment --><p><code>(air-distance (problem-goal prob) city))</code></p>
<div class="fragment"><div class="line">(defmethod problem-successors ((prob trip-problem) city)</div></div><!-- fragment --><p><code>(neighbors city))</code></p>
<p>With the definitions in place, it is easy to use the searching tool:</p>
<div class="fragment"><div class="line">&gt; (setf p4 (make-instance &#39;trip-problem</div></div><!-- fragment --> <pre class="fragment">                    `:states (list (city 'new-york))`

                    `:goal (city 'san-francisco)))`
</pre><div class="fragment"><div class="line">#&lt;TRIP-PROBLEM 31572426&gt;</div><div class="line">&gt; (searcher p4)</div><div class="line">;; Search: ((NEW-YORK 73.58 40.47))</div><div class="line">;; Search: ((PITTSBURG 79.57 40.27))</div><div class="line">;; Search: ((CHICAGO 87.37 41.5))</div><div class="line">;; Search: ((KANSAS-CITY 94.35 39.06))</div><div class="line">;; Search: ((DENVER 105.0 39.45))</div><div class="line">;; Search: ((FLAGSTAFF 111.41 35.13))</div><div class="line">;; Search: ((RENO 119.49 39.3))</div><div class="line">;; Search: ((SAN-FRANCISCO 122.26 37.47))</div><div class="line">(SAN-FRANCISCO 122.26 37.47)</div></div><!-- fragment --><h2>13.9 Действительно ли CLOS Объектно-Ориентированный?</h2>
<p>Есть некоторые аргументы в пользу того, действительно ли CLOS вообще объектно-ориентирован. Аргументы следующие:</p>
<p>CLOS <em>является</em> объектно-ориентированной системой, потому что она обеспечивает все три основных критерия объектной ориентации: объекты с внутренним состоянием, классы объектов со специализированным поведением для каждого класса и наследованием между классами.</p>
<p>CLOS <em>не</em> объектно-ориентированная система, потому что она не предоставляет модульным объектам сокрытие информации. В примере <code>audited-account</code> мы хотели бы инкапсулировать переменную экземпляра <code>audit-trail</code>, чтобы только методы <code>withdraw</code> могли ее изменить. Но поскольку методы написаны отдельно от определений классов, мы не можем этого сделать. Вместо этого нам пришлось определить метод доступа для <code>audit-trail</code>. Это позволило нам написать методы <code>withdraw</code>, но также позволяет кому-либо еще изменить контрольный журнал.</p>
<p>CLOS является <em>более общей, чем</em> объектно-ориентированная система, потому что позволяет использовать методы, которые специализируются на более чем одном аргументе. В настоящих объектно-ориентированных системах методы связаны с объектами определенного класса. Эта ассоциация лексически очевидна (и метафора передачи сообщений ясна), когда мы пишем методы внутри определения класса, как в нашем макросе <code>define-class</code>. Метафора передачи сообщений по-прежнему очевидна, когда мы пишем обобщенные функции, применение которых определяется/выбирается по классу их первого аргумента, как мы до сих пор использовали CLOS.</p>
<p>Но методы CLOS могут определяться по классу любого требуемого аргумента или любой их комбинации. Рассмотрим следующее определение <code>conc</code>, которое похоже на <code>append</code>, за исключением того, что оно работает как для векторов, так и для списков. Вместо того, чтобы писать <code>conc</code> с использованием условных операторов, мы можем использовать возможности диспетчеризации мультиметодов CLOS для определения четырех случаев: (1) первый аргумент равен nil, (2) второй аргумент равен nil, (3) оба аргумента являются списками , и (4) оба аргумента являются векторами. Обратите внимание, что если один из аргументов равен nil, будут применяться два метода, но будет использоваться метод для <code>null</code>, потому что класс <code>null</code> более специфичен, чем класс <code>list</code>.</p>
<div class="fragment"><div class="line">(defmethod conc ((x null) y) y)</div><div class="line">(defmethod conc (x (y null)) x)</div><div class="line">(defmethod conc ((x list) (y list))</div></div><!-- fragment --><p><code>(cons (first x) (conc (rest x) y)))</code></p>
<div class="fragment"><div class="line">(defmethod conc ((x vector) (y vector))</div></div><!-- fragment --><p><code>(let ((vect (make-array (+ (length x) (length y)))))</code> </p><pre class="fragment">`(replace vect x)`

`(replace vect y :startl (length x))))`
</pre><p>Здесь мы видим, что это определение работает:</p>
<div class="fragment"><div class="line">&gt; (conc nil &#39;(a b c)) =&gt; (A B C)</div><div class="line">&gt; (conc &#39;(a b c) nil) =&gt; (A B C)</div><div class="line">&gt; (conc &#39;(a b c) &#39;(d e f)) =&gt; (A B C D E F)</div></div><!-- fragment --><p>`&gt; (conc '#(a b c) '#(d e f))<code>=&gt;</code>#(A B C D E F)`</p>
<p>Это работает, но можно спросить: а где объекты? Метафора передачи сообщения объекту здесь неприменима, если только мы не рассматриваем объект как список аргументов, а не как один привилегированный аргумент.</p>
<p>Поразительно, что этот стиль определения метода очень похож на стиль, используемый в Prolog. В качестве другого примера сравним следующие два определения <code>len</code>, отношения/функции для вычисления длины списка:</p>
<div class="fragment"><div class="line">;; CLOS</div><div class="line">(defmethod len ((x null)) 0)</div><div class="line">(defmethod len ((x cons))</div><div class="line">(+  1 (len (rest x))))</div></div><!-- fragment --><div class="fragment"><div class="line">%% Prolog</div><div class="line">len([],0).</div><div class="line">len(CXIL].N1) :-</div><div class="line">len(L.N). NI is N+1.</div></div><!-- fragment --><h2>13.10 Преимущества объектно-ориентированного программирования</h2>
<p>Бертран Мейер в своей книге об объектно-ориентированном языке Eiffel (1988) перечисляет пять качеств, которые влияют на качество программного обеспечения:</p>
<ul>
<li><em>Правильность</em>. Ясно, что правильная программа имеет первостепенное значение.</li>
<li><em>Надежность</em>. Программы должны продолжать работать надлежащим образом даже при вводе, выходящем за рамки исходных спецификаций.</li>
<li><em>Расширяемость</em>. Программы должны легко изменяться при изменении технических характеристик.</li>
<li>*Возможность повторного использования *. Компоненты программы должны легко переноситься в новые программы, тем самым окупая затраты на разработку программного обеспечения на нескольких проектах.</li>
<li><em>Совместимость</em>. Программы должны хорошо взаимодействовать с другими программами. Например, программа для работы с электронными таблицами должна не только правильно манипулировать числами, но и быть совместимой с программами обработки текстов, чтобы таблицы можно было легко включать в документы.</li>
</ul>
<p>Здесь мы перечисляем, как объектно-ориентированный подход в целом и CLOS в частности могут повлиять на эти показатели качества:</p>
<ul>
<li>*Правильность *. Правильность обычно достигается в два этапа: правильность отдельных модулей и правильность всей системы. Объектно-ориентированный подход упрощает доказательство правильности модулей, поскольку они четко определены, и может облегчить анализ взаимодействия между модулями, поскольку интерфейс строго ограничен. CLOS не обеспечивает сокрытие информации, как это делают другие системы.</li>
<li><em>Надежность</em>. Обобщенные функции дают возможность функциям принимать во время выполнения класс аргумента, который программист не ожидал во время компиляции. Это особенно верно в случае CLOS, потому что множественное наследование позволяет писать методы по умолчанию, которые могут использоваться широким спектром классов.</li>
<li>*Расширяемость *. Объектно-ориентированные системы с наследованием позволяют легко определять новые классы, которые являются незначительными отличиями существующих. Опять же, множественное наследование CLOS делает процесс расширения даже проще, чем в системах с одиночным наследованием.</li>
<li><em>Возможность повторного использования</em>. Это та область, где объектно-ориентированный стиль вносит наибольший вклад. Вместо того, чтобы писать каждую новую программу с нуля, объектно-ориентированные программисты могут просматривать библиотеку классов и либо повторно использовать существующие классы как есть, либо специализировать существующий класс посредством наследования. Большие библиотеки классов CLOS еще не появились. Возможно, они сделают это, когда язык станет более устоявшимся.</li>
<li><em>Совместимость</em>. Чем больше программ использует стандартные компоненты, тем больше они смогут взаимодействовать друг с другом. Таким образом, объектно-ориентированная программа, вероятно, будет совместима с другими программами, разработанными на основе той же библиотеки классов.</li>
</ul>
<h2>13.11 История и Ссылки</h2>
<p>The first object-oriented language was Simula, which was designed by Ole-Johan Dahl and Krysten Nygaard (<a href="B9780080571157500285.xhtml#bb0265">1966</a>, <a href="B9780080571157500285.xhtml#bb0920">Nygaard and Dahl 1981</a>) as an extension of Algol 60. It is still in use today, mostly in Norway and Sweden. Simula provides the ability to define classes with single inheritance. Methods can be inherited from a superclass or overridden by a subclass. It also provides <em>coroutines</em>, class instances that execute continuously, saving local state in instance variables but periodically pausing to let other coroutines run. Although Simula is a general-purpose language, it provides special support for simulation, as the name implies. The built-in class <code>simulation</code> allows a programmer to keep track of simulated time while running a set of processes as coroutines.</p>
<p>In 1969 Alan Kay was a graduate student at the University of Utah. He became aware of Simula and realized that the object-oriented style was well suited to his research in graphies (<a href="B9780080571157500285.xhtml#bb0600">Kay 1969</a>). A few years later, at Xerox, he joined with Adele Goldberg and Daniel Ingalls to develop the Smalltalk language (see <a href="B9780080571157500285.xhtml#bb0475">Goldberg and Robinson 1983</a>). While Simula can be viewed as an attempt to add object-oriented features to strongly typed Algol 60, Smalltalk can be seen as an attempt to use the dynamic, loosely typed features of Lisp, but with methods and objects replacing functions and s-expressions. In Simula, objects existed alongside traditional data types like numbers and strings; in Smalltalk, every datum is an object. This gave Smalltalk the feel of an integra ted Lisp environment, where the user can inspect, copy, or edit any part of the environment. In fact, it was not the object-oriented features of Smalltalk per se that have made a lasting impression but rather the then-innovative idea that every user would have a large graphical display and could interact with the system using a mouse and menus rather than by typing commands.</p>
<p>Guy Steele's <em>LAMBDA: The Ultimate Declarative</em> (1976a and b) was perhaps the first paper to demonstrate how object-oriented programming can be done in Lisp. As the title suggests, it was all done using <code>lambda,</code> in a similar way to our <code>define-class</code> example. Steele summarized the approach with the equation "Actors = Closures (mod Syntax)," refering to Cari Hewitt's "Actors" object-oriented formalism.</p>
<p>In 1979, the MIT Lisp Machine group developed the Flavors system based on this approach but offering considerable extensions (<a href="B9780080571157500285.xhtml#bb0155">Cannon 1980</a>, <a href="B9780080571157500285.xhtml#bb1360">Weinreb 1980</a>, <a href="B9780080571157500285.xhtml#bb0860">Moon et al. 1983</a>). "Flavor" was a popular jargon word for "type" or "kind" at MIT, so it was natural that it became the term for what we call classes.</p>
<p>The Flavor system was the first to support multiple inheritance. Other languages shunned multiple inheritance because it was too dynamic. With single inheritance, each instance variable and method could be assigned a unique offset number, and looking up a variable or method was therefore trivial. But with multiple inheritance, these computations had to be done at run time. The Lisp tradition enabled programmers to accept this dynamic computation, when other languages would not. Once it was accepted, the MIT group soon came to embrace it. They developed complex protocols for combining different flavors into new ones. The concept of <em>mix-ins</em> was developed by programmers who frequented Steve's Ice Cream parlor in nearby Davis Square. Steve's offered a list of ice cream flavors every day but also offered to create new flavors-dynamically-by mixing in various cookies, candies, or fruit, at the request of the individual customer. For example, Steve's did not have chocolate-chip ice cream on the menu, but you could always order vanilla ice cream with chocolate chips mixed in.<a href="#fn0025">3</a></p>
<p>This kind of "flavor hacking" appealed to the MIT Lisp Machine group, who adopted the metaphor for their object-oriented programming system. All flavors inherited from the top-mostflavor in the hierarchy: vanilla. In the window system, for example, the flavor <code>basic-window</code> was defined to support the minimal functionality of all windows, and then new flavors of window were defined by combining mix-in flavors such as <code>scroll-bar-mixin</code>, <code>label-mixin</code>, and <code>border-mixin</code>. These mix-in flavors were used only to define other flavors. Just as you couldn't go into Steve's and order "crushed Heath bars, hold the ice cream," there was a mechanism to prohibit instantiation of mix-ins.</p>
<p>A complicated repetoire of <em>method combinations</em> was developed. The default method combination on Flavors was similar to CLOS: first do all the :<code>before</code> methods, then the most specific primary method, then the <code>:after</code> methods. But it was possible to combine methods in other ways as well. For example, consider the <code>inside-width</code> method, which returns the width in pixels of the usuable portion of a window. A programmer could specify that the combined method for <code>inside-width</code> was to be computed by calling all applicable methods and summing them. Then an <code>inside-width</code> method for the <code>basic-window</code> flavor would be defined to return the width of the full window, and each mix-in would have a simple method to say how much of the width it consumed. For example, if borders are 8 pixels wide and scroll bars are 12 pixels wide, then the <code>inside-width</code> method for <code>border-mixin</code> returns <code>-8</code> and <code>scroll-bar-mixin</code> returns <code>- 12</code>. Then any window, no matter how many mix-ins it is composed of, automatically computes the proper inside width.</p>
<p>In 1981, Symbolics came out with a more efficient implementation of Flavors. Objects were no longer just closures. They were still funcallable, but there was additional hardware support that distinguished them from other functions. After a few years Symbolics abandoned the (send <em>object message</em>) syntax in favor of a new syntax based on generic functions. This system was known as New Flavors. It had a strong influence on the eventual CLOS design.</p>
<p>The other strong influence on CLOS was the CommonLoops system developed at Xerox PARC. (See <a href="B9780080571157500285.xhtml#bb0095">Bobrow 1982</a>, <a href="B9780080571157500285.xhtml#bb0105">Bobrow et al. 1986</a>, <a href="B9780080571157500285.xhtml#bb1185">Stefik and Bobrow 1986</a>.) CommonLoops continued the New Flavors trend away from message passing by introducing <em>multimethods</em>: methods that specialize on more than one argument.</p>
<p>As of summer 1991, CLOS itself is in a state of limbo. It was legitimized by its appearance in <em>Common Lisp the Language</em>, 2d edition, but it is not yet official, and an important part, the metaobject protocol, is not yet complete. A tutorial on CLOS is <a href="B9780080571157500285.xhtml#bb0620">Keene 1989</a>.</p>
<p>We have seen how easy it is to build an object-oriented system on top of Lisp, using <code>lambda</code> as the primary tool. An interesting alternative is to build Lisp on top of an object-oriented system. That is the approach taken in the Oaklisp system of <a href="B9780080571157500285.xhtml#bb0695">Lang and Perlmutter (1988)</a>. Instead of defining methods using <code>lambda</code> as the primitive, Oaklisp has <code>add-method</code> as a primitive and defines <code>lambda</code> as a macro that adds a method to an anonymous, empty operation.</p>
<p>Of course, object-oriented systems are thriving outside the Lisp world. With the success of UNIX-based workstations, C has become one of the most widely available programming languages. C is a fairly low-level language, so there have been several attempts to use it as a kind of portable assembly language. The most successful of these attempts is C++, a language developed by Bjarne Stroustrup of AT&amp;T Bell Labs (<a href="B9780080571157500285.xhtml#bb1210">Stroustrup 1986</a>). C++ provides a number of extensions, including the ability to define classes. However, as an add-on to an existing language, it does not provide as many features as the other languages discussed here. Crucially, it does not provide garbage collection, nor does it support fully generic functions.</p>
<p>Eiffel (<a href="B9780080571157500285.xhtml#bb0830">Meyer 1988</a>) is an attempt to define an object-oriented system from the ground up rather than tacking it on to an existing language. Eiffel supports multiple inheritance and garbage collection and a limited amount of dynamic dispatching.</p>
<p>So-called modern languages like Ada and Modula support information-hiding through generic functions and classes, but they do not provide inheritance, and thus can not be classified as true object-oriented languages.</p>
<p>Despite these other languages, the Lisp-based object-oriented systems are the only ones since Smalltalk to introduce important new concepts: multiple inheritance and method combination from Flavors, and multimethods from CommonLoops.</p>
<h2>13.12 Упражнения</h2>
<p><b>Exercise 13.3 [m]</b> Implement <code>deposit</code> and <code>interest</code> methods for the <code>account</code> class using CLOS.</p>
<p><b>Exercise 13.4 [m]</b> Implement the <code>password-account</code> class using CLOS. Can it be done as cleanly with inheritance as it was done with delegation? Or should you use delegation within CLOS?</p>
<p><b>Exercise 13.5 [h]</b> Implement graph searching, search paths, and A* searching as classes in CLOS.</p>
<p><b>Exercise 13.6 [h]</b> Implement a priority queue to hold the states of a problem. Instead of a list, the <code>problem-states</code> will be a vector of lists, each initially null. Each new state will have a priority (determined by the generic function <code>priority</code>) which must be an integer between zero and the length of the vector, where zero indicates the highest priority. A new state with priority <em>p</em> is pushed onto element <em>p</em> of the vector, and the state to be explored next is the first state in the first nonempty position. As stated in the text, some of the previously defined methods made the unwarranted assumption that <code>problem-states</code> would always hold a list. Change these methods. </p><hr/>
<p><a href="#xfn0015">1</a> More accurately, we have a guarantee that there is no way to get at the inside of a closure using portable Common Lisp code. Particular implementations may provide debugging tools for getting at this hidden information, such as <code>inspect</code>. So closures are not perfect at hiding information from these tools. Of course, no information-hiding method will be guaranteed against such covert channels-even with the most sophisticated software security measures, it is always possible to, say, wipe a magnet over the computer's disks and alter sensitive data. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0020">2</a> There is a technical sense of "generic function" that is used within CLOS. These functions are not generic according to this technical sense. !!!(p) {:.ftnote1}</p>
<p><a href="#xfn0025">3</a> Flavor fans will be happy to know that Steve's Ice Cream is now sold nationally in the United States. Alas, it is not possible to create flavors dynamically. Also, be warned that Steve's was bought out by his Teal Square rival, Joey's. The original Steve retired from the business for years, then came back with a new line of stores under his last name, Harrell. !!!(p) {:.ftnote1} </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
