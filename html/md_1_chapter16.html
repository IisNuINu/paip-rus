<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>paip-ru: Глава 16</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">paip-ru
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Глава 16 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Экспертные Системы</h2>
<blockquote class="doxtable">
<p>Эксперт - это тот, кто знает все больше и больше о все меньшем и меньшем. </p>
</blockquote>
<blockquote class="doxtable">
<p>-Nicholas Murray Butler (1862-1947) </p>
</blockquote>
<p>В 1970-х годах был ужасный интерес к области <em>экспертных систем, основанных на знаниях</em>. Экспертная система или система, основанная на знаниях, - это система, которая решает проблемы, применяя знания, полученные от одного или нескольких экспертов в данной области. Поскольку эти эксперты, как правило, не являются программистами, они, скорее всего, выразят свои знания в терминах, которые нельзя сразу перевести в программу. Целью исследования экспертных систем является создание представления, достаточно гибкого для обработки экспертных знаний, но все же пригодного для манипулирования компьютерной программой для выработки решений.</p>
<p>Правдоподобный кандидат на это представление - такие же логические факты и правила, как в Прологе. Однако есть три области, в которых Пролог плохо поддерживает системемы, основанные на общих знаниях:</p>
<ul>
<li>Рассуждения с неуверенностью(Нечеткие рассуждения). Пролог имеет дело только с черно-белым миром фактов, которые явно истинны или ложны (и он даже не очень хорошо справляется с ложью). Часто эксперты выражают эмпирические правила, которые "вероятны(likely)" или "уверены(certain) на 90%".</li>
<li>Объяснение. Prolog дает решения для запросов, но не указывает, как эти решения были получены. Система, которая может объяснить пользователю свои решения в понятной форме, будет пользоваться большим доверием.</li>
<li>Гибкий выбор типа потока управления. Prolog работает путем обратной цепочки от цели. В некоторых случаях нам может потребоваться более разнообразная стратегия контроля/управления. Например, в медицинской диагностике прописан порядок получения определенной информации о пациенте. Медицинская система должна следовать этому порядку, даже если он не вписывается в стратегию обратной цепочки.</li>
</ul>
<p>Ранние экспертные системы использовали самые разные методы для решения этих проблем. В конце концов стало ясно, что определенные методы используются часто, и они были зафиксированы в <em>оболочках экспертных систем</em>: специализированных средах программирования, которые помогали получать знания от экспертов и использовать их для решения проблем и предоставления объяснений. Идея заключалась в том, что эти оболочки обеспечат более высокий уровень абстракции, чем просто Lisp или Prolog, и упростят написание новых экспертных систем.</p>
<p>Экспертная система MYCIN была одной из первых и остается одной из самых известных. Это было написано доктором Эдвардо Шортлиффом в 1974 году как эксперимент по медицинской диагностике. MYCIN был разработана для назначения антибактериальной терапии при бактериальных инфекциях крови, и когда она была завершена, она была оценена для выполнения этой задачи как эксперт в этой области Её название происходит от общего суффикса лекарств, которые он назначает: эритромицин, клиндамицин и так далее. Ниже приводится слегка измененная версия одного из правил MYCIN, а также перефразирование на английский язык, созданное системой:</p>
<div class="fragment"><div class="line">(defrule 52</div></div><!-- fragment --><p><code>if (site culture is blood)</code></p>
<p><code>(gram organism is neg)</code></p>
<p><code>(morphology organism is rod)</code></p>
<p><code>(burn patient is serious)</code></p>
<p><code>then .4</code></p>
<p><code>(identity organism is pseudomonas))</code></p>
<div class="fragment"><div class="line">Rule 52:</div></div><!-- fragment --><p><code>If</code></p>
<p><code>1) THE SITE OF THE CULTURE IS BLOOD</code></p>
<p><code>2) THE GRAM OF THE ORGANISM IS NEG</code></p>
<p><code>3) THE MORPHOLOGY OF THE ORGANISM IS ROD</code></p>
<p><code>4) THE BURN OF THE PATIENT IS SERIOUS</code></p>
<p><code>Then there is weakly suggestive evidence (0.4) that</code></p>
<p><code>1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS</code></p>
<p>MYCIN привел к разработке оболочки экспертной системы EMYCIN. EMYCIN означает "сущность(essential) MYCIN", хотя его часто неправильно представляют как "пустой(empty) MYCIN". В любом случае, название относится к оболочке для получения знаний, рассуждений с ее помощью и объяснения результатов без конкретных медицинских знаний.</p>
<p>EMYCIN - это интерпретатор правил с обратной цепочкой, который имеет много общего с Prolog. Однако есть четыре важных отличия. Во-первых, и это наиболее важно, EMYCIN имеет дело с неопределенностью. Вместо того чтобы настаивать на том, чтобы все предсказания были истинными или ложными, EMYCIN связывает с каждым предсказанием <em>фактор достоверности</em>. Во-вторых, EMYCIN кэширует результаты своих вычислений, чтобы их не нужно было дублировать. В-третьих, EMYCIN предоставляет системе простой способ запросить информацию у пользователя. В-четвертых, он дает объяснения своего поведения. Это можно выразить уравнением:</p>
<div class="fragment"><div class="line">EMYCIN = Prolog + uncertainty + caching + questions + explanations</div></div><!-- fragment --><p>Сначала мы рассмотрим отличия EMYCIN от Prolog. После этого мы вернемся к основному ядру EMYCIN, интерпретатору правил с обратной цепочкой. Наконец, мы покажем, как добавить некоторые медицинские знания к EMYCIN для воссоздания MYCIN. Глоссарий программы находится на <a href="#f0010">рисунок 16.1</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter16/f16-01.jpg" alt="f16-01"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 16.1: Глоссарий программы EMYCIN </td></tr>
</table>
<p>*(ed: this could be a markdown table)*</p>
<h2>16.1 Работа с неопределенностью</h2>
<p>EMYCIN имеет дело с неопределенностью, заменяя два логических значения, истинное и ложное, на диапазон значений, называемых <em>факторами достоверности</em>. Это числа от -1 (ложь) до + 1 (истина), где 0 представляет собой полностью неизвестное. В Лиспе:</p>
<div class="fragment"><div class="line">(defconstant true +  1.0)</div><div class="line">(defconstant false -  1.0)</div><div class="line">(defconstant unknown 0.0)</div></div><!-- fragment --><p>Чтобы определить логику факторов достоверности, нам необходимо определить логические операции, такие как <code>and/и</code>, <code>or/или</code>, <code>not/не</code>. Первая операция, которую следует рассмотреть, - это сочетание двух различных частей доказательств, выраженных как факторы определенности. Предположим, мы пытаемся определить вероятность того, что у пациента есть заболевание &Chi;. Предположим, что у нас есть группа предыдущих пациентов, которым были даны два лабораторных теста. Первый тест говорит, что у 60% пациентов есть заболевание, а второй говорит, что оно есть у 40%. Как нам объединить эти два доказательства в одно? К сожалению, невозможно правильно ответить на этот вопрос, не зная больше о <em>зависимости</em> двух источников друг от друга. Предположим, что первый тест показывает, что 60% пациентов (которые все оказались мужчинами) имеют болезнь, а второй говорит, что 40% (которые все оказались женщинами) болеют. Тогда мы должны сделать вывод, что он есть у 100%, потому что два теста охватывают все население. С другой стороны, если первый тест положителен только для пациентов в возрасте 70 лет и старше, а второй положителен только для пациентов в возрасте 80 лет и старше, то второй является лишь частью первого. Это не добавляет никакой новой информации, поэтому в данном случае правильный ответ - 60%.</p>
<p>В <a href="#s0050">section 16.9</a> мы рассмотрим способы учета такого рода рассуждений. А пока мы представим метод комбинирования, фактически используемый в EMYCIN. Он определяется формулой:</p>
<p>combine (A, B) =</p>
<p>A+B-AB;A,B&gt;0A+B+AB;A,B&lt;0A+B1-minAB;otherwise</p>
<div class="image">
<img src="images/chapter16/si1_e.gif" alt="si1_e"/>
</div>
<p>Согласно этой формуле, combine(.60,.40) = .76, что является компромиссом между крайними значениями 0,60 и 1,00. Это то же самое, что вероятность p(A or B), если предположить, что A и B независимы.</p>
<p>Однако должно быть ясно, что факторы уверенности - это не то же самое, что вероятности. Факторы уверенности пытаются справиться с недоверием так же, как с доверием, но не с зависимостью и независимостью. Функция комбинирования EMYCIN имеет ряд желаемых свойств:</p>
<ul>
<li>Он всегда вычисляет число от - 1 до +1.</li>
<li>Комбинирование неизвестного (нуля) с чем-либо ничего не меняет.</li>
<li>Объединение истины с чем угодно (кроме ложи) дает истину.</li>
<li>Объединение истины и лжи является ошибкой.</li>
<li>Комбинирование двух противоположностей дает неизвестное.</li>
<li>Объединение/комбинирование двух положительных результатов (кроме истинного) дает больший положительный результат.</li>
<li>Комбинирование положительного и отрицательного дает нечто среднее.</li>
</ul>
<p>До сих пор мы видели, как combine(комбинирование) двух отдельных доказательств одной и той же гипотезы. Другими словами, если у нас есть два правила:</p>
<p>A =&gt; C</p>
<p>B =&gt; C</p>
<p>и мы знаем A с коэффициентом достоверности (certainty factor - cf) .6 и B со значением cf .4, тогда мы можем заключить C с cf .76. Но рассмотрим правило с коньюнкцией(объединением) в посылке:</p>
<p>A and B =&gt; C</p>
<p>Комбинирование A и B в этом случае сильно отличается от их комбинирования, когда они находятся в отдельных правилах. EMYCIN выбирает комбинирование объединений, беря минимум фактора уверенности(cf) каждого конъюнкта. Если бы факторы уверенности были вероятностями, это было бы эквивалентно предположению зависимости между конъюнктами в правиле. (Если бы конъюнкты были независимыми, то правильным ответом было бы произведение вероятностей.) Итак, EMYCIN делает вполне разумное (но иногда неверное) предположение, что условия, связанные вместе в одном правиле, будут зависеть друг от друга, в то время как условия в отдельных правилах независимы.</p>
<p>Последняя сложность заключается в том, что сами правила могут быть неопределенными. То есть MYCIN использует правила, которые выглядят так:</p>
<p>A and B =&gt; .9C</p>
<p>говорят, что A и B подразумевают C с уверенностью(cf) .9. EMYCIN просто умножает cf правила на комбинированный cf предпосылки. Таким образом, если A имеет cf .6, а B имеет cf .4, то посылка в целом имеет cf .4 (минимум A и B), который умножается на .9, чтобы получить .36. Затем .36 комбинируется с любыми существующими cf для C. Если C заранее неизвестен, то объединение .36 с 0 даст .36. Если бы у C был предыдущий cf равный .76, то новый cf был бы .36 + .76 - (.36 x .76) = .8464.</p>
<p>Вот функции комбинации факторов достоверности EMYCIN в Lisp:</p>
<div class="fragment"><div class="line">(defun cf-or (a b)</div><div class="line">  &quot;Combine the certainty factors for the formula (A or B).</div><div class="line">  This is used when two rules support the same conclusion.&quot;</div><div class="line">  (cond ((and (&gt; a 0) (&gt; b 0))</div><div class="line">         (+ a b (* -1 a b)))</div><div class="line">        ((and (&lt; a 0) (&lt; b 0))</div><div class="line">         (+ a b (* a b)))</div><div class="line">        (t (/ (+ a b)</div><div class="line">              (- 1 (min (abs a) (abs b)))))))</div><div class="line"></div><div class="line">(defun cf-and (a b)</div><div class="line">  &quot;Combine the certainty factors for the formula (A and B).&quot;</div><div class="line">  (min a b))</div></div><!-- fragment --><p>Факторы уверенности можно рассматривать как обобщение истинностных значений. EMYCIN - это система правил с обратной связью, которая объединяет факторы достоверности в соответствии с функциями, изложенными выше. Но если бы мы использовали только факторы достоверности true и false, тогда EMYCIN вел бы себя точно так же, как Prolog, возвращая только ответы, которые определенно истинны. Дополнительный механизм EMYCIN имеет значение только тогда, когда мы предоставляем частичные факторы уверенности.</p>
<p>На самом деле значения истинности служат в Прологе двум целям. Они определяют окончательный ответ, да, но они также определяют, когда прекращать поиск: если какая-либо из посылок правила ложна, то нет смысла смотреть на другие посылки. Если в EMYCIN мы прекращаем поиск только тогда, когда одна из предпосылок была абсолютно ложной, тогда нам, возможно, пришлось бы перебирать множество правил, только чтобы получить ответы с очень низкими факторами уверенности. Вместо этого EMYCIN произвольно прекращает поиск и считает предпосылку ложной, если ее коэффициент достоверности(фактор уверенности) ниже .2. Следующие функции поддерживают эту произвольную точку отсечения:</p>
<div class="fragment"><div class="line">(defconstant cf-cut-off 0.2</div><div class="line">  &quot;Below this certainty we cut off search.&quot;)</div><div class="line"></div><div class="line">(defun true-p (cf)</div><div class="line">  &quot;Is this certainty factor considered true?&quot;</div><div class="line">  (and (cf-p cf) (&gt; cf cf-cut-off)))</div><div class="line"></div><div class="line">(defun false-p (cf)</div><div class="line">  &quot;Is this certainty factor considered false?&quot;</div><div class="line">  (and (cf-p cf) (&lt; cf (- cf-cut-off 1.0))))</div><div class="line"></div><div class="line">(defun cf-p (x)</div><div class="line">  &quot;Is X a valid numeric certainty factor?&quot;</div><div class="line">  (and (numberp x) (&lt;= false x true)))</div></div><!-- fragment --><p><b>Упражнение 16.1 [m]</b> Предположим, вы читаете заголовок "Элвис жив в Каламазу" в бульварной газете, которой вы приписываете коэффициент уверенности .01. Если вы объедините достоверность, используя правило комбинирования EMYCIN, сколько еще экземпляров газеты вам нужно будет увидеть, прежде чем вы станете уверенным, что Элвис жив .95?</p>
<h2>16.2 Кэширование производных фактов</h2>
<p>Второе, что отличает EMYCIN от Prolog, - это то, что EMYCIN <em>кэширует</em> все полученные данные в базе данных. Когда Prolog просят дважды доказать одну и ту же цель, он дважды выполняет одно и то же вычисление, независимо от того, насколько это трудоемко. EMYCIN выполняет вычисление в первый раз и просто извлекает его во второй раз.</p>
<p>Мы можем реализовать простую базу данных, предоставив три функции: <code>put-db</code> для добавления связи между ключом и значением, <code>get-db</code> для получения значения и <code>clear-db</code> для очистки базы данных, чтобы начать сначала:</p>
<div class="fragment"><div class="line">(let ((db (make-hash-table :test #&#39;equal)))</div><div class="line">  (defun get-db (key) (gethash key db))</div><div class="line">  (defun put-db (key val) (setf (gethash key db) val))</div><div class="line">  (defun clear-db () (clrhash db)))</div></div><!-- fragment --><p>Эта база данных достаточно общая, чтобы удерживать любую связь между ключом и значением. Однако большая часть информации, которую мы хотим сохранить, носит более конкретный характер. EMYCIN предназначен для работы с объектами (или <em>экземплярами</em>) и атрибутами (или <em>параметрами</em>) этих объектов. Например, у каждого пациента(patient) есть параметр имя(name). Предположительно, значение этого параметра будет известно точно. С другой стороны, каждый микроскопический организм имеет параметр <code>identity</code>(идентичности), который обычно не известен в начале консультации. Применение правил приведет к нескольким возможным значениям этого параметра, каждое со своим коэффициентом достоверности(фактором уверенности). В общем, тогда в базе данных будут ключи вида (<em>экземпляр параметра</em>) со значениями вида ((*val*1*cf*1) (*val*2*cf*2)...) . В следующем коде <code>get-vals</code> возвращает список пар значение/cf для данного параметра и экземпляра, <code>get-cf</code> возвращает фактор уверенности(коэффициент достоверности/cf) для триплета параметр/экземпляр/значение, а <code>update-cf</code> изменяет фактор уверенности за счет объединения старого с новым. Обратите внимание, что при первом вызове <code>update-cf</code> для данного триплета параметра/экземпляра/значения, <code>get-cf</code> вернет неизвестность(ноль). Комбинируя это с данным <code>cf</code>, получаем сам <code>cf</code>. Также обратите внимание, что база данных должна быть equal хэш-таблицей, потому что ключи могут включать в себя только что созданные списки.</p>
<div class="fragment"><div class="line">(defun get-vals (parm inst)</div><div class="line">  &quot;Return a list of (val cf) pairs for this (parm inst).&quot;</div><div class="line">  (get-db (list parm inst)))</div><div class="line"></div><div class="line">(defun get-cf (parm inst val)</div><div class="line">  &quot;Look up the certainty factor or return unknown.&quot;</div><div class="line">  (or (second (assoc val (get-vals parm inst)))</div><div class="line">      unknown))</div><div class="line"></div><div class="line">(defun update-cf (parm inst val cf)</div><div class="line">  &quot;Change the certianty factor for (parm inst is val),</div><div class="line">  by combining the given cf with the old.&quot;</div><div class="line">  (let ((new-cf (cf-or cf (get-cf parm inst val))))</div><div class="line">    (put-db (list parm inst)</div><div class="line">            (cons (list val new-cf)</div><div class="line">                  (remove val (get-db (list parm inst))</div><div class="line">                          :key #&#39;first)))))</div></div><!-- fragment --><p>База данных содержит всю информацию, относящуюся к конкретному случаю проблемы. Например, в области медицины база данных будет содержать всю информацию о текущем пациенте. Когда мы хотим рассмотреть нового пациента, база данных очищается.</p>
<p>Есть еще три источника информации, которые нельзя сохранить в этой базе данных, потому что их нужно поддерживать от одной проблемы к другой. Во-первых, <em>база правил</em> содержит все правила, определенные экспертом. Во-вторых, есть структура для определения каждого параметра; они индексируются под именем каждого параметра. В-третьих, мы увидим, что поток управления частично управляется списком <em>контекстов</em>(<em>contexts</em>), которые необходимо учитывать. Это структуры, которые будут переданы функции <code>MYCIN</code>.</p>
<h2>16.3 Задавать вопросы</h2>
<p>Третий способ, которым EMYCIN отличается от Prolog, - это предоставление автоматических средств для задания вопросов пользователю, когда ответы не могут быть получены из правил. Это не принципиальная разница; в конце концов, не так уж сложно написать правила Пролога, которые выводят запрос и читают ответ. EMYCIN позволяет разработчику базы знаний написать простое объявление вместо правила и даже примет объявление по умолчанию, если оно не предусмотрено. Система также гарантирует, что один и тот же вопрос никогда не будет задан дважды.</p>
<p>Следующая функция <code>ask-vals</code> печатает запрос, который запрашивает параметр экземпляра и считывает от пользователя значение или список значений с соответствующими факторами достоверности. Функция сначала просматривает базу данных, чтобы убедиться, что вопрос не задавался ранее. Затем она проверяет каждое значение и фактор уверенности, чтобы убедиться, что каждое из них относится к правильному типу, а также позволяет пользователю задавать определенные вопросы. А ? ответ покажет, какой тип ответа ожидается. <code>Rule</code>(Правило) покажет текущее правило, над которым работает система. <code>Why</code>(Почему) также показывает текущее правило, но более подробно объясняет, что система знает и что пытается выяснить. Наконец, <code>help</code> выводит следующую сводку:</p>
<div class="fragment"><div class="line">(defconstant help-string</div><div class="line">  &quot;~&amp;Type one of the following:</div><div class="line"> ?     - to see possible answers for this parameter</div><div class="line"> rule  - to show the current rule</div><div class="line"> why   - to see why this question is asked</div><div class="line"> help  - to see this list</div><div class="line"> xxx   - (for some specific xxx) if there is a definite answer</div><div class="line"> (xxx .5 yyy .4) - If there are several answers with</div><div class="line">                   different certainty factors.&quot;)</div></div><!-- fragment --><p>Вот и <code>ask-vals</code>. Обратите внимание, что параметры <code>why</code> и <code>rule</code> предполагают, что текущее правило было сохранено в базе данных. Вскоре будут определены функции <code>print-why</code>, <code>parm-type</code> и <code>check-reply</code>.</p>
<div class="fragment"><div class="line">(defun ask-vals (parm inst)</div><div class="line">  &quot;Ask the user for the value(s) of inst&#39;s parm parameter,</div><div class="line">  unless this has already been asked.  Keep asking until the</div><div class="line">  user types UNKNOWN (return nil) or a valid reply (return t).&quot;</div><div class="line">  (unless (get-db `(asked ,parm ,inst))</div><div class="line">    (put-db `(asked ,parm ,inst) t)</div><div class="line">    (loop</div><div class="line">      (let ((ans (prompt-and-read-vals parm inst)))</div><div class="line">        (case ans</div><div class="line">          (help (format t help-string))</div><div class="line">          (why  (print-why (get-db &#39;current-rule) parm))</div><div class="line">          (rule (princ (get-db &#39;current-rule)))</div><div class="line">          ((unk unknown) (RETURN nil))</div><div class="line">          (?    (format t &quot;~&amp;A ~a must be of type ~a&quot;</div><div class="line">                        parm (parm-type parm)) nil)</div><div class="line">          (t    (if (check-reply ans parm inst)</div><div class="line">                    (RETURN t)</div><div class="line">                    (format t &quot;~&amp;Illegal reply.  ~</div><div class="line">                             Type ? to see legal ones.&quot;))))))))</div></div><!-- fragment --><p>Далее следует <code>prompt-and-read-vals</code>, функция, которая фактически запрашивает запрос и читает ответ. По сути, он вызывает <code>format</code>, чтобы напечатать приглашение, и <code>read</code>, чтобы получить ответ, но здесь есть несколько тонкостей. Во-первых, она вызывает <code>finish-output</code>. Некоторые реализации Lisp буферизуют вывод построчно. Поскольку приглашение не может заканчиваться новой строкой, <code>finish-output</code> гарантирует, что вывод будет напечатан до того, как будет прочитан ответ.</p>
<p>До сих пор весь код, который ссылается на <code>parm</code>, действительно ссылается на имя параметра-символа. Сами фактические параметры будут реализованы в виде структур. Мы используем <code>get-parm</code> для поиска структуры, связанной с символом, и функции селектора <code>parm-prompt</code>, чтобы выбрать подсказку для каждого параметра, и <code>parm-reader</code>, чтобы выбрать функцию чтения. Обычно это будет функция <code>read</code>, но <code>read-line</code> подходит для чтения параметров со строковыми значениями.</p>
<p>Макрос <code>defparm</code> (показанный здесь) обеспечивает способ определения подсказок и считывателей для параметров.</p>
<div class="fragment"><div class="line">(defun prompt-and-read-vals (parm inst)</div><div class="line">  &quot;Print the prompt for this parameter (or make one up) and</div><div class="line">  read the reply.&quot;</div><div class="line">  (fresh-line)</div><div class="line">  (format t (parm-prompt (get-parm parm)) (inst-name inst) parm)</div><div class="line">  (princ &quot; &quot;)</div><div class="line">  (finish-output)</div><div class="line">  (funcall (parm-reader (get-parm parm))))</div><div class="line"></div><div class="line">(defun inst-name (inst)</div><div class="line">  &quot;The name of this instance.&quot;</div><div class="line">  ;; The stored name is either like ((&quot;Jan Doe&quot; 1.0)) or nil</div><div class="line">  (or (first (first (get-vals &#39;name inst)))</div><div class="line">      inst))</div></div><!-- fragment --><p>Функция <code>check-reply</code> использует <code>parse-reply</code> для преобразования ответа пользователя в каноническую форму, а затем проверяет, что каждое значение имеет правильный тип и что каждый фактор уверенности действителен. Если да, база данных обновляется, чтобы отразить новые факторы уверенности.</p>
<div class="fragment"><div class="line">(defun check-reply (reply parm inst)</div><div class="line">  &quot;If reply is valid for this parm, update the DB.</div><div class="line">  Reply should be a val or (val1 cf1 val2 cf2 ...).</div><div class="line">  Each val must be of the right type for this parm.&quot;</div><div class="line">  (let ((answers (parse-reply reply)))</div><div class="line">    (when (every #&#39;(lambda (pair)</div><div class="line">                     (and (typep (first pair) (parm-type parm))</div><div class="line">                          (cf-p (second pair))))</div><div class="line">                 answers)</div><div class="line">      ;; Add replies to the data base</div><div class="line">      (dolist (pair answers)</div><div class="line">        (update-cf parm inst (first pair) (second pair)))</div><div class="line">      answers)))</div><div class="line"></div><div class="line">(defun parse-reply (reply)</div><div class="line">  &quot;Convert the reply into a list of (value cf) pairs.&quot;</div><div class="line">  (cond ((null reply) nil)</div><div class="line">        ((atom reply) `((,reply ,true)))</div><div class="line">        (t (cons (list (first reply) (second reply))</div><div class="line">                 (parse-reply (rest2 reply))))))</div></div><!-- fragment --><p>Параметры реализованы в виде структур с шестью слотами: имя - name (символ), context - контекст, для которого предназначен параметр, prompt - приглашение, используемое для запроса значения параметра, логическое значение, которое сообщает, следует ли спрашивать пользователя до или после использования правил, ограничение типа, описывающее допустимые значения, и, наконец, функция, используемая для чтения значения параметра.</p>
<p>Параметры хранятся в списке свойств с их именами в свойстве parm, поэтому для получения имени типа parm требуется сначала получить структуру parm, а затем выбрать поле ограничения типа. По умолчанию параметру присваивается тип t, что означает, что для этого типа допустимо любое значение. Мы также определяем тип <code>yes/no</code>- да/ нет, который пригодится для логических(Boolean) параметров.</p>
<p>Мы хотим, чтобы запрос по умолчанию был "What is the PARM of the INST?"(Что такое PARM INST?) Но в большинстве пользовательских подсказок требуется напечатать inst, а не parm. Чтобы упростить написание пользовательских подсказок, <code>prompt-and-read-vals</code> делает экземпляр первым аргументом строки формата, а parm - вторым. Следовательно, в приглашении по умолчанию нам нужно использовать директиву формата <code>"~*"</code>, чтобы пропустить аргумент экземпляра, и <code>"~2:*"</code> для возврата назад на два аргумента, чтобы вернуться к экземпляру. (Эти директивы распространены в вызовах <code>cerror</code>, где один список аргументов передается двум строкам формата.)</p>
<p><code>defparm</code> - это макрос, который вызывает <code>new-parm</code>, функцию - конструктор, определенную в <code>parm</code> структуре, и сохраняет полученную структуру под именем параметра в свойстве <code>parm</code> .</p>
<div class="fragment"><div class="line">(defstruct (parm (:constructor</div><div class="line">                  new-parm (name &amp;optional context type-restriction</div><div class="line">                            prompt ask-first reader)))</div><div class="line">  name (context nil) (prompt &quot;~&amp;What is the ~*~a of ~2:*~a?&quot;)</div><div class="line">  (ask-first nil) (type-restriction t) (reader &#39;read))</div><div class="line"></div><div class="line">(defmacro defparm (parm &amp;rest args)</div><div class="line">  &quot;Define a parameter.&quot;</div><div class="line">  `(setf (get &#39;,parm &#39;parm) (apply #&#39;new-parm &#39;,parm &#39;,args)))</div><div class="line"></div><div class="line">(defun parm-type (parm-name)</div><div class="line">  &quot;What type is expected for a value of this parameter?&quot;</div><div class="line">  (parm-type-restriction (get-parm parm-name)))</div><div class="line"></div><div class="line">(defun get-parm (parm-name)</div><div class="line">  &quot;Look up the parameter structure with this name.&quot;</div><div class="line">  ;; If there is none, make one</div><div class="line">  (or (get parm-name &#39;parm)</div><div class="line">      (setf (get parm-name &#39;parm) (new-parm parm-name))))</div><div class="line"></div><div class="line">(deftype yes/no () &#39;(member yes no))</div></div><!-- fragment --><h2>16.4 Контексты вместо переменных</h2>
<p>Ранее мы приводили уравнение, связывающее EMYCIN с Prolog. Это уравнение было не совсем правильным, потому что в EMYCIN отсутствует одна из самых важных функций Prolog: логическая переменная. Вместо этого EMYCIN использует <em>контексты</em> - <em>contexts</em>. Итак, полное уравнение:</p>
<p>EMYCIN = Prolog + uncertainty + caching + questions + explanations + contexts - variables (EMYCIN = Пролог + неопределенность + кеширование + вопросы + объяснения + контексты - переменные)</p>
<p>Контекст определяется разработчиками MYCIN как ситуация, в которой работает программа. Но имеет смысл рассматривать контекст просто как тип данных. Таким образом, список контекстов, предоставленный программе, определит, о каких типах объектов можно рассуждать. Программа отслеживает самый последний экземпляр каждого типа, и правила могут ссылаться только на эти экземпляры, используя имя типа. В нашей версии MYCIN существует три типа или контекста: пациенты(patients), культуры(cultures) и организмы(organisms). Вот пример правила, которое ссылается на все три контекста:</p>
<div class="fragment"><div class="line">(defrule 52</div></div><!-- fragment --><p><code>if (site culture is blood)</code> </p><pre class="fragment">`(gram organism is neg)`

`(morphology organism is rod)`

`(burn patient is serious)`
</pre><p><code>then .4</code> </p><pre class="fragment">`(identity organism is pseudomonas))`
</pre><p>На данный момент игнорируя факторы уверенности, это правило MYCIN эквивалентно правилу Пролога в форме:</p>
<div class="fragment"><div class="line">(&lt;- (identity ?o ?pseudomonas)</div></div><!-- fragment --><p><code>(and (culture</code> ?c) <code>(site ?c blood)</code></p>
<p><code>(organism ?o) (gram ?o neg) (morphology ?o rod)</code></p>
<p><code>(patient ?p) (burn ?p serious)))</code></p>
<p>Механизм контекста обеспечивает достаточную гибкость для обработки многих случаев, которые в противном случае обрабатывались бы переменными. Одна важная вещь, которую нельзя сделать, - это ссылаться на несколько экземпляров одного и того же контекста. Можно сослаться только на самый последний экземпляр. Контексты реализованы как структуры со следующим определением:</p>
<div class="fragment"><div class="line">(defstruct context</div><div class="line">  &quot;A context is a sub-domain, a type.&quot;</div><div class="line">  name (number 0) initial-data goals)</div><div class="line"></div><div class="line">(defmacro defcontext (name &amp;optional initial-data goals)</div><div class="line">  &quot;Define a context.&quot;</div><div class="line">  `(make-context :name &#39;,name :initial-data &#39;,initial-data</div><div class="line">                 :goals &#39;,goals))</div></div><!-- fragment --><p>Поле <code>name</code>(имя) похоже на <code>patient или organism.</code> Экземпляры контекстов нумеруются; поле <code>number</code> содержит номер самого последнего экземпляра. У каждого контекста также есть два списка параметров. Параметры начальных данных запрашиваются при создании каждого экземпляра. Параметры исходных данных обычно известны пользователю. Например, врач обычно знает имя, возраст и пол пациента, и в целях обучения ожидает, что ему сначала зададут эти вопросы, даже если они не учитываются в каждом случае. С другой стороны, параметры цели обычно неизвестны пользователю. Они определяются в процессе поиска/прохождения обратной цепочки.</p>
<p>Следующая функция создает новый экземпляр контекста, записывает сообщение и сохраняет этот экземпляр в двух местах в базе данных: под ключом <code>current-instance</code>, а также под именем контекста. Контексты образуют дерево. В нашем примере контекст <code>patient</code>(пациент) является корнем дерева, а текущий пациент хранится в базе данных под ключом <code>patient.</code> Следующий уровень дерева предназначен для культур, взятых у пациента; текущая культура хранится в ключе <code>culture</code>. Наконец, есть уровень для организмов, обнаруженных в каждой культуре. Текущий организм хранится под ключами <code>organism</code> и <code>current-instance</code>. Контекстное дерево показано на <a href="#f0015">рисунке 16.2</a>.</p>
<table class="doxtable">
<tr>
<th>[]()  </th></tr>
<tr>
<td><div class="image">
<img src="images/chapter16/f16-02.jpg" alt="f16-02"/>
</div>
 </td></tr>
<tr>
<td>Рисунок 16.2: Дерево контекста </td></tr>
</table>
<div class="fragment"><div class="line">(defun new-instance (context)</div><div class="line">  &quot;Create a new instance of this context.&quot;</div><div class="line">  (let ((instance (format nil &quot;~a-~d&quot;</div><div class="line">                          (context-name context)</div><div class="line">                          (incf (context-number context)))))</div><div class="line">  (format t &quot;~&amp;------ ~a ------~&amp;&quot; instance)</div><div class="line">    (put-db (context-name context) instance)</div><div class="line">    (put-db &#39;current-instance instance)))</div></div><!-- fragment --><h2>16.5 Возвращение к обратной цепочке</h2>
<p>Теперь, когда мы увидели, чем EMYCIN отличается от Prolog, мы готовы заняться тем же способом: интерпретатором правил с обратной цепочкой. Как и Prolog, EMYCIN ставит перед собой цель и применяет правила, соответствующие этой цели. Применение правила означает рассмотрение каждой посылки правила как цели и рекурсивное применение правил, соответствующих каждой посылке.</p>
<p>Остались еще некоторые отличия. В Прологе целью может быть любое выражение, и подходящими правилами являются те, чьи головы объединяются/унифицируются с целью. Если какое-либо подходящее правило сработает, значит, цель истинна. В EMYCIN правило может дать цели уверенность .99, но мы все равно должны учитывать все другие правила, соответствующие цели, потому что они могут снизить точность ниже порога отсечения. Таким образом, EMYCIN всегда сначала собирает все свидетельства, относящиеся к паре параметр/экземпляр, и оценивает/вычисляет цель только после того, как все свидетельства получены. Например, если цель была (<code>temp patient &gt; 98.6</code>), Emycin сначала вычислит все правила с выводами(заключениями) о текущей температуре пациента, и только затем сравнит температуру с 98.6.</p>
<p>С другой стороны, в Прологе есть возможность искать в глубину, потому что семантика правил Пролога такова, что если какое-либо правило утверждает, что цель истинна, то это правда. EMYCIN должен искать в ширину, потому что цель с уверенностью 0,99 может оказаться ложной при рассмотрении большего количества доказательств.</p>
<p>Теперь мы готовы набросать схему интерпретатора правил EMYCIN. Для <code>find-out</code> параметра экземпляра: Если значение уже хранится в базе данных, используйте известное значение В противном случае, два варианта: использование правил или спросить пользователя. Делайте это в порядке, указанном для этого параметра, и, если первый успешен, не беспокойтесь о втором. Обратите внимание, что <code>ask-vals</code> (определенную выше) не будет задавать один и тот же вопрос дважды.</p>
<p>Чтобы использовать правила, найдите все правила, относящиеся к данному параметру, и вычислите их с помощью <code>use-rule</code>. После того, как каждое правило было проверено/опробавано, если какое-либо из них вычисляется как истинное, то считается успешным.</p>
<p>Чтобы использовать правило <code>use-rule</code>, сначала проверьте, можно ли полностью отклонить какую-либо из посылок. Если бы у нас не было этой проверки, то система могла бы начать задавать пользователям явно не относящиеся к делу вопросы. Таким образом, мы тратим часть времени программы (проверяя каждую предпосылку дважды), чтобы сэкономить более ценное время пользователя. (Функция <code>eval-condition</code> принимает необязательный аргумент, определяющий, должны ли мы рекурсивно задавать вопросы, пытаясь принять или отклонить условие.)</p>
<p>Если никакая посылка не может быть отклонена, то вычислите каждую посылку по очереди с помощью <code>evaluate-condition</code>, отслеживая накопленный фактор уверенности с помощью <code>cf-and</code> (который в настоящее время равен <code>min</code>), и отключите вычисление, когда фактор уверенности падает ниже порогового значения. Если посылки вычислены в true то добавьте выводы в базу данных. Последовательность вызовов выглядит так. Обратите внимание, что рекурсивный вызов <code>find-out</code> - это то, что позволяет выполнять цепочку:</p>
<p><code>find-out</code> ; Чтобы узнать параметр для экземпляра:</p>
<p><code>get-db</code> ; Посмотрите, кэшируется ли он в базе данных</p>
<p><code>ask-vals</code> ; Посмотрите, знает ли пользователь ответ</p>
<p><code>use-rules</code> ; Посмотрите, есть ли для этого правило:</p>
<p><code>reject-premise</code> ; Посмотрите, является ли это правило откровенно ложным</p>
<p><code>satisfy-premises</code> ; Или посмотрите, верно ли каждое условие:</p>
<p><code>eval-condition</code> ; Вычислите каждое условие</p>
<p><code>find-out</code> ; Путем нахождения значений параметра</p>
<p>Перед показом интерпретатора приведем определение структуры правил вместе с функциями для поддержки базы данных правил:</p>
<div class="fragment"><div class="line">(defstruct (rule (:print-function print-rule))</div><div class="line">  number premises conclusions cf)</div><div class="line"></div><div class="line">(let ((rules (make-hash-table)))</div><div class="line"></div><div class="line">  (defun put-rule (rule)</div><div class="line">    &quot;Put the rule in a table, indexed under each</div><div class="line">    parm in the conclusion.&quot;</div><div class="line">    (dolist (concl (rule-conclusions rule))</div><div class="line">      (push rule (gethash (first concl) rules)))</div><div class="line">    rule)</div><div class="line"></div><div class="line">  (defun get-rules (parm)</div><div class="line">    &quot;A list of rules that help determine this parameter.&quot;</div><div class="line">    (gethash parm rules))</div><div class="line"></div><div class="line">  (defun clear-rules () (clrhash rules)))</div></div><!-- fragment --><p>Итак, вот интерпретатор <code>find-out</code>. Он может узнать значение (значения) параметра тремя способами. Во-первых, он проверяет, сохранено ли уже значение в базе данных. Затем он пытается спросить пользователя или использовать правила. Порядок, в котором проверяются эти две опции, зависит от свойства параметра <code>parm-ask-first</code>. В любом случае, если ответ определен, он сохраняется в базе данных.</p>
<div class="fragment"><div class="line">(defun find-out (parm &amp;optional (inst (get-db &#39;current-instance)))</div><div class="line">  &quot;Find the value(s) of this parameter for this instance,</div><div class="line">  unless the values are already known.</div><div class="line">  Some parameters we ask first; others we use rules first.&quot;</div><div class="line">  (or (get-db `(known ,parm ,inst))</div><div class="line">      (put-db `(known ,parm ,inst)</div><div class="line">              (if (parm-ask-first (get-parm parm))</div><div class="line">                  (or (ask-vals parm inst) (use-rules parm))</div><div class="line">                  (or (use-rules parm) (ask-vals parm inst))))))</div><div class="line"></div><div class="line">(defun use-rules (parm)</div><div class="line">  &quot;Try every rule associated with this parameter.</div><div class="line">  Return true if one of the rules returns true.&quot;</div><div class="line">  (some #&#39;true-p (mapcar #&#39;use-rule (get-rules parm))))</div><div class="line"></div><div class="line">(defun use-rule (rule)</div><div class="line">  &quot;Apply a rule to the current situation.&quot;</div><div class="line">  ;; Keep track of the rule for the explanation system:</div><div class="line">  (put-db &#39;current-rule rule)</div><div class="line">  ;; If any premise is known false, give up.</div><div class="line">  ;; If every premise can be proved true,  then</div><div class="line">  ;; draw conclusions (weighted with the certainty factor).</div><div class="line">  (unless (some #&#39;reject-premise (rule-premises rule))</div><div class="line">    (let ((cf (satisfy-premises (rule-premises rule) true)))</div><div class="line">      (when (true-p cf)</div><div class="line">        (dolist (conclusion (rule-conclusions rule))</div><div class="line">          (conclude conclusion (* cf (rule-cf rule))))</div><div class="line">        cf))))</div><div class="line"></div><div class="line">(defun satisfy-premises (premises cf-so-far)</div><div class="line">  &quot;A list of premises is satisfied if they are all true.</div><div class="line">  A combined cf is returned.&quot;</div><div class="line">  ;; cf-so-far is an accumulator of certainty factors</div><div class="line">  (cond ((null premises) cf-so-far)</div><div class="line">        ((not (true-p cf-so-far)) false)</div><div class="line">        (t (satisfy-premises</div><div class="line">             (rest premises)</div><div class="line">             (cf-and cf-so-far</div><div class="line">                     (eval-condition (first premises)))))))</div></div><!-- fragment --><p>Функция <code>eval-condition</code> вычисляет одно условие, возвращая его коэффициент достоверности(фактор уверенности). Если <code>find-out-p</code> истинен, она сначала вызывает <code>find-out</code>, который может либо запросить пользователя, либо применить соответствующие правила. Если <code>find-out-p</code> ложен, она вычисляет условие, используя текущее состояние базы данных. Она делает это, просматривая каждое сохраненное значение для пары параметр/экземпляр и вычисляя на нем оператор. Например, если условие равно (<code>temp patient &gt; 98.6</code>), а значения <code>temp</code> для текущего пациента равны (<code>(98 .3) (99 .6) (100 .1)</code>), то <code>eval-condition</code> проверит каждое из значений 98, 99 и 100 против 98,6 с помощью оператора &gt;. Этот тест будет успешным дважды, поэтому результирующий коэффициент достоверности составит .6 + .1 = .7.</p>
<p>Функция <code>reject-premise</code> предназначена для быстрой проверки исключения правила. Таким образом, она вызывает <code>eval-condition</code> с <code>find-out-p</code> nil, поэтому она отклонит предпосылку, только если она явно ложна, без поиска дополнительной информации.</p>
<p>Если посылки правила верны, то выводы добавляются в базу данных с помощью <code>conclude</code>. Обратите внимание, что <code>is</code> - единственный оператор, разрешенный в выводах, <code>is</code> - просто псевдоним для equal(равенства).</p>
<div class="fragment"><div class="line">(defun eval-condition (condition &amp;optional (find-out-p t))</div><div class="line">  &quot;See if this condition is true, optionally using FIND-OUT</div><div class="line">  to determine unknown parameters.&quot;</div><div class="line">  (multiple-value-bind (parm inst op val)</div><div class="line">      (parse-condition condition)</div><div class="line">    (when find-out-p</div><div class="line">      (find-out parm inst))</div><div class="line">    ;; Add up all the (val cf) pairs that satisfy the test</div><div class="line">    (loop for pair in (get-vals parm inst)</div><div class="line">          when (funcall op (first pair) val)</div><div class="line">          sum (second pair))))</div><div class="line"></div><div class="line">(defun reject-premise (premise)</div><div class="line">  &quot;A premise is rejected if it is known false, without</div><div class="line">  needing to call find-out recursively.&quot;</div><div class="line">  (false-p (eval-condition premise nil)))</div><div class="line"></div><div class="line">(defun conclude (conclusion cf)</div><div class="line">  &quot;Add a conclusion (with specified certainty factor) to DB.&quot;</div><div class="line">  (multiple-value-bind (parm inst op val)</div><div class="line">      (parse-condition conclusion)</div><div class="line">    (update-cf parm inst val cf)))</div><div class="line"></div><div class="line">(defun is (a b) (equal a b))</div></div><!-- fragment --><p>Все условия имеют вид: (<em>parameter instance operator value</em>) - (<em>параметр экземпляр оператор значение</em>). Например: <code>(morphology organism is rod).</code> Функция <code>parse-condition</code> превращает список этой формы в четыре значения. Хитрость в том, что она использует базу данных для возврата текущего экземпляра контекста, а не самого имени контекста:</p>
<div class="fragment"><div class="line">(defun parse-condition (condition)</div><div class="line">  &quot;A condition is of the form (parm inst op val).</div><div class="line">  So for (age patient is 21), we would return 4 values:</div><div class="line">  (age patient-1 is 21), where patient-1 is the current patient.&quot;</div><div class="line">  (values (first condition)</div><div class="line">          (get-db (second condition))</div><div class="line">          (third condition)</div><div class="line">          (fourth condition)))</div></div><!-- fragment --><p>На этом этапе такой вызов, как (<code>find-out 'identity 'organism-1</code>) будет действовать правильно, только если мы каким-то образом ввели правильную информацию о текущем пациенте, культуре и организме. Функция <code>get-context-data</code> гарантирует, что каждый контекст обрабатывается по порядку. Сначала создается экземпляр, затем используется <code>find-out</code> для определения как исходных параметров данных, так и целей. Выводы для каждой цели печатаются, и программа спрашивает, есть ли еще один экземпляр этого контекста. Наконец, нам также нужна функция верхнего уровня <code>emycin</code>, которая просто очищает базу данных перед вызовом <code>get-context-data</code>.</p>
<div class="fragment"><div class="line">(defun emycin (contexts)</div><div class="line">  &quot;An Expert System Shell.  Accumulate data for instances of each</div><div class="line">  context, and solve for goals.  Then report the findings.&quot;</div><div class="line">  (clear-db)</div><div class="line">  (get-context-data contexts))</div><div class="line"></div><div class="line">(defun get-context-data (contexts)</div><div class="line">  &quot;For each context, create an instance and try to find out</div><div class="line">  required data.  Then go on to other contexts, depth first,</div><div class="line">  and finally ask if there are other instances of this context.&quot;</div><div class="line">  (unless (null contexts)</div><div class="line">    (let* ((context (first contexts))</div><div class="line">           (inst (new-instance context)))</div><div class="line">      (put-db &#39;current-rule &#39;initial)</div><div class="line">      (mapc #&#39;find-out (context-initial-data context))</div><div class="line">      (put-db &#39;current-rule &#39;goal)</div><div class="line">      (mapc #&#39;find-out (context-goals context))</div><div class="line">      (report-findings context inst)</div><div class="line">      (get-context-data (rest contexts))</div><div class="line">      (when (y-or-n-p &quot;Is there another ~a?&quot;</div><div class="line">                      (context-name context))</div><div class="line">        (get-context-data contexts)))))</div></div><!-- fragment --><h2>16.6 Взаимодействие с экспертом</h2>
<p>На этом этапе вся серьезная вычислительная работа завершена: мы определили механизм правил обратной цепочки, который имеет дело с неопределенностью, кэшированием, запросами и контекстами. Но с точки зрения взаимодействия ввода/вывода предстоит еще немало поработать. Язык программирования должен только взаимодействовать с программистами, поэтому вполне допустимо, чтобы программист делал всю работу. Но оболочка экспертной системы должна облегчить (если не отменить) потребность в программистах. Оболочки экспертной системы действительно имеют два класса пользователей: эксперты используют оболочку при разработке системы, а конечные пользователи или клиенты используют получившуюся экспертную систему, когда она завершена. Иногда эксперт может вводить знания непосредственно в оболочку, но чаще предполагается, что эксперт будет пользоваться помощью <em>инженера знаний</em> - кого-то, кто обучен использованию оболочки и извлечению знаний, но не обязательно либо эксперт в своей области, либо опытный программист.</p>
<p>В нашей версии EMYCIN мы предоставляем только самые простые инструменты, облегчающие работу эксперта. Макросы <code>defcontext</code> и <code>defparm</code>, определенные выше, немного проще, чем явный вызов <code>make-context</code> и <code>make-parm</code>, но не намного. Макрос <code>defrule</code> определяет правило и проверяет наличие очевидных ошибок:</p>
<div class="fragment"><div class="line">(defmacro defrule (number &amp;body body)</div><div class="line">  &quot;Define a rule with conditions, a certainty factor, and</div><div class="line">  conclusions.  Example: (defrule R001 if ... then .9 ...)&quot;</div><div class="line">  (assert (eq (first body) &#39;if))</div><div class="line">  (let* ((then-part (member &#39;then body))</div><div class="line">         (premises (ldiff (rest body) then-part))</div><div class="line">         (conclusions (rest2 then-part))</div><div class="line">         (cf (second then-part)))</div><div class="line">    ;; Do some error checking:</div><div class="line">    (check-conditions number premises &#39;premise)</div><div class="line">    (check-conditions number conclusions &#39;conclusion)</div><div class="line">    (when (not (cf-p cf))</div><div class="line">      (warn &quot;Rule ~a: Illegal certainty factor: ~a&quot; number cf))</div><div class="line">    ;; Now build the rule:</div><div class="line">    `(put-rule</div><div class="line">       (make-rule :number &#39;,number :cf ,cf :premises &#39;,premises</div><div class="line">                  :conclusions &#39;,conclusions))))</div></div><!-- fragment --><p>Функция <code>check-conditions</code> проверяет, что каждое правило имеет по крайней мере одну предпосылку и вывод, что каждое условие имеет правильную форму и что значение условия имеет правильный тип для параметра. Также проверяется, что в выводах используется только оператор <code>is</code>:</p>
<div class="fragment"><div class="line">(defun check-conditions (rule-num conditions kind)</div><div class="line">  &quot;Warn if any conditions are invalid.&quot;</div><div class="line">  (when (null conditions)</div><div class="line">    (warn &quot;Rule ~a: Missing ~a&quot; rule-num kind))</div><div class="line">  (dolist (condition conditions)</div><div class="line">    (when (not (consp condition))</div><div class="line">      (warn &quot;Rule ~a: Illegal ~a: ~a&quot; rule-num kind condition))</div><div class="line">    (multiple-value-bind (parm inst op val)</div><div class="line">        (parse-condition condition)</div><div class="line">      (declare (ignore inst))</div><div class="line">      (when (and (eq kind &#39;conclusion) (not (eq op &#39;is)))</div><div class="line">        (warn &quot;Rule ~a: Illegal operator (~a) in conclusion: ~a&quot;</div><div class="line">              rule-num op condition))</div><div class="line">      (when (not (typep val (parm-type parm)))</div><div class="line">        (warn &quot;Rule ~a: Illegal value (~a) in ~a: ~a&quot;</div><div class="line">              rule-num val kind condition)))))</div></div><!-- fragment --><p>Настоящий EMYCIN имел интерактивную среду, которая запрашивала у эксперта каждый контекст, параметр и правило. Рэндалл Дэвис (<a href="B9780080571157500285.xhtml#bb0290">1977</a>, <a href="B9780080571157500285.xhtml#bb0295">1979</a>, <a href="B9780080571157500285.xhtml#bb0IRESIAS">Davis and Lenat 1982</a> описывает программу TEIRESIAS, которая помогала вводить и отлаживать правила.</p>
<h2>16.7 Взаимодействие с клиентом</h2>
<p>Как только знание получено(введено), нам нужен какой-то способ увидеть(вывести) его. Клиент хочет запустить систему над своей собственной проблемой и увидеть две вещи: решение проблемы и объяснение, почему решение является разумным. EMYCIN предоставляет примитивные возможности для обоих из них. Функция <code>report-findings</code> выводит информацию обо всех параметрах цели для данного экземпляра:</p>
<div class="fragment"><div class="line">(defun report-findings (context inst)</div><div class="line">  &quot;Print findings on each goal for this instance.&quot;</div><div class="line">  (when (context-goals context)</div><div class="line">    (format t &quot;~&amp;Findings for ~a:&quot; (inst-name inst))</div><div class="line">    (dolist (goal (context-goals context))</div><div class="line">      (let ((values (get-vals goal inst)))</div><div class="line">        ;; If there are any values for this goal,</div><div class="line">        ;; print them sorted by certainty factor.</div><div class="line">        (if values</div><div class="line">            (format t &quot;~&amp; ~a:~{~{ ~a (~,3f)  ~}~}&quot; goal</div><div class="line">                    (sort (copy-list values) #&#39;&gt; :key #&#39;second))</div><div class="line">            (format t &quot;~&amp; ~a: unknown&quot; goal))))))</div></div><!-- fragment --><p>Единственная возможность объяснения, которую предлагает наша версия EMYCIN, - это способ увидеть текущее правило. Если пользователь вводит <code>rule</code> в ответ на запрос, печатается псевдоанглийский перевод текущего правила. Вот пример правила и его перевод:</p>
<div class="fragment"><div class="line">(defrule 52</div><div class="line">  if (site culture is blood)</div><div class="line">      (gram organism is neg)</div><div class="line">      (morphology organism is rod)</div><div class="line">      (burn patient is serious)</div><div class="line">  then .4</div><div class="line">      (identity organism is pseudomonas))</div><div class="line">Rule 52:</div><div class="line">  If</div><div class="line">    1) THE SITE OF THE CULTURE IS BLOOD</div><div class="line">    2) THE GRAM OF THE ORGANISM IS NEG</div><div class="line">    3) THE MORPHOLOGY OF THE ORGANISM IS ROD</div><div class="line">    4) THE BURN OF THE PATIENT IS SERIOUS</div><div class="line">  Then there is weakly suggestive evidence (0.4) that</div><div class="line">    1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS</div></div><!-- fragment --><p>Функция <code>print-rule</code> генерирует такой перевод:</p>
<div class="fragment"><div class="line">(defun print-rule (rule &amp;optional (stream t) depth)</div><div class="line">  (declare (ignore depth))</div><div class="line">  (format stream &quot;~&amp;Rule ~a:~&amp;  If&quot; (rule-number rule))</div><div class="line">  (print-conditions (rule-premises rule) stream)</div><div class="line">  (format stream &quot;~&amp;  Then ~a (~a) that&quot;</div><div class="line">          (cf-&gt;english (rule-cf rule)) (rule-cf rule))</div><div class="line">  (print-conditions (rule-conclusions rule) stream))</div><div class="line"></div><div class="line">(defun print-conditions (conditions &amp;optional</div><div class="line">                         (stream t) (num 1))</div><div class="line">  &quot;Print a list of numbered conditions.&quot;</div><div class="line">  (dolist (condition conditions)</div><div class="line">    (print-condition condition stream num)))</div><div class="line"></div><div class="line">(defun print-condition (condition stream number)</div><div class="line">  &quot;Print a single condition in pseudo-English.&quot;</div><div class="line">  (format stream &quot;~&amp;    ~d)~{ ~a~}&quot; number</div><div class="line">          (let ((parm (first condition))</div><div class="line">                (inst (second condition))</div><div class="line">                (op (third condition))</div><div class="line">                (val (fourth condition)))</div><div class="line">            (case val</div><div class="line">              (YES `(the ,inst ,op ,parm))</div><div class="line">              (NO  `(the ,inst ,op not ,parm))</div><div class="line">              (T   `(the ,parm of the ,inst ,op ,val))))))</div><div class="line"></div><div class="line">(defun cf-&gt;english (cf)</div><div class="line">  &quot;Convert a certainy factor to an English phrase.&quot;</div><div class="line">  (cond ((= cf  1.0) &quot;there is certain evidence&quot;)</div><div class="line">        ((&gt; cf   .8) &quot;there is strongly suggestive evidence&quot;)</div><div class="line">        ((&gt; cf   .5) &quot;there is suggestive evidence&quot;)</div><div class="line">        ((&gt; cf  0.0) &quot;there is weakly suggestive evidence&quot;)</div><div class="line">        ((= cf  0.0) &quot;there is NO evidence either way&quot;)</div><div class="line">        ((&lt; cf  0.0) (concatenate &#39;string (cf-&gt;english (- cf))</div><div class="line">                                  &quot; AGAINST the conclusion&quot;))))</div></div><!-- fragment --><p>Если пользователь вводит <code>why</code> в ответ на запрос, печатается более подробное описание того же правила. Сначала отображаются уже известные предпосылки, а затем - оставшаяся часть правила. Запрашиваемый параметр всегда будет первой предпосылкой в оставшейся части правила. <code>current-rule</code> сохраняется в базе данных с помощью <code>use-rule</code> всякий раз, когда применяется правило, но оно также устанавливается с помощью <code>get-context-data</code> для атома <code>initial</code> или цели, когда система запрашивает для параметров. <code>print-why</code> также проверяет этот случай. Обратите внимание на использование функции <code>partition-if</code> со страницы 256.</p>
<div class="fragment"><div class="line">(defun print-why (rule parm)</div><div class="line">  &quot;Tell why this rule is being used.  Print what is known,</div><div class="line">  what we are trying to find out, and what we can conclude.&quot;</div><div class="line">  (format t &quot;~&amp;[Why is the value of ~a being asked for?]&quot; parm)</div><div class="line">  (if (member rule &#39;(initial goal))</div><div class="line">      (format t &quot;~&amp;~a is one of the ~a parameters.&quot;</div><div class="line">              parm rule)</div><div class="line">      (multiple-value-bind (knowns unknowns)</div><div class="line">          (partition-if #&#39;(lambda (premise)</div><div class="line">                            (true-p (eval-condition premise nil)))</div><div class="line">                        (rule-premises rule))</div><div class="line">        (when knowns</div><div class="line">          (format t &quot;~&amp;It is known that:&quot;)</div><div class="line">          (print-conditions knowns)</div><div class="line">          (format t &quot;~&amp;Therefore,&quot;))</div><div class="line">        (let ((new-rule (copy-rule rule)))</div><div class="line">          (setf (rule-premises new-rule) unknowns)</div><div class="line">          (print new-rule)))))</div></div><!-- fragment --><p>Это завершает определение <code>emycin</code>. Теперь мы готовы применить оболочку к конкретному домену, что положит начало созданию экспертной системы.</p>
<h2>16.8 <b>MYCIN</b>, Медицинская экспертная система</h2>
<p>В этом разделе <code>emycin</code> применяется к исходной области Mycin: инфекционное заболевание крови. В нашей версии MYCIN существует три контекста: сначала мы рассматриваем пациента, затем любые культуры, выращенные из образцов, взятых у пациента, и, наконец, любые инфекционные организмы в культурах. Цель состоит в том, чтобы определить идентичность каждого организма. Настоящий MYCIN был более сложным с учетом любых лекарств или операций, которые пациент мог перенести ранее. Он также решал реальный вопрос: какую терапию назначить. Однако большая часть этого была сделана с помощью специальных процедур для расчета оптимальных дозировок и т.п., поэтому здесь они не рассматриваются. Исходный MYCIN также проводил различие между существующими и предшествующими культурами, организмами и лекарствами. Всего нужно было рассмотреть десять контекстов, в то время как в нашей версии их всего три:</p>
<div class="fragment"><div class="line">(defun mycin ()</div><div class="line">  &quot;Determine what organism is infecting a patient.&quot;</div><div class="line">  (emycin</div><div class="line">    (list (defcontext patient  (name sex age)  ())</div><div class="line">          (defcontext culture  (site days-old) ())</div><div class="line">          (defcontext organism ()              (identity)))))</div></div><!-- fragment --><p>Эти контексты объявляют, что мы сначала спросим каждого пациента, имя, пол и возраст, а также месторасположение каждой культуры и количество прошедших дней, с момента её изоляции. Для организмов нет первоначальных вопросов, но для них есть цель: определить идентичность организма.</p>
<p>Следующим шагом является объявление параметров для контекстов. Каждому параметру присваивается тип, и большинству из них даются prompts(приглашения/подсказки), чтобы сделать диалог более естественным:</p>
<div class="fragment"><div class="line">;;; Parameters for patient:</div><div class="line">(defparm name patient t &quot;Patient&#39;s name: &quot; t read-line)</div><div class="line">(defparm sex patient (member male female) &quot;Sex:&quot; t)</div><div class="line">(defparm age patient number &quot;Age:&quot; t)</div><div class="line">(defparm burn patient (member no mild serious)</div><div class="line">  &quot;Is ~a a burn patient?  If so, mild or serious?&quot; t)</div><div class="line">(defparm compromised-host patient yes/no</div><div class="line">  &quot;Is ~a a compromised host?&quot;)</div><div class="line"></div><div class="line">;;; Parameters for culture:</div><div class="line">(defparm site culture (member blood)</div><div class="line">  &quot;From what site was the specimen for ~a taken?&quot; t)</div><div class="line">(defparm days-old culture number</div><div class="line">  &quot;How many days ago was this culture (~a) obtained?&quot; t)</div><div class="line"></div><div class="line">;;; Parameters for organism:</div><div class="line">(defparm identity organism</div><div class="line">  (member pseudomonas klebsiella enterobacteriaceae</div><div class="line">          staphylococcus bacteroides streptococcus)</div><div class="line">  &quot;Enter the identity (genus) of ~a:&quot; t)</div><div class="line">(defparm gram organism (member acid-fast pos neg)</div><div class="line">  &quot;The gram stain of ~a:&quot; t)</div><div class="line">(defparm morphology organism (member rod coccus)</div><div class="line">  &quot;Is ~a a rod or coccus (etc.):&quot;)</div><div class="line">(defparm aerobicity organism (member aerobic anaerobic))</div><div class="line">(defparm growth-conformation organism</div><div class="line">  (member chains pairs clumps))</div></div><!-- fragment --><p>Теперь нам нужны некоторые правила, которые помогут определить идентичность организмов. Следующие правила взяты из <a href="B9780080571157500285.xhtml#bb1100">Shortliffe 1976</a>. Номера правил относятся к страницам, на которых они перечислены. Настоящий MYCIN имел около 400 правил, касающихся гораздо более широкого спектра предпосылок и выводов.</p>
<div class="fragment"><div class="line">(clear-rules)</div><div class="line"></div><div class="line">(defrule 52</div><div class="line">  if (site culture is blood)</div><div class="line">     (gram organism is neg)</div><div class="line">     (morphology organism is rod)</div><div class="line">     (burn patient is serious)</div><div class="line">  then .4</div><div class="line">     (identity organism is pseudomonas))</div><div class="line"></div><div class="line">(defrule 71</div><div class="line">  if (gram organism is pos)</div><div class="line">     (morphology organism is coccus)</div><div class="line">     (growth-conformation organism is clumps)</div><div class="line">  then .7</div><div class="line">     (identity organism is staphylococcus))</div><div class="line"></div><div class="line">(defrule 73</div><div class="line">  if (site culture is blood)</div><div class="line">     (gram organism is neg)</div><div class="line">     (morphology organism is rod)</div><div class="line">     (aerobicity organism is anaerobic)</div><div class="line">  then .9</div><div class="line">     (identity organism is bacteroides))</div><div class="line"></div><div class="line">(defrule 75</div><div class="line">  if (gram organism is neg)</div><div class="line">     (morphology organism is rod)</div><div class="line">     (compromised-host patient is yes)</div><div class="line">  then .6</div><div class="line">     (identity organism is pseudomonas))</div><div class="line"></div><div class="line">(defrule 107</div><div class="line">  if (gram organism is neg)</div><div class="line">     (morphology organism is rod)</div><div class="line">     (aerobicity organism is aerobic)</div><div class="line">  then .8</div><div class="line">     (identity organism is enterobacteriaceae))</div><div class="line"></div><div class="line">(defrule 165</div><div class="line">  if (gram organism is pos)</div><div class="line">     (morphology organism is coccus)</div><div class="line">     (growth-conformation organism is chains)</div><div class="line">  then .7</div><div class="line">     (identity organism is streptococcus))</div></div><!-- fragment --><p>Вот пример использования программы:</p>
<div class="fragment"><div class="line">&gt; (mycin)</div><div class="line">------ PATIENT-1 ------</div><div class="line">Patient&#39;s name: Sylvia Fischer</div><div class="line">Sex: female</div><div class="line">Age: 27</div><div class="line">------ CULTURE-1 ------</div></div><!-- fragment --><p><code>From what site was the specimen for CULTURE-1 taken? blood</code></p>
<p><code>How many days ago was this culture (CULTURE-1) obtained? 3</code></p>
<div class="fragment"><div class="line">------ ORGANISM-1 ------</div><div class="line">Enter the identity (genus) of ORGANISM-1: unknown</div><div class="line">The gram stain of ORGANISM-1: ?</div><div class="line">A GRAM must be of type (MEMBER ACID-FAST POS NEG)</div><div class="line">The gram stain of ORGANISM-1: neg</div></div><!-- fragment --><p>Пользователь набрал ? чтобы увидеть список действительных ответов. Диалог продолжается:</p>
<div class="fragment"><div class="line">Is ORGANISM-1 a rod or coccus (etc.): rod</div></div><!-- fragment --><p><code>What is the AEROBICITY of ORGANISM-1? Why</code></p>
<div class="fragment"><div class="line">[Why is the value of AEROBICITY being asked for?]</div><div class="line">It is known that:</div><div class="line">      1) THE GRAM OF THE ORGANISM IS NEG</div><div class="line">      2) THE MORPHOLOGY OF THE ORGANISM IS ROD</div><div class="line">Therefore,</div><div class="line">Rule 107:</div><div class="line">  If</div><div class="line">      1) THE AEROBICITY OF THE ORGANISM IS AEROBIC</div><div class="line">  Then there is suggestive evidence (0.8) that</div><div class="line">      1) THE IDENTITY OF THE ORGANISM IS ENTEROBACTERIACEAE</div></div><!-- fragment --><p>Пользователь хочет знать, почему система спрашивает об аэробности организма. Ответ показывает текущее правило, то, что уже известно о правиле, и тот факт, что если организм аэробный, то мы можем сделать некоторые выводы о его идентичности. В этом гипотетическом случае организм фактически аэробен:</p>
<p><code>What is the AEROBICITY of ORGANISM-1? aerobic</code></p>
<p><code>Is Sylvia Fischer a compromised host? yes</code></p>
<p>`Is Sylvia Fischer a burn patient? If so. mild or serious? why`</p>
<div class="fragment"><div class="line">[Why is the value of BURN being asked for?]</div><div class="line">It is known that:</div><div class="line">      1) THE SITE OF THE CULTURE IS BLOOD</div><div class="line">      2) THE GRAM OF THE ORGANISM IS NEG</div><div class="line">      3) THE MORPHOLOGY OF THE ORGANISM IS ROD</div><div class="line">Therefore,</div><div class="line">Rule 52:</div><div class="line">  If</div><div class="line">      1) THE BURN OF THE PATIENT IS SERIOUS</div><div class="line">  Then there is weakly suggestive evidence (0.4) that</div><div class="line">      1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS</div></div><!-- fragment --><p>`Is Sylvia Fischer a burn patient? If so, mild or serious? serious`</p>
<div class="fragment"><div class="line">Findings for ORGANISM-1:</div><div class="line">  IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)</div></div><!-- fragment --><p>Система использовала правило 107, чтобы сделать вывод, что это могут быть энтеробактерии. Уверенность равна .8, достоверность самого правила, потому что все условия были достоверно известны. Правила 52 и 75 поддерживают гипотезу псевдомонад. Коэффициенты достоверности двух правил, .6 и .4, объединяются по формуле .6 + .4 - (.6 x .4) = .76. После распечатки результатов для первого организма система спрашивает, был ли другой организм получен из этой культуры:</p>
<p><code>Is there another ORGANISM? (Y or N) Y</code></p>
<div class="fragment"><div class="line">------ ORGANISM-2 ------</div><div class="line">Enter the identity (genus) of ORGANISM-2: unknown</div><div class="line">The gram stain of ORGANISM-2: (neg .8 pos .2)</div><div class="line">Is ORGANISM-2 a rod or coccus (etc.): rod</div></div><!-- fragment --><p><code>What is the AEROBICITY of ORGANISM-2? anaerobic</code></p>
<p>Для второго организма лабораторный тест не дал результатов, поэтому пользователь ввел квалифицированный ответ, указывающий, что он, вероятно, является грамотрицательным, но, возможно, грамположительным. Этот организм тоже был rod, но был анаэробным. Обратите внимание, что система не повторяет вопросы, ответы на которые ей уже известны. При рассмотрении правил 75 и 52 она уже знает, что посев произошел из крови, и что пациент является скомпрометированным хозяином и серьезным ожоговым пациентом. В конце концов, правило 73 способствует выводу о бактероидах, а правила 75 и 52 снова объединяются, чтобы предложить pseudomonas, хотя и с более низким фактором уверенности, потому что обнаружение neg имело более низкий фактор уверенности:</p>
<div class="fragment"><div class="line">Findings for ORGANISM-2:</div><div class="line">  IDENTITY: BACTEROIDES (0.720) PSEUDOMONAS (0.646)</div></div><!-- fragment --><p>Наконец, программа дает пользователю возможность расширить контекстное дерево новыми организмами, культурами или пациентами:</p>
<p><code>Is there another ORGANISM? (Y or N) N</code></p>
<p><code>Is there another CULTURE? (Y or N) N</code></p>
<p><code>Is there another PATIENT? (Y or N) N</code></p>
<p>Набор правил, перечисленных выше, не демонстрирует двух важных характеристик системы: возможность обратной цепочки и возможность использовать операторы, отличные от тех, которые находятся в помещении.</p>
<p>Если мы добавим следующие три правила и повторим случай, показанный выше, то вычисление правила 75 вернется к правилу 1, 2 и, наконец, 3, пытаясь определить, является ли пациент скомпрометированным хозяином. Обратите внимание, что задается вопрос: "What is Sylvia Fischer's white blood cell count?"(Какое количество лейкоцитов у Сильвии Фишер?), а не "Is the white blood cell count of Sylvia Fischer &lt; 2.5?"(Является ли количество лейкоцитов Сильвии Фишер &lt; 2.5?) Последний вопрос будет достаточным для рассматриваемой предпосылки, но не будет столь же полезным для других правил, которые могут относиться к WBC.</p>
<div class="fragment"><div class="line">(defparm wbc patient number</div><div class="line">  &quot;What is ~a&#39;s white blood cell count?&quot;)</div><div class="line">(defrule 1</div><div class="line">  if (immunosuppressed patient is yes)</div><div class="line">  then 1.0 (compromised-host patient is yes))</div><div class="line">(defrule 2</div><div class="line">  if (leukopenia patient is yes)</div><div class="line">  then 1.0 (immunosuppressed patient is yes))</div><div class="line">(defrule 3</div><div class="line">  if (wbc patient &lt;  2.5)</div><div class="line">  then .9 (leukopenia patient is yes))</div></div><!-- fragment --><h2>16.9 Альтернативы факторам уверенности</h2>
<p>Факторы уверенности - это компромисс. Хорошая новость заключается в том, что система, основанная на правилах с факторами уверенности, требует, чтобы эксперт придумал только небольшой набор чисел (по одному для каждого правила), и позволит быстро вычислять ответы. Плохая новость в том, что вычисленный ответ может привести к иррациональным решениям.</p>
<p>Факторы уверенности были подтверждены их эффективностью (MYCIN работает так же или лучше, чем опытные врачи) и интуитивным обращением (они удовлетворяют критериям, перечисленным на странице 534). Однако они подвержены парадоксам, когда вычисляют странные результаты (как в упражнении 16.1, стр. 536). Если правила, составляющие базу знаний, построены по модульному принципу, то проблем обычно не возникает, но, безусловно, вызывает беспокойство то, что ответы могут быть недостоверными.</p>
<p>До MYCIN большинство рассуждений о неопределенности делалось с помощью теории вероятностей. Законы вероятности - в частности, закон Байеса - представляют собой хорошо обоснованный математический формализм, который не зависит от несоответствий факторов уверенности. Действительно, можно показать, что теория вероятностей является единственным формализмом, ведущим к рациональному поведению, в том смысле, что если вам нужно сделать серию ставок на некоторые неопределенные события, объединение информации с теорией вероятности даст вам наивысшую ожидаемую ценность для вашего Пари. Несмотря на это, в середине 1970-х от теории вероятностей отказались. Аргумент, сделанный <a href="B9780080571157500285.xhtml#bb1105">Шортлиффом и Бьюкененом (1975)</a>, заключался в том, что теория вероятностей требует слишком большого количества условных вероятностей и что люди не умеют их оценивать. Они утверждали, что с факторами уверенности интуитивно легче справиться. Эту точку зрения разделяли и другие исследователи того времени. Шафер с последующими уточнениями Демпстера создал теорию функций убеждений, которая, как и факторы уверенности, представляет собой комбинацию убеждений за и против события. Вместо того, чтобы представлять событие единственной вероятностью или определенностью, теория Демпстера-Шафера поддерживает два числа, которые аналогичны нижней и верхней границе вероятности. Вместо одного числа, такого как .5, теория Демпстера-Шейфера будет иметь интервал вроде [.4, .6], представляющий диапазон вероятностей. Полное отсутствие знаний будет представлено диапазоном [0,1]. В конце 1970-х - начале 1980-х годов было вложено много усилий в эти и другие невероятностные теории. Другой пример - теория нечетких множеств Заде, которая также основана на интервалах.</p>
<p>Существует множество свидетельств того, что людям трудно решать проблемы, связанные с вероятностью. В серии очень занимательных и наводящих на размышления статей Тверски и Канеман (<a href="B9780080571157500285.xhtml#bb1245">1974</a>, <a href="B9780080571157500285.xhtml#bb1250">1983</a>, <a href="B9780080571157500285.xhtml#bb1255">1986</a>) как люди делают иррациональный выбор, когда сталкиваются с проблемами, довольно простыми с математической точки зрения. Они сравнивают эти ошибки в выборе с ошибками визуального восприятия, вызванными оптическими иллюзиями. Этим ошибкам подвержены даже обученные врачи и статистики.</p>
<p>В качестве примера рассмотрим следующий сценарий. Адриан и Доминика собираются пожениться. Адриан идет на обычный анализ крови, и ему говорят, что результаты положительны для редкого генетического заболевания, которым страдает только 1 человек из 10 000. Врач говорит, что тест на 99% точен - он дает ложноположительные результаты только в 1 из 100 случаев. Адриан подавлен, будучи убежденным, что вероятность того, что действительно заболеть, составляет 99%. К счастью, Доминика оказалась знакомой с байесовской теорией и быстро успокоила Адриана, что вероятность около 1%. Рассуждения таковы: возьмите 10 001 человека наугад. Предполагается, что из них только 1 болен. Этот человек определенно мог ожидать положительный результат теста на болезнь. Но если все остальные 10 000 человек сдадут анализ крови, то 1% из них или 100 человек также будут иметь положительный результат. Таким образом, вероятность того, что действительно заболеть, при положительном результате теста составляет 1/101. Докторов обучили такому анализу, но, к сожалению, многие из них продолжают рассуждать больше как Адриан, чем Доминика.</p>
<p>В конце 1980-х годов волна субъективной байесовской теории вероятностей начала возвращаться. <a href="B9780080571157500285.xhtml#bb0185">Cheeseman (1985)</a> показал, что, хотя теория Демпстера-Шафера выглядит способной, на самом деле она не может помочь вам принимать лучшие решения, чем теория вероятностей. <a href="B9780080571157500285.xhtml#bb0525">Хекерман (1986)</a> повторно исследовал факторы достоверности MYCIN, показывая, как их можно интерпретировать как вероятности. Книга Иудеи <a href="B9780080571157500285.xhtml#bb0935">Перл, 1988</a> является красноречивой защитой теории вероятностей. Он показывает, что существуют эффективные алгоритмы для объединения и распространения вероятностей, пока сеть взаимозависимостей не содержит петель. Кажется вероятным, что неопределенные рассуждения в 1990-х годах все больше будут основываться на байесовской теории вероятностей.</p>
<h2>16.10 История и Ссылки</h2>
<p>The MYCIN project is well documented in <a href="B9780080571157500285.xhtml#bb0145">Buchanan and Shortliffe 1984</a>. An earlier book, <a href="B9780080571157500285.xhtml#bb1100">Shortliffe 1976</a>, is interesting mainly for historical purposes. Good introductions to expert systems in general include <a href="B9780080571157500285.xhtml#bb1365">Weiss and Kulikowski 1984</a>, <a href="B9780080571157500285.xhtml#bb1345">Waterman 1986</a>, <a href="B9780080571157500285.xhtml#bb0760">Luger and Stubblefield 1989</a>, and <a href="B9780080571157500285.xhtml#bb0580">Jackson 1990</a>.</p>
<p>Dempster-Shafer evidence theory is presented enthusiastically in <a href="B9780080571157500285.xhtml#bb0485">Gordon and Shortliffe 1984</a> and in a critical light in <a href="B9780080571157500285.xhtml#bb0940">Pearl 1989</a>/1978. Fuzzy set theory is presented in Zadeh 1979 and <a href="B9780080571157500285.xhtml#bb0350">Dubois and Prade 1988</a>.</p>
<p><a href="B9780080571157500285.xhtml#bb0935">Pearl (1988)</a> captures most of the important points that lead to the renaissance of probability theory. <a href="B9780080571157500285.xhtml#bb1090">Shafer and Pearl 1990</a> is a balanced collection of papers on all kinds of uncertain reasoning.</p>
<h2>16.11 Упражнения</h2>
<p><b>Exercise 16.2 [s]</b> Suppose the rule writer wanted to be able to use symbolic certainty factors instead of numbers. What would you need to change to support rules like this:</p>
<div class="fragment"><div class="line">(defrule 100 if ... then true ...)</div><div class="line">(defrule 101 if ... then probably ...)</div></div><!-- fragment --><p><b>Exercise 16.3 [m]</b> Change <code>prompt-and-read-vals</code> so that it gives a better prompt for parameters of type <code>yes/no</code>.</p>
<p><b>Exercise 16.4 [m]</b> Currently, the rule writer can introduce a new parameter without defining it first. That is handy for rapid testing, but it means that the user of the system won't be able to see a nice English prompt, nor ask for the type of the parameter. In addition, if the rule writer simply misspells a parameter, it will be treated as a new one. Make a simple change to fix these problems.</p>
<p><b>Exercise 16.5 [d]</b> Write rules in a domain you are an expert in, or find and interview an expert in some domain, and write down rules coaxed from the expert. Evaluate your resulting system. Was it easier to develop your system with EMYCIN than it would have been without it?</p>
<p><b>Exercise 16.6 [s]</b> It is said that an early version of MYCIN asked if the patient was pregnant, even though the patient was male. Write a rule that would fix this problem.</p>
<p><b>Exercise 16.7 [m]</b> To a yes/no question, what is the difference between yes and <code>(no-1)</code> ? What does this suggest?</p>
<p><b>Exercise 16.8 [m]</b> What happens if the user types <code>why</code> to the prompt about the patient's name? What happens if the expert wants to have more than one context with a name parameter? If there is a problem, fix it.</p>
<p>The remaining exercises discuss extensions that were in the original EMYCIN, but were not implemented in our version. Implementing all the extensions will result in a system that is very close to the full power of EMYCIN. These extensions are discussed in <a href="B9780080571157500030.xhtml">chapter 3</a> of <a href="B9780080571157500285.xhtml#bb0145">Buchanan and Shortliffe 1984</a>.</p>
<p><b>Exercise 16.9 [h]</b> Add a spelling corrector to <code>ask-vals</code>. If the user enters an invalid reply, and the parameter type is a <code>member</code> expression, check if the reply is "close" in spelling to one of the valid values, and if so, use that value. That way, the user can type just <code>entero</code> instead of <code>enterobacteriaceae</code>. You may experiment with the definition of "close," but you should certainly allow for prefixes and at least one instance of a changed, missing, inserted, or transposed letter.</p>
<p><b>Exercise 16.10 [m]</b> Indent the output for each new branch in the context tree. In other words, have the prompts and findings printed like this:</p>
<div class="fragment"><div class="line">------ PATIENT-1 ------</div><div class="line">Patient&#39;s name: Sylvia Fischer</div><div class="line">Sex: female</div><div class="line">Age: 27</div><div class="line">      ------ CULTURE-1 ------</div></div><!-- fragment --><p><code>From what site was the specimen for CULTURE-1 taken? blood</code></p>
<p><code>How many days ago was this culture (CULTURE-1) obtained? 3</code></p>
<div class="fragment"><div class="line">------ ORGANISM-1 ------</div><div class="line">Enter the identity (genus) of ORGANISM-1: unknown</div><div class="line">The gram stain of ORGANISM-1: neg</div><div class="line">...</div><div class="line">Findings for ORGANISM-1:</div><div class="line">  IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)</div></div><!-- fragment --><p><code>Is there another ORGANISM? (Y or N) N</code></p>
<p><code>Is there another CULTURE? (Y or N) N</code></p>
<p><code>Is there another PATIENT? (Y or N) N</code></p>
<p><b>Exercise 16.11 [h]</b> We said that our <code>emycin</code> looks at all possible rules for each parameter, because there is no telling how a later rule may affect the certainty factor. Actually, that is not quite true. If there is a rule that leads to a conclusion with certainty 1, then no other rules need be considered. This was called a <em>unity path</em>. Modify the program to look for unity paths first.</p>
<p><b>Exercise 16.12 [m]</b> Depending on whether a parameter is in <code>initial-data</code> or not, all the relevant rules are run either before or after asking the user for the value of the parameter. But there are some cases when not all initial data parameters should be asked for. As an example, suppose that <code>identity</code> and <code>gram</code> were initial data parameters of <code>organism</code>. If the user gave a positive answer for <code>identity</code>, then it would be wasteful to ask for the <code>gram</code> parameter, since it could be determined directly from rules. After receiving complaints about this problem, a system of <em>antecedent rules</em> was developed. These rules were always run first, before asking questions. Implement antecedent rules.</p>
<p><b>Exercise 16.13 [h]</b> It is useful to be able to write <em>default rules</em> that fill in a value after all other rules have failed to determine one. A default rule looks like this:</p>
<div class="fragment"><div class="line">(defrule n if (parm inst unknown) then (parm inst is default))</div></div><!-- fragment --><p>It may also have other conjuncts in the premise. Beside details like writing the <code>unknown</code> operator, the difficult part is in making sure that these rules get run at the right time (after other rules have had a chance to fill in the parameter), and that infinite loops are avoided.</p>
<p><b>Exercise 16.14 [h]</b> The context tree proved to be a limitation. Eventually, the need arose for a rule that said, "If any of the organisms in a culture has property X, then the culture has property Y." Implement a means of checking for <code>some</code> or <code>every</code> instance of a context.</p>
<p><b>Exercise 16.15 [m]</b> As the rule base grew, it became increasingly hard to remember the justification for previous rules. Implement a mechanism that keeps track of the author and date of creation of each rule, and allows the author to add documentation explaining the rationale for the rule.</p>
<p><b>Exercise 16.16 [m]</b> It is difficult to come up with the perfect prompt for each parameter. One solution is not to insist that one promptfits all users, but rather to allow the expert to supply three different prompts: a normal prompt, a verbose prompt (or reprompt) for when the user replies with a ?, and a terse prompt for the experienced user. Modify <code>defparm</code> to accommodate this concept, add a command for the user to ask for the terse prompts, and change <code>ask-vals</code> to use the proper prompt.</p>
<p>The remaining exercises cover three additional replies the user can make: <code>how</code>, <code>stop</code>, and <code>change</code>.</p>
<p><b>Exercise 16.17 [d]</b> In addition to <code>why</code> replies, EMYCIN also allowed for <code>how</code> questions. The user can ask how the value of a particular parameter/instance pair was determined, and the system will reply with a list of rules and the evidence they supplied for or against each value. Implement this mechanism. It will require storing additional information in the data base.</p>
<p><b>Exercise 16.18 [m]</b> There was also a stop command that immediately halted the session. Implement it.</p>
<p><b>Exercise 16.19 [d]</b> The original EMYCIN also had a change command to allow the user to change the answer to certain questions without starting all over. Each question was assigned a number, which was printed before the prompt. The command change, followed by a list of numbers, causes the system to look up the questions associated with each number and delete the answer to these questions. The system also throws away the entire context tree and all derived parameter values. At that point the entire consultation is restarted, using only the data obtained from the unchanged questions. Although it may seem wasteful to start over from the beginning, it will not be wasteful of the user's time, since correct answers will not be asked again.</p>
<p>Identify what needs to be altered to implement change and make the alterations.</p>
<p><b>Exercise 16.20 [h]</b> Change the definition of <code>cf</code>-and and <code>cf-or</code> to use fuzzy set theory instead of certainty factors. Do the same for Dempster-Shafer theory.</p>
<h2>16.12 Ответы</h2>
<p><b>Answer 16.1</b> Because EMYCIN assumes independence, each reading of the same headline would increase the certainty factor. The following computation shows that 298 more copies would be needed to reach .95 certainty. A more sophisticated reasoner would realize that multiple copies of a newspaper are completely dependent on one another, and would not change the certainty with each new copy.</p>
<div class="fragment"><div class="line">&gt; (loop for cf = .01 then (cf-or .01 cf)</div><div class="line">      until (&gt; cf .95)</div><div class="line">      count t)</div><div class="line">298</div></div><!-- fragment --><p><b>Answer 16.2</b> The <code>defrule</code> expandsto (<code>make-rule :number '101 :cf true ...</code>); that is, the certainty factor is unquoted, so it is already legal to use true as a certainty factor! To support <code>probably</code> and other hedges, just define new constants.</p>
<p><b>Answer 16.4</b> Just make the default parameter type be <code>nil</code> (by changing <code>t</code> to <code>nil</code> in <code>parm-type</code>). Then any rule that uses an undefined parameter will automatically generate a warning.</p>
<p><b>Answer 16.6</b></p>
<div class="fragment"><div class="line">(defrule 4</div><div class="line">  if (sex patient is male)</div><div class="line">  then -  1 (pregnant patient is yes))</div></div><!-- fragment --><p><b>Answer 16.7</b> Logically, there should be no difference, but to EMYCIN there is a big difference. EMYCIN would not complain if you answered <code>(yes 1 no 1)</code>. This suggests that the system should have some way of dealing with mutually exclusive answers. One way would be to accept only yes responses for Boolean parameters, but have the input routine translate no to <code>(yes -1)</code> and <code>(no *cf*)</code> to <code>(yes 1-*cf*)</code>. Another possibility would be to have <code>update-cf check</code> to see if any certainty factor on a mutually exclusive value is 1, and if so, change the other values to -1.</p>
<p><b>Answer 16.18</b> Add the clause <code>(stop (throw 'stop nil))</code> to the case statement inask-valsandwrapa <code>(catch 'stop ...)</code> around the code in <code>emycin</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
