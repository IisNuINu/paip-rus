# Глава 16
## Экспертные Системы

> Эксперт - это тот, кто знает все больше и больше о все меньшем и меньшем.

> -Nicholas Murray Butler (1862-1947)

В 1970-х годах был ужасный интерес к области *экспертных систем, основанных на знаниях*.
Экспертная система или система, основанная на знаниях, - это система, которая решает проблемы, применяя знания, полученные от одного или нескольких экспертов в данной области.
Поскольку эти эксперты, как правило, не являются программистами, они, скорее всего, выразят свои знания в терминах, которые нельзя сразу перевести в программу.
Целью исследования экспертных систем является создание представления, достаточно гибкого для обработки экспертных знаний, но все же пригодного для манипулирования компьютерной программой для выработки решений.

Правдоподобный кандидат на это представление - такие же логические факты и правила, как в Прологе.
Однако есть три области, в которых Пролог плохо поддерживает системемы, основанные на общих знаниях:

* Рассуждения с неуверенностью(Нечеткие рассуждения).
Пролог имеет дело только с черно-белым миром фактов, которые явно истинны или ложны (и он даже не очень хорошо справляется с ложью).
Часто эксперты выражают эмпирические правила, которые "вероятны(likely)" или "уверены(certain) на 90%".

* Объяснение.
Prolog дает решения для запросов, но не указывает, как эти решения были получены.
Система, которая может объяснить пользователю свои решения в понятной форме, будет пользоваться большим доверием.

* Гибкий выбор типа потока управления.
Prolog работает путем обратной цепочки от цели.
В некоторых случаях нам может потребоваться более разнообразная стратегия контроля/управления.
Например, в медицинской диагностике прописан порядок получения определенной информации о пациенте.
Медицинская система должна следовать этому порядку, даже если он не вписывается в стратегию обратной цепочки.

Ранние экспертные системы использовали самые разные методы для решения этих проблем.
В конце концов стало ясно, что определенные методы используются часто, и они были зафиксированы в *оболочках экспертных систем*: специализированных средах программирования, которые помогали получать знания от экспертов и использовать их для решения проблем и предоставления объяснений.
Идея заключалась в том, что эти оболочки обеспечат более высокий уровень абстракции, чем просто Lisp или Prolog, и упростят написание новых экспертных систем.

Экспертная система MYCIN была одной из первых и остается одной из самых известных.
Это было написано доктором Эдвардо Шортлиффом в 1974 году как эксперимент по медицинской диагностике.
MYCIN был разработана для назначения антибактериальной терапии при бактериальных инфекциях крови, и когда она была завершена, она была оценена для выполнения этой задачи как эксперт в этой области
Её название происходит от общего суффикса лекарств, которые он назначает: эритромицин, клиндамицин и так далее.
Ниже приводится слегка измененная версия одного из правил MYCIN, а также перефразирование на английский язык, созданное системой:

```lisp
(defrule 52
```

  `if (site culture is blood)`

    `(gram organism is neg)`

    `(morphology organism is rod)`

    `(burn patient is serious)`

  `then .4`

    `(identity organism is pseudomonas))`

```lisp
Rule 52:
```

  `If`

    `1) THE SITE OF THE CULTURE IS BLOOD`

    `2) THE GRAM OF THE ORGANISM IS NEG`

    `3) THE MORPHOLOGY OF THE ORGANISM IS ROD`

    `4) THE BURN OF THE PATIENT IS SERIOUS`

  `Then there is weakly suggestive evidence (0.4) that`

    `1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS`

MYCIN привел к разработке оболочки экспертной системы EMYCIN.
EMYCIN означает "сущность(essential) MYCIN", хотя его часто неправильно представляют как "пустой(empty) MYCIN".
В любом случае, название относится к оболочке для получения знаний, рассуждений с ее помощью и объяснения результатов без конкретных медицинских знаний.

EMYCIN - это интерпретатор правил с обратной цепочкой, который имеет много общего с Prolog.
Однако есть четыре важных отличия.
Во-первых, и это наиболее важно, EMYCIN имеет дело с неопределенностью.
Вместо того чтобы настаивать на том, чтобы все предсказания были истинными или ложными, EMYCIN связывает с каждым предсказанием *фактор достоверности*.
Во-вторых, EMYCIN кэширует результаты своих вычислений, чтобы их не нужно было дублировать.
В-третьих, EMYCIN предоставляет системе простой способ запросить информацию у пользователя.
В-четвертых, он дает объяснения своего поведения.
Это можно выразить уравнением:

```lisp
EMYCIN = Prolog + uncertainty + caching + questions + explanations
```

Сначала мы рассмотрим отличия EMYCIN от Prolog.
После этого мы вернемся к основному ядру EMYCIN, интерпретатору правил с обратной цепочкой.
Наконец, мы покажем, как добавить некоторые медицинские знания к EMYCIN для воссоздания MYCIN.
Глоссарий программы находится на [рисунок 16.1](#f0010).

| []()                                         |
|----------------------------------------------|
| ![f16-01](images/chapter16/f16-01.jpg)       |
| Рисунок 16.1: Глоссарий программы EMYCIN |

*(ed: this could be a markdown table)*

## 16.1 Работа с неопределенностью

EMYCIN имеет дело с неопределенностью, заменяя два логических значения, истинное и ложное, на диапазон значений, называемых *факторами достоверности*.
Это числа от -1 (ложь) до + 1 (истина), где 0 представляет собой полностью неизвестное.
В Лиспе:

```lisp
(defconstant true +  1.0)
(defconstant false -  1.0)
(defconstant unknown 0.0)
```

Чтобы определить логику факторов достоверности, нам необходимо определить логические операции, такие как `and/и`, `or/или`, `not/не`. Первая операция, которую следует рассмотреть, - это сочетание двух различных частей доказательств, выраженных как факторы определенности.
Предположим, мы пытаемся определить вероятность того, что у пациента есть заболевание &Chi;.
Предположим, что у нас есть группа предыдущих пациентов, которым были даны два лабораторных теста.
Первый тест говорит, что у 60% пациентов есть заболевание, а второй говорит, что  оно есть у 40%.
Как нам объединить эти два доказательства в одно?
К сожалению, невозможно правильно ответить на этот вопрос, не зная больше о *зависимости* двух источников друг от друга.
Предположим, что первый тест показывает, что 60% пациентов (которые все оказались мужчинами) имеют болезнь, а второй говорит, что 40% (которые все оказались женщинами) болеют.
Тогда мы должны сделать вывод, что он есть у 100%, потому что два теста охватывают все население.
С другой стороны, если первый тест положителен только для пациентов в возрасте 70 лет и старше, а второй положителен только для пациентов в возрасте 80 лет и старше, то второй является лишь частью первого.
Это не добавляет никакой новой информации, поэтому в данном случае правильный ответ - 60%.

В [section 16.9](#s0050) мы рассмотрим способы учета такого рода рассуждений.
А пока мы представим метод комбинирования, фактически используемый в EMYCIN.
Он определяется формулой:

combine (A, B) =

A+B-AB;A,B>0A+B+AB;A,B<0A+B1-minAB;otherwise

![si1_e](images/chapter16/si1_e.gif)

Согласно этой формуле, combine(.60,.40) = .76, что является компромиссом между крайними значениями 0,60 и 1,00.
Это то же самое, что вероятность p(A or B), если предположить, что A и B независимы.

Однако должно быть ясно, что факторы уверенности - это не то же самое, что вероятности.
Факторы уверенности пытаются справиться с недоверием так же, как с доверием, но не с зависимостью и независимостью.
Функция комбинирования EMYCIN имеет ряд желаемых свойств:

* Он всегда вычисляет число от - 1 до +1.

* Комбинирование неизвестного (нуля) с чем-либо ничего не меняет.

* Объединение истины с чем угодно (кроме ложи) дает истину.

* Объединение истины и лжи является ошибкой.

* Комбинирование двух противоположностей дает неизвестное.

* Объединение/комбинирование двух положительных результатов (кроме истинного) дает больший положительный результат.

* Комбинирование положительного и отрицательного дает нечто среднее.

До сих пор мы видели, как combine(комбинирование) двух отдельных доказательств одной и той же гипотезы.
Другими словами, если у нас есть два правила:

A => C

B => C

и мы знаем A с коэффициентом достоверности (certainty factor - cf) .6 и B со значением cf .4, тогда мы можем заключить C с cf  .76.
Но рассмотрим правило с коньюнкцией(объединением) в посылке:

A and B => C

Комбинирование A и B в этом случае сильно отличается от их комбинирования, когда они находятся в отдельных правилах.
EMYCIN выбирает комбинирование объединений, беря минимум фактора уверенности(cf) каждого конъюнкта.
Если бы факторы уверенности были вероятностями, это было бы эквивалентно предположению зависимости между конъюнктами в правиле.
(Если бы конъюнкты были независимыми, то правильным ответом было бы произведение вероятностей.) Итак, EMYCIN делает вполне разумное (но иногда неверное) предположение, что условия, связанные вместе в одном правиле, будут зависеть друг от друга, в то время как условия в отдельных правилах независимы.

Последняя сложность заключается в том, что сами правила могут быть неопределенными.
То есть MYCIN использует правила, которые выглядят так:

A and B => .9C

говорят, что A и B подразумевают C с уверенностью(cf) .9.
EMYCIN просто умножает cf правила на комбинированный cf предпосылки.
Таким образом, если A имеет cf .6, а B имеет cf .4, то посылка в целом имеет cf .4 (минимум A и B), который умножается на .9, чтобы получить .36.
Затем .36 комбинируется с любыми существующими cf для C.
Если C заранее неизвестен, то объединение .36 с 0 даст .36.
Если бы у C был предыдущий cf равный .76, то новый cf был бы .36 + .76 - (.36 x .76) = .8464.

Вот функции комбинации факторов достоверности EMYCIN в Lisp:

```lisp
(defun cf-or (a b)
  "Combine the certainty factors for the formula (A or B).
  This is used when two rules support the same conclusion."
  (cond ((and (> a 0) (> b 0))
         (+ a b (* -1 a b)))
        ((and (< a 0) (< b 0))
         (+ a b (* a b)))
        (t (/ (+ a b)
              (- 1 (min (abs a) (abs b)))))))

(defun cf-and (a b)
  "Combine the certainty factors for the formula (A and B)."
  (min a b))
```

Факторы уверенности можно рассматривать как обобщение истинностных значений.
EMYCIN - это система правил с обратной связью, которая объединяет факторы достоверности в соответствии с функциями, изложенными выше.
Но если бы мы использовали только факторы достоверности true и false, тогда EMYCIN вел бы себя точно так же, как Prolog, возвращая только ответы, которые определенно истинны.
Дополнительный механизм EMYCIN имеет значение только тогда, когда мы предоставляем частичные факторы уверенности.

На самом деле значения истинности служат в Прологе двум целям.
Они определяют окончательный ответ, да, но они также определяют, когда прекращать поиск: если какая-либо из посылок правила ложна, то нет смысла смотреть на другие посылки.
Если в EMYCIN мы прекращаем поиск только тогда, когда одна из предпосылок была абсолютно ложной, тогда нам, возможно, пришлось бы перебирать множество правил, только чтобы получить ответы с очень низкими факторами уверенности.
Вместо этого EMYCIN произвольно прекращает поиск и считает предпосылку ложной, если ее коэффициент достоверности(фактор уверенности) ниже .2.
Следующие функции поддерживают эту произвольную точку отсечения:

```lisp
(defconstant cf-cut-off 0.2
  "Below this certainty we cut off search.")

(defun true-p (cf)
  "Is this certainty factor considered true?"
  (and (cf-p cf) (> cf cf-cut-off)))

(defun false-p (cf)
  "Is this certainty factor considered false?"
  (and (cf-p cf) (< cf (- cf-cut-off 1.0))))

(defun cf-p (x)
  "Is X a valid numeric certainty factor?"
  (and (numberp x) (<= false x true)))
```

**Упражнение 16.1 [m]** Предположим, вы читаете заголовок "Элвис жив в Каламазу" в бульварной газете, которой вы приписываете коэффициент уверенности .01.
Если вы объедините достоверность, используя правило комбинирования EMYCIN, сколько еще экземпляров газеты вам нужно будет увидеть, прежде чем вы станете уверенным, что Элвис жив .95?

## 16.2 Кэширование производных фактов

Второе, что отличает EMYCIN от Prolog, - это то, что EMYCIN *кэширует* все полученные данные в базе данных.
Когда Prolog просят дважды доказать одну и ту же цель, он дважды выполняет одно и то же вычисление, независимо от того, насколько это трудоемко.
EMYCIN выполняет вычисление в первый раз и просто извлекает его во второй раз.

Мы можем реализовать простую базу данных, предоставив три функции: `put-db` для добавления связи между ключом и значением, `get-db` для получения значения и `clear-db` для очистки базы данных, чтобы начать сначала:

```lisp
(let ((db (make-hash-table :test #'equal)))
  (defun get-db (key) (gethash key db))
  (defun put-db (key val) (setf (gethash key db) val))
  (defun clear-db () (clrhash db)))
```

Эта база данных достаточно общая, чтобы удерживать любую связь между ключом и значением.
Однако большая часть информации, которую мы хотим сохранить, носит более конкретный характер.
EMYCIN предназначен для работы с объектами (или *экземплярами*) и атрибутами (или *параметрами*) этих объектов.
Например, у каждого пациента(patient) есть параметр имя(name).
Предположительно, значение этого параметра будет известно точно.
С другой стороны, каждый микроскопический организм имеет параметр `identity`(идентичности), который обычно не известен в начале консультации.
Применение правил приведет к нескольким возможным значениям этого параметра, каждое со своим коэффициентом достоверности(фактором уверенности).
В общем, тогда в базе данных будут ключи вида (*экземпляр параметра*) со значениями вида ((*val*1*cf*1) (*val*2*cf*2)...) .
В следующем коде `get-vals` возвращает список пар значение/cf для данного параметра и экземпляра, `get-cf` возвращает фактор уверенности(коэффициент достоверности/cf) для триплета параметр/экземпляр/значение, а `update-cf` изменяет фактор уверенности за счет объединения старого с новым.
Обратите внимание, что при первом вызове `update-cf` для данного триплета параметра/экземпляра/значения, `get-cf` вернет неизвестность(ноль).
Комбинируя это с данным `cf`, получаем сам `cf`.
Также обратите внимание, что база данных должна быть equal хэш-таблицей, потому что ключи могут включать в себя только что созданные списки.

```lisp
(defun get-vals (parm inst)
  "Return a list of (val cf) pairs for this (parm inst)."
  (get-db (list parm inst)))

(defun get-cf (parm inst val)
  "Look up the certainty factor or return unknown."
  (or (second (assoc val (get-vals parm inst)))
      unknown))

(defun update-cf (parm inst val cf)
  "Change the certianty factor for (parm inst is val),
  by combining the given cf with the old."
  (let ((new-cf (cf-or cf (get-cf parm inst val))))
    (put-db (list parm inst)
            (cons (list val new-cf)
                  (remove val (get-db (list parm inst))
                          :key #'first)))))
```

База данных содержит всю информацию, относящуюся к конкретному случаю проблемы.
Например, в области медицины база данных будет содержать всю информацию о текущем пациенте.
Когда мы хотим рассмотреть нового пациента, база данных очищается.

Есть еще три источника информации, которые нельзя сохранить в этой базе данных, потому что их нужно поддерживать от одной проблемы к другой.
Во-первых, *база правил* содержит все правила, определенные экспертом.
Во-вторых, есть структура для определения каждого параметра; они индексируются под именем каждого параметра.
В-третьих, мы увидим, что поток управления частично управляется списком *контекстов*(*contexts*), которые необходимо учитывать.
Это структуры, которые будут переданы функции `MYCIN`.

## 16.3 Задавать вопросы

Третий способ, которым EMYCIN отличается от Prolog, - это предоставление автоматических средств для задания вопросов пользователю, когда ответы не могут быть получены из правил.
Это не принципиальная разница; в конце концов, не так уж сложно написать правила Пролога, которые выводят запрос и читают ответ.
EMYCIN позволяет разработчику базы знаний написать простое объявление вместо правила и даже примет объявление по умолчанию, если оно не предусмотрено.
Система также гарантирует, что один и тот же вопрос никогда не будет задан дважды.

Следующая функция `ask-vals` печатает запрос, который запрашивает параметр экземпляра и считывает от пользователя значение или список значений с соответствующими факторами достоверности.
Функция сначала просматривает базу данных, чтобы убедиться, что вопрос не задавался ранее.
Затем она проверяет каждое значение и фактор уверенности, чтобы убедиться, что каждое из них относится к правильному типу, а также позволяет пользователю задавать определенные вопросы.
А ? ответ покажет, какой тип ответа ожидается.
`Rule`(Правило) покажет текущее правило, над которым работает система.
`Why`(Почему) также показывает текущее правило, но более подробно объясняет, что система знает и что пытается выяснить.
Наконец, `help` выводит следующую сводку:

```lisp
(defconstant help-string
  "~&Type one of the following:
 ?     - to see possible answers for this parameter
 rule  - to show the current rule
 why   - to see why this question is asked
 help  - to see this list
 xxx   - (for some specific xxx) if there is a definite answer
 (xxx .5 yyy .4) - If there are several answers with
                   different certainty factors.")
```

Вот и `ask-vals`.
Обратите внимание, что параметры `why` и `rule` предполагают, что текущее правило было сохранено в базе данных.
Вскоре будут определены функции `print-why`, `parm-type` и `check-reply`.

```lisp
(defun ask-vals (parm inst)
  "Ask the user for the value(s) of inst's parm parameter,
  unless this has already been asked.  Keep asking until the
  user types UNKNOWN (return nil) or a valid reply (return t)."
  (unless (get-db `(asked ,parm ,inst))
    (put-db `(asked ,parm ,inst) t)
    (loop
      (let ((ans (prompt-and-read-vals parm inst)))
        (case ans
          (help (format t help-string))
          (why  (print-why (get-db 'current-rule) parm))
          (rule (princ (get-db 'current-rule)))
          ((unk unknown) (RETURN nil))
          (?    (format t "~&A ~a must be of type ~a"
                        parm (parm-type parm)) nil)
          (t    (if (check-reply ans parm inst)
                    (RETURN t)
                    (format t "~&Illegal reply.  ~
                             Type ? to see legal ones."))))))))
```

Далее следует `prompt-and-read-vals`, функция, которая фактически запрашивает запрос и читает ответ.
По сути, он вызывает `format`, чтобы напечатать приглашение, и `read`, чтобы получить ответ, но здесь есть несколько тонкостей.
Во-первых, она вызывает `finish-output`. Некоторые реализации Lisp буферизуют вывод построчно.
Поскольку приглашение не может заканчиваться новой строкой, `finish-output` гарантирует, что вывод будет напечатан до того, как будет прочитан ответ.

До сих пор весь код, который ссылается на `parm`, действительно ссылается на имя параметра-символа.
Сами фактические параметры будут реализованы в виде структур.
Мы используем `get-parm` для поиска структуры, связанной с символом, и функции селектора `parm-prompt`, чтобы выбрать подсказку для каждого параметра, и `parm-reader`, чтобы выбрать функцию чтения.
Обычно это будет функция `read`, но `read-line` подходит для чтения параметров со строковыми значениями.

Макрос `defparm` (показанный здесь) обеспечивает способ определения подсказок и считывателей для параметров.

```lisp
(defun prompt-and-read-vals (parm inst)
  "Print the prompt for this parameter (or make one up) and
  read the reply."
  (fresh-line)
  (format t (parm-prompt (get-parm parm)) (inst-name inst) parm)
  (princ " ")
  (finish-output)
  (funcall (parm-reader (get-parm parm))))

(defun inst-name (inst)
  "The name of this instance."
  ;; The stored name is either like (("Jan Doe" 1.0)) or nil
  (or (first (first (get-vals 'name inst)))
      inst))
```

Функция `check-reply` использует `parse-reply` для преобразования ответа пользователя в каноническую форму, а затем проверяет, что каждое значение имеет правильный тип и что каждый фактор уверенности действителен.
Если да, база данных обновляется, чтобы отразить новые факторы уверенности.

```lisp
(defun check-reply (reply parm inst)
  "If reply is valid for this parm, update the DB.
  Reply should be a val or (val1 cf1 val2 cf2 ...).
  Each val must be of the right type for this parm."
  (let ((answers (parse-reply reply)))
    (when (every #'(lambda (pair)
                     (and (typep (first pair) (parm-type parm))
                          (cf-p (second pair))))
                 answers)
      ;; Add replies to the data base
      (dolist (pair answers)
        (update-cf parm inst (first pair) (second pair)))
      answers)))

(defun parse-reply (reply)
  "Convert the reply into a list of (value cf) pairs."
  (cond ((null reply) nil)
        ((atom reply) `((,reply ,true)))
        (t (cons (list (first reply) (second reply))
                 (parse-reply (rest2 reply))))))
```

Параметры реализованы в виде структур с шестью слотами: имя - name (символ), context - контекст, для которого предназначен параметр, prompt - приглашение, используемое для запроса значения параметра, логическое значение, которое сообщает, следует ли спрашивать пользователя до или после использования правил, ограничение типа, описывающее допустимые значения, и, наконец, функция, используемая для чтения значения параметра.

Параметры хранятся в списке свойств с их именами в свойстве parm, поэтому для получения имени типа parm требуется сначала получить структуру parm, а затем выбрать поле ограничения типа.
По умолчанию параметру присваивается тип t, что означает, что для этого типа допустимо любое значение.
Мы также определяем тип `yes/no`- да/ нет, который пригодится для логических(Boolean) параметров.

Мы хотим, чтобы запрос по умолчанию был "What is the PARM of the INST?"(Что такое PARM INST?) Но в большинстве пользовательских подсказок требуется напечатать inst, а не parm.
Чтобы упростить написание пользовательских подсказок, `prompt-and-read-vals` делает экземпляр первым аргументом строки формата, а parm - вторым.
Следовательно, в приглашении по умолчанию нам нужно использовать директиву формата `"~*"`, чтобы пропустить аргумент экземпляра, и `"~2:*"` для возврата назад на два аргумента, чтобы вернуться к экземпляру.
(Эти директивы распространены в вызовах `cerror`, где один список аргументов передается двум строкам формата.)

`defparm` - это макрос, который вызывает `new-parm`, функцию - конструктор, определенную в `parm` структуре, и сохраняет полученную структуру под именем параметра в свойстве `parm` .

```lisp
(defstruct (parm (:constructor
                  new-parm (name &optional context type-restriction
                            prompt ask-first reader)))
  name (context nil) (prompt "~&What is the ~*~a of ~2:*~a?")
  (ask-first nil) (type-restriction t) (reader 'read))

(defmacro defparm (parm &rest args)
  "Define a parameter."
  `(setf (get ',parm 'parm) (apply #'new-parm ',parm ',args)))

(defun parm-type (parm-name)
  "What type is expected for a value of this parameter?"
  (parm-type-restriction (get-parm parm-name)))

(defun get-parm (parm-name)
  "Look up the parameter structure with this name."
  ;; If there is none, make one
  (or (get parm-name 'parm)
      (setf (get parm-name 'parm) (new-parm parm-name))))

(deftype yes/no () '(member yes no))
```

## 16.4 Контексты вместо переменных

Ранее мы приводили уравнение, связывающее EMYCIN с Prolog.
Это уравнение было не совсем правильным, потому что в EMYCIN отсутствует одна из самых важных функций Prolog: логическая переменная.
Вместо этого EMYCIN использует *контексты* - *contexts*.
Итак, полное уравнение:

EMYCIN = Prolog + uncertainty + caching + questions + explanations + contexts - variables
(EMYCIN = Пролог + неопределенность + кеширование + вопросы + объяснения + контексты - переменные)

Контекст определяется разработчиками MYCIN как ситуация, в которой работает программа.
Но имеет смысл рассматривать контекст просто как тип данных.
Таким образом, список контекстов, предоставленный программе, определит, о каких типах объектов можно рассуждать.
Программа отслеживает самый последний экземпляр каждого типа, и правила могут ссылаться только на эти экземпляры, используя имя типа.
В нашей версии MYCIN существует три типа или контекста: пациенты(patients), культуры(cultures) и организмы(organisms).
Вот пример правила, которое ссылается на все три контекста:

```lisp
(defrule 52
```

  `if (site culture is blood)`

      `(gram organism is neg)`

      `(morphology organism is rod)`

      `(burn patient is serious)`

  `then .4`

      `(identity organism is pseudomonas))`

На данный момент игнорируя факторы уверенности, это правило MYCIN эквивалентно правилу Пролога в форме:

```lisp
(<- (identity ?o ?pseudomonas)
```

  `(and (culture` ?c) `(site ?c blood)`

    `(organism ?o) (gram ?o neg) (morphology ?o rod)`

    `(patient ?p) (burn ?p serious)))`

Механизм контекста обеспечивает достаточную гибкость для обработки многих случаев, которые в противном случае обрабатывались бы переменными.
Одна важная вещь, которую нельзя сделать, - это ссылаться на несколько экземпляров одного и того же контекста.
Можно сослаться только на самый последний экземпляр.
Контексты реализованы как структуры со следующим определением:

```lisp
(defstruct context
  "A context is a sub-domain, a type."
  name (number 0) initial-data goals)

(defmacro defcontext (name &optional initial-data goals)
  "Define a context."
  `(make-context :name ',name :initial-data ',initial-data
                 :goals ',goals))
```

Поле `name`(имя) похоже на `patient или organism.` Экземпляры контекстов нумеруются; поле `number` содержит номер самого последнего экземпляра.
У каждого контекста также есть два списка параметров.
Параметры начальных данных запрашиваются при создании каждого экземпляра.
Параметры исходных данных обычно известны пользователю.
Например, врач обычно знает имя, возраст и пол пациента, и в целях обучения ожидает, что ему сначала зададут эти вопросы, даже если они не учитываются в каждом случае.
С другой стороны, параметры цели обычно неизвестны пользователю.
Они определяются в процессе поиска/прохождения обратной цепочки.

Следующая функция создает новый экземпляр контекста, записывает сообщение и сохраняет этот экземпляр в двух местах в базе данных: под ключом `current-instance`, а также под именем контекста.
Контексты образуют дерево.
В нашем примере контекст `patient`(пациент) является корнем дерева, а текущий пациент хранится в базе данных под ключом `patient.` Следующий уровень дерева предназначен для культур, взятых у пациента; текущая культура хранится в ключе `culture`.
Наконец, есть уровень для организмов, обнаруженных в каждой культуре.
Текущий организм хранится под ключами `organism` и `current-instance`.
Контекстное дерево показано на [рисунке 16.2](#f0015).

| []()                                   |
|----------------------------------------|
| ![f16-02](images/chapter16/f16-02.jpg) |
| Рисунок 16.2: Дерево контекста           |

```lisp
(defun new-instance (context)
  "Create a new instance of this context."
  (let ((instance (format nil "~a-~d"
                          (context-name context)
                          (incf (context-number context)))))
  (format t "~&------ ~a ------~&" instance)
    (put-db (context-name context) instance)
    (put-db 'current-instance instance)))
```

## 16.5 Возвращение к обратной цепочке

Теперь, когда мы увидели, чем EMYCIN отличается от Prolog, мы готовы заняться тем же способом: интерпретатором правил с обратной цепочкой.
Как и Prolog, EMYCIN ставит перед собой цель и применяет правила, соответствующие этой цели.
Применение правила означает рассмотрение каждой посылки правила как цели и рекурсивное применение правил, соответствующих каждой посылке.

Остались еще некоторые отличия.
В Прологе целью может быть любое выражение, и подходящими правилами являются те, чьи головы объединяются/унифицируются с целью.
Если какое-либо подходящее правило сработает, значит, цель истинна.
В EMYCIN правило может дать цели уверенность .99, но мы все равно должны учитывать все другие правила, соответствующие цели, потому что они могут снизить точность ниже порога отсечения.
Таким образом, EMYCIN всегда сначала собирает все свидетельства, относящиеся к паре параметр/экземпляр, и оценивает/вычисляет цель только после того, как все свидетельства получены.
Например, если цель была (`temp patient  > 98.6`), Emycin сначала вычислит все правила с выводами(заключениями) о текущей температуре пациента, и только затем сравнит температуру с 98.6.

С другой стороны, в Прологе есть возможность искать в глубину, потому что семантика правил Пролога такова, что если какое-либо правило утверждает, что цель истинна, то это правда.
EMYCIN должен искать в ширину, потому что цель с уверенностью 0,99 может оказаться ложной при рассмотрении большего количества доказательств.

Теперь мы готовы набросать схему интерпретатора правил EMYCIN. Для `find-out` параметра экземпляра: Если значение уже хранится в базе данных, используйте известное значение
В противном случае, два варианта: использование правил или спросить пользователя.
Делайте это в порядке, указанном для этого параметра, и, если первый успешен, не беспокойтесь о втором.
Обратите внимание, что `ask-vals` (определенную выше) не будет задавать один и тот же вопрос дважды.

Чтобы использовать правила, найдите все правила, относящиеся к данному параметру, и вычислите их с помощью `use-rule`.
После того, как каждое правило было проверено/опробавано, если какое-либо из них вычисляется как истинное, то считается успешным.

Чтобы использовать правило `use-rule`, сначала проверьте, можно ли полностью отклонить какую-либо из посылок.
Если бы у нас не было этой проверки, то система могла бы начать задавать пользователям явно не относящиеся к делу вопросы.
Таким образом, мы тратим часть времени программы (проверяя каждую предпосылку дважды), чтобы сэкономить более ценное время пользователя.
(Функция `eval-condition` принимает необязательный аргумент, определяющий, должны ли мы рекурсивно задавать вопросы, пытаясь принять или отклонить условие.)

Если никакая посылка не может быть отклонена, то вычислите каждую посылку по очереди с помощью `evaluate-condition`, отслеживая накопленный фактор уверенности с помощью `cf-and` (который в настоящее время равен `min`), и отключите вычисление, когда фактор уверенности падает ниже порогового значения.
Если посылки вычислены в true то добавьте выводы в базу данных.
Последовательность вызовов выглядит так.
Обратите внимание, что рекурсивный вызов `find-out` - это то, что позволяет выполнять цепочку:

`find-out`                 ;  Чтобы узнать параметр для экземпляра:

`  get-db`                 ;   Посмотрите, кэшируется ли он в базе данных

`  ask-vals`               ;   Посмотрите, знает ли пользователь ответ

`  use-rules`              ;   Посмотрите, есть ли для этого правило:

`      reject-premise`    ;      Посмотрите, является ли это правило откровенно ложным

`      satisfy-premises`  ;      Или посмотрите, верно ли каждое условие:

`          eval-condition` ;        Вычислите каждое условие

`            find-out`      ;          Путем нахождения значений параметра

Перед показом интерпретатора приведем определение структуры правил вместе с функциями для поддержки базы данных правил:

```lisp
(defstruct (rule (:print-function print-rule))
  number premises conclusions cf)

(let ((rules (make-hash-table)))

  (defun put-rule (rule)
    "Put the rule in a table, indexed under each
    parm in the conclusion."
    (dolist (concl (rule-conclusions rule))
      (push rule (gethash (first concl) rules)))
    rule)

  (defun get-rules (parm)
    "A list of rules that help determine this parameter."
    (gethash parm rules))

  (defun clear-rules () (clrhash rules)))
```

Итак, вот интерпретатор `find-out`.
Он может узнать значение (значения) параметра тремя способами.
Во-первых, он проверяет, сохранено ли уже значение в базе данных.
Затем он пытается спросить пользователя или использовать правила.
Порядок, в котором проверяются эти две опции, зависит от свойства параметра `parm-ask-first`.
В любом случае, если ответ определен, он сохраняется в базе данных.

```lisp
(defun find-out (parm &optional (inst (get-db 'current-instance)))
  "Find the value(s) of this parameter for this instance,
  unless the values are already known.
  Some parameters we ask first; others we use rules first."
  (or (get-db `(known ,parm ,inst))
      (put-db `(known ,parm ,inst)
              (if (parm-ask-first (get-parm parm))
                  (or (ask-vals parm inst) (use-rules parm))
                  (or (use-rules parm) (ask-vals parm inst))))))

(defun use-rules (parm)
  "Try every rule associated with this parameter.
  Return true if one of the rules returns true."
  (some #'true-p (mapcar #'use-rule (get-rules parm))))

(defun use-rule (rule)
  "Apply a rule to the current situation."
  ;; Keep track of the rule for the explanation system:
  (put-db 'current-rule rule)
  ;; If any premise is known false, give up.
  ;; If every premise can be proved true,  then
  ;; draw conclusions (weighted with the certainty factor).
  (unless (some #'reject-premise (rule-premises rule))
    (let ((cf (satisfy-premises (rule-premises rule) true)))
      (when (true-p cf)
        (dolist (conclusion (rule-conclusions rule))
          (conclude conclusion (* cf (rule-cf rule))))
        cf))))

(defun satisfy-premises (premises cf-so-far)
  "A list of premises is satisfied if they are all true.
  A combined cf is returned."
  ;; cf-so-far is an accumulator of certainty factors
  (cond ((null premises) cf-so-far)
        ((not (true-p cf-so-far)) false)
        (t (satisfy-premises
             (rest premises)
             (cf-and cf-so-far
                     (eval-condition (first premises)))))))
```

Функция `eval-condition` вычисляет одно условие, возвращая его коэффициент достоверности(фактор уверенности).
Если `find-out-p` истинен, она сначала вызывает `find-out`, который может либо запросить пользователя, либо применить соответствующие правила.
Если `find-out-p` ложен, она вычисляет условие, используя текущее состояние базы данных.
Она делает это, просматривая каждое сохраненное значение для пары параметр/экземпляр и вычисляя на нем оператор.
Например, если условие равно (`temp patient > 98.6`), а значения `temp` для текущего пациента равны (`(98 .3) (99 .6) (100 .1)`), то `eval-condition` проверит каждое из значений 98, 99 и 100 против 98,6 с помощью оператора >.
Этот тест будет успешным дважды, поэтому результирующий коэффициент достоверности составит .6 + .1 = .7.

Функция `reject-premise` предназначена для быстрой проверки исключения правила.
Таким образом, она вызывает `eval-condition` с `find-out-p` nil, поэтому она отклонит предпосылку, только если она явно ложна, без поиска дополнительной информации.

Если посылки правила верны, то выводы добавляются в базу данных с помощью `conclude`.
Обратите внимание, что `is` - единственный оператор, разрешенный в выводах, `is` - просто псевдоним для equal(равенства).

```lisp
(defun eval-condition (condition &optional (find-out-p t))
  "See if this condition is true, optionally using FIND-OUT
  to determine unknown parameters."
  (multiple-value-bind (parm inst op val)
      (parse-condition condition)
    (when find-out-p
      (find-out parm inst))
    ;; Add up all the (val cf) pairs that satisfy the test
    (loop for pair in (get-vals parm inst)
          when (funcall op (first pair) val)
          sum (second pair))))

(defun reject-premise (premise)
  "A premise is rejected if it is known false, without
  needing to call find-out recursively."
  (false-p (eval-condition premise nil)))

(defun conclude (conclusion cf)
  "Add a conclusion (with specified certainty factor) to DB."
  (multiple-value-bind (parm inst op val)
      (parse-condition conclusion)
    (update-cf parm inst val cf)))

(defun is (a b) (equal a b))
```

Все условия имеют вид: (*parameter instance operator value*) - (*параметр экземпляр оператор значение*).
Например: `(morphology organism is rod).` Функция `parse-condition` превращает список этой формы в четыре значения.
Хитрость в том, что она использует базу данных для возврата текущего экземпляра контекста, а не самого имени контекста:

```lisp
(defun parse-condition (condition)
  "A condition is of the form (parm inst op val).
  So for (age patient is 21), we would return 4 values:
  (age patient-1 is 21), where patient-1 is the current patient."
  (values (first condition)
          (get-db (second condition))
          (third condition)
          (fourth condition)))
```

На этом этапе такой вызов, как (`find-out 'identity 'organism-1`) будет действовать правильно, только если мы каким-то образом ввели правильную информацию о текущем пациенте, культуре и организме.
Функция `get-context-data` гарантирует, что каждый контекст обрабатывается по порядку.
Сначала создается экземпляр, затем используется `find-out` для определения как исходных параметров данных, так и целей.
Выводы для каждой цели печатаются, и программа спрашивает, есть ли еще один экземпляр этого контекста.
Наконец, нам также нужна функция верхнего уровня `emycin`, которая просто очищает базу данных перед вызовом `get-context-data`.

```lisp
(defun emycin (contexts)
  "An Expert System Shell.  Accumulate data for instances of each
  context, and solve for goals.  Then report the findings."
  (clear-db)
  (get-context-data contexts))

(defun get-context-data (contexts)
  "For each context, create an instance and try to find out
  required data.  Then go on to other contexts, depth first,
  and finally ask if there are other instances of this context."
  (unless (null contexts)
    (let* ((context (first contexts))
           (inst (new-instance context)))
      (put-db 'current-rule 'initial)
      (mapc #'find-out (context-initial-data context))
      (put-db 'current-rule 'goal)
      (mapc #'find-out (context-goals context))
      (report-findings context inst)
      (get-context-data (rest contexts))
      (when (y-or-n-p "Is there another ~a?"
                      (context-name context))
        (get-context-data contexts)))))
```

## 16.6 Взаимодействие с экспертом

На этом этапе вся серьезная вычислительная работа завершена: мы определили механизм правил обратной цепочки, который имеет дело с неопределенностью, кэшированием, запросами и контекстами.
Но с точки зрения взаимодействия ввода/вывода предстоит еще немало поработать.
Язык программирования должен только взаимодействовать с программистами, поэтому вполне допустимо, чтобы программист делал всю работу.
Но оболочка экспертной системы должна облегчить (если не отменить) потребность в программистах.
Оболочки экспертной системы действительно имеют два класса пользователей: эксперты используют оболочку при разработке системы, а конечные пользователи или клиенты используют получившуюся экспертную систему, когда она завершена.
Иногда эксперт может вводить знания непосредственно в оболочку, но чаще предполагается, что эксперт будет пользоваться помощью *инженера знаний* - кого-то, кто обучен использованию оболочки и извлечению знаний, но не обязательно либо эксперт в своей области, либо опытный программист.

В нашей версии EMYCIN мы предоставляем только самые простые инструменты, облегчающие работу эксперта.
Макросы `defcontext` и `defparm`, определенные выше, немного проще, чем явный вызов `make-context` и `make-parm`, но не намного.
Макрос `defrule` определяет правило и проверяет наличие очевидных ошибок:

```lisp
(defmacro defrule (number &body body)
  "Define a rule with conditions, a certainty factor, and
  conclusions.  Example: (defrule R001 if ... then .9 ...)"
  (assert (eq (first body) 'if))
  (let* ((then-part (member 'then body))
         (premises (ldiff (rest body) then-part))
         (conclusions (rest2 then-part))
         (cf (second then-part)))
    ;; Do some error checking:
    (check-conditions number premises 'premise)
    (check-conditions number conclusions 'conclusion)
    (when (not (cf-p cf))
      (warn "Rule ~a: Illegal certainty factor: ~a" number cf))
    ;; Now build the rule:
    `(put-rule
       (make-rule :number ',number :cf ,cf :premises ',premises
                  :conclusions ',conclusions))))
```

Функция `check-conditions` проверяет, что каждое правило имеет по крайней мере одну предпосылку и вывод, что каждое условие имеет правильную форму и что значение условия имеет правильный тип для параметра.
Также проверяется, что в выводах используется только оператор `is`:

```lisp
(defun check-conditions (rule-num conditions kind)
  "Warn if any conditions are invalid."
  (when (null conditions)
    (warn "Rule ~a: Missing ~a" rule-num kind))
  (dolist (condition conditions)
    (when (not (consp condition))
      (warn "Rule ~a: Illegal ~a: ~a" rule-num kind condition))
    (multiple-value-bind (parm inst op val)
        (parse-condition condition)
      (declare (ignore inst))
      (when (and (eq kind 'conclusion) (not (eq op 'is)))
        (warn "Rule ~a: Illegal operator (~a) in conclusion: ~a"
              rule-num op condition))
      (when (not (typep val (parm-type parm)))
        (warn "Rule ~a: Illegal value (~a) in ~a: ~a"
              rule-num val kind condition)))))
```

Настоящий EMYCIN имел интерактивную среду, которая запрашивала у эксперта каждый контекст, параметр и правило.
Рэндалл Дэвис ([1977](B9780080571157500285.xhtml#bb0290), [1979](B9780080571157500285.xhtml#bb0295), [Davis and Lenat 1982](B9780080571157500285.xhtml#bb0IRESIAS) описывает программу TEIRESIAS, которая помогала вводить и отлаживать правила.

## 16.7 Взаимодействие с клиентом

Как только знание получено(введено), нам нужен какой-то способ увидеть(вывести) его.
Клиент хочет запустить систему над своей собственной проблемой и увидеть две вещи: решение проблемы и объяснение, почему решение является разумным.
EMYCIN предоставляет примитивные возможности для обоих из них.
Функция `report-findings` выводит информацию обо всех параметрах цели для данного экземпляра:

```lisp
(defun report-findings (context inst)
  "Print findings on each goal for this instance."
  (when (context-goals context)
    (format t "~&Findings for ~a:" (inst-name inst))
    (dolist (goal (context-goals context))
      (let ((values (get-vals goal inst)))
        ;; If there are any values for this goal,
        ;; print them sorted by certainty factor.
        (if values
            (format t "~& ~a:~{~{ ~a (~,3f)  ~}~}" goal
                    (sort (copy-list values) #'> :key #'second))
            (format t "~& ~a: unknown" goal))))))
```

Единственная возможность объяснения, которую предлагает наша версия EMYCIN, - это способ увидеть текущее правило.
Если пользователь вводит `rule` в ответ на запрос, печатается псевдоанглийский перевод текущего правила.
Вот пример правила и его перевод:

```lisp
(defrule 52
  if (site culture is blood)
      (gram organism is neg)
      (morphology organism is rod)
      (burn patient is serious)
  then .4
      (identity organism is pseudomonas))
Rule 52:
  If
    1) THE SITE OF THE CULTURE IS BLOOD
    2) THE GRAM OF THE ORGANISM IS NEG
    3) THE MORPHOLOGY OF THE ORGANISM IS ROD
    4) THE BURN OF THE PATIENT IS SERIOUS
  Then there is weakly suggestive evidence (0.4) that
    1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS
```

Функция `print-rule` генерирует такой перевод:

```lisp
(defun print-rule (rule &optional (stream t) depth)
  (declare (ignore depth))
  (format stream "~&Rule ~a:~&  If" (rule-number rule))
  (print-conditions (rule-premises rule) stream)
  (format stream "~&  Then ~a (~a) that"
          (cf->english (rule-cf rule)) (rule-cf rule))
  (print-conditions (rule-conclusions rule) stream))

(defun print-conditions (conditions &optional
                         (stream t) (num 1))
  "Print a list of numbered conditions."
  (dolist (condition conditions)
    (print-condition condition stream num)))

(defun print-condition (condition stream number)
  "Print a single condition in pseudo-English."
  (format stream "~&    ~d)~{ ~a~}" number
          (let ((parm (first condition))
                (inst (second condition))
                (op (third condition))
                (val (fourth condition)))
            (case val
              (YES `(the ,inst ,op ,parm))
              (NO  `(the ,inst ,op not ,parm))
              (T   `(the ,parm of the ,inst ,op ,val))))))

(defun cf->english (cf)
  "Convert a certainy factor to an English phrase."
  (cond ((= cf  1.0) "there is certain evidence")
        ((> cf   .8) "there is strongly suggestive evidence")
        ((> cf   .5) "there is suggestive evidence")
        ((> cf  0.0) "there is weakly suggestive evidence")
        ((= cf  0.0) "there is NO evidence either way")
        ((< cf  0.0) (concatenate 'string (cf->english (- cf))
                                  " AGAINST the conclusion"))))
```

Если пользователь вводит `why` в ответ на запрос, печатается более подробное описание того же правила.
Сначала отображаются уже известные предпосылки, а затем - оставшаяся часть правила.
Запрашиваемый параметр всегда будет первой предпосылкой в оставшейся части правила.
`current-rule` сохраняется в базе данных с помощью `use-rule` всякий раз, когда применяется правило, но оно также устанавливается с помощью `get-context-data` для атома `initial` или цели, когда система запрашивает для параметров.
`print-why` также проверяет этот случай.
Обратите внимание на использование функции `partition-if` со страницы 256.

```lisp
(defun print-why (rule parm)
  "Tell why this rule is being used.  Print what is known,
  what we are trying to find out, and what we can conclude."
  (format t "~&[Why is the value of ~a being asked for?]" parm)
  (if (member rule '(initial goal))
      (format t "~&~a is one of the ~a parameters."
              parm rule)
      (multiple-value-bind (knowns unknowns)
          (partition-if #'(lambda (premise)
                            (true-p (eval-condition premise nil)))
                        (rule-premises rule))
        (when knowns
          (format t "~&It is known that:")
          (print-conditions knowns)
          (format t "~&Therefore,"))
        (let ((new-rule (copy-rule rule)))
          (setf (rule-premises new-rule) unknowns)
          (print new-rule)))))
```

Это завершает определение `emycin`.
Теперь мы готовы применить оболочку к конкретному домену, что положит начало созданию экспертной системы.

## 16.8 **MYCIN**, Медицинская экспертная система

В этом разделе `emycin` применяется к исходной области Mycin: инфекционное заболевание крови.
В нашей версии MYCIN существует три контекста: сначала мы рассматриваем пациента, затем любые культуры, выращенные из образцов, взятых у пациента, и, наконец, любые инфекционные организмы в культурах.
Цель состоит в том, чтобы определить идентичность каждого организма.
Настоящий MYCIN был более сложным с учетом любых лекарств или операций, которые пациент мог перенести ранее.
Он также решал реальный вопрос: какую терапию назначить.
Однако большая часть этого была сделана с помощью специальных процедур для расчета оптимальных дозировок и т.п., поэтому здесь они не рассматриваются.
Исходный MYCIN также проводил различие между существующими и предшествующими культурами, организмами и лекарствами.
Всего нужно было рассмотреть десять контекстов, в то время как в нашей версии их всего три:

```lisp
(defun mycin ()
  "Determine what organism is infecting a patient."
  (emycin
    (list (defcontext patient  (name sex age)  ())
          (defcontext culture  (site days-old) ())
          (defcontext organism ()              (identity)))))
```

Эти контексты объявляют, что мы сначала спросим каждого пациента, имя, пол и возраст, а также месторасположение каждой культуры и количество прошедших дней, с момента её изоляции.
Для организмов нет первоначальных вопросов, но для них есть цель: определить идентичность организма.

Следующим шагом является объявление параметров для контекстов.
Каждому параметру присваивается тип, и большинству из них даются prompts(приглашения/подсказки), чтобы сделать диалог более естественным:

```lisp
;;; Parameters for patient:
(defparm name patient t "Patient's name: " t read-line)
(defparm sex patient (member male female) "Sex:" t)
(defparm age patient number "Age:" t)
(defparm burn patient (member no mild serious)
  "Is ~a a burn patient?  If so, mild or serious?" t)
(defparm compromised-host patient yes/no
  "Is ~a a compromised host?")

;;; Parameters for culture:
(defparm site culture (member blood)
  "From what site was the specimen for ~a taken?" t)
(defparm days-old culture number
  "How many days ago was this culture (~a) obtained?" t)

;;; Parameters for organism:
(defparm identity organism
  (member pseudomonas klebsiella enterobacteriaceae
          staphylococcus bacteroides streptococcus)
  "Enter the identity (genus) of ~a:" t)
(defparm gram organism (member acid-fast pos neg)
  "The gram stain of ~a:" t)
(defparm morphology organism (member rod coccus)
  "Is ~a a rod or coccus (etc.):")
(defparm aerobicity organism (member aerobic anaerobic))
(defparm growth-conformation organism
  (member chains pairs clumps))
```

Теперь нам нужны некоторые правила, которые помогут определить идентичность организмов.
Следующие правила взяты из [Shortliffe 1976](B9780080571157500285.xhtml#bb1100).
Номера правил относятся к страницам, на которых они перечислены.
Настоящий MYCIN имел около 400 правил, касающихся гораздо более широкого спектра предпосылок и выводов.

```lisp
(clear-rules)

(defrule 52
  if (site culture is blood)
     (gram organism is neg)
     (morphology organism is rod)
     (burn patient is serious)
  then .4
     (identity organism is pseudomonas))

(defrule 71
  if (gram organism is pos)
     (morphology organism is coccus)
     (growth-conformation organism is clumps)
  then .7
     (identity organism is staphylococcus))

(defrule 73
  if (site culture is blood)
     (gram organism is neg)
     (morphology organism is rod)
     (aerobicity organism is anaerobic)
  then .9
     (identity organism is bacteroides))

(defrule 75
  if (gram organism is neg)
     (morphology organism is rod)
     (compromised-host patient is yes)
  then .6
     (identity organism is pseudomonas))

(defrule 107
  if (gram organism is neg)
     (morphology organism is rod)
     (aerobicity organism is aerobic)
  then .8
     (identity organism is enterobacteriaceae))

(defrule 165
  if (gram organism is pos)
     (morphology organism is coccus)
     (growth-conformation organism is chains)
  then .7
     (identity organism is streptococcus))
```

Вот пример использования программы:

```lisp
> (mycin)
------ PATIENT-1 ------
Patient's name: Sylvia Fischer
Sex: female
Age: 27
------ CULTURE-1 ------
```

`From what site was the specimen for CULTURE-1 taken?
blood`

`How many days ago was this culture (CULTURE-1) obtained?
3`

```lisp
------ ORGANISM-1 ------
Enter the identity (genus) of ORGANISM-1: unknown
The gram stain of ORGANISM-1: ?
A GRAM must be of type (MEMBER ACID-FAST POS NEG)
The gram stain of ORGANISM-1: neg
```

Пользователь набрал ? чтобы увидеть список действительных ответов.
Диалог продолжается:

```lisp
Is ORGANISM-1 a rod or coccus (etc.): rod
```

`What is the AEROBICITY of ORGANISM-1?
Why`

```lisp
[Why is the value of AEROBICITY being asked for?]
It is known that:
      1) THE GRAM OF THE ORGANISM IS NEG
      2) THE MORPHOLOGY OF THE ORGANISM IS ROD
Therefore,
Rule 107:
  If
      1) THE AEROBICITY OF THE ORGANISM IS AEROBIC
  Then there is suggestive evidence (0.8) that
      1) THE IDENTITY OF THE ORGANISM IS ENTEROBACTERIACEAE
```

Пользователь хочет знать, почему система спрашивает об аэробности организма.
Ответ показывает текущее правило, то, что уже известно о правиле, и тот факт, что если организм аэробный, то мы можем сделать некоторые выводы о его идентичности.
В этом гипотетическом случае организм фактически аэробен:

`What is the AEROBICITY of ORGANISM-1?
aerobic`

`Is Sylvia Fischer a compromised host?
yes`

`Is Sylvia Fischer a burn patient?
If so.
mild or serious?
why`

```lisp
[Why is the value of BURN being asked for?]
It is known that:
      1) THE SITE OF THE CULTURE IS BLOOD
      2) THE GRAM OF THE ORGANISM IS NEG
      3) THE MORPHOLOGY OF THE ORGANISM IS ROD
Therefore,
Rule 52:
  If
      1) THE BURN OF THE PATIENT IS SERIOUS
  Then there is weakly suggestive evidence (0.4) that
      1) THE IDENTITY OF THE ORGANISM IS PSEUDOMONAS
```

`Is Sylvia Fischer a burn patient?
If so, mild or serious?
serious`

```lisp
Findings for ORGANISM-1:
  IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)
```

Система использовала правило 107, чтобы сделать вывод, что это могут быть энтеробактерии.
Уверенность равна .8, достоверность самого правила, потому что все условия были достоверно известны.
Правила 52 и 75 поддерживают гипотезу псевдомонад.
Коэффициенты достоверности двух правил, .6 и .4, объединяются по формуле .6 + .4 - (.6 x .4) = .76.
После распечатки результатов для первого организма система спрашивает, был ли другой организм получен из этой культуры:

`Is there another ORGANISM?
(Y or N) Y`

```lisp
------ ORGANISM-2 ------
Enter the identity (genus) of ORGANISM-2: unknown
The gram stain of ORGANISM-2: (neg .8 pos .2)
Is ORGANISM-2 a rod or coccus (etc.): rod
```

`What is the AEROBICITY of ORGANISM-2?
anaerobic`

Для второго организма лабораторный тест не дал результатов, поэтому пользователь ввел квалифицированный ответ, указывающий, что он, вероятно, является грамотрицательным, но, возможно, грамположительным.
Этот организм тоже был rod, но был анаэробным.
Обратите внимание, что система не повторяет вопросы, ответы на которые ей уже известны.
При рассмотрении правил 75 и 52 она уже знает, что посев произошел из крови, и что пациент является скомпрометированным хозяином и серьезным ожоговым пациентом.
В конце концов, правило 73 способствует выводу о бактероидах, а правила 75 и 52 снова объединяются, чтобы предложить pseudomonas, хотя и с более низким фактором уверенности, потому что  обнаружение neg имело более низкий фактор уверенности:

```lisp
Findings for ORGANISM-2:
  IDENTITY: BACTEROIDES (0.720) PSEUDOMONAS (0.646)
```

Наконец, программа дает пользователю возможность расширить контекстное дерево новыми организмами, культурами или пациентами:

`Is there another ORGANISM?
(Y or N) N`

`Is there another CULTURE?
(Y or N) N`

`Is there another PATIENT?
(Y or N) N`

Набор правил, перечисленных выше, не демонстрирует двух важных характеристик системы: возможность обратной цепочки и возможность использовать операторы, отличные от тех, которые находятся в помещении. 

Если мы добавим следующие три правила и повторим случай, показанный выше, то вычисление правила 75 вернется к правилу 1, 2 и, наконец, 3, пытаясь определить, является ли пациент скомпрометированным хозяином.
Обратите внимание, что задается вопрос: "What is Sylvia Fischer's white blood cell count?"(Какое количество лейкоцитов у Сильвии Фишер?), а не "Is the white blood cell count of Sylvia Fischer < 2.5?"(Является ли количество лейкоцитов Сильвии Фишер < 2.5?) Последний вопрос будет достаточным для рассматриваемой предпосылки, но не будет столь же полезным для других правил, которые могут относиться к WBC.

```lisp
(defparm wbc patient number
  "What is ~a's white blood cell count?")
(defrule 1
  if (immunosuppressed patient is yes)
  then 1.0 (compromised-host patient is yes))
(defrule 2
  if (leukopenia patient is yes)
  then 1.0 (immunosuppressed patient is yes))
(defrule 3
  if (wbc patient <  2.5)
  then .9 (leukopenia patient is yes))
```

## 16.9 Альтернативы факторам уверенности

Факторы уверенности - это компромисс.
Хорошая новость заключается в том, что система, основанная на правилах с факторами уверенности, требует, чтобы эксперт придумал только небольшой набор чисел (по одному для каждого правила), и позволит быстро вычислять ответы.
Плохая новость в том, что вычисленный ответ может привести к иррациональным решениям.

Факторы уверенности были подтверждены их эффективностью (MYCIN работает так же или лучше, чем опытные врачи) и интуитивным обращением (они удовлетворяют критериям, перечисленным на странице 534).
Однако они подвержены парадоксам, когда вычисляют странные результаты (как в упражнении 16.1, стр. 536).
Если правила, составляющие базу знаний, построены по модульному принципу, то проблем обычно не возникает, но, безусловно, вызывает беспокойство то, что ответы могут быть недостоверными.

До MYCIN большинство рассуждений о неопределенности делалось с помощью теории вероятностей.
Законы вероятности - в частности, закон Байеса - представляют собой хорошо обоснованный математический формализм, который не зависит от несоответствий факторов уверенности.
Действительно, можно показать, что теория вероятностей является единственным формализмом, ведущим к рациональному поведению, в том смысле, что если вам нужно сделать серию ставок на некоторые неопределенные события, объединение информации с теорией вероятности даст вам наивысшую ожидаемую ценность для вашего Пари.
Несмотря на это, в середине 1970-х от теории вероятностей отказались.
Аргумент, сделанный [Шортлиффом и Бьюкененом (1975)](B9780080571157500285.xhtml#bb1105), заключался в том, что теория вероятностей требует слишком большого количества условных вероятностей и что люди не умеют их оценивать.
Они утверждали, что с факторами уверенности интуитивно легче справиться.
Эту точку зрения разделяли и другие исследователи того времени.
Шафер с последующими уточнениями Демпстера создал теорию функций убеждений, которая, как и факторы уверенности, представляет собой комбинацию убеждений за и против события.
Вместо того, чтобы представлять событие единственной вероятностью или определенностью, теория Демпстера-Шафера поддерживает два числа, которые аналогичны нижней и верхней границе вероятности.
Вместо одного числа, такого как .5, теория Демпстера-Шейфера будет иметь интервал вроде [.4, .6], представляющий диапазон вероятностей.
Полное отсутствие знаний будет представлено диапазоном [0,1].
В конце 1970-х - начале 1980-х годов было вложено много усилий в эти и другие невероятностные теории.
Другой пример - теория нечетких множеств Заде, которая также основана на интервалах.

Существует множество свидетельств того, что людям трудно решать проблемы, связанные с вероятностью.
В серии очень занимательных и наводящих на размышления статей Тверски и Канеман ([1974](B9780080571157500285.xhtml#bb1245), [1983](B9780080571157500285.xhtml#bb1250), [1986](B9780080571157500285.xhtml#bb1255)) как люди делают иррациональный выбор, когда сталкиваются с проблемами, довольно простыми с математической точки зрения.
Они сравнивают эти ошибки в выборе с ошибками визуального восприятия, вызванными оптическими иллюзиями.
Этим ошибкам подвержены даже обученные врачи и статистики.

В качестве примера рассмотрим следующий сценарий.
Адриан и Доминика собираются пожениться.
Адриан идет на обычный анализ крови, и ему говорят, что результаты положительны для редкого генетического заболевания, которым страдает только 1 человек из 10 000.
Врач говорит, что тест на 99% точен - он дает ложноположительные результаты только в 1 из 100 случаев.
Адриан подавлен, будучи убежденным, что вероятность того, что действительно заболеть, составляет 99%.
К счастью, Доминика оказалась знакомой с байесовской теорией и быстро успокоила Адриана, что вероятность около 1%.
Рассуждения таковы: возьмите 10 001 человека наугад.
Предполагается, что из них только 1 болен.
Этот человек определенно мог ожидать положительный результат теста на болезнь.
Но если все остальные 10 000 человек сдадут анализ крови, то 1% из них или 100 человек также будут иметь положительный результат.
Таким образом, вероятность того, что действительно заболеть, при положительном результате теста составляет 1/101.
Докторов обучили такому анализу, но, к сожалению, многие из них продолжают рассуждать больше как Адриан, чем Доминика.

В конце 1980-х годов волна субъективной байесовской теории вероятностей начала возвращаться.
[Cheeseman (1985)](B9780080571157500285.xhtml#bb0185) показал, что, хотя теория Демпстера-Шафера выглядит способной, на самом деле она не может помочь вам принимать лучшие решения, чем теория вероятностей.
[Хекерман (1986)] (B9780080571157500285.xhtml#bb0525) повторно исследовал факторы достоверности MYCIN, показывая, как их можно интерпретировать как вероятности.
Книга Иудеи [Перл, 1988](B9780080571157500285.xhtml#bb0935) является красноречивой защитой теории вероятностей.
Он показывает, что существуют эффективные алгоритмы для объединения и распространения вероятностей, пока сеть взаимозависимостей не содержит петель.
Кажется вероятным, что неопределенные рассуждения в 1990-х годах все больше будут основываться на байесовской теории вероятностей.

## 16.10 История и Ссылки

The MYCIN project is well documented in [Buchanan and Shortliffe 1984](B9780080571157500285.xhtml#bb0145).
An earlier book, [Shortliffe 1976](B9780080571157500285.xhtml#bb1100), is interesting mainly for historical purposes.
Good introductions to expert systems in general include [Weiss and Kulikowski 1984](B9780080571157500285.xhtml#bb1365), [Waterman 1986](B9780080571157500285.xhtml#bb1345), [Luger and Stubblefield 1989](B9780080571157500285.xhtml#bb0760), and [Jackson 1990](B9780080571157500285.xhtml#bb0580).

Dempster-Shafer evidence theory is presented enthusiastically in [Gordon and Shortliffe 1984](B9780080571157500285.xhtml#bb0485) and in a critical light in [Pearl 1989](B9780080571157500285.xhtml#bb0940)/1978.
Fuzzy set theory is presented in Zadeh 1979 and [Dubois and Prade 1988](B9780080571157500285.xhtml#bb0350).

[Pearl (1988)](B9780080571157500285.xhtml#bb0935) captures most of the important points that lead to the renaissance of probability theory.
[Shafer and Pearl 1990](B9780080571157500285.xhtml#bb1090) is a balanced collection of papers on all kinds of uncertain reasoning.

## 16.11 Упражнения

**Exercise  16.2 [s]** Suppose the rule writer wanted to be able to use symbolic certainty factors instead of numbers.
What would you need to change to support rules like this:

```lisp
(defrule 100 if ... then true ...)
(defrule 101 if ... then probably ...)
```

**Exercise  16.3 [m]** Change `prompt-and-read-vals` so that it gives a better prompt for parameters of type `yes/no`.

**Exercise  16.4 [m]** Currently, the rule writer can introduce a new parameter without defining it first.
That is handy for rapid testing, but it means that the user of the system won't be able to see a nice English prompt, nor ask for the type of the parameter.
In addition, if the rule writer simply misspells a parameter, it will be treated as a new one.
Make a simple change to fix these problems.

**Exercise  16.5 [d]** Write rules in a domain you are an expert in, or find and interview an expert in some domain, and write down rules coaxed from the expert.
Evaluate your resulting system.
Was it easier to develop your system with EMYCIN than it would have been without it?

**Exercise  16.6 [s]** It is said that an early version of MYCIN asked if the patient was pregnant, even though the patient was male.
Write a rule that would fix this problem.

**Exercise  16.7 [m]** To a yes/no question, what is the difference between yes and `(no-1)` ? What does this suggest?

**Exercise  16.8 [m]** What happens if the user types `why` to the prompt about the patient's name?
What happens if the expert wants to have more than one context with a name parameter?
If there is a problem, fix it.

The remaining exercises discuss extensions that were in the original EMYCIN, but were not implemented in our version.
Implementing all the extensions will result in a system that is very close to the full power of EMYCIN.
These extensions are discussed in [chapter 3](B9780080571157500030.xhtml) of [Buchanan and Shortliffe 1984](B9780080571157500285.xhtml#bb0145).

**Exercise  16.9 [h]** Add a spelling corrector to `ask-vals`.
If the user enters an invalid reply, and the parameter type is a `member` expression, check if the reply is "close" in spelling to one of the valid values, and if so, use that value.
That way, the user can type just `entero` instead of `enterobacteriaceae`.
You may experiment with the definition of "close," but you should certainly allow for prefixes and at least one instance of a changed, missing, inserted, or transposed letter.

**Exercise  16.10 [m]** Indent the output for each new branch in the context tree.
In other words, have the prompts and findings printed like this:

```lisp
------ PATIENT-1 ------
Patient's name: Sylvia Fischer
Sex: female
Age: 27
      ------ CULTURE-1 ------
```

`      From what site was the specimen for CULTURE-1 taken?
blood`

`      How many days ago was this culture (CULTURE-1) obtained?
3`

```lisp
          ------ ORGANISM-1 ------
          Enter the identity (genus) of ORGANISM-1: unknown
          The gram stain of ORGANISM-1: neg
          ...
          Findings for ORGANISM-1:
            IDENTITY: ENTEROBACTERIACEAE (0.800) PSEUDOMONAS (0.760)
```

`          Is there another ORGANISM?
(Y or N) N`

`      Is there another CULTURE?
(Y or N) N`

`Is there another PATIENT?
(Y or N) N`

**Exercise  16.11 [h]** We said that our `emycin` looks at all possible rules for each parameter, because there is no telling how a later rule may affect the certainty factor.
Actually, that is not quite true.
If there is a rule that leads to a conclusion with certainty 1, then no other rules need be considered.
This was called a *unity path*.
Modify the program to look for unity paths first.

**Exercise  16.12 [m]** Depending on whether a parameter is in `initial-data` or not, all the relevant rules are run either before or after asking the user for the value of the parameter.
But there are some cases when not all initial data parameters should be asked for.
As an example, suppose that `identity` and `gram` were initial data parameters of `organism`.
If the user gave a positive answer for `identity`, then it would be wasteful to ask for the `gram` parameter, since it could be determined directly from rules.
After receiving complaints about this problem, a system of *antecedent rules* was developed.
These rules were always run first, before asking questions.
Implement antecedent rules.

**Exercise  16.13 [h]** It is useful to be able to write *default rules* that fill in a value after all other rules have failed to determine one.
A default rule looks like this:

```lisp
(defrule n if (parm inst unknown) then (parm inst is default))
```

It may also have other conjuncts in the premise.
Beside details like writing the `unknown` operator, the difficult part is in making sure that these rules get run at the right time (after other rules have had a chance to fill in the parameter), and that infinite loops are avoided.

**Exercise  16.14 [h]** The context tree proved to be a limitation.
Eventually, the need arose for a rule that said, "If any of the organisms in a culture has property X, then the culture has property Y." Implement a means of checking for `some` or `every` instance of a context.

**Exercise  16.15 [m]** As the rule base grew, it became increasingly hard to remember the justification for previous rules.
Implement a mechanism that keeps track of the author and date of creation of each rule, and allows the author to add documentation explaining the rationale for the rule.

**Exercise  16.16 [m]** It is difficult to come up with the perfect prompt for each parameter.
One solution is not to insist that one promptfits all users, but rather to allow the expert to supply three different prompts: a normal prompt, a verbose prompt (or reprompt) for when the user replies with a ?, and a terse prompt for the experienced user.
Modify `defparm` to accommodate this concept, add a command for the user to ask for the terse prompts, and change `ask-vals` to use the proper prompt.

The remaining exercises cover three additional replies the user can make: `how`, `stop`, and `change`.

**Exercise  16.17 [d]** In addition to `why` replies, EMYCIN also allowed for `how` questions.
The user can ask how the value of a particular parameter/instance pair was determined, and the system will reply with a list of rules and the evidence they supplied for or against each value.
Implement this mechanism.
It will require storing additional information in the data base.

**Exercise  16.18 [m]** There was also a stop command that immediately halted the session.
Implement it.

**Exercise  16.19 [d]** The original EMYCIN also had a change command to allow the user to change the answer to certain questions without starting all over.
Each question was assigned a number, which was printed before the prompt.
The command change, followed by a list of numbers, causes the system to look up the questions associated with each number and delete the answer to these questions.
The system also throws away the entire context tree and all derived parameter values.
At that point the entire consultation is restarted, using only the data obtained from the unchanged questions.
Although it may seem wasteful to start over from the beginning, it will not be wasteful of the user's time, since correct answers will not be asked again.

Identify what needs to be altered to implement change and make the alterations.

**Exercise  16.20 [h]** Change the definition of `cf`-and and `cf-or` to use fuzzy set theory instead of certainty factors.
Do the same for Dempster-Shafer theory.

## 16.12 Ответы

**Answer 16.1** Because EMYCIN assumes independence, each reading of the same headline would increase the certainty factor.
The following computation shows that 298 more copies would be needed to reach .95 certainty.
A more sophisticated reasoner would realize that multiple copies of a newspaper are completely dependent on one another, and would not change the certainty with each new copy.

```lisp
> (loop for cf = .01 then (cf-or .01 cf)
      until (> cf .95)
      count t)
298
```

**Answer 16.2** The `defrule` expandsto (`make-rule :number '101 :cf true ...`); that is, the certainty factor is unquoted, so it is already legal to use true as a certainty factor!
To support `probably` and other hedges, just define new constants.

**Answer 16.4** Just make the default parameter type be `nil` (by changing `t` to `nil` in `parm-type`).
Then any rule that uses an undefined parameter will automatically generate a warning.

**Answer 16.6**

```lisp
(defrule 4
  if (sex patient is male)
  then -  1 (pregnant patient is yes))
```

**Answer 16.7** Logically, there should be no difference, but to EMYCIN there is a big difference.
EMYCIN would not complain if you answered `(yes 1 no 1)`.
This suggests that the system should have some way of dealing with mutually exclusive answers.
One way would be to accept only yes responses for Boolean parameters, but have the input routine translate no to `(yes -1)` and `(no *cf*)` to `(yes 1-*cf*)`.
Another possibility would be to have `update-cf check` to see if any certainty factor on a mutually exclusive value is 1, and if so, change the other values to -1.

**Answer 16.18** Add the clause `(stop (throw 'stop nil))` to the case statement inask-valsandwrapa `(catch 'stop ...)` around the code in `emycin`.