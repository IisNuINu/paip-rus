# Глава 23
## Компиляция Lisp

Во многих учебниках показаны простые интерпретаторы Лиспа, потому что они просты в написании и потому, что полезно знать, как работает интерпретатор.
К сожалению, не так много учебников показывают, как писать компилятор, хотя по тем же двум причинам.
Самый простой компилятор не должен быть намного сложнее интерпретатора.

Одна вещь, которая делает компилятор более сложным, заключается в том, что мы должны описывать вывод компилятора: набор инструкций машины, для которой мы компилируем.
На данный момент давайте предположим, что это машина на основе стека.
Последовательность вызова на этом компьютере для вызова функции с *n* аргументами состоит в том, чтобы поместить *n* аргументов в стек, а затем поместить туда функцию, которая будет вызвана.
Инструкция `"CALL *n*"` сохраняет точку возврата в стеке и переходит к первой инструкции вызываемой функции.
По соглашению, первая инструкция функции всегда будет `"ARGS *n*"`, которая выталкивает *n* аргументов из стека, помещая их в окружающую среду новой функции, где к ним могут получить доступ инструкции `LVAR` и `LSET`.
Функция должна возвращаться с инструкцией `RETURN`, которая сбрасывает счетчик программы и окружение до точки исходной инструкции `CALL`.

Кроме того, наша машина имеет три инструкции `JUMP`; одна, переходящая безусловно, и две, которые выполняют переход в зависимости от того, является ли вершина стека нулевой или ненулевой.
Также есть инструкция для удаления ненужных значений из стека, а также для доступа и изменения глобальных переменных.
Набор команд показан на [рисунке 23.1](#f0010).
Словарь для программы компилятора приведен на [рисунке 23.2](# f0015).
Краткое описание более сложной версии компилятора приведено на [страница 795](#p795).

| []() |
|---|
| ![f23-01](images/chapter23/f23-01.jpg) |
| Рисунок 23.1: Набор Инструкций для гипотетической Стековой Машины |

*(ed: should be a markdown table)*

| []() |
|---|
| ![f23-02](images/chapter23/f23-02.jpg) |
| Figure 23.2: Glossary for the Scheme Compiler |

*(ed: should be a markdown table)*

Например, процедура

```lisp
(lambda () (if (= x y) (f (g x)) (h x y (h 1 2))))
```

должна скомпилироваться в следующие инструкции:

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `Y`  |
|       | `GVAR`   | `=`  |
|       | `CALL`   | `2`  |
|       | `FJUMP`  | `L1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `G`  |
|       | `CALL`   | `1`  |
|       | `GVAR`   | `F`  |
|       | `CALL`   | `1`  |
|       | `JUMP`   | `L2` |
| `L1:` | `GVAR`   | `X`  |
|       | `GVAR`   | `Y`  |
|       | `CONST`  | `1`  |
|       | `CONST`  | `2`  |
|       | `GVAR`   | `H`  |
|       | `CALL`   | `2`  |
|       | `GVAR`   | `H`  |
|       | `CALL`   | `3`  |
| `L2:` | `RETURN` |      |

Первая версия компилятора Scheme довольно проста.
Он имитирует структуру вычислителя(evaluator) Scheme.
Разница в том, что каждый случай генерирует код, а не вычисляет подвыражения:

```lisp
(defun comp (x env)
  "Compile the expression x into a list of instructions"
  (cond
    ((symbolp x) (gen-var x env))
    ((atom x) (gen 'CONST x))
    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))
    ((case (first x)
       (QUOTE  (gen 'CONST (second x)))
       (BEGIN  (comp-begin (rest x) env))
       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))
       (IF     (comp-if (second x) (third x) (fourth x) env))
       (LAMBDA (gen 'FN (comp-lambda (second x) (rest (rest x)) env)))
       ;; Procedure application:
       ;; Compile args, then fn, then the call
       (t      (seq (mappend #'(lambda (y) (comp y env)) (rest x))
                    (comp (first x) env)
                              (gen 'call (length (rest x)))))))))

```

Компилятор `comp` имеет те же девять вариантов - фактически ту же самую структуру - что и интерпретатор `interp` из [главы 22](B9780080571157500224.xhtml).
Каждый случай немного сложнее, поэтому три основных случая были разделены на отдельные функции: `comp-begin`, `comp-if` и `comp-lambda`. 
Выражение `begin` компилируется путем компиляции каждого аргумента по очереди, но обязательно выталкивает каждое значение, кроме последнего, из стека после его вычисления.
Последний элемент в `begin` остается в стеке как значение всего выражения. 
Обратите внимание, что функция `gen` генерирует одну инструкцию (фактически список из одной инструкции), а `seq` создает последовательность инструкций из двух или более подпоследовательностей.

```lisp
(defun comp-begin (exps env)
  "Compile a sequence of expressions, popping all but the last."
  (cond ((null exps) (gen 'CONST nil))
        ((length=1 exps) (comp (first exps) env))
        (t (seq (comp (first exps) env)
                (gen 'POP)
                (comp-begin (rest exps) env)))))
```

Выражение `if` компилируется путем компиляции предиката, части then(затем) и части иначе(else), а также путем вставки соответствующих инструкций ветвления.

```lisp
(defun comp-if (pred then else env)
  "Compile a conditional expression."
  (let ((L1 (gen-label))
        (L2 (gen-label)))
    (seq (comp pred env) (gen 'FJUMP L1)
         (comp then env) (gen 'JUMP L2)
         (list L1) (comp else env)
         (list L2))))
```

Наконец, `lambda`- выражение компилируется путем компиляции тела, окружая его одной инструкцией для установки аргументов и другой для возврата из функции, а затем сохраняя полученный скомпилированный код вместе с окружающей средой(environment).
Тип данных `fn` реализован в виде структуры со слотами для тела кода, списка аргументов и имени функции (только для целей печати).

```lisp
(defstruct (fn (:print-function print-fn))
  code (env nil) (name nil) (args nil))

(defun comp-lambda (args body env)
  "Compile a lambda form into a closure with compiled code."
  (assert (and (listp args) (every #'symbolp args)) ()
          "Lambda arglist must be a list of symbols, not ~a" args)
  ;; For now, no &rest parameters.
  ;; The next version will support Scheme's version of &rest
  (make-fn
    :env env :args args
    :code (seq (gen 'ARGS (length args))
               (comp-begin body (cons args env))
               (gen 'RETURN))))
```

Преимущество компиляции перед интерпретацией состоит в том, что многое можно решить во время компиляции.
Например, компилятор может определить, относится ли ссылка к глобальной переменной или к лексической переменной, и если это ссылка на лексическую переменную, где именно эта лексическая переменная хранится.
Это вычисление выполняется компилятором только один раз, но оно должно выполняться каждый раз, когда выражение встречается в интерпретаторе.
Точно так же компилятор может подсчитать количество аргументов раз и навсегда, в то время как интерпретатор должен пройти цикл, подсчитывая количество аргументов и проверяя конец аргументов после интерпретации каждого из них.

Еще одно преимущество состоит в том, что компилятор может быть более надежным.
Например, в `comp-lambda` мы проверяем, что список параметров лямбда-выражения является списком, содержащим только символы.
Было бы слишком дорого делать такие проверки в интерпретаторе, но в компиляторе стоит проверить один раз во время компиляции на наличие условий ошибки, а не повторно проверять во время выполнения.

Прежде чем мы покажем остальную часть компилятора, вот полезный интерфейс верхнего уровня для `comp`:

```lisp
(defvar *label-num* 0)

(defun compiler (x)
  "Compile an expression as if it were in a parameterless lambda."
  (setf *label-num* 0)
  (comp-lambda '() (list x) nil))

(defun comp-show (x)
  "Compile an expression and show the resulting code"
   (show-fn (compiler x))
  (values))
```

Теперь вот код для генерации отдельных инструкций и последовательностей инструкций.
Последовательность инструкций - это просто список, но мы предоставляем функцию `seq` вместо того, чтобы напрямую использовать `append` для целей абстракции данных.
label - это просто атом.

```lisp
(defun gen (opcode &rest args)
  "Return a one-element list of the specified instruction."
  (list (cons opcode args)))

(defun seq (&rest code)
  "Return a sequence of instructions"
  (apply #'append code))

(defun gen-label (&optional (label 'L))
  "Generate a label (a symbol of the form Lnnn)"
  (intern (format nil "~a~d" label (incf *label-num*))))
```

Окружающие среды теперь представлены в виде списков кадров(frames), где каждый кадр представляет собой последовательность переменных.
На локальные переменные ссылаются не по их имени, а по двум целым числам: индекс в списке фреймов и индекс в отдельном фрейме.
Как обычно, индексы отсчитываются от нуля.
Например, данный код:

```lisp
(let ((a 2.0)
          (b 2.1))
  (let ((c 1.0)
            (d 1.1))
    (let ((e 0.0)
          (f 0.1))
      (+ a b c d e f))))
```

самая внутренняя окружающая среда - это `((e f) (c d) (a b))`.
Функция `in-env-p` проверяет, появляется ли переменная в среде.
Если бы эта среда была названа `env`, то `(in-env-p 'f env)` вернула бы `(0 1)`, а `(in-env-p' x env)` вернула бы `nil`.

```lisp
(defun gen-var (var env)
  "Generate an instruction to reference a variable's value."
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LVAR (first p) (second p) ";" var)
        (gen 'GVAR var))))

(defun gen-set (var env)
  "Generate an instruction to set a variable to top-of-stack."
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LSET (first p) (second p) ";" var)
        (gen 'GSET var))))(def-scheme-macro define (name &rest body)
  (if (atom name)
      `(name! (set! ,name . ,body) ',name)
      (scheme-macro-expand
         `(define ,(first name)
            (lambda ,(rest name) . ,body)))))
```

Наконец, у нас есть несколько вспомогательных функций для распечатки результатов, для различения меток и инструкций и для определения индекса переменной в среде.
Функции Scheme теперь реализованы в виде структур, которые должны иметь поле для кода и поле для окружающей среды.
Кроме того, мы предоставляем поле для имени функции и для списка аргументов; они используются только для целей отладки. 
Мы примем соглашение, согласно которому макрос `define` устанавливает поле имени функции, вызывая `name`! (которая не является частью стандартной схемы).

```lisp
(defun name! (fn name)
  "Set the name field of fn, if it is an un-named fn."
  (when (and (fn-p fn) (null (fn-name fn)))
    (setf (fn-name fn) name))
  name)

;; This should also go in init-scheme-interp:
(set-global-var! 'name! #'name!)

(defun print-fn (fn &optional (stream *standard-output*) depth)
  (declare (ignore depth))
  (format stream "{~a}" (or (fn-name fn) '??)))

(defun show-fn (fn &optional (stream *standard-output*) (depth 0))
  "Print all the instructions in a function.
  If the argument is not a function, just princ it,
  but in a column at least 8 spaces wide."
  (if (not (fn-p fn))
      (format stream "~8a" fn)
      (progn
        (fresh-line)
        (incf depth 8)
        (dolist (instr (fn-code fn))
          (if (label-p instr)
              (format stream "~a:" instr)
              (progn
                (format stream "~VT" depth)
                (dolist (arg instr)
                  (show-fn arg stream depth))
                (fresh-line)))))))

(defun label-p (x) "Is x a label?" (atom x))

(defun in-env-p (symbol env)
  "If symbol is in the environment, return its index numbers."
  (let ((frame (find symbol env :test #'find)))
    (if frame (list (position frame env) (position symbol frame)))))
```

Теперь мы готовы показать компилятор в работе:

```
> (comp-show '(if (= x y) (f (g x)) (h x y (h 1 2))))
```

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `Y`  |
|       | `GVAR`   | `=`  |
|       | `CALL`   | `2`  |
|       | `FJUMP`  | `L1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `G`  |
|       | `CALL`   | `1`  |
|       | `GVAR`   | `F`  |
|       | `CALL`   | `1`  |
|       | `JUMP`   | `L2` |
| `L1:` | `GVAR`   | `X`  |
|       | `GVAR`   | `Y`  |
|       | `CONST`  | `1`  |
|       | `CONST`  | `2`  |
|       | `GVAR`   | `H`  |
|       | `CALL`   | `2`  |
|       | `GVAR`   | `H`  |
|       | `CALL`   | `3`  |
| `L2:` | `RETURN` |      |

Этот пример должен дать читателю представление о коде, созданном компилятором.

Другая причина, по которой компилятор имеет преимущество перед интерпретатором, заключается в том, что компилятор может позволить себе потратить некоторое время на попытки найти более эффективное кодирование выражения, в то время как для интерпретатора накладные расходы на поиск более эффективной интерпретации обычно сводят на нет любое полученное преимущество. .
Вот несколько мест, где компилятор мог бы работать лучше, чем интерпретатор (хотя наш компилятор в настоящее время этого не делает):

```
> (comp-show '(begin "doc" (write x) y))
```

| []() |          |         |
|------|----------|---------|
|      | `ARGS`   | `0`     |
|      | `CONST`  | `doc`   |
|      | `POP`    |         |
|      | `GVAR`   | `X`     |
|      | `GVAR`   | `WRITE` |
|      | `CALL`   | `1`     |
|      | `POP`    |         |
|      | `GVAR`   | `Y`     |
|      | `RETURN` |         |

В этом примере генерируется код, который помещает константу `"doc"` в стек, а затем немедленно удаляет ее.
Если у нас есть компилятор, отслеживающий, какие выражения компилируются "для значения" - поскольку y - это значение выражения выше - и какие компилируются только "для эффекта", то мы можем вообще избежать генерации кода для ссылки на константы или переменные для эффекта.
Вот еще пример:

```
> (comp-show '(begin (+ (* a x) (f x)) x))
```

| []()     |     |
|----------|-----|
| `ARGS`   | `0` |
| `GVAR`   | `A` |
| `GVAR`   | `X` |
| `GVAR`   | `*` |
| `CALL`   | `2` |
| `GVAR`   | `X` |
| `GVAR`   | `F` |
| `CALL`   | `1` |
| `GVAR`   | `+` |
| `CALL`   | `2` |
| `POP`    |     |
| `GVAR`   | `X` |
| `RETURN` |     |

В этом выражении, если мы можем быть уверены, что + и * относятся к обычным арифметическим функциям, то мы можем скомпилировать его, как если бы это было `(begin (f x) x)`.
Более того, разумно предположить, что + и * будут инструкциями на нашей машине, которые можно выполнить непосредственно, а не вызывать функцию.
Многие компиляторы тратят значительную часть своего времени на оптимизацию арифметических операций, принимая во внимание ассоциативность, коммутативность, распределительность и другие свойства.

Помимо арифметики, компиляторы часто проводят экспертизу в условных выражениях.
Рассмотреть следующее:

```
> (comp-show '(if (and p q) x y))
```

| []()  |          |       |
|-------|----------|-------|
|       | `ARGS`   | `0`   |
|       | `GVAR`   | `P`   |
|       | `FJUMP`  | `L3`  |
|       | `GVAR`   | `Q`   |
|       | `JUMP`   | `L4`  |
| `L3:` | `GVAR`   | `NIL` |
| `L4:` | `FJUMP`  | `L1`  |
|       | `GVAR`   | `X`   |
|       | `JUMP`   | `L2`  |
| `L1:` | `GVAR`   | `Y`   |
| `L2:` | `RETURN` |       |

Обратите внимание, что `(and p q)` макро-расширяется до `(if p q nil)`.
Полученный скомпилированный код корректен, но неэффективен.
Во-первых, существует безусловный переход к `L4`, который обозначает условный переход к `L1`.
Это можно было бы заменить условным переходом к `L1`.
Во-вторых, на `L3` мы загружаем `NIL`, а затем переходим при nil к `L1`.
Эти две инструкции могут быть заменены безусловным переходом к `L1`.
В-третьих, `FJUMP` к `L3` можно заменить на `FJUMP` к `L1`, так как теперь мы знаем, что код в `L3` безоговорочно переходит к `L1`.

Наконец, некоторые компиляторы, особенно компиляторы Lisp, проводят экспертизу вызова функций.
Рассмотреть следующее:

```
> (comp-show '(f (g x y)))
```

| []() |          |     |
| ---  |----------|-----|
|      | `ARGS`   | `0` |
|      | `GVAR`   | `X` |
|      | `GVAR`   | `Y` |
|      | `GVAR`   | `G` |
|      | `CALL`   | `2` |
|      | `GVAR`   | `F` |
|      | `CALL`   | `1` |
|      | `RETURN` |     |

Здесь мы вызываем `g` и когда `g` возвращается мы вызываем `f` , а когда `f` возвращаеся мы вернемся из этой функции.
Но это последнее возвращение является расточительным; мы помещаем адрес возврата в стек, а затем убираем его и возвращаемся к следующему адресу возврата.
Альтернативный протокол вызова функции включает в себя помещение в стек адреса возврата перед вызовом `g`, но затем не помещать в стек адрес возврата перед вызовом `f;` когда `f` возвращается, он вернется непосредственно к вызывающей функции, какой бы она ни была.

Такая оптимизация выглядит небольшим выигрышем; мы в основном исключаем единственную инструкцию.
Фактически, последствия этого нового протокола огромны: теперь мы можем вызывать рекурсивную функцию до произвольной глубины без увеличения стека вообще - до тех пор, пока рекурсивный вызов является последним оператором в функции (или в ветви функция, когда есть условные выражения).
Функция, которая подчиняется этому ограничению на свои рекурсивные вызовы, известна как *правильная хвосто- рекурсивная* функция.
Эта тема обсуждалась в [разделе 22.3.](B9780080571157500224.xhtml#s0020)

До сих пор все примеры касались только глобальных переменных.
Вот пример использования локальных переменных:

```
> (comp-show '((lambda (x) ((lambda (y z) (f x y z)) 3 x)) 4))
```

| []()     |          |          |     |     |     |     |
|----------|----------|----------|-----|-----|-----|-----|
| `ARGS`   | `0`      |          |     |     |     |     |
| `CONST`  | `4`      |          |     |     |     |     |
| `FN`     |          |          |     |     |     |     |
|          | `ARGS`   | `1`      |     |     |     |     |
|          | `CONST`  | `3`      |     |     |     |     |
|          | `LVAR`   | `0`      | `0` | ;   | `X` |     |
|          | `FN`     |          |     |     |     |     |
|          |          | `ARGS`   | `2` |     |     |     |
|          |          | `LVAR`   | `1` | `0` | ;   | `X` |
|          |          | `LVAR`   | `0` | `0` | ;   | `Y` |
|          |          | `LVAR`   | `0` | `1` | `;` | `Z` |
|          |          | `GVAR`   | `F` |     |     |     |
|          |          | `CALL`   | `3` |     |     |     |
|          |          | `RETURN` |     |     |     |     |
|          | `CALL`   | `2`      |     |     |     |     |
|          | `RETURN` |          |     |     |     |     |
| `CALL`   | `1`      |          |     |     |     |     |
| `RETURN` |          |          |     |     |     |     |

Код имеет отступ для отображения вложенных функций.
Функция верхнего уровня загружает константу 4 и анонимную функцию и вызывает функцию.
Эта функция загружает константу 3 и локальную переменную `x`, которая является первым (0-м) элементом в верхнем (0-м) кадре.
Затем он вызывает функцию с двойной вложенностью для этих двух аргументов.
Эта функция загружает `x, y`, и `z: x` теперь является 0-м элементом следующего (первого) кадра, а `y` и `z` являются 0-м и 1-м элементами верхнего кадра.
Со всеми аргументами, наконец, вызывается функция `f`.
Обратите внимание, что никакие продолжения не сохраняются - `f` может возвращаться непосредственно вызывающей эту функцию стороне.

Однако все эти явные манипуляции с окружением неэффективны; в этом случае мы могли бы скомпилировать все, просто поместив 4, 3 и 4 в стек и вызвав `f`.

## 23.1 Правильный хвосто-рекурсивный компилятор Лиспа

В этом разделе мы описываем новую версию компилятора, сначала показывая примеры его вывода, а затем исследуя сам компилятор, который кратко описан на [рис. 23.3](#f0020).
В новой версии компилятора также используется другая последовательность вызова функций с использованием двух новых инструкций, `CALLJ` и `SAVE`.
Как следует из названия, `SAVE` сохраняет адрес возврата в стеке.
Инструкция `CALLJ` больше ничего не сохраняет; её можно рассматривать как безусловный переход - отсюда и буква `J` в её названии.

| []() |
|---|
| ![f23-03](images/chapter23/f23-03.jpg) |
| Figure 23.3: Glossary of the Scheme Compiler, Second Version |

*(ed: should be a markdown table)*

Сначала мы посмотрим, как работают вызовы вложенных функций:

```
> (comp-show '(f (g x)))
```

| []()  |         |      |
|-------|---------|------|
|       | `ARGS`  | `0`  |
|       | `SAVE`  | `K1` |
|       | `GVAR`  | `X`  |
|       | `GVAR`  | `G`  |
|       | `CALLJ` | `1`  |
| `K1:` | `GVAR`  | `F`  |
|       | `CALLJ` | `1`  |

Точка продолжения `K1` сохраняется, чтобы g мог вернуться к ней, но тогда продолжение для f не сохраняется, поэтому f возвращается к любому продолжению, находящемуся в стеке.
Таким образом, нет необходимости в явной инструкции `RETURN`.
Последний `CALL` подобен безусловному переходу.

В следующем примере показано, что все функции, кроме последней `(f)`, нуждаются в точке продолжения:

```
> (comp-show '(f (g (h x) (h y))))
```

| []()  |         |      |
|-------|---------|------|
|       | `ARGS`  | `0`  |
|       | `SAVE`  | `K1` |
|       | `SAVE`  | `K2` |
|       | `GVAR`  | `X`  |
|       | `GVAR`  | `H`  |
|       | `CALLJ` | `1`  |
| `K2:` | `SAVE`  | `K3` |
|       | `GVAR`  | `Y`  |
|       | `GVAR`  | `H`  |
|       | `CALLJ` | `1`  |
| `K3:` | `GVAR`  | `G`  |
|       | `CALLJ` | `2`  |
| `K1:` | `GVAR`  | `F`  |
|       | `CALLJ` | `1`  |

Этот код сначала вычисляет `(h x)` и возвращается к `K2`.
Затем он вычисляет `(h y)` и возвращается к `K3`.
Затем он вызывает `g` для этих двух значений и возвращается к `K1` перед переходом к `f`.
Поскольку все, что возвращает `f`, также будет окончательным значением функции, которую мы компилируем, нет необходимости сохранять точку продолжения для возврата `f`.

В следующем примере мы видим, что ненужные константы и переменные в выражениях `begin` игнорируются:

```
> (comp-show '(begin "doc" x (f x) y))
```

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `SAVE`   | `K1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `F`  |
|       | `CALLJ`  | `1`  |
| `K1:` | `POP`    |      |
|       | `GVAR`   | `Y`  |
|       | `RETURN` |      |

Одним из основных недостатков первой версии компилятора является то, что она могла передавать данные, но на самом деле она не могла ничего *делать* с объектами данных.
Мы исправляем эту проблему, дополнив машину инструкциями для выполнения арифметических и других примитивных операций.
Ненужные примитивные операции, такие как переменные, константы и арифметические операции, игнорируются, когда они находятся в нефинальной позиции в пределах `begin`.
Сравните два следующих выражения:

```
> (comp-show '(begin (+ (* a x) (f x)) x))
```

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `SAVE`   | `K1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `F`  |
|       | `CALLJ`  | `1`  |
| `K1:` | `POP`    |      |
|       | `GVAR`   | `X`  |
|       | `RETURN` |      |

| `> (comp-show '(begin (+ (* a x) (f x))))` |

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `A`  |
|       | `GVAR`   | `X`  |
|       | `*`      |      |
|       | `SAVE`   | `K1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `F`  |
|       | `CALLJ`  | `1`  |
| `K1:` | `+`      |      |
|       | `RETURN` |      |

Первая версия компилятора была контекстно-свободной в том смысле, что она эквивалентно компилировала все эквивалентные выражения, независимо от того, где они появились.
Компилятор с правильной хвостовой рекурсией должен быть контекстно-зависимым: он должен компилировать вызов, который является конечным значением функции, иначе, чем вызов, который используется в качестве промежуточного значения или значение которого игнорируется.
В первой версии компилятора `comp-lambda` отвечал за генерацию инструкции `RETURN`, и весь код в конечном итоге достигал этой инструкции.
Чтобы убедиться, что `RETURN` был достигнут, код для двух ветвей выражения `if` должен был воссоединиться в конце.

В компиляторе с хвостовой рекурсией каждый фрагмент кода отвечает за вставку собственной инструкции `RETURN` или неявный возврат путем вызова другой функции без сохранения точки продолжения.

Мы отслеживаем эти возможности с помощью двух флагов.
Параметр `val?` истинен, когда выражение, которое мы компилируем, возвращает значение, которое используется в другом месте.
Параметр `more?` является ложным, когда выражение представляет окончательное значение, и истинным, когда необходимо еще вычислять.
Таким образом, есть три возможности:

| `val?` | `more?` | example: the `X` in:          |
|--------|---------|-------------------------------|
| true   | true    | `(if X y z)`*or*`(f X y)`     |
| true   | false   | `(if p X z)`*or*`(begin y X)` |
| false  | true    | `(begin X y)`                 |
| false  | false   | *impossible*                  |

Код для компилятора, использующего эти соглашения, следующий:

```lisp
(defun comp (x env)
  "Compile the expression x into a list of instructions"
  (cond
    ((symbolp x) (gen-var x env))
    ((atom x) (gen 'CONST x))
    ((scheme-macro (first x)) (comp (scheme-macro-expand x) env))
    ((case (first x)
       (QUOTE  (gen 'CONST (second x)))
       (BEGIN  (comp-begin (rest x) env))
       (SET!   (seq (comp (third x) env) (gen-set (second x) env)))
       (IF     (comp-if (second x) (third x) (fourth x) env))
       (LAMBDA (gen 'FN (comp-lambda (second x) (rest (rest x)) env)))
       ;; Procedure application:
       ;; Compile args, then fn, then the call
       (t      (seq (mappend #'(lambda (y) (comp y env)) (rest x))
                    (comp (first x) env)
                              (gen 'call (length (rest x)))))))))
```

Здесь мы добавили еще один случай: `t` и `nil` компилируются непосредственно в примитивные инструкции, а не полагаются на их привязку как глобальные переменные.
(В реальной Scheme логические значения - это `# t` и `#f`, которые не нужно заключать в кавычки, пустой список - это `()`, который должен быть заключен в кавычки, а `t` и `nil` - обычные символы. без особого значения.)

Я также добавил проверку на ошибки количества аргументов, передаваемых в `quote`, `set!` и `if`.
Обратите внимание, что в компиляторе разумно выполнять больше проверок ошибок, чем в интерпретаторе, поскольку проверка должна выполняться только один раз, а не каждый раз.
Функция проверки аргументов следующая:

```lisp
(defun arg-count (form min &optional (max min))
  "Report an error if form has wrong number of args."
  (let ((n-args (length (rest form))))
    (assert (<= min n-args max) (form)
      "Wrong number of arguments for ~a in ~a:
       ~d supplied, ~d~@[ to ~d~] expected"
      (first form) form n-args min (if (/= min max) max))))
```

**Exercise  23.1 [m]** Измените компилятор, чтобы проверить наличие дополнительных ошибок времени компиляции, совершенных следующим ошибочным выражением:

```lisp
(cdr (+ (list x y) 'y (3 x) (car 3 x)))
```

Хвостово-рекурсивный компилятор по-прежнему имеет девять известных случаев, но я ввел `comp-var`, `comp-const`, `comp-if` и `comp-funcall`, чтобы справиться с повышенной сложностью, вызванной параметрами `var?` и `more?`.

Давайте рассмотрим функции `comp-` по очереди.
Во-первых, `comp-begin` и `comp-list` просто обрабатывают и передают дополнительные параметры.
`comp-list` будет использоваться в `comp-funcall`, новой функции, которая будет введена для компиляции применения процедуры.

```lisp
(defun comp-begin (exps env val? more?)
  "Compile a sequence of expressions,
  returning the last one as the value."
  (cond ((null exps) (comp-const nil val? more?))
        ((length=1 exps) (comp (first exps) env val? more?))
        (t (seq (comp (first exps) env nil t)
                (comp-begin (rest exps) env val? more?)))))

(defun comp-list (exps env)
  "Compile a list, leaving them all on the stack."
  (if (null exps) nil
      (seq (comp (first exps) env t t)
           (comp-list (rest exps) env))))
```

Затем есть две тривиальные функции для компиляции доступа к переменным и константам.
Если значение не требуется, они не производят никаких инструкций вообще.
Если больше ничего не нужно делать, то эти функции должны генерировать инструкцию возврата.
Это изменение по сравнению с предыдущей версией `comp`, где вызывающий генерировал инструкцию возврата.
Обратите внимание, что я расширил машину, чтобы включить инструкции для наиболее распространенных констант: t, nil и некоторых небольших целых чисел.

```lisp
(defun comp-const (x val? more?)
  "Compile a constant expression."
  (if val? (seq (if (member x '(t nil -1 0 1 2))
                    (gen x)
                    (gen 'CONST x))
                (unless more? (gen 'RETURN)))))

(defun comp-var (x env val? more?)
  "Compile a variable reference."
  (if val? (seq (gen-var x env) (unless more? (gen 'RETURN)))))
```

Оставшиеся две функции более сложны.
Сначала рассмотрим `comp-if`. Вместо того чтобы слепо генерировать код для предиката и обеих ветвей, мы рассмотрим некоторые частные случаи(case).
Во-первых, ясно, что `(if t x y)` можно свести к `x` и `(if nil x y)` можно свести к `y`.
Возможно, не так очевидно, что `(if p x x)` может быть сведено к `(begin p x)`, или что сравнение equality на равенство между двумя ветвями должно выполняться на объектном коде, а не на исходном коде.
Когда эти тривиальные частные случаи были рассмотрены, у нас осталось еще три случая: `(if р х nil), (if p nil y)` и `(if p x y)`.
Шаблон меток и переходов для каждого из них различен.

```lisp
(defun comp-if (pred then else env val? more?)
  "Compile a conditional (IF) expression."
  (cond
    ((null pred)          ; (if nil x y) ==> y
     (comp else env val? more?))
    ((constantp pred)     ; (if t x y) ==> x
     (comp then env val? more?))
    ((and (listp pred)    ; (if (not p) x y) ==> (if p y x)
          (length=1 (rest pred))
          (primitive-p (first pred) env 1)
          (eq (prim-opcode (primitive-p (first pred) env 1)) 'not))
     (comp-if (second pred) else then env val? more?))
    (t (let ((pcode (comp pred env t t))
             (tcode (comp then env val? more?))
             (ecode (comp else env val? more?)))
         (cond
           ((equal tcode ecode) ; (if p x x) ==> (begin p x)
            (seq (comp pred env nil t) ecode))
           ((null tcode)  ; (if p nil y) ==> p (TJUMP L2) y L2:
            (let ((L2 (gen-label)))
              (seq pcode (gen 'TJUMP L2) ecode (list L2)
                   (unless more? (gen 'RETURN)))))
           ((null ecode)  ; (if p x) ==> p (FJUMP L1) x L1:
            (let ((L1 (gen-label)))
              (seq pcode (gen 'FJUMP L1) tcode (list L1)
                   (unless more? (gen 'RETURN)))))
           (t             ; (if p x y) ==> p (FJUMP L1) x L1: y
                          ; or p (FJUMP L1) x (JUMP L2) L1: y L2:
            (let ((L1 (gen-label))
                  (L2 (if more? (gen-label))))
              (seq pcode (gen 'FJUMP L1) tcode
                   (if more? (gen 'JUMP L2))
                   (list L1) ecode (if more? (list L2))))))))))
```

Вот несколько примеров выражений типа `if`.
Во-первых, очень простой пример:

```
> (comp-show '(if p (+ x y) (* x y)))
```

| []()   |          |      |
|--------|----------|------|
|        | `ARGS`   | `0`  |
|        | `GVAR`   | `P`  |
|        | `FJUMP`  | `L1` |
|        | `GVAR`   | `X`  |
|        | `GVAR`   | `Y`  |
|        | `+`      |      |
|        | `RETURN` |      |
| `L1 :` | `GVAR`   | `X`  |
|        | `GVAR`   | `Y`  |
|        | `*`      |      |
|        | `RETURN` |      |

Каждая ветвь имеет свою собственную инструкцию `RETURN`.
Но обратите внимание, что генерируемый код чувствителен к его контексту.
Например, если мы поместим одно и то же выражение в выражение `begin`, мы получим нечто совершенно другое:

```
> (comp-show '(begin (if p (+ x y) (* x y)) z))
```

| []() |          |     |
|------|----------|-----|
|      | `ARGS`   | `0` |
|      | `GVAR`   | `Z` |
|      | `RETURN` |     |

Здесь происходит то, что `(+ x y)` и `(* x y)`, скомпилированные в контексте, где значение игнорируется, оба повторяются в не генерируемом коде.
Таким образом, `if` выражение сводится к `(if p nil nil)`, который  компирируется как `(begin p nil)`, который также не генерирует никакого кода, когда не вычисляется для значения, поэтому окончательный код просто ссылается на `z`.
Компилятор может выполнить эту оптимизацию только потому, что он знает, что `+` и `*` -это операции без побочных эффектов.
Рассмотрим, что происходит, когда мы заменяем + на `f`:

```
> (comp-show '(begin (if p (f x) (* x x)) z))
```

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `P`  |
|       | `FJUMP`  | `L2` |
|       | `SAVE`   | `K1` |
|       | `GVAR`   | `X`  |
|       | `GVAR`   | `F`  |
|       | `CALLJ`  | `1`  |
| `K1:` | `POP`    |      |
| `L2:` | `GVAR`   | `Z`  |
|       | `RETURN` |      |

Здесь мы имеем вызов `(f x)` если `p` равно истине (а затем выбросывающий возвращенное значение), но нам не нужно вычислять `(* x x)`, когда `p` ложно 

Эти примеры непреднамеренно выявили некоторую структуру `comp-funcall`, которая обрабатывает пять случаев.
Во-первых, она знает некоторые примитивные функции, которые имеют соответствующие инструкции, и компилирует эти инструкции встраиваемыми, когда необходимы их значения.
Если значения не нужны, то функция может быть проигнорирована, и только аргументы могут быть скомпилированы.
Это предполагает истинные функции без каких-либо побочных эффектов.
Если есть примитивные операции с побочными эффектами, они тоже могут быть скомпилированы встроенно, но эта операция никогда не может быть проигнорирована.
Следующий случай - это когда функция является лямбда-выражением без аргументов.
Мы можем просто скомпилировать тело лямбда-выражения, как если бы это было выражение `begin`.
Непримитивные функции требуют вызова функции.
Есть два случая: когда нужно скомпилировать больше, мы должны сохранить точку продолжения, и когда мы компилируем конечное значение функции, мы можем просто ответвляться(переходить) на вызываемую функцию.
Все это выглядит примерно так:

```lisp
(defun comp-funcall (f args env val? more?)
  "Compile an application of a function to arguments."
  (let ((prim (primitive-p f env (length args))))
    (cond
      (prim  ; function compilable to a primitive instruction
       (if (and (not val?) (not (prim-side-effects prim)))
           ;; Side-effect free primitive when value unused
           (comp-begin args env nil more?)
           ;; Primitive with value or call needed
           (seq (comp-list args env)
                (gen (prim-opcode prim))
                (unless val? (gen 'POP))
                (unless more? (gen 'RETURN)))))
      ((and (starts-with f 'lambda) (null (second f)))
       ;; ((lambda () body)) => (begin body)
       (assert (null args) () "Too many arguments supplied")
       (comp-begin (rest2 f) env val? more?))
      (more? ; Need to save the continuation point
       (let ((k (gen-label 'k)))
         (seq (gen 'SAVE k)
              (comp-list args env)
              (comp f env t t)
              (gen 'CALLJ (length args))
              (list k)
              (if (not val?) (gen 'POP)))))
      (t     ; function call as rename plus goto
       (seq (comp-list args env)
            (comp f env t t)
            (gen 'CALLJ (length args)))))))
```

Поддержка примитивов проста.
Тип данных `prim` имеет пять слотов.
Первый содержит имя символа, глобально связанного с примитивной операцией.
Второй, `n-args`, - это число аргументов, требующихся примитиву.
Мы должны учитывать количество аргументов для каждой функции, потому что мы хотим, чтобы `(+ x y)` компилировалась в примитивную инструкцию сложения, в то время как `(+ x y z)` нет.
Вместо этого она будет компилироваться в вызов функции +.
Слот `opcode` дает код операции, который используется для реализации примитива.
Поле `always`  истинно, если примитив всегда возвращает не-nil значение, `ложно`, если оно всегда возвращает nil, и nil в противном случае.
Оно используется в упражнении 23.6.
Наконец, поле `side-effects` указывает, есть ли у функции какие-либо побочные эффекты, такие как выполнение ввода-вывода или изменение значения объекта.

```lisp
(defstruct (prim (:type list))
  symbol n-args opcode always side-effects)

(defparameter *primitive-fns*
  '((+ 2 + true nil) (- 2 - true nil) (* 2 * true nil) (/ 2 / true nil)
    (< 2 < nil nil) (> 2 > nil nil) (<= 2 <= nil nil) (>= 2 >= nil nil)
    (/= 2 /= nil nil) (= 2 = nil nil)
    (eq? 2 eq nil nil) (equal? 2 equal nil nil) (eqv? 2 eql nil nil)
    (not 1 not nil nil) (null? 1 not nil nil) (cons 2 cons true nil)
    (car 1 car nil nil) (cdr 1 cdr nil nil)  (cadr 1 cadr nil nil)
    (list 1 list1 true nil) (list 2 list2 true nil) (list 3 list3 true nil)
    (read 0 read nil t) (write 1 write nil t) (display 1 display nil t)
    (newline 0 newline nil t) (compiler 1 compiler t nil)
    (name! 2 name! true t) (random 1 random true nil)))

(defun primitive-p (f env n-args)
  "F is a primitive if it is in the table, and is not shadowed
  by something in the environment, and has the right number of args."
  (and (not (in-env-p f env))
       (find f *primitive-fns*
             :test #'(lambda (f prim)
                       (and (eq f (prim-symbol prim))
                            (= n-args (prim-n-args prim)))))))

(defun list1 (x) (list x))
(defun list2 (x y) (list x y))
(defun list3 (x y z) (list x y z))
(defun display (x) (princ x))
(defun newline () (terpri))
```

Эти оптимизации работают только в том случае, если символы постоянно привязаны к глобальным значениям, приведенным здесь.
Мы можем обеспечить это, изменив `gen-set`, чтобы сохранить их как константы:

```lisp
(defun gen-set (var env)
  "Generate an instruction to set a variable to top-of-stack."
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LSET (first p) (second p) ";" var)
        (if (assoc var *primitive-fns*)
            (error "Can't alter the constant ~a" var)
            (gen 'GSET var)))))
```

Теперь выражение типа `(+ x 1)` будет правильно скомпилировано с использованием инструкции +, а не вызова подпрограммы, и выражение типа `(set ! + *)` будет помечено как ошибка, если + является глобальной переменной, но разрешено, если он был локально привязан.
Однако нам все еще нужно уметь обрабатывать такие выражения, как `(set! add +)`, а затем `(add x y)`.
Таким образом, нам нужен некоторый объект функции, к которому + будет глобально привязан, даже если компилятор обычно оптимизирует ссылки на эту функцию.
Функция `init-scheme-comp` заботится об этом требовании:

```lisp
(defun init-scheme-comp ()
  "Initialize the primitive functions."
  (dolist (prim *primitive-fns*)
     (setf (get (prim-symbol prim) 'global-val)
           (new-fn :env nil :name (prim-symbol prim)
                   :code (seq (gen 'PRIM (prim-symbol prim))
                              (gen 'RETURN))))))
```

Нужно внести еще одно изменение - переписать `comp-lambda`.
Нам все еще нужно извлечь аргументы из стека, но мы больше не генерируем инструкцию `RETURN`, так как это делается `comp-begin`, если это необходимо.
На этом этапе мы предоставим hook для подсматривающего(peephole) оптимизатора, который будет представлен в [разделе 23.4](#s0025), и для ассемблера, чтобы преобразовать язык ассемблера в машинный код, `new-fn` предоставляет этот интерфейс, но пока `new-fn` действует точно так же, как `make-fn`.

Мы также должны учитывать возможность rest аргументов в лямбда-списке.
Новая функция, `gen-rgs`, генерирует единственную инструкцию для загрузки аргументов стека.
Она вводит новую инструкцию, `ARGS`., в абстрактную машину.
Эта инструкция работает точно так же, как `ARGS`, за исключением того, что она также сохраняет все оставшиеся в стеке аргументы в список и сохраняет этот список как значение аргумента rest.
С этим нововведением новая версия `comp-lambda` выглядит следующим образом:

```lisp
(defun comp-lambda (args body env)
  "Compile a lambda form into a closure with compiled code."
  (new-fn :env env :args args
          :code (seq (gen-args args 0)
                     (comp-begin body
                                 (cons (make-true-list args) env)
                                 t nil))))

(defun gen-args (args n-so-far)
  "Generate an instruction to load the arguments."
  (cond ((null args) (gen 'ARGS n-so-far))
        ((symbolp args) (gen 'ARGS. n-so-far))
        ((and (consp args) (symbolp (first args)))
         (gen-args (rest args) (+ n-so-far 1)))
        (t (error "Illegal argument list"))))

(defun make-true-list (dotted-list)
  "Convert a possibly dotted list into a true, non-dotted list."
  (cond ((null dotted-list) nil)
        ((atom dotted-list) (list dotted-list))
        (t (cons (first dotted-list)
                 (make-true-list (rest dotted-list))))))

(defun new-fn (&key code env name args)
  "Build a new function."
  (assemble (make-fn :env env :name name :args args
                     :code (optimize code))))
```

`new-fn` включает вызовы ассемблера и оптимизатора для генерации фактического машинного кода.
На данный момент обе функции будут идентичными:

```lisp
(defun optimize (code) code)
(defun assemble (fn) fn)
```

Вот еще несколько примеров работы компилятора:

```
> (comp-show '(if (null? (car l)) (f (+ (* a x) b)) (g (/ x 2))))
```

| []()  |         |         |     |
|-------|---------|---------|-----|
|       | `ARGS`  | `0`     |     |
|       | `GVAR`  | `L`     |     |
|       | `CAR`   |         |     |
|       | `FJUMP` | `L1`    |     |
|       | `GVAR`  | `X`     |     |
|       | `2`     |         |     |
|       | /       |         |     |
|       | `GVAR`  | `G`     |     |
|       | `CALLJ` | `1`     |     |
| `L1:` | `GVAR`  | `A`     |     |
|       |         | `GVAR`  | `X` |
|       |         | `*`     |     |
|       |         | `GVAR`  | `B` |
|       |         | `+`     |     |
|       |         | `GVAR`  | `F` |
|       |         | `CALLJ` | `1` |

В этом коде нет необходимости сохранять какие-либо точки продолжения, поскольку единственные вызовы непримитивных функций происходят как конечные значения двух ветвей функции.

```lisp
> (comp-show '(define (lastl l)
```

`                            (if (null?
(cdr l)) (car l)`

```lisp
                                    (last1 (cdr l)))))
```

| []()  |          |          |     |     |     |     |
|-------|----------|----------|-----|-----|-----|-----|
|       | `ARGS`   | `0`      |     |     |     |     |
|       | `FN`     |          |     |     |     |     |
|       | `ARGS`   | `1`      |     |     |     |     |
|       | `LVAR`   | `0`      | `0` | `;` | `L` |     |
|       | `CDR`    |          |     |     |     |     |
|       | `FJUMP`  | `L1`     |     |     |     |     |
|       | `LVAR`   | `0`      | `0` | `;` | `L` |     |
|       | `CDR`    |          |     |     |     |     |
|       | `GVAR`   | `LAST1`  |     |     |     |     |
|       | `CALLJ`  | `1`      |     |     |     |     |
| `L1:` |          | `LVAR`   | `0` | `0` | `;` | `L` |
|       |          | `CAR`    |     |     |     |     |
|       |          | `RETURN` |     |     |     |     |
|       | `GSET`   | `LAST1`  |     |     |     |     |
|       | `CONST`  | `LAST1`  |     |     |     |     |
|       | `NAME!`  |          |     |     |     |     |
|       | `RETURN` |          |     |     |     |     |

Функция верхнего уровня просто присваивает вложенную функцию глобальной переменной `last1`.
Поскольку `last1` является хвосто-рекурсивной, она имеет только одну точку возврата для случая завершения и просто вызывает себя без сохранения продолжений до тех пор, пока этот случай не будет выполнен.

Сравните это с приведенным ниже не хвосто-рекурсивным определением `length`.
Она не является хвостово-рекурсивной, потому что перед рекурсивным вызовом `length` она должна сохранить точку продолжения, `K1`, чтобы знать, куда вернуться, чтобы добавить 1.

```lisp
> (comp-show '(define (length l)
```

`                                (if (null?
l) 0 (+  1 (length (cdr l))))))`

| []()  |          |          |          |     |     |     |
|-------|----------|----------|----------|-----|-----|-----|
|       | `ARGS`   | `0`      |          |     |     |     |
|       | `FN`     |          |          |     |     |     |
|       |          | `ARGS`   | `1`      |     |     |     |
|       |          | `LVAR`   | `0`      | `0` | `;` | `L` |
|       |          | `FJUMP`  | `L2`     |     |     |     |
|       |          | `1`      |          |     |     |     |
|       |          | `SAVE`   | `K1`     |     |     |     |
|       |          | `LVAR`   | `0`      | `0` | `;` | `L` |
|       |          | `CDR`    |          |     |     |     |
|       |          | `GVAR`   | `LENGTH` |     |     |     |
|       |          | `CALLJ`  | `1`      |     |     |     |
| `K1:` |          | `+`      |          |     |     |     |
|       |          | `RETURN` |          |     |     |     |
| `L2`  |          | `0`      |          |     |     |     |
|       |          | `RETURN` |          |     |     |     |
|       | `GSET`   | `LENGTH` |          |     |     |     |
|       | `CONST`  | `LENGTH` |          |     |     |     |
|       | `NAME!`  |          |          |     |     |     |
|       | `RETURN` |          |          |     |     |     |

Конечно, можно написать `length` в хвостовой рекурсивной манере:

```lisp
> (comp-show '(define (length l)
                            (letrec ((len (lambda (l n)
```

`                                                            (if (null?
l) n`

```lisp
                                                                    (len (rest l) (+ n l))))))
                                (len l 0))))
```

| []()  |          |          |         |          |        |     |       |       |
|-------|----------|----------|---------|----------|--------|-----|-------|-------|
|       | `ARGS`   | `0`      |         |          |        |     |       |       |
|       | `FN`     |          |         |          |        |     |       |       |
|       |          | `ARGS`   | `1`     |          |        |     |       |       |
|       |          | `NIL`    |         |          |        |     |       |       |
|       |          | `FN`     |         |          |        |     |       |       |
|       |          |          | `ARGS`  | `1`      |        |     |       |       |
|       |          |          | `FN`    |          |        |     |       |       |
|       |          |          |         | `ARGS`   | `2`    |     |       |       |
|       |          |          |         | `LVAR`   | `0`    | `0` | `;`   | `L`   |
|       |          |          |         | `FJUMP`  | `L2`   |     |       |       |
|       |          |          |         | `SAVE`   | `K1`   |     |       |       |
|       |          |          |         | `LVAR`   | `0`    | `0` | `;`   | `L`   |
|       |          |          |         | `GVAR`   | `REST` |     |       |       |
|       |          |          |         | `CALLJ`  | `1`    |     |       |       |
| `K1:` |          |          |         | `LVAR`   | `0`    | `1` | `;`   | `N`   |
|       |          |          |         | `1`      |        |     |       |       |
|       |          |          |         | `+`      |        |     |       |       |
|       |          |          |         | `LVAR`   | `1`    | `0` | `;`   | `LEN` |
|       |          |          |         | `CALLJ`  | `2`    |     |       |       |
| `L2:` |          |          |         | `LVAR`   | `0`    | `1` | `;`   | `N`   |
|       |          |          |         | `RETURN` |        |     |       |       |
|       |          |          | `LSET`  | `0`      | `0`    | `;` | `LEN` |       |
|       |          |          | `POP`   |          |        |     |       |       |
|       |          |          | `LVAR`  | `1`      | `0`    | `;` | `L`   |       |
|       |          |          | `0`     |          |        |     |       |       |
|       |          |          | `LVAR`  | `0`      | `0`    | `;` | `LEN` |       |
|       |          |          | `CALLJ` | `2`      |        |     |       |       |
|       |          | `CALLJ`  | `1`     |          |        |     |       |       |
|       | `GSET`   | `LENGTH` |         |          |        |     |       |       |
|       | `CONST`  | `LENGTH` |         |          |        |     |       |       |
|       | `NAME!`  |          |         |          |        |     |       |       |
|       | `RETURN` |          |         |          |        |     |       |       |

Давайте еще раз рассмотрим пример с вложенными условными обозначениями:

```
> (comp-show '(if (not (and p q (not r))) x y))
```

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `P`  |
|       | `FJUMP`  | `L3` |
|       | `GVAR`   | `Q`  |
|       | `FJUMP`  | `L1` |
|       | `GVAR`   | `R`  |
|       | `NOT`    |      |
|       | `JUMP`   | `L2` |
| `L1:` | `NIL`    |      |
| `L2:` | `JUMP`   | `L4` |
| `L3:` | `NIL`    |      |
| `L4:` | `FJUMP`  | `L5` |
|       | `GVAR`   | `Y`  |
|       | `RETURN` |      |
| `L5:` | `GVAR`   | `X`  |
|       | `RETURN` |      |

Здесь проблема заключается в множественном `JUMP` и в нераспознавании отрицания.
Если `p` ложно, то выражение `and` ложно, а весь предикат истинен, поэтому мы должны вернуть `x`.
Код делает на самом деле возврат `х`, но сначала он прыгает на `L3`, загружает `NIL`, а затем делает `FJUMP`, который всегда будет прыгать на `L5`.
Другие ветви обладают аналогичной неэффективностью.
Достаточно умный компилятор должен уметь генерировать следующий код:

| []()  |          |      |
|-------|----------|------|
|       | `ARGS`   | `0`  |
|       | `GVAR`   | `P`  |
|       | `FJUMP`  | `L1` |
|       | `GVAR`   | `Q`  |
|       | `FJUMP`  | `L1` |
|       | `GVAR`   | `R`  |
|       | `TJUMP`  | `L1` |
|       | `GVAR`   | `Y`  |
|       | `RETURN` |      |
| `L1:` | `GVAR X` |      |
|       | `RETURN` |      |

## 23.2 Введение Call/cc

Теперь, когда базовый компилятор работает, мы можем подумать о том, как реализовать `call/cc` в нашем компиляторе.
Во-первых, помните, что `call/cc` - это нормальная(обычная) функция, а не специальная форма.
Таким образом, мы могли бы определить её как примитивную, на манер `car` и `cons`.
Однако примитивы в том виде, в каком они были определены, могут видеть только свои аргументы, а `call/cc` должна будет видеть стек времени выполнения, чтобы сохранить текущее продолжение.
Один из вариантов - установить `call/cc` как обычную Непримитивную функцию Scheme, но написать ее тело в ассемблерном коде самостоятельно.
Нам нужно ввести одну новую инструкцию, `CC`, которая помещает в стек функцию (к которой мы также должны написать ассемблерный код вручную), которая сохраняет текущее продолжение (стек) в своей среде окружения и при вызове извлекает это продолжение и устанавливает его, возвращая стеку это значение.
Для этого требуется еще одна инструкция, `SET-CC`.
Подробности этой и всех других инструкций раскрываются в следующем разделе.

## 23.3 Абстрактная Машина

До сих пор мы определяли набор команд мифической абстрактной машины и генерировали ассемблерный код для этого набора команд.
Теперь пришло время фактически выполнить ассемблерный код и, следовательно, иметь полезный компилятор.
Есть несколько путей, которые мы могли бы использовать: мы могли бы реализовать машину в аппаратном, программном обеспечении или микрокоде, или мы могли бы перевести ассемблерный код для нашей абстрактной машины в ассемблерный код какой-либо существующей машины.
Каждый из этих подходов уже применялся в прошлом.

**Железо.** *Если абстрактная машина достаточно проста, она может быть реализована непосредственно в аппаратном обеспечении.
Чипы Scheme-79 и Scheme-81 ([Стилл и Sussman 1980](B9780080571157500285.xhtml#bb1180); [Batali et al.
1982](B9780080571157500285.xhtml#bb0070)) были СБИС-реализациями машины, разработанной специально для запуска Scheme.(B9780080571157500285.xhtml#bb1180); 

**Макроассемблер.** в подходе трансляции или макроассемблера каждая инструкция на абстрактном машинном языке переводится в одну или несколько инструкций в наборе команд целевого компьютера.
Это может быть сделано либо непосредственно, либо путем генерации кода сборки и передачи его ассемблеру целевого компьютера.
В общем случае это приведет к расширению кода, поскольку целевой компьютер, вероятно, не будет обеспечивать прямую поддержку типов данных схемы.
Таким образом, в то время как в нашей абстрактной машине мы могли бы написать одну инструкцию для сложения, с машинным кодом нам, возможно, придется выполнить серию инструкций, чтобы проверить тип аргументов, сделать целочисленное сложение, если они оба являются целыми числами, сложение с плавающей запятой, если они оба являются числами с плавающей запятой, и так далее.
Возможно, нам также придется проверить результат на переполнение и, возможно, преобразовать его в представление bignum.
Компиляторы, генерирующие машинный код, часто включают более сложный анализ потока данных, чтобы знать, когда такие проверки необходимы, а когда их можно пропустить.

**Микрокод.** проект MIT Lisp Machine, в отличие от чипов Scheme, фактически привел к рабочим машинам.
Одним из важных решений было использование микрокода вместо одиночного чипа.
Это позволило легко изменить систему по мере накопления опыта, а также по мере изменения языка хоста с ZetaLisp на Common Lisp.
Наиболее важной архитектурной особенностью Lisp машины было включение битов тегов в каждое слово для указания типов данных.
Также важным был микрокод для реализации некоторых часто используемых универсальных операций.
Например, в Lisp машине Symbolics 3600  микрокод для сложения одновременно выполнял сложение целого числа, сложение с плавающей запятой и проверку битов тега.
Если оба аргумента оказывались либо целыми числами, либо числами с плавающей запятой, то принимался соответствующий результат.
В противном случае был подан сигнал о ловушке, и выполнялся вход в процедуру конверсии.
Этот подход делает компилятор относительно простым, но тенденция в архитектуре уходит от высоко микрокодированных процессоров к более простым (RISC) процессорам.

**Программное обеспечение.** Мы можем устранить многие из этих проблем с помощью технологии, известной как *сбокра байт-кода.* Здесь мы переводим инструкции в вектор байтов, а затем интерпретируем байты с помощью интерпретатора байт-кода.
Это дает нам (почти) машину, которую мы хотим; это решает проблему расширения кода, но это может быть медленнее, чем компиляция в нативный кода(код хост машины), потому что интерпретатор байт-кода написан в программном обеспечении, а не аппаратном или микрокоде.

Каждый код операции представляет собой один байт (у нас есть менее 256 кодов операций, так что это будет работать).
Инструкции с аргументами принимают свои аргументы в следующих байтах потока команд.
Так, например, инструкция `CALL` занимает два байта: один для кода операции и один для количества аргументов.
Это означает, что мы установили ограничение в 256 аргументов для вызова функции.
Инструкция `LVAR` будет занимать три байта: один для кода операции, один для смещения кадра и один для смещения внутри кадра.
Опять же, мы установили 256 в качестве ограничения на уровень вложенности и переменные на кадр.
Эти ограничения кажутся достаточно высокими для любого кода, написанного человеком, но помните, что не только люди пишут код.
Вполне возможно, что какой-то сложный макрос может расшириться до чего-то с более чем 256 переменными, поэтому полная реализация будет иметь некоторый способ учета этого.
Инструкции `GVAR` и `CONST` должны ссылаться на произвольный объект; либо мы можем выделить достаточно байтов, чтобы поместить указатель на этот объект, либо мы можем добавить поле `constants` в структуру `fn` и следовать  инструкциям с однобайтовым индексом в этот вектор констант.
Этот последний подход более распространен.

Теперь мы можем обрабатывать ветви, изменяя счетчик программы на индекс в кодовом векторе.
(Ограничение функций до 256 байт кода кажется суровым; двухбайтовая метка позволяет использовать 65536 байт кода для каждой функции.) Таким образом, код более компактен, ветвление эффективно, а диспетчеризация может быть быстрой, потому что код операции-это маленькое целое число, и мы можем использовать таблицу ветвей, чтобы перейти к нужному фрагменту кода для каждой инструкции.

Другим источником неэффективности является реализация стека в виде списка и создание новых ячеек каждый раз, когда что-то добавляется в стек.
Альтернативой является реализация стека в виде вектора с указателем заполнения.
Таким образом, push не требует никакого консинга(создания списка), а только изменения указателя (и проверки на переполнение).
Однако эта проверка имеет смысл, поскольку позволяет обнаружить бесконечные циклы в коде пользователя.

Далее следует ассемблер, который генерирует последовательность инструкций (в виде вектора).
Это компромисс между байтовыми кодами и форматом языка ассемблера.
Во - первых, нам нужны некоторые функции доступа, чтобы добраться до частей инструкции:

```lisp
(defun opcode (instr) (if (label-p instr) :label (first instr)))
(defun args (instr) (if (listp instr) (rest instr)))
(defun arg1 (instr) (if (listp instr) (second instr)))
(defun arg2 (instr) (if (listp instr) (third instr)))
(defun arg3 (instr) (if (listp instr) (fourth instr)))

(defsetf arg1 (instr) (val) `(setf (second ,instr) ,val))
```

Теперь мы пишем ассемблер, который уже интегрирован в компилятор с хуком в `new-fn`.

```lisp
(defun assemble (fn)
  "Turn a list of instructions into a vector."
  (multiple-value-bind (length labels)
      (asm-first-pass (fn-code fn))
    (setf (fn-code fn)
          (asm-second-pass (fn-code fn)
                           length labels))
    fn))

(defun asm-first-pass (code)
  "Return the labels and the total code length."
  (let ((length 0)
        (labels nil))
    (dolist (instr code)
      (if (label-p instr)
          (push (cons instr length) labels)
          (incf length)))
    (values length labels)))

(defun asm-second-pass (code length labels)
  "Put code into code-vector, adjusting for labels."
  (let ((addr 0)
        (code-vector (make-array length)))
    (dolist (instr code)
      (unless (label-p instr)
        (if (is instr '(JUMP TJUMP FJUMP SAVE))
            (setf (arg1 instr)
                  (cdr (assoc (arg1 instr) labels))))
        (setf (aref code-vector addr) instr)
        (incf addr)))
    code-vector))
```

Если мы хотим иметь возможность смотреть на ассемблерный код, нам нужна новая функция печати:

```lisp
(defun show-fn (fn &optional (stream *standard-output*) (indent 2))
  "Print all the instructions in a function.
  If the argument is not a function, just princ it,
  but in a column at least 8 spaces wide."
  ;; This version handles code that has been assembled into a vector
  (if (not (fn-p fn))
      (format stream "~8a" fn)
      (progn
        (fresh-line)
        (dotimes (i (length (fn-code fn)))
          (let ((instr (elt (fn-code fn) i)))
            (if (label-p instr)
                (format stream "~a:" instr)
                (progn
                  (format stream "~VT~2d: " indent i)
                  (dolist (arg instr)
                    (show-fn arg stream (+ indent 8)))
                  (fresh-line))))))))

(defstruct ret-addr fn pc env)

(defun is (instr op)
  "True if instr's opcode is OP, or one of OP when OP is a list."
  (if (listp op)
      (member (opcode instr) op)
      (eq (opcode instr) op)))

(defun top (stack) (first stack))

(defun machine (f)
  "Run the abstract machine on the code for f."
  (let* ((code (fn-code f))
         (pc 0)
         (env nil)
         (stack nil)
         (n-args 0)
         (instr nil))
    (loop
       (setf instr (elt code pc))
       (incf pc)
       (case (opcode instr)

         ;; Variable/stack manipulation instructions:
         (LVAR   (push (elt (elt env (arg1 instr)) (arg2 instr))
                       stack))
         (LSET   (setf (elt (elt env (arg1 instr)) (arg2 instr))
                       (top stack)))
         (GVAR   (push (get (arg1 instr) 'global-val) stack))
         (GSET   (setf (get (arg1 instr) 'global-val) (top stack)))
         (POP    (pop stack))
         (CONST  (push (arg1 instr) stack))

         ;; Branching instructions:
         (JUMP   (setf pc (arg1 instr)))
         (FJUMP  (if (null (pop stack)) (setf pc (arg1 instr))))
         (TJUMP  (if (pop stack) (setf pc (arg1 instr))))

         ;; Function call/return instructions:
         (SAVE   (push (make-ret-addr :pc (arg1 instr)
                                      :fn f :env env)
                       stack))
         (RETURN ;; return value is top of stack; ret-addr is second
          (setf f (ret-addr-fn (second stack))
                code (fn-code f)
                env (ret-addr-env (second stack))
                pc (ret-addr-pc (second stack)))
          ;; Get rid of the ret-addr, but keep the value
          (setf stack (cons (first stack) (rest2 stack))))
         (CALLJ  (pop env)                 ; discard the top frame
                 (setf f  (pop stack)
                       code (fn-code f)
                       env (fn-env f)
                       pc 0
                       n-args (arg1 instr)))
         (ARGS   (assert (= n-args (arg1 instr)) ()
                         "Wrong number of arguments:~
                         ~d expected, ~d supplied"
                         (arg1 instr) n-args)
                 (push (make-array (arg1 instr)) env)
                 (loop for i from (- n-args 1) downto 0 do
                       (setf (elt (first env) i) (pop stack))))
         (ARGS.  (assert (>= n-args (arg1 instr)) ()
                         "Wrong number of arguments:~
                         ~d or more expected, ~d supplied"
                         (arg1 instr) n-args)
                 (push (make-array (+ 1 (arg1 instr))) env)
                 (loop repeat (- n-args (arg1 instr)) do
                       (push (pop stack) (elt (first env) (arg1 instr))))
                 (loop for i from (- (arg1 instr) 1) downto 0 do
                       (setf (elt (first env) i) (pop stack))))
         (FN     (push (make-fn :code (fn-code (arg1 instr))
                                :env env) stack))
         (PRIM   (push (apply (arg1 instr)
                              (loop with args = nil repeat n-args
                                    do (push (pop stack) args)
                                    finally (return args)))
                       stack))

         ;; Continuation instructions:
         (SET-CC (setf stack (top stack)))
         (CC     (push (make-fn
                         :env (list (vector stack))
                         :code '((ARGS 1) (LVAR 1 0 ";" stack) (SET-CC)
                                 (LVAR 0 0) (RETURN)))
                       stack))

         ;; Nullary operations:
         ((SCHEME-READ NEWLINE) ; *** fix, gat, 11/9/92
          (push (funcall (opcode instr)) stack))

         ;; Unary operations:
         ((CAR CDR CADR NOT LIST1 COMPILER DISPLAY WRITE RANDOM)
          (push (funcall (opcode instr) (pop stack)) stack))

         ;; Binary operations:
         ((+ - * / < > <= >= /= = CONS LIST2 NAME! EQ EQUAL EQL)
          (setf stack (cons (funcall (opcode instr) (second stack)
                                     (first stack))
                            (rest2 stack))))

         ;; Ternary operations:
         (LIST3
          (setf stack (cons (funcall (opcode instr) (third stack)
                                     (second stack) (first stack))
                            (rest3 stack))))

         ;; Constants:
         ((T NIL -1 0 1 2)
          (push (opcode instr) stack))

         ;; Other:
         ((HALT) (RETURN (top stack)))
         (otherwise (error "Unknown opcode: ~a" instr))))))

(defun init-scheme-comp ()
  "Initialize values (including call/cc) for the Scheme compiler."
  (set-global-var! 'exit
    (new-fn :name 'exit :args '(val) :code '((HALT))))
  (set-global-var! 'call/cc
    (new-fn :name 'call/cc :args '(f)
            :code '((ARGS 1) (CC) (LVAR 0 0 ";" f)
            (CALLJ 1)))) ; *** Bug fix, gat, 11/9/92
  (dolist (prim *primitive-fns*)
     (setf (get (prim-symbol prim) 'global-val)
           (new-fn :env nil :name (prim-symbol prim)
                   :code (seq (gen 'PRIM (prim-symbol prim))
                              (gen 'RETURN))))))
```

Вот верхний уровень Scheme.
Обратите внимание, что он написан на самой Scheme; мы компилируем определение цикла read-eval-print, [1](#fn0010) загружаем его в машину, а затем начинаем выполнять.
Существует также интерфейс для компиляции и выполнения единичного выражения `comp-go`.

```lisp
(defconstant scheme-top-level
  '(begin (define (scheme)
            (newline)
            (display "=> ")
            (write ((compiler (read))))
            (scheme))
          (scheme)))

(defun scheme ()
  "A compiled Scheme read-eval-print loop"
  (init-scheme-comp)
  (machine (compiler scheme-top-level)))

(defun comp-go (exp)
  "Compile and execute the expression."
  (machine (compiler `(exit ,exp))))
```

**Exercise  23.2 [m]** Эта реализация машины расточительна в своем представлении сред окружения.
Например, рассмотрим, что происходит в хвостово-рекурсивной функции.
Каждая инструкция `ARG` строит новый фрейм и помещает его в окружение.
Затем каждый `CALL` извлекает последний кадр из окружающей среды.
Таким образом, хотя стек не растет с хвостовыми рекурсивными вызовами, куча определенно растет.
В конце концов, нам придется собрать(убрать мусор) все эти неиспользуемые кадры (и ячейки cons, используемые для составления списков из них).
Как мы могли бы избежать или ограничить эту сборку мусора?

## 23.4 Подглядывающий(Peephole) Опримизатор 

В этом разделе мы исследуем простую технику, которая будет генерировать немного лучший код в тех случаях, когда компилятор дает неэффективные последовательности инструкций.
Идея состоит в том, чтобы посмотреть на короткие последовательности инструкций для заранее определенных шаблонов и заменить их эквивалентными, но более эффективными инструкциями.

В следующем примере `comp-if` уже произвел некоторую оптимизацию на уровне исходного кода, например устранил вызов `(f x)`.

```
> (comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x))
```

| []() |          |     |
|------|----------|-----|
| `0:` | `ARGS`   | `0` |
| 1:   | 1        |     |
| `2:` | `FJUMP`  | `6` |
| `3:` | `2`      |     |
| `4:` | `GSET`   | `X` |
| `5:` | `POP`    |     |
| `6:` | `GVAR`   | `X` |
| `7:` | `RETURN` |     |

Но сгенерированный код можно было бы сделать намного лучше.
Это можно было бы сделать с помощью дополнительных оптимизаций исходного уровня для преобразования выражения в `(set! x 2)'.
В качестве альтернативы это можно было бы также сделать, рассмотрев предыдущую последовательность инструкций и трансформировав локальные неэффективности.
Оптимизатор, представленный в этом разделе, способен генерировать следующий код:

```
> (comp-show '(begin (if (if t 1 (f x)) (set! x 2)) x))
```

| []() |          |     |
|------|----------|-----|
| `0:` | `ARGS`   | `0` |
| 1:   | 2        |     |
| `2:` | `GSET`   | `X` |
| `3:` | `RETURN` |     |

Функция `optimize` реализована как функция управляемая данными, которая просматривает код операции каждой инструкции и производит оптимизацию на основе последующих инструкций.
Чтобы быть более конкретным, `optimize` берет список инструкций языка ассемблера и просматривает каждую инструкцию по порядку, пытаясь применить оптимизацию.
Если какие-либо изменения вообще будут внесены, то `оптимизация` будет вызвана снова во всем списке команд, потому что дальнейшие изменения могут быть вызваны первым раундом изменений.

```lisp
(defun optimize (code)
  "Perform peephole optimization on assembly code."
  (let ((any-change nil))
    ;; Optimize each tail
    (loop for code-tail on code do
          (setf any-change (or (optimize-1 code-tail code)
                               any-change)))
    ;; If any changes were made, call optimize again
    (if any-change
        (optimize code)
        code)))
```

Функция `optimize-1` отвечает за каждую отдельную попытку оптимизации.
Ей передаются два аргумента: список инструкций, начинающихся с текущей и идущих до конца списка, и список всех инструкций.
Второй аргумент используется редко.
Вся идея подглядывающего(peephole) оптимизатора  состоит в том, что он должен смотреть только на несколько инструкций, следующих за текущей.
`optimize-1` управляется данными, основанными на коде операции первой инструкции.
Обратите внимание, что функции оптимизатора выполняют свою работу путем деструктивного изменения последовательности команд, а не путем сохранения и возврата новой последовательности.

```lisp
(defun optimize-1 (code all-code)
  "Perform peephole optimization on a tail of the assembly code.
  If a change is made, return true."
  ;; Data-driven by the opcode of the first instruction
  (let* ((instr (first code))
         (optimizer (get-optimizer (opcode instr))))
    (when optimizer
      (funcall optimizer instr code all-code))))
```

Нам нужна таблица, чтобы связать отдельные функции оптимизатора с кодами операций.
Поскольку коды операций включают в себя числа, а также символы, хэш-таблица `eql` является подходящим выбором:

```lisp
(let ((optimizers (make-hash-table :test #'eql)))

  (defun get-optimizer (opcode)
    "Get the assembly language optimizer for this opcode."
    (gethash opcode optimizers))

  (defun put-optimizer (opcode fn)
    "Store an assembly language optimizer for this opcode."
    (setf (gethash opcode optimizers) fn)))
```

Теперь мы могли бы построить таблицу с помощью `put-optimizer`, но стоит определить макрос, чтобы сделать это немного аккуратнее:

```lisp
(defmacro def-optimizer (opcodes args &body body)
  "Define assembly language optimizers for these opcodes."
  (assert (and (listp opcodes) (listp args) (= (length args) 3)))
  `(dolist (op ',opcodes)
     (put-optimizer op #'(lambda ,args .,body))))
```

Прежде чем показать пример функции оптимизатора, мы представим три вспомогательные функции.
`gen1` генерирует одну инструкцию, `target` находит кодовую последовательность, к которой ветвится команда перехода, а `next-instr` находит следующую фактическую инструкцию в последовательности, пропуская метки.

```lisp
(defun gen1 (&rest args) "Generate a single instruction" args)
(defun target (instr code) (second (member (arg1 instr) code)))
(defun next-instr (code) (find-if (complement #'label-p) code))
```

Вот шесть функций оптимизатора, которые реализуют несколько важных оптимизаций подглядывающего оптимизатора.

```lisp
(def-optimizer (:LABEL) (instr code all-code)
  ;; ... L ... => ... ... ;if no reference to L
  (when (not (find instr all-code :key #'arg1))
    (setf (first code) (second code)
          (rest code) (rest2 code))
    t))

(def-optimizer (GSET LSET) (instr code all-code)
  ;; ex: (begin (set! x y) (if x z))
  ;; (SET X) (POP) (VAR X) ==> (SET X)
  (when (and (is (second code) 'POP)
             (is (third code) '(GVAR LVAR))
             (eq (arg1 instr) (arg1 (third code))))
    (setf (rest code) (nthcdr 3 code))
    t))

(def-optimizer (JUMP CALL CALLJ RETURN) (instr code all-code)
  ;; (JUMP L1) ...dead code... L2 ==> (JUMP L1) L2
  (setf (rest code) (member-if #'label-p (rest code)))
  ;; (JUMP L1) ... L1 (JUMP L2) ==> (JUMP L2)  ... L1 (JUMP L2)
  (when (and (is instr 'JUMP)
             (is (target instr code) '(JUMP RETURN))
    (setf (first code) (copy-list (target instr code)))
    t)))

(def-optimizer (TJUMP FJUMP) (instr code all-code)
  ;; (FJUMP L1) ... L1 (JUMP L2) ==> (FJUMP L2) ... L1 (JUMP L2)
  (when (is (target instr code) 'JUMP)
    (setf (second instr) (arg1 (target instr code)))
    t))

(def-optimizer (T -1 0 1 2) (instr code all-code)
  (case (opcode (second code))
    (NOT ;; (T) (NOT) ==> NIL
     (setf (first code) (gen1 'NIL)
           (rest code) (rest2 code))
     t)
    (FJUMP ;; (T) (FJUMP L) ... => ...
     (setf (first code) (third code)
           (rest code) (rest3 code))
     t)
    (TJUMP ;; (T) (TJUMP L) ... => (JUMP L) ...
     (setf (first code) (gen1 'JUMP (arg1 (next-instr code))))
     t)))

(def-optimizer (NIL) (instr code all-code)
  (case (opcode (second code))
    (NOT ;; (NIL) (NOT) ==> T
     (setf (first code) (gen1 'T)
           (rest code) (rest2 code))
     t)
    (TJUMP ;; (NIL) (TJUMP L) ... => ...
     (setf (first code) (third code)
             (rest code) (rest3 code))
     t)
    (FJUMP ;; (NIL) (FJUMP L) ==> (JUMP L)
     (setf (first code) (gen1 'JUMP (arg1 (next-instr code))))
     t)))
```

## 23.5 Языки с отличными лексическими соглашениями

В этой главе показано, как вычислять язык с Лисп-подобным синтаксисом, написав цикл read-eval-print, где нужно заменить только `eval`.
В этом разделе мы увидим, как сделать часть `read` немного более общей.
Мы все еще читаем Лисп-подобный синтаксис, но лексические соглашения могут немного отличаться.

Функция Lisp `read` управляется объектом, называемым *readtable*, который хранится в специальной переменной `*readtable*.` Эта таблица связывает некоторые действия с каждым из возможных символьных знаков, которые могут быть прочитаны.
Например, запись в таблице чтения(readtable) для символа `#\(`,  будет содержать указания для чтения списка.
Запись для `#\;` будет содержать указания игнорировать каждый символьный знак до конца строки.

Поскольку readtable хранится в специальной переменной, можно полностью изменить способ чтения, просто динамически повторно привязав эту переменную.

Новая функция `scheme-read` временно изменяет таблицу чтения на новую, Scheme readtable.
Она также принимает необязательный аргумент, поток для чтения, и возвращает специальный маркер в конце файла.
Это можно проверить с помощью предиката `eof-object?`.
Обратите внимание, что после установки `scheme-read` в качестве  Scheme  значения `symbol-read` нам больше ничего не нужно делать - `scheme-read` всегда будет вызываться при необходимости (верхним уровнем Scheme и любой пользовательской программой Scheme).

```lisp
(defconstant eof "EoF")
(defun eof-object? (x) (eq x eof))
(defvar *scheme-readtable* (copy-readtable))

(defun scheme-read (&optional (stream *standard-input*))
  (let ((*readtable* *scheme-readtable*))
    (read stream nil eof)))
```

Смысл наличия специальной константы `eof` заключается в том, что она не может быть использована.
Пользователь не может ввести последовательность знаков, которая будет читаться как что-то от `eq` до `eof`.
В Common Lisp, но не в Scheme, есть escape механизм, который делает `eof` поддающимся подделке.
Пользователь может ввести `#.eof`, чтобы получить эффект конца файла.
Это похоже на соглашение `^D` в системах UNIX, и это может быть довольно удобно.

До сих пор readtable  Scheme является просто копией стандартной readtable.
Следующим шагом в реализации `scheme-read` является изменение `*scheme-readtable*`, добавление макросов чтения для любых необходимых символьных знаков.
Здесь мы определяем макросы для `#t` и `#f` (истинных и ложных значений), для `#d`(десятичные числа) и для обратной кавычки макроса чтения (так называемый quasiquote в Scheme).
Обратите внимание, что знаки обратной кавычки и запятой определяются как макросы чтения, но `@` в `,@` обрабатывается чтением следующего символьного знака, а не макросом чтения для `@`

```lisp
(set-dispatch-macro-character #\# #\t
  #'(lambda (&rest ignore) t)
  *scheme-readtable*)

(set-dispatch-macro-character #\# #\f
  #'(lambda (&rest ignore) nil)
  *scheme-readtable*)

(set-dispatch-macro-character #\# #\d
  ;; In both Common Lisp and Scheme,
  ;; #x, #o and #b are hexidecimal, octal, and binary,
  ;; e.g. #xff = #o377 = #b11111111 = 255
  ;; In Scheme only, #d255 is decimal 255.
  #'(lambda (stream &rest ignore)
      (let ((*read-base* 10)) (scheme-read stream)))
  *scheme-readtable*)

(set-macro-character #\`
  #'(lambda (s ignore) (list 'quasiquote (scheme-read s)))
  nil *scheme-readtable*)

(set-macro-character #\,
   #'(lambda (stream ignore)
       (let ((ch (read-char stream)))
         (if (char= ch #\@)
             (list 'unquote-splicing (read stream))
             (progn (unread-char ch stream)
                    (list 'unquote (read stream))))))
   nil *scheme-readtable*)
```

Наконец, мы устанавливаем  `scheme-read` и `eof-object?` как примитивы:

```lisp
(defparameter *primitive-fns*
  '((+ 2 + true) (- 2 - true) (* 2 * true) (/ 2 / true)
    (< 2 <) (> 2 >) (<= 2 <=) (>= 2 >=) (/= 2 /=) (= 2 =)
    (eq? 2 eq) (equal? 2 equal) (eqv? 2 eql)
    (not 1 not) (null? 1 not)
    (car 1 car) (cdr 1 cdr)  (cadr 1 cadr) (cons 2 cons true)
    (list 1 list1 true) (list 2 list2 true) (list 3 list3 true)
    (read 0 scheme-read nil t) (eof-object? 1 eof-object?) ;***
    (write 1 write nil t) (display 1 display nil t)
    (newline 0 newline nil t) (compiler 1 compiler t)
    (name! 2 name! true t) (random 1 random true nil)))
```

Здесь мы тестируем `scheme-read`.
Знаки, выделенные курсивом, были напечатаны в ответ на `scheme-read`.

```lisp
> (scheme-read) #*t*
T
> (scheme-read) #f
NIL
> (scheme-read) *'(a,b,@cd)*
(QUASIQUOTE (A (UNQUOTE B) (UNQUOTE-SPLICING C) D))
```

Последний шаг состоит в том, чтобы сделать quasiquote макрокомандой, которая расширяется в надлежащую последовательность вызовов `cons`, `list` и `append`.
Внимательный читатель будет отслеживать разницу между формой, возвращаемой `scheme-read` (нечто, начинающееся с `quasiquote`), расширением этой формы с помощью макроса Scheme `quasiquote` (который реализуется с помощью функции Common Lisp `quasi-q`) и окончательного вычисления расширения.
В среде, где `b` привязано к числу 2, а `c` привязано к списку `(c1 c2)`, мы могли бы иметь:

| []()       |                                                       |
|------------|-------------------------------------------------------|
| Typed:     | `'(a ,b ,@c d)`                                       |
| Read:      | `(quasiquote (a (unquote b) (unquote-splicing c) d))` |
| Expanded:  | `(cons 'a (cons b (append c '(d))))`                  |
| Evaluated: | `(a 2 c1 c2 d)`                                       |

Реализация макроса `quasiquote` очень похожа на макрокоманду, приведенную в книге Charniak et al.'s `Программирование искусственного интеллекта`. Я добавил поддержку векторов.
В `comb-quasiquote` я добавляю трюк с повторным использованием старой cons-ячейки `x` вместо создания ячейки списка(cons) для `left` и `right`, когда это возможно.
Однако реализация по-прежнему тратит впустую cons-ячейки - более эффективная версия будет передавать обратно несколько значений, а не использовать `quote` в списке, только чтобы затем снова удалить его.

```lisp
(setf (scheme-macro 'quasiquote) 'quasi-q)

(defun quasi-q (x)
  "Expand a quasiquote form into append, list, and cons calls."
  (cond
    ((vectorp x)
     (list 'apply 'vector (quasi-q (coerce x 'list))))
    ((atom x)
     (if (constantp x) x (list 'quote x)))
    ((starts-with x 'unquote)
     (assert (and (rest x) (null (rest2 x))))
     (second x))
    ((starts-with x 'quasiquote)
     (assert (and (rest x) (null (rest2 x))))
     (quasi-q (quasi-q (second x))))
    ((starts-with (first x) 'unquote-splicing)
     (if (null (rest x))
         (second (first x))
         (list 'append (second (first x)) (quasi-q (rest x)))))
    (t (combine-quasiquote (quasi-q (car x))
                           (quasi-q (cdr x))
                           x))))

(defun combine-quasiquote (left right x)
  "Combine left and right (car and cdr), possibly re-using x."
  (cond ((and (constantp left) (constantp right))
         (if (and (eql (eval left) (first x))
                  (eql (eval right) (rest x)))
             (list 'quote x)
             (list 'quote (cons (eval left) (eval right)))))
        ((null right) (list 'list left))
        ((starts-with right 'list)
         (list* 'list left (rest right)))
        (t (list 'cons left right))))
```

На самом деле, есть большая проблема с макросом `quasiquote`, или, точнее, во всем подходе к макрорасширению, основанному на текстовой подстановке.
Предположим, нам нужна функция, которая работала бы так:

```lisp
(extrema '(3 1 10 5 20 2))
((max 20) (min 1))
```

Мы могли бы написать функцию Scheme:

```lisp
(define (extrema list)
```

`      ;; Given a list of numbers.
return an a-list`

```lisp
      ;; with max and min values
      '((max ,(apply max list)) (min ,(apply min list))))
```

После расширения quasiquote определение `extrema` будет таким:

```lisp
(define extrema
      (lambda (list)
          (list (list 'max (apply max list))
                      (list 'min (apply min list)))))
```

Проблема в том, что `list` является аргументом функции `extrema`, и этот аргумент затеняет глобальное определение `list` как функции.
Таким образом, функция выйдет из строя.
Один из способов обойти эту дилемму - сделать так, чтобы макрорасширение использовало глобальное значение `list`, а не сам символ `list`.
Другими словами, замените `'list'` в `quasi-q` на (` get-global-var 'list`).
Тогда расширение можно использовать даже в среде, где `list` привязан локально.
Однако следует быть осторожным: если будет предпринята эта тактика, то нужно изменить `comp-funcall`, чтобы распознавать константы функций и делать правильные вещи в отношении примитивов.

Именно такие проблемы заставили разработчиков Scheme признать, что они не знают, как лучше всего определять макросы, поэтому в Scheme нет стандартного механизма определения макросов.
Такие проблемы редко возникают в Common Lisp, потому что функции и переменные имеют разные пространства имен и потому что определения локальных функций (с `flet` или` labels`) широко не используются.
Те, кто действительно определяет локальные функции, обычно не используют уже установленные имена, такие как `list` и `append`.

## 23.6 История и Ссылки

Guy Steele's 1978 MIT master's thesis on the language Scheme, rewritten as Steele 1983, describes an innovative and influential compiler for Scheme, called RABBIT.
[2](#fn0015) A good article on an "industrial-strength" Scheme compiler based on this approach is described in [Kranz et al.'s 1986](B9780080571157500285.xhtml#bb0675) paper on ORBIT, the compiler for the T dialect of Scheme.

Abelson and Sussman's *Structure and Interpretation of Computer Programs* (1985) contains an excellent chapter on compilation, using slightly different techniques and compiling into a somewhat more confusing machine language.
Another good text is [John Allen's *Anatomy of Lisp* (1978)](B9780080571157500285.xhtml#bb0040).
It presents a very clear, simple compiler, although it is for an older, dynamically scoped dialect of Lisp and it does not address tail-recursion or `call/cc`.

The peephole optimizer described here is based on the one in [Masinter and Deutsch 1980](B9780080571157500285.xhtml#bb0780).

## 23.7 Упражнения

**Exercise  23.3 [h]** Scheme's syntax for numbers is slightly different from Common Lisp's.
In particular, complex numbers are written like `3+4i` rather than `#c(3 4)`.
How could you make `scheme-read` account for this?

**Exercise  23.4 [m]** Is it possible to make the core Scheme language even smaller, by eliminating any of the five special forms `(quote, begin, set!, if, lambda)` and replacing them with macros?

**Exercise  23.5 [m]** Add the ability to recognize internal defines (see [page 779](B9780080571157500224.xhtml#p779)).

**Exercise  23.6 [h]** In `comp-if` we included a special case for `(if t x y)` and `(if nil x y)`.
But there are other cases where we know the value of the predicate.
For example, `(if (*a b) x y)` can also reduce to `x`.
Arrange for these optimizations to be made.
Note the `prim-always` field of the `prim structure` has been provided for this purpose.

**Exercise  23.7 [m]** Consider the following version of the quicksort algorithm for sorting a vector:

```lisp
(define (sort-vector vector test)
      (define (sort lo hi)
              (if (>= lo hi)
                        vector
                        (let ((pivot (partition vector lo hi test)))
                                (sort lo pivot)
                        (sort (+ pivot 1) hi))))
      (sort 0 (- (vector-length vector 1))))
```

Here the function `partition` takes a vector, two indices into the vector, and a comparison function, `test`.
It modifies the vector and returns an index, `pivot`, such that all elements of the vector below `pivot` are less than all elements at `pivot` or above.

It is well known that quicksort takes time proportional to *n* log *n* to sort a vector of *n* elements, if the pivots are chosen well.
With poor pivot choices, it can take time proportional to *n*2.

The question is, what is the space required by quicksort?
Besides the vector itself, how much additional storage must be temporarily allocated to sort a vector?

Now consider the following modified version of quicksort.
What time and space complexity does it have?

```lisp
(define (sort-vector vector test)
      (define (sort lo hi)
          (if (>= lo hi)
                  vector
                  (let ((pivot (partition vector lo hi)))
                        (if (> (- hi pivot) (- pivot lo))
                                  (begin (sort lo pivot)
                                                      (sort (+ pivot 1) hi))
                                  (begin (sort (+ pivot 1) hi)
                                                      (sort lo pivot))))))
      (sort 0 (- (vector-length vector 1))))
```

The next three exercises describe extensions that are not part of the Scheme standard.

**Exercise  23.8 [h]** The set!
special form is defined only when its first argument is a symbol.
Extend `set!` to work like `setf` when the first argument is a list.
That is, `(set!
(car x) y)` should expand into something like `((setter car) y x)`, where `(setter car)` evaluates to the primitive procedure `set-car!`.
You will need to add some new primitive functions, and you should also provide a way for the user to define new `set!` procedures.
One way to do that would be with a `setter` function for `set!`, for example:

`(set!
(setter third)`

`            (lambda (val list) (set-car!
(cdr (cdr list)) val)))`

**Exercise  23.9 [m]** It is a curious asymmetry of Scheme that there is a special notation for lambda expressions within `define` expressions, but not within `let`.
Thus, we see the following:

`(define square (lambda (x) (* x x)))`*;is the same as*

```lisp
(define (square x) (* x x))
```

`(let ((square (lambda (x) (* x x)))) ...) ;`*is not the same as*

`(let (((square x) (* x x))) ...) ;`*                          <= illegal!*

Do you think this last expression should be legal?
If so, modify the macros for `let, let*`, and `letrec` to allow the new syntax.
If not, explain why it should not be included in the language.

**Exercise  23.10 [m]** Scheme does not define `funcall`, because the normal function-call syntax does the work of funcall.
This suggests two problems.
(1) Is it possible to define `funcall` in Scheme?
Show a definition or explain why there can't be one.
Would you ever have reason to use `funcall` in a Scheme program?
(2) Scheme does define `apply`, as there is no syntax for an application.
One might want to extend the syntax to make `(+ . numbers)` equivalent to `(apply + numbers)`.
Would this bea good idea?

**Exercise  23.11 [d]** Write a compiler that translates Scheme to Common Lisp.
This will involve changing the names of some procedures and special forms, figuring out a way to map Scheme's single name space into Common Lisp's distinct function and variable name spaces, and dealing with Scheme's continuations.
One possibility is to translate a `call/cc` into a `catch` and `throw`, and disallow dynamic continuations.

## 23.8 Ответы

**Answer 23.2** We can save frames by making a resource for frames, as was done on page 337.
Unfortunately, we can't just use the def resource macro as is, because we need a separate resource for each size frame.
Thus, a two-dimensional array or a vector of vectors is necessary.
Furthermore, one must be careful in determining when a frame is no longer needed, and when it has been saved and may be used again.
Some compilers will generate a special calling sequence for a tail-recursive call where the environment can be used as is, without discarding and then creating a new frame for the arguments.
Some compilers have varied and advanced representations for environments.
An environment may never be represented explicitly as a list of frames; instead it may be represented implicitly as a series of values in registers.

**Answer 23.3** We could read in Scheme expressions as before, and then convert any symbols that looked like complex numbers into numbers.
The following routines do this without consing.

```lisp
(defun scheme-read (&optional (stream *standard-input*))
  (let ((*readtable* *scheme-readtable*))
    (convert-numbers (read stream nil eof))))

(defun convert-numbers (x)
  "Replace symbols that look like Scheme numbers with their values."
  ;; Don't copy structure, make changes in place.
  (typecase x
    (cons   (setf (car x) (convert-numbers (car x)))
            (setf (cdr x) (convert-numbers (cdr x)))
        x) ; *** Bug fix, gat, 11/9/92
    (symbol (or (convert-number x) x))
    (vector (dotimes (i (length x))
              (setf (aref x i) (convert-numbers (aref x i))))
        x) ; *** Bug fix, gat, 11/9/92
    (t x)))

(defun convert-number (symbol)
  "If str looks like a complex number, return the number."
  (let* ((str (symbol-name symbol))
         (pos (position-if #'sign-p str))
         (end (- (length str) 1)))
    (when (and pos (char-equal (char str end) #\i))
      (let ((re (read-from-string str nil nil :start 0 :end pos))
            (im (read-from-string str nil nil :start pos :end end)))
        (when (and (numberp re) (numberp im))
          (complex re im))))))

(defun sign-p (char) (find char "+-"))
```

Actually, that's not quite good enough, because a Scheme complex number can have multiple signs in it, as in `3.
4e- 5+6.
7e+8i`, and it need not have two numbers, as in `3i` or `4+i` or just `+  i`.
The other problem is that complex numbers can only have a lowercase `i`, but read does not distinguish between the symbols `3+4i` and `3+4I`.

**Answer 23.4** Yes, it is possible to implement `begin` as a macro:

```lisp
(setf (scheme-macro 'begin)
                #'(lambda (&rest exps) '((lambda () .,exps))))
```

With some work we could also eliminate quote.
Instead of `'x`, we could use `(string->symbol "X" )`, and instead of `'(1 2)`, wecoulduse something like `(list 1 2)`.
The problem is in knowing when to reuse the same list.
Consider:

```lisp
=> (define (one-two) '(1 2))
ONE-TWO
```

`=> (eq?
(one-two) (one-two))`

```lisp
T
```

`=> (eq?
'(1 2) '(1 2))`

```lisp
NIL
```

A clever memoized macro for quote could handle this, but it would be less efficient than having `quote` as a special form.
In short, what's the point?

It is also (nearly) possible to replace `if` with alternate code.
The idea is to replace:

`(if`*test then-part else-part*)

with

(*test*`(delay`*then-part*) `(delay`*else-part*))

Now if we are assured that any *test* returns either `#t` or `#f`, then we can make the following definitions:

```lisp
(define #t (lambda (then-part else-part) (force then-part)))
(define #f (lambda (then-part else-part) (force else-part)))
```

The only problem with this is that any value, not just `#t`, counts as true.

This seems to be a common phenomenon in Scheme compilers: translating everything into a few very general constructs, and then recognizing special cases of these constructs and compiling them specially.
This has the disadvantage (compared to explicit use of many special forms) that compilation may be slower, because all macros have to be expanded first, and then special cases have to be recognized.
It has the advantage that the optimizations will be applied even when the user did not have a special construct in mind.
Common Lisp attempts to get the advantages of both by allowing implementations to play loose with what they implement as macros and as special forms.

**Answer 23.6** We define the predicate `always` and install it in two places in `comp-if` :

```lisp
(defun always (pred env)
      "Does predicate always evaluate to true or false?"
      (cond ((eq pred t) 'true)
                        ((eq pred nil) 'false)
                        ((symbolp pred) nil)
                        ((atom pred) 'true)
                        ((scheme-macro (first pred))
                          (always (scheme-macro-expand pred) env))
                        ((case (first pred)
                                (QUOTE (if (null (second pred)) 'false 'true))
                                (BEGIN (if (null (rest pred)) 'false
                                                                    (always (last1 pred) env)))
```

`                                (SET!
(always (third pred) env))`

```lisp
        (IF (let ((test (always (second pred)) env)
            (then (always (third pred)) env)
            (else (always (fourth pred)) env))
                                (cond ((eq test 'true) then)
                                                                    ((eq test 'false) else)
                                                                    ((eq then else) then))))
        (LAMBDA 'true)
        (t (let ((prim (primitive-p (first pred) env
                                              (length (rest pred)))))
                      (if prim (prim-always prim))))))))
```

`(defun comp-if (pred then else env val?
more?)`

```lisp
      (case (always pred env)
          (true ; (if nil x y) = => y ; ***
```

`              (comp then env val?
more?)) ; ***`

```lisp
          (false ; (if t x y) = => x ; ***
```

`              (comp else env val?
more?)) ; ***`

```lisp
          (otherwise
              (let ((pcode (comp pred env t t))
```

`                            (tcode (comp then env val?
more?))`

`                            (ecode (comp else env val?
more?)))`

```lisp
              (cond
                  ((and (listp pred) ; (if (not p) x y) ==> (if p y x)
                                    (length=1 (rest pred))
                                    (primitive-p (first pred) env 1)
                                    (eq (prim-opcode (primitive-p (first pred) env 1))
                                                  'not))
```

`                  (comp-if (second pred) else then env val?
more?))`

```lisp
                ((equal tcode ecode) ; (if p x x) ==> (begin p x)
                  (seq (comp pred env nil t) ecode))
                ((null tcode) ; (if p nil y) ==> p (TJUMP L2) y L2:
                  (let ((L2 (gen-label)))
                          (seq pcode (gen 'TJUMP L2) ecode (list L2)
```

`                  (unless more?
(gen 'RETURN)))))`

```lisp
            ((null ecode) ; (if p x) ==> p (FJUMP L1) x L1:
            (let ((L1 (gen-label)))
                    (seq pcode (gen TJUMP L1) tcode (list L1)
```

`                                  (unless more?
(gen 'RETURN)))))`

```lisp
            (t                                                             ; (if p x y) ==> p (FJUMP L1) x L1: y
                                                                              ; or p (FJUMP L1) x (JUMP L2) L1: y L2:
            (let ((L1 (gen-label))
```

`                          (L2 (if more?
(gen-label))))`

```lisp
                (seq pcode (gen 'FJUMP L1) tcode
```

`                              (if more?
(gen 'JUMP L2))`

`                              (list L1) ecode (if more?
(list L2))))))))))`

Development note: originally, I had coded `always` as a predicate that took a Boolean value as input and returned true if the expression always had that value.
Thus, you had to ask first if the predicate was always true, and then if it was always false.
Then I realized this was duplicating much effort, and that the duplication was exponential, not just linear: for a triply-nested conditional I would have to do eight times the work, not twice the work.
Thus I switched to the above formulation, where `always` is a three-valued function, returning `true`, `false`, or `nil` for none-of-the-above.
But to demonstrate that the right solution doesn't always appear the first time, I give my original definition as well:

```lisp
(defun always (boolean pred env)
      "Does predicate always evaluate to boolean in env?"
      (if (atom pred)
          (and (constantp pred) (equiv boolean pred))
          (case (first pred)
                (QUOTE (equiv boolean pred))
                (BEGIN (if (null (rest pred)) (equiv boolean nil)
                                                    (always boolean (last1 pred) env)))
```

`                (SET!
(always boolean (third pred) env))`

```lisp
                (IF (or (and (always t (second pred) env)
                                                      (always boolean (third pred) env))
                                          (and (always nil (second pred) env)
                                                      (always boolean (fourth pred) env))
                                          (and (always boolean (third pred) env)
                                                      (always boolean (fourth pred) env))))
                (LAMBDA (equiv boolean t))
                (t (let ((prim (primitive-p (first pred) env
                                                                                          (length (rest pred)))))
                        (and prim
                                        (eq (prim-always prim)
                                                    (if boolean 'true 'false))))))))
(defun equiv (x y) "Boolean equivalence" (eq (not x) (not y)))
```

**Answer 23.7** The original version requires *O*(*n*) stack space for poorly chosen pivots.
Assuming a properly tail-recursive compiler, the modified version will never require more than *O*(log *n*) space, because at each step at least half of the vector is being sorted tail-recursively.

**Answer 23.10** (1) `(defun (funcall fn . args) (apply fn args))` (2) Suppose you changed the piece of code `(+ . numbers)` to `(+ . (map sqrt numbers))`.
The latter is the same expression as (+ `map sqrt numbers),` which is not the intended resuit at all.
So there would be an arbitrary restriction: the last argument in an apply form would have to be an atom.
This kind of restriction goes against the grain of Scheme.

----------------------

[1](#xfn0010) Strictly speaking, this is a read-compile-funcall-write loop.
!!!(p) {:.ftnote1}

[2](#xfn0015) At the time, the MacLisp compiler dealt with something called "lisp assembly code" or LAP.
The function to input LAP was called `lapin`.
Those who know French will get the pun.
!!!(p) {:.ftnote1}