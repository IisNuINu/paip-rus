#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter12.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-08 11:00+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter12.md:3
msgid ""
"# Chapter 12\n"
"## Compiling Logic Programs"
msgstr ""
"# Глава 12\n"
"## Компиляция Логических Программ"

#: in/chapter12.md:8
msgid ""
"The end of [chapter 11](B978008057115750011X.xhtml) introduced a new, more "
"efficient representation for logic variables.\n"
"It would be reasonable to build a new version of the Prolog interpreter "
"incorporating this representation.\n"
"However, [chapter 9](B9780080571157500091.xhtml) has taught us that "
"compilers run faster than interpreters and are not that much harder to "
"build.\n"
"Thus, this chapter will present a Prolog compiler that translates from "
"Prolog to Lisp."
msgstr ""
"В конце [главы 11](B978008057115750011X.xhtml) было представлено новое, "
"более эффективное представление для логических переменных.\n"
"Было бы разумно построить новую версию интерпретатора Пролога, включающую "
"это представление.\n"
"Однако [глава 9](B9780080571157500091.xhtml) научила нас, что компиляторы "
"работают быстрее, чем интерпретаторы, и их не так уж сложно построить.\n"
"Таким образом, в этой главе будет представлен компилятор Пролога, который "
"преобразует Пролог в Лисп."

#: in/chapter12.md:12
msgid ""
"Each Prolog predicate will be translated into a Lisp function, and we will "
"adopt the convention that a predicate called with a different number of "
"arguments is a different predicate.\n"
"If the symbol `p` can be called with either one or two arguments, we will "
"need two Lisp functions to implement the two predicates.\n"
"Following Prolog tradition, these will be called `p/1` and `p/2`."
msgstr ""
"Каждый предикат Пролога будет преобразован в функцию Лиспа, и мы примем "
"соглашение, согласно которому предикат, вызываемый с другим числом "
"аргументов, является другим(отличающимся от предыдущего) предикатом.\n"
"Если символ `p` может быть вызван с одним или двумя аргументами, нам "
"понадобятся две функции Лиспа для реализации двух предикатов.\n"
"Следуя традиции Пролога, они будут называться `p/1` и `p/2`."

#: in/chapter12.md:17
msgid ""
"The next step is to decide what the generated Lisp code should look like.\n"
"It must unify the head of each clause against the arguments, and if the "
"unification succeeds, it must call the predicates in the body.\n"
"The difficult part is that the choice points have to be remembered.\n"
"If a call to a predicate in the first clause fails, we must be able to "
"return to the second clause and try again."
msgstr ""
"Следующий шаг - решить, как должен выглядеть сгенерированный код Lisp.\n"
"Он должен объединить/унифицировать заголовок каждого предложения напротив "
"аргументов, и, если объединение/унификация завершится успешно, он должен "
"вызвать предикаты в теле.\n"
"Трудность состоит в том, что нужно помнить о точках выбора.\n"
"Если вызов предиката в первом предложении завершился неудачно, мы должны "
"иметь возможность вернуться ко второму предложению и повторить попытку."

#: in/chapter12.md:25
msgid ""
"This can be done by passing in a *success continuation* as an extra argument "
"to every predicate.\n"
"This continuation represents the goals that remain unsolved, the `other-"
"goals` argument of `prove`.\n"
"For each clause in the predicate, if all the goals in a clause succeed, then "
"we should call the success continuation.\n"
"If a goal fails, we don't do anything special; we just go on to the next "
"clause.\n"
"There is one complication: after failing we have to undo any bindings made "
"by `unify!`.\n"
"Consider an example.\n"
"The clauses"
msgstr ""
"Это можно сделать, передав *успешное продолжение* в качестве дополнительного "
"аргумента каждому предикату.\n"
"Это продолжение представляет собой цели, которые остаются нерешенными, "
"аргумент функции `prove` `other-goals`(другие цели).\n"
"Для каждого предложения в предикате, если все цели в предложении выполнены, "
"мы должны вызвать успешное продолжение.\n"
"Если цель не удается/не достигается, мы не делаем ничего особенного; мы "
"просто переходим к следующему предложению.\n"
"Есть одно осложнение: после неудачи мы должны отменить все привязки, "
"сделанные `unify!`.\n"
"Рассмотрим пример.\n"
"Предложения"

#: in/chapter12.md:31
msgid ""
"```lisp\n"
"(<- (likes Robin cats))\n"
"(<- (likes Sandy ?x) (likes ?x cats))\n"
"(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))\n"
"```"
msgstr ""

#: in/chapter12.md:33
msgid "could be compiled into this:"
msgstr "можно скомпилировать в это:"

#: in/chapter12.md:38
msgid ""
"```lisp\n"
"(defun likes/2 (?arg1 ?arg2 cont)\n"
"  ;; First clause:\n"
"```"
msgstr ""

#: in/chapter12.md:42
msgid ""
"`  (if (and (unify!\n"
"?arg1 'Robin) (unify!\n"
"?arg2 'cats))`"
msgstr ""

#: in/chapter12.md:48
msgid ""
"```lisp\n"
"      (funcall cont))\n"
"  (undo-bindings)\n"
"  ;; Second clause:\n"
"```"
msgstr ""

#: in/chapter12.md:51
msgid ""
"`  (if (unify!\n"
"?argl 'Sandy)`"
msgstr ""

#: in/chapter12.md:57
msgid ""
"```lisp\n"
"      (likes/2 ?arg2 'cats cont))\n"
"  (undo-bindings)\n"
"  ;; Third clause:\n"
"```"
msgstr ""

#: in/chapter12.md:60
msgid ""
"`  (if (unify!\n"
"?argl 'Kim)`"
msgstr ""

#: in/chapter12.md:65
msgid ""
"```lisp\n"
"      (likes/2 ?arg2 'Lee\n"
"          #'(lambda () (likes/2 ?arg2 'Kim cont))))))\n"
"```"
msgstr ""

#: in/chapter12.md:73
msgid ""
"In the first clause, we just check the two arguments and, if the "
"unifications succeed, call the continuation directly, because the first "
"clause has no body.\n"
"In the second clause, `likes/2` is called recursively, to see if `?arg2` "
"likes `cats`.\n"
"If this succeeds, then the original goal succeeds, and the continuation "
"`cont` is called.\n"
"In the third clause, we have to call `likes/2` recursively again, this time "
"requesting that it check if `?arg2` likes `Lee`.\n"
"If this check succeeds, then the continuation will be called.\n"
"In this case, the continuation involves another call to `likes/2`, to check "
"if `?arg2` likes `Kim`.\n"
"If this succeeds, then the original continuation, `cont`, will finally be "
"called."
msgstr ""
"В первом предложении мы просто проверяем два аргумента и, если унификации "
"успешны, вызываем продолжение напрямую, потому что первое предложение не "
"имеет тела.\n"
"Во втором предложении рекурсивно вызывается `likes/2`, чтобы увидеть, "
"нравятся ли `?arg2` кошки(`cats`).\n"
"Если это удалось, то исходная цель достигнута, и вызывается продолжение "
"`cont`.\n"
"В третьем предложении мы должны снова рекурсивно вызвать `likes/2`, на этот "
"раз попросив проверить, нравится ли `?arg2` `Lee`.\n"
"Если эта проверка прошла успешно, будет вызвано продолжение.\n"
"В этом случае продолжение включает в себя еще один вызов функции `likes/2`, "
"чтобы проверить, нравится ли `?аrg2` `Ким`.\n"
"Если это удастся, то, наконец, будет вызвано исходное продолжение, `cont`."

#: in/chapter12.md:76
msgid ""
"Recall that in the Prolog interpreter, we had to append the list of pending "
"goals, `other-goals`, to the goals in the body of the clause.\n"
"In the compiler, there is no need to do an `append.` Instead, the "
"continuation cont represents the other-goals, and the body of the clause is "
"represented by explicit calls to functions."
msgstr ""
"Напомним, что в интерпретаторе Пролога мы должны были добавить список "
"ожидающих целей, `other-goals`, к целям в теле предложения.\n"
"В компиляторе нет необходимости выполнять `append`. Вместо этого продолжение "
"cont представляет `other-goals`(другие цели), а тело предложения "
"представлено явными вызовами функций."

#: in/chapter12.md:80
msgid ""
"Note that the code for `likes/2` given before has eliminated some "
"unnecessary calls to `unify!`.\n"
"The most obvious implementation would have one call to `unify!` for each "
"argument.\n"
"Thus, for the second clause, we would have the code:"
msgstr ""
"Обратите внимание, что приведенный ранее код для `likes/2` устраняет "
"некоторые ненужные вызовы `unify!`.\n"
"Самая очевидная реализация будет иметь один вызов `unify!` для каждого "
"аргумента.\n"
"Таким образом, для второго предложения у нас будет код:"

#: in/chapter12.md:84
msgid ""
"`(if (and (unify!\n"
"?argl 'Sandy) (unify!\n"
"?arg2 ?x))`"
msgstr ""

#: in/chapter12.md:88
msgid ""
"```lisp\n"
"  (likes/2 ?x 'cats cont))\n"
"```"
msgstr ""

#: in/chapter12.md:90
msgid "where we would need a suitable let binding for the variable `?x`."
msgstr "где нам понадобится подходящая привязка let для переменной `?x`."

#: in/chapter12.md:92
msgid "## 12.1 A Prolog Compiler"
msgstr "## 12.1 Компилятор Пролога"

#: in/chapter12.md:96
msgid ""
"This section presents the compiler summarized in [figure  12.1](#f0010).\n"
"At the top level is the function `prolog-compile`, which takes a symbol, "
"looks at the clauses defined for that symbol, and groups the clauses by "
"arity.\n"
"Each symbol/arity is compiled into a separate Lisp function by `compile-"
"predicate`."
msgstr ""
"В этом разделе представлен компилятор, показанный на [рис. 12.1](#f0010).\n"
"На верхнем уровне находится функция `prolog-compile`, которая принимает "
"символ, просматривает предложения, определенные для этого символа, и "
"группирует их по арности(количеству аргументов).\n"
"Каждый символ/арность компилируется в отдельную функцию Лиспа с помощью "
"`compile-predicate`."

#: in/chapter12.md:101
msgid ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f12-01](images/chapter12/f12-01.jpg)        |\n"
"| Figure 12.1: Glossary for the Prolog Compiler |"
msgstr ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f12-01](images/chapter12/f12-01.jpg)        |\n"
"| Рисунок 12.1: Глоссарий для компилятора Prolog |"

#: in/chapter12.md:103
msgid "(ed: this should be a markdown table)"
msgstr ""

#: in/chapter12.md:117
msgid ""
"```lisp\n"
"(defun prolog-compile (symbol &optional\n"
"                       (clauses (get-clauses symbol)))\n"
"  \"Compile a symbol; make a separate function for each arity.\"\n"
"  (unless (null clauses)\n"
"    (let ((arity (relation-arity (clause-head (first clauses)))))\n"
"      ;; Compile the clauses with this arity\n"
"      (compile-predicate\n"
"        symbol arity (clauses-with-arity clauses #'= arity))\n"
"      ;; Compile all the clauses with any other arity\n"
"      (prolog-compile\n"
"        symbol (clauses-with-arity clauses #'/= arity)))))\n"
"```"
msgstr ""

#: in/chapter12.md:119
msgid "Three utility functions are included here:"
msgstr "Сюда включены три служебные функции:"

#: in/chapter12.md:127
msgid ""
"```lisp\n"
"(defun clauses-with-arity (clauses test arity)\n"
"  \"Return all clauses whose head has given arity.\"\n"
"  (find-all arity clauses\n"
"            :key #'(lambda (clause)\n"
"                     (relation-arity (clause-head clause)))\n"
"            :test test))"
msgstr ""

#: in/chapter12.md:132
msgid ""
"(defun relation-arity (relation)\n"
"  \"The number of arguments to a relation.\n"
"  Example: (relation-arity '(p a b c)) => 3\"\n"
"  (length (args relation)))"
msgstr ""

#: in/chapter12.md:135
msgid ""
"(defun args (x) \"The arguments of a relation\" (rest x))\n"
"```"
msgstr ""

#: in/chapter12.md:138
msgid ""
"The next step is to compile the clauses for a given predicate with a fixed "
"arity into a Lisp function.\n"
"For now, that will be done by compiling each clause independently and "
"wrapping them in a `lambda` with the right parameter list."
msgstr ""
"Следующим шагом является компиляция предложений для данного предиката с "
"фиксированной арностью в функцию Lisp.\n"
"На данный момент это будет сделано путем независимой компиляции каждого "
"предложения и помещения их в лямбда с правильным списком параметров."

#: in/chapter12.md:151
msgid ""
"```lisp\n"
"(defun compile-predicate (symbol arity clauses)\n"
"  \"Compile all the clauses for a given symbol/arity\n"
"  into a single LISP function.\"\n"
"  (let ((predicate (make-predicate symbol arity))\n"
"        (parameters (make-parameters arity)))\n"
"    (compile\n"
"     (eval\n"
"      `(defun ,predicate (,@parameters cont)\n"
"            .,(mapcar #'(lambda (clause)\n"
"                        (compile-clause parameters clause 'cont))\n"
"              clauses))))))"
msgstr ""

#: in/chapter12.md:156
msgid ""
"(defun make-parameters (arity)\n"
"  \"Return the list (?arg1 ?arg2 ... ?arg-arity)\"\n"
"  (loop for i from 1 to arity\n"
"        collect (new-symbol '?arg i)))"
msgstr ""

#: in/chapter12.md:161
msgid ""
"(defun make-predicate (symbol arity)\n"
"  \"Return the symbol: symbol/arity\"\n"
"  (symbol symbol '/ arity))\n"
"```"
msgstr ""

#: in/chapter12.md:165
msgid ""
"Now for the hard part: we must actually generate the code for a clause.\n"
"Here again is an example of the code desired for one clause.\n"
"We'll start by setting as a target the simple code:"
msgstr ""
"Теперь самое сложное: мы должны фактически сгенерировать код для "
"предложения.\n"
"Вот снова пример кода, желаемого для одного предложения.\n"
"Начнем с установки в качестве цели простого кода:"

#: in/chapter12.md:171
msgid ""
"```lisp\n"
"(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))\n"
"(defun likes/2 (?arg1 ?arg2 cont)\n"
"  ...\n"
"```"
msgstr ""

#: in/chapter12.md:175
msgid ""
"`  (if (and (unify!\n"
"?argl 'Kim) (unify!\n"
"?arg2 ?x)`"
msgstr ""

#: in/chapter12.md:180
msgid ""
"```lisp\n"
"      (likes/2 ?arg2 'Lee\n"
"            #'(lambda () (likes/2 ?x 'Kim))))\n"
"```"
msgstr ""

#: in/chapter12.md:182
msgctxt "in/chapter12.md:182"
msgid "  ...)"
msgstr ""

#: in/chapter12.md:184
msgid ""
"but we'll also consider the possibility of upgrading to the improved code:"
msgstr "но мы также рассмотрим возможность обновления до улучшенного кода:"

#: in/chapter12.md:189
msgid ""
"```lisp\n"
"(defun likes/2 (?arg1 ?arg2 cont)\n"
"  ...\n"
"```"
msgstr ""

#: in/chapter12.md:192
msgid ""
"`  (if (unify!\n"
"?arg1 'Kim)`"
msgstr ""

#: in/chapter12.md:194
msgid "      `(likes/2 ?arg2 'Lee`"
msgstr ""

#: in/chapter12.md:196
msgid "            `#'(lambda () (likes/2 ?arg2 'Kim))))`"
msgstr ""

#: in/chapter12.md:198
msgctxt "in/chapter12.md:198"
msgid "  ...)"
msgstr ""

#: in/chapter12.md:206
msgid ""
"One approach would be to write two functions, `compile-head` and `compile-"
"body`, and then combine them into the code (if *head body*).\n"
"This approach could easily generate the prior code.\n"
"However, let's allow ourselves to think ahead a little.\n"
"If we eventually want to generate the improved code, we will need some "
"communication between the head and the body.\n"
"We will have to know that the head decided not to compile the unification of "
"`?arg2` and `?x`, but because of this, the body will have to substitute `?"
"arg2` for `?x`.\n"
"That means that the `compile-head` function conceptually returns two values: "
"the code for the head, and an indication of substitutions to perform in the "
"body.\n"
"This could be handled by explicitly manipulating multiple values, but it "
"seems complicated."
msgstr ""
"Один из подходов - написать две функции, `compile-head` и `compile-body`, а "
"затем объединить их в код (if *head body*)\n"
"Такой подход может легко сгенерировать предыдущий код.\n"
"Однако позволим себе немного забежать вперед.\n"
"Если мы в конечном итоге захотим сгенерировать улучшенный код, нам "
"понадобится некоторая связь между головой(head) и телом(body).\n"
"Нам нужно знать, что голова решила не компилировать объединение/унификацию `?"
"arg2` и `?x`, но из-за этого тело должно будет заменить `?arg2` на `?x`.\n"
"Это означает, что функция `compile-head` концептуально возвращает два "
"значения: код для головы(head) и указание замен, которые необходимо "
"выполнить в теле(body).\n"
"С этим можно справиться, явно манипулируя мноожественными значениями, но это "
"кажется сложным."

#: in/chapter12.md:210
msgid ""
"An alternate approach is to eliminate `compile-head` and just write `compile-"
"body`.\n"
"This is possible if we in effect do a source-code transformation on the "
"clause.\n"
"Instead of treating the clause as:"
msgstr ""
"Альтернативный подход - исключить `compile-head` и просто написать `compile-"
"body`.\n"
"Это возможно, если мы действительно выполним преобразование исходного кода в "
"предложении.\n"
"Вместо того, чтобы трактовать это предложение как:"

#: in/chapter12.md:215
msgid ""
"```lisp\n"
"(<- (likes Kim ?x)\n"
"  (likes ?x Lee) (likes ?x Kim))\n"
"```"
msgstr ""

#: in/chapter12.md:217
msgid "we transform it to the equivalent:"
msgstr "преобразуем его в эквивалент:"

#: in/chapter12.md:222
msgid ""
"```lisp\n"
"(<- (likes ?arg1 ?arg2)\n"
"  (= ?arg1 Kim) (= ?arg2 ?x) (likes ?x Lee) (likes ?x Kim))\n"
"```"
msgstr ""

#: in/chapter12.md:226
msgid ""
"Now the arguments in the head of the clause match the arguments in the "
"function `likes/2`, so there is no need to generate any code for the head.\n"
"This makes things simpler by eliminating `compile-head`, and it is a better "
"decomposition for another reason: instead of adding optimizations to "
"`compile-head`, we will add them to the code in `compile`-`body` that "
"handles =.\n"
"That way, we can optimize calls that the user makes to =, in addition to the "
"calls introduced by the source-code transformation."
msgstr ""
"Теперь аргументы в заголовке(head) предложения соответствуют аргументам в "
"функции `likes/2`, поэтому нет необходимости создавать какой-либо код для "
"заголовка(head).\n"
"Это упрощает задачу за счет исключения `compile-head`, и это лучшая "
"декомпозиция по другой причине: вместо добавления оптимизаций в `compile-"
"head` мы добавим их в код в `compile-body`, который обрабатывает знак равно "
"=.\n"
"Таким образом, мы можем оптимизировать вызовы, которые пользователь делает к "
"=, в дополнение к вызовам, вводимым преобразованием исходного кода."

#: in/chapter12.md:228
msgid ""
"To get an overview, the calling sequence of functions will turn out to be as "
"follows:"
msgstr ""
"Для ознакомления, последовательность вызовов функций окажется следующей:"

#: in/chapter12.md:239
msgid ""
"```lisp\n"
"prolog-compile\n"
"  compile-predicate\n"
"    compile-clause\n"
"      compile-body\n"
"        compile-call\n"
"        compile-arg\n"
"        compile-unify\n"
"            compile-arg\n"
"```"
msgstr ""

#: in/chapter12.md:243
msgid ""
"where each function calls the ones below it that are indented one level.\n"
"We have already defined the first two functions.\n"
"Here then is our first version of `compile-clause`:"
msgstr ""
"где каждая функция вызывает те, что ниже, с отступом на один уровень.\n"
"Мы уже определили первые две функции.\n"
"Вот наша первая версия `compile-clause`:"

#: in/chapter12.md:252
msgid ""
"```lisp\n"
"(defun compile-clause (parms clause cont)\n"
"  \"Transform away the head, and compile the resulting body.\"\n"
"  (compile-body\n"
"    (nconc\n"
"      (mapcar #'make-= parms (args (clause-head clause)))\n"
"      (clause-body clause))\n"
"    cont))"
msgstr ""

#: in/chapter12.md:255
msgid ""
"(defun make-= (x y) `(= ,x ,y))\n"
"```"
msgstr ""

#: in/chapter12.md:261
msgid ""
"The bulk of the work is in `compile-body`, which is a little more "
"complicated.\n"
"There are three cases.\n"
"If there is no body, we just call the continuation.\n"
"If the body starts with a call to =, we compile a call to `unify!`.\n"
"Otherwise, we compile a call to a function, passing in the appropriate "
"continuation."
msgstr ""
"Основная часть работы выполняется в `compile-body`, который немного "
"сложнее.\n"
"Есть три случая.\n"
"Если тела нет, мы просто вызываем продолжение.\n"
"Если тело начинается с вызова =, мы компилируем вызов `unify!`.\n"
"В противном случае мы компилируем вызов функции, передавая соответствующее "
"продолжение."

#: in/chapter12.md:267
msgid ""
"However, it is worthwhile to think ahead at this point.\n"
"If we want to treat = specially now, we will probably want to treat other "
"goals specially later.\n"
"So instead of explicitly checking for =, we will do a data-driven dispatch, "
"looking for any predicate that has a `prolog-compiler-macro` property "
"attached to it.\n"
"Like Lisp compiler macros, the macro can decline to handle the goal.\n"
"We will adopt the convention that returning `:pass` means the macro decided "
"not to handle i t, and thus it should be compiled as a normal goal."
msgstr ""
"Однако на этом этапе стоит подумать о будущем.\n"
"Если мы хотим трактовать сейчас = специально, мы, вероятно, захотим позже "
"обработать другие цели специально.\n"
"Поэтому вместо явной проверки для = мы будем выполнять управляемую данными "
"диспетчеризацию, ища любой предикат, к которому привязано свойство `prolog-"
"compiler-macro`.\n"
"Как и макросы компилятора Лиспа, макрос может не справиться с поставленной "
"задачей.\n"
"Мы примем соглашение, согласно которому возврат `:pass` означает, что макрос "
"решил не обрабатывать это и следовательно, он должен быть скомпилирован как "
"обычная цель."

#: in/chapter12.md:288
msgid ""
"```lisp\n"
"(defun compile-body (body cont)\n"
"  \"Compile the body of a clause.\"\n"
"  (if (null body)\n"
"      `(funcall ,cont)\n"
"      (let* ((goal (first body))\n"
"             (macro (prolog-compiler-macro (predicate goal)))\n"
"             (macro-val (if macro\n"
"                            (funcall macro goal (rest body) cont))))\n"
"        (if (and macro (not (eq macro-val :pass)))\n"
"            macro-val\n"
"            (compile-call\n"
"               (make-predicate (predicate goal)\n"
"                               (relation-arity goal))\n"
"               (mapcar #'(lambda (arg) (compile-arg arg))\n"
"                       (args goal))\n"
"               (if (null (rest body))\n"
"                   cont\n"
"                   `#'(lambda ()\n"
"                      ,(compile-body (rest body) cont))))))))"
msgstr ""

#: in/chapter12.md:292
msgid ""
"(defun compile-call (predicate args cont)\n"
"  \"Compile a call to a prolog predicate.\"\n"
"  `(,predicate ,@args ,cont))"
msgstr ""

#: in/chapter12.md:297
msgid ""
"(defun prolog-compiler-macro (name)\n"
"  \"Fetch the compiler macro for a Prolog predicate.\"\n"
"  ;; Note NAME is the raw name, not the name/arity\n"
"  (get name 'prolog-compiler-macro))"
msgstr ""

#: in/chapter12.md:302
msgid ""
"(defmacro def-prolog-compiler-macro (name arglist &body body)\n"
"  \"Define a compiler macro for Prolog.\"\n"
"  `(setf (get ',name 'prolog-compiler-macro)\n"
"         #'(lambda ,arglist .,body)))"
msgstr ""

#: in/chapter12.md:309
msgid ""
"(def-prolog-compiler-macro = (goal body cont)\n"
"  (let ((args (args goal)))\n"
"    (if (/= (length args) 2)\n"
"        :pass\n"
"        `(if ,(compile-unify (first args) (second args))\n"
"             ,(compile-body body cont)))))"
msgstr ""

#: in/chapter12.md:314
msgid ""
"(defun compile-unify (x y)\n"
"  \"Return code that tests if var and term unify.\"\n"
"  `(unify! ,(compile-arg x) ,(compile-arg y)))\n"
"```"
msgstr ""

#: in/chapter12.md:317
msgid ""
"All that remains is `compile-arg`, a function to compile the arguments to "
"goals in the body.\n"
"There are three cases to consider, as shown in the compilation to the "
"argument of `q` below:"
msgstr ""
"Все, что остается, это `compile-arg`, функция для компиляции аргументов в "
"цели для тела предложения.\n"
"Следует рассмотреть три случая, как показано ниже при компиляции аргумента "
"`q`:"

#: in/chapter12.md:323
msgid ""
"| []()                         |                              |\n"
"|------------------------------|------------------------------|\n"
"| `1 (<- (p ?x) (q ?x))`       | `(q/1 ?x cont)`              |\n"
"| `2 (<- (p ?x) (q (f a b)))`  | `(q/1 '(f a b) cont)`        |\n"
"| `3 (<- (p ?x) (q (f ?x b)))` | `(q/1 (list 'f ?x 'b) cont)` |"
msgstr ""

#: in/chapter12.md:330
msgid ""
"In case 1, the argument is a variable, and it is compiled as is.\n"
"In case 2, the argument is a constant expression (one without any variables) "
"that compiles into a quoted expression.\n"
"In case 3, the argument contains a variable, so we have to generate code "
"that builds up the expression.\n"
"Case 3 is actually split into two in the list below: one compiles into a "
"call to `list`, and the other a call to `cons`.\n"
"It is important to remember that the goal `(q (f ?x b))` does *not* involve "
"a call to the function `f`.\n"
"Rather, it involves the term `(f ?x b)`, which is just a list of three "
"elements."
msgstr ""
"В случае 1 аргументом является переменная, и она компилируется как есть.\n"
"В случае 2 аргумент - это постоянное выражение (без переменных), которое "
"компилируется в цитируемое(quote) выражение.\n"
"В случае 3 аргумент содержит переменную, поэтому мы должны сгенерировать "
"код, который строит выражение.\n"
"Случай 3 фактически разделен на две части в списке ниже: одна компилируется "
"в вызов `list`, а другая - в вызов `cons`.\n"
"Важно помнить, что цель `(q (f ?x b))` *не* включает вызов функции `f`.\n"
"Скорее, она включает термин `(f ?x b)`, который представляет собой просто "
"список из трех элементов."

#: in/chapter12.md:340
msgid ""
"```lisp\n"
"(defun compile-arg (arg)\n"
"  \"Generate code for an argument to a goal in the body.\"\n"
"  (cond ((variable-p arg) arg)\n"
"        ((not (has-variable-p arg)) `',arg)\n"
"        ((proper-listp arg)\n"
"         `(list .,(mapcar #'compile-arg arg)))\n"
"        (t `(cons ,(compile-arg (first arg))\n"
"                  ,(compile-arg (rest arg))))))"
msgstr ""

#: in/chapter12.md:344
msgid ""
"(defun has-variable-p (x)\n"
"  \"Is there a variable anywhere in the expression x?\"\n"
"  (find-if-anywhere #'variable-p x))"
msgstr ""

#: in/chapter12.md:350
msgid ""
"(defun proper-listp (x)\n"
"  \"Is x a proper (non-dotted) list?\"\n"
"  (or (null x)\n"
"      (and (consp x) (proper-listp (rest x)))))\n"
"```"
msgstr ""

#: in/chapter12.md:353
msgid ""
"Let's see how it works.\n"
"We will consider the following clauses:"
msgstr ""
"Посмотрим, как это работает.\n"
"Мы рассмотрим следующие пункты:"

#: in/chapter12.md:361
msgid ""
"```lisp\n"
"(<- (likes Robin cats))\n"
"(<- (likes Sandy ?x) (likes ?x cats))\n"
"(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))\n"
"(<- (member ?item (?item . ?rest)))\n"
"(<- (member ?item (?x . ?rest)) (member ?item ?rest))\n"
"```"
msgstr ""

#: in/chapter12.md:363
msgid "Here's what `prolog-compile` gives us:"
msgstr "Вот что дает нам `prolog-compile`:"

#: in/chapter12.md:367
msgid ""
"```lisp\n"
"(DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)\n"
"```"
msgstr ""

#: in/chapter12.md:370
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 'ROBIN)`"
msgstr ""

#: in/chapter12.md:373
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 'CATS)`"
msgstr ""

#: in/chapter12.md:377
msgctxt "in/chapter12.md:377"
msgid ""
"```lisp\n"
"      (FUNCALL CONT)))\n"
"```"
msgstr ""

#: in/chapter12.md:380
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 'SANDY)`"
msgstr ""

#: in/chapter12.md:383
msgctxt "in/chapter12.md:383"
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 ?X)`"
msgstr ""

#: in/chapter12.md:387
msgid ""
"```lisp\n"
"      (LIKES/2 ?X 'CATS CONT)))\n"
"```"
msgstr ""

#: in/chapter12.md:390
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 'KIM)`"
msgstr ""

#: in/chapter12.md:393
msgctxt "in/chapter12.md:393"
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 ?X)`"
msgstr ""

#: in/chapter12.md:399
msgid ""
"```lisp\n"
"      (LIKES/2 ?X 'LEE (LAMBDA ()\n"
"            (LIKES/2 ?X 'KIM CONT))))))\n"
"(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)\n"
"```"
msgstr ""

#: in/chapter12.md:402
msgctxt "in/chapter12.md:402"
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:405
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 (CONS ?ITEM ?REST))`"
msgstr ""

#: in/chapter12.md:409
msgctxt "in/chapter12.md:409"
msgid ""
"```lisp\n"
"      (FUNCALL CONT)))\n"
"```"
msgstr ""

#: in/chapter12.md:412
msgctxt "in/chapter12.md:412"
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:415
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 (CONS ?X ?REST))`"
msgstr ""

#: in/chapter12.md:419
msgid ""
"```lisp\n"
"      (MEMBER/2 ?ITEM ?REST CONT))))\n"
"```"
msgstr ""

#: in/chapter12.md:421
msgid "## 12.2 Fixing the Errors in the Compiler"
msgstr "## 12.2 Исправление ошибок в компиляторе"

#: in/chapter12.md:423
msgid "There are some problems in this version of the compiler:"
msgstr "В этой версии компилятора есть некоторые проблемы:"

#: in/chapter12.md:425
msgid "*   We forgot to undo the bindings after each call to `unify!`."
msgstr "*   Мы забыли отменить привязки после каждого вызова `unify!`."

#: in/chapter12.md:428
msgid ""
"*   The definition of `undo-bindings` ! defined previously requires as an "
"argument an index into the `*trail*` array.\n"
"So we will have to save the current top of the trail when we enter each "
"function."
msgstr ""
"*   Определение `undo-bindings!` определенное ранее требует в качестве "
"аргумента индекса в массиве `*trail*`.\n"
"Таким образом, нам нужно будет сохранять текущую вершину trail при входе в "
"каждую функцию."

#: in/chapter12.md:431
msgid ""
"*   Local variables, such as `?x`, were used without being introduced.\n"
"They should be bound to new variables."
msgstr ""
"*   Локальные переменные, такие как `?x`, использовались без введения.\n"
"Они должны быть привязаны к новым переменным."

#: in/chapter12.md:436
msgid ""
"Undoing the bindings is simple: we add a single line to `compile-predicate,` "
"a call to the function `maybe-add-undo-bindings.` This function inserts a "
"call to `undo-bindings!` after every failure.\n"
"If there is only one clause, no undoing is necessary, because the predicate "
"higher up in the calling sequence will do it when it fails.\n"
"If there are multiple clauses, the function wraps the whole function body in "
"a let that captures the initial value of the trail's fill pointer, so that "
"the bindings can be undone to the right point.\n"
"Similarly, we can handle the unbound-variable problem by wrapping a call to "
"`bind-unbound-vars` around each compiled clause:"
msgstr ""
"Отменить привязку просто: мы добавляем одну строку в `compile-predicate`, "
"вызов функции `might-add-undo-bindings`. Эта функция вставляет вызов `undo-"
"bindings!` после каждой неудачи(failure).\n"
"Если есть только одно предложение, отмены не требуется, потому что предикат, "
"расположенный выше в вызывающей последовательности, сделает это в случае "
"неудачи(failure).\n"
"Если есть несколько предложений, функция оборачивает все тело функции в let, "
"которая фиксирует начальное значение указателя заполнения trail, так что "
"привязки могут быть отменены в нужной точке.\n"
"Точно так же мы можем решить проблему несвязанных переменных, заключив вызов "
"`bind-unbound-vars` вокруг каждого скомпилированного предложения:"

#: in/chapter12.md:450
msgid ""
"```lisp\n"
"(defun compile-predicate (symbol arity clauses)\n"
"  \"Compile all the clauses for a given symbol/arity\n"
"  into a single LISP function.\"\n"
"  (let ((predicate (make-predicate symbol arity))\n"
"        (parameters (make-parameters arity)))\n"
"    (compile\n"
"     (eval\n"
"      `(defun ,predicate (,@parameters cont)\n"
"  .,(maybe-add-undo-bindings                  ;***\n"
"     (mapcar #'(lambda (clause)\n"
"           (compile-clause parameters clause 'cont))\n"
"      clauses)))))))"
msgstr ""

#: in/chapter12.md:460
msgid ""
"(defun compile-clause (parms clause cont)\n"
"  \"Transform away the head, and compile the resulting body.\"\n"
"  (bind-unbound-vars                                   ;***\n"
"    parms                                              ;***\n"
"    (compile-body\n"
"      (nconc\n"
"        (mapcar #'make-= parms (args (clause-head clause)))\n"
"        (clause-body clause))\n"
"      cont)))"
msgstr ""

#: in/chapter12.md:471
msgid ""
"(defun maybe-add-undo-bindings (compiled-exps)\n"
"  \"Undo any bindings that need undoing.\n"
"  If there are any, bind the trail before we start.\"\n"
"  (if (length=1 compiled-exps)\n"
"      compiled-exps\n"
"      `((let ((old-trail (fill-pointer *trail*)))\n"
"          ,(first compiled-exps)\n"
"          ,@(loop for exp in (rest compiled-exps)\n"
"                  collect '(undo-bindings! old-trail)\n"
"                  collect exp)))))"
msgstr ""

#: in/chapter12.md:483
msgid ""
"(defun bind-unbound-vars (parameters exp)\n"
"  \"If there are any variables in exp (besides the parameters)\n"
"  then bind them to new vars.\"\n"
"  (let ((exp-vars (set-difference (variables-in exp)\n"
"                                  parameters)))\n"
"    (if exp-vars\n"
"        `(let ,(mapcar #'(lambda (var) `(,var (?)))\n"
"                       exp-vars)\n"
"           ,exp)\n"
"        exp)))\n"
"```"
msgstr ""

#: in/chapter12.md:485
msgid ""
"With these improvements, here's the code we get for `likes` and `member`:"
msgstr "С этими улучшениями мы получили код для `likes` и `member`:"

#: in/chapter12.md:490
msgid ""
"```lisp\n"
"(DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)\n"
"  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))\n"
"```"
msgstr ""

#: in/chapter12.md:493
msgid ""
"`    (IF (UNIFY!\n"
"?ARG1 'ROBIN)`"
msgstr ""

#: in/chapter12.md:496
msgid ""
"`      (IF (UNIFY!\n"
"?ARG2 'CATS)`"
msgstr ""

#: in/chapter12.md:500
msgid ""
"```lisp\n"
"            (FUNCALL CONT)))\n"
"```"
msgstr ""

#: in/chapter12.md:503
msgctxt "in/chapter12.md:503"
msgid ""
"`    (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:507
msgctxt "in/chapter12.md:507"
msgid ""
"```lisp\n"
"    (LET ((?X (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:510
msgid ""
"`      (IF (UNIFY!\n"
"?ARG1 'SANDY)`"
msgstr ""

#: in/chapter12.md:513
msgctxt "in/chapter12.md:513"
msgid ""
"`        (IF (UNIFY!\n"
"?ARG2 ?X)`"
msgstr ""

#: in/chapter12.md:517
msgid ""
"```lisp\n"
"            (LIKES/2 ?X 'CATS CONT))))\n"
"```"
msgstr ""

#: in/chapter12.md:520
msgctxt "in/chapter12.md:520"
msgid ""
"`    (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:524
msgctxt "in/chapter12.md:524"
msgid ""
"```lisp\n"
"    (LET ((?X (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:527
msgid ""
"`      (IF (UNIFY!\n"
"?ARG1 'KIM)`"
msgstr ""

#: in/chapter12.md:530
msgctxt "in/chapter12.md:530"
msgid ""
"`        (IF (UNIFY!\n"
"?ARG2 ?X)`"
msgstr ""

#: in/chapter12.md:539
msgid ""
"```lisp\n"
"            (LIKES/2 ?X 'LEE (LAMBDA ()\n"
"                    (LIKES/2 ?X 'KIM CONT))))))))\n"
"(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)\n"
"  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))\n"
"    (LET ((?ITEM (?))\n"
"            (?REST (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:542
msgctxt "in/chapter12.md:542"
msgid ""
"`      (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:545
msgid ""
"`            (IF (UNIFY!\n"
"?ARG2 (CONS ?ITEM ?REST))`"
msgstr ""

#: in/chapter12.md:549
msgid ""
"```lisp\n"
"                        (FUNCALL CONT))))\n"
"```"
msgstr ""

#: in/chapter12.md:552
msgctxt "in/chapter12.md:552"
msgid ""
"`    (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:556
msgid ""
"```lisp\n"
"    (LET ((?X (?))\n"
"```"
msgstr ""

#: in/chapter12.md:559
msgid ""
"`            (?\n"
"ITEM (?))`"
msgstr ""

#: in/chapter12.md:563
msgid ""
"```lisp\n"
"            (?REST (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:566
msgid ""
"`    (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:569
msgid ""
"`      (IF (UNIFY!\n"
"?ARG2 (CONS ?X ?REST))`"
msgstr ""

#: in/chapter12.md:573
msgid ""
"```lisp\n"
"                        (MEMBER/2 ?ITEM ?REST CONT))))))\n"
"```"
msgstr ""

#: in/chapter12.md:575
msgid "## 12.3 Improving the Compiler"
msgstr "## 12.3 Улучшение компилятора"

#: in/chapter12.md:581
msgid ""
"This is fairly good, although there is still room for improvement.\n"
"One minor improvement is to eliminate unneeded variables.\n"
"For example, `?rest` in the first clause of `member` and `?x` in the second "
"clause are bound to new variables-the result of the (?) call-and then only "
"used once.\n"
"The generated code could be made a little tighter by just putting (?) "
"inline, rather than binding it to a variable and then referencing that "
"variable.\n"
"There are two parts to this change: updating `compile-arg` to compile an "
"anonymous variable inline, and changing the <- macro so that it converts all "
"variables that only appear once in a clause into anonymous variables:"
msgstr ""
"Это неплохо, хотя есть еще возможности для улучшения.\n"
"Одно небольшое улучшение - устранение ненужных переменных.\n"
"Например, `?rest` в первом предложении `member` и `?x` во втором предложении "
"привязаны к новым переменным - результату вызова (?) - и затем используются "
"только один раз.\n"
"Сгенерированный код можно было бы немного упростить, просто поместив вызов "
"(?) в нужную позицию(inline), а не связывая его результат с переменной и "
"затем ссылаясь на эту переменную.\n"
"Это изменение состоит из двух частей: обновление `compile-arg` для "
"компиляции анонимной переменной встроенной(inline) и изменение макроса <- "
"так, чтобы он преобразовывал все переменные, которые появляются только один "
"раз в предложении, в анонимные переменные:"

#: in/chapter12.md:586
msgid ""
"```lisp\n"
"(defmacro <- (&rest clause)\n"
"  \"Add a clause to the data base.\"\n"
"  `(add-clause ',(make-anonymous clause)))"
msgstr ""

#: in/chapter12.md:595
msgid ""
"(defun compile-arg (arg)\n"
"  \"Generate code for an argument to a goal in the body.\"\n"
"  (cond ((variable-p arg) arg)\n"
"        ((not (has-variable-p arg)) `',arg)\n"
"        ((proper-listp arg)\n"
"         `(list .,(mapcar #'compile-arg arg)))\n"
"        (t `(cons ,(compile-arg (first arg))\n"
"                  ,(compile-arg (rest arg))))))"
msgstr ""

#: in/chapter12.md:606
msgid ""
"(defun make-anonymous (exp &optional\n"
"                       (anon-vars (anonymous-variables-in exp)))\n"
"  \"Replace variables that are only used once with ?.\"\n"
"  (cond ((consp exp)\n"
"         (reuse-cons (make-anonymous (first exp) anon-vars)\n"
"                     (make-anonymous (rest exp) anon-vars)\n"
"                     exp))\n"
"        ((member exp anon-vars) '?)\n"
"        (t exp)))\n"
"```"
msgstr ""

#: in/chapter12.md:611
msgid ""
"Finding anonymous variables is tricky.\n"
"The following function keeps two lists: the variables that have been seen "
"once, and the variables that have been seen twice or more.\n"
"The local function `walk` is then used to walk over the tree, recursively "
"considering the components of each cons cell and updating the two lists as "
"each variable is encountered.\n"
"This use of local functions should be remembered, as well as an alternative "
"discussed in [exercise 12.23](#p4625) on [page 428](#p428)."
msgstr ""
"Найти анонимные переменные непросто.\n"
"Следующая функция хранит два списка: переменные, которые были обнаружены "
"один раз, и переменные, которые были обнаружены дважды или более.\n"
"Затем для обхода дерева используется локальная функция `walk`, рекурсивно "
"рассматривая компоненты каждой cons-ячейки и обновляя два списка при "
"обнаружении каждой переменной.\n"
"Следует помнить об использовании локальных функций, а также об альтернативе, "
"обсуждаемой в [упражнении 12.23](#p4625) на [стр. 428](#p428)."

#: in/chapter12.md:631
msgid ""
"```lisp\n"
"(defun anonymous-variables-in (tree)\n"
"  \"Return a list of all variables that occur only once in tree.\"\n"
"  (let ((seen-once nil)\n"
"            (seen-more nil))\n"
"    (labels ((walk (x)\n"
"            (cond\n"
"                ((variable-p x)\n"
"                    (cond ((member x seen-once)\n"
"                              (setf seen-once (delete x seen-once))\n"
"                              (push x seen-more))\n"
"                        ((member x seen-more) nil)\n"
"                        (t (push x seen-once))))\n"
"                ((consp x)\n"
"                    (walk (first x))\n"
"                    (walk (rest x))))))\n"
"      (walk tree)\n"
"      seen-once)))\n"
"```"
msgstr ""

#: in/chapter12.md:633
msgid "Now `member` compiles into this:"
msgstr "Теперь `member` компилируется в это:"

#: in/chapter12.md:637
msgid ""
"```lisp\n"
"(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)\n"
"```"
msgstr ""

#: in/chapter12.md:639
msgid "  `(LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))`"
msgstr ""

#: in/chapter12.md:641
msgid "    `(LET ((?ITEM (?)))`"
msgstr ""

#: in/chapter12.md:644
msgid ""
"      `(IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:647
msgid ""
"        `(IF (UNIFY!\n"
"?ARG2 (CONS ?ITEM (?)))`"
msgstr ""

#: in/chapter12.md:649
msgid "                `(FUNCALL CONT))))`"
msgstr ""

#: in/chapter12.md:652
msgid ""
"    `(UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:657
msgid ""
"```lisp\n"
"    (LET ((?ITEM (?))\n"
"        (?REST (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:660
msgctxt "in/chapter12.md:660"
msgid ""
"`      (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:663
msgctxt "in/chapter12.md:663"
msgid ""
"`        (IF (UNIFY!\n"
"?ARG2 (CONS (?) ?REST))`"
msgstr ""

#: in/chapter12.md:667
msgid ""
"```lisp\n"
"            (MEMBER/2 ?ITEM ?REST CONT))))))\n"
"```"
msgstr ""

#: in/chapter12.md:669
msgid "## 12.4 Improving the Compilation of Unification"
msgstr "## 12.4 Улучшение компиляции унификации"

#: in/chapter12.md:672
msgid ""
"Now we turn to the improvement of `compile-unify`.\n"
"Recall that we want to elimina te certain calls to `unify!` so that, for "
"example, the first clause of `member:`"
msgstr ""
"Теперь перейдем к усовершенствованию `compile-unify`.\n"
"Напомним, что мы хотим исключить определенные вызовы `unify!`, Чтобы, "
"например, первое предложение `member:`"

#: in/chapter12.md:676
msgid ""
"```lisp\n"
"(<- (member ?item (?item . ?rest)))\n"
"```"
msgstr ""

#: in/chapter12.md:678
msgid "compiles into:"
msgstr "компилируется в:"

#: in/chapter12.md:682
msgid ""
"```lisp\n"
"(LET ((?ITEM (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:685
msgctxt "in/chapter12.md:685"
msgid ""
"`  (IF (UNIFY!\n"
"?ARG1 ?ITEM)`"
msgstr ""

#: in/chapter12.md:688
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 (CONS ?ITEM (?)))`"
msgstr ""

#: in/chapter12.md:692
msgid ""
"```lisp\n"
"        (FUNCALL CONT))))\n"
"```"
msgstr ""

#: in/chapter12.md:694
msgid "when it could compile to the more efficient:"
msgstr "когда оно могло бы скомпилироваться в более эффективный:"

#: in/chapter12.md:697
msgid ""
"`(IF (UNIFY!\n"
"?ARG2 (CONS ?ARG1 (?)))`"
msgstr ""

#: in/chapter12.md:701
msgid ""
"```lisp\n"
"    (FUNCALL CONT))\n"
"```"
msgstr ""

#: in/chapter12.md:707
msgid ""
"Eliminating the unification in one goal has repercussions in other goals "
"later on, so we will need to keep track of expressions that have been "
"unified together.\n"
"We have a design choice.\n"
"Either `compile-unify` can modify a global state variable, or it can return "
"multiple values.\n"
"On the grounds that global variables are messy, we make the second choice: "
"`compile-unify` will take a binding list as an extra argument and will "
"return two values, the actual code and an updated binding list.\n"
"We will expect that other related functions will have to be modified to deal "
"with these multiple values."
msgstr ""
"Устранение объединения/унификации одной цели в дальнейшем отразится и на "
"других целях, поэтому нам нужно будет отслеживать выражения, которые были "
"объединены/унифицированы вместе.\n"
"У нас есть выбор дизайна.\n"
"Либо `compile-unify` может изменять глобальную переменную состояния, либо "
"возвращать несколько значений.\n"
"На основании того, что глобальные переменные беспорядочны, мы делаем второй "
"выбор: `compile-unify` принимает список привязок в качестве дополнительного "
"аргумента и возвращает два значения: фактический код и обновленный список "
"привязок.\n"
"Мы ожидаем, что для работы с этими множественными значениями придется "
"изменить другие связанные функции."

#: in/chapter12.md:711
msgid ""
"When `compile-unify` is first called in our example clause, it is asked to "
"unify `?argl` and `?item`.\n"
"We want it to return no code (or more precisely, the trivially true test, "
"t).\n"
"For the second value, it should return a new binding list, with `?item` "
"bound to `?arg1.` That binding will be used to replace `?item` with `?arg1` "
"in subsequent code."
msgstr ""
"Когда в нашем примере сначала вызывается `compile-unify`, её просят "
"объединить/унифицировать `?argl` и `?item`.\n"
"Мы хотим, чтобы она возвращала не код (точнее, тривиально верный тест t).\n"
"Для второго значения она должна вернуть новый список привязок с `?item`, "
"привязанным к `?arg1`. Эта привязка будет использоваться для замены `?item` "
"на `?arg1` в последующем коде."

#: in/chapter12.md:717
msgid ""
"How do we know to bind `?item` to `?arg1` rather than the other way around?\n"
"Because `?arg1` is already bound to something-the value passed in to `member."
"` We don't know what this value is, but we can't ignore it.\n"
"Thus, the initial binding list will have to indicate that the parameters are "
"bound to something.\n"
"A simple convention is to bind the parameters to themselves.\n"
"Thus, the initial binding list will be:"
msgstr ""
"Как мы узнаем, что нужно привязать `?item` к `?arg1`, а не наоборот?\n"
"Поскольку `?arg1` уже привязан к чему-то - значению, переданному в `member`. "
"Мы не знаем, что это за значение, но мы не можем его игнорировать.\n"
"Таким образом, в исходном списке привязки должно быть указано, что параметры "
"к чему-то привязаны.\n"
"Простое соглашение - привязать параметры к самим себе.\n"
"Таким образом, исходный список привязки будет:"

#: in/chapter12.md:721
msgid ""
"```lisp\n"
"((?arg1 .?arg1) (?arg2 . ?arg2))\n"
"```"
msgstr ""

#: in/chapter12.md:723
msgid ""
"We saw in the previous chapter ([page 354](B978008057115750011X.xhtml#p354)) "
"that binding a variable to itself can lead to problems; we will have to be "
"careful."
msgstr ""
"В предыдущей главе ([страница 354](B978008057115750011X.xhtml#p354)) мы "
"видели, что привязка переменной к самой себе может привести к проблемам; нам "
"придется быть осторожными."

#: in/chapter12.md:729
msgid ""
"Besides eliminating unifications of new variables against parameters, there "
"are quite a few other improvements that can be made.\n"
"For example, unifications involving only constants can be done at compile "
"time.\n"
"The call `(= (f a) (f a ))` always succeeds, while `(=  3 4)` always fails.\n"
"In addition, unification of two cons cells can be broken into components at "
"compile time: `(= (f ?x) (f a))` reduces to `(= ?x a)` and `(= f f)`, where "
"the latter trivially succeeds.\n"
"We can even do some occurs checking at compile time: `(= ?x (f ?x))` should "
"fail."
msgstr ""
"Помимо устранения объединения/унификации новых переменных с параметрами, "
"можно сделать еще несколько улучшений.\n"
"Например, унификации, включающие только константы, могут быть выполнены во "
"время компиляции.\n"
"Вызов `(= (f a) (f a))` всегда успешен, а `(= 3 4)` всегда терпит неудачу.\n"
"Кроме того, объединение/унификация двух cons-ячеек может быть разбита на "
"компоненты во время компиляции: `(= (f ?x) (f a))` сокращается до `(= ?x a)` "
"и `(= f f)`, где последний тривиально успешен(истинен).\n"
"Мы даже можем выполнить проверку некоторых событий во время компиляции: `(= ?"
"x (f ?x))` должно завершиться неудачей(fail)."

#: in/chapter12.md:732
msgid ""
"The following table lists these improvements, along with a breakdown for the "
"cases of unifying a bound `(?arg1)` or unbound `(?x)` variable agains "
"another expression.\n"
"The first column is the unification call, the second is the generated code, "
"and the third is the bindings that will be added as a resuit of the call:"
msgstr ""
"В следующей таблице перечислены эти улучшения вместе с разбивкой по случаям "
"объединения/унификации связанной переменной `(?arg1)` или несвязанной "
"переменной `(?x)` с другим выражением.\n"
"Первый столбец - это вызов унификации, второй - сгенерированный код, а "
"третий - привязки, которые будут добавлены в результате вызова:"

#: in/chapter12.md:747
msgid ""
"|      | Unification         | Code                    | Bindings            "
"|\n"
"|------|---------------------|-------------------------|---------------------|\n"
"| 1    | `(= 3 3)`           | `t`                     | `-`                 "
"|\n"
"| 2    | `(= 3 4)`           | `nil`                   | `-`                 "
"|\n"
"| 3    | `(= (f ?x) (?p 3))` | `t`                     | `(?x . 3) (?p . f)` "
"|\n"
"| 4    | `(= ?arg1 ?y)`      | `t`                     | `(?y . ?arg1)`      "
"|\n"
"| 5    | `(= ?arg1 ?arg2)`   | `(unify! ?arg1 ?arg2)`  | `(?arg1 . ?arg2)`   "
"|\n"
"| 6    | `(= ?arg1 3)`       | `(unify! ?arg1 3)`      | `(?arg1 . 3)`       "
"|\n"
"| 7    | `(= ?arg1 (f ? y))` | `(unify! ?arg1 . . . )` | `(?y . ?y)`         "
"|\n"
"| 8    | `(= ?x ?y)`         | `t`                     | `(?y . ?y)`         "
"|\n"
"| 9    | `(= ?x 3)`          | `t`                     | `(?x . 3)`          "
"|\n"
"| 10   | `(= ?x (f ? y))`    | `(unify! ?x . . . )`    | `(?y . ?y)`         "
"|\n"
"| 11   | `(= ?x (f ? x))`    | `nil`                   | `-`                 "
"|\n"
"| 12   | `(= ?x ?)`          | `t`                     | `-`                 "
"|"
msgstr ""

#: in/chapter12.md:751
msgid ""
"From this table we can craft our new version of `compile-unify`.\n"
"The first part is fairly easy.\n"
"It takes care of the first three cases in this table and makes sure that "
"`compile-unify-variable` is called with a variable as the first argument for "
"the other cases."
msgstr ""
"Из этой таблицы мы можем создать нашу новую версию `compile-unify`.\n"
"Первая часть довольно проста.\n"
"Она заботится о первых трех случаях в этой таблице и обеспечивает вызов "
"`compile-unify-variable` с переменной в качестве первого аргумента для "
"остальных случаев."

#: in/chapter12.md:769
msgid ""
"```lisp\n"
"(defun compile-unify (x y bindings)\n"
"  \"Return 2 values: code to test if x and y unify,\n"
"  and a new binding list.\"\n"
"  (cond\n"
"    ;; Unify constants and conses:                       ; Case\n"
"    ((not (or (has-variable-p x) (has-variable-p y)))    ; 1,2\n"
"     (values (equal x y) bindings))\n"
"    ((and (consp x) (consp y))                           ; 3\n"
"     (multiple-value-bind (code1 bindings1)\n"
"         (compile-unify (first x) (first y) bindings)\n"
"       (multiple-value-bind (code2 bindings2)\n"
"           (compile-unify (rest x) (rest y) bindings1)\n"
"         (values (compile-if code1 code2) bindings2))))\n"
"    ;; Here x or y is a variable.  Pick the right one:\n"
"    ((variable-p x) (compile-unify-variable x y bindings))\n"
"    (t              (compile-unify-variable y x bindings))))"
msgstr ""

#: in/chapter12.md:777
msgid ""
"(defun compile-if (pred then-part)\n"
"  \"Compile a Lisp IF form. No else-part allowed.\"\n"
"  (case pred\n"
"    ((t) then-part)\n"
"    ((nil) nil)\n"
"    (otherwise `(if ,pred ,then-part))))\n"
"```"
msgstr ""

#: in/chapter12.md:784
msgid ""
"The function `compile-unify-variable` following is one of the most complex "
"we have seen.\n"
"For each argument, we see if it has a binding (the local variables `xb` and "
"`yb`), and then use the bindings to get the value of each argument (`x1` and "
"`y1`).\n"
"Note that for either an unbound variable or one bound to itself, `x` will "
"equal `x1` (and the same for `y` and `y1`).\n"
"If either of the pairs of values is not equal, we should use the new ones "
"(`x1` or `y1`), and the clause commented deref does that.\n"
"After that point, we just go through the cases, one at a time.\n"
"It turns out that it was easier to change the order slightly from the "
"preceding table, but each clause is commented with the corresponding number:"
msgstr ""
"Следующая функция `compile-unify-variable` - одна из самых сложных, которые "
"мы видели.\n"
"Для каждого аргумента мы смотрим, есть ли у него привязка (локальные "
"переменные `xb` и` yb`), а затем используем привязки, чтобы получить "
"значение каждого аргумента (`x1` и `y1`).\n"
"Обратите внимание, что либо для несвязанной переменной, либо для переменной, "
"привязанной к самой себе, `x` будет равняться `x1` (и то же самое для `y` и "
"`y1`).\n"
"Если любая из пар значений не эквивалентна, мы должны использовать новые "
"(`x1` или `y1`), и предложение с комментарием deref делает это.\n"
"После этого мы просто рассмотрим случаи/варианты по одному.\n"
"Оказалось, что было проще немного изменить порядок, чем в предыдущей "
"таблице, но каждое предложение снабжено соответствующим номером:"

#: in/chapter12.md:810
msgid ""
"```lisp\n"
"(defun compile-unify-variable (x y bindings)\n"
"  \"X is a variable, and Y may be.\"\n"
"  (let* ((xb (follow-binding x bindings))\n"
"         (x1 (if xb (cdr xb) x))\n"
"         (yb (if (variable-p y) (follow-binding y bindings)))\n"
"         (y1 (if yb (cdr yb) y)))\n"
"    (cond                                                 ; Case:\n"
"      ((or (eq x '?) (eq y '?)) (values t bindings))      ; 12\n"
"      ((not (and (equal x x1) (equal y y1)))              ; deref\n"
"       (compile-unify x1 y1 bindings))\n"
"      ((find-anywhere x1 y1) (values nil bindings))       ; 11\n"
"      ((consp y1)                                         ; 7,10\n"
"       (values `(unify! ,x1 ,(compile-arg y1 bindings))\n"
"               (bind-variables-in y1 bindings)))\n"
"      ((not (null xb))\n"
"       ;; i.e. x is an ?arg variable\n"
"       (if (and (variable-p y1) (null yb))\n"
"           (values 't (extend-bindings y1 x1 bindings))   ; 4\n"
"           (values `(unify! ,x1 ,(compile-arg y1 bindings))\n"
"                   (extend-bindings x1 y1 bindings))))    ; 5,6\n"
"      ((not (null yb))\n"
"       (compile-unify-variable y1 x1 bindings))\n"
"      (t (values 't (extend-bindings x1 y1 bindings)))))) ; 8,9\n"
"```"
msgstr ""

#: in/chapter12.md:813
msgid ""
"Take some time to understand just how this function works.\n"
"Then go on to the following auxiliary functions:"
msgstr ""
"Найдите время, чтобы понять, как работает эта функция.\n"
"Затем переходите к следующим вспомогательным функциям:"

#: in/chapter12.md:822
msgid ""
"```lisp\n"
"(defun bind-variables-in (exp bindings)\n"
"  \"Bind all variables in exp to themselves, and add that to\n"
"  bindings (except for variables already bound).\"\n"
"  (dolist (var (variables-in exp))\n"
"    (unless (get-binding var bindings)\n"
"      (setf bindings (extend-bindings var var bindings))))\n"
"  bindings)"
msgstr ""

#: in/chapter12.md:831
msgid ""
"(defun follow-binding (var bindings)\n"
"  \"Get the ultimate binding of var according to bindings.\"\n"
"  (let ((b (get-binding var bindings)))\n"
"    (if (eq (car b) (cdr b))\n"
"        b\n"
"        (or (follow-binding (cdr b) bindings)\n"
"            b))))\n"
"```"
msgstr ""

#: in/chapter12.md:835
msgid ""
"Now we need to integrate the new `compile-unify` into the rest of the "
"compiler.\n"
"The problem is that the new version takes an extra argument and returns an "
"extra value, so all the functions that call it need to be changed.\n"
"Let's look again at the calling sequence:"
msgstr ""
"Теперь нам нужно интегрировать новый `compile-unify` в остальную часть "
"компилятора.\n"
"Проблема в том, что новая версия принимает дополнительный аргумент и "
"возвращает дополнительное значение, поэтому все вызывающие его функции "
"должны быть изменены.\n"
"Давайте еще раз посмотрим на последовательность вызовов:"

#: in/chapter12.md:846
msgid ""
"```lisp\n"
"prolog-compile\n"
"  compile-predicate\n"
"    compile-clause\n"
"      compile-body\n"
"        compile-call\n"
"        compile-arg\n"
"          compile-unify\n"
"            compile-arg\n"
"```"
msgstr ""

#: in/chapter12.md:849
msgid ""
"First, going downward, we see that `compile-arg` needs to take a binding "
"list as an argument, so that it can look up and substitute in the "
"appropriate values.\n"
"But it will not alter the binding list, so it still returns one value:"
msgstr ""
"Во-первых, спускаясь вниз, мы видим, что `compile-arg` должна принимать "
"список привязок в качестве аргумента, чтобы она могла искать и подставлять "
"соответствующие значения.\n"
"Но она не изменяет список привязок, поэтому она все равно возвращает одно "
"значение:"

#: in/chapter12.md:867
msgid ""
"```lisp\n"
"(defun compile-arg (arg bindings)\n"
"  \"Generate code for an argument to a goal in the body.\"\n"
"  (cond ((eq arg '?) '(?))\n"
"        ((variable-p arg)\n"
"         (let ((binding (get-binding arg bindings)))\n"
"           (if (and (not (null binding))\n"
"                    (not (eq arg (binding-val binding))))\n"
"             (compile-arg (binding-val binding) bindings)\n"
"             arg)))\n"
"        ((not (find-if-anywhere #'variable-p arg)) `',arg)\n"
"        ((proper-listp arg)\n"
"         `(list .,(mapcar #'(lambda (a) (compile-arg a bindings))\n"
"                          arg)))\n"
"        (t `(cons ,(compile-arg (first arg) bindings)\n"
"                  ,(compile-arg (rest arg) bindings)))))\n"
"```"
msgstr ""

#: in/chapter12.md:869
msgid ""
"Now, going upward, `compile-body` needs to take a binding list and pass it "
"on to various functions:"
msgstr ""
"Теперь, поднимаясь вверх, `compile-body` надо взять список привязок и "
"передать его различным функциям:"

#: in/chapter12.md:898
msgid ""
"```lisp\n"
"(defun compile-body (body cont bindings)\n"
"  \"Compile the body of a clause.\"\n"
"  (cond\n"
"    ((null body)\n"
"     `(funcall ,cont))\n"
"    ((eq (first body) '!)                              ;***\n"
"     `(progn ,(compile-body (rest body) cont bindings) ;***\n"
"             (return-from ,*predicate* nil)))          ;***\n"
"    (t (let* ((goal (first body))\n"
"              (macro (prolog-compiler-macro (predicate goal)))\n"
"              (macro-val (if macro\n"
"                             (funcall macro goal (rest body)\n"
"                                      cont bindings))))\n"
"        (if (and macro (not (eq macro-val :pass)))\n"
"            macro-val\n"
"            `(,(make-predicate (predicate goal)\n"
"                               (relation-arity goal))\n"
"              ,@(mapcar #'(lambda (arg)\n"
"                            (compile-arg arg bindings))\n"
"                        (args goal))\n"
"              ,(if (null (rest body))\n"
"                   cont\n"
"                   `#'(lambda ()\n"
"                        ,(compile-body\n"
"                           (rest body) cont\n"
"                           (bind-new-variables bindings goal))))))))))\n"
"```"
msgstr ""

#: in/chapter12.md:901
msgid ""
"The function `bind-new-variables` takes any variables mentioned in the goal "
"that have not been bound yet and binds these variables to themselves.\n"
"This is because the goal, whatever it is, may bind its arguments."
msgstr ""
"Функция `bind-new-variables` принимает любые переменные, упомянутые в цели, "
"которые еще не были связаны, и связывает эти переменные с собой.\n"
"Это потому, что цель, какой бы она ни была, может связывать ее аргументы."

#: in/chapter12.md:908
msgid ""
"```lisp\n"
"(defun bind-new-variables (bindings goal)\n"
"  \"Extend bindings to include any unbound variables in goal.\"\n"
"  (let ((variables (remove-if #'(lambda (v) (assoc v bindings))\n"
"                              (variables-in goal))))\n"
"    (nconc (mapcar #'self-cons variables) bindings)))"
msgstr ""

#: in/chapter12.md:911
msgid ""
"(defun self-cons (x) (cons x x))\n"
"```"
msgstr ""

#: in/chapter12.md:913
msgid ""
"One of the functions that needs to be changed to accept a binding list is "
"the compiler macro for =:"
msgstr ""
"Одна из функций, которую необходимо изменить, чтобы принять список привязки, "
"- это макрос компилятора для =:"

#: in/chapter12.md:926
msgid ""
"```lisp\n"
"(def-prolog-compiler-macro = (goal body cont bindings)\n"
"  \"Compile a goal which is a call to =.\"\n"
"  (let ((args (args goal)))\n"
"    (if (/= (length args) 2)\n"
"        :pass ;; decline to handle this goal\n"
"        (multiple-value-bind (code1 bindings1)\n"
"            (compile-unify (first args) (second args) bindings)\n"
"          (compile-if\n"
"            code1\n"
"            (compile-body body cont bindings1))))))\n"
"```"
msgstr ""

#: in/chapter12.md:928
msgid ""
"The last step upward is to change `compile-clause` so that it starts "
"everything off by passing in to `compile-body` a binding list with all the "
"parameters bound to themselves:"
msgstr ""
"Последний шаг вверх - изменить `compile-clause` так, чтобы она запускала "
"все, передавая `compile-body` список привязки со всеми параметрами, "
"привязанными к себе:"

#: in/chapter12.md:941
msgid ""
"```lisp\n"
"(defun compile-clause (parms clause cont)\n"
"  \"Transform away the head, and compile the resulting body.\"\n"
"  (bind-unbound-vars\n"
"    parms\n"
"    (compile-body\n"
"      (nconc\n"
"        (mapcar #'make-= parms (args (clause-head clause)))\n"
"        (clause-body clause))\n"
"      cont\n"
"      (mapcar #'self-cons parms))))                    ;***\n"
"```"
msgstr ""

#: in/chapter12.md:943
msgid "Finally, we can see the fruits of our efforts:"
msgstr "Наконец, мы видим плоды наших усилий:"

#: in/chapter12.md:948
msgid ""
"```lisp\n"
"(DEFUN MEMBER/2 (?ARG1 ?ARG2 CONT)\n"
"  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))\n"
"```"
msgstr ""

#: in/chapter12.md:951
msgid ""
"`    (IF (UNIFY!\n"
"?ARG2 (CONS ?ARG1 (?)))`"
msgstr ""

#: in/chapter12.md:955
msgid ""
"```lisp\n"
"            (FUNCALL CONT))\n"
"```"
msgstr ""

#: in/chapter12.md:958
msgctxt "in/chapter12.md:958"
msgid ""
"`    (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:962
msgid ""
"```lisp\n"
"    (LET ((?REST (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:965
msgctxt "in/chapter12.md:965"
msgid ""
"`        (IF (UNIFY!\n"
"?ARG2 (CONS (?) ?REST))`"
msgstr ""

#: in/chapter12.md:971
msgid ""
"```lisp\n"
"                (MEMBER/2 ?ARG1 ?REST CONT)))))\n"
"  (DEFUN LIKES/2 (?ARG1 ?ARG2 CONT)\n"
"    (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))\n"
"```"
msgstr ""

#: in/chapter12.md:974
msgid ""
"`        (IF (UNIFY!\n"
"?ARG1 'ROBIN)`"
msgstr ""

#: in/chapter12.md:977
msgid ""
"`                (IF (UNIFY!\n"
"?ARG2 'CATS)`"
msgstr ""

#: in/chapter12.md:981
msgid ""
"```lisp\n"
"                    (FUNCALL CONT)))\n"
"```"
msgstr ""

#: in/chapter12.md:984
msgctxt "in/chapter12.md:984"
msgid ""
"`        (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:987
msgid ""
"`        (IF (UNIFY!\n"
"?ARG1 'SANDY)`"
msgstr ""

#: in/chapter12.md:991
msgid ""
"```lisp\n"
"            (LIKES/2 ?ARG2 'CATS CONT))\n"
"```"
msgstr ""

#: in/chapter12.md:994
msgctxt "in/chapter12.md:994"
msgid ""
"`        (UNDO-BINDINGS!\n"
"OLD-TRAIL)`"
msgstr ""

#: in/chapter12.md:997
msgid ""
"`        (IF (UNIFY!\n"
"?ARG1 'KIM)`"
msgstr ""

#: in/chapter12.md:1002
msgid ""
"```lisp\n"
"            (LIKES/2 ?ARG2 'LEE (LAMBDA ()\n"
"                        (LIKES/2 ?ARG2 'KIM CONT))))))\n"
"```"
msgstr ""

#: in/chapter12.md:1004
msgid "## 12.5 Further Improvements to Unification"
msgstr "## 12.5 Дальнейшие улучшения унификации"

#: in/chapter12.md:1008
msgid ""
"Could `compile-unify` be improved yet again?\n"
"If we insist that it call `unify!,` it seems that it can't be made much "
"better.\n"
"However, we could improve it by in effect compiling `unify!.` This is a key "
"idea in the Warren Abstract Machine, or WAM, which is the most commonly used "
"model for Prolog compilers."
msgstr ""
"Можно ли еще раз улучшить `compile-unify`?\n"
"Если мы будем настаивать на том, чтобы он вызывал `unify!`, кажется, что его "
"нельзя сделать намного лучше.\n"
"Однако мы могли бы улучшить его, фактически скомпилировав `unify!`. Это "
"ключевая идея в абстрактной машине Уоррена, или WAM(Warren Abstract "
"Machine), которая является наиболее часто используемой моделью для "
"компиляторов Пролога."

#: in/chapter12.md:1013
msgid ""
"We call `unify!` in four cases (5, 6, 7, and 10), and in each case the first "
"argument is a variable, and we know something about the second argument.\n"
"But the first thing `unify!` does is redundantly test if the first argument "
"is a variable.\n"
"We could eliminate unnecessary tests by calling more specialized functions "
"rather than the general-purpose function `unify!`.\n"
"Consider this call:"
msgstr ""
"Мы вызываем `unify!` в четырех случаях (5, 6, 7 и 10), и в каждом случае "
"первый аргумент является переменной, и мы кое-что знаем о втором аргументе.\n"
"Но первое, что делает `unify!` - это избыточно проверяет, является ли первый "
"аргумент переменной.\n"
"Мы могли бы исключить ненужные тесты, вызвав более специализированные "
"функции, а не универсальную функцию `unify!`.\n"
"Рассмотрим этот вызов:"

#: in/chapter12.md:1016
msgid ""
"`(unify!\n"
"?arg2 (cons ?arg1 (?)))`"
msgstr ""

#: in/chapter12.md:1020
msgid ""
"If `?arg2` is an unbound variable, this code is appropriate.\n"
"But if `?arg2` is a constant atom, we should fail immediately, without "
"allowing `cons` and `?` to generate garbage.\n"
"We could change the test to:"
msgstr ""
"Если `?arg2` является несвязанной переменной, этот код подходит.\n"
"Но если `?arg2` - постоянный атом, мы должны немедленно выйти с "
"ошибкой(fail), не позволяя `cons` и `?` генерировать мусор.\n"
"Мы могли бы изменить тест на:"

#: in/chapter12.md:1024
msgid ""
"```lisp\n"
"(and (consp-or-variable-p ?arg2)\n"
"```"
msgstr ""

#: in/chapter12.md:1027
msgid ""
"`    (unify-first!\n"
"?arg2 ?arg1)`"
msgstr ""

#: in/chapter12.md:1030
msgid ""
"`    (unify-rest!\n"
"?arg2 (?)))`"
msgstr ""

#: in/chapter12.md:1034
msgid ""
"with suitable definitions for the functions referenced here.\n"
"This change should speed execution time and limit the amount of garbage "
"generated.\n"
"Of course, it makes the generated code longer, so that could slow things "
"down if the program ends up spending too much time bringing the code to the "
"processor."
msgstr ""
"с подходящими определениями упомянутых здесь функций.\n"
"Это изменение должно ускорить время выполнения и ограничить количество "
"генерируемого мусора.\n"
"Конечно, это удлиняет сгенерированный код, так что это может замедлить "
"работу, если программа в конечном итоге будет тратить слишком много времени "
"на передачу кода процессору."

#: in/chapter12.md:1039
msgid ""
"**Exercise  12.1 [h]** Write definitions for `consp-or-variable-p, unify-"
"first!,` and `unify-rest!`, and change the compiler to generate code like "
"that outlined previously.\n"
"You might want to look at the function `compile-rule` in [section 9.6]"
"(B9780080571157500091.xhtml#s0035), starting on [page 300]"
"(B9780080571157500091.xhtml#p300).\n"
"This function compiled a call to `pat-match` into individual tests; now we "
"want to do the same thing to `unify!`.\n"
"Run some benchmarks to compare the altered compiler to the original version."
msgstr ""
"** Упражнение 12.1 [h] ** Напишите определения для `consp-or-variable-p, "
"unify-first!` и `unify-rest!`, и измените компилятор для генерации кода, "
"подобного описанному ранее.\n"
"Вы можете посмотреть функцию `compile-rule` в [раздел 9.6]"
"(B9780080571157500091.xhtml#s0035), начиная с [страницы 300] "
"(B9780080571157500091.xhtml#p300).\n"
"Эта функция скомпилировала вызов `pat-match` в отдельные тесты; теперь мы "
"хотим сделать то же самое для `unify!`.\n"
"Выполните несколько тестов, чтобы сравнить измененный компилятор с исходной "
"версией."

#: in/chapter12.md:1042
msgid ""
"**Exercise  12.2 [h]** We can gain some more efficiency by keeping track of "
"which variables have been dereferenced and calling an appropriate "
"unification function: either one that dereferences the argument or one that "
"assumes the argument has already been dereferenced.\n"
"Implement this approach."
msgstr ""

#: in/chapter12.md:1045
msgid ""
"**Exercise  12.3 [m]** What code is generated for `(= (f (g ?x) ?y) (f ?y (?"
"p a)))?`What more efficient code represents the same unification?\n"
"How easy is it to change the compiler to get this more efficient result?"
msgstr ""
"**Упражнение 12.3 [m]** Какой код создается для `(= (f (g ?x) ?y) (f ?y (?p "
"a)))?` Какой более эффективный код представляет ту же унификацию?\n"
"Насколько легко изменить компилятор, чтобы получить более эффективный "
"результат?"

#: in/chapter12.md:1051
msgid ""
"**Exercise  12.4 [h]** In retrospect, it seems that binding variables to "
"themselves, as in `(?argl . ?argl`), was not such a good idea.\n"
"It complicates the meaning of bindings, and prohibits us from using existing "
"tools.\n"
"For example, I had to use `find-anywhere` instead of `occur-check` for case "
"11, because `occur-check` expects a noncircular binding list.\n"
"But find-anywhere does not do as complete a job as `occur-check`.\n"
"Write a version of `compile-unify` that returns three values: the code, a "
"noncircular binding list, and a list of variables that are bound to unknown "
"values."
msgstr ""
"**Упражнение 12.4 [h]** Оглядываясь назад, кажется, что привязка переменных "
"к самим себе, как в `(?argl . ?argl`), была не такой уж хорошей идеей.\n"
"Это усложняет значение привязок и запрещает нам использовать существующие "
"инструменты.\n"
"Например, для случая 11 мне пришлось использовать `find-anywhere` вместо "
"`occur-check`, потому что `occur-check` ожидает незацикленный список "
"привязок.\n"
"Но функция find-anywhere не так хорошо выполняет свою работу, как `occur-"
"check`.\n"
"Напишите версию `compile-unify`, которая возвращает три значения: код, "
"незацикленный список привязки и список переменных, которые привязаны к "
"неизвестным значениям."

#: in/chapter12.md:1059
msgid ""
"**Exercise  12.5 [h]** An alternative to the previous exercise is not to use "
"binding lists at ail.\n"
"Instead, we could pass in a list of equivalence classes-that is, a list of "
"lists, where each sublist contains one or more elements that have been "
"unified.\n"
"In this approach, the initial equivalence class list would be `((?arg1) (?"
"arg2))`.\n"
"After unifying `?arg1` with `?x`, `?arg2` with `?y`, and `?x` with 4, the "
"list would be ( `(4 ?arg1 ?x) (?arg2 ?y))`.\n"
"This assumes the convention that the canonical member of an equivalence "
"class (the one that will be substituted for all others) comes first.\n"
"Implement this approach.\n"
"What advantages and disadvantages does it have?"
msgstr ""
"**Упражнение 12.5 [h]** Альтернативой предыдущему упражнению является отказ "
"от использования списков привязки во всех случаях.\n"
"Вместо этого мы могли бы передать список классов эквивалентности, то есть "
"список списков, где каждый подсписок содержит один или несколько элементов, "
"которые были объединены/унифицированы.\n"
"При таком подходе начальный список классов эквивалентности будет `((?arg1) (?"
"arg2))`.\n"
"После объединения/унификации `?arg1` с `?x`, `?arg2` с `?arg2` и `?x` с 4, "
"список будет ( `(4 ?arg1 ?x) (?arg2 ?y))`.\n"
"Это предполагает соглашение о том, что канонический член класса "
"эквивалентности (тот, который будет заменен всеми остальными) идет первым.\n"
"Реализуйте этот подход.\n"
"Какие у него преимущества и недостатки?"

#: in/chapter12.md:1061
msgid "## 12.6 The User Interface to the Compiler"
msgstr "## 12.6 Пользовательский интерфейс для компилятора"

#: in/chapter12.md:1068
msgid ""
"The compiler can translate Prolog to Lisp, but that does us no good unless "
"we can conveniently arrange to compile the right Prolog relations and call "
"the right Lisp functions.\n"
"In other words, we have to integrate the compiler with the `<-` and `?` "
"macros.\n"
"Surprisingly, we don't need to change these macros at all.\n"
"Rather, we will change the functions these macros call.\n"
"When a new clause is entered, we will enter the clause's predicate in the "
"list `*uncompiled*`.\n"
"This is a one-line addition to `add-clause:`"
msgstr ""
"Компилятор может преобразовывать Пролог в Лисп, но это не принесет нам "
"пользы, если мы не сможем удобно организовать компиляцию правильных "
"отношений Пролога и вызвать правильные функции Лиспа.\n"
"Другими словами, мы должны интегрировать компилятор с макросами `<-` и `?`.\n"
"Удивительно, но нам вообще не нужно менять эти макросы.\n"
"Вместо этого мы изменим функции, которые вызывают эти макросы.\n"
"Когда вводится новое предложение, мы вводим предикат предложения в список "
"`*uncompiled*`.\n"
"Это однострочное дополнение к `add-clause:`"

#: in/chapter12.md:1072
msgid ""
"```lisp\n"
"(defvar *uncompiled* nil\n"
"  \"Prolog symbols that have not been compiled.\")"
msgstr ""

#: in/chapter12.md:1084
msgid ""
"(defun add-clause (clause)\n"
"  \"Add a clause to the data base, indexed by head's predicate.\"\n"
"  ;; The predicate must be a non-variable symbol.\n"
"  (let ((pred (predicate (clause-head clause))))\n"
"    (assert (and (symbolp pred) (not (variable-p pred))))\n"
"    (pushnew pred *db-predicates*)\n"
"    (pushnew pred *uncompiled*)                          ;***\n"
"    (setf (get pred 'clauses)\n"
"          (nconc (get-clauses pred) (list clause)))\n"
"    pred))\n"
"```"
msgstr ""

#: in/chapter12.md:1087
msgid ""
"Now when a query is made, the ?- macro expands into a call to `top-level-"
"prove.` The list of goals in the query, along with the `show-prolog-vars` "
"goal, is added as the sole clause for the relation `top-level-query.` Next, "
"that query, along with any others that are on the uncompiled list, are "
"compiled.\n"
"Finally, the newly compiled top-level query function is called."
msgstr ""
"Теперь, когда делается запрос, макрос `?-` заменяется вызовом `top-level-"
"proof`. Список целей в запросе вместе с целью `show-prolog-vars` добавляется "
"в качестве единственного предложения. для отношения `top-level-query`. Затем "
"этот запрос, вместе с любыми другими, которые находятся в некомпилированном "
"списке, компилируется.\n"
"Наконец, вызывается вновь скомпилированная функция запроса верхнего уровня."

#: in/chapter12.md:1102
msgid ""
"```lisp\n"
"(defun top-level-prove (goals)\n"
"  \"Prove the list of goals by compiling and calling it.\"\n"
"  ;; First redefine top-level-query\n"
"  (clear-predicate 'top-level-query)\n"
"  (let ((vars (delete '? (variables-in goals))))\n"
"    (add-clause `((top-level-query)\n"
"                  ,@goals\n"
"                  (show-prolog-vars ,(mapcar #'symbol-name vars)\n"
"                                    ,vars))))\n"
"  ;; Now run it\n"
"  (run-prolog 'top-level-query/0 #'ignore)\n"
"  (format t \"~&No.\")\n"
"  (values))"
msgstr ""

#: in/chapter12.md:1113
msgid ""
"(defun run-prolog (procedure cont)\n"
"  \"Run a 0-ary prolog procedure with a given continuation.\"\n"
"  ;; First compile anything else that needs it\n"
"  (prolog-compile-symbols)\n"
"  ;; Reset the trail and the new variable counter\n"
"  (setf (fill-pointer *trail*) 0)\n"
"  (setf *var-counter* 0)\n"
"  ;; Finally, call the query\n"
"  (catch 'top-level-prove\n"
"    (funcall procedure cont)))"
msgstr ""

#: in/chapter12.md:1119
msgid ""
"(defun prolog-compile-symbols (&optional (symbols *uncompiled*))\n"
"  \"Compile a list of Prolog symbols.\n"
"  By default, the list is all symbols that need it.\"\n"
"  (mapc #'prolog-compile symbols)\n"
"  (setf *uncompiled* (set-difference *uncompiled* symbols)))"
msgstr ""

#: in/chapter12.md:1124
msgid ""
"(defun ignore (&rest args)\n"
"  (declare (ignore args))\n"
"  nil)\n"
"```"
msgstr ""

#: in/chapter12.md:1128
msgid ""
"Note that at the top level, we don't need the continuation to do anything.\n"
"Arbitrarily, we chose to pass in the function `ignore`, which is defined to "
"ignore its arguments.\n"
"This function is useful in a variety of places; some programmers will "
"proclaim it inline and then use a call to `ignore` in place of an ignore "
"declaration:"
msgstr ""
"Обратите внимание, что на верхнем уровне нам не нужно продолжение, чтобы что-"
"то делать.\n"
"Произвольно мы решили передать функцию `ignore`, которая определена так, "
"чтобы игнорировать свои аргументы.\n"
"Эта функция полезна во многих местах; некоторые программисты объявляют её "
"встроенной и затем используют вызов `ignore` вместо объявления(декларации) "
"ignore:"

#: in/chapter12.md:1134
msgid ""
"```lisp\n"
"(defun third-arg (x y z)\n"
"  (ignore x y)\n"
"  z)\n"
"```"
msgstr ""

#: in/chapter12.md:1141
msgid ""
"The compiler's calling convention is different from the interpreter, so the "
"primitives need to be redefined.\n"
"The old definition of the primitive `show-prolog-vars` had three parameters: "
"the list of arguments to the goal, a binding list, and a list of pending "
"goals.\n"
"The new definition of `show-prolog-vars/2` also has three parameters, but "
"that is just a coincidence.\n"
"The first two parameters are the two separate arguments to the goal: a list "
"of variable names and a list of variable values.\n"
"The last parameter is a continuation function.\n"
"To continue, we call that function, but to fail, we throw to the catch point "
"set up in `top-level-prove`."
msgstr ""
"Соглашение о вызовах компилятора отличается от интерпретатора, поэтому "
"необходимо переопределить примитивы.\n"
"Старое определение примитива `show-prolog-vars` имело три параметра: список "
"аргументов цели, список привязки и список ожидающих целей.\n"
"Новое определение `show-prolog-vars/2` также имеет три параметра, но это "
"просто совпадение.\n"
"Первые два параметра - это два отдельных аргумента цели: список имен "
"переменных и список значений переменных.\n"
"Последний параметр - функция продолжение.\n"
"Чтобы продолжить, мы вызываем эту функцию, но в случае неудачи мы переходим "
"к точке перехвата, установленной в `top-level-prove`."

#: in/chapter12.md:1154
msgid ""
"```lisp\n"
"(defun show-prolog-vars/2 (var-names vars cont)\n"
"  \"Display the variables, and prompt the user to see\n"
"  if we should continue.  If not, return to the top level.\"\n"
"  (if (null vars)\n"
"      (format t \"~&Yes\")\n"
"      (loop for name in var-names\n"
"            for var in vars do\n"
"            (format t \"~&~a = ~a\" name (deref-exp var))))\n"
"  (if (continue-p)\n"
"      (funcall cont)\n"
"      (throw 'top-level-prove nil)))"
msgstr ""

#: in/chapter12.md:1164
msgid ""
"(defun deref-exp (exp)\n"
"  \"Build something equivalent to EXP with variables dereferenced.\"\n"
"  (if (atom (deref exp))\n"
"      exp\n"
"      (reuse-cons\n"
"        (deref-exp (first exp))\n"
"        (deref-exp (rest exp))\n"
"        exp)))\n"
"```"
msgstr ""

#: in/chapter12.md:1166
msgid ""
"With these definitions in place, we can invoke the compiler automatically "
"just by making a query with the ? - macro."
msgstr ""
"Имея эти определения, мы можем вызвать компилятор автоматически, просто "
"сделав запрос с макросом ?-."

#: in/chapter12.md:1173
msgid ""
"**Exercise 12.6 [m]** Suppose you define a predicate `p`, which calls `q`, "
"and then define `q`.\n"
"In some implementations of Lisp, when you make a query like `(?\n"
"- (p ?x))`, you may get a warning message like `\"function q/1 undefined\"` "
"before getting the correct answer.\n"
"The problem is that each function is compiled separately, so warnings "
"detected during the compilation of `p/1` will be printed right away, even if "
"the function `q/1` will be defined later.\n"
"In ANSI Common Lisp there is a way to delay the printing of warnings until a "
"series of compilations are done: wrap the compilation with the macro `with-"
"compi`l`ation-unit.` Even if your implementation does not provide this "
"macro, it may provide the same functionality under a different name.\n"
"Find out if `with-compilation-unit` is already defined in your "
"implementation, or if it can be defined."
msgstr ""
"**Упражнение 12.6 [m]** Предположим, вы определяете предикат `p`, который "
"вызывает `q`, а затем определяете `q`.\n"
"В некоторых реализациях Lisp, когда вы делаете запрос типа `(?- (p? x)) `, "
"вы можете получить предупреждающее сообщение типа `\"function q/1 undefined"
"\"` перед получением правильного ответа.\n"
"Проблема в том, что каждая функция компилируется отдельно, поэтому "
"предупреждения, обнаруженные во время компиляции `p/1`, будут выводиться "
"сразу, даже если функция `q/1` будет определена позже.\n"
"В ANSI Common Lisp есть способ отложить вывод предупреждений до тех пор, "
"пока не будет выполнена серия компиляций: завершите компиляцию макросом "
"`with-compilation-unit`. Даже если ваша реализация не предоставляет этот "
"макрос, он может предоставлять те же функции под другим именем.\n"
"Выясните, определен ли уже в вашей реализации `with-compilation-unit` или "
"его можно определить."

#: in/chapter12.md:1175
msgid "## 12.7 Benchmarking the Compiler"
msgstr "## 12.7 Тестирование компилятора"

#: in/chapter12.md:1177
msgid ""
"Our compiled Prolog code runs the zebra puzzle in 17.4 seconds, a 16-fold "
"speed-up over the interpreted version, for a rate of 740 LIPS."
msgstr ""
"Наш скомпилированный код Prolog запускает головоломку зебра за 17,4 секунды, "
"что в 16 раз больше, чем у интерпретированной версии, со скоростью 740 LIPS."

#: in/chapter12.md:1179
msgid ""
"Another popular benchmark is Lisp's reverse function, which we can code as "
"the rev relation:"
msgstr ""
"Другой популярный тест - это обратная функция Lisp, которую мы можем "
"закодировать как отношение rev:"

#: in/chapter12.md:1186
msgid ""
"```lisp\n"
"(<- (rev () ()))\n"
"(<- (rev (?x . ?a) ?b) (rev ?a ?c) (concat ?c (?x) ?b))\n"
"(<- (concat () ?1 ?1)\n"
"(<- (concat (?x . ?a) ?b (?x . ?c)) (concat ?a ?b ?c))\n"
"```"
msgstr ""

#: in/chapter12.md:1190
msgid ""
"rev uses the relation concat, which stands for concatenation, (`concat ?a ?"
"b ?c`)is true when `?a` concatenated to `?b` yields `?c`.\n"
"This relationlike name is preferred over more procedural names like append.\n"
"But `rev` is very similar to the following Lisp definitions:"
msgstr ""
"rev использует отношение concat, которое означает конкатенацию, (`concat ?a ?"
"b ?c`) истинно, когда `?a`, объединенное с `?b`, дает `?c`.\n"
"Это родственное имя предпочтительнее других процедурных имен, таких как "
"append.\n"
"Но `rev` очень похож на следующие определения Лиспа:"

#: in/chapter12.md:1197
msgid ""
"```lisp\n"
"(defun rev (1)\n"
"  (if (null 1)\n"
"    nil\n"
"    (app (rev (rest 1 ))\n"
"        (list (first 1)))))"
msgstr ""

#: in/chapter12.md:1204
msgid ""
"(defun app (x y)\n"
"  (if (null x)\n"
"    y\n"
"      (cons (first x)\n"
"        (app (rest x) y))))\n"
"```"
msgstr ""

#: in/chapter12.md:1207
msgid ""
"Both versions are inefficient.\n"
"It is possible to write an iterative version of `reverse` that does no extra "
"consing and is tail-recursive:"
msgstr ""
"Обе версии неэффективны.\n"
"Можно написать итеративную версию `reverse`, которая не требует "
"дополнительных затрат и является хвосто-рекурсивной:"

#: in/chapter12.md:1213
msgid ""
"```lisp\n"
"(<- (irev ?l ?r) (irev3 ?l () ?r))\n"
"(<- (irev3 (?x . ?l) ?so-far ?r) (irev3 ?l (?x . ?so-far) ?r))\n"
"(<- (irev3 () ?r ?r))\n"
"```"
msgstr ""

#: in/chapter12.md:1215
msgid "The Prolog `irev` is equivalent to this Lisp program:"
msgstr "Пролог `irev` эквивалентен этой программе на Лиспе:"

#: in/chapter12.md:1218
msgid ""
"```lisp\n"
"(defun irev (list) (irev2 list nil))"
msgstr ""

#: in/chapter12.md:1224
msgid ""
"(defun irev2 (list so-far)\n"
"  (if (consp list)\n"
"      (irev2 (rest list) (cons (first list) so-far))\n"
"      so-far))\n"
"```"
msgstr ""

#: in/chapter12.md:1227
msgid ""
"The following table shows times in seconds to execute these routines on "
"lists of length 20 and 100, for both Prolog and Lisp, both interpreted and "
"compiled.\n"
"(Only compiled Lisp could execute rev on a 100-element list without running "
"out of stack space.) Times for the zebra puzzle are also included, although "
"there is no Lisp version of this program."
msgstr ""
"В следующей таблице показано время в секундах для выполнения этих "
"подпрограмм в списках длиной 20 и 100, как для Пролога, так и для Лиспа, как "
"интерпретируемых, так и скомпилированных.\n"
"(Только скомпилированный Lisp может выполнить rev для списка из 100 "
"элементов, не исчерпывая пространства стека.) Также включены времена для "
"головоломки \"зебра\", хотя версии этой программы на Lisp не существует."

#: in/chapter12.md:1235
msgid ""
"| Problem    | Interp. Prolog | Comp. Prolog | Speed-up | Interp. Lisp | "
"Comp. Lisp |\n"
"|------------|----------------|--------------|----------|--------------|------------|\n"
"| `zebra`    | 278.000        | 17.241       | 16       | -            | "
"-          |\n"
"| `rev 20`   | 4.24           | .208         | 20       | .241         "
"| .0023      |\n"
"| `rev 100`  | -              | -            | -        | -            "
"| .0614      |\n"
"| `irev 20`  | .22            | .010         | 22       | .028         "
"| .0005      |\n"
"| `irev 100` | 9.81           | .054         | 181      | .139         "
"| .0014      |"
msgstr ""

#: in/chapter12.md:1238
msgid ""
"This benchmark is too small to be conclusive, but on these examples the "
"Prolog compiler is 16 to 181 times faster than the Prolog interpreter, "
"slightly faster than interpreted Lisp, but still 17 to 90 times slower than "
"compiled Lisp.\n"
"This suggests that the Prolog interpreter cannot be used as a practical "
"programming tool, but the Prolog compiler can."
msgstr ""
"Этот тест слишком мал, чтобы быть окончательным, но в этих примерах "
"компилятор Prolog в 16–181 раз быстрее интерпретатора Prolog, немного "
"быстрее, чем интерпретируемый Lisp, но все же в 17–90 раз медленнее, чем "
"скомпилированный Lisp.\n"
"Это говорит о том, что интерпретатор Пролога не может использоваться в "
"качестве практического инструмента программирования, но компилятор Пролога "
"может."

#: in/chapter12.md:1243
msgid ""
"Before moving on, it is interesting to note that Prolog provides for "
"optional arguments automatically.\n"
"Although there is no special syntax for optional arguments, an often-used "
"convention is to have two versions of a relation, one with *n* arguments and "
"one with *n -* 1.\n"
"A single clause for the *n -* 1 case provides the missing, and therefore "
"\"optional,\" argument.\n"
"In the following example, `irev/2` can be considered as a version of "
"`irev/3` where the missing optional argument is ()."
msgstr ""
"Прежде чем двигаться дальше, интересно отметить, что Пролог автоматически "
"предоставляет необязательные аргументы.\n"
"Хотя не существует специального синтаксиса для необязательных аргументов, "
"часто используется соглашение о наличии двух версий отношения: одной с *n* "
"аргументами и одной с *n -* 1.\n"
"Единственное предложение для случая *n -* 1 обеспечивает отсутствующий и, "
"следовательно, \"необязательный\" аргумент.\n"
"В следующем примере `irev/2` можно рассматривать как версию `irev/3`, в "
"которой отсутствует необязательный аргумент ()."

#: in/chapter12.md:1249
msgid ""
"```lisp\n"
"(<- (irev ?l ?r) (irev ?l () ?r))\n"
"(<- (irev (?x . ?l ) ?so-far ?r) (irev ?l (?x . ?so-far) ?r))\n"
"(<- (irev () ?r ?r))\n"
"```"
msgstr ""

#: in/chapter12.md:1251
msgid "This is roughly equivalent to the following Lisp verison:"
msgstr "Это примерно эквивалентно следующей версии Лиспа:"

#: in/chapter12.md:1258
msgid ""
"```lisp\n"
"(defun irev (list &optional (so-far nil))\n"
"  (if (consp list)\n"
"      (irev (rest list) (cons (first list) so-far))\n"
"      so-far))\n"
"```"
msgstr ""

#: in/chapter12.md:1260
msgid "## 12.8 Adding More Primitives"
msgstr "## 12.8 Добавление дополнительных примитивов"

#: in/chapter12.md:1265
msgid ""
"Just as a Lisp compiler needs machine instructions to do input/output, "
"arithmetic, and the like, so our Prolog system needs to be able to perform "
"certain primitive actions.\n"
"For the Prolog interpreter, primitives were implemented by function "
"symbols.\n"
"When the interpreter went to fetch a list of clauses, if it got a function "
"instead, it called that function, passing it the arguments to the current "
"relation, the current bindings, and a list of unsatisfied goals.\n"
"For the Prolog compiler, primitives can be installed simply by writing a "
"Lisp function that respects the convention of taking a continuation as the "
"final argument and has a name of the form *symbol/arity.* For example, "
"here's an easy way to handle input and output:"
msgstr ""
"Точно так же, как компилятору Lisp нужны машинные инструкции для ввода/"
"вывода, арифметики и т.п., наша система Prolog должна иметь возможность "
"выполнять определенные примитивные действия.\n"
"Для интерпретатора Пролога примитивы были реализованы с помощью символов "
"функций.\n"
"Когда интерпретатор отправлялся за списком предложений, если вместо этого он "
"получал функцию, он вызывал эту функцию, передавая ей аргументы в текущее "
"отношение, текущие привязки и список неудовлетворенных целей.\n"
"Для компилятора Prolog примитивы могут быть установлены просто путем "
"написания функции Lisp, которая соблюдает соглашение о принятии продолжения "
"в качестве последнего аргумента и имеет имя в форме *symbol/arity*(символ/"
"аность) Например, вот простой способ обработки ввода и вывод:"

#: in/chapter12.md:1269
msgid ""
"```lisp\n"
"(defun read/1 (exp cont)\n"
"```"
msgstr ""

#: in/chapter12.md:1272
msgid ""
"`  (if (unify!\n"
"exp (read))`"
msgstr ""

#: in/chapter12.md:1279
msgid ""
"```lisp\n"
"      (funcall cont)))\n"
"(defun write/1 (exp cont)\n"
"  (write (deref-exp exp) :pretty t)\n"
"  (funcall cont))\n"
"```"
msgstr ""

#: in/chapter12.md:1287
msgid ""
"Calling `(write ?x)` will always succeed, so the continuation will always be "
"called.\n"
"Similarly, one could use `(read ?x)` to read a value and unify it with `?"
"x`.\n"
"If `?x` is unbound, this is the same as assigning the value.\n"
"However, it is also possible to make a call like `(read (?x + ?y))`, which "
"succeeds only if the input is a three-element list with + in the middle.\n"
"It is an easy extension to define `read/2` and `write/2` as relations that "
"indicate what stream to use.\n"
"To make this useful, one would need to define `open/2` as a relation that "
"takes a pathname as one argument and gives a stream back as the other.\n"
"Other optional arguments could also be supported, if desired."
msgstr ""
"Вызов `(write ?x)` всегда будет успешным, поэтому всегда будет вызываться "
"продолжение.\n"
"Точно так же можно использовать `(read ?x)` для чтения значения и "
"объединения/унификации его с `?x`.\n"
"Если `?x` не связан, это то же самое, что присвоение значения.\n"
"Однако также можно выполнить вызов типа `(read (?x + ?y))`, который будет "
"успешным только в том случае, если вход представляет собой список из трех "
"элементов с + в середине.\n"
"Это простое расширение для определения `read/2` и `write/2` как отношений, "
"указывающих, какой поток использовать.\n"
"Чтобы сделать это полезным, нужно определить `open/2` как отношение, которое "
"принимает pathname(путь) в качестве одного аргумента и возвращает поток в "
"качестве другого.\n"
"При желании могут поддерживаться и другие необязательные аргументы."

#: in/chapter12.md:1289
msgid "The primitive nl outputs a newline:"
msgstr "Примитив nl выводит новую строку:"

#: in/chapter12.md:1293
msgid ""
"```lisp\n"
"(defun nl/0 (cont) (terpri) (funcall cont))\n"
"```"
msgstr ""

#: in/chapter12.md:1296
msgid ""
"We provided special support for the unification predicate, =.\n"
"However, we could have simplified the compiler greatly by having a simple "
"definition for `=/2`:"
msgstr ""
"Мы предоставили специальную поддержку для предиката унификации, =.\n"
"Однако мы могли бы значительно упростить компилятор, имея простое "
"определение для `=/2`:"

#: in/chapter12.md:1300
msgid ""
"```lisp\n"
"(defun =/2 (?arg1 ?arg2 cont)\n"
"```"
msgstr ""

#: in/chapter12.md:1303
msgid ""
"`  (if (unify!\n"
"?arg1 ?arg2)`"
msgstr ""

#: in/chapter12.md:1307
msgid ""
"```lisp\n"
"    (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:1309
msgid "In fact, if we give our compiler the single clause:"
msgstr ""
"Фактически, если мы дадим нашему компилятору единственное предложение:\n"

#: in/chapter12.md:1311
msgid "(<- (= ?x `?x))`"
msgstr ""

#: in/chapter12.md:1318
msgid ""
"it produces just this code for the definition of `=/ 2`.\n"
"There are other equality predicates to worry about.\n"
"The predicate `= =/2` is more like equal in Lisp.\n"
"It does no unification, but instead tests if two structures are equal with "
"regard to their elements.\n"
"A variable is considered equal only to itself.\n"
"Here's an implementation:"
msgstr ""
"он производит именно этот код для определения `=/ 2`.\n"
"Есть и другие предикаты равенства, о которых стоит побеспокоиться.\n"
"Предикат `= =/2` больше похож на equal в Лиспе.\n"
"Он не объединяет/унифицирует, а вместо этого проверяет равенство двух "
"структур по своим элементам.\n"
"Переменная считается равной(equal) только самой себе.\n"
"Вот реализация:"

#: in/chapter12.md:1323
msgid ""
"```lisp\n"
"(defun =/2 (?arg1 ?arg2 cont)\n"
"  \"Are the two arguments EQUAL with no unification,\n"
"```"
msgstr ""

#: in/chapter12.md:1326
msgid ""
"`  but with dereferencing?\n"
"If so, succeed.\"`"
msgstr ""
"`но с разыменованием?\n"
"Если так, то получится. \""

#: in/chapter12.md:1339
msgid ""
"```lisp\n"
"  (if (deref-equal ?arg1 ?arg2)\n"
"    (funcall cont)))\n"
"(defun deref-equal (x y)\n"
"  \"Are the two arguments EQUAL with no unification,\n"
"  but with dereferencing?\"\n"
"  (or (eql (deref x) (deref y))\n"
"    (and (consp x)\n"
"      (consp y)\n"
"      (deref-equal (first x) (first y))\n"
"      (deref-equal (rest x) (rest y)))))\n"
"```"
msgstr ""

#: in/chapter12.md:1342
msgid ""
"One of the most important primitives is `call`.\n"
"Like `funcall` in Lisp, `call` allows us to build up a goal and then try to "
"prove it."
msgstr ""
"Один из самых важных примитивов - это `call`.\n"
"Как и `funcall` в Лиспе, `call` позволяет нам создать цель, а затем "
"попытаться ее доказать."

#: in/chapter12.md:1351
msgid ""
"```lisp\n"
"(defun call/1 (goal cont)\n"
"  \"Try to prove goal by calling it.\"\n"
"  (deref goal)\n"
"  (apply (make-predicate (first goal)\n"
"          (length (args goal)))\n"
"      (append (args goal) (list cont))))\n"
"```"
msgstr ""

#: in/chapter12.md:1354
msgid ""
"This version of `call` will give a run-time error if the goal is not "
"instantiated to a list whose first element is a properly defined predicate; "
"one might want to check for that, and fail silently if there is no defined "
"predicate.\n"
"Here's an example of `call` where the goal is legal:"
msgstr ""
"Эта версия `call` выдаст ошибку времени выполнения, если цель не "
"инстанцируется для списка, первый элемент которого является правильно "
"определенным предикатом; можно проверить это и молча потерпеть неудачу, если "
"нет определенного предиката.\n"
"Вот пример call, в котором цель законна:"

#: in/chapter12.md:1365
msgid ""
"```lisp\n"
"> (?- (= ?p member) (call (?p ?x (a b c))))\n"
"?P = MEMBER\n"
"?X = A;\n"
"?P = MEMBER\n"
"?X = B;\n"
"?P = MEMBER\n"
"?X = C;\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1368
msgid ""
"Now that we have `call`, a lot of new things can be implemented.\n"
"Here are the logical connectives and and or:"
msgstr ""
"Теперь, когда у нас есть `call`, можно реализовать много нового.\n"
"Вот логические связки and и or:"

#: in/chapter12.md:1374
msgid ""
"```lisp\n"
"(<- (or ?a ?b) (call ?a))\n"
"(<- (or ?a ?b) (call ?b))\n"
"(<- (and ?a ?b) (call ?a) (call ?b))\n"
"```"
msgstr ""

#: in/chapter12.md:1378
msgid ""
"Note that these are only binary connectives, not the *n*-ary special forms "
"used in Lisp.\n"
"Also, this definition negates most of the advantage of compilation.\n"
"The goals inside an and or or will be interpreted by `call`, rather than "
"being compiled."
msgstr ""
"Обратите внимание, что это только бинарные связки, а не *n*-арные "
"специальные формы, используемые в Лиспе.\n"
"Кроме того, это определение сводит на нет большую часть преимуществ "
"компиляции.\n"
"Цели внутри and или or будут интерпретироваться с помощью `call`, а не "
"компилироваться."

#: in/chapter12.md:1384
msgid ""
"We can also define `not,` or at least the normal Prolog `not,` which is "
"quite distinct from the logical `not.`\n"
"In fact, in some dialects, `not` is written \\+, which is supposed to be "
"&#x22AC;, that is, \"can not be derived.\"\n"
"The interpretation is that if goal G can not be proved, then (`not G` ) is "
"true.\n"
"Logically, there is a difference between (`not G` ) being true and being "
"unknown, but ignoring that difference makes Prolog a more practical "
"programming language.\n"
"See [Lloyd 1987](B9780080571157500285.xhtml#bb0745) for more on the formal "
"semantics of negation in Prolog."
msgstr ""
"Мы также можем определить `not` или, по крайней мере, нормальный Пролог "
"`not`, который сильно отличается от логического `not`.\n"
"Фактически, в некоторых диалектах `not` пишется \\+, что предполагается как "
"&#x22AC;, то есть \"не может быть производным\".\n"
"Интерпретация состоит в том, что если цель G не может быть доказана, то "
"(`not G`) истинно.\n"
"Логически существует разница между истинным и неизвестным (`not G`), но "
"игнорирование этой разницы делает Prolog более практичным языком "
"программирования.\n"
"См. [Lloyd 1987](B9780080571157500285.xhtml#bb0745) для получения "
"дополнительной информации о формальной семантике отрицания в Прологе."

#: in/chapter12.md:1387
msgid ""
"Here's an implementation of `not/1`.\n"
"Since it has to manipulate the trail, and we may have other predicates that "
"will want to do the same, we'll package up what was done in `maybe-add-undo-"
"bindings` into the macro `with-undo-bindings:`"
msgstr ""
"Вот реализация `not/1`.\n"
"Поскольку он должен управлять trail, и у нас могут быть другие предикаты, "
"которые захотят сделать то же самое, мы упакуем то, что было сделано в "
"`might-add-undo-bindings` в макрос `with-undo-bindings:`"

#: in/chapter12.md:1397
msgid ""
"```lisp\n"
"(defmacro with-undo-bindings (&body body)\n"
"  \"Undo bindings after each expression in body except the last.\"\n"
"  (if (length=1 body)\n"
"    (first body)\n"
"    '(let ((old-trail (fill-pointer *trail*)))\n"
"      ,(first body)\n"
"        ,@(loop for exp in (rest body)\n"
"```"
msgstr ""

#: in/chapter12.md:1400
msgid ""
"`                collect '(undo-bindings!\n"
"old-trail)`"
msgstr ""

#: in/chapter12.md:1405
msgid ""
"```lisp\n"
"                collect exp))))\n"
"(defun not/1 (relation cont)\n"
"```"
msgstr ""

#: in/chapter12.md:1408
msgid ""
"`  \"Negation by failure: If you can't prove G.\n"
"then (not G) true.\"`"
msgstr ""
"`\"Отрицание неудачей: Если вы не можете доказать, что G.\n"
"тогда (not G) верно\"`."

#: in/chapter12.md:1415
msgid ""
"```lisp\n"
"  ;; Either way, undo the bindings.\n"
"  (with-undo-bindings\n"
"    (call/1 relation #'(lambda () (return-from not/1 nil)))\n"
"    (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:1417
msgid "Here's an example where `not` works fine:"
msgstr "Вот пример, когда `not` работает нормально:"

#: in/chapter12.md:1424
msgid ""
"```lisp\n"
"> (?- (member ?x (a b c)) (not (= ?x b)))\n"
"?X = A;\n"
"?X = C;\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1426
msgid "Now see what happens when we simply reverse the order of the two goals:"
msgstr ""
"Теперь посмотрим, что произойдет, если мы просто изменим порядок двух целей:"

#: in/chapter12.md:1431
msgid ""
"```lisp\n"
"> (?- (not (= ?x b)) (member ?x (a b c)))\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1435
msgid ""
"The first example succeeds unless `?x` is bound to `b.` In the second "
"example, `?x` is unbound at the start, so `(= ?x b )` succeeds, the not "
"fails, and the `member` goal is never reached.\n"
"So our implementation of `not` has a consistent procedural interpretation, "
"but it is not equivalent to the declarative interpretation usually given to "
"logical negation.\n"
"Normally, one would expect that `a` and `c` would be valid solutions to the "
"query, regardless of the order of the goals."
msgstr ""
"Первый пример завершается успешно, если только `?x` не привязан к `b`. Во "
"втором примере `?x` не cвязан в начале, поэтому `(= ?x b )` завершается "
"успешно, not терпит неудачу и `member` цель никогда не достигается.\n"
"Таким образом, наша реализация `not` имеет последовательную процедурную "
"интерпретацию, но она не эквивалентна декларативной интерпретации, обычно "
"применяемой для логического отрицания.\n"
"Обычно можно было бы ожидать, что `a` и `c` будут допустимыми решениями "
"запроса, независимо от порядка целей."

#: in/chapter12.md:1448
msgid ""
"One of the fundamental differences between Prolog and Lisp is that Prolog is "
"relational: you can easily express individual relations.\n"
"Lisp, on the other hand, is good at expressing collections of things as "
"lists.\n"
"So far we don't have any way of forming a collection of objects that satisfy "
"a relation in Prolog.\n"
"We can easily iterate over the objects; we just can't gather them together.\n"
"The primitive `bagof` is one way of doing the collection.\n"
"In general, `(bagof ?x (p ?x) ?bag)` unifies `?bag` with a list of all `?"
"x's` that satisfy `(p ?x)`.\n"
"If there are no such `?x's`, then the call to `bagof` fails.\n"
"A *bag* is an unordered collection with duplicates allowed.\n"
"For example, the bag {*a*, *b, a*} is the same as the bag {*a*, *a*, *b*}, "
"but different from {*a*, *b*}.\n"
"Bags stands in contrast to *sets,* which are unordered collections with no "
"duplicates.\n"
"The set {*a*, *b*} is the same as the set {*b*, *a*}.\n"
"Here is an implementation of `bagof:`"
msgstr ""
"Одно из фундаментальных различий между Prolog и Lisp заключается в том, что "
"Prolog является реляционным: вы можете легко выражать индивидуальные "
"отношения.\n"
"Lisp, с другой стороны, хорошо выражает коллекции вещей в виде списков.\n"
"Пока у нас нет способа сформировать коллекцию объектов, удовлетворяющих "
"отношению в Прологе.\n"
"Мы можем легко перебирать объекты; мы просто не можем собрать их вместе.\n"
"Примитивный `bagof` - это один из способов сбора данных.\n"
"В общем, `(bagof ?x (p ?x) ?bag)` объединяет `?bag` со списком всех `?x`-ов, "
"которые удовлетворяют `(p ?x)`.\n"
"Если таких `?x`-ов нет, то вызов `bagof` не выполняется.\n"
"A *bag* - это неупорядоченная коллекция, в которой разрешены дубликаты.\n"
"Например, *bag* {*a*, *b, a*} такая же, как *bag* {*a*, *a*, *b*}, но "
"отличается от {*a*, *b*}.\n"
"Bags контрастируют с *sets*, которые представляют собой неупорядоченные "
"коллекции без дубликатов.\n"
"Набор(set) {*a*, *b*} такой же, как набор(set) {*a*, *b*}.\n"
"Вот реализация `bagof:`"

#: in/chapter12.md:1454
msgid ""
"```lisp\n"
"(defun bagof/3 (exp goal resuit cont)\n"
"  \"Find all solutions to GOAL, and for each solution,\n"
"  collect the value of EXP into the list RESULT.\"\n"
"```"
msgstr ""

#: in/chapter12.md:1457
msgctxt "in/chapter12.md:1457"
msgid ""
"`  ;; Ex: Assume (p 1) (p 2) (p 3).\n"
"Then:`"
msgstr ""

#: in/chapter12.md:1465
msgid ""
"```lisp\n"
"  ;: (bagof ?x (p ?x) ?1) => ?1 = (1 2 3)\n"
"  (let ((answers nil))\n"
"  (call/1 goal #'(lambda ()\n"
"      (push (deref-copy exp) answers)))\n"
"  (if (and (not (null answers))\n"
"```"
msgstr ""

#: in/chapter12.md:1468
msgid ""
"`    (unify!\n"
"resuit (nreverse answers)))`"
msgstr ""

#: in/chapter12.md:1478
msgid ""
"```lisp\n"
"  (funcall cont))))\n"
"  (defun deref-copy (exp)\n"
"  \"Copy the expression, replacing variables with new ones.\n"
"  The part without variables can be returned as is.\"\n"
"  (sublis (mapcar #'(lambda (var) (cons (deref var) (?))\n"
"    (unique-find-anywhere-if #'var-p exp))\n"
"  exp))\n"
"```"
msgstr ""

#: in/chapter12.md:1481
msgid ""
"Below we use `bagof` to collect a list of everyone Sandy likes.\n"
"Note that the result is a bag, not a set: Sandy appears more than once."
msgstr ""
"Ниже мы используем `bagof`, чтобы собрать список всех, кого любит "
"Сэнди(Sandy likes).\n"
"Обратите внимание, что в результате получается bag, а не set: Сэнди "
"появляется несколько раз."

#: in/chapter12.md:1488
msgid ""
"```lisp\n"
"> (?- (bagof ?who (likes Sandy ?who) ?bag))\n"
"?WHO = SANDY\n"
"?BAG = (LEE KIM ROBIN SANDY CATS SANDY);\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1490
msgid ""
"In the next example, we form the bag of every list of length three that has "
"`A` and `B` as members:"
msgstr ""
"В следующем примере мы формируем bag из каждого списка длиной три, в котором "
"в качестве членов входят `A` и `B`:"

#: in/chapter12.md:1499
msgid ""
"```lisp\n"
"> (?- (bagof ?l (and (length ?l (1  + (1  + (1  + 0))))\n"
"      (and (member a ?l) (member b ?l)))\n"
"    ?bag))\n"
"?L = (?5 ?8 ?11 ?68 ?66)\n"
"?BAG = ((A B ?17) (A ?21 B) (B A ?31) (?38 A B) (B ?48 A) (?52 B A))\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1501
msgid ""
"Those who are disappointed with a bag containing multiple versions of the "
"same answer may prefer the primitive `setof`, which does the same "
"computation as `bagof` but then discards the duplicates."
msgstr ""
"Те, кто разочарован bag, содержащим несколько версий одного и того же "
"ответа, могут предпочесть примитивный `setof`, который выполняет те же "
"вычисления, что и `bagof`, но затем отбрасывает дубликаты."

#: in/chapter12.md:1507
msgid ""
"```lisp\n"
"(defun setof/3 (exp goal resuit cont)\n"
"  \"Find all unique solutions to GOAL, and for each solution,\n"
"  collect the value of EXP into the list RESULT.\"\n"
"```"
msgstr ""

#: in/chapter12.md:1510
msgctxt "in/chapter12.md:1510"
msgid ""
"`  ;; Ex: Assume (p 1) (p 2) (p 3).\n"
"Then:`"
msgstr ""

#: in/chapter12.md:1518
msgid ""
"```lisp\n"
"  ;;  (setof ?x (p ?x) ?l ) => ?l = (1 2 3)\n"
"  (let ((answers nil))\n"
"  (call/1 goal #'(lambda ()\n"
"      (push (deref-copy exp) answers)))\n"
"  (if (and (not (null answers))\n"
"```"
msgstr ""

#: in/chapter12.md:1521
msgid ""
"`    (unify!\n"
"resuit (delete-duplicates`"
msgstr ""

#: in/chapter12.md:1527
msgid ""
"```lisp\n"
"        answers\n"
"        :test #'deref-equal)))\n"
"  (funcall cont))))\n"
"```"
msgstr ""

#: in/chapter12.md:1532
msgid ""
"Prolog supports arithmetic with the operator `is`.\n"
"For example, `(is ?x (+ ?y 1))` unifies `?x` with the value of `?y` plus "
"one.\n"
"This expression fails if `?y` is unbound, and it gives a run-time error if `?"
"y` is not a number.\n"
"For our version of Prolog, we can support not just arithmetic but any Lisp "
"expression:"
msgstr ""
"Пролог поддерживает арифметические операции с оператором `is`.\n"
"Например, `(is ?x (+ ?y 1))` объединяет/унифицирует `?x` со значением `?y` "
"плюс один.\n"
"Это выражение не работает, если `?y` не привязано, и выдает ошибку времени "
"выполнения, если `?y` не является числом.\n"
"В нашей версии Пролога мы можем поддерживать не только арифметику, но и "
"любое выражение Лиспа:"

#: in/chapter12.md:1539
msgid ""
"```lisp\n"
"(defun is/2 (var exp cont)\n"
"  ;; Example: (is ?x (+  3 (* ?y (+ ?z 4))))\n"
"  ;; Or even: (is (?x ?y ?x) (cons (first ?z) ?l))\n"
"  (if (and (not (find-if-anywhere #'unbound-var-p exp))\n"
"```"
msgstr ""

#: in/chapter12.md:1542
msgid ""
"`    (unify!\n"
"var (eval (deref-exp exp))))`"
msgstr ""

#: in/chapter12.md:1549
msgid ""
"```lisp\n"
"  (funcall cont)))\n"
"(defun unbound-var-p (exp)\n"
"  \"Is EXP an unbound var?\"\n"
"  (and (var-p exp) (not (bound-p exp))))\n"
"```"
msgstr ""

#: in/chapter12.md:1552
msgid ""
"As an aside, we might as well give the Prolog programmer access to the "
"function `unbound-var-p`.\n"
"The standard name for this predicate is `var/1`:"
msgstr ""
"Кроме того, мы могли бы также предоставить программисту Prolog доступ к "
"функции `unbound-var-p`.\n"
"Стандартное имя этого предиката - `var/1`:"

#: in/chapter12.md:1559
msgid ""
"```lisp\n"
"(defun var/1 (?arg1 cont)\n"
"  \"Succeeds if ?arg1 is an uninstantiated variable.\"\n"
"  (if (unbound-var-p ?arg1)\n"
"  (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:1563
msgid ""
"The is primitive fails if any part of the second argument is unbound.\n"
"However, there are expressions with variables that can be solved, although "
"not with a direct call to `eval`.\n"
"For example, the following goal could be solved by binding `?x` to `2`:"
msgstr ""
"Это примитив не работает, если какая-либо часть второго аргумента не "
"связана.\n"
"Однако есть выражения с переменными, которые можно решить, хотя и не прямым "
"вызовом `eval`.\n"
"Например, следующая цель может быть решена путем привязки `?x` к `2`:"

#: in/chapter12.md:1567
msgid ""
"```lisp\n"
"(solve (=  12 (* (+ ?x 1) 4)))\n"
"```"
msgstr ""

#: in/chapter12.md:1573
msgid ""
"We might want to have more direct access to Lisp from Prolog.\n"
"The problem with `is` is that it requires a check for unbound variables, and "
"it calls `eval` to evaluate arguments recursively.\n"
"In some cases, we just want to get at Lisp's `apply`, without going through "
"the safety net provided by is.\n"
"The primitive `lisp` does that.\n"
"Needless to say, `lisp` is not a part of standard Prolog."
msgstr ""
"Мы могли бы захотеть иметь более прямой доступ к Лиспу из Пролога.\n"
"Проблема с `is` в том, что он требует проверки на наличие несвязанных "
"переменных и вызывает `eval` для рекурсивного вычисления аргументов.\n"
"В некоторых случаях мы просто хотим добраться до Лисп `apply`, не прибегая к "
"страховочной сетке, предоставляемой `is`.\n"
"Это делает примитив `lisp`.\n"
"Излишне говорить, что `lisp` не является частью стандартного Пролога."

#: in/chapter12.md:1579
msgid ""
"```lisp\n"
"(defun lisp/2 (?result exp cont)\n"
"  \"Apply (first exp) to (rest exp), and return the result.\"\n"
"  (if (and (consp (deref exp))\n"
"```"
msgstr ""

#: in/chapter12.md:1582
msgid ""
"`    (unify!\n"
"?result (apply (first exp) (rest exp))))`"
msgstr ""

#: in/chapter12.md:1586
msgid ""
"```lisp\n"
"  (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:1589
msgid ""
"**Exercise  12.7 [m]** Define the primitive `solve/1`, which works like the "
"function `solve` used in student ([page 225](B9780080571157500078."
"xhtml#p225)).\n"
"Decide if it should take a single equation as argument or a list of "
"equations."
msgstr ""
"**Упражнение 12.7 [m]** Определите примитив `solve/1`, который работает "
"аналогично функции `solve`, используемой в student ([страница 225]"
"(B9780080571157500078.xhtml#p225)).\n"
"Решите, следует использовать в качестве аргумента одно уравнение или список "
"уравнений."

#: in/chapter12.md:1595
msgid ""
"**Exercise  12.8 [h]** Assume we had a goal of the form `(solve (=  12 (* "
"(+ ?x 1) 4)))`.\n"
"Rather than manipulate the equation when `solve/1` is called at run time, we "
"might prefer to do part of the work at compile time, treating the call as if "
"it were `(solve (= ?x 2))`.\n"
"Write a Prolog compiler macro for `solve`.\n"
"Notice that even when you have defined a compiler macro, you still need the "
"underlying primitive, because the predicate might be invoked through a "
"`call/1`.\n"
"The same thing happens in Lisp: even when you supply a compiler macro, you "
"still need the actual function, in case of a `funcall` or `apply`."
msgstr ""
"**Упражнение 12.8 [h]** Предположим, у нас есть цель вида `(solve (=  12 (* "
"(+ ?x 1) 4)))`.\n"
"Вместо того, чтобы манипулировать уравнением, когда во время выполнения "
"вызывается `solve/1`, мы могли бы предпочесть выполнять часть работы во "
"время компиляции, обрабатывая вызов, как если бы он был `(solve (= ?x 2))`.\n"
"Напишите макрос компилятора Пролога для `solve`.\n"
"Обратите внимание, что даже если вы определили макрос компилятора, вам все "
"равно понадобится базовый примитив, потому что предикат может быть вызван "
"через `call/1`.\n"
"То же самое происходит в Лиспе: даже когда вы предоставляете макрос "
"компилятора, вам все равно нужна фактическая функция в случае `funcall` или "
"`apply`."

#: in/chapter12.md:1598
msgid ""
"**Exercise  12.9 [h]** Which of the predicates `call`, and, `or`, `not`, or "
"`repeat` could benefit from compiler macros?\n"
"Write compiler macros for those predicates that could use one."
msgstr ""
"**Упражнение 12.9 [h]** Для какого из предикатов `call`, `and`, `or`, `not` "
"или` repeat` можно использовать макросы компилятора?\n"
"Напишите макросы компилятора для тех предикатов, которые могут его "
"использовать."

#: in/chapter12.md:1604
msgid ""
"**Exercise  12.10 [m]** You might have noticed that `call/1` is inefficient "
"in two important ways.\n"
"First, it calls `make-predicate`, which must build a symbol by appending "
"strings and then look the string up in the Lisp symbol table.\n"
"Alter `make-predicate` to store the predicate symbol the first time it is "
"created, so it can do a faster lookup on subsequent calls.\n"
"The second inefficiency is the call to append.\n"
"Change the whole compiler so that the continuation argument comes first, not "
"last, thus eliminating the need for append in `call`."
msgstr ""
"**Упражнение 12.10 [m]** Вы могли заметить, что `call/1` неэффективен по "
"двум важным причинам.\n"
"Сначала он вызывает `make-predicate`, который должен построить символ, "
"добавляя строки, а затем искать строку в таблице символов Lisp.\n"
"Измените `make-predicate` для сохранения символа предиката при его первом "
"создании, чтобы он мог быстрее выполнять поиск при последующих вызовах.\n"
"Вторая неэффективность - это вызов append.\n"
"Измените весь компилятор так, чтобы аргумент продолжение шел первым, а не "
"последним, что устраняет необходимость применения  `append` в `call`."

#: in/chapter12.md:1608
msgid ""
"**Exercise  12.11 [s]** The primitive `true/0` always succeeds, and `fail/0` "
"always fails.\n"
"Define these primitives.\n"
"Hint: the first corresponds to a Common Lisp function, and the second is a "
"function already defined in this chapter."
msgstr ""
"**Упражнение 12.11 [s]** Примитив `true/0` всегда выполняется успешно, а "
"`fail/0` всегда терпит неудачу.\n"
"Определите эти примитивы.\n"
"Подсказка: первая соответствует функции Common Lisp, а вторая - функции, уже "
"определенной в этой главе."

#: in/chapter12.md:1610
msgid ""
"**Exercise  12.12 [s]** Would it be possible to write `= =/2` as a list of "
"clauses rather than as a primitive?"
msgstr ""
"**Упражнение 12.12 [s]** Можно ли написать `= =/2` как список предложений, а "
"не как примитив?"

#: in/chapter12.md:1612
msgid ""
"**Exercise  12.13 [m]** Write a version of `deref-copy` that traverses the "
"argument expression only once."
msgstr ""
"**Упражнение 12.13 [m]** Напишите версию `deref-copy`, которая обходит "
"выражение аргумента только один раз."

#: in/chapter12.md:1614
msgid "## 12.9 The Cut"
msgstr "## 12.9 Cut(Обрезка)"

#: in/chapter12.md:1625
msgid ""
"In Lisp, it is possible to write programs that backtrack explicitly, "
"although it can be awkward when there are more than one or two backtrack "
"points.\n"
"In Prolog, backtracking is automatic and implicit, but we don't yet know of "
"any way to *avoid* backtracking.\n"
"There are two reasons why a Prolog programmer might want to disable "
"backtracking.\n"
"First, keeping track of the backtrack points takes up time and space.\n"
"A programmer who knows that a certain problem has only one solution should "
"be able to speed up the computation by telling the program not to consider "
"the other possible branches.\n"
"Second, sometimes a simple logical specification of a problem will yield "
"redundant solutions, or even some unintended solutions.\n"
"It may be that simply pruning the search space to eliminate some "
"backtracking will yield only the desired answers, while restructuring the "
"program to give all and only the right answers would be more difficult.\n"
"Here's an example.\n"
"Suppose we wanted to define a predicate, `max/3`, which holds when the third "
"argument is the maximum of the first two arguments, where the first two "
"arguments will always be instantiated to numbers.\n"
"The straightforward definition is:"
msgstr ""
"В Лиспе можно писать программы с явным откатом(backtrack), хотя это может "
"быть неудобно, если имеется более одной или двух точек возврата.\n"
"В Прологе откат является автоматическим и неявным, но мы пока не знаем "
"никакого способа *избежать* его.\n"
"Существует две причины, по которым программист на Prolog может захотеть "
"отключить откат.\n"
"Во-первых, отслеживание точек отката требует времени и места.\n"
"Программист, который знает, что у определенной проблемы есть только одно "
"решение, должен иметь возможность ускорить вычисления, сказав программе не "
"рассматривать другие возможные ответвления.\n"
"Во-вторых, иногда простая логическая спецификация проблемы приводит к "
"избыточным решениям или даже к некоторым непредвиденным решениям.\n"
"Может случиться так, что простое сокращение пространства поиска, чтобы "
"исключить некоторые отслеживания откатов, даст только желаемые ответы, в то "
"время как реструктуризация программы, чтобы давать все и только правильные "
"ответы, будет сложнее.\n"
"Вот пример.\n"
"Предположим, мы хотим определить предикат `max/3`, который выполняется, "
"когда третий аргумент является максимумом из первых двух аргументов, где "
"первые два аргумента всегда будут преобразованы в числа.\n"
"Прямое определение:"

#: in/chapter12.md:1630
msgid ""
"```lisp\n"
"(<- (max ?x ?y ?x) (>= ?x ?y))\n"
"(<- (max ?x ?y ?y) (< ?x ?y))\n"
"```"
msgstr ""

#: in/chapter12.md:1634
msgid ""
"Declaratively, this is correct, but procedurally it is a waste of time to "
"compute the < relation if the >= has succeeded: in that case the < can never "
"succeed.\n"
"The cut symbol, written !, can be used to stop the wasteful computation.\n"
"We could write:"
msgstr ""
"Декларативно оно правильно, но с процедурной точки зрения вычисление "
"отношения < является пустой тратой времени, если >= успешно: в этом случае < "
"не может быть успешным.\n"
"Символ сокращения/обрезки, записываемый !, Можно использовать, чтобы "
"остановить бесполезные вычисления.\n"
"Мы могли бы написать:"

#: in/chapter12.md:1639
msgid ""
"```lisp\n"
"(<- (max ?x ?y ?x) (>= ?x ?y) !)\n"
"(<- (max ?x ?y ?y))\n"
"```"
msgstr ""

#: in/chapter12.md:1643
msgid ""
"The cut in the first clause says that if the first clause succeeds, then no "
"other clauses will be considered.\n"
"So now the second clause can not be interpreted on its own.\n"
"Rather, it is interpreted as \"if the first clause fails, then the `max` of "
"two numbers is the second one.\""
msgstr ""
"Обрезка в первом предложении говорит о том, что если первое предложение "
"будет успешным, то никакие другие предложения не будут рассматриваться.\n"
"Так что теперь второй пункт нельзя толковать самостоятельно.\n"
"Скорее, он интерпретируется как \"если первое предложение не выполняется, то "
"второе из двух чисел является максимальным\"."

#: in/chapter12.md:1650
msgid ""
"In general, a cut can occur anywhere in the body of a clause, not just at "
"the end.\n"
"There is no good declarative interpretation of a cut, but the procedural "
"interpretation is two-fold.\n"
"First, when a cut is \"executed\" as a goal, it always succeeds.\n"
"But in addition to succeeding, it sets up a fence that cannot be crossed by "
"subsequent backtracking.\n"
"The cut serves to cut off backtracking both from goals to the right of the "
"cut (in the same clause) and from clauses below the cut (in the same "
"predicate).\n"
"Let's look at a more abstract example:"
msgstr ""
"Как правило, сокращение/обрезка может происходить в любом месте предложения, "
"а не только в конце.\n"
"Хорошей декларативной интерпретации обрезки не существует, но процедурная "
"интерпретация двояка.\n"
"Во-первых, когда обрезка \"выполняется\" как цель, она всегда успешна.\n"
"Но в дополнение к успеху она устанавливает барьер, который нельзя преодолеть "
"последующим откатом.\n"
"Обрезка служит для отключения отката как от целей справа от обрезки (в том "
"же предложении), так и от предложений ниже обрезки (в том же предикате).\n"
"Давайте посмотрим на более абстрактный пример:"

#: in/chapter12.md:1655
msgid ""
"```lisp\n"
"(<- (p) (q) (r) ! (s) (t))\n"
"(<- (p) (s))\n"
"```"
msgstr ""

#: in/chapter12.md:1660
msgid ""
"In processing the first clause of `p`, backtracking can occur freely while "
"attempting to solve `q` and `r`.\n"
"Once `r` is solved, the cut is encountered.\n"
"From that point on, backtracking can occur freely while solving `s` and `t`, "
"but Prolog will never backtrack past the cut into `r`, nor will the second "
"clause be considered.\n"
"On the other hand, if `q` or `r` failed (before the cut is encountered), "
"then Prolog would go on to the second clause."
msgstr ""
"При обработке первого предложения `p` откат может происходить свободно при "
"попытке решить `q` и `r`.\n"
"Как только `r` решен, встречается обрезка.\n"
"С этого момента откат может происходить свободно при решении `s` и` t`, но "
"Prolog никогда не будет откатываться за обрез в `r`, и второе предложение не "
"будет рассматриваться.\n"
"С другой стороны, если `q` или `r` завершились неудачно (до того, как "
"произойдет обрезка), тогда Пролог перейдет ко второму предложению."

#: in/chapter12.md:1663
msgid ""
"Now that the intent of the cut is clear, let's think of how it should be "
"implemented.\n"
"We'll look at a slightly more complex predicate, one with variables and "
"multiple cuts:"
msgstr ""
"Теперь, когда цель сокращения ясна, давайте подумаем, как его следует "
"реализовать.\n"
"Мы рассмотрим немного более сложный предикат с переменными и несколькими "
"разрезами:"

#: in/chapter12.md:1668
msgid ""
"```lisp\n"
"(<- (p ?x a) ! (q ?x))\n"
"(<- (p ?x b) (r ?x) ! (s ?x))\n"
"```"
msgstr ""

#: in/chapter12.md:1673
msgid ""
"We have to arrange it so that as soon as we backtrack into a cut, no more "
"goals are considered.\n"
"In the first clause, when `q/1` fails, we want to return from `p/2` "
"immediately, rather than considering the second clause.\n"
"Similarly, the first time `s/1` fails, we want to return from `p/2`, rather "
"than going on to consider other solutions to `r/1`.\n"
"Thus, we want code that looks something like this:"
msgstr ""
"Мы должны организовать это так, чтобы, как только мы возвращаемся к "
"сокращению, цели больше не учитывались.\n"
"В первом предложении, когда `q / 1` не работает, мы хотим немедленно "
"вернуться из` p / 2`, а не рассматривать второе предложение.\n"
"Точно так же в первый раз, когда «s / 1» терпит неудачу, мы хотим вернуться "
"из «p / 2», вместо того, чтобы рассматривать другие решения для «r / 1».\n"
"Таким образом, нам нужен код, который выглядит примерно так:"

#: in/chapter12.md:1678
msgid ""
"```lisp\n"
"(defun p/2 (argl arg2 cont)\n"
"  (let ((old-trail (fill-pointer *trail*)))\n"
"```"
msgstr ""

#: in/chapter12.md:1681
msgid ""
"`    (if (unify!\n"
"arg2 'a)`"
msgstr ""

#: in/chapter12.md:1686
msgid ""
"```lisp\n"
"      (progn (q/1 argl cont)\n"
"          (return-from p/2 nil)))\n"
"```"
msgstr ""

#: in/chapter12.md:1689
msgctxt "in/chapter12.md:1689"
msgid ""
"`    (undo-bindings!\n"
"old-trail)`"
msgstr ""

#: in/chapter12.md:1692
msgid ""
"`    (if (unify!\n"
"arg2 'b)`"
msgstr ""

#: in/chapter12.md:1698
msgid ""
"```lisp\n"
"      (r/1 argl #'(lambda ()\n"
"              (progn (s/1 argl cont)\n"
"                (return-from p/2 nil)))))))\n"
"```"
msgstr ""

#: in/chapter12.md:1702
msgid ""
"We can get this code by making a single change to `compile-body:` when the "
"first goal in a body (or what remains of the body) is the cut symbol, then "
"we should generate a `progn` that contains the code for the rest of the "
"body, followed by a `return-from` the predicate being compiled.\n"
"Unfortunately, the name of the predicate is not available to `compile-body.` "
"We could change `compile-clause` and `compile-body` to take the predicate "
"name as an extra argument, or we could bind the predicate as a special "
"variable in `compile-predicate`.\n"
"I choose the latter:"
msgstr ""
"Мы можем получить этот код, сделав одно изменение в `compile-body:` когда "
"первая цель в теле (или то, что осталось от тела) является отрезанным "
"символом, тогда мы должны сгенерировать `progn`, содержащий код для "
"остальной части тела, за которой следует `return-from` компилируемого "
"предиката.\n"
"К сожалению, имя предиката недоступно для `compile-body`. Мы могли бы "
"изменить `compile-clause` и `compile-body`, чтобы использовать имя предиката "
"в качестве дополнительного аргумента, или мы могли бы привязать предикат как "
"специальную переменную в `compile-predicate`.\n"
"Я выбираю последнее:"

#: in/chapter12.md:1706
msgid ""
"```lisp\n"
"(defvar *predicate* nil\n"
"  \"The Prolog predicate currently being compiled\")"
msgstr ""

#: in/chapter12.md:1719
msgid ""
"(defun compile-predicate (symbol arity clauses)\n"
"  \"Compile all the clauses for a given symbol/arity\n"
"  into a single LISP function.\"\n"
"  (let ((*predicate* (make-predicate symbol arity))    ;***\n"
"        (parameters (make-parameters arity)))\n"
"    (compile\n"
"     (eval\n"
"      `(defun ,*predicate* (,@parameters cont)\n"
"  .,(maybe-add-undo-bindings\n"
"     (mapcar #'(lambda (clause)\n"
"           (compile-clause parameters clause 'cont))\n"
"      clauses)))))))"
msgstr ""

#: in/chapter12.md:1747
msgid ""
"(defun compile-body (body cont bindings)\n"
"  \"Compile the body of a clause.\"\n"
"  (cond\n"
"    ((null body)\n"
"     `(funcall ,cont))\n"
"    ((eq (first body) '!)                              ;***\n"
"     `(progn ,(compile-body (rest body) cont bindings) ;***\n"
"             (return-from ,*predicate* nil)))          ;***\n"
"    (t (let* ((goal (first body))\n"
"              (macro (prolog-compiler-macro (predicate goal)))\n"
"              (macro-val (if macro\n"
"                             (funcall macro goal (rest body)\n"
"                                      cont bindings))))\n"
"        (if (and macro (not (eq macro-val :pass)))\n"
"            macro-val\n"
"            `(,(make-predicate (predicate goal)\n"
"                               (relation-arity goal))\n"
"              ,@(mapcar #'(lambda (arg)\n"
"                            (compile-arg arg bindings))\n"
"                        (args goal))\n"
"              ,(if (null (rest body))\n"
"                   cont\n"
"                   `#'(lambda ()\n"
"                        ,(compile-body\n"
"                           (rest body) cont\n"
"                           (bind-new-variables bindings goal))))))))))\n"
"```"
msgstr ""

#: in/chapter12.md:1749
msgid ""
"**Exercise  12.14 [m]** Given the definitions below, figure out what a call "
"to `test-cut` will do, and what it will write:"
msgstr ""
"**Упражнение 12.14 [m]** Учитывая приведенные ниже определения, выясните, "
"что будет делать вызов `test-cut` и что он будет писать:"

#: in/chapter12.md:1756
msgid ""
"```lisp\n"
"(<- (test-cut) (p a) (p b) ! (p c) (p d))\n"
"(<- (test-cut) (p e))\n"
"(<- (p ?x) (write (?x 1)))\n"
"(<- (p ?x) (write (?x 2)))\n"
"```"
msgstr ""

#: in/chapter12.md:1759
msgid ""
"Another way to use the cut is in a *repeat/fail* loop.\n"
"The predicate repeat is defined with the following two clauses:"
msgstr ""
"Другой способ использовать обрезку - это цикл *repeat/fail*(повтор/сбой).\n"
"Повторение предиката определяет следующие два предложения:"

#: in/chapter12.md:1764
msgid ""
"```lisp\n"
"(<- (repeat))\n"
"(<- (repeat) (repeat))\n"
"```"
msgstr ""

#: in/chapter12.md:1766
msgid "An alterna te definition as a primitive is:"
msgstr "Альтернативное определение примитива:"

#: in/chapter12.md:1771
msgid ""
"```lisp\n"
"(defun repeat/0 (cont)\n"
"  (loop (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:1774
msgid ""
"Unfortunately, `repeat` is one of the most abused predicates.\n"
"Several Prolog books present programs like this:"
msgstr ""
"К сожалению, `repeat` - один из предикатов, которым злоупотребляют.\n"
"В нескольких книгах по Прологу представлены такие программы:"

#: in/chapter12.md:1785
msgid ""
"```lisp\n"
"(<- (main)\n"
"  (write \"Hello.\")\n"
"  (repeat)\n"
"  (write \"Command: \")\n"
"  (read ?command)\n"
"  (process ?command)\n"
"  (= ?command exit)\n"
"  (write \"Good bye.\"))\n"
"```"
msgstr ""

#: in/chapter12.md:1790
msgid ""
"The intent is that commands are read one at a time, and then processed.\n"
"For each command except `exit, process` takes the appropriate action and "
"then fails.\n"
"This causes a backtrack to the repeat goal, and a new command is read and "
"processed.\n"
"When the command is `exit`, the procedure returns."
msgstr ""
"Смысл состоит в том, что команды читаются по одной, а затем обрабатываются.\n"
"Для каждой команды, кроме `exit`, процесс выполняет соответствующее действие "
"и затем терпит неудачу.\n"
"Это вызывает откат к цели repeat(повторения), и новая команда считывается и "
"обрабатывается.\n"
"Когда команда `exit`, процедура возвращается."

#: in/chapter12.md:1799
msgid ""
"There are two reasons why this is a poor program.\n"
"First, it violates the principle of referential transparency.\n"
"Things that look alike are supposed to be alike, regardless of the context "
"in which they are used.\n"
"But here there is no way to tell that four of the six goals in the body "
"comprise a loop, and the other goals are outside the loop.\n"
"Second, it violates the principle of abstraction.\n"
"A predicate should be understandable as a separate unit.\n"
"But here the predicate process can only be understood by considering the "
"context in which it is called: a context that requires it to fail after "
"processing each command.\n"
"As [Richard O'Keefe 1990](B9780080571157500285.xhtml#bb0925) points out, the "
"correct way to write this clause is as follows:"
msgstr ""
"Есть две причины, почему это плохая программа.\n"
"Во-первых, это нарушает принцип ссылочной прозрачности.\n"
"Вещи, которые выглядят одинаково, должны быть одинаковыми, независимо от "
"контекста, в котором они используются.\n"
"Но здесь невозможно сказать, что четыре из шести целей в теле составляют "
"цикл, а другие цели находятся вне цикла.\n"
"Во-вторых, это нарушает принцип абстракции.\n"
"Предикат должен быть понятен как отдельная единица.\n"
"Но здесь процесс предиката можно понять только при рассмотрении контекста, в "
"котором он вызывается: контекста, который требует его сбоя после обработки "
"каждой команды.\n"
"Как указывает [Ричард О'Киф 1990] (B9780080571157500285.xhtml#bb0925), "
"правильный способ написания этого предложения выглядит следующим образом:"

#: in/chapter12.md:1811
msgid ""
"```lisp\n"
"(<- (main)\n"
"  (write \"Hello.\")\n"
"  (repeat)\n"
"      (write \"Command: \")\n"
"      (read ?command)\n"
"      (process ?command)\n"
"      (or (= ?command exit) (fail))\n"
"  !\n"
"  (write \"Good bye.\"))\n"
"```"
msgstr ""

#: in/chapter12.md:1816
msgid ""
"The indentation clearly indicates the limits of the repeat loop.\n"
"The loop is terminated by an explicit test and is followed by a cut, so that "
"a calling program won't accidently backtrack into the loop after it has "
"exited.\n"
"Personally, I prefer a language like Lisp, where the parentheses make "
"constructs like loops explicit and indentation can be done automatically.\n"
"But O'Keefe shows that well-structured readable programs can be written in "
"Prolog."
msgstr ""
"Отступ четко указывает на пределы повторения цикла.\n"
"Цикл завершается явным тестом, за которым следует отрезка, чтобы вызывающая "
"программа не могла случайно вернуться(откатиться) в цикл после выхода.\n"
"Лично я предпочитаю такой язык, как Lisp, где круглые скобки делают такие "
"конструкции, как циклы, явными, а отступы могут выполняться автоматически.\n"
"Но О'Киф показывает, что хорошо структурированные читаемые программы можно "
"писать и на Прологе."

#: in/chapter12.md:1819
msgid ""
"The if-then and if-then-else constructions can easily be written as "
"clauses.\n"
"Note that the if-then-else uses a cut to commit to the `then` part if the "
"test is satisfied."
msgstr ""
"Конструкции if-then и if-then-else можно легко записать в виде предложений.\n"
"Обратите внимание, что if-then-else использует обрезку для фиксации части "
"`then`, если тест удовлетворен."

#: in/chapter12.md:1829
msgid ""
"```lisp\n"
"(<- (if ?test ?then) (if ?then ?else (fail)))\n"
"(<- (if ?test ?then ?else)\n"
"  (call ?test)\n"
"  !\n"
"  (call ?then))\n"
"(<- (if ?test ?then ?else)\n"
"  (call ?else))\n"
"```"
msgstr ""

#: in/chapter12.md:1833
msgid ""
"The cut can be used to implement the nonlogical `not`.\n"
"The following two clauses are often given before as the definition of "
"`not`.\n"
"Our compiler successfully turns these two clauses into exactly the same code "
"as was given before for the primitive `not/1`:"
msgstr ""
"Обрезка может использоваться для реализации нелогического `не`.\n"
"Следующие два предложения часто приводятся перед определением `not`.\n"
"Наш компилятор успешно превращает эти два предложения в точно такой же код, "
"который был приведен ранее для примитива `not/1`:"

#: in/chapter12.md:1838
msgid ""
"```lisp\n"
"(<- (not ?p) (call ?p) ! (fail))\n"
"(<- (not ?p))\n"
"```"
msgstr ""

#: in/chapter12.md:1840
msgid "## 12.10 \"Real\" Prolog"
msgstr "## 12.10 \"Настоящий\" Пролог"

#: in/chapter12.md:1843
msgid ""
"The Prolog-In-Lisp system developed in this chapter uses Lisp syntax because "
"it is intended to be embedded in a Lisp system.\n"
"Other Prolog implementations using Lisp syntax include micro-Prolog, "
"Symbolics Prolog, and LMI Prolog."
msgstr ""
"Система Prolog-In-Lisp, разработанная в этой главе, использует синтаксис "
"Lisp, потому что она предназначена для встраивания в систему Lisp.\n"
"Другие реализации Пролога, использующие синтаксис Лиспа, включают микро-"
"Пролог, Символический Пролог и Пролог LMI."

#: in/chapter12.md:1852
msgid ""
"However, the majority of Prolog systems use a syntax closer to traditional "
"mathematical notation.\n"
"The following table compares the syntax of \"standard\" Prolog to the syntax "
"of Prolog-In-Lisp.\n"
"While there is currently an international committee working on standardizing "
"Prolog, the final report has not yet been released, so different dialects "
"may have slightly different syntax.\n"
"However, most implementations follow the notation summarized here.\n"
"They derive from the Prolog developed at the University of Edinburgh for the "
"DEC-10 by David H.\n"
"D.\n"
"Warren and his colleagues.\n"
"The names for the primitives in the last section are also taken from "
"Edinburgh Prolog."
msgstr ""
"Однако большинство систем Пролога используют синтаксис, близкий к "
"традиционным математическим обозначениям.\n"
"В следующей таблице сравнивается синтаксис \"стандартного\" Пролога с "
"синтаксисом Пролога-в-Лиспе.\n"
"Хотя в настоящее время над стандартизацией Пролога работает международный "
"комитет, окончательный отчет еще не выпущен, поэтому разные диалекты могут "
"иметь немного отличающийся синтаксис.\n"
"Тем не менее, в большинстве реализаций используются обозначения, приведенные "
"здесь.\n"
"Они являются производными от Пролога, разработанного в Эдинбургском "
"университете для DEC-10 Дэвидом Х.\n"
"Д.\n"
"Уоррен и его коллеги.\n"
"Имена примитивов в последнем разделе также взяты из Эдинбургского Пролога."

#: in/chapter12.md:1868
msgid ""
"|           | Prolog          | Prolog-In-Lisp        |\n"
"|-----------|-----------------|-----------------------|\n"
"| atom      | `lower`         | `const`               |\n"
"| variable  | `Upper`         | `?var`                |\n"
"| anonymous | `-`             | `?`                   |\n"
"| goal      | `p(Var,const)`  | `(p ?var const)`      |\n"
"| rule      | `p(X) :- q(X).` | `(<- (p ?x) (q ?x))`  |\n"
"| fact      | `p(a).`         | `(<- (p a))`          |\n"
"| query     | `?- p(X).`      | `(?- (p ?x))`         |\n"
"| list      | `[a,b,c]`       | `(a b c)`             |\n"
"| cons      | `[a| Rest]`     | `(a . ?rest)`         |\n"
"| nil       | `[]`            | `()`                  |\n"
"| and       | `p(X). q(X)`    | `(and (p ?x) (q ?x)>` |\n"
"| or        | `P(X): q(X)`    | `(or (p ?x) (q ?x))`  |\n"
"| not       | `\\+ p(X)`       | `(not (p ?x))`        |"
msgstr ""

#: in/chapter12.md:1876
msgid ""
"We have adopted Lisp's bias toward lists; terms are built out of atoms, "
"variables, and conses of other terms.\n"
"In real Prolog cons cells are provided, but terms are usually built out of "
"*structures*, not lists.\n"
"The Prolog term `p(a,b)` corresponds to the Lisp vector `#(p/2 a b)`, not "
"the list `(p a b)`.\n"
"A minority of Prolog implementations use *structure sharing.* In this "
"approach, every non-atomic term is represented by a skeleton that contains "
"place holders for variables and a header that points to the skeleton and "
"also contains the variables that will fill the place holders.\n"
"With structure sharing, making a copy is easy: just copy the header, "
"regardless of the size of the skeleton.\n"
"However, manipulating terms is complicated by the need to keep track of both "
"skeleton and header.\n"
"See [Boyer and Moore 1972](B9780080571157500285.xhtml#bb0110) for more on "
"structure sharing."
msgstr ""
"Мы переняли склонность Лиспа к спискам; термины состоят из атомов, "
"переменных и заключений других терминов.\n"
"В реальном Prolog есть cons-ячейки, но термины обычно строятся из "
"*структур*, а не списков.\n"
"Термин Пролога `p(a, b)` соответствует вектору Лиспа `#(p/2 a b)`, а не "
"списку `(p a b)`.\n"
"Меньшая часть реализаций Prolog использует *совместное использование "
"структур.* В этом подходе каждый неатомарный термин представлен каркасом, "
"который содержит заполнители для переменных и заголовок, который указывает "
"на каркас, а также содержит переменные, которые будут заполнять "
"заполнители .\n"
"С разделяемой структуры просто сделать копию: просто скопируйте заголовок, "
"независимо от размера скелета.\n"
"Однако манипулирование терминами осложняется необходимостью отслеживать как "
"скелет, так и заголовок.\n"
"См. [Boyer and Moore 1972](B9780080571157500285.xhtml#bb0110) для получения "
"дополнительной информации о совместном использовании структуры."

#: in/chapter12.md:1882
msgid ""
"Another major difference is that real Prolog uses the equivalent of failure "
"continuations, not success continuations.\n"
"No actual continuation, in the sense of a closure, is built.\n"
"Instead, when a choice is made, the address of the code for the next choice "
"is pushed on a stack.\n"
"Upon failure, the next choice is popped off the stack.\n"
"This is reminiscent of the backtracking approach using Scheme's `call/cc` "
"facility outlined on [page 772](B9780080571157500224.xhtml#p772)."
msgstr ""
"Еще одно важное отличие состоит в том, что настоящий Пролог использует "
"эквивалент продолжений неудач, а не продолжений успехов.\n"
"Никакого фактического продолжения в смысле замыкания не создается.\n"
"Вместо этого, когда выбор сделан, адрес кода для следующего выбора "
"помещается в стек.\n"
"В случае неудачи из стека выскакивает следующий вариант.\n"
"Это напоминает подход с откатом с использованием возможности Scheme `call/"
"cc`, описанный на [стр. 772] (B9780080571157500224.xhtml#p772)."

#: in/chapter12.md:1887
msgid ""
"**Exercise  12.15 [m]** Assuming an approach using a stack of failure "
"continuations instead of success continuations, show what the code for `p` "
"and `member` would look like.\n"
"Note that you need not pass failure continuations around; you can just push "
"them onto a stack that `top-level-prove` will invoke.\n"
"How would the cut be implemented?\n"
"Did we make the right choice in implementing our compiler with success "
"continuations, or would failure continuations have been better?"
msgstr ""
"**Упражнение 12.15 [m]** Предполагая подход, использующий стек продолжений "
"неудач вместо продолжений успехов, покажите, как будет выглядеть код для `p` "
"и `member`.\n"
"Обратите внимание, что вам не нужно передавать продолжения сбоя; вы можете "
"просто поместить их в стек, который вызовет `top-level-prove`.\n"
"Как будет реализовано сокращение?\n"
"Правильно ли мы сделали выбор, реализовав наш компилятор с продолжениями "
"успехов, или было бы лучше продолжать неудачи?"

#: in/chapter12.md:1889
msgid "## 12.11 History and References"
msgstr "## 12.11 История и ссылки"

#: in/chapter12.md:1897
msgid ""
"As described in [chapter 11](B978008057115750011X.xhtml), the idea of logic "
"programming was fairly well understood by the mid-1970s.\n"
"But because the implementations of that time were slow, logic programming "
"did not catch on.\n"
"It was the Prolog compiler for the DEC-10 that made logic programming a "
"serious alternative to Lisp and other general-purpose languages.\n"
"The compiler was developed in 1977 by David H.\n"
"D.\n"
"Warren with Fernando Pereira and Luis Pereira.\n"
"See the paper by [Warren (1979)](B9780080571157500285.xhtml#bb1325) and by "
"all three (1977)."
msgstr ""

#: in/chapter12.md:1908
msgid ""
"Unfortunately, David H.\n"
"D.\n"
"Warren's pioneering work on compiling Prolog has never been published in a "
"widely accessible form.\n"
"His main contribution was the description of the Warren Abstract Machine "
"(WAM), an instruction set for compiled Prolog.\n"
"Most existing compilers use this instruction set, or a slight modification "
"of it.\n"
"This can be done either through byte-code interpretation or through "
"macroexpansion to native machine instructions.\n"
"[A&iuml;t-Kaci 1991](B9780080571157500285.xhtml#bb0020) provides a good "
"tutorial on the WAM, much less terse than the original ([Warren 1983]"
"(B9780080571157500285.xhtml#bb1330)).\n"
"The compiler presented in this chapter does not use the WAM.\n"
"Instead, it is modeled after Mark [Stickel's (1988)](B9780080571157500285."
"xhtml#bb1200) theorem prover.\n"
"A similar compiler is briefly sketched by Jacques [Cohen 1985]"
"(B9780080571157500285.xhtml#bb0225)."
msgstr ""

#: in/chapter12.md:1910
msgid "## 12.12 Exercises"
msgstr "## 12.12 Упражнения"

#: in/chapter12.md:1914
msgid ""
"**Exercise  12.16 [m]** Change the Prolog compiler to allow implicit "
"`calls`.\n"
"That is, if a goal is not a cons cell headed by a predicate, compile it as "
"if it were a `call`.\n"
"The clause:"
msgstr ""

#: in/chapter12.md:1918
msgid ""
"```lisp\n"
"(<- (p ?x ?y) (?x c) ?y)\n"
"```"
msgstr ""

#: in/chapter12.md:1920
msgid "should be compiled as if it were:"
msgstr ""

#: in/chapter12.md:1924
msgid ""
"```lisp\n"
"(<- (p ?x ?y) (call (?x c)) (call ?y))\n"
"```"
msgstr ""

#: in/chapter12.md:1926
msgid "**Exercise  12.17 [h]** Here are some standard Prolog primitives:"
msgstr ""

#: in/chapter12.md:1928
msgid "*   `get/1` Read a single character and unify it with the argument."
msgstr ""

#: in/chapter12.md:1930
msgid "*   `put/1` Print a single character."
msgstr ""

#: in/chapter12.md:1932
msgid ""
"*   `nonvar/1, /=, /==` The opposites of `var, = and = =` , respectively."
msgstr ""

#: in/chapter12.md:1934
msgid "*   `integer/1` True if the argument is an integer."
msgstr ""

#: in/chapter12.md:1936
msgid "*   `atom/1` True if the argument is a symbol (like Lisp's `symbol p`)."
msgstr ""

#: in/chapter12.md:1938
msgid ""
"*   `atomic/1` True if the argument is a number or symbol (like Lisp's "
"`atom`)."
msgstr ""

#: in/chapter12.md:1940
msgid ""
"*   <,>,=<,>= Arithmetic comparison; succeeds when the arguments are both "
"instantiated to numbers and the comparison is true."
msgstr ""

#: in/chapter12.md:1942
msgid "*   `listing/0` Print out the clauses for all defined predicates."
msgstr ""

#: in/chapter12.md:1944
msgid "*   `listing/1` Print out the clauses for the argument predicate."
msgstr ""

#: in/chapter12.md:1947
msgid ""
"Implement these predicates.\n"
"In each case, decide if the predicate should be implemented as a primitive "
"or a list of clauses, and if it should have a compiler macro."
msgstr ""

#: in/chapter12.md:1952
msgid ""
"There are some naming conflicts that need to be resolved.\n"
"Terms like `atom` have one meaning in Prolog and another in Lisp.\n"
"Also, in Prolog the normal notation is \\= and \\==, not /= and /==.\n"
"For Prolog-In-Lisp, you need to decide which notations to use: Prolog's or "
"Lisp's."
msgstr ""

#: in/chapter12.md:1956
msgid ""
"**Exercise  12.18 [s]** In Lisp, we are used to writing n-ary calls like "
"`(<  1 n 10 ) or (= x y z )`.\n"
"Write compiler macros that expand n-ary calls into a series of binary "
"calls.\n"
"For example, `(<  1 n 10)` should expand into `(and (<  1 n) (< n 10))`."
msgstr ""

#: in/chapter12.md:1959
msgid ""
"**Exercise  12.19 [m]** One feature of Lisp that is absent in Prolog is the "
"`quote` mechanism.\n"
"Is there a use for `quote?` If so, implement it; if not, explain why it is "
"not needed."
msgstr ""

#: in/chapter12.md:1967
msgid ""
"**Exercise  12.20 [h]** Write a tracing mechanism for Prolog.\n"
"Add procedures `p-trace` and `p-untrace` to trace and untrace Prolog "
"predicates.\n"
"Add code to the compiler to generate calls to a printing procedure for goals "
"that are traced.\n"
"In Lisp, we have to trace procedures when they are called and when they "
"return.\n"
"In Prolog, there are four cases to consider: the call, successful "
"completion, backtrack into subsequent clauses, and failure with no more "
"clauses.\n"
"We will call these four `cases call`, `exit`, `redo,` and `fail`, "
"respectively.\n"
"If we traced `member,` we would expect tracing output to look something like "
"this:"
msgstr ""

#: in/chapter12.md:1991
msgid ""
"```lisp\n"
"> (?- (member ?x (a b c d)) (fail))\n"
"  CALL MEMBER: ?1 (A B C D)\n"
"  EXIT MEMBER: A (A B C D)\n"
"  REDO MEMBER: ?1 (A B C D)\n"
"    CALL MEMBER: ?1 (B C D)\n"
"    EXIT MEMBER: B (B C D)\n"
"    REDO MEMBER: ?1 (B C D)\n"
"      CALL MEMBER: ?1 (C D)\n"
"      EXIT MEMBER: C (C D)\n"
"      REDO MEMBER: ?1 (C D)\n"
"        CALL MEMBER: ?1 (D)\n"
"        EXIT MEMBER: D (D)\n"
"        REDO MEMBER: ?1 (D)\n"
"          CALL MEMBER: ?1 NIL\n"
"          REDO MEMBER: ?1 NIL\n"
"          FAIL MEMBER: ?1 NIL\n"
"        FAIL MEMBER: ?1 (D)\n"
"      FAIL MEMBER: ?1 (C D)\n"
"    FAIL MEMBER: ?1 (B C D)\n"
"  FAIL MEMBER: ?1 (A B C D)\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:1995
msgid ""
"**Exercise  12.21 [m]** Some Lisp systems are very slow at compiling "
"functions.\n"
"`KCL` is an example; it compiles by translating to `C` and then calling the "
"`C` compiler and assembler.\n"
"In `KCL` it is best to compile only code that is completely debugged, and "
"run interpreted while developing a program."
msgstr ""

#: in/chapter12.md:1998
msgid ""
"Alter the Prolog compiler so that calling the Lisp compiler is optional.\n"
"In all cases, Prolog functions are translated into Lisp, but they are only "
"compiled to machine language when a variable is set."
msgstr ""

#: in/chapter12.md:2003
msgid ""
"**Exercise  12.22 [d]** Some Prolog systems provide the predicate `freeze` "
"to \"freeze\" a goal until its variables are instantiated.\n"
"For example, the goal `(freeze x (> x 0))` is interpreted as follows: if `x` "
"is instantiated, then just evaluate the goal `(> x 0)`, and succeed or fail "
"depending on the result.\n"
"However, if `x` is unbound, then succeed and continue the computation, but "
"remember the goal `(> x 0)` and evaluate it as soon as `x` becomes "
"instantiated.\n"
"Implement freeze."
msgstr ""

#: in/chapter12.md:2005
msgid ""
"**Exercise  12.23 [m]** Write a recursive version of `anonymous-variables-"
"in` that does not use a local function."
msgstr ""

#: in/chapter12.md:2007
msgid "## 12.13 Answers"
msgstr "## 12.13 Ответы"

#: in/chapter12.md:2009
msgid ""
"**Answer 12.6** Here's a version that works for Texas Instruments and Lucid "
"implementations:"
msgstr ""

#: in/chapter12.md:2019
msgid ""
"```lisp\n"
"(defmacro with-compilation-unit (options &body body)\n"
"  \"Do the body, but delay compiler warnings until the end.\"\n"
"  ;; This is defined in Common Lisp the Language, 2nd ed.\n"
"  '(,(read-time-case\n"
"    #+TI 'compiler:compiler-warnings-context-bind\n"
"    #+Lucid 'with-deferred-warnings\n"
"        'progn)\n"
"    .,body))"
msgstr ""

#: in/chapter12.md:2027
msgid ""
"(defun prolog-compile-symbols (&optional (symbols *uncompiled*))\n"
"  \"Compile a list of Prolog symbols.\n"
"  By default, the list is all symbols that need it.\"\n"
"  (with-compilation-unit ()\n"
"  (mapc #'prolog-compile symbols)\n"
"  (setf *uncompiled* (set-difference *uncompiled* symbols))))\n"
"```"
msgstr ""

#: in/chapter12.md:2030
msgid ""
"**Answer 12.9** Macros for `and` and `or` are very important, since these "
"are commonly used.\n"
"The macro for `and` is trivial:"
msgstr ""

#: in/chapter12.md:2035
msgid ""
"```lisp\n"
"(def-prolog-compiler-macro and (goal body cont bindings)\n"
"  (compile-body (append (args goal) body) cont bindings))\n"
"```"
msgstr ""

#: in/chapter12.md:2037
msgid "The macro for or is trickier:"
msgstr ""

#: in/chapter12.md:2051
msgid ""
"```lisp\n"
"(def-prolog-compiler-macro or (goal body cont bindings)\n"
"  (let ((disjuncts (args goal)))\n"
"    (case (length disjuncts)\n"
"      (0 fail)\n"
"      (1 (compile-body (cons (first disjuncts) body) cont bindings))\n"
"      (t (let ((fn (gensym \"F\")))\n"
"        '(fl&egrave;t ((,fn () ,(compile-body body cont bindings)))\n"
"          .,(maybe-add-undo-bindings\n"
"            (loop for g in disjuncts collect\n"
"              (compile-body (list g) '#',fn\n"
"                bindings)))))))))\n"
"```"
msgstr ""

#: in/chapter12.md:2054
msgid ""
"**Answer 12.11**`true/0` is `funcall` : when a goal succeeds, we call the "
"continuation, `fail/0` is `ignore`: when a goal fails, we ignore the "
"continuation.\n"
"We could also define compiler macros for these primitives:"
msgstr ""

#: in/chapter12.md:2058
msgid ""
"```lisp\n"
"(def-prolog-compiler-macro true (goal body cont bindings)\n"
"  (compile-body body cont bindings))"
msgstr ""

#: in/chapter12.md:2063
msgid ""
"(def-prolog-compiler-macro fail (goal body cont bindings)\n"
"  (declare (ignore goal body cont bindings))\n"
"  nil)\n"
"```"
msgstr ""

#: in/chapter12.md:2065
msgid "**Answer 12.13**"
msgstr ""

#: in/chapter12.md:2088
msgid ""
"```lisp\n"
"(defun deref-copy (exp)\n"
"  \"Build a copy of the expression, which may have variables.\n"
"  The part without variables can be returned as is.\"\n"
"  (let ((var-alist nil ))\n"
"    (labels\n"
"      ((walk (exp)\n"
"        (deref exp)\n"
"        (cond ((consp exp)\n"
"          (reuse-cons (walk (first exp))\n"
"              (walk (rest exp))\n"
"              exp))\n"
"          ((var-p exp)\n"
"          (let ((entry (assoc exp var-alist)))\n"
"            (if (not (null entry))\n"
"            (cdr entry)\n"
"            (let ((var-copy (?)))\n"
"                (push (cons exp var-copy) var-alist)\n"
"                var-copy))))\n"
"          (t exp))))\n"
"    (walk exp))))\n"
"```"
msgstr ""

#: in/chapter12.md:2095
msgid ""
"**Answer 12.14** In the first clause of `test-cut`, all four calls to `p` "
"will succeed via the first clause of `p`.\n"
"Then backtracking will occur over the calls to `(p c)` and `(p d)`.\n"
"All four combinations of `1` and `2` succeed.\n"
"After that, backtracking would normally go back to the call to `(p b)`.\n"
"But the cut prevents this, and the whole `(test-cut)` goal fails, without "
"ever considering the second clause.\n"
"Here's the actual output:"
msgstr ""

#: in/chapter12.md:2108
msgid ""
"```lisp\n"
"(?- (test-cut))\n"
"(A 1)(B 1)(C 1) (D 1)\n"
"Yes;\n"
"(D 2)\n"
"Yes;\n"
"(C 2)(D 1)\n"
"Yes;\n"
"(D 2)\n"
"Yes;\n"
"No.\n"
"```"
msgstr ""

#: in/chapter12.md:2110
msgid "**Answer 12.17** For example:"
msgstr ""

#: in/chapter12.md:2119
msgid ""
"```lisp\n"
"(defun >/2 (x y cont)\n"
"  (if (and (numberp (deref x)) (numberp (deref y)) (> x y))\n"
"    (funcall cont)))\n"
"(defun numberp/1 (x cont)\n"
"  (if (numberp (deref x))\n"
"    (funcall cont)))\n"
"```"
msgstr ""

#: in/chapter12.md:2124
msgid ""
"**Answer 12.19** Lisp uses quote in two ways: to distinguish a symbol from "
"the value of the variable represented by that symbol, and to distinguish a "
"literal list from the value that would be returned by evaluating a function "
"call.\n"
"The first distinction Prolog makes by a lexical convention: variables begin "
"with a question mark in our Prolog, and they are capitalized in real "
"Prolog.\n"
"The second distinction is not necessary because Prolog is relational rather "
"than functional.\n"
"An expression is a goal if it is a member of the body of a clause, and is a "
"literal if it is an argument to a goal."
msgstr ""

#: in/chapter12.md:2126
msgid ""
"**Answer 12.20** Hint: Here's how `member` could be augmented with calls to "
"a procedure, `prolog-trace`, which will print information about the four "
"kinds of tracing events:"
msgstr ""

#: in/chapter12.md:2135
msgid ""
"```lisp\n"
"(defun member/2 (?arg1 ?arg2 cont)\n"
"  (let ((old-trail (fill-pointer *tra1l*))\n"
"      (exit-cont #'(lambda ()\n"
"          (prolog-trace 'exit 'member ?arg1 ?arg2 )\n"
"          (funcall cont))))\n"
"    (prolog-trace 'call 'member ?arg1 ?arg2)\n"
"```"
msgstr ""

#: in/chapter12.md:2138
msgid ""
"`    (if (unify!\n"
"?arg2 (cons ?arg1 (?)))`"
msgstr ""

#: in/chapter12.md:2142
msgid ""
"```lisp\n"
"      (funcall exit-cont))\n"
"```"
msgstr ""

#: in/chapter12.md:2145
msgctxt "in/chapter12.md:2145"
msgid ""
"`    (undo-bindings!\n"
"old-trail)`"
msgstr ""

#: in/chapter12.md:2150
msgid ""
"```lisp\n"
"    (prolog-trace 'redo 'member ?arg1 ?arg2)\n"
"    (let ((?rest (?)))\n"
"```"
msgstr ""

#: in/chapter12.md:2153
msgid ""
"`      (if (unify!\n"
"?arg2 (cons (?) ?rest))`"
msgstr ""

#: in/chapter12.md:2158
msgid ""
"```lisp\n"
"      (member/2 ?arg1 ?rest exit-cont)))\n"
"    (prolog-trace 'fail 'member ?arg1 ?arg2)))\n"
"```"
msgstr ""

#: in/chapter12.md:2160
msgid "The definition of `prolog-trace` is:"
msgstr ""

#: in/chapter12.md:2171
msgid ""
"```lisp\n"
"(defvar *prolog-trace-indent* 0)\n"
"(defun prolog-trace (kind predicate &rest args)\n"
"  (if (member kind '(call redo))\n"
"  (incf *prolog-trace-indent* 3))\n"
"  (format t \"~&~VT~a ~  a:~{ ~  a  ~}\"\n"
"      *prolog-trace-indent* kind predicate args)\n"
"  (if (member kind '(fail exit))\n"
"  (decf *prolog-trace-indent* 3)))\n"
"```"
msgstr ""

#: in/chapter12.md:2173
msgid "**Answer 12.23**"
msgstr ""

#: in/chapter12.md:2178
msgid ""
"```lisp\n"
"(defun anonymous-variables-in (tree)\n"
"  \"Return a list of all variables that occur only once in tree.\"\n"
"  (values (anon-vars-in tree nil nil)))"
msgstr ""

#: in/chapter12.md:2194
msgid ""
"(defun anon-vars-in (tree seen-once seen-more)\n"
"  \"Walk the data structure TREE, returning a list of variables\n"
"  seen once, and a list of variables seen more than once.\"\n"
"  (cond\n"
"    ((consp tree)\n"
"    (multiple-value-bind (new-seen-once new-seen-more)\n"
"      (anon-vars-in (first tree) seen-once seen-more)\n"
"      (anon-vars-in (rest tree) new-seen-once new-seen-more)))\n"
"    ((not (variable-p tree)) (values seen-once seen-more))\n"
"    ((member tree seen-once)\n"
"    (values (delete tree seen-once) (cons tree seen-more)))\n"
"    ((member tree seen-more)\n"
"    (values seen-once seen-more))\n"
"    (t (values (cons tree seen-once) seen-more))))\n"
"```"
msgstr ""
