# Chapter 6
## Построение Программных Средств

> *Человек - животное, использующее инструменты ... Без инструментов он - ничто, с инструментами он все.*

> -Thomas Carlyle (1795-1881)

В [главах 4](B9780080571157500042.xhtml) и [5](B9780080571157500054.xhtml) мы были заинтересованы в создании двух конкретных программ, GPS и ELIZA. В этой главе мы еще раз рассмотрим эти две программы, чтобы выявить некоторые общие закономерности(шаблоны).
Эти закономерности(шаблоны) будут абстрагированы, чтобы сформировать программные инструменты для многократного использования, которые окажутся полезными в следующих главах.

## 6.1 Интерактивный Инструмент Интерпретатора

Структура функции `eliza` обычная.
Она повторяется ниже:

```lisp
(defun eliza ()
  "Respond to user input using pattern matching rules."
  (loop
    (print 'eliza>)
    (print (flatten (use-eliza-rules (read))))))
```

Многие другие приложения используют этот шаблон, включая сам Лисп.
Верхний уровень Lisp можно определить как:

```lisp
(defun lisp ()
  (loop
    (print '>)
    (print (eval (read)))))
```

Верхний уровень системы Lisp исторически назывался "read-eval-print loop/циклом чтения-вычисления-печати(REPL)". Большинство современных Лиспов выводят приглашение перед чтением ввода, поэтому его на самом деле следует называть "цикл подсказка-чтение-вычисление-печать", но в некоторых ранних системах, таких как MacLisp, приглашения не было, поэтому более короткое имя прижилось.
Если бы мы не указали приглашение, мы могли бы написать полный интерпретатор Лиспа, используя всего четыре символа:

```lisp
(loop (print (eval (read))))
```

Может показаться шуткой утверждение, что эти четыре символа и восемь круглых скобок составляют интерпретатор Лиспа.
Когда мы напишем эту строку, действительно ли мы чего-нибудь достигнем?
Один из ответов на этот вопрос - подумать о том, что нам нужно сделать, чтобы написать интерпретатор Лиспа (или Паскаля) на Паскале.
Нам понадобится лексический анализатор и менеджер таблиц символов.
Это значительный объем работы, но все это выполняется с помощью `read`.
Нам понадобится синтаксический анализатор для сборки лексических токенов в операторы.
`read` также обрабатывает это, но только потому, что операторы Lisp имеют тривиальный синтаксис: синтаксис списков и атомов.
Таким образом, `read` отлично работает как синтаксический анализатор для Лиспа, но не работает для Паскаля.
Затем нам понадобится часть интерпретатора, которая занимается оценкой(eval)/вычислением или интерпретацией; `eval` делает это прекрасно, и с таким же успехом может обрабатывать выражения Паскаля, если мы разберем синтаксис Паскаля в выражениях Лиспа, `print` выполняет гораздо меньше работы, чем `read` или `eval`, но все же довольно удобна.

Важный момент не в том, можно ли считать одну строчку кода реализацией Лиспа, а в выявлении общих схем вычислений.
И `eliza`, и `lisp` можно рассматривать как интерактивные интерпретаторы, которые читают некоторый ввод, преобразуют или вычисляют ввод каким-либо образом, распечатывают результат и затем возвращаются за дополнительным вводом.
Мы можем выделить следующий общий шаблон:

```lisp
(defun *program* ()
  (loop
    (print *prompt*)
    (print (*transform* (read)))))
```

Есть два способа использовать повторяющиеся шаблоны, подобные этому: формально и неформально.
Неформальная альтернатива - рассматривать шаблон как клише или идиому, которые будут часто встречаться при написании программ, но будут варьироваться от одного использования к другому.
Когда мы захотим написать новую программу, мы вспоминаем, как писали или читали похожую, возвращаемся назад и смотрим на первую программу, копируем соответствующие разделы, а затем изменяем их для новой программы.
Если заимствование обширное, было бы хорошей практикой вставить комментарий в новую программу со ссылкой на оригинал, но тогда бы небыло никакой "официальной" связи между исходной и производной программой.

Формальной альтернативой является создание абстракции в форме функций и, возможно, структур данных, и явной ссылки на эту абстракцию в каждом новом приложении - другими словами, для фиксации абстракции в форме пригодного для повторного использования программного инструмента.
Шаблон интерпретатора можно абстрагировать в функцию следующим образом:


```lisp
(defun interactive-interpreter (prompt transformer)
  "Read an expression, transform it, and print the result."
  (loop
    (print prompt)
    (print (funcall transformer (read)))))
```

Затем эту функцию можно было бы использовать при написании каждого нового интерпретатора:

```lisp
(defun lisp ()
  (interactive-interpreter '> #'eval))

(defun eliza ()
  (interactive-interpreter 'eliza>
    #'(lambda (x) (flatten (use-eliza-rules x)))))
```

Или с помощью функции высшего порядка compose:

```lisp
(defun compose (f g)
  "Return the function that computes (f (g x))."
  #'(lambda (x) (funcall f (funcall g x))))

(defun eliza ()
  (interactive-interpreter 'eliza>
    (compose #'flatten #'use-eliza-rules)))
```

Есть два различия между формальным и неформальным подходами.
Во-первых, они выглядят поразному.
Если абстракция простая, как эта, то, вероятно, легче прочитать выражение, в котором цикл явно выписан, чем прочитать выражение, вызывающее `interactive-interpreter`(интерактивный интерпретатор), поскольку для этого требуется найти определение `interactive-interpreter` и понять его.


Другое отличие проявляется в так называемом *обслуживании/сопровождение*.
Предположим, мы обнаружили недостаточную функциональность в определении интерактивного интерпретатора.
Одно из таких упущений состоит в том, что `loop` не имеет выхода.
Я предполагал, что пользователь может завершить цикл, нажав какую-либо клавишу прерывания (или break, или abort).
Более понятная реализация позволила бы пользователю дать интерпретатору явную команду завершения.
Еще одна полезная функция - обработка ошибок в интерпретаторе.
Если мы будем использовать неформальный подход, то добавление такой возможности в одну программу не повлияет на другие.
Но если мы воспользуемся формальным подходом, то улучшение `interactive-interpreter`(интерактивного интерпретатора) автоматически внесет новую функциональность во все программы, которые её используют.

Следующая версия `interactive-interpreter` добавляет две новых возможности.
Во-первых, она использует макрос `handler-case` [1](# fn0015) для обработки ошибок.
Этот макрос вычисляет свой первый аргумент и обычно просто возвращает это значение.
Однако при возникновении ошибки последующие аргументы проверяются на наличие условия ошибки, которое соответствует возникшей ошибке.
При таком использовании, в случае `error` соответствует всем ошибкам, и предпринимаемое действие - распечатать состояние ошибки и продолжить.

Эта версия также позволяет приглашению быть либо строкой, либо функцией без аргументов, которая будет вызываться для печати приглашения.
Например, функция `prompt-generator` возвращает функцию, которая будет печатать подсказки вида [1], [2] и так далее.

```lisp
(defun interactive-interpreter (prompt transformer)
   "Read an expression, transform it, and print the result."
   (loop
      (handler-case
	  (progn
	    (if (stringp prompt)
		(print prompt)
		(funcall prompt))
	    (print (funcall transformer (read))))
	;; In case of error, do this:
	(error (condition)
	  (format t "~&;; Error ~a ignored, back to top level."
		  condition)))))

(defun prompt-generator (&optional (num 0) (ctl-string "[~d] "))
  "Return a function that prints prompts like [l], [2], etc."
  #'(lambda () (format t ctl-string (incf num))))
```

## 6.2 Инструмент Сопоставления с образцом

Функция `pat-match` была средством сопоставления с образцом, определенным специально для программы ELIZA.
Последующим программам также потребуются сопоставители с образцами, и вместо того, чтобы писать специализированные сопоставители для каждой новой программы, легче определить один общий сопоставитель с образцом, который может удовлетворить большинство потребностей и может быть расширен в случае возникновения новых потребностей.

Проблема при разработке "общего" инструмента - решить, какие функции предоставить.
Мы можем попытаться определить функции, которые могут быть полезны, но также неплохо сделать список функций открытым, чтобы при необходимости можно было легко добавлять новые.

Функции могут быть добавлены путем обобщения или специализации уже существующих.
Например, мы предоставляем сегментные переменные, которые соответствуют нулю или нескольким входным элементам.
Мы можем специализировать эту функциональность, предоставляя своего рода сегментную переменную, которая соответствует одному или нескольким элементам, или необязательную переменную, которая соответствует нулю или одному элементу.
Другая возможность состоит в том, чтобы обобщить сегментные переменные, чтобы указать соответствие *m* к *n* элементов, для любого заданного *m* и *n*.
Эти идеи приходят из опыта работы с нотациями для написания регулярных выражений, а также из очень общих эвристик для обобщения, таких как "рассмотрения важных частных случаев" и "ноль и один, вероятно, будут важными частными случаями".

Еще одна полезная функциональность заключается в том, чтобы позволить пользователю указать произвольный предикат, которому должно соответствовать сопоставление.
Обозначение `(?is ?n numberp)` может быть использовано для сопоставления любого выражения, которое является числом, и привязки его к переменной `?n`.
Это будет выглядеть как-то так:

```lisp
> (pat-match '(x = (?is ?n numberp)) '(x = 34)) => ((?n . 34))
> (pat-match '(x = (?is ?n numberp)) '(x = x)) => NIL
```

Поскольку образцы подобны булевым(логическим) выражениям, имеет смысл разрешить булевы операторы над ними.
Следуя соглашению о вопросительном знаке в именах переменных, мы будем использовать `?and`, `?or` и `?not` для операторов.[2](#fn0020) Вот образец для сопоставления реляционного выражения с одним из трех отношений.
Оно удачно, потому что < соответствует одной из трех возможностей, указанных как `(?or < = >).`

```lisp
> (pat-match '(?x (?or < = >) ?y) '(3 < 4)) => ((?Y . 4) (?X . 3))
```

Вот пример образца с `?and`, который проверяет является ли выражение одновременно числом и при этом еще нечетным:

```lisp
> (pat-match '(x = (?and (?is ?n numberp) (?is ?n oddp))) '(x = 3)) => ((?N . 3))
```

В следующем образце использование `?not` гарантирует, что две части не равны:

```lisp
> (pat-match '(?x /= (?not ?x)) '(3 /= 4)) => ((?X . 3))
```

Обозначение сегментных совпадений мы видели ранее.
Оно расширено, чтобы учесть три возможности: ноль или более выражений; одно или более выражений; и ноль или одно выражения.
Наконц, обозначение `(?if *exp*)` может использоваться для проверки связи между несколькими переменными. Оно должно быть указано как сегментный образец, а не как отдельный образец, потому что оно вообще не использует вход:

```lisp
> (pat-match '(?x > ?y (?if (> ?x ?y))) '(4 > 3)) =>
((?Y . 3) (?X . 4))
```

Когда описание проблемы становиться таким сложным, рекомендуется попытаться сформулировать более формальную спецификацию.
В следующей таблице описана граматика образцов с испольованием того же формата правил грамматики, который описан в [chapter 2](B9780080571157500029.xhtml).

| входн.символ      | выходной символ или значение |     расшифровка                               |
|-------------------|------------------------|---------------------------------------------------|
| *pat* =>          | *var*                  | соответствие  одному произвольному выражению      |
|                   | *Constant*             | соответствие  только этому атому                  |
|                   | *segment-pat*          | соответствие какой то последовательности          |
|                   | *single-pat*           | соответствие чего-либо с одним выражением         |
|                   | (*pat* . *pat*)        | соответствие первого и остатка                    |
| *single-pat* =>   | (?is *var predicate*)  | тестовый предикат для одного выражения            |
|                   | (?or *pat*...)         | соответствие любому образцу в одном выражении     |
|                   | (?and *pat*...)        | соответствие всем образцам в одном выражении      |
|                   | (?not *pat*...)        | соответствует, если образец не совпадает          |
| *segment-pat* =>  | ( (?* *var*)...)       | соответствие нулю или более выражений            |
|                   | ( (?+ *var*) ... )     | соответствие одному или нескольким выражениям    |
|                   | ( ( ?? *var*) ... )    | соответствие нулю или одному выражинию           |
|                   | ( ( ?if *exp* )...)    | тест если exp ( может иметь перем.) истинно      |
| *Var* =>          | ?chars                 | некоторый символ начинающийся с  ?               |
| *constant* =>     | *atom*                 | любой неизменяемый атом                          |

Не смотря на дополнительную сложность, все образцы можно разделить на пять случаев.
Образец должен быть либо переменнной, либо константой, либо (обобщенным) сегментынм образцом, либо (обобщенным) одноэлементным образцом, либо конструкцией(точечной парой) из двух образцов.
Следующее определение `pat-match` отражает пять случаев (вместе с двумя проверками на неудачу):

```lisp
(defun pat-match (pattern input &optional (bindings no-bindings))
  "Match pattern against input in the context of the bindings"
  (cond ((eq bindings fail) fail)
    ((variable-p pattern)
      (match-variable pattern input bindings))
    ((eql pattern input) bindings)
    ((segment-pattern-p pattern)
      (segment-matcher pattern input bindings))
    ((single-pattern-p pattern) ; ***
      (single-matcher pattern input bindings)) ; ***
    ((and (consp pattern) (consp input))
      (pat-match (rest pattern) (rest input)
            (pat-match (first pattern) (first input)
                bindings)))
    (t fail)))
```

Для полноты картины, повтрим необходимые константы и низкоуровневые функции из ELIZA:

```lisp
(defconstant fail nil "Indicates pat-match failure")

(defconstant no-bindings '((t . t))
  "Indicates pat-match success, with no variables.")

(defun variable-p (x)
  "Is x a variable (a symbol beginning with '?')?"
  (and (symbolp x) (equal (elt (symbol-name x) 0) #\?)))

(defun get-binding (var bindings)
  "Find a (variable . value) pair in a binding list."
  (assoc var bindings))

(defun binding-var (binding)
  "Get the variable part of a single binding."
  (car binding))

(defun binding-val (binding)
  "Get the value part of a single binding."
  (cdr binding))

(defun make-binding (var val) (cons var val))

(defun lookup (var bindings)
  "Get the value part (for var) from a binding list."
  (binding-val (get-binding var bindings)))

(defun extend-bindings (var val bindings)
  "Add a (var . value) pair to a binding list."
  (cons (make-binding var val)
    ;; Once we add a "real" binding,
    ;; we can get rid of the dummy no-bindings
    (if (eq bindings no-bindings)
      nil
      bindings)))

(defun match-variable (var input bindings)
  "Does VAR match input? Uses (or updates) and returns bindings."
  (let ((binding (get-binding var bindings)))
    (cond ((not binding) (extend-bindings var input bindings))
      ((equal input (binding-val binding)) bindings)
      (t fail))))
```

Следующим шагом является определение предикатов, распознающих обобщенные сегментные и одноэлементные образцы, а также функции сопоставления, которые работают с ними.
Мы могли бы реализовать `segment-matcher` и `single-matcher` с операторами case, которые учитывают все возможные случаи.
Однако это затруднило бы расширение сопоставителя.
Программист, который захотел бы добавить новый тип сегментного образца, должен был бы отредактировать определения как `segment-pattern-p`, так и `segment-matcher`, чтобы добавить новую функциональность.
Само по себе это может быть неплохо, но подумайте, что произойдет, когда два программиста добавляют независимую функциональность одновременно.
Если вы захотите использовать и ту и другую, то ни одна из версий `segment-matcher` (или `segment-pattern-p`) не подойдет.
Вам придется снова отредактировать функции, чтобы просто объединить эти два расширения.

Решение этой дилеммы состоит в том, чтобы раз и навсегда написать одну версию `segment-pattern-p` и `segment-matcher`, но чтобы эти функции ссылались на таблицу пар образец/действие(pattern/action).
В таблице будет сказано "если вы видите `?*` в образце, тогда используйте функцию `segment-match`" и так далее.
Затем программисты, которые хотят расширить сопоставитель, просто добавляют записи в таблицу, и тогда тривиально объединить разные расширения (если, конечно, два программиста не выбрали один и тот же символ для обозначения различных действий).

Такой стиль программирования, при котором пары образец/действие хранятся в таблице, называется программированием, управляемым данными, т.е.: *data-driven* *programming*.
Это очень гибкий стиль, подходящий для написания расширяемых систем.

Есть много способов реализовать таблицы в  Common Lisp, как обсуждалось в [section 3.6](B9780080571157500030.xhtml#s0080), [page 73](B9780080571157500030.xhtml#p73).
В этом случае ключи к таблице будут символами  (подобно `?*`), и нормально, если представление таблицы распределено в памяти.
Таким образом, списки свойств являются подходящим выбором.
У нас будет две таблицы, представляющих свойства `segment-match` и свойства `single-match` для символов подобных `?*`.
Значение каждого свойства будет именем функции, которая реализует сопоставление.
Вот записи таблицы для реализации описанной ранее грамматики:

```lisp
(setf (get '?is 'single-match) 'match-is)
(setf (get '?or 'single-match) 'match-or)
(setf (get '?and 'single-match) 'match-and)
(setf (get '?not 'single-match) 'match-not)
(setf (get '?* 'segment-match) 'segment-match)
(setf (get '?+ 'segment-match) 'segment-match+)
(setf (get '?? 'segment-match) 'segment-match?)
(setf (get '?if 'segment-match) 'match-if)
```

Определив таблицу, нам нужно сделать две вещи.
Во-первых, определить "клей" скрепляющий таблицу: предикаты и функции выполняющие действия.
Функция управляемая данными(нашей таблицей), которая находит функции и вызывает их (такие как `segment-matcher` и `single-matcher`) называется *функцией диспетчеризации*.

```lisp
(defun segment-pattern-p (pattern)
  "Is this a segment-matching pattern like ((?* var) . pat)?"
  (and (consp pattern) (consp (first pattern))
    (symbolp (first (first pattern)))
    (segment-match-fn (first (first pattern)))))

(defun single-pattern-p (pattern)
  "Is this a single-matching pattern? 
  E.g. (?is x predicate) (?and . patterns) (?or . patterns)."
  (and (consp pattern)
      (single-match-fn (first pattern))))

(defun segment-matcher (pattern input bindings)
  "Call the right function for this kind of segment pattern."
  (funcall (segment-match-fn (first (first pattern)))
        pattern input bindings))

(defun single-matcher (pattern input bindings)
  "Call the right function for this kind of single pattern."
  (funcall (single-match-fn (first pattern))
        (rest pattern) input bindings))

(defun segment-match-fn (x)
  "Get the segment-match function for x,
  if it is a symbol that has one."
  (when (symbolp x) (get x 'segment-match)))

(defun single-match-fn (x)
  "Get the single-match function for x,
  if it is a symbol that has one."
  (when (symbolp x) (get x 'single-match)))
```

Последнее, что нужно сделать, это определить остальные функции сопоставления.
Во превых, функции сопоставления с одним образцом:

```lisp
(defun match-is (var-and-pred input bindings)
  "Succeed and bind var if the input satisfies pred,
  where var-and-pred is the list (var pred)."
  (let* ((var (first var-and-pred))
      (pred (second var-and-pred))
      (new-bindings (pat-match var input bindings)))
    (if (or (eq new-bindings fail)
        (not (funcall pred input)))
      fail
      new-bindings)))

(defun match-and (patterns input bindings)
  "Succeed if all the patterns match the input."
  (cond ((eq bindings fail) fail)
      ((null patterns) bindings)
      (t (match-and (rest patterns) input
              (pat-match (first patterns) input
                  bindings)))))

(defun match-or (patterns input bindings)
  "Succeed if any one of the patterns match the input."
  (if (null patterns)
      fail
        (let ((new-bindings (pat-match (first patterns)
                    input bindings)))
        (if (eq new-bindings fail)
          (match-or (rest patterns) input bindings)
          new-bindings))))

(defun match-not (patterns input bindings)
  "Succeed if none of the patterns match the input
  This will never bind any variables."
  (if (match-or patterns input bindings)
      fail
      bindings))
```

Теперь функции сопоставления сегментных образцов.
`segment-match` аналогичен версии, представленной как часть ELIZA. Разница в том, как мы определяем  `pos`, позицию первого элемента ввода, который может соответствовать следующему элементу образца после сегментной переменной.
В ELIZA мы предполагали, что сегментная переменная была либо последним элементом образца, либо сопровождалась константой.
В следующей версии, мы разрешаем не константные образцам следовать за сегментными переменными.
Для обработки этого добавлена функция `first-match-pos`.
Если следующий элемент на самом деле является константой, тот же расчет выполняется с использованием `position`.
Если это не константа, мы просто возвращаем первую возможную начальную позицию - если только это не приведет к тому, что мы пройдем конец ввода, и в этом случае мы возвращаем nil, чтобы указать на сбой:

```lisp
(defun segment-match (pattern input bindings &optional (start 0))
  "Match the segment pattern ((?* var) . pat) against input."
  (let ((var (second (first pattern)))
      (pat (rest pattern)))
    (if (null pat)
      (match-variable var input bindings)
      (let ((pos (first-match-pos (first pat) input start)))
        (if (null pos)
            fail
            (let ((b2 (pat-match
                    pat (subseq input pos)
                    (match-variable var (subseq input 0 pos)
                        bindings))))
              ;; If this match failed, try another longer one
              (if (eq b2 fail)
                (segment-match pattern input bindings (+ pos 1))
                b2)))))))

 (defun first-match-pos (pat1 input start)
   "Find the first position that pat1 could possibly match input,
   starting at position start. If pat1 is non-constant, then just  return start."
   (cond ((and (atom pat1) (not (variable-p pat1)))
	  (position pat1 input :start start :test #'equal))
	 ((<= start (length input)) start)
	 (t nil)))
```

В первом примере ниже сегментная переменная `?x` соответствует последовательности (`b c`).
Во втором примере есть две сегментные переменные в строке.
Первое успешное совпадение достигается  первой переменной `?x` соответствующей пустой последовательности, а второй `?y` соответствует (`b c`).

```lisp
> (pat-match '(a (?* ?x) d) '(a b c d)) => ((?X B C))
> (pat-match '(a (?* ?x) (?* ?y) d) '(a b c d))=> ((?Y B C) (?X))
```

В следующем примере `?x` сначала сопоставляется с nil, а `?y` с (`b c d` ), но это приводит к неудаче, поэтому мы пытаемся сопоставить `?x` с сегментом единичной длины.
Это тоже приводит к неудаче, но наконец сопоставление проходит успешно с  `?x` сопоставленным с двух элементным сегментом (`b c`) и  `?y` сопоставленным с (`d`).

```lisp
 > (pat-match  '(a (?* ?x) (?* ?y) ?x ?y)  '(a b c d (b c) (d))) => ((?Y D) (?X B C))
```
Учитывая `segment-match`, легко определить функцию для сопоставления одного или нескольких элементов и функцию для сопоставления нуля или одного элемента:

```lisp
(defun segment-match+ (pattern input bindings)
  "Match one or more elements of input."
  (segment-match pattern input bindings 1))

(defun segment-match? (pattern input bindings)
  "Match zero or one element of input."
  (let ((var (second (first pattern)))
      (pat (rest pattern)))
    (or (pat-match (cons var pat) input bindings)
      (pat-match pat input bindings))))
```

Наконец, мы предоставляем функцию для проверки произвольного фрагмента кода Лиспа.
Это достигается путем выполнения кода с привязками подразумеваемыми списком привязок.
Это один из немногих случаев, когда уместно вызвать `eval`: когда мы хотим предоставить пользователю неограниченный доступ к интерпретатору Лисп.

```lisp
(defun match-if (pattern input bindings)
  "Test an arbitrary expression involving variables
  The pattern looks like ((?if code) . rest)."
  (and (progv (mapcar #'car bindings)
        (mapcar #'cdr bindings)
      (eval (second (first pattern))))
    (pat-match (rest pattern) input bindings)))
```
Прим. преводчика: код предложенный автором в common lisp не работает, т.к. eval вычисляется в нулевом лексическом окружении, поэтому его создание с помощью progv бесполезно.
Я предлагаю  реализовать эту функцию воспользовашись функцией подстановки значений переменных в заданный образец с помощью функции sublis.


```lisp
(defun match-if (pattern input bindings)
  "Проверить произвольное выражение с переменными
   Образец выглядит как ((?if code) . rest)"
  (and (eval (sublis bindings (second (first pattern))))
       (pat-match (rest pattern) input bindings)))
```


Вот два примера использования `?if`.
Первый успешен, потому что `(+  3 4)` действительно `7`, и второй неудачен, потому что `(>  3 4)` является ложным.

```lisp
> (pat-match  '(?x ?op ?y is ?z (?if (eql (?op ?x ?y) ?z))) '(3 + 4 is 7)) => ((?Z . 7) (?Y . 4) (?OP . +) (?X . 3))
> (pat-match  '(?x ?op ?y (?if (?op ?x ?y))) '(3 > 4)) => NIL
```

Синтаксис, который мы определили для образцов имеет два достоинства: во-первых, синтаксис очень общий, поэтому его легко расширить.
Во-вторых, синтаксисом может легко управлять `pat-match`.
Однако, есть один недостаток: синтаксис многословен, и некоторые могут счесть его уродливым.
Сравните следующие два образца:

```lisp
(a (?* ?x) (?* ?y) d)
(a ?x* ?y* d)
```

Многие читатели находят, что второй образец легче понять с первого взгляда.
Мы могли бы изменить `pat-match`, чтобы учесть образцы формы `?x*`, но это означало бы, что `pat-match` будет выполнять гораздо больше работы, для выполнения каждого соответствия.
Альтернативой является оставить `pat-match` как есть, но определить другой уровень синтаксиса для использования только человеком читателем.
То есть программист может ввести второе выражение выше и преобразовать его в первое, которое затем будет обработано с помощью `pat-match`.

Другими словами, мы определим средство для определения своего рода макроса сопоставления с образцом, который будет расширен при первом просмотре образца.
Лучше сделать это расширение один раз, чем усложнять `pat-match` и фактически делать это расширение каждый раз, когда используется образец.
(Конечно, если образец используется только один раз, то нет никакого преимущества.
Но в большинстве программ каждый образец будет использоваться снова и снова.)

Нам нужно определить две функции: одну для определения макроса сопоставления с образцом, а другую для развертывания образцов, которые могут содержать эти макросы.
Мы разрешаем только символыам быть макросами, поэтому разумно хранить расширение в списке свойств каждого символа:

```lisp
(defun pat-match-abbrev (symbol expansion)
  "Define symbol as a macro standing for a pat-match pattern."
  (setf (get symbol 'expand-pat-match-abbrev)
    (expand-pat-match-abbrev expansion))

(defun expand-pat-match-abbrev (pat)
  "Expand out all pattern matching abbreviations in pat."
  (cond ((and (symbolp pat) (get pat 'expand-pat-match-abbrev)))
      ((atom pat) pat)
      (t (cons (expand-pat-match-abbrev (first pat))
          (expand-pat-match-abbrev (rest pat))))))
```

Мы бы использовали эту возможность следующим образом:

```lisp
> (pat-match-abbrev '?x* '(?* ?x)) => (?* ?X)
> (pat-match-abbrev '?y* '(?* ?y)) => (?* ?Y)
> (setf axyd (expand-pat-match-abbrev '(a ?x* ?y* d))) => (A (?* ?X) (?* ?Y) D)
> (pat-match axyd '(a b c d)) => ((?Y B C) (?X))
```

**Exercise  6**.**1** [**m**] Вернитесь назад и измените правила ELIZA, чтобы использовать возможность сокращения.
Легче ли стало читать правила?

**Exercise  6**.**2** [**h**] В нескольких предыдущих примерах эта привязка обнаруживалась каждый раз, когда выполнялась привязка переменных образца, удовлетворяющих входным данным.
Неформально покажите, что `pat-match` всегда найдет такую привязку, или покажите контрпример, где она не может ее найти.

## 6.3 Инструмент Преобразования На Основе Правил

Как мы определили, сопоставитель с образцом сопоставляет один ввод с одним образцом.
В `eliza` нам нужно сопоставить каждый ввод с рядом образцов, а затем вернуть результат на основе правила, содержащего первый совпадающий образец.
Чтобы освежить вашу память, вот функция `use-eliza-rules`:

```lisp
(defun use-eliza-rules (input)
  "Find some rule with which to transform the input."
  (some #'(lambda (rule)
      (let ((result (pat-match (rule-pattern rule) input)))
        (if (not (eq result fail))
          (sublis (switch-viewpoint result)
            (random-elt (rule-responses rule))))))
    *eliza-rules*))
```

Оказывается, это довольно обычная вещь: поиск в списке правил подходящего правила и выполнение действий в соответствии с этим правилом.
Чтобы превратить структуру `use-eliza-rules` в программный инструмент, мы позволим пользователю указать каждое из следующих действий:

*   * Какое правило использовать.
Каждое правило будет охарактеризовано как if-part и then-part, но способы достижения этих двух частей могут отличаться.

*   Какой список правил использовать.
Очень часто, для каждого приложения будет свой список правил.

*   Как узнать, соответствует ли правило.
По умолчанию мы будем использовать `pat-match`, но должна быть возможность использование других сопоставителей.

*   Что делать при совпадении правила.
После того как мы определили, какое правило использовать, мы должны определить, что означает его использование.
По умолчанию привязка совпадения просто подставляется в часть then-part правила.

Инструмент преобразования на основе правил теперь выглядит так:

```lisp
(defun rule-based-translator
      (input rules &key (matcher #'pat-match)
        (rule-if #'first) (rule-then #'rest) (action #'sublis))
  "Find the first rule in rules that matches input,
  and apply the action to that rule."
  (some
    #'(lambda (rule)
        (let ((result (funcall matcher (funcall rule-if rule)
                input)))
        (if (not (eq result fail))
          (funcall action result (funcall rule-then rule)))))
    rules))

(defun use-eliza-rules (input)
  "Find some rule with which to transform the input."
  (rule-based-translator input *eliza-rules*
    :action #'(lambda (bindings responses)
          (sublis (switch-viewpoint bindings)
                (random-elt responses)))))
```

## 6.4 набор инструментов поиска

Программа GPS может рассматриваться как проблема решаемая *поиском*.
В общем, задача поиска включает нахождение(исследование/проверка) из некоторого начального состояния и исследования соседних состояний, и т.д. пока не будет найдено решение(необходимое состояние).
Как и в GPS, *состояние* означает описание любой ситуации или положения дел.
У каждого состояния может быть несколько соседей, поэтому необходим выбор способа поиска.
Мы можем идти по одному пути, пока не увидим, что это тупик, или мы можем рассматривать множество разных путей одновременно, расширяя каждый путь шаг за шагом.
Проблемы поиска называются *недетерминированными*, потому что невозможно определить, что лучше всего предпринять дальше.
Проблемы ИИ по самой своей природе, как правило, недетерминированы.
Это может сбивать с толку программистов, привыкших к детерминированным задачам.
В этом разделе мы попытаемся прояснить эту путаницу.
Этот раздел также служит примером того, как функции высшего порядка могут использоваться для реализации общих инструментов, которые могут быть определены при помощи передачи специальных функций.

Абстрактно задачу поиска можно охарактеризовать четырьмя признаками:

*   *Начальное/start* состояние.

*   *Целевое/goal* состояние (или состояния).

*   *Наследники/преемники/successors* или состояния, которые могут быть достигнуты из любого другого состояния.


*   *Стратегия/strategy*, определяющая *порядок* поиска.

Первые три признака являются частью проблемы, а четвертый - частью решения.
В GPS было дано начальное состояние вместе с описанием состояний цели.
Состояния наследники определялись путем консультаций с операторами.
Стратегия поиска заключалась в анализе конечных целей.
Это никогда не оговаривалось явно, но было скрыто в структуре всей программы.
В этом разделе мы сформулируем общий инструмент поиска, покажем, как его можно использовать для реализации нескольких различных стратегий поиска, а затем покажем, как с помощью этого инструмента можно реализовать GPS.

Первое понятие, которое мы должны определить, - это *пространство состояний* или набор всех возможных состояний.
Мы можем рассматривать состояния как узлы, а отношения к наследнику как связи на графе.
Некоторые графы пространства состояний будут иметь небольшое количество состояний, в то время как другие - бесконечное количество, но их все же можно решить, если мы будем искать с умом.
Некоторые графы будут иметь регулярную структуру, в то время как другие - случайную.
Мы начнем с рассмотрения только деревьев, то есть графов, в которых состояние может быть достигнуто только одной уникальной последовательностью ссылок на наследников/преемников.
Вот дерево:

![u06-01](images/chapter6/u06-01.jpg)

### Поиск по Дереву

Мы назовем наш первый инструмент поиска `tree-search`, потому что он предназначен для поиска в пространстве состояний, которые имеют форму деревьев.
Требуется четыре аргумента: (1) список допустимых начальных состояний, (2) предикат, чтобы решить, достигли ли мы целевого состояния, (3) функция, чтобы генерировать преемников состояния, и (4) функция, которая решает, в каком порядке искать.
Первый аргумент-это список, а не одно состояние, так что `tree-search` может рекурсивно вызвать себя после того, как он исследовал несколько путей в пространстве состояний.
Думайте о первом аргументе не как о начальном состоянии, а как о списке возможных состояний, из которых может быть достигнута цель.
Этот список представляет собой край дерева, который был исследован до сих пор.
`tree-search` имеет три случая: если больше нет состояний для рассмотрения, то алгоритм сдается и возвращает `fail`.
Если первое возможное состояние - это состояние цели, то возвращается успешное состояние.
В противном случае создаются наследники/преемники первого состояния и присоединяются к другим состояниям.
Порядок в этом комбинированном списке устанавливается в соответствии с конкретной стратегией поиска и продолжает поиск.
Обратите внимание, что `tree-search` сам по себе не определяет никакой конкретной стратегии поиска.

```lisp
(defun tree-search (states goal-p successors combiner)
  "Find a state that satisfies goal-p.
   Start with states,and search according to successors and combiner."
  (dbg :search "~&; ; Search: ~  a" states)
  (cond ((null states) fail)
      ((funcall goal-p (first states)) (first states))
      (t (tree-search
          (funcall combiner
                (funcall successors (first states))
                (rest states))
          goal-p successors combiner))))
```

Первая стратегия, которую мы рассмотрим, называется *поиск в глубину/depth-first search*.
При поиске в глубину сначала рассматриваются самые длинные пути.
Другими словами, мы создаем наследников состояния, а затем сначала работаем над первым наследником.
Мы возвращаемся к одному из последующих наследников только в том случае, если достигаем состояния, в котором вообще нет наследников.
Эта стратегия может быть реализована простым добавлением предыдущих состояний в конец списка новых наследников на каждой итерации.
Функция `depth-first-search` принимает одно начальное состояние, предикат цели и функцию-наследников.
Она упаковывает начальное состояние в список, как и ожидалось при `tree-search`, и указывает append в качестве комбинирующей функции:

```lisp
(defun depth-first-search (start goal-p successors)
  "Search new states first until goal is reached."
  (tree-search (list start) goal-p successors #'append))
```

Давайте посмотрим, как мы можем искать в двоичном дереве, определенном ранее.
Сначала мы определяем функцию-генерации наследников `binary-tree`.
Она возвращает список из двух состояний: два числа, одно вдвое превышает входное состояние, и второе на один больше первого.
Таким образом, наследниками 1 будут 2 и 3, а наследниками 2 будут 4 и 5.
Функция `binary-tree` генерирует бесконечное дерево, первые 15 узлов которого показаны в нашем примере.

```lisp
(defun binary-tree (x) (list (* 2 x) (+  1 (* 2 x))))
```

Чтобы упростить определение цели, мы определяем функцию как функцию, которая возвращает предикат, проверяющий конкретное значение.
Обратите внимание, что это не сам тест.
Скорее, он возвращает функцию, которую можно вызвать для выполнения тестов:

```lisp
(defun is (value) #'(lambda (x) (eql x value)))
```

Теперь мы можем включить вывод отладки и выполнить поиск в двоичном дереве, начиная с 1 и ища, скажем, 12 в качестве состояния цели.
Каждая строка вывода отладки показывает список состояний, которые были сгенерированы как наследники, но еще не исследованы:

```lisp
> (debug :search) => (SEARCH)
> (depth-first-search 1 (is 12) #'binary-tree)
;; Search: (1)
;; Search: (2 3)
;; Search: (4 5 3)
;; Search: (8 9 5 3)
;; Search: (16 17 9 5 3)
;; Search: (32 33 17 9 5 3)
;; Search: (64 65 33 17 9 5 3)
;; Search: (128 129 65 33 17 9 5 3)
;; Search: (256 257 129 65 33 17 9 5 3)
;; Search: (512 513 257 129 65 33 17 9 5 3)
;; Search: (1024 1025 513 257 129 65 33 17 9 5 3)
;; Search: (2048 2049 1025 513 257 129 65 33 17 9 5 3)
[Abort]
```

Проблема в том, что мы ищем в бесконечном дереве, а стратегия поиска в глубину просто ныряет вниз по левой ветви на каждом шаге.
Единственный способ остановить обреченный поиск - это набрать код прерывания.

Альтернативной стратегией является *поиск в ширину/breadth-first search*, когда кратчайший путь исследуется/продолжается первым на каждом шаге.
Её можно реализовать, просто добавив новые состояния-наследники в конец существующих состояний:

```lisp
(defun prepend (x y) "Prepend y to start of x" (append y x))

(defun breadth-first-search (start goal-p successors)
  "Search old states first until goal is reached."
  (tree-search (list start) goal-p successors #'prepend))
```

Единственная разница между поиском в глубину и в ширину - это разница между `append` и `prepend`.
Здесь мы видим поиск в ширину - `breadth-first-search` - в действии:

```lisp
> (breadth-first-search 1 (is 12) 'binary-tree)
;; Search: (1)
;; Search: (2 3)
;; Search: (3 4 5)
;; Search: (4 5 6 7)
;; Search: (5 6 7 8 9)
;; Search: (6 7 8 9 10 11)
;; Search: (7 8 9 10 11 12 13)
;; Search: (8 9 10 11 12 13 14 15)
;; Search: (9 10 11 12 13 14 15 16 17)
;; Search: (10 11 12 13 14 15 16 17 18 19)
;; Search: (11 12 13 14 15 16 17 18 19 20 21)
;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)
12
```

Поиск в ширину сначала ищет соседей каждого узла в числовом порядке, и поэтому он в конечном итоге найдет любую цель.
Это методично, а, следовательно медленно и тяжело.
Поиск в глубину  будет намного быстрее - если ему вообще удастся найти цель.
Например, если бы мы искали 2048, то поиск в глубину занял бы 12 шагов, а поиск в ширину-2048 шагов.
Поиск в ширину также требует большего объема памяти, поскольку он сохраняет больше промежуточных состояний.

Если дерево поиска конечно, то цель в конечном итоге будет найдена либо поиском в ширину, либо поиском в глубину.
Оба метода выполняют поиск во всем пространстве состояний, но в различном порядке.
Теперь мы покажем поиск в глубину в двоичном дереве из 15 узлов, представленном ранее.
На поиск цели (12) уходит примерно столько же времени, сколько и при поиске в ширину.
Чтобы найти 15, потребовалось бы больше времени; и меньше, чтобы найти 8.
Большая разница в количестве состояний, рассматриваемых одновременно.
Самое большее, поиск в глубину рассматривает одновременно четыре; в общем, для поиска по дереву *n-узлов* требуется хранить только состояния *log2 n*, тогда как поиск в ширину должен сохранять состояния *n/2*.

```lisp
(defun finite-binary-tree (n)
  "Return a successor function that generates a binary tree
  with n nodes."
  #'(lambda (x)
          (remove-if #'(lambda (child) (> child n))
                (binary-tree x))))

```

```lisp		
> (depth-first-search 1 (is 12) (finite-binary-tree 15))
;; Search: (1)
;; Search: (2 3)
;; Search: (4 5 3)
;; Search: (8 9 5 3)
;; Search: (9 5 3)
;; Search: (5 3)
;; Search: (10 11 3)
;; Search: (11 3)
;; Search: (3)
;; Search: (6 7)
;; Search: (12 13 7)
12
```

### Управление поиском

Хотя поиск в ширину более методичен, ни одна из стратегий не может использовать какие-либо знания о пространстве состояний.
Оба этих поиска ищут вслепую.
В большинстве реальных приложений мы будем иметь некоторую оценку того, насколько далеко состояние находится от решения.
В таких случаях мы можем реализовать *поиск по первому наилучшему/best-first*.
Название не совсем точное; если бы мы действительно могли найти первого лучшего, это был бы совсем не поиск.
Название указывает на то, что вначале ищется состояние, которое *кажется* лучшим.

Чтобы реализовать поиск "первый-наилучший", нам нужно добавить еще одну информацию: функцию стоимости, которая дает оценку того, насколько далеко данное состояние находится от цели.

Например с бинарным деревом мы будем использовать в качестве оценки стоимости численное отличие от цели.
Итак, если мы ищем 12, то 12 стоит 0, 8 стоит 4, а 2048 стоит 2036.
Функция высшего порядка `diff`, показанная ниже, возвращает функцию стоимости, которая вычисляет отличие(дистанцию) от(до) цели.
Функция высшего порядка sorter принимает функцию стоимости в качестве аргумента и возвращает объединенную функцию, которая берет списки старых и новых состояний, соединяет их вместе и сортирует результат на основе функции стоимости, ставя в начало наименьшую стоимость.
(Встроенная функция `sort` сортирует список в соответствии с функцией сравнения.
В этом случае на первом месте стоят меньшие числа.
`sort` принимает необязательный аргумент `: key`, который говорит, как вычислить цену для каждого элемента.
Будьте осторожны - `sort` - это разрушающая функция.)

```lisp
(defun diff (num)
  "Return the function that finds the difference from num."
  #'(lambda (x) (abs (- x num))))

(defun sorter (cost-fn)
  "Return a combiner function that sorts according to cost-fn."
  #'(lambda (new old)
      (sort (append new old) #'< :key cost-fn)))

(defun best-first-search (start goal-p successors cost-fn)
  "Search lowest cost states first until goal is reached."
  (tree-search (list start) goal-p successors (sorter cost-fn)))
```

Теперь, используя отличие от цели в качестве функции стоимости, мы можем искать с помощью поиска best-first:

```lisp
> (best-first-search 1 (is 12) #'binary-tree (diff 12))
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (14 15 6 2)
;; Search: (15 6 2 28 29)
;; Search: (6 2 28 29 30 31)
;; Search: (12 13 2 28 29 30 31)
12
```

Чем больше мы знаем о пространстве состояний, тем лучше мы можем искать.
Например, если мы знаем, что все наследники больше, чем состояния, из которых они происходят, то мы можем использовать функцию стоимости, которая дает очень высокую стоимость для чисел превышающих цель.
Функция `price-is-right` похожа на `diff`, за исключением того, что она дает высокий штраф за превышение цели.[3](#fn0025) использование этой функции стоимости приводит к почти оптимальному поиску в данном примере.
Он совершает "ошибку" поиска находя 7 перед 6 (потому что 7 ближе к 12), но не тратит время на поиск 14 и 15:

```lisp
(defun price-is-right (price)
  "Return a function that measures the difference from price,
  but gives a big penalty for going over price."
  #'(lambda (x) (if (> x price)
              most-positive-fixnum
              (- price x))))

> (best-first-search 1 (is 12) #'binary-tree (price-is-right 12)) ;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (6 2 14 15)
;; Search: (12 2 13 14 15)
12
```

Все методы поиска, которые мы видели до сих пор, рассматривали постоянно увеличивающиеся списки состояний, по мере выполнения поиска.
Для проблем, где есть только одно решение или небольшое число решений, это неизбежно.
Чтобы найти иголку в стоге сена, нужно просмотреть кучу сена.
Но для проблем со многими решениями, возможно, стоит отказаться от бесперспективных путей.
При этом возникнет риск вообще не найти решение, но это может сэкономить достаточно места и времени, чтобы компенсировать этот риск.
Поиск наилучшего первого(best-first), который сохраняет только фиксированное число альтернативных состояний в любой момент времени, известен как поиск по лучу(*beam search*).
Думайте о поиске как о луче света сквозь тьму пространства состояний.
В других стратегиях поиска свет расширяется по мере того, какёёёёёёёёёёёёё мы ищем глубже, но в поиске по лучу свет остается плотно сфокусированным.
Поиск по лучу-это вариант поиска первого лучшего(best-first), но он также похож на поиск в глубину.
Разница заключается в том, что поиск по лучу смотрит на несколько путей сразу, а не только на один, и выбирает лучший из них, чтобы посмотреть на следующий.
Но он отказывается от возможности бесконечно возвращаться назад.
Функция `beam-search` точно такая же, как `best-first-search`, за исключением того, что после сортировки состояний мы берем только первые состояния `beam-width`.
Это делается с помощью `subseq`; `(subseq list start end)` возвращает подсписок, который начинается в позиции *start* и заканчивается непосредственно перед позицией *end*.

```lisp
(defun beam-search (start goal-p successors cost-fn beam-width)
  "Search highest scoring states first until goal is reached,
  but never consider more than beam-width states at a time."
  (tree-search (list start) goal-p successors
        #'(lambda (old new)
          (let ((sorted (funcall (sorter cost-fn) old new)))
            (if (> beam-width (length sorted))
              sorted
              (subseq sorted 0 beam-width))))))
```

Мы можем успешно искать 12 в двоичном дереве используя ширину луча только 2:

```lisp
> (beam-search 1 (is 12) #'binary-tree (price-is-right 12) 2)
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6)
;; Search: (6 14)
;; Search: (12 13)
12
```

Однако если мы вернемся к функции scoring(подсчета очков), которая просто принимает разницу от 12, то поиск по лучу завершится неудачей.
Когда он генерирует 14 и 15, он отбрасывает 6, и таким образом теряет свой единственный шанс найти цель:

```lisp
> (beam-search 1 (is 12) #'binary-tree (diff 12) 2)
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6)
;; Search: (14 15)
;; Search: (15 28)
;; Search: (28 30)
;; Search: (30 56)
;; Search: (56 60)
;; Search: (60 112)
;; Search: (112 120)
;; Search: (120 224)
[Abort]
```

Этот поиск был бы успешным, если бы мы задали ширину луча равную 3.
Это иллюстрирует общий принцип: мы можем найти цель, либо просматривая на большее количество состояний, либо будучи информированее в отношении состояний, на которые мы смотрим.
Это означает, что у вас есть лучшая функция упорядочения.

Обратите внимание, что при бесконечной ширине луча мы получаем поиск первого лучшего.
При ширине луча 1 мы получаем поиск в глубину без возвратов.
Это можно было бы назвать "глубинным поиском", но он более широко известен как *восхождение на холм*.
Представьте себе альпиниста, пытающегося достичь вершины в густом тумане.
Одна из стратегий заключается в том, чтобы альпинист посмотрел на соседние локации, поднялся на самую высокую и снова посмотрел.
Эта стратегия может в конечном итоге достичь пика, но она также может застрять на вершине предгорья или *локального максимума*.
Другая стратегия была бы для альпиниста, чтобы повернуть назад и попробовать снова, когда туман поднимается, но в AI, к сожалению, туман редко поднимается.[4](#fn0030)

В качестве конкретного примера задачи, которую можно решить с помощью поиска, рассмотрим задачу планирования полета через североамериканский континент на небольшом самолете, дальность полета которого ограничена 1000 километрами.
Предположим, у нас есть список выбранных городов с аэропортами, а также их положение по долготе и широте:

```lisp
(defstruct (city (:type list)) name long lat)

(defparameter *cities*
   '((Atlanta        84.23 33.45)      (Los Angeles       118.15 34.03)     
   (Boston           71.05 42.21)      (Memphis           90.03 35.09)     
   (Chicago          87.37 41.50)      (New York          73.58 40.47)     
   (Denver           105.00 39.45)     (Oklahoma City     97.28 35.26)     
   (Eugene           123.05 44.03)     (Pittsburgh        79.57 40.27)     
   (Flagstaff        111.41 35.13)     (Quebec            71.11 46.49)     
   (Grand Jet        108.37 39.05)     (Reno              119.49 39.30)    
   (Houston          105.00 34.00)     (San Francisco     122.26 37.47)    
   (Indianapolis     86.10 39.46)      (Tampa             82.27 27.57)     
   (Jacksonville     81.40 30.22)      (Victoria          123.21 48.25)    
   (Kansas City      94.35 39.06)      (Wilmington        77.57 34.14)))   
```

В этом примере вводится новая опция для `defstruct`.
Вместо того чтобы просто дать название структуре, можно также использовать:

```lisp
(defstruct (structure-name (option value)...) "optional doc" slot...)
```

Для города опция :type указывается как `list`.
Это означает, что города будут реализованы в виде списков из трех элементов, так как они находятся в начальном значении для `*cities*`.

Города показаны на карте в [[figure  6.1](#f0010), которая имеет связи между всеми городами в пределах 1000-километрового диапазона друг от друга. [5](#fn0035) Эта карта была нарисована с помощью функции `air-distance`, которая возвращает расстояние в километрах между двумя городами "по мере полета вороны".- Она будет определена позже.
Две другие полезные функции - это `neighbors`(соседи), которая находит все города в радиусе 1000 километров, и `city`(город), которая отображает имя города.
Первая использует `find-all-if`, которая была определена на [стр. 101](B9780080571157500030.xhtml#p101) как синоним для `remove-if-not`.

| []()                                  |
|---------------------------------------|
| ![f06-01](images/chapter6/f06-01.jpg) |
| Figure 6.1: Карта некоторых городов   |

```lisp
(defun neighbors (city)
  "Find all cities within 1000 kilometers."
  (find-all-if #'(lambda (c)
          (and (not (eq c city))
              (< (air-distance c city) 1000.0)))
        *cities*))

(defun city (name)
  "Find the city with this name."
  (assoc name *cities*))
```

Теперь мы готовы планировать поездку.
Функция `trip`(поездка) принимает название города отправления и назначения и выполняет поиск по лучу шириной в единицу, рассматривая всех соседей как преемников состояния.
Стоимость для состояния - это расстояние по воздуху до города назначения:

```lisp
(defun trip (start dest)
  "Search for a way from the start to dest."
  (beam-search start (is dest) #'neighbors
          #'(lambda (c) (air-distance c dest))
          1))
```

Здесь мы планируем поездку из Сан-Франциско в Бостон.
Результат кажется наилучшим из возможных путей:

```lisp
> (trip (city 'san-francisco) (city 'boston))
;; Search: ((SAN-FRANCISCO 122.26 37.47))
;; Search: ((RENO 119.49 39.3))
;; Search: ((GRAND-JCT 108.37 39.05))
;; Search: ((DENVER 105.0 39.45))
;; Search: ((KANSAS-CITY 94.35 39.06))
;; Search: ((INDIANAPOLIS 86.1 39.46))
;; Search: ((PITTSBURGH 79.57 40.27))
;; Search: ((BOSTON 71.05 42.21))
(BOSTON 71.05 42.21)
```

Но посмотрите, что происходит, когда мы планируем обратный путь.
Есть два объезда, в Чикаго и Флагстафф:

```lisp
> (trip (city 'boston) (city 'san-francisco))
;; Search: ((BOSTON 71.05 42.21))
;; Search: ((PITTSBURGH 79.57 40.27))
;; Search: ((CHICAGO 87.37 41.5))
;; Search: ((KANSAS-CITY 94.35 39.06))
;; Search: ((DENVER 105.0 39.45))
;; Search: ((FLAGSTAFF 111.41 35.13))
;; Search: ((RENO 119.49 39.3))
;; Search: ((SAN-FRANCISCO 122.26 37.47))
(SAN-FRANCISCO 122.26 37.47)
```

Почему `trip` отправился из Денвера в Сан-Франциско через Флагстафф?
Потому что Флагстафф ближе к месту назначения, чем Grand Junction.
Проблема в том, что мы минимизируем расстояние до пункта назначения на каждом шаге, тогда как мы должны минимизировать сумму расстояний до пункта назначения плюс уже пройденное расстояние.

### Поиск Путей

Чтобы свести к минимуму общее расстояние, нам нужно каким-то образом поговорить о пути(*path*), ведущем к цели.
Но функции, которые мы определили до сих пор, имеют дело только с отдельными состояниями на этом пути.
Представление путей привело бы к еще одному преимуществу: мы могли бы вернуть путь как решение, а не просто вернуть целевое состояние.
Как бы то ни было, `trip` возвращает только целевое состояние, а не путь к нему.
Таким образом, нет никакого способа определить, что сделал `trip`, кроме как прочитав выходные данные отладки.

Структура данных путь(path) предназначена для решения обеих этих проблем.
Путь имеет четыре поля: текущее состояние, предыдущая часть пути, которую продолжает этот путь, стоимость пути до сих пор и оценка общей стоимости до достижения цели.
Вот определение структуры для path.
Она использует опцию `:print-function`, чтобы сказать, что все пути должны быть напечатаны с помощью функции `print-path`, которая будет определена ниже.

```lisp
(defstruct (path (:print-function print-path))
    state (previous nil) (cost-so-far 0) (total-cost 0))
```

Следующий вопрос заключается в том, как интегрировать пути в процедуры поиска с наименьшим количеством переделок.
Очевидно, что было бы лучше внести одно изменение в `tree-search`(поиск по дереву), а не менять `depth-first-search`, `breadth-first-search` и `beam-search`
Однако, оглядываясь назад на определение `tree-search`, мы видим, что оно не делает никаких предположений о структуре состояний, кроме того факта, что ими можно манипулировать с помощью функций предиката цели, функции определения приемников и функции объединителя/комбинатора.
Это предполагает, что мы можем использовать `tree-search` без изменений, если мы передадим ей пути вместо состояний и предоставим ей функции, которые могут обрабатывать пути.

В следующем переопределении `trip` функция `beam-search` вызывается с пятью аргументами.
Вместо того, чтобы передать ей город в качестве начального состояния, мы передаем путь, который имеет город в качестве своего поля состояния.
Предикат цели должен проверить, является ли его аргумент путем, состояние которого является назначением; мы предполагаем (и позже определяем) версию `is`, которая вмещает её.
Функция successor(преемник) - самая сложная.
Вместо того чтобы просто генерировать список соседей, мы хотим сначала сгенерировать соседей, а затем превратить каждый из них в путь, который расширяет текущий путь, но с обновленной стоимостью уплаченной сих пор и общей расчетной стоимостью.
Функция `path-saver` возвращает функцию, которая будет делать именно это.
Наконец, функция cost(стоимости), которую мы пытаемся минимизировать, - это `path-total-cost` и мы предоставляем ширину луча, которая теперь является необязательным аргументом для `trip`, и которая по умолчанию равна единице:

```lisp
(defun trip (start dest &optional (beam-width 1))
  "Search for the best path from the start to dest."
  (beam-search
    (make-path :state start)
    (is dest :key #'path-state)
    (path-saver #'neighbors #'air-distance
          #'(lambda (c) (air-distance c dest)))
#'path-total-cost
beam-width))
```

Расчет `air-distance` включает в себя некоторое сложное преобразование долготы и широты в координаты `x-y-z`.
Поскольку это проблема геометрии, а не искусственного интеллекта, код представлен без дальнейших комментариев:

```lisp
(defconstant earth-diameter 12765.0
  "Diameter of planet earth in kilometers.")
(defun air-distance (city1 city2)
  "The great circle distance between two cities."
  (let ((d (distance (xyz-coords city1) (xyz-coords city2))))
    ;; d is the straight-line chord between the two cities,
    ;; The length of the subtending arc is given by:
    (* earth-diameter (asin (/ d 2)))))

(defun xyz-coords (city)
  "Returns the x,y,z coordinates of a point on a sphere.
  The center is (0 0 0) and the north pole is (0 0 1)."
  (let ((psi (deg->radians (city-lat city)))
        (phi (deg->radians (city-long city))))
      (list (* (cos psi) (cos phi))
            (* (cos psi) (sin phi))
            (sin psi))))

(defun distance (point1 point2)
  "The Euclidean distance between two points.
  The points are coordinates in n-dimensional space."
  (sqrt (reduce #'+ (mapcar #'(lambda (a b) (expt (- a b) 2))
                point1 point2))))

(defun deg->radians (deg)
  "Convert degrees and minutes to radians."
  (* (+ (truncate deg) (* (rem  deg 1) 100/60)) pi 1/180))
```

Прежде чем показать вспомогательные функции, которые реализуют это, вот несколько примеров, которые показывают, что она может сделать.
При ширине луча 1 проезд через Флагстаффа исключается, но остается объезд через Чикаго.
При ширине луча 3 найден правильный оптимальный путь.
В следующих примерах каждый вызов новой версии `trip` возвращает путь, который печатается с помощью `show-city-path`:

```lisp
> (show-city-path (trip (city 'san-francisco) (city 'boston) 1))
#<Path 4514.8  km: San-Francisco - Reno - Grand-Jet - Denver -
  Kansas-City - Indianapolis - Pittsburgh - Boston  >
> (show-city-path (trip (city 'boston) (city 'san-francisco) 1))
#<Path 4577.3  km: Boston - Pittsburgh - Chicago - Kansas-City -
  Denver - Grand-Jet - Reno - San-Francisco  >
> (show-city-path (trip (city 'boston) (city 'san-francisco) 3))
#<Path 4514.8  km: Boston - Pittsburgh - Indianapolis -
  Kansas-City - Denver - Grand-Jet - Reno - San-Francisco  >
```

Этот пример показывает, как поиск подвержен нарушениям в пространстве поиска.
Было легко найти правильный путь с запада на восток, но обратный путь потребовал больше поисков, потому что Флагстафф - это ложный многообещающий шаг.
В общем, в пространстве поиска могут таиться еще худшие тупики.
Посмотрите, что происходит, когда мы ограничиваем дальность полета самолета до 700 километров.
Карта показана на [рис. 6.2](#f0015).

| []()                                      |
|-------------------------------------------|
| ![f06-02](images/chapter6/f06-02.jpg)     |
| Рис.6.2: Карта городов с достиж. в 700 км |

Если мы попытаемся спланировать поездку из Тампы в Квебек, у нас могут возникнуть проблемы с тупиком в Уилмингтоне, Северная Каролина.
При ширине луча 1 путь в Джексонвилл(Jacksonville), а затем в Уилмингтон(Wilmington) будет опробован в первую очередь.
Оттуда каждый шаг пути чередуется между Атлантой(Atlanta) и Уилмингтоном(Wilmington).
Поиск никогда не приближается к цели.
Но при ширине Луча 2 путь из Тампы в Атланту не отбрасывается, и в конечном итоге он продолжается до Индианаполиса и, в конечном счете, до Квебека.
Таким образом, возможность возврата имеет важное значение для избежания тупиков.

Теперь перейдем к деталям реализации.
Функция `is` по-прежнему возвращает предикат, который проверяет значение, но теперь она принимает ключевые слова `:key` и `:test`:

```lisp
(defun is (value &key (key #'identity) (test #'eql))
  "Returns a predicate that tests for a given value."
  #'(lambda (path) (funcall test value (funcall key path))))
```

Функция `path-saver` возвращает функцию, которая будет принимать путь в качестве аргумента и генерировать пути-преемники.
`path-saver` принимает в качестве аргумента функцию-генерации преемников, которая работает с голыми состояниями.
Она вызывает эту функцию и для каждого возвращенного состояния создает путь, который расширяет существующий путь и сохраняет стоимость пути пройденного до сих пор, а также предполагаемую общую стоимость:

```lisp
(defun path-saver (successors cost-fn cost-left-fn)
  #'(lambda (old-path)
      (let ((old-state (path-state old-path)))
        (mapcar
          #'(lambda (new-state)
            (let ((old-cost
                  (+ (path-cost-so-far old-path)
                      (funcall cost-fn old-state new-state))))
              (make-path
                :state new-state
                :previous old-path
                :cost-so-far old-cost
                :total-cost (+ old-cost (funcall cost-left-fn
                        new-state)))))
          (funcall successors old-state)))))
```

По умолчанию структура path будет напечатана как `#S ( PATH ... )`.
Но поскольку каждый путь имеет поле `previous`, которое заполняется другим путем, этот вывод будет довольно подробным.
Вот почему мы установили `print-path` в качестве функции печати для путей, когда определяли структуру.
Она использует обозначение `#<...>` , что является общим соглашением Lisp для вывода на печать, который не может быть восстановлен с помощью `read`.
Функция `show-city-path` выводит более полное представление пути.
Мы также определяем `map-path` для итерации(прхода) по пути, для сбора значений:

```lisp
(defun print-path (path &optional (stream t) depth)
  (declare (ignore depth))
  (format stream "#<Path to ~a cost ~,lf>"
        (path-state path) (path-total-cost path)))

(defun show-city-path (path &optional (stream t))
  "Show the length of a path, and the cities along it."
  (format stream "#<Path ~,lf km: ~{~:(~a~)~^- ~}>"
        (path-total-cost path)
        (reverse (map-path #'city-name path)))
  (values))

(defun map-path (fn path)
  "Call fn on each state in the path, collecting results."
  (if (null path)
      nil
      (cons (funcall fn (path-state path))
          (map-path fn (path-previous path)))))
```

### Угадывание против гарантированно хорошего решения

В учебниках по элементарному искусственному интеллекту большое внимание уделяется алгоритмам поиска, которые гарантированно найдут наилучшее решение.
Однако на практике эти алгоритмы практически не используются.
Проблема заключается в том, что для того, чтобы гарантировать наилучшее решение, необходимо рассмотреть множество других решений, чтобы исключить их.
Для проблем с большими пространствами поиска это обычно занимает слишком много времени.
Альтернативой является использование алгоритма, который, вероятно, вернет решение, близкое к лучшему решению, но не дает никаких гарантий.
Такие алгоритмы, традиционно известные как алгоритмы *недопустимого эвристического поиска*, могут быть намного быстрее.

Из алгоритмов, которые мы видели до сих пор, поиск  best-first(первый лучший) почти, но не совсем, гарантирует лучшее решение.
Проблема в том, что он заканчивается слишком рано.
Предположим, что он рассчитал три пути стоимостью 90, 95 и 110 долларов.
Затем он расширяет путь 90.
Предположим, что это приводит к решению общей стоимостью 100.
Поиск первого лучшего затем вернет это решение.
Но вполне возможно, что путь 95 может привести к решению с общей стоимостью менее 100.
Возможно, путь 95 находится всего в одной единице от цели, поэтому он может привести к полному пути длиной 96.
Это означает, что оптимальный поиск должен исследовать путь 95 (но не путь 110) перед завершением поиска.

С другой стороны, поиск в глубину и поиск по лучу - это определенно эвристические алгоритмы.
Поиск в глубину находит решение без учета его стоимости.
При поиске по лучу выбор хорошего значения для ширины луча может привести к хорошему, быстрому решению, в то время как выбор неправильного значения может привести к неудаче или к плохому решению.
Один из выходов из этой дилеммы состоит в том, чтобы начать с узкой ширины луча, и если это не приведет к приемлемому решению, расширить Луч и попробовать снова.
Мы будем называть это итеративным расширением, хотя это не стандартный термин.
Есть много вариаций на эту тему, но вот одна простая:

```lisp
(defun iter-wide-search (start goal-p successors cost-fn
                &key (width 1) (max 100))
  "Search, increasing beam width from width to max.
  Return the first solution found at any width."
  (dbg :search "; Width: ~d" width)
  (unless (> width max)
    (or (beam-search start goal-p successors cost-fn width)
      (iter-wide-search start goal-p successors cost-fn
                        :width (+ width 1) :max max))))
```

Здесь `iter-wide-search` использующийся для поиска по двоичному дереву, терпит неудачу с шириной луча 1 и 2, и в конечном итоге преуспевая с шириной луча 3:

```lisp
> (iter-wide-search 1 (is 12) (finite-binary-tree 15) (diff 12))
Width: 1
;; Search: (1)
;; Search: (3)
;; Search: (7)
;; Search: (14)
; Width: 2
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6)
;; Search: (14 15)
;; Search: (15)
;; Search: NIL
; Width: 3
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (14 15 6)
;; Search: (15 6)
;; Search: (6)
;; Search: (12 13)
12
```

Название итеративное расширение происходит от устоявшегося термина `итеративное углубление`.
Итеративное углубление используется для управления поиском в глубину, когда мы не знаем глубину искомого решения.
Идея состоит в том, чтобы сначала ограничить поиск глубиной 1, затем 2 и так далее.
Таким образом, мы гарантированно найдем решение на минимальной глубине, как и при поиске в ширину, но не теряя при этом много места для хранения.
Конечно, итеративное углубление действительно тратит некоторое время, потому что на каждой увеличивающейся глубине оно повторяет всю работу, проделанную на предыдущей глубине.
Но предположим, что среднее состояние имеет десять преемников.
Это означает, что увеличение глубины на единицу приводит к увеличению поиска в десять раз, поэтому только 10% времени тратится на повторную работу.
Таким образом, итеративное углубление использует лишь немного больше времени и гораздо меньше пространства.
Мы увидим это снова в [главах 11](B978008057115750011X.xhtml) и [18](B9780080571157500182.xhtml).

### Графы Поиска

До сих пор `tree-search` была рабочей лошадкой, стоящей за всеми поисковыми процедурами.
Это любопытно, если учесть, что проблема путешествия между городами включает в себя граф, который вовсе не является деревом.
Причина, по которой работает `tree-search`, заключается в том, что любой граф можно рассматривать как дерево, если мы игнорируем тот факт, что некоторые узлы идентичны.
Например, граф на [рис. 6.3](#f0020) может быть представлен в виде дерева.
[Рисунок 6.4](#f0025) показывает только верхние четыре уровня дерева; каждый из нижних узлов (за исключением 6s) нуждается в дальнейшем расширении.

| []()                                  |
|---------------------------------------|
| ![f06-03](images/chapter6/f06-03.jpg) |
| Рис. 6.3: Граф с шестью узлами        |

| []()                                  |
|---------------------------------------|
| ![f06-04](images/chapter6/f06-04.jpg) |
| Рис. 6.4: Соответствующее дерево      |

При поиске путей через граф городов мы неявно превращали граф в дерево.
То есть, если `tree-search` найдет два пути из Питтсбурга в Канзас-Сити (через Чикаго или Индианаполис), то он будет рассматривать их как два независимых пути, точно так же, как если бы было два разных города Канзас.
Это упростило алгоритмы, но также удвоило количество путей, оставшихся для изучения.
Если конечная цель-Сан-Франциско, нам придется искать путь из Канзас-Сити в Сан-Франциско дважды, а не один раз.
На самом деле, хотя граф имеет только 22 города, дерево бесконечно, потому что мы можем перемещаться между соседними городами любое количество раз.
Таким образом, хотя можно рассматривать граф как дерево, существует потенциальная экономия при рассмотрении его как истинного графа.

Функция `graph-search` делает именно это.
Она похожа на `tree-search`, но принимает два дополнительных аргумента: функцию сравнения, которая проверяет, равны ли два состояния, и список состояний, которые больше не рассматриваются, т.к были рассмотрены ранее.
Разница между `graph-search` и `tree-search` заключается в вызове `new-states`, которая генерирует преемников, но устраняет состояния, которые находятся либо в списке рассматриваемых в настоящее время состояний, либо в списке старых состояний, рассматривавшихся в прошлом.

```lisp
(defun graph-search (states goal-p successors combiner &optional (state= #'eql) old-states)
 "Find a state that satisfies goal-p. Start with states,and search according to successors and combiner.
  Don't try the same state twice."
  (dbg :search "~&;; Search: ~a" states)
  (cond ((null states) fail)
        ((funcall goal-p (first states)) (first states))
        (t (graph-search
            (funcall
              combiner
              (new-states states successors state= old-states)
              (rest states))
            goal-p successors combiner state=
            (adjoin (first states) old-states
                      :test state=)))))

(defun new-states (states successors state= old-states)
  "Generate successor states that have not been seen before."
  (remove-if
    #'(lambda (state)
      (or (member state states :test state=)
        (member state old-states :test state=)))
      (funcall successors (first states))))
```

Используя функцию-преемницу `next2`, мы можем искать на графе, показанном здесь, либо в виде дерева, либо в виде графа.
Если мы ищем по нему в виде графа, требуется меньше итераций и меньше места для хранения, чтобы найти цель.
Конечно, существуют дополнительные накладные расходы для проверки идентичности состояний, но на графах, подобных этому, мы получаем экспоненциальное ускорение при постоянном объеме накладных расходов.

```lisp
(defun next2 (x) (list (+ x 1) (+ x 2)))

> (tree-search '(1) (is 6) #'next2 #'prepend)
;; Search: (1)
;; Search: (2 3)
;; Search: (3 3 4)
;; Search: (3 4 4 5)
;; Search:(4 4 5 4 5)
;; Search: (4 5 4 5 5 6)
;; Search: (5 4 5 5 6 5 6)
;; Search: (4 5 5 6 5 6 6 7)
;; Search: (5 5 6 5 6 6 7 5 6)
;; Search: (5 6 5 6 6 7 5 6 6 7)
;; Search: (6 5 6 6 7 5 6 6 7 6 7)
6
> (graph-search '(1) (is 6) #'next2 #'prepend)
;; Search: (1)
;; Search: (2 3)
;; Search: (3 4)
;; Search: (4 5)
;; Search: (5 6)
;; Search: (6 7)
6
```

Следующим шагом является расширение алгоритма графового поиска - `graph-search` для обработки путей.
Сложность заключается в том, чтобы решить, какой путь выбрать, когда два пути достигают одного и того же состояния.
Если у нас есть функция стоимости, то ответ прост: сохраняем путь с более дешевой стоимостью.
Поиск лучшего первого(Best-first в графе, удаляющий повторяющиеся состояния, называется A* поиском.

Поиск A* более сложен, чем  `graph-search`, из-за необходимости как добавлять, так и удалять пути в списках текущих и старых путей.
Для каждого нового состояния-преемника существует три возможности.
Новое состояние может быть в списке текущих путей, в списке старых путей или ни в одном из них.
В первых двух случаях имеются две подслучая.
Если новый путь дороже старого, то игнорируйте новый путь- т.к. он не может привести к лучшему решению.
Если новый путь дешевле, чем соответствующий путь в списке текущих путей, то замените его новым путем.
Если он дешевле, чем соответствующий путь в списке старых путей, то удалите старый путь и поместите новый путь в список текущих путей.

Кроме того, вместо того, чтобы сортировать пути по общей стоимости на каждой итерации, они сортируются, и новые пути вставляются в нужное место по одному с помощью `insert-path`.
Еще две функции `better-path` и `find-path` используются, чтобы сравнить пути и посмотреть, появилось ли уже нужное состояние.

```lisp
(defun a*-search (paths goal-p successors cost-fn cost-left-fn
                  &optional (state= #'eql) old-paths)
  "Find a path whose state satisfies goal-p.  Start with paths,
  and expand successors, exploring least cost first.
  When there are duplicate states, keep the one with the
  lower cost and discard the other."
  (dbg :search ";; Search: ~a" paths)
  (cond
    ((null paths) fail)
    ((funcall goal-p (path-state (first paths)))
     (values (first paths) paths))
    (t (let* ((path (pop paths))
              (state (path-state path)))
         ;; Update PATHS and OLD-PATHS to reflect
         ;; the new successors of STATE:
         (setf old-paths (insert-path path old-paths))
         (dolist (state2 (funcall successors state))
           (let* ((cost (+ (path-cost-so-far path)
                           (funcall cost-fn state state2)))
                  (cost2 (funcall cost-left-fn state2))
                  (path2 (make-path
                           :state state2 :previous path
                           :cost-so-far cost
                           :total-cost (+ cost cost2)))
                  (old nil))
             ;; Place the new path, path2, in the right list:
             (cond
               ((setf old (find-path state2 paths state=))
                (when (better-path path2 old)
                  (setf paths (insert-path
                                path2 (delete old paths)))))
               ((setf old (find-path state2 old-paths state=))
                (when (better-path path2 old)
                  (setf paths (insert-path path2 paths))
                  (setf old-paths (delete old old-paths))))
               (t (setf paths (insert-path path2 paths))))))
         ;; Finally, call A* again with the updated path lists:
         (a*-search paths goal-p successors cost-fn cost-left-fn
                    state= old-paths)))))
```

Вот три вспомогательные функции::

```lisp
(defun find-path (state paths state=)
  "Find the path with this state among a list of paths."
  (find state paths :key #'path-state :test state=))

(defun better-path (pathl path2)
  "Is path1 cheaper than path2?"
  (< (path-total-cost path1) (path-total-cost path2)))

(defun insert-path (path paths)
  "Put path into the right position, sorted by total cost."
  ;; MERGE is a built-in function
  (merge 'list (list path) paths #'< :key #'path-total-cost))

(defun path-states (path)
  "Collect the states along this path."
  (if (null path)
      nil
      (cons (path-state path)
            (path-states (path-previous path)))))
```

Ниже мы используем `a*-search` для поиска 6 на графе, ранее показанном на [рис. 6.3](#f0020).
Функция стоимости-это константа 1 для каждого шага.
Другими словами, общая стоимость-это длина пути.
Эвристическая функция оценки - это всего лишь отличие от цели.
A*  алгоритму  требуется всего три шага поиска, чтобы найти оптимальное решение.
Сравните это с алгоритмом поиска по графу, который требовал пяти шагов, и алгоритмом поиска по дереву, который требовал десяти шагов - и ни один из них не нашел оптимального решения.

```lisp
> (path-states
      (a*-search (list (make-path :state 1)) (is 6)
                    #'next2 #'(lambda (x y) 1) (diff 6)))
;; Search: (#<Path to 1 cost 0.0  >)
;; Search: (#<Path to 3 cost 4.0  > #<Path to 2 cost 5.0  >)
;; Search: (#<Path to 5 cost 3.0  > #<Path to 4 cost 4.0  >
                #<Path to 2 cost 5.0  >)
;; Search: (#<Path to 6 cost 3.0  > #<Path to 7 cost 4.0  >
                #<Path to 4 cost 4.0  > #<Path to 2 cost 5.0  >)
(6 5 3 1)
```

Может показаться ограничивающим, что все эти функции поиска возвращают один ответ.
В некоторых приложениях мы можем рассматирвать несколько решений или все возможные решения.
Другие приложения более естественно рассматривать как задачи оптимизации, где мы не знаем заранее, что считается достижением цели, но просто пытаемся найти какое-то действие приводящее к уменьшению стоимости решения.

Оказывается, что функции, которые мы определили, совсем не ограничивают нас в этом отношении.
Они могут быть использованы для достижения обеих этих новых целей-при условии, что мы тщательно определим предикат цели.
Чтобы найти все решения проблемы, всё, что нам нужно сделать, это определить и передать такой предикат цели, который всегда терпит неудачу, но сохраняет все решения в списке.
Предикат цели будет видеть все возможные решения и сохранять только те, которые являются реальными решениями.
Конечно, если пространство поиска бесконечно, это никогда не закончится, поэтому пользователь должен быть осторожен в применении этой техники.
Также можно было бы написать предикат цели, который остановил бы поиск после нахождения определенного числа решений или после просмотра определенного числа состояний.
Вот функция, которая находит все решения, используя поиск по лучу:

```lisp
(defun search-all (start goal-p successors cost-fn beam-width)
  "Find all solutions to a search problem, using beam search."
  ;; Be careful: this can lead to an infinite loop.
  (let ((solutions nil))
    (beam-search
      start #'(lambda (x)
              (when (funcall goal-p x) (push x solutions))
              nil)
      successors cost-fn beam-width)
  solutions))
```

## 6.5 GPS как поиск

Программа GPS может рассматриваться как проблема поиска.
Например, в мире трех блоков блоков есть только 13 различных состояний.
Их можно было расположить в виде графа и искать точно так же, как мы искали маршрут между городами.
[Рисунок 6.5](#f0030) показывает этот граф.

| []()                                    |
|-----------------------------------------|
| ![f06-05](images/chapter6/f06-05.jpg)   |
| Рисунок 6.5: мир блоков в виде графа    |

Функция `search-gps` делает именно это.
Например, функция gps на [стр. 135](B9780080571157500042.xhtml#p135), она вычисляет конечное состояние, а затем выбирает действия, которые приводят к этому состоянию.
Но она вычисляет состояние с помощью поиска по лучу.
Предикат цели проверяет, удовлетворяет ли текущее состояние каждому условию в цели, функция - successor находит все применимые операторы и применяет их, а функция стоимости просто суммирует количество действий, выполненных до сих пор, плюс количество условий, которые еще не выполнены:

```lisp
(defun search-gps (start goal &optional (beam-width 10))
  "Search for a sequence of operators leading to goal."
  (find-all-if
    #'action-p
    (beam-search
      (cons '(start) start)
      #'(lambda (state) (subsetp goal state :test #'equal))
      #'gps-successors
      #'(lambda (state)
          (+ (count-if #'action-p state)
             (count-if #'(lambda (con)
                           (not (member-equal con state)))
                       goal)))
      beam-width)))
```

Вот функция определения преемников(successor):

```lisp
(defun gps-successors (state)
  "Return a list of states reachable from this one using ops."
  (mapcar
    #'(lambda (op)
        (append
          (remove-if #'(lambda (x)
                         (member-equal x (op-del-list op)))
                     state)
          (op-add-list op)))
    (applicable-ops state)))

(defun applicable-ops (state)
  "Return a list of all ops that are applicable now."
  (find-all-if
    #'(lambda (op)
        (subsetp (op-preconds op) state :test #'equal))
    *ops*))
```

Техника поиска быстро находит хорошие решения для самых разных задач.
Здесь мы видим решение аномалии Сассмана в мире трех блоков блоков:

```lisp
(setf start '((c on a) (a on table) (b on table) (space on c)
            (space on b) (space on table)))
> (search-gps start '((a on b) (b on c)))
((START)
  (EXECUTING (MOVE C FROM A TO TABLE))
  (EXECUTING (MOVE B FROM TABLE TO C))
  (EXECUTING (MOVE A FROM TABLE TO B)))
> (search-gps start '((b on c) (a on b)))
((START)
  (EXECUTING (MOVE C FROM A TO TABLE))
  (EXECUTING (MOVE B FROM TABLE TO C))
  (EXECUTING (MOVE A FROM TABLE TO B)))
```

В этих решениях мы ищем вперед от начала к цели; это совершенно отличается от подхода средство-анализа коненой цели (means-ends), при котором мы ищем назад от цели, для достижения которой ищем применимые операторы.
Но мы могли бы сформулировать анализ конечных целей аналитически, как поиск вперед, просто переставив старт и цель: состояние цели GPS - это начальное состояние поиска, а предикат цели поиска проверяет, совпадает ли состояние с начальным состоянием GPS.
Оставим это вам как упражнение.

## 6.6 истории и литература

Pattern matching is one of the most important tools for AI.
As such, it is covered in most textbooks on Lisp.
Good treatments include Abelson and Sussman (1984), [Wilensky (1986)](B9780080571157500285.xhtml#bb1390), [Winston and Horn (1988)](B9780080571157500285.xhtml#bb1410), and [Kreutzer and McKenzie (1990)](B9780080571157500285.xhtml#bb0680).
An overview is presented in the "pattern-matching" entry in *Encyclopedia of AI* ([Shapiro 1990](B9780080571157500285.xhtml#bb1085)).

Nilsson's *Problem*-*Solving Methods in Artificial Intelligence* (1971) was an early text-book that emphasized search as the most important defining characteristic of AI.
More recent texts give less importance to search; Winston's *Artificial Intelligence* (1984) gives a balanced overview, and his *Lisp* (1988) provides implementations of some of the algorithms.
They are at a lower level of abstraction than the ones in this chapter.
Iterative deepening was first presented by [Korf (1985)](B9780080571157500285.xhtml#bb0640), and iterative broadening by [Ginsberg and Harvey (1990)](B9780080571157500285.xhtml#bb0470).

## 6.7 Упражнения

**Exercise  6**.**3** [**m**] Напишите более общую версию `interaetive-interpreter`, чем та, которая определена в этой главе.
Решите, какую функциональность можно определить, и укажите для них значения по умолчанию.

**Exercise  6**.**4** [**m**] Определите версию `compose`, которая допускает любое количество аргументов, а не только два.
Подсказка: вы можете использовать функцию `reduce`.

**Exercise  6**.**5** [**m**] Определите версию `compose`, которая допускает любое количество аргументов, но более эффективна, чем ответ на предыдущее упражнение.
Подсказка: попробуйте принимать решения, когда вызывается `compose` для построения результирующей функции, а не принимать одни и те же решения снова и снова каждый раз, когда вызывается результирующая функция.

**Exercise  6**.**6** [**m**] Одна из проблем с `pat-match` состоит в том, что он придает особое значение символам, начинающимся с ?, Что означает, что они не могут использоваться для сопоставления с литеральным образцом.
Определите образец, который буквально соответствует литеральному вводу, чтобы такие символы можно было сопоставить.

**Exercise  6**.**7** [**m**] Обсудите плюсы и минусы программирования, управляемого данными, по сравнению с традиционным подходом.


**Exercise  6**.**8** [**m**] Напишите версию `tree-search` используя явный цикл, а не рекурсию.

**Exercise  6**.**9** [**m**] Функция `sorter` неэффективна по двум причинам: она вызывает `append`, который должен сделать копию первого аргумента, и сортирует весь результат, а не просто вставляет новые состояния в уже отсортированные *старые* состояния.
Напишите более эффективный `sorter`.

**Exercise  6**.**10** [**m**] Напишите версии `graph-search` и `a*-search`, которые используют хэш-таблицы, а не списки, чтобы проверить, было ли состояние замечено ранее.

**Exercise  6**.**11** [**m**] Напишите функцию, которая вызывает `beam-search` для поиска первых *n* решений проблемы и возвращает их в виде списка.

**Exercise  6**.**12** [**m**] На персональных компьютерах без оборудования с плавающей запятой расчет `air-distance` будет довольно медленным.
Если для вас это проблема, договоритесь вычислять `xyz-coords` каждого города только один раз, а затем сохраните их, или сохраните полную таблицу расстояний между городами.
Также предварительно вычислите и сохраните соседей каждого города.

**Exercise  6**.**13** [**d**] Напишите версию GPS, которая использует поиск A* вместо поиска по лучу.
Сравните две версии в различных областях.

**Exercise  6**.**14** [**d**] Напишите версию GPS, которая учитывает стоимость для каждого оператора.
Например, доставка ребенка в школу может стоить 2, а вызов лимузина для перевозки ребенка может стоить 100.
Используйте эти стоимости вместо постоянной стоимости 1 для каждой операции.

**Exercise  6**.**15** [**d**] Напишите версию GPS, которая использует инструменты поиска, но выполняет анализ средств и результатов.

## 6.8 Ответы

**Answer 6**.**2** К сожалению, `pat-match` не всегда дает ответ.
Проблема в том, что он будет повторно связывать сегментную переменную только в случае несоответствия остальной части шаблона после переменной сегмента.
Во всех приведенных выше примерах "остальная часть шаблона после переменной сегмента" была всем шаблоном, поэтому `pat-match` всегда работал правильно.
Но если переменная сегмента оказывается вложенной в список, то оставшаяся часть подсписка переменной сегмента является только частью остальной части всего образца, как показано в следующем примере:

```lisp
> (pat-match '(((?* ?x) (?* ?y)) ?x ?y) '((a b c d ) (a b) (c d))) => NIL
```

Правильный ответ с `?x` связывается с `(a b)` и `?y` связывается с `(c d)`, не найден, потому что соответствие внутреннему сегменту выполнено успешно с `?x`, привязанным к `( )` и `?y` привязан к `(a b c d)`, и как только мы выйдем из внутреннего соответствия и вернемся на верхний уровень, для альтернативных привязок не будет возврата.

**Answer 6**.**3** Следующая версия позволяет пользователю указать все четыре компонента цикла prompt-read-eval-print(REPL), а также потоки, которые будут использоваться для ввода и вывода.
Значения по умолчанию устанавливаются как для интерпретатора Лиспа.

```lisp
(defun interactive-interpreter
        (&key (read #'read) (eval #'eval) (print #'print)
          (prompt "> ") (input t) (output t))
  "Read an expression, evaluate it, and print the result."
  (loop
    (fresh-line output)
    (princ prompt output)
      (funcall print (funcall eval (funcall read input))
              output)))
```

Вот еще одна версия, которая выполняет все вышеперечисленное, а также обрабатывает несколько значений и связывает различные "исторические переменные", которые связывает верхний уровень Lisp.

```lisp
(defun interactive-interpreter
      (&key (read #'read) (eval #'eval) (print #'print)
      (prompt "> ") (input t) (output t))
  "Read an expression, evaluate it, and print the result(s).
  Does multiple values and binds: * ** ***-+ ++ +++/ // ///"
  (let (* ** *** - + ++ +++ / // /// vals)
    ;; The above variables are all special, except VALS
    ;; The variable - holds the current input
    ;; * *** *** are the 3 most recent values
    ;; + ++ +++ are the 3 most recent inputs
    ;;/ // /// are the 3 most recent lists of multiple-values
    (loop
      (fresh-line output)
      (princ prompt output)
      ;; First read and evaluate an expression
      (setf - (funcall read input)
          vals (multiple-value-list (funcall eval -)))
      ;; Now update the history variables
   (setf +++ ++     /// //     *** (first ///)   
         ++ +       // /       ** (first //)     
         + -        / vals     * (first /)) 
      ;; Finally print the computed value(s)
      (dolist (value vals)
        (funcall print value output)))))
```

**Answer 6**.**4**

```lisp
(defun compose (&rest functions)
  "Return the function that is the composition of all the args. i.e.
(compose f g h) = (lambda (x) (f (g (h x))))." 
#'(lambda (x)
      (reduce #'funcall functions :from-end t :initial-value x)))
```

**Answer 6**.**5**

```lisp
(defun compose (&rest functions)
  "Return the function that is the composition of all the args. i.e.
(compose f g h) = (lambda (x) (f (g (h x))))."
  (case (length functions)
    (0 #'identity)
    (1 (first functions))
    (2 (let ((f (first functions))
            (g (second functions)))
        #'(lambda (x) (funcall f (funcall g x)))))
    (t #'(lambda (x)
          (reduce #'funcall functions :from-end t
                  :initia1-value x)))))
```

**Answer 6**.**8**

```lisp
(defun tree-search (states goal-p successors combiner)
"Find a state that satisfies goal-p.
Start with states, and search according to successors and combiner."
  (loop
    (cond ((null states) (RETURN fail))
          ((funcall goal-p (first states))
          (RETURN (first states))
          (t (setf states
                  (funcall combiner
                          (funcall successors (first states))
                          (rest states))))))))
```

**Answer 6**.**9**

```lisp
(defun sorter (cost-fn)
  "Return a combiner function that sorts according to cost-fn."
  #'(lambda (new old)
      (merge 'list (sort new #'> :key cost-fn)
          old #'> :key cost-fn)))
```

**Answer 6**.**11**

```lisp
(defun search-n (start n goal-p successors cost-fn beam-width)
  "Find n solutions to a search problem, using beam search."
  (let ((solutions nil))
    (beam-search
      start #'(lambda (x)
          (cond ((not (funcall goal-p x)) nil)
              ((= n 0) x)
              (t (decf n)
                  (push x solutions)
                  nil)))
      successors cost-fn beam-width)
    solutions))
```

----------------------

[1](#xfn0015) Макрос `handler-case` есть только в  ANSI Common Lisp.

[2](#xfn0020) В качестве альтернативы можно было бы зарезервировать вопросительный знак только для переменных и использовать другие обозначения для этих операторов сопоставления.
Подойдут ключевые слова, такие как `:and`, `:or`, `:is` и т. д.

[3](#xfn0025) Встроенная константа `most-positive-fixnum` - это большое целое число, самое большое, которое может быть выражено без использования больших чисел.
Его значение зависит от реализации, но в большинстве Лиспов оно превышает 16 миллионов.

[4](#xfn0030) В [Главе 8](B978008057115750008X.xhtml) мы увидим пример, когда туман рассеялся: когда-то символическое интегрирование рассматривалось как проблема поиска, но теперь новые математические результаты позволяют решать тот же класс задач интеграции без поиска.

[5](#xfn0035) Проницательный читатель поймет, что этот граф - не дерево.
Разница между деревьями и графами и последствия для поиска будут рассмотрены позже.