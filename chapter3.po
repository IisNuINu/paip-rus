#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter3.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-10-10 22:44+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter3.md:3
msgid ""
"# Chapter 3\n"
"## Overview of Lisp"
msgstr ""
"# Глава 3\n"
"## Обзор Lisp"

#: in/chapter3.md:6
msgid ""
"> No doubt about it.\n"
"Common Lisp is a *big* language."
msgstr ""
"> Никаких сомнений.\n"
"\n"
">Common Lisp - это *большой* язык.\n"

#: in/chapter3.md:8
msgid "> -Guy L. Steele, Jr."
msgstr ""

#: in/chapter3.md:10
msgid "> Foreword to Koschman 1990"
msgstr "> Предисловие к Кошману 1990"

#: in/chapter3.md:13
msgid ""
"This chapter briefly covers the most important special forms and functions "
"in Lisp.\n"
"It can be safely skipped or skimmed by the experienced Common Lisp "
"programmer but is required reading for the novice Lisp programmer, or one "
"who is new to the Common Lisp dialect."
msgstr ""
"В этой главе кратко рассматриваются наиболее важные специальные формы и "
"функции в Lisp.\n"
"Она может быть безопасно пропущена или пропущена опытным программистом "
"Common Lisp, но необходима для чтения начинающим программистом Lisp или тем, "
"кто новичок в диалекте Common Lisp."

#: in/chapter3.md:17
msgid ""
"This chapter can be used as a reference source, but the definitive reference "
"is Steele's *Common Lisp the Language*, 2d edition, which should be "
"consulted whenever there is any confusion.\n"
"Since that book is 25 times longer than this chapter, it is clear that we "
"can only touch on the important highlights here.\n"
"More detailed coverage is given later in this book as each feature is used "
"in a real program."
msgstr ""
"Эта глава может быть использована в качестве справочного источника, но "
"окончательная ссылка-это Стил *Common Lisp The Language*, 2d edition, к "
"которому следует обращаться всякий раз, когда возникает какая-либо "
"путаница.\n"
"Поскольку эта книга в 25 раз длиннее, чем эта глава, ясно, что мы можем "
"коснуться здесь только важных моментов.\n"
"Более подробное освещение дается ниже в этой книге, поскольку каждая функция "
"используется в реальной программе."

#: in/chapter3.md:19
msgid "## 3.1 A Guide to Lisp Style"
msgstr "## 3.1 Руководство по Лисп стилю"

#: in/chapter3.md:25
msgid ""
"The beginning Common Lisp programmer is often overwhelmed by the number of "
"options that the language provides.\n"
"In this chapter we show fourteen different ways to find the length of a "
"list.\n"
"How is the programmer to choose between them?\n"
"One answer is by reading examples of good programs - as illustrated in this "
"book - and copying that style.\n"
"In general, there are six maxims that every programmer should follow:"
msgstr ""
"Начинающий программист Common Lisp часто перегружен количеством опций, "
"которые предоставляет язык.\n"
"В этой главе мы покажем четырнадцать различных способов определения длины "
"списка.\n"
"Как программисту выбирать между ними?\n"
"Один из ответов - это чтение примеров хороших программ, как показано в этой "
"книге, и копирование этого стиля.\n"
"В общем, есть шесть Максим(Заповедей), которым должен следовать каждый "
"программист:"

#: in/chapter3.md:32
msgid ""
"* Be specific.\n"
"* Use abstractions.\n"
"* Be concise.\n"
"* Use the provided tools.\n"
"* Don't be obscure.\n"
"* Be consistent."
msgstr ""
"* Быть конкретными.\n"
"* Использовать абстракции.\n"
"* Быть кратким.\n"
"* Использовать предоставленные инструменты.\n"
"* Не быть непонятным.\n"
"* Быть последовательным."

#: in/chapter3.md:34
msgid "These require some explanation."
msgstr "Они требуют некоторого объяснения"

#: in/chapter3.md:40
msgid ""
"Using the most specific form possible makes it easier for your reader to "
"understand your intent.\n"
"For example, the conditional special form `when` is more specific than "
"`if`.\n"
"The reader who sees a `when` knows to look for only one thing: the clause to "
"consider when the test is true.\n"
"The reader who sees an `if` can rightfully expect two clauses: one for when "
"the test is true, and one for when it is false.\n"
"Even though it is possible to use `if` when there is only one clause, it is "
"preferable to use `when,` because `when` is more specific."
msgstr ""
"Использование максимально конкретной формы облегчает читателю вашей "
"программы понимание ваших намерений.\n"
"Например, условная специальная форма `when`(когда) более конкретна, чем "
"`if`(если).\n"
"Читатель, который видит `when`, знает, что нужно искать только одну вещь: "
"предложение, которое нужно учитывать, когда тест истинен.\n"
"Читатель, который видит `if`, может с полным правом ожидать двух "
"предложений: одно для ситуации, когда тест истинен, и одно для того, когда "
"тест ложен.\n"
"Даже если можно использовать `if`, когда есть только одно предложение, "
"предпочтительнее использовать `when`, потому что `when` более конкретно."

#: in/chapter3.md:45
msgid ""
"One important way of being specific is using abstractions.\n"
"Lisp provides very general data structures, such as lists and arrays.\n"
"These can be used to implement specific data structures that your program "
"will use, but you should not make the mistake of invoking primitive "
"functions directly.\n"
"If you define a list of names:"
msgstr ""
"Одним из важных способов быть конкретным является использование абстракций.\n"
"Lisp предоставляет очень общие структуры данных, такие как списки и "
"массивы.\n"
"Они могут быть использованы для реализации конкретных структур данных, "
"которые будут использоваться вашей программой, но вы не должны совершать "
"ошибку, вызывая примитивные функции напрямую.\n"
"Если вы определяете список имен"

#: in/chapter3.md:49
msgid ""
"```lisp\n"
"(defvar *names* '((Robert E. Lee) ...))\n"
"```"
msgstr ""

#: in/chapter3.md:52
msgid ""
"then you should also define functions to get at the components of each "
"name.\n"
"To get at `Lee`, use `(last-name (first *names*))`, not `(caddar *names*)`."
msgstr ""
"затем вы также должны определить функции, чтобы добраться до компонентов "
"каждого имени.\n"
"Чтобы добраться до `Lee`, используйте `(last-name (first *names*))`, а не "
"`(caddar *names*)`."

#: in/chapter3.md:56
msgid ""
"Often the maxims are in concord.\n"
"For example, if your code is trying to find an element in a list, you should "
"use `find` (or maybe `find-if`), not `loop` or `do`.\n"
"`find` is more specific than the general constructs `loop` or `do,` it is an "
"abstraction, it is more concise, it is a built-in tool, and it is simple to "
"understand."
msgstr ""
"Часто Максимы(Заповеди) находятся в согласии.\n"
"Например, если ваш код пытается найти элемент в списке, вы должны "
"использовать `find` (или, возможно, `find-if`), а не `loop` или `do`.\n"
"`find`(найти) более конкретна, чем общие конструкции цикла `loop` или `do` - "
"эта абстракция более лаконична, является встроенным инструментом и ее легко "
"понять."

#: in/chapter3.md:60
msgid ""
"Sometimes, however, the maxims are in conflict, and experience will tell you "
"which one to prefer.\n"
"<a id=\"tfn03-1\"></a>\n"
"Consider the following two ways of placing a new key/value pair on an "
"association list:[[1]](#fn03-1)"
msgstr ""
"Иногда, однако, заповеди вступают в конфликт, и опыт подскажет вам, какую из "
"них предпочесть.\n"
"<a id=\"tfn03-1\"></a>\n"
"Рассмотрим следующие два способа размещения новой пары ключ/значение в "
"ассоциативном списке:[[1]](#fn03-1)"

#: in/chapter3.md:65
msgid ""
"```lisp\n"
"(push (cons key val) a-list)\n"
"(setf a-list (acons key val a-list))\n"
"```"
msgstr ""

#: in/chapter3.md:69
msgid ""
"The first is more concise.\n"
"But the second is more specific, as it uses the `acons` function, which is "
"designed specifically for association lists.\n"
"The decision between them probably hinges on obscurity: those who find "
"`acons` to be a familiar function would prefer the second, and those who "
"find it obscure would prefer the first."
msgstr ""
"Первый более лаконичен.\n"
"Но второй более специфичен/конкретен, так как он использует функцию `acons`, "
"которая разработана специально для ассоциативных списков.\n"
"Выбор между ними, вероятно, зависит от известности функций: те, кто считает "
"`acons` знакомой функцией, предпочтут второй вариант, а те, кто считает ее "
"непонятной(или малоизвестной), предпочтут первый."

#: in/chapter3.md:73
msgid ""
"A similar choice arises in the question of setting a variable to a value.\n"
"Some prefer `(setq x val)` because it is most specific; others use `(setf x "
"val)`, feeling that it is more consistent to use a single form, `setf`, for "
"all updating.\n"
"Whichever choice you make on such issues, remember the sixth maxim: be "
"consistent."
msgstr ""
"Аналогичный выбор возникает и в вопросе о присвоении переменной значения.\n"
"Некоторые предпочтут `(setq x val)`, потому что он наиболее специфичен для "
"данной ситуации; другие используют `(setf x val)`, чувствуя, что более "
"последовательно использовать одну форму, `setf`, для всех обновлений.\n"
"Какой бы выбор вы ни сделали в таких вопросах, помните шестую Максиму: "
"будьте последовательны."

#: in/chapter3.md:75
msgid "## 3.2 Special Forms"
msgstr "## 3.2 Специальные Формы"

#: in/chapter3.md:77
msgid ""
"As noted in [chapter 1](chapter1.md), \"special form\" is the term used to "
"refer both to Common Lisp's syntactic constructs and the reserved words that "
"mark these constructs."
msgstr ""
"Как отмечалось в [главе 1] (chapter1.md), \"специальная форма\" - это "
"термин, используемый для обозначения как синтаксических конструкций Common "
"Lisp, так и зарезервированных слов, которые обозначают/маркируют эти "
"конструкции."

#: in/chapter3.md:79
msgid "The most commonly used special forms are:"
msgstr "Наиболее часто используемые специальные формы:"

#: in/chapter3.md:89
msgid ""
"| definitions    | conditional | variables | iteration | other      |\n"
"|----------------|-------------|-----------|-----------|------------|\n"
"| `defun`        | `and`       | `let`     | `do`      | `declare`  |\n"
"| `defstruct`    | `case`      | `let*`    | `do*`     | `function` |\n"
"| `defvar`       | `cond`      | `pop`     | `dolist`  | `progn`    |\n"
"| `defparameter` | `if`        | `push`    | `dotimes` | `quote`    |\n"
"| `defconstant`  | `or`        | `setf`    | `loop`    | `return`   |\n"
"| `defmacro`     | `unless`    | `incf`    |           | `trace`    |\n"
"| `labels`       | `when`      | `decf`    |           | `untrace`  |"
msgstr ""
"| определения    | условия     | переменные| итерации  | другое     |\n"
"|----------------|-------------|-----------|-----------|------------|\n"
"| `defun`        | `and`       | `let`     | `do`      | `declare`  |\n"
"| `defstruct`    | `case`      | `let*`    | `do*`     | `function` |\n"
"| `defvar`       | `cond`      | `pop`     | `dolist`  | `progn`    |\n"
"| `defparameter` | `if`        | `push`    | `dotimes` | `quote`    |\n"
"| `defconstant`  | `or`        | `setf`    | `loop`    | `return`   |\n"
"| `defmacro`     | `unless`    | `incf`    |           | `trace`    |\n"
"| `labels`       | `when`      | `decf`    |           | `untrace`  |"

#: in/chapter3.md:93
msgid ""
"To be precise, only `declare`, `function`, `if`, `labels`, `let`, `let*`, "
"`progn` and `quote` are true special forms.\n"
"The others are actually defined as macros that expand into calls to more "
"primitive special forms and functions.\n"
"There is no real difference to the programmer, and Common Lisp "
"implementations are free to implement macros as special forms and vice "
"versa, so for simplicity we will continue to use \"special form\" as a "
"blanket term for both true special forms and built-in macros."
msgstr ""
"Если быть точным, то только `declare`, `function`, `if`, `labels`, `let`, "
"`let*`, `progn` и `quote` настоящие специальные формы.\n"
"Остальные фактически определяются как макросы, которые расширяются в вызовы "
"более примитивных специальных форм и функций.\n"
"Для программиста нет никакой реальной разницы, и реализации Common Lisp "
"могут свободно реализовывать макросы как специальные формы и наоборот, "
"поэтому для простоты мы будем продолжать использовать \"специальную форму\" "
"в качестве общего термина как для истинных специальных форм, так и для "
"встроенных макросов."

#: in/chapter3.md:95
msgid "### Special Forms for Definitions"
msgstr "### Специальные формы для определений"

#: in/chapter3.md:98
msgid ""
"In this section we survey the special forms that can be used to introduce "
"new global functions, macros, variables, and structures.\n"
"We have already seen the `defun` form for defining functions; the `defmacro` "
"form is similar and is covered on [page 66](#p66)."
msgstr ""
"В этом разделе мы рассмотрим специальные формы, которые могут быть "
"использованы для введения новых глобальных функций, макросов, переменных и "
"структур.\n"
"Мы уже видели форму `defun` для определения функций; форма `defmacro` "
"аналогична и рассматривается на [стр. 66](#p66)."

#: in/chapter3.md:102
msgid ""
"> `(defun` *function-name (parameter...) \"optional documentation\" body..."
"*)\n"
">\n"
"> `(defmacro` *macro-name (parameter...) \"optional documentation\" body...*)"
msgstr ""

#: in/chapter3.md:106
msgid ""
"There are three forms for introducing special variables.\n"
"`defvar` defines a special variable and can optionally be used to supply an "
"initial value and a documentation string.\n"
"The initial value is evaluated and assigned only if the variable does not "
"yet have any value, `defparameter` is similar, except that the value is "
"required, and it will be used to change any existing value, `defconstant` is "
"used to declare that a symbol will always stand for a particular value."
msgstr ""
"Существует три формы введения специальных переменных.\n"
"`defvar` определяет специальную переменную и может быть дополнительно "
"использован для предоставления начального значения и строки документации.\n"
"Начальное значение вычисляется и присваивается только в том случае, если "
"переменная еще не имеет никакого значения, `defparameter` аналогичен, за "
"исключением того, что значение является обязательным, и он будет "
"использоваться для изменения любого существующего значения, `defconstant` "
"используется для объявления того, что символ всегда будет означать "
"определенное значение."

#: in/chapter3.md:108
msgid "> `(defvar` *variable-name initial-value \"optional documentation\"* )"
msgstr ""

#: in/chapter3.md:110
msgid "> `(defparameter` *variable-name value \"optional documentation\"*)"
msgstr ""

#: in/chapter3.md:112
msgid "> `(defconstant` *variable-name value \"optional documentation\"*)"
msgstr ""

#: in/chapter3.md:115
msgid ""
"All the `def-` forms define global objects.\n"
"It is also possible to define local variables with `let`, and to define "
"local functions with `labels`, as we shall see."
msgstr ""
"Все формы \"def -\" определяют глобальные объекты.\n"
"Кроме того, как мы увидим, можно определить локальные переменные с помощью "
"`let`, а локальные функции - с помощью `labels`."

#: in/chapter3.md:120
msgid ""
"Most programming languages provide a way to group related data together into "
"a structure.\n"
"Common Lisp is no exception.\n"
"The `defstruct` special form defines a structure type (known as a *record* "
"type in Pascal) and automatically defines functions to get at components of "
"the structure.\n"
"The general syntax is:"
msgstr ""
"Большинство языков программирования предоставляют возможность группировать "
"связанные данные в структуру.\n"
"Common Lisp не является исключением.\n"
"Специальная форма `defstruct` определяет тип структуры (известный как тип "
"*record* в Pascal) и автоматически определяет функции для доступа к "
"компонентам структуры.\n"
"Общий синтаксис таков:"

#: in/chapter3.md:122
msgid "> `(defstruct` *structure-name \"optional documentation\" slot...*)"
msgstr ""

#: in/chapter3.md:124
msgid "As an example, we could define a structure for names:"
msgstr "Например, мы могли бы определить структуру для имен:"

#: in/chapter3.md:131
msgid ""
"```lisp\n"
"(defstruct name\n"
"  first\n"
"  (middle nil)\n"
"  last)\n"
"```"
msgstr ""

#: in/chapter3.md:135
msgid ""
"This automatically defines the constructor function `make-name,` the "
"recognizer predicate `name-p,` and the accessor functions `name-first, name-"
"middle` and `name-last`.\n"
"The `(middle nil)` means that each new name built by `make-name` will have a "
"middle name of `nil` by default.\n"
"Here we create, access, and modify a structure:"
msgstr ""
"Она автоматически определяет функцию конструктора `make-name`, предикат "
"распознавателя `name-p` и функции доступа `name-first, name-middle` и `name-"
"last`.\n"
"`(middle nil)` означает, что каждое новое имя(name), построенное с помощью "
"`make-name`, по умолчанию будет иметь среднее имя(middle) равное `nil`.\n"
"Здесь мы можем создавать, получать доступ и изменять структуру:"

#: in/chapter3.md:139
msgid ""
"```lisp\n"
"> (setf b (make-name :first 'Barney :last 'Rubble)) =>\n"
"#S(NAME :FIRST BARNEY :LAST RUBBLE)"
msgstr ""

#: in/chapter3.md:141
msgid "> (name-first b) => BARNEY"
msgstr ""

#: in/chapter3.md:143
msgid "> (name-middle b) => NIL"
msgstr ""

#: in/chapter3.md:145
msgid "> (name-last b) => RUBBLE"
msgstr ""

#: in/chapter3.md:147
msgid "> (name-p b) => T"
msgstr ""

#: in/chapter3.md:149
msgid "> (name-p 'Barney) => NIL ; only the results of make-name are names"
msgstr ""

#: in/chapter3.md:151
msgid "> (setf (name-middle b) 'Q) => Q"
msgstr ""

#: in/chapter3.md:154
msgid ""
"> b => #S(NAME :FIRST BARNEY :MIDDLE Q :LAST RUBBLE)\n"
"```"
msgstr ""

#: in/chapter3.md:161
msgid ""
"The printed representation of a structure starts with a `#S` and is followed "
"by a list consisting of the type of the structure and alternating pairs of "
"slot names and values.\n"
"Do not let this representation fool you: it is a convenient way of printing "
"the structure, but it is not an accurate picture of the way structures are "
"represented internally.\n"
"Structures are actually implemented much like vectors.\n"
"For the `name` structure, the type would be in the zero element of the "
"vector, the first name in the first element, middle in the second, and last "
"in the third.\n"
"This means structures are more efficient than lists: they take up less "
"space, and any element can be accessed in a single step.\n"
"In a list, it takes *n* steps to access the *n*th element."
msgstr ""
"Печатное представление структуры начинается с буквы `#S` и сопровождается "
"списком, состоящим из типа структуры и чередующихся пар имен слотов и "
"значений.\n"
"Не позволяйте этому представлению обмануть вас: это удобный способ печати "
"структуры, но это не точная картина того, как структуры представлены "
"внутри.\n"
"Структуры на самом деле реализуются очень похоже на векторы.\n"
"Для структуры `name`, это тип который будет находиться в нулевом элементе "
"вектора, первое имя(first)-в первом элементе, среднее(middle)-во втором и "
"последнее(last)-в третьем.\n"
"Это означает, что структуры более эффективны, чем списки: они занимают "
"меньше места, и любой элемент может быть доступен в один шаг.\n"
"Список требует *n* шагов для доступа к *n*-му элементу."

#: in/chapter3.md:164
msgid ""
"There are options that give more control over the structure itself and the "
"individual slots.\n"
"They will be covered later as they come up."
msgstr ""
"Есть опции, которые дают больше контроля над самой структурой и отдельными "
"слотами.\n"
"Они будут описаны позже, когда появится в них необходимость."

#: in/chapter3.md:166
msgid "### Special Forms for Conditionals"
msgstr "### Специальные формы для условий"

#: in/chapter3.md:170
msgid ""
"We have seen the special form `if,` which has the form (`if` *test then-part "
"else-part*), where either the *then-part* or the *else-part* is the value, "
"depending on the success of the *test.*\n"
"Remember that only `nil` counts as false; all other values are considered "
"true for the purpose of conditionals.\n"
"However, the constant `t` is the conventional value used to denote truth "
"(unless there is a good reason for using some other value)."
msgstr ""
"Мы видели специальную форму `if`, которая имеет вид (`if` *test then-part "
"else-part*), где *then-part* или *else-part* даст значение формы, в "
"зависимости от успешности теста *test.*\n"
"Помните, что только `nil` считается ложью; все остальные значения считаются "
"истинными для целей условных обозначений.\n"
"Однако константа `t` - это всеми принимаемое значение, используемое для "
"обозначения истины (если только нет веской причины использовать какое-то "
"другое значение)."

#: in/chapter3.md:175
msgid ""
"There are actually quite a few special forms for doing conditional "
"evaluation.\n"
"Technically, `if` is defined as a special form, while the other conditionals "
"are macros, so in some sense `if` is supposed to be the most basic.\n"
"Some programmers prefer to use `if` for most of their conditionals; others "
"prefer `cond` because it has been around the longest and is versatile (if "
"not particularly pretty).\n"
"Finally, some programmers opt for a style more like English prose, and "
"freely use `when, unless, if,` and all the others."
msgstr ""
"На самом деле существует довольно много специальных форм для выполнения "
"условных вычислений.\n"
"Технически, `if` определяется как специальная форма, в то время как другие "
"условные обозначения являются макросами, поэтому в некотором смысле `if` "
"считается самой базовой формой.\n"
"Некоторые программисты предпочитают использовать `if` для большинства своих "
"условных обозначений; другие предпочитают `cond`, потому что он был самым "
"длинным и универсальным (если не особенно красивым).\n"
"Наконец, некоторые программисты выбирают стиль, больше похожий на английскую "
"прозу, и свободно используют `when, unless, if` и все остальные."

#: in/chapter3.md:179
msgid ""
"The following table shows how each conditional can be expressed in terms of "
"`if` and `cond`.\n"
"Actually, these translations are not quite right, because `or, case`, and "
"`cond` take care not to evaluate any expression more than once, while the "
"translations with `if` can lead to multiple evaluation of some expressions.\n"
"The table also has translations to `cond.` The syntax of `cond` is a series "
"of *cond-clauses,* each consisting of a test expression followed by any "
"number of *result* expressions:"
msgstr ""
"В следующей таблице показано, как каждое условие может быть выражено в "
"терминах `if` и `cond`.\n"
"На самом деле эти преобразования не совсем верны, потому что `or, case` и "
"`cond` заботятся о том, чтобы не вычислять какое-либо выражение более одного "
"раза, в то время как преобразования с `if` могут привести к многократному "
"вычислению некоторых выражений.\n"
"В таблице также есть преобразования в `cond`. Синтаксис `cond` представляет "
"собой ряд предложений *cond-clauses*, каждое из которых состоит из тестового "
"выражения, за которым следует произвольное количество *result* выражений:"

#: in/chapter3.md:185
msgid ""
"```\n"
"(cond (test result...)\n"
"      (test result...)\n"
"      ...)\n"
"```"
msgstr ""

#: in/chapter3.md:190
msgid ""
"`cond` goes through the cond-clauses one at a time, evaluating each test "
"expression.\n"
"As soon as a test expression evaluates non-nil, the result expressions for "
"that clause are each evaluated, and the last expression in the clause is the "
"value of the whole `cond.`\n"
"In particular, if a cond-clause consists of just a test and no result "
"expressions, then the value of the `cond` is the test expression itself, if "
"it is non-nil.\n"
"If all of the test expressions evaluate to nil, then nil is returned as the "
"value of the `cond.` A common idiom is to make the last cond-clause be `(t` "
"*result...*)."
msgstr ""
"`cond` проходит по предложениям cond-clauses по одному за раз, вычисляя "
"каждое тестовое выражение.\n"
"Как только тестовое выражение вычисляет не-nil значение, вычисляется каждое "
"результирующее выражение для этого предложения, и последнее выражение в "
"предложении является значением всего `cond`.\n"
"В частности, если предложение cond-clause состоит только из теста и никаких "
"результирующих выражений, то значением `cond` является значение самого "
"тестового выражения, если оно не равно nil.\n"
"Если все выражения вычисляются в nil, то nil будет возвращен как значение "
"`cond.` Распространенная идиома состоит в том, чтобы сделать последнее "
"предложение cond-clause выражением по умолчанию `(t *result...*)`."

#: in/chapter3.md:193
msgid ""
"The forms `when` and `unless` operate like a single `cond` clause.\n"
"Both forms consist of a test followed by any number of consequents, which "
"are evaluated if the test is satisfied - that is, if the test is true for "
"`when` or false for `unless.`"
msgstr ""
"Формы `when` и `unless` действуют как единичное предложение `cond`.\n"
"Обе формы состоят из теста, за которым следует любое количество "
"последовательных выражений, которые вычисляются, если тест удовлетворен - то "
"есть, если тест истинен для `when` или ложен для `unless`."

#: in/chapter3.md:197
msgid ""
"The `and` form tests whether every one of a list of conditions is true, and "
"`or` tests whether any one is true.\n"
"Both evaluate the arguments left to right, and stop as soon as the final "
"result can be determined.\n"
"Here is a table of equivalences:"
msgstr ""
"Форма `and` проверяет, истинно ли каждое из условий списка, а форма `or` "
"проверяет, истинно ли какое-либо из них.\n"
"Оба вычисляют аргументы слева направо и останавливаются, как только можно "
"определить окончательный результат.\n"
"Вот таблица эквивалентностей:"

#: in/chapter3.md:205
msgid ""
"| **conditional**                  | `if` **form**                       | "
"`cond` **form**                    |\n"
"|----------------------------------|-------------------------------------|------------------------------------|\n"
"| `(when` *test a b c*)            | `(if` *test* `(progn` *a  b c*))    | "
"`(cond` (*test a b c*))            |\n"
"| `(unless` *test x y*)            | `(if (not` *test*) `(progn` *x y*)) | "
"`(cond ((not` *test*) *x y*))      |\n"
"| `(and` *a b c*)                  | `(if` *a* `(if` *b c*))             | "
"`(cond` (*a* `(cond` (*b c*))))    |\n"
"| `(or` *a b c*)                   | `(if` *a a* `(if` *b b c*))         | "
"`(cond (a)` (*b*) (*c*))           |\n"
"| `(*case*` *a* (*b c*) `*(t x*))` | `(if (eql` *a 'b*) *c x*)           | "
"`(cond ((eql `*a 'b*) *c*) (*tx*)) |"
msgstr ""

#: in/chapter3.md:208
msgid ""
"It is considered poor style to use `and` and `or` for anything other than "
"testing a logical condition, `when, unless,` and `if` can all be used for "
"taking conditional action.\n"
"For example:"
msgstr ""
"Считается плохим стилем использовать `and` и `or` для чего-либо, кроме "
"проверки логического условия, `when, unless` и `if` могут быть использованы "
"для выполнения условных действий.\n"
"Например:"

#: in/chapter3.md:219
msgid ""
"```lisp\n"
"(and (> n 100)\n"
"     (princ \"N is large.\"))    ; Bad style!\n"
"(or (<= n 100)\n"
"    (princ \"N is large.\"))    ; Even worse style!\n"
"(cond ((> n 100)        ; OK, but not MY preference\n"
"      (princ \"N is large.\"))\n"
"(when (> n 100)\n"
"  (princ \"N is large.\"))    ; Good style.\n"
"```"
msgstr ""

#: in/chapter3.md:221
msgid ""
"When the main purpose is to return a value rather than take action, `cond` "
"and `if` (with explicit `nil` in the else case) are preferred over when and "
"`unless`, which implicitly return `nil` in the else case, `when` and "
"`unless` are preferred when there is only one possibility, `if` (or, for "
"some people, `cond)` when there are two, and `cond` when there are more than "
"two:"
msgstr ""
"Когда основная цель состоит в том, чтобы вернуть значение, а не "
"предпринимать действия,  предпочтительнее использовать `cond` и `if`(с явным "
"`nil` для случая else), чем `when` и `unless`, которые неявно возвращают "
"`nil` в случае else, `when` и `unless` предпочтительнее, когда есть только "
"одна возможность, `if` (или, для некоторых людей, `cond`), когда их два, и "
"`cond`, когда их больше двух:"

#: in/chapter3.md:231
msgid ""
"```lisp\n"
"(defun tax-bracket (income)\n"
"  \"Determine what percent tax should be paid for this income.\"\n"
"  (cond ((< income 10000.00) 0.00)\n"
"        ((< income 30000.00) 0.20)\n"
"        ((< income 50000.00) 0.25)\n"
"        ((< income 70000.00) 0.30)\n"
"        (t                   0.35)))\n"
"```"
msgstr ""

#: in/chapter3.md:234
msgid ""
"If there are several tests comparing an expression to constants, then case "
"is appropriate.\n"
"A `case` form looks like:"
msgstr ""
"Если существует несколько тестов, сравнивающих выражение с константами, то "
"`case` является подходящим.\n"
"Форма `case` выглядит следующим образом:"

#: in/chapter3.md:237
msgid ""
"> `(case` *expression*  \n"
"      (*match result*...)...)"
msgstr ""

#: in/chapter3.md:244
msgid ""
"The *expression* is evaluated and compared to each successive *match*.\n"
"As soon as one is `eql`, the *result* expressions are evaluated and the last "
"one is returned.\n"
"Note that the *match* expressions are *not* evaluated.\n"
"If a *match* expression is a list, then case tests if the *expression* is "
"`eql` to any member of the list.\n"
"If a *match* expression is the symbol `otherwise` (or the symbol `t`), then "
"it matches anything.\n"
"(It only makes sense for this `otherwise` clause to be the last one.)"
msgstr ""
"*expression* вычисляется и сравнивается с каждым последующим *match*.\n"
"Как только одно из них становится равным в смысле: `eql`, вычисляются "
"выражения *result* и возвращается значение последнего.\n"
"Обратите внимание, что выражения *match* не вычисляются.\n"
"Если выражение *match* является списком, то case проверяет, является ли "
"*expression* равным в `eql` для любого члена списка.\n"
"Если выражение *match* является символом `otherwise` (или символом `t`), то "
"оно соответствует чему угодно.\n"
"(Это имеет смысл только для того, чтобы это предложение `otherwise` было "
"последним.)"

#: in/chapter3.md:247
msgid ""
"There is also another special form, `typecase`, which compares the type of "
"an expression against several possibilities and, like `case`, chooses the "
"first clause that matches.\n"
"In addition, the special forms `ecase` and `etypecase` are just like `case` "
"and `typecase` except that they signal an error if there is no match."
msgstr ""
"Существует также другая специальная форма, `typecase`, которая сравнивает "
"тип выражения с несколькими возможностями и, как и `case`, выбирает первое "
"предложение, которое соответствует.\n"
"Кроме того, специальные формы `ecase` и `etypecase` подобные `case` и "
"`typecase` за исключением того, что они сигнализируют об ошибке, если нет "
"соответствия."

#: in/chapter3.md:251
msgid ""
"You can think of the `e` as standing for either \"exhaustive\" or \"error."
"\"\n"
"The forms `ccase` and `ctypecase` also signal errors, but they can be "
"continuable errors (as opposed to fatal errors): the user is offered the "
"chance to change the expression to something that satisfies one of the "
"matches.\n"
"Here are some examples of case forms and their `cond` equivalents:"
msgstr ""
"Вы можете думать, что буква `e` означает либо \"exhaustive/исчерпывающий\", "
"либо \"error/ошибка\".\n"
"Формы \"ccase\" и \"ctypecase\" также сигнализируют об ошибках, но они могут "
"быть continuable ошибками (в отличие от фатальных ошибок): пользователю "
"предлагается возможность изменить выражение на то, что удовлетворяет одному "
"из искомых соответствий.\n"
"Вот несколько примеров case форм и их `cond` эквивалентов:"

#: in/chapter3.md:271
msgid ""
"| []()                 |                                    |\n"
"|----------------------|------------------------------------|\n"
"| `(case x`            | `(cond`                            |\n"
"| `(1 10)`             | `((eql x 1) 10)`                   |\n"
"| `(2 20))`            | `((eql x 2) 20))`                  |\n"
"|                      |                                    |\n"
"| `(typecase x`        | `(cond`                            |\n"
"| `(number (abs x))`   | `((typep x 'number) (abs x))`      |\n"
"| `(list (length x)))` | `((typep x 'list) (length x)))`    |\n"
"|                      |                                    |\n"
"| `(ecase x`           | `(cond`                            |\n"
"| `(1 10)`             | `((eql x 1) 10)`                   |\n"
"| `(2 20))`            | `((eql x 2) 20)`                   |\n"
"|                      | `(t (error \"no valid case\")))`     |\n"
"|                      |                                    |\n"
"| `(etypecase x`       | `(cond`                            |\n"
"| `(number (abs x))`   | `((typep x 'number) (abs x))`      |\n"
"| `(list (length x)))` | `((typep x 'list) (length x))`     |\n"
"|                      | `(t (error \"no valid typecase\")))` |"
msgstr ""

#: in/chapter3.md:273
msgid "### Special Forms for Dealing with Variables and Places"
msgstr "### Специальные формы для работы с переменными и местами"

#: in/chapter3.md:277
msgid ""
"The special form `setf` is used to assign a new value to a variable or "
"*place,* much as an assignment statement with `=` or `:=` is used in other "
"languages.\n"
"A place, or *generalized variable* is a name for a location that can have a "
"value stored in it.\n"
"Here is a table of corresponding assignment forms in Lisp and Pascal:"
msgstr ""
"Специальная форма `setf` используется для присвоения нового значения "
"переменной или *place/месту*, так же как оператор присваивания  `=` или `:=` "
"используется в других языках.\n"
"Место(place), или *обобщенная переменная* - это наименование местоположения, "
"в котором может храниться значение.\n"
"Вот таблица соответствующих форм присвоения в Lisp и Pascal:"

#: in/chapter3.md:285
msgid ""
"| []()                        |                      |\n"
"|-----------------------------|----------------------|\n"
"| `;; Lisp`                   | `/* Pascal */`       |\n"
"| `(setf x 0)`                | `x := 0;`            |\n"
"| `(setf (aref A i j) 0)`     | `A[i,j] := 0;`       |\n"
"| `(setf (rest list) nil)`    | `list^.rest := nil;` |\n"
"| `(setf (name-middle b) 'Q)` | `b\\middle := \"Q\";`   |"
msgstr ""

#: in/chapter3.md:290
msgid ""
"`setf` can be used to set a component of a structure as well as to set a "
"variable.\n"
"In languages like Pascal, the expressions that can appear on the left-hand "
"side of an assignment statement are limited by the syntax of the language.\n"
"In Lisp, the user can extend the expressions that are allowed in a `setf` "
"form using the special forms `defsetf` or `define-setf-method`.\n"
"These are introduced on [pages 514](B9780080571157500157.xhtml#p514) and "
"[884](B978008057115750025X.xhtml#p884) respectively."
msgstr ""
"`setf` можно использовать как для установки компонента структуры, так и для "
"установки переменной.\n"
"В таких языках, как Pascal, выражения, которые могут появляться в левой "
"части инструкции присваивания, ограничены синтаксисом языка.\n"
"В Лиспе, пользователь может расширить выражения, которые допустимы в форме "
"`setf` используя специальные формы `defsetf` или `define-setf-method`\n"
"Они представлены на [страницах 514](B9780080571157500157.xhtml#p514) и [884]"
"(B978008057115750025X.xhtml#p884) соответственно."

#: in/chapter3.md:294
msgid ""
"There are also some built-in functions that modify places.\n"
"For example, (`rplacd list nil`) has the same effect as (`setf` (`rest "
"list`) `nil`), except that it returns `list` instead of `nil`.\n"
"Most Common Lisp programmers prefer to use the `setf` forms rather than the "
"specialized functions."
msgstr ""
"Есть также некоторые встроенные функции, которые изменяют места.\n"
"Например, (`rplacd список nil`) имеет такой же эффект, как (`setf` (`rest "
"list`) `nil`), за исключением того, что он возвращает `list` вместо `nil`.\n"
"Большинство программистов Common Lisp предпочитают использовать формы  "
"`setf`, а не специализированные функции."

#: in/chapter3.md:297
msgid ""
"If you only want to set a variable, the special form `setq` can be used "
"instead.\n"
"In this book I choose to use `setf` throughout, opting for consistency over "
"specificity."
msgstr ""
"Если вы хотите установить только переменную, то вместо нее можно "
"использовать специальную форму setq.\n"
"В этой книге я предпочитаю использовать `setf` повсюду, предпочитая "
"последовательность специфике."

#: in/chapter3.md:305
msgid ""
"The discussion in this section makes it seem that variables (and slots of "
"structures) are assigned new values all the time.\n"
"Actually, many Lisp programs do no assignments whatsoever.\n"
"It is very common to use Lisp in a functional style where new variables may "
"be introduced, but once a new variable is established, it never changes.\n"
"One way to introduce a new variable is as a parameter of a function.\n"
"It is also possible to introduce local variables using the special form "
"`let`.\n"
"Following are the general `let` form, along with an example.\n"
"Each variable is bound to the corresponding value, and then the body is "
"evaluated:"
msgstr ""
"Обсуждение в этом разделе заставляет думать, что переменным (и слотам "
"структур) все время присваиваются новые значения.\n"
"На самом деле, многие программы Lisp вообще не выполняют никаких "
"присваиваний.\n"
"Очень часто используется Lisp в функциональном стиле, где могут быть введены "
"новые переменные, но как только новая переменная установлена, она никогда не "
"меняется.\n"
"Один из способов ввести новую переменную - это ввести ее в качестве "
"параметра функции.\n"
"Кроме того, можно ввести локальные переменные, используя специальную форму "
"`let`.\n"
"Ниже приводится общая форма `let`, а также пример.\n"
"Каждая переменная привязывается к соответствующему значению, а затем тело "
"вычисляется:"

#: in/chapter3.md:308
msgid ""
"> `(let` ((*variable value*)...)  \n"
"> *body*...)"
msgstr ""

#: in/chapter3.md:314
msgid ""
"```lisp\n"
"(let ((x 40)\n"
"       (y (+ 1 1)))\n"
"  (+ x y)) => 42\n"
"```"
msgstr ""

#: in/chapter3.md:317
msgid ""
"Defining a local variable with a `let` form is really no different from "
"defining parameters to an anonymous function.\n"
"The former is equivalent to:"
msgstr ""
"Определение локальной переменной с помощью формы `let` на самом деле ничем "
"не отличается от определения параметров анонимной функции.\n"
"Первое эквивалентно:"

#: in/chapter3.md:323
msgid ""
"| []()                        |\n"
"|-----------------------------|\n"
"| ((`lambda` (*variable*... ) |\n"
"| `  ` *body*... )            |\n"
"| *value*...)                 |"
msgstr ""

#: in/chapter3.md:330
msgid ""
"```lisp\n"
"((lambda (x y)\n"
"     (+ x y))\n"
"40\n"
"(+ 1 1))\n"
"```"
msgstr ""

#: in/chapter3.md:333
msgid ""
"First, all the values are evaluated.\n"
"Then they are bound to the variables (the parameters of the lambda "
"expression), and finally the body is evaluated, using those bindings."
msgstr ""
"Во-первых, все значения вычисляются.\n"
"Затем они привязываются к переменным (параметрам лямбда-выражения), и, "
"наконец, тело вычисляется, используя эти привязки."

#: in/chapter3.md:336
msgid ""
"The special form `let*` is appropriate when you want to use one of the newly "
"introduced variables in a subsequent *value* computation.\n"
"For example:"
msgstr ""
"Специальная форма `let*` подходит, когда вы хотите использовать одну из "
"вновь введенных переменных в последующем вычислении *value*.\n"
"Например:"

#: in/chapter3.md:342
msgid ""
"```lisp\n"
"(let* ((x 6)\n"
"       (y (* x x)))\n"
"  (+ x y)) => 42\n"
"```"
msgstr ""

#: in/chapter3.md:344
msgid ""
"We could not have used `let` here, because then the variable `x` would be "
"unbound during the computation of `y`'s value."
msgstr ""
"Мы не могли бы использовать здесь `let`, потому что тогда переменная `x` "
"была бы несвязана во время вычисления значения `y`."

#: in/chapter3.md:347
msgid ""
"&#9635; **Exercise 3.1 [m]** Show a `lambda` expression that is equivalent "
"to the above `let*` expression.\n"
"You may need more than one `lambda.`"
msgstr ""
"&#9635; **Упражнение 3.1 [m]** покажите выражение `lambda`, эквивалентное "
"приведенному выше выражению `let*`.\n"
"Вам может понадобиться больше, чем одна `lambda.`"

#: in/chapter3.md:351
msgid ""
"Because lists are so important to Lisp, there are special forms for adding "
"and deleting elements from the front of a list - in other words, for "
"treating a list as a stack.\n"
"If `list` is the name of a location that holds a list, then (`push` *x* "
"`list`) will change `list` to have *x* as its first element, and (`pop "
"list`) will return the first element and, as a side-effect, change `list` to "
"no longer contain the first element.\n"
"`push` and `pop` are equivalent to the following expressions:"
msgstr ""
"Поскольку списки очень важны для Lisp, существуют специальные формы для "
"добавления и удаления элементов из передней части списка - другими словами, "
"для обработки списка как стека.\n"
"Если '`list` - это имя местоположения, содержащего список, то (`push` *x* "
"`list`) изменит `list`, чтобы иметь *x* в качестве его первого элемента, и "
"(`pop list`) вернет первый элемент и, как побочный эффект, изменит `list`, "
"чтобы он больше не содерал первый элемент.\n"
"`push` и `pop` эквивалентны следующим выражениям:"

#: in/chapter3.md:358
msgid ""
"```lisp\n"
"(push x list) = (setf list (cons x list))\n"
"(pop list)    = (let ((result (first list)))\n"
"                 (setf list (rest list))\n"
"                 result)\n"
"```"
msgstr ""

#: in/chapter3.md:364
msgid ""
"Just as a list can be used to accumulate elements, a running sum can be used "
"to accumulate numbers.\n"
"Lisp provides two more special forms, `incf` and `decf`, that can be used to "
"increment or decrement a sum.\n"
"For both forms the first argument must be a location (a variable or other "
"`setf`-able form) and the second argument, which is optional, is the number "
"to increment or decrement by.\n"
"For those who know C, (`incf x`) is equivalent to `++x`, and (`incf x 2`) is "
"equivalent to `x+=2`.\n"
"In Lisp the equivalence is:"
msgstr ""
"Точно так же, как список может использоваться для накопления элементов, "
"вызов sum может использоваться для накопления чисел.\n"
"Lisp предоставляет еще две специальные формы, `incf` и `decf`, которые могут "
"быть использованы для увеличения или уменьшения суммы.\n"
"Для обеих форм первым аргументом должно быть местоположение (переменная или "
"другая `setf` - подобная форма), а вторым аргументом, который является "
"необязательным, является число, на которое нужно увеличивать или уменьшать.\n"
"Для тех, кто знает Си, (`incf x`) эквивалентно `++x`, а (`incf x 2`) "
"эквивалентно `x+=2`.\n"
"В Лиспе эквивалентны формы:"

#: in/chapter3.md:369
msgid ""
"```lisp\n"
"(incf x) = (incf x 1) = (setf x (+ x 1))\n"
"(decf x) = (decf x 1) = (setf x (- x 1))\n"
"```"
msgstr ""

#: in/chapter3.md:375
msgid ""
"When the location is a complex form rather than a variable, Lisp is careful "
"to expand into code that does not evaluate any subform more than once.\n"
"This holds for `push`, `pop`, `incf,` and `decf`.\n"
"In the following example, we have a list of players and want to decide which "
"player has the highest score, and thus has won the game.\n"
"The structure `player` has slots for the player's score and number of wins, "
"and the function `determine-winner` increments the winning player's `wins` "
"field.\n"
"The expansion of the `incf` form binds a temporary variable so that the sort "
"is not done twice."
msgstr ""
"Когда расположение представляет собой сложную форму, а не переменную, Lisp "
"осторожно расширяется в код, который не вычисляет ни одну подформу более "
"одного раза.\n"
"Это справедливо для `push`, `pop`, `incf` и `decf`.\n"
"В следующем примере у нас есть список игроков, и мы хотим решить, какой "
"игрок имеет самый высокий балл и, таким образом, выигрывает игру.\n"
"Структура `player` имеет слоты для счета(score) игрока и количества побед, а "
"функция `determine-winner` увеличивает поле `wins` победившего игрока.\n"
"Расширение формы 'incf' связывает временную переменную, так что сортировка "
"не выполняется дважды."

#: in/chapter3.md:378
msgid ""
"```lisp\n"
"(defstruct player (score 0) (wins 0))"
msgstr ""

#: in/chapter3.md:384
msgid ""
"(defun determine-winner (players)\n"
"  \"Increment the WINS for the player with highest score.\"\n"
"  (incf (player-wins (first (sort players #'>\n"
"                                  :key #'player-score)))))"
msgstr ""

#: in/chapter3.md:390
msgid ""
"(defun determine-winner (players)\n"
"   \"Increment the WINS for the player with highest score.\"\n"
"   (let ((temp (first (sort players #'> :key #'player-score))))\n"
"      (setf (player-wins temp) (+ (player-wins temp) 1))))\n"
"```"
msgstr ""

#: in/chapter3.md:392
msgid "### Functions and Special Forms for Repetition"
msgstr "### Функции и специальные формы для повторения"

#: in/chapter3.md:396
msgid ""
"Many languages have a small number of reserved words for forming iterative "
"loops.\n"
"For example, Pascal has `while, repeat,` and `for` statements.\n"
"In contrast, Common Lisp has an almost bewildering range of possibilities, "
"as summarized below:"
msgstr ""
"Многие языки имеют небольшое количество зарезервированных слов для "
"формирования итерационных циклов.\n"
"Например, Паскаль имеет выражения `while, repeat` и `for`\n"
"В отличие от него, Common Lisp обладает почти ошеломляющим диапазоном "
"возможностей, как показано ниже:"

#: in/chapter3.md:407
msgid ""
"| []()                  |                                 |\n"
"|-----------------------|---------------------------------|\n"
"| `dolist`              | loop over elements of a list    |\n"
"| `dotimes`             | loop over successive integers   |\n"
"| `do, do*`             | general loop, sparse syntax     |\n"
"| `loop`                | general loop, verbose syntax    |\n"
"| `mapc, mapcar`        | loop over elements of lists(s)  |\n"
"| `some, every`         | loop over list until condition  |\n"
"| `find, reduce,`*etc.* | more specific looping functions |\n"
"| *recursion*           | general repetition              |"
msgstr ""

#: in/chapter3.md:411
msgid ""
"To explain each possibility we will present versions of the function "
"`length`, which returns the number of elements in a list.\n"
"First, the special form `dolist` can be used to iterate over the elements of "
"a list.\n"
"The syntax is:"
msgstr ""
"Для объяснения каждой возможности мы представим версии функции `length`, "
"которая возвращает количество элементов в списке.\n"
"Во-первых, специальная форма `dolist` может использоваться для перебора "
"элементов списка.\n"
"Синтаксис таков:"

#: in/chapter3.md:413
msgid "> `(dolist (`*variable list optional-result*) *body...*)"
msgstr ""

#: in/chapter3.md:416
msgid ""
"This means that the body is executed once for each element of the list, with "
"*variable* bound to the first element, then the second element, and so on.\n"
"At the end, `dolist` evaluates and returns the *optional-result* expression, "
"or nil if there is no result expression."
msgstr ""
"Это означает, что тело выполняется один раз для каждого элемента списка, "
"причем *variable* связывается к первому элементу, затем ко второму элементу "
"и так далее.\n"
"В конце концов, `dolist` вычисляет и возвращает выражение *optional-result*, "
"или nil, если нет выражения для возврата результата."

#: in/chapter3.md:421
msgid ""
"Below is a version of `length` using `dolist`.\n"
"The `let` form introduces a new variable, `len`, which is initially bound to "
"zero.\n"
"The `dolist` form then executes the body once for each element of the list, "
"with the body incrementing `len` by one each time.\n"
"This use is unusual in that the loop iteration variable, `element`, is not "
"used in the body."
msgstr ""
"Ниже приведена версия `length` с использованием `dolist`.\n"
"Форма `let` вводит новую переменную, `len`, которая изначально привязана к "
"нулю.\n"
"Затем форма `dolist` выполняет тело один раз для каждого элемента списка, "
"причем тело каждый раз увеличивает `len` на единицу.\n"
"Это использование необычно тем, что переменная итерации цикла, `element`, не "
"используется в теле."

#: in/chapter3.md:429
msgid ""
"```lisp\n"
"(defun length1 (list)\n"
"  (let ((len 0))            ; start with LEN=0\n"
"    (dolist (element list)  ; and on each iteration\n"
"      (incf len))           ;  increment LEN by 1\n"
"    len))                   ; and return LEN\n"
"```"
msgstr ""

#: in/chapter3.md:432
msgid ""
"It is also possible to use the optional result of `dolist`, as shown below.\n"
"While many programmers use this style, I find that it is too easy to lose "
"track of the result, and so I prefer to place the result last explicitly."
msgstr ""
"Также можно использовать необязательный результат `dolist`, как показано "
"ниже.\n"
"В то время как многие программисты используют этот стиль, я нахожу, что "
"слишком легко потерять след результата, и поэтому я предпочитаю явно "
"размещать результат последним."

#: in/chapter3.md:439
msgid ""
"```lisp\n"
"(defun length1.1 (list)         ; alternate version:\n"
"  (let ((len 0))                ; (not my preference)\n"
"    (dolist (element list len)  ; uses len as result here\n"
"      (incf len))))\n"
"```"
msgstr ""

#: in/chapter3.md:444
msgid ""
"The function `mapc` performs much the same operation as the special form "
"`dolist`.\n"
"In the simplest case, `mapc` takes two arguments, the first a function, the "
"second a list.\n"
"It applies the function to each element of the list.\n"
"Here is `length` using `mapc`:"
msgstr ""
"Функция `mapc` выполняет такие же операции, как и специальная форма "
"`dolist`.\n"
"В простейшем случае `mapc` принимает два аргумента: первый-функцию, второй-"
"список.\n"
"Она применяет эту функцию к каждому элементу списка.\n"
"Здесь `length`, использует  `mapc`:"

#: in/chapter3.md:453
msgid ""
"```lisp\n"
"(defun length2 (list)\n"
"  (let ((len 0))                    ; start with LEN=0\n"
"    (mapc #'(lambda (element)       ; and on each iteration\n"
"              (incf len))           ;  increment LEN by 1\n"
"          list)\n"
"    len))                           ; and return LEN\n"
"```"
msgstr ""

#: in/chapter3.md:456
msgid ""
"There are seven different mapping functions, of which the most useful are "
"`mapc` and `mapcar`.\n"
"`mapcar` executes the same function calls as `mapc,` but then returns the "
"results in a list."
msgstr ""
"Существует семь различных функций отображения(mapping), из которых наиболее "
"полезными являются `mapc` и `mapcar`.\n"
"`mapcar` выполняет те же вызовы функций, что и `mapc`, но затем возвращает "
"результаты в виде списка."

#: in/chapter3.md:458
msgid "There is also a `dotimes` form, which has the syntax:"
msgstr "Существует также форма `dotimes`, которая имеет синтаксис:"

#: in/chapter3.md:460
msgid "> (`dotimes` (*variable number optional-result*) *body...*)"
msgstr ""

#: in/chapter3.md:463
msgid ""
"and executes the body with *variable* bound first to zero, then one, all the "
"way up to *number*-1 (for a total of *number* times).\n"
"Of course, `dotimes` is not appropriate for implementing `length`, since we "
"don't know the number of iterations ahead of time."
msgstr ""
"и выполняет тело с *variable* привязанной сначала к нулю, затем к единице, "
"вплоть до *number*-1 (в общей сложности *number* раз).\n"
"Конечно, `dotimes` не подходит для реализации `length`, так как мы не знаем "
"количество итераций заранее."

#: in/chapter3.md:466
msgid ""
"There are two very general looping forms, `do` and `loop`.\n"
"The syntax of `do` is as follows:"
msgstr ""
"Есть две очень общие формы цикла `do` и `loop`.\n"
"Синтаксис `do` выглядит следующим образом:"

#: in/chapter3.md:472
msgid ""
"```lisp\n"
"(do ((variable initial next)...)\n"
"    (exit-test result)\n"
"  body...)\n"
"```"
msgstr ""

#: in/chapter3.md:479
msgid ""
"Each *variable* is initially bound to the *initial* value.\n"
"If *exit-test* is true, then *result* is returned.\n"
"Otherwise, the body is executed and each *variable* is set to the "
"corresponding *next* value and *exit-test* is tried again.\n"
"The loop repeats until *exit-test* is true.\n"
"If a *next* value is omitted, then the corresponding variable is not updated "
"each time through the loop.\n"
"Rather, it is treated as if it had been bound with a `let` form."
msgstr ""
"Каждая *variable/переменная* изначально привязана к *initial/исходному* "
"значению.\n"
"Если вычисление *exit-test*  дает значение true, то возвращается *result*.\n"
"В противном случае выполняется тело/body, и каждая *variable/переменная* "
"устанавливается в соответствующее значение *next*, и повторяется вычисление "
"*exit-test*.\n"
"Цикл повторяется до тех пор, пока *exit-test* не станет истинным.\n"
"Если значение *next* опущено, то соответствующая переменная не обновляется "
"каждый раз в цикле.\n"
"Скорее, с ней обращаются так, как если бы она был связана с формой `let`."

#: in/chapter3.md:485
msgid ""
"Here is `length` implemented with `do`, using two variables, `len` to count "
"the number of elements, and `l` to go down the list.\n"
"This is often referred to as *cdr-ing down a list,* because on each "
"operation we apply the function `cdr` to the list.\n"
"(Actually, here we have used the more mnemonic name `rest` instead of "
"`cdr`.)\n"
"Note that the `do` loop has no body!\n"
"All the computation is done in the variable initialization and stepping, and "
"in the end test."
msgstr ""
"Здесь `length` реализована с помощью `do`, используя две переменные: `len` "
"для подсчета количества элементов и `l` для прохода вниз по списку.\n"
"Это часто называют *cdr-ингом вниз по списку*, потому что при каждой "
"операции мы применяем функцию `cdr` к списку.\n"
"(На самом деле, здесь мы использовали более мнемоническое(запоминающееся) "
"название `rest` вместо `cdr`.)\n"
"Обратите внимание, что цикл `do` не имеет тела!\n"
"Все вычисления выполняются в переменной инициализации и пошаговом "
"выполнении, а также в тесте завершения цикла."

#: in/chapter3.md:492
msgid ""
"```lisp\n"
"(defun length3 (list)\n"
"  (do ((len 0 (+ len 1))   ; start with LEN=0, increment\n"
"       (l list (rest l)))  ; ... on each iteration\n"
"      ((null l) len)))     ; (until the end of the list)\n"
"```"
msgstr ""

#: in/chapter3.md:500
msgid ""
"I find the `do` form a little confusing, because it does not clearly say "
"that we are looping through a list.\n"
"To see that it is indeed iterating over the list requires looking at both "
"the variable `l` and the end test.\n"
"Worse, there is no variable that stands for the current element of the list; "
"we would need to say (`first l`) to get at it.\n"
"Both `dolist` and `mapc` take care of stepping, end testing, and variable "
"naming automatically.\n"
"They are examples of the \"be specific\" principle.\n"
"Because it is so unspecific, `do` will not be used much in this book.\n"
"However, many good programmers use it, so it is important to know how to "
"read `do` loops, even if you decide never to write one."
msgstr ""
"Я нахожу форму `do` немного запутанной, потому что она не ясно говорит, что "
"мы проходим через список.\n"
"Чтобы увидеть, что он действительно проходит по списку, необходимо "
"посмотреть как на переменную `l`, так и на тест завершения цикла.\n"
"Хуже того, нет переменной, которая обозначает текущий элемент списка; нам "
"нужно было бы сказать (`first l`), чтобы добраться до него.\n"
"И `dolist`, и `mapc` заботяться о выполнении шагов и проверки на завершение "
"списка, и автоматическому именованию переменной.\n"
"Они являются примерами принципа \"быть конкретным\".\n"
"Из-за того, что она так неконкретна,  `do` не будет часто использоваться в "
"этой книге.\n"
"Однако многие хорошие программисты используют её, поэтому важно знать, как "
"читать циклы `do`, даже если вы решили никогда их не писать."

#: in/chapter3.md:504
msgid ""
"The syntax of `loop` is an entire language by itself, and a decidedly non-"
"Lisp-like language it is.\n"
"Rather than list all the possibilities for `loop`, we will just give "
"examples here, and refer the reader to *Common Lisp the Language*, 2d "
"edition, or chapter 24.5 for more details.\n"
"Here are three versions of `length` using `loop`:"
msgstr ""
"Синтаксис `loop` -это целый язык сам по себе, и это определенно не "
"Лиспоподобный язык.\n"
"Вместо того, чтобы перечислять все возможности для `loop`, мы просто "
"приведем примеры здесь, и отсылаем читателя к *Common Lisp The Language*, 2d "
"edition или главе 24.5 для получения более подробной информации.\n"
"Вот три версии `length` с использованием `loop`:"

#: in/chapter3.md:509
msgid ""
"```lisp\n"
"(defun length4 (list)\n"
"  (loop for element in list      ; go through each element\n"
"        count t))                ;   counting each one"
msgstr ""

#: in/chapter3.md:513
msgid ""
"(defun length5 (list)\n"
"  (loop for element in list      ; go through each element\n"
"        summing 1))              ;   adding 1 each time"
msgstr ""

#: in/chapter3.md:521
msgid ""
"(defun length6 (list)\n"
"  (loop with len = 0             ; start with LEN=0\n"
"        until (null list)        ; and (until end of list)\n"
"        for element = (pop list) ; on each iteration\n"
"        do (incf len)            ;  increment LEN by 1\n"
"        finally (return len)))   ; and return LEN\n"
"```"
msgstr ""

#: in/chapter3.md:526
msgid ""
"Every programmer learns that there are certain kinds of loops that are used "
"again and again.\n"
"These are often called *programming idioms* or *cliches.* An example is "
"going through the elements of a list or array and doing some operation to "
"each element.\n"
"In most languages, these idioms do not have an explicit syntactic marker.\n"
"Instead, they are implemented with a general loop construct, and it is up to "
"the reader of the program to recognize what the programmer is doing."
msgstr ""
"Каждый программист знает, что существуют определенные типы циклов, которые "
"используются снова и снова.\n"
"Их часто называют *программными идиомами* или *клише*. Пример-это перебор "
"элементов списка или массива и выполнение некоторой операции для каждого "
"элемента.\n"
"В большинстве языков эти идиомы не имеют явного синтаксического маркера.\n"
"Вместо этого они реализуются с помощью общей конструкции цикла, и только "
"читатель программы может распознать, что делает программист."

#: in/chapter3.md:531
msgid ""
"Lisp is unusual in that it provides ways to explicitly encapsulate such "
"idioms, and refer to them with explicit syntactic and functional forms.\n"
"`dolist` and `dotimes` are two examples of this - they both follow the \"be "
"specific\" principle.\n"
"Most programmers prefer to use a `dolist` rather than an equivalent `do,` "
"because it cries out \"this loop iterates over the elements of a list.\"\n"
"Of course, the corresponding `do` form also says the same thing - but it "
"takes more work for the reader to discover this."
msgstr ""
"Lisp необычен тем, что он предоставляет способы явно инкапсулировать такие "
"идиомы и ссылаться на них используя явный синтаксичес и функциональные "
"формамы.\n"
"`dolist` и `dotimes` являются двумя примерами этого - они оба следуют "
"принципу \"быть конкретным\".\n"
"Большинство программистов предпочитают использовать `dolist`, а не "
"эквивалентное `do`, потому что оно кричит: \"этот цикл проходит по элементам "
"списка.\"\n"
"Конечно, соответствующая форма `do` также говорит то же самое, но читателю "
"требуется больше работы, чтобы обнаружить это."

#: in/chapter3.md:537
msgid ""
"In addition to special forms like `dolist` and `dotimes,` there are quite a "
"few functions that are designed to handle common idioms.\n"
"Two examples are `count-if,` which counts the number of elements of a "
"sequence that satisfy a predicate, and `position-if,` which returns the "
"index of an element satisfying a predicate.\n"
"Both can be used to implement `length.`\n"
"In `length7` below, `count-if` gives the number of elements in `list` that "
"satisfy the predicate `true.`\n"
"Since `true` is defined to be always true, this gives the length of the list."
msgstr ""
"В дополнение к специальным формам, таким как `dolist` и `dotimes`, "
"существует довольно много функций, предназначенных для обработки общих "
"идиом.\n"
"Два примера: `count-if`, которая подсчитывает количество элементов "
"последовательности, удовлетворяющих предикату, и `position-if`, которая "
"возвращает индекс элемента, удовлетворяющего предикату.\n"
"Обе могут быть использованы для реализации `length.`\n"
"В `length7` ниже, `count-if` определяет количество элементов в списке-"
"`list`, которые удовлетворяют предикату, т.е для всех них он возвращает "
"`true`.\n"
"Поскольку `true` определяется как всегда true, функция возвращает длину "
"списка."

#: in/chapter3.md:541
msgid ""
"```lisp\n"
"(defun length7 (list)\n"
"  (count-if #'true list))"
msgstr ""

#: in/chapter3.md:544
msgid ""
"(defun true (x) t)\n"
"```"
msgstr ""

#: in/chapter3.md:548
msgid ""
"In `length8,` the function `position-if` finds the position of an element "
"that satisfies the predicate true, starting from the end of the list.\n"
"This will be the very last element of the list, and since indexing is zero-"
"based, we add one to get the length.\n"
"Admittedly, this is not the most straightforward implementation of `length.`"
msgstr ""
"В `length8` функция `position-if` находит позицию элемента, удовлетворяющего "
"предикату true, начиная с конца списка.\n"
"Это будет самый последний элемент списка, и поскольку индексация начинается "
"с нуля, мы добавим единицу, чтобы получить длину.\n"
"По общему признанию, это не самая простая реализация `length.`"

#: in/chapter3.md:555
msgid ""
"```lisp\n"
"(defun length8 (list)\n"
"  (if (null list)\n"
"      0\n"
"      (+ 1 (position-if #'true list :from-end t))))\n"
"```"
msgstr ""

#: in/chapter3.md:560
msgid ""
"A partial table of functions that implement looping idioms is given below.\n"
"These functions are designed to be flexible enough to handle almost all "
"operations on sequences.\n"
"The flexibility comes in three forms.\n"
"First, functions like `mapcar` can apply to an arbitrary number of lists, "
"not just one:"
msgstr ""
"Ниже приведена часть таблицы функций, реализующих циклические идиомы.\n"
"Эти функции разработаны так, чтобы быть достаточно гибкими для обработки "
"почти всех операций над последовательностями.\n"
"Гибкость проявляется в трех формах.\n"
"Во-первых, такие функции, как `mapcar` , могут применяться к произвольному "
"числу списков, а не только к одному:"

#: in/chapter3.md:566
msgid ""
"```lisp\n"
"> (mapcar #'- '(1 2 3)) => (-1 -2 -3)\n"
"> (mapcar #'+ '(1 2) '(10 20)) => (11 22)\n"
"> (mapcar #'+ '(1 2) '(10 20) '(100 200)) => (111 222)\n"
"```"
msgstr ""

#: in/chapter3.md:568
msgid ""
"Second, many of the functions accept keywords that allow the user to vary "
"the test for comparing elements, or to only consider part of the sequence."
msgstr ""
"Во-вторых, многие функции принимают ключевые слова, которые позволяют "
"пользователю изменять тест(test) для сравнения элементов или рассматривать "
"только часть последовательности."

#: in/chapter3.md:571
msgid ""
"```lisp\n"
"> (remove 1 '(1 2 3 2 1 0 -1)) => (2 3 2 0 -1)"
msgstr ""

#: in/chapter3.md:573
msgid "> (remove 1 '(1 2 3 2 1 0 -1) :key #'abs) => (2 3 2 0)"
msgstr ""

#: in/chapter3.md:575
msgid "> (remove 1 '(1 2 3 2 1 0 -1) :test #'<) => (1 1 0 -1)"
msgstr ""

#: in/chapter3.md:578
msgid ""
"> (remove 1 '(1 2 3 2 1 0 -1) : start 4) => (1 2 3 2 0 -1)\n"
"```"
msgstr ""
"> (remove 1 '(1 2 3 2 1 0 -1) :start 4) => (1 2 3 2 0 -1)\n"
"```"

#: in/chapter3.md:580
msgid ""
"Third, some have corresponding functions ending in `-if` or `-if-not` that "
"take a predicate rather than an element to match against:"
msgstr ""
"В-третьих, некоторые из них имеют соответствующие функции, заканчивающиеся "
"на `-if` или `-if-not`, которые принимают предикат, а не элемент для "
"сопоставления с ним:"

#: in/chapter3.md:583
msgid ""
"```lisp\n"
"> (remove-if #'oddp '(1 2 3 2 1 0 -1)) => (2 2 0)"
msgstr ""

#: in/chapter3.md:585
msgid "> (remove-if-not #'oddp '(1 2 3 2 1 0 -1)) => (1 3 1 -1)"
msgstr ""

#: in/chapter3.md:588
msgid ""
"> (find-if #'evenp '(1 2 3 2 1 0 -1)) => 2\n"
"```"
msgstr ""

#: in/chapter3.md:590
msgid "The following two tables assume these two values:"
msgstr "Следующие две таблицы предполагают эти два значения:"

#: in/chapter3.md:595
msgctxt "in/chapter3.md:595"
msgid ""
"```lisp\n"
"(setf x '(a b c))\n"
"(setf y '(1 2 3))\n"
"```"
msgstr ""

#: in/chapter3.md:597
msgid ""
"The first table lists functions that work on any number of lists but do not "
"accept keywords:"
msgstr ""
"В первой таблице перечислены функции, которые работают с любым количеством "
"списков, но не принимают ключевые слова:"

#: in/chapter3.md:604
msgid ""
"| []()                |                  "
"|                                                  |\n"
"|---------------------|------------------|--------------------------------------------------|\n"
"| `(every #' oddp y)` | => `nil`         | test if every element satisfies a "
"predicate      |\n"
"| `(some #' oddp y)`  | => `t`           | test if some element satisfies "
"predicate         |\n"
"| `(mapcar #'- y)`    | => `(-1 -2 -3)`  | apply function to each element "
"and return result |\n"
"| `(mapc #'print y)`  | *prints* `1 2 3` | perform operation on each "
"element                |"
msgstr ""
"| пример              | результат        |    "
"пояснение                                          |\n"
"|---------------------|------------------|-------------------------------------------------------|\n"
"| ``(every #'oddp y)``  | => `nil`         | проверяет, удовлетворяет ли "
"каждый элемент предикату   |\n"
"| ``(some #'oddp y)``   | => `t`           | проверяет, удовлетворяет ли "
"какой-нибудь эл-т предикату|\n"
"| ``(mapcar #'- y)``    | => `(-1 -2 -3)`  | применяет функцию к каждому "
"элементу и возвр. результат|\n"
"| ``(mapc #'print y)``  | *prints* `1 2 3` | выполняет операцию над каждым "
"элементом                |"

#: in/chapter3.md:606
msgid ""
"The second table lists functions that have `-if` and `-if-not` versions and "
"also accept keyword arguments:"
msgstr ""
"Во второй таблице перечислены функции, которые имеют версии `-if` и `-if-"
"not`, а также принимают аргументы ключевые слова:"

#: in/chapter3.md:617
msgid ""
"| []()                 |              "
"|                                       |\n"
"|----------------------|--------------|---------------------------------------|\n"
"| `(member 2 y)`       | =>`(2 3)`    | see if element is in "
"list             |\n"
"| `(count 'b x)`       | => 1         | count the number of matching "
"elements |\n"
"| `(delete 1 y)`       | => `(2 3)`   | omit matching "
"elements                |\n"
"| `(find 2 y)`         | => `2`       | find first element that "
"matches       |\n"
"| `(position 'a x)`    | => 0         | find index of element in "
"sequence     |\n"
"| `(reduce #'+ y)`     | => `6`       | apply function to successive "
"elements |\n"
"| `(remove 2 y)`       | => `(1 3)`   | like `delete`, but makes a new "
"copy   |\n"
"| `(substitute 4 2 y)` | => `(1 4 3)` | replace elements with new "
"ones        |"
msgstr ""
"| функция              | результат    |  "
"объяснение                                  |\n"
"|----------------------|--------------|----------------------------------------------|\n"
"| `(member 2 y)`       | =>`(2 3)`    | проверяет есть ли элемент в "
"списке           |\n"
"| `(count 'b x)`       | => 1         | считает количество совпавших "
"элементов       |\n"
"| `(delete 1 y)`       | => `(2 3)`   | изымает совпавшие "
"элементы                   |\n"
"| `(find 2 y)`         | => `2`       | ищет первый совпадающий "
"элемент              |\n"
"| `(position 'a x)`    | => 0         | ищет индек элемента в "
"последовательности     |\n"
"| ``(reduce #'+ y)``     | => `6`       | применяет функцию к "
"последовательным элементам |\n"
"| `(remove 2 y)`       | => `(1 3)`   | подобно `delete`, но создает новую "
"копию     |\n"
"| `(substitute 4 2 y)` | => `(1 4 3)` | заменяет элементы "
"новыми                     |"

#: in/chapter3.md:621
msgid ""
"### Repetition through Recursion\n"
"Lisp has gained a reputation as a \"recursive\" language, meaning that Lisp "
"encourages programmers to write functions that call themselves.\n"
"As we have seen above, there is a dizzying number of functions and special "
"forms for writing loops in Common Lisp, but it is also true that many "
"programs handle repetition through recursion rather than with a syntactic "
"loop."
msgstr ""
"### Повторение через рекурсию\n"
"Lisp приобрел репутацию \"рекурсивного\" языка, что означает, что Lisp "
"поощряет программистов писать функции, которые вызывают сами себя.\n"
"Как мы видели выше, существует головокружительное количество функций и "
"специальных форм для записи циклов в Common Lisp, но также верно, что многие "
"программы реализуют повторение через рекурсию, а не с помощью "
"синтаксического цикла."

#: in/chapter3.md:624
msgid ""
"One simple definition of `length` is \"the empty list has length 0, and any "
"other list has a length which is one more than the length of the rest of the "
"list (after the first element).\"\n"
"This translates directly into a recursive function:"
msgstr ""
"Одно из простых определений `length` таково:\" пустой список имеет длину 0, "
"а любой другой список имеет длину, которая на единицу больше длины "
"остатка(rest) списка (после первого элемента).\"\n"
"Оно переводится непосредственно в рекурсивную функцию:"

#: in/chapter3.md:631
msgid ""
"```lisp\n"
"(defun length9 (list)\n"
"  (if (null list)\n"
"      0\n"
"      (+ 1 (length9 (rest list)))))\n"
"```"
msgstr ""

#: in/chapter3.md:642
msgid ""
"This version of `length` arises naturally from the recursive definition of a "
"list: \"a list is either the empty list or an element `cons`ed onto another "
"list.\"\n"
"In general, most recursive functions derive from the recursive nature of the "
"data they are operating on.\n"
"Some kinds of data, like binary trees, are hard to deal with in anything but "
"a recursive fashion.\n"
"Others, like lists and integers, can be defined either recursively (leading "
"to recursive functions) or as a sequence (leading to iterative functions).\n"
"In this book, I tend to use the \"list-as-sequence\" view rather than the "
"\"list-as-first-and-rest\" view.\n"
"The reason is that defining a list as a first and a rest is an arbitrary and "
"artificial distinction that is based on the implementation of lists that "
"Lisp happens to use.\n"
"But there are many other ways to decompose a list.\n"
"We could break it into the last element and all-but-the-last elements, for "
"example, or the first half and the second half.\n"
"The \"list-as-sequence\" view makes no such artificial distinction.\n"
"It treats all elements identically."
msgstr ""
"Эта версия `length` естественным образом возникает из рекурсивного "
"определения списка: \"список-это либо пустой список, либо элемент, `cons`-"
"ед(присоединенный) к другому списку.\"\n"
"В общем, большинство рекурсивных функций вытекают из рекурсивной природы "
"данных, с которыми они работают.\n"
"Некоторые виды данных, такие как бинарные деревья, трудно обрабатывать "
"иначе, чем рекурсивно.\n"
"Другие, такие как списки и целые числа, могут быть определены либо "
"рекурсивно (приводя к рекурсивным функциям), либо как последовательность "
"(приводя к итеративным функциям).\n"
"В этой книге я склонен использовать представление \"список-как-"
"последовательность\", а не \"список-как-первый-и-остальные\".\n"
"Причина в том, что определение списка как первого и остальных-это "
"произвольное и искусственное различие, основанное на реализации списков, "
"которые Лисп случайно использует.\n"
"Но есть много других способов разложить список.\n"
"Мы могли бы разбить его на последний элемент и все-кроме-последних "
"элементов, например, или на первую половину и вторую половину.\n"
"Представление \"список как последовательность\" не делает такого "
"искусственного различия.\n"
"Оно относится ко всем элементам одинаково."

#: in/chapter3.md:646
msgid ""
"One objection to the use of recursive functions is that they are "
"inefficient, because the compiler has to allocate memory for each recursive "
"call.\n"
"This may be true for the function `length9`, but it is not necessarily true "
"for all recursive calls.\n"
"Consider the following definition:"
msgstr ""
"Одно из возражений против использования рекурсивных функций состоит в том, "
"что они неэффективны, поскольку компилятор должен выделять память для "
"каждого рекурсивного вызова.\n"
"Это может быть верно для функции `length9`, но это не обязательно верно для "
"всех рекурсивных вызовов.\n"
"Рассмотрим следующее определение:"

#: in/chapter3.md:650
msgid ""
"```lisp\n"
"(defun length10 (list)\n"
"  (length10-aux list 0))"
msgstr ""

#: in/chapter3.md:656
msgid ""
"(defun length10-aux (sublist len-so-far)\n"
"  (if (null sublist)\n"
"      len-so-far\n"
"      (length10-aux (rest sublist) (+ 1 len-so-far))))\n"
"```"
msgstr ""

#: in/chapter3.md:663
msgid ""
"`length10` uses `length10-aux` as an auxiliary function, passing it 0 as the "
"length of the list so far.\n"
"`length10-aux` then goes down the list to the end, adding 1 for each "
"element.\n"
"The invariant relation is that the length of the sublist plus `len-so-far` "
"always equals the length of the original list.\n"
"Thus, when the sublist is nil, then `len-so-far` is the length of the "
"original list.\n"
"Variables like `len-so-far` that keep track of partial results are called "
"*accumulators.*\n"
"Other examples of functions that use accumulators include `flatten-all` on "
"page 329; `one-unknown` on page 237; the Prolog predicates discussed on page "
"686; and `anonymous-variables-in` on pages 400 and 433, which uses two "
"accumulators."
msgstr ""
"`length10` использует `length10-aux` в качестве вспомогательной функции, "
"передавая ей 0 в качестве длины списка вычисленной до сих пор(length of the "
"list so far, т.е. len-so-far).\n"
"`length10-aux` затем проходит вниз по списку до конца, добавляя по 1 для "
"каждого элемента.\n"
"Инвариантное отношение состоит в том, что длина подсписка плюс `len-so-far` "
"всегда равна длине исходного списка.\n"
"Таким образом, когда подсписока становиться равна nil, то `len-so-far` - это "
"длина исходного списка.\n"
"Переменные, такие как `len-so-far`, отслеживающие промежуточные результаты "
"называются *accumulators/аккумуляторы*.\n"
"Другие примеры функций, использующих аккумуляторы, включают `flatten-all` на "
"стр. 329; `one-unknown` на стр. 237; предикаты пролога, обсуждаемые на стр. "
"686; и `anonymous-variables-in` на стр. 400 и 433, которая использует два "
"аккумулятора."

#: in/chapter3.md:671
msgid ""
"The important difference between `length9` and `length10` is *when* the "
"addition is done.\n"
"In `length9`, the function calls itself, then returns, and then adds 1.\n"
"In `length10-aux`, the function adds 1, then calls itself, then returns.\n"
"There are no pending operations to do after the recursive call returns, so "
"the compiler is free to release any memory allocated for the original call "
"before making the recursive call.\n"
"`length10-aux` is called a *tail-recursive* function, because the recursive "
"call appears as the last thing the function does (the tail).\n"
"Many compilers will optimize tail-recursive calls, although not all do.\n"
"([Chapter 22](chapter22.md) treats tail-recursion in more detail, and points "
"out that Scheme compilers guarantee that tail-recursive calls will be "
"optimized.)"
msgstr ""
"Важное различие между `length9` и `length10` заключается в том, *когда* "
"выполняется сложение.\n"
"В `length9` функция вызывает саму себя, затем возвращается, а затем "
"добавляет 1.\n"
"В `length10-aux` функция добавляет 1, затем вызывает саму себя, а затем "
"возвращается.\n"
"После возврата рекурсивного вызова отложенные операции не выполняются, "
"поэтому компилятор может освободить любую память, выделенную для исходного "
"вызова, перед выполнением рекурсивного вызова.\n"
"`length10-aux` называется *tail-recursive/хвосто-рекурсивной* функцией, "
"потому что рекурсивный вызов является последним, что делает функция, т.е - "
"хвостом.\n"
"Многие компиляторы оптимизируют хвостовые рекурсивные вызовы, хотя это "
"делают не все.\n"
"([Глава 22](chapter22.md) рассматривает хвостовую рекурсию более подробно и "
"указывает, что компиляторы Scheme гарантируют, что хвостовые рекурсивные "
"вызовы будут оптимизированы.)"

#: in/chapter3.md:675
msgid ""
"Some find it ugly to introduce `length10-aux`.\n"
"For them, there are two alternatives.\n"
"First, we could combine `length10` and `length10-aux` into a single function "
"with an optional parameter:"
msgstr ""
"Некоторые находят уродливым введение функции `length10-aux`.\n"
"Для них есть две альтернативы.\n"
"Во-первых, мы могли бы объединить `length10` и `length10-aux` в единую "
"функцию с дополнительным параметром:"

#: in/chapter3.md:682
msgid ""
"```lisp\n"
"(defun length11 (list &optional (len-so-far 0))\n"
"  (if (null list)\n"
"      len-so-far\n"
"      (length11 (rest list) (+ 1 len-so-far))))\n"
"```"
msgstr ""

#: in/chapter3.md:685
msgid ""
"Second, we could introduce a *local* function inside the definition of the "
"main function.\n"
"This is done with the special form `labels`:"
msgstr ""
"Во-вторых, мы могли бы ввести *локальную/local* функцию внутри определения "
"главной функции.\n"
"Это делается с помощью специальной формы `labels`:"

#: in/chapter3.md:695
msgid ""
"```lisp\n"
"(defun length12 (the-list)\n"
"  (labels\n"
"    ((length13 (list len-so-far)\n"
"       (if (null list)\n"
"           len-so-far\n"
"           (length13 (rest list) (+ 1 len-so-far)))))\n"
"    (length13 the-list 0)))\n"
"```"
msgstr ""

#: in/chapter3.md:698
msgid ""
"In general, a `labels` form (or the similar `flet` form) can be used to "
"introduce one or more local functions.\n"
"It has the following syntax:"
msgstr ""
"В общем случае форма `labels` (или аналогичная форма `flet`) может быть "
"использована для введения одной или нескольких локальных функций.\n"
"Она имеет следующий синтаксис:"

#: in/chapter3.md:703
msgid ""
"```lisp\n"
"(labels ((function-name (parameter...) function-body)...)\n"
" body-of-labels)\n"
"```"
msgstr ""

#: in/chapter3.md:705
msgid "### Other Special Forms"
msgstr "### Другие Специальные Формы"

#: in/chapter3.md:709
msgid ""
"A few more special forms do not fit neatly into any category.\n"
"We have already seen the two special forms for creating constants and "
"functions, `quote` and `function.`\n"
"These are so common that they have abbreviations: `'x` for `(quote x`) and "
"`#'f` for `(function f).`"
msgstr ""
"Еще несколько специальных форм не вписываются точно ни в одну категорию.\n"
"Мы уже видели две специальные формы для создания констант и функций: `quote` "
"и `function.`\n"
"Они настолько распространены, что имеют аббревиатуры(сокращения): `'x` для "
"`(quote x`) и `#'f` для `(function f).`"

#: in/chapter3.md:711
msgid ""
"The special form `progn` can be used to evaluate a sequence of forms and "
"return the value of the last one:"
msgstr ""
"Специальная форма `progn` может быть использована для вычисления "
"последовательности форм и возврата значения последней из них:"

#: in/chapter3.md:715
msgid ""
"```lisp\n"
"(progn (setf x 0) (setf x (+ x 1)) x) => 1\n"
"```"
msgstr ""

#: in/chapter3.md:722
msgid ""
"`progn` is the equivalent of a `begin...end` block in other languages, but "
"it is used very infrequently in Lisp.\n"
"There are two reasons for this.\n"
"First, programs written in a functional style never need a sequence of "
"actions, because they don't have side effects.\n"
"Second, even when side effects are used, many special forms allow for a body "
"which is a sequence - an implicit `progn.`\n"
"I can only think of three places where a `progn` is justified.\n"
"First, to implement side effects in a branch of a two-branched conditional, "
"one could use either an `if` with a `progn,` or a `cond`:"
msgstr ""
"`progn` - это эквивалент блока `begin...end` в других языках, но он "
"используется очень редко в Lisp.\n"
"Для этого есть две причины.\n"
"Во-первых, программы, написанные в функциональном стиле, никогда не "
"нуждаются в последовательности действий, потому что они не имеют побочных "
"эффектов.\n"
"Во-вторых, даже когда используются побочные эффекты, Многие специальные "
"формы допускают тело, которое является последовательностью-неявным `progn`.\n"
"Я знаю только о трех местах, где применение   `progn`   оправдано.\n"
"Во-первых, для реализации побочных эффектов в ветви двухветвленного "
"условного обозначения можно использовать либо  `if`  с   `progn`,   либо   "
"`cond`:"

#: in/chapter3.md:729
msgid ""
"```lisp\n"
"(if (> x 100)                             (cond ((> x 100)\n"
"    (progn (print \"too big\")                     (print \"too big\")\n"
"           (setf x 100))                         (setf x 100))\n"
"    x)                                          (t x))\n"
"```"
msgstr ""

#: in/chapter3.md:732
msgid ""
"If the conditional had only one branch, then `when` or `unless` should be "
"used, since they allow an implicit `progn`.\n"
"If there are more than two branches, then `cond` should be used."
msgstr ""
"Если условие имеет только одну ветвь, то следует использовать `when` или "
"`unless`, поскольку они допускают неявный `progn`.\n"
"Если существует более двух ветвей, то следует использовать `cond`."

#: in/chapter3.md:736
msgid ""
"Second, `progn` is sometimes needed in macros that expand into more than one "
"top-level form, as in the `defun*` macro on page 326, [section 10.3]"
"(B9780080571157500108.xhtml#s0020).\n"
"Third, a progn is sometimes needed in an `unwind-protect`, an advanced "
"macro.\n"
"An example of this is the `with-resource` macro on [page 338]"
"(B9780080571157500108.xhtml#p338), [section 10.4](B9780080571157500108."
"xhtml#s0025)."
msgstr ""
"Во-вторых, `progn` иногда требуется в макросах, которые расширяются более "
"чем в одну форму верхнего уровня, как в макросе `defun*` на стр. 326, "
"[раздел 10.3](B9780080571157500108.xhtml#s0020).\n"
"В-третьих, `defun*` иногда необходим в продвинутом макросе `unwind-"
"protect`.\n"
"Примером этого является макрос `with-resource` на [стр. 338] "
"(B9780080571157500108.xhtml#p338), [раздел 10.4](B9780080571157500108."
"xhtml#s0025)."

#: in/chapter3.md:738
msgid ""
"The forms `trace` and `untrace` are used to control debugging information "
"about entry and exit to a function:"
msgstr ""
"Формы `trace` и `untrace` используются для управления отладочной информацией "
"о входе и выходе в функцию:"

#: in/chapter3.md:751
msgid ""
"```lisp\n"
"> (trace length9) => (LENGTH9)\n"
"> (length9 '(a b c))=>\n"
"(1 ENTER LENGTH9: (ABC))\n"
"  (2 ENTER LENGTH9: (B C))\n"
"    (3 ENTER LENGTH9: (C))\n"
"      (4 ENTER LENGTH9: NIL)\n"
"      (4 EXIT LENGTH9: 0)\n"
"    (3 EXIT LENGTH9: 1)\n"
"  (2 EXIT LENGTH9: 2)\n"
"(1 EXIT LENGTH9: 3)\n"
"3"
msgstr ""

#: in/chapter3.md:753
msgid "> (untrace length9) => (LENGTH9)"
msgstr ""

#: in/chapter3.md:756
msgid ""
"> (length9 '(a b c)) => 3\n"
"```"
msgstr ""

#: in/chapter3.md:762
msgid ""
"Finally, the special form `return` can be used to break out of a block of "
"code.\n"
"Blocks are set up by the special form `block`, or by the looping forms `(do, "
"do*, dolist, dotimes`, or `loop`).\n"
"For example, the following function computes the product of a list of "
"numbers, but if any number is zero, then the whole product must be zero, so "
"we immediately return zero from the `dolist` loop.\n"
"Note that this returns from the `dolist` only, not from the function itself "
"(although in this case, the value returned by `dolist` becomes the value "
"returned by the function, because it is the last expression in the "
"function).\n"
"I have used uppercase letters in `RETURN` to emphasize the fact that it is "
"an unusual step to exit from a loop."
msgstr ""
"Наконец, специальная форма `return` может быть использована для выхода из "
"блока кода.\n"
"Блоки устанавливает специальная форма `block`, или циклические формы `(do, "
"do*, dolist, dotimes` или `loop`).\n"
"Например, следующая функция вычисляет произведение списка чисел, но если "
"любое число равно нулю, то все произведение должно быть равно нулю, поэтому "
"мы немедленно возвращаем ноль из цикла `dolist`.\n"
"Обратите внимание, что она возвращается только из `dolist`, а не из самой "
"функции (хотя в этом случае значение, возвращаемое `dolist`, становится "
"значением, возвращаемым функцией, потому что это последнее выражение в "
"функции).\n"
"Я использовал прописные буквы в `RETURN`, чтобы подчеркнуть тот факт, что "
"это необычный шаг для выхода из цикла."

#: in/chapter3.md:772
msgid ""
"```lisp\n"
"(defun product (numbers)\n"
"  \"Multiply all the numbers together to compute their product.\"\n"
"  (let ((prod 1))\n"
"    (dolist (n numbers prod)\n"
"      (if (= n 0)\n"
"          (RETURN 0)\n"
"          (setf prod (* n prod))))))\n"
"```"
msgstr ""

#: in/chapter3.md:774
msgid "### Macros"
msgstr "### Макросы"

#: in/chapter3.md:779
msgid ""
"The preceding discussion has been somewhat cavalier with the term \"special "
"form.\"\n"
"Actually, some of these special forms are really *macros*, forms that the "
"compiler expands into some other code.\n"
"Common Lisp provides a number of built-in macros and allows the user to "
"extend the language by defining new macros.\n"
"(There is no way for the user to define new special forms, however.)"
msgstr ""
"Предыдущее обсуждение было несколько бесцеремонным с термином \"особая/"
"специальная форма\".\n"
"На самом деле некоторые из этих специальных форм на самом деле являются "
"*макросами*, формами, которые компилятор расширяет в какой-то другой код.\n"
"Common Lisp предоставляет ряд встроенных макросов и позволяет пользователю "
"расширять язык, определяя новые макросы.\n"
"(Однако пользователь не может определить новые специальные формы.)"

#: in/chapter3.md:783
msgid ""
"Macros are defined with the special form `defmacro`.\n"
"Suppose we wanted to define a macro, `while`, that would act like the "
"`while` loop statement of Pascal.\n"
"Writing a macro is a four-step process:"
msgstr ""
"Макросы определяются с помощью специальной формы `defmacro`.\n"
"Предположим, мы хотим определить макрос `while`, который будет действовать "
"как оператор цикла `while` в Pascal.\n"
"Написание макроса - это четырехэтапный процесс:"

#: in/chapter3.md:788
msgid ""
"* Decide if the macro is really necessary.\n"
"* Write down the syntax of the macro.\n"
"* Figure out what the macro should expand into.\n"
"* Use `defmacro` to implement the syntax/expansion correspondence."
msgstr ""
"* Решите, действительно ли макрос необходим.\n"
"* Запишите синтаксис макроса.\n"
"* Определите, во что должен расширяться макрос.\n"
"* Используйте `defmacro` для реализации соответствия синтаксиса/расширения."

#: in/chapter3.md:795
msgid ""
"The first step in writing a macro is to recognize that every time you write "
"one, you are defining a new language that is just like Lisp except for your "
"new macro.\n"
"The programmer who thinks that way will rightfully be extremely frugal in "
"defining macros.\n"
"(Besides, when someone asks, \"What did you get done today?\" it sounds more "
"impressive to say \"I defined a new language and wrote a compiler for it\" "
"than to say \"I just hacked up a couple of macros.\")\n"
"Introducing a macro puts much more memory strain on the reader of your "
"program than does introducing a function, variable or data type, so it "
"should not be taken lightly.\n"
"Introduce macros only when there is a clear need, and when the macro fits in "
"well with your existing system.\n"
"As C.A.R. Hoare put it, \"One thing the language designer should not do is "
"to include untried ideas of his own.\""
msgstr ""
"Первый шаг при написании макроса заключается в том, чтобы признать, что "
"каждый раз, когда вы пишете его, вы определяете новый язык, который похож на "
"Lisp, за исключением вашего нового макроса.\n"
"Программист, который так думает, по праву будет крайне скуп в определении "
"макросов.\n"
"(Кроме того, когда кто-то спрашивает: \"Что ты сегодня сделал?\" это звучит "
"более впечатляюще, чтобы сказать: \"я определил новый язык и написал "
"компилятор для него\", чем сказать: \"я только что написал пару макросов."
"\")\n"
"Введение макроса накладывает гораздо большую нагрузку на память читателя "
"вашей программы, чем введение функции, переменной или типа данных, поэтому "
"его не следует воспринимать легкомысленно.\n"
"Вводите макросы только тогда, когда есть явная необходимость, и когда макрос "
"хорошо вписывается в существующую систему.\n"
"Как выразился К. А. Р. Хоар, \"одна вещь, которую не должен делать языковой "
"дизайнер, - это включать в него свои собственные неопробованные идеи.\""

#: in/chapter3.md:801
msgid ""
"The next step is to decide what code the macro should expand into.\n"
"It is a good idea to follow established Lisp conventions for macro syntax "
"whenever possible.\n"
"Look at the looping macros `(dolist, dotimes, do-symbols),` the defining "
"macros `(defun, defvar, defparameter, defstruct),` or the I/O macros `(with-"
"open-file`, `with-open-stream`, `with-input-from-string)`, for example.\n"
"If you follow the naming and syntax conventions for one of these instead of "
"inventing your own conventions, you'll be doing the reader of your program a "
"favor.\n"
"For `while,` a good syntax is:"
msgstr ""
"Следующий шаг - решить, в какой код должен расширяться макрос.\n"
"Хорошей идеей будет, следование установленным соглашениям Lisp для "
"синтаксиса макросов, когда это возможно.\n"
"Для примера, посмотрите на макросы циклов `(dolist, dotimes, do-symbols),` "
"определяющих макросов `(defun, defvar, defparameter, defstruct),` или "
"макросов ввода/вывода `(with-open-file`, `with-open-stream`, `with-input-"
"from-string)`.\n"
"Если вы будете следовать правилам именования и синтаксиса для одного из них "
"вместо того, чтобы изобретать свои собственные правила, вы окажете услугу "
"читателю вашей программы.\n"
"Для `while`, хороший синтаксис - это:"

#: in/chapter3.md:803
msgid "> `(while` *test body...*)"
msgstr ""

#: in/chapter3.md:805
msgid ""
"The third step is to write the code that you want a macro call to expand "
"into:"
msgstr ""
"Третий шаг - написать код, в который вы хотите развернуть вызов макроса:"

#: in/chapter3.md:811
msgid ""
"```lisp\n"
"loop\n"
"  unless test (return nil))\n"
"  body\n"
"```"
msgstr ""

#: in/chapter3.md:816
msgid ""
"The final step is to write the definition of the macro, using `defmacro`.\n"
"A `defmacro` form is similar to a `defun` in that it has a parameter list, "
"optional documentation string, and body.\n"
"There are a few differences in what is allowed in the parameter list, which "
"will be covered later.\n"
"Here is a definition of the macro `while`, which takes a test and a body, "
"and builds up the `loop` code shown previously:"
msgstr ""
"Последний шаг - написать определение макроса, используя `defmacro`.\n"
"Форма `defmacro` похожа на форму `defun` в том смысле, что она содержит "
"список параметров, необязательную строку документации и тело.\n"
"Есть несколько различий в том, что разрешено в списке параметров, которые "
"будут рассмотрены позже.\n"
"Вот определение макроса `while`, который принимает тест(test) и тело(body) и "
"строит код `цикла/loop`, показанный ранее:"

#: in/chapter3.md:824
msgid ""
"```lisp\n"
"(defmacro while (test &rest body)\n"
"  \"Repeat body while test is true.\"\n"
"  (list* 'loop\n"
"         (list 'unless test '(return nil))\n"
"         body))\n"
"```"
msgstr ""

#: in/chapter3.md:827
msgid ""
"(The function `list*` is like `list`, except that the last argument is "
"appended onto the end of the list of the other arguments.)\n"
"We can see what this macro expands into by using `macroexpand`, and see how "
"it runs by typing in an example:"
msgstr ""
"(Функция `list*` похожа на `list`, за исключением того, что последний "
"аргумент добавляется в конец списка других аргументов.)\n"
"Мы можем увидеть, во что расширяется этот макрос, используя `macroexpand`, и "
"посмотреть, как он работает, набрав пример:"

#: in/chapter3.md:844
msgid ""
"```lisp\n"
"> (macroexpand-1 '(while (< i 10)\n"
"                   (print (* i i))\n"
"                   (setf i (+ i 1))))=>\n"
"(LOOP (UNLESS (< I 10) (RETURN NIL))\n"
"      (PRINT (* I I))\n"
"      (SETF I (+ I 1)))\n"
"> (setf i 7) =>7\n"
"> (while (< i 10)\n"
"    (print (* i i))\n"
"    (setf i (+ i 1)))\n"
"49\n"
"64\n"
"81\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter3.md:846
msgid ""
"[Section 24.6](B9780080571157500248.xhtml) (page 853) describes a more "
"complicated macro and some details on the pitfalls of writing complicated "
"macros (page 855)."
msgstr ""
"[Раздел 24.6] (B9780080571157500248.xhtml) (стр. 853) описывает более "
"сложный макрос и некоторые подробности о подводных камнях написания сложных "
"макросов (стр. 855)."

#: in/chapter3.md:848
msgid "### Backquote Notation"
msgstr "### Нотация Обратной Кавычки(Backquote)"

#: in/chapter3.md:854
msgid ""
"The hardest part about defining `while` is building the code that is the "
"expansion of the macro.\n"
"It would be nice if there was a more immediate way of building code.\n"
"The following version of `while` following attempts to do just that.\n"
"It defines the local variable `code` to be a template for the code we want, "
"and then substitutes the real values of the variables test and body for the "
"placeholders in the code.\n"
"This is done with the function `subst`; (`subst` *new old tree*) substitutes "
"*new* for each occurrence of *old* anywhere within *tree.*"
msgstr ""
"Самое сложное в определении `while` - это построение кода, который является "
"расширением макроса.\n"
"Было бы неплохо, если бы существовал более непосредственный способ "
"построения кода.\n"
"Следующая версия `while` предпринимает попытку сделать именно это.\n"
"Она определяет локальную переменную `code` как шаблон для кода, который мы "
"хотим получить, а затем подставляет реальные значения переменных test и body "
"в заполнители в переменной `code`.\n"
"Это делается с помощью функции `subst`; (`subst` *new old tree*) заменяет на "
"*new* каждое вхождение *old* в любом месте внутри *tree.*"

#: in/chapter3.md:861
msgid ""
"```lisp\n"
"(defmacro while (test &rest body)\n"
"  \"Repeat body while test is true.\"\n"
"  (let ((code '(loop (unless test (return nil)) . body)))\n"
"    (subst test 'test (subst body 'body code))))\n"
"```"
msgstr ""

#: in/chapter3.md:868
msgid ""
"The need to build up code (and noncode data) from components is so frequent "
"that there is a special notation for it, the *backquote* notation.\n"
"The backquote character ``\"`\"`` is similar to the quote character `"
"\"'\"`.\n"
"A backquote indicates that what follows is *mostly* a literal expression but "
"may contain some components that are to be evaluated.\n"
"Anything marked by a leading comma `\",\"` is evaluated and inserted into "
"the structure, and anything marked with a leading `\",@\"` must evaluate to "
"a list that is spliced into the structure: each element of the list is "
"inserted, without the top-level parentheses.\n"
"The notation is covered in more detail in [section 23.5]"
"(B9780080571157500236.xhtml#s0030).\n"
"Here we use the combination of backquote and comma to rewrite `while`:"
msgstr ""
"Необходимость создавать код (и некодовые данные) из компонентов настолько "
"часта, что для этого существует специальная нотация(форма записи) - нотация "
"обратной кавычки(*backquote*).\n"
"Символ обратной кавычки ``\"`\"`` аналогичен символу кавычки ``\"'\"``.\n"
"Обратная кавычка указывает на то, что нижеследующее является *в основном* "
"буквальным выражением(не требующем вычисления), но может содержать некоторые "
"компоненты, которые должны быть вычислены.\n"
"Все, что помечено ведущей запятой `\",\"`, вычисляется и вставляется в "
"структуру, а все, что помечено ведущей запятой с собакой `\",@\"`, должно "
"вычисляться в список, который сращивается со структурой: т.е. каждый элемент "
"списка вставляется без скобок верхнего уровня.\n"
"Более подробно эта нотация описана в [разделе 23.5] (B9780080571157500236."
"xhtml#s0030).\n"
"Здесь мы используем комбинацию обратной кавычки и запятой, чтобы переписать "
"`while`:"

#: in/chapter3.md:875
msgid ""
"```lisp\n"
"(defmacro while (test &rest body)\n"
"  \"Repeat body while test is true.\"\n"
"  `(loop (unless ,test (return nil))\n"
"         ,@body))\n"
"```"
msgstr ""

#: in/chapter3.md:879
msgid ""
"Here are some more examples of backquote.\n"
"Note that at the end of a list, `\",@\"` has the same effect as `\".\"` "
"followed by `\",\"`.\n"
"In the middle of a list, only `\",@\"`is a possibility."
msgstr ""
"Вот еще несколько примеров использовавния обратной кавычки.\n"
"Обратите внимание, что в конце списка `\",@\"` имеет тот же эффект, что и `"
"\".\"` - с последующей за \n"
"ним запятой - `\",\"`.\n"
"В середине списка возможно только `\",@\"`."

#: in/chapter3.md:882
msgid ""
"```lisp\n"
"> (setf test1 '(a test)) => (A TEST)"
msgstr ""

#: in/chapter3.md:884
msgid "> `(this is ,test1) => (THIS IS (A TEST))"
msgstr "> `(this is ,test1) => (THIS IS (A TEST))"

#: in/chapter3.md:886
msgid "> `(this is ,@test1) => (THIS IS A TEST)"
msgstr "> `(this is ,@ test1) => (THIS IS A TEST)"

#: in/chapter3.md:888
msgid "> `(this is . ,test1) => (THIS IS A TEST)"
msgstr "> `(this is . ,test1) => (THIS IS A TEST)"

#: in/chapter3.md:892
msgid ""
"> `(this is ,@test1 -- this is only ,@test1) =>\n"
"(THIS IS A TEST -- THIS IS ONLY A TEST)\n"
"```"
msgstr ""
"> `(this is ,@ test1 -- this is only ,@ test1) =>\n"
"(THIS IS A TEST -- THIS IS ONLY A TEST)\n"
"```"

#: in/chapter3.md:895
msgid ""
"This completes the section on special forms and macros.\n"
"The remaining sections of this chapter give an overview of the important "
"built-in functions in Common Lisp."
msgstr ""
"На этом завершается раздел о специальных формах и макросах.\n"
"В остальных разделах этой главы дается обзор важных функций встроенных в "
"Common Lisp."

#: in/chapter3.md:897
msgid "## 3.3 Functions on Lists"
msgstr "## 3.3 Функции работающие со списками"

#: in/chapter3.md:899
msgid "For the sake of example, assume we have the following assignments:"
msgstr ""
"Для примера предположим, что у нас есть следующие присвоения переменным:"

#: in/chapter3.md:904
msgctxt "in/chapter3.md:904"
msgid ""
"```lisp\n"
"(setf x '(a b c))\n"
"(setf y '(1 2 3))\n"
"```"
msgstr ""

#: in/chapter3.md:907
msgid ""
"The most important functions on lists are summarized here.\n"
"The more complicated ones are explained more thoroughly when they are used."
msgstr ""
"Здесь собраны наиболее важные функции работы со списками.\n"
"Более сложные из них объясняются более подробно, когда они будут "
"использоваться."

#: in/chapter3.md:934
msgid ""
"| []()             |                        "
"|                                                |\n"
"|------------------|------------------------|------------------------------------------------|\n"
"| `(first x)`      | => `a`                 | first element of a "
"list                        |\n"
"| `(second x)`     | => `b`                 | second element of a "
"list                       |\n"
"| `(third x)`      | => `c`                 | third element of a "
"list                        |\n"
"| `(nth 0 x)`      | => `a`                 | nth element of a list, `0`-"
"based               |\n"
"| `(rest x)`       | => `(b c)`             | all but the first "
"element                      |\n"
"| `(car x)`        | => `a`                 | another name for the first "
"element of a list   |\n"
"| `(cdr x)`        | => `(b c)`             | another name for all but the "
"first element     |\n"
"| `(last x)`       | => `(c)`               | last cons cell in a "
"list                       |\n"
"| `(length x)`     | => 3                   | number of elements in a "
"list                   |\n"
"| `(reverse x)`    | => `(c b a)`           | puts list in reverse "
"order                     |\n"
"| `(cons 0 y)`     | => `(0 1 2 3)`         | add to front of "
"list                           |\n"
"| `(append x y)`   | => `(a b c 1 2 3)`     | append together "
"elements                       |\n"
"| `(list x y)`     | => `((a b c) (1 2 3))` | make a new "
"list                                |\n"
"| `(list* 1 2 x)`  | => `(1 2 a b c)`       | append last argument to "
"others                 |\n"
"| `(null nil)`     | => `T`                 | predicate is true of the empty "
"list            |\n"
"| `(null x)`       | => `nil`               | ... and false for everything "
"else              |\n"
"| `(listp x)`      | => `T`                 | predicate is true of any list, "
"including `nil` |\n"
"| `(listp 3)`      | => `nil`               | ... and is false for "
"nonlists                  |\n"
"| `(consp x)`      | => `t`                 | predicate is true of non-nil "
"lists             |\n"
"| `(consp nil)`    | => `nil`               | ... and false for atoms, "
"including `nil`       |\n"
"| `(equal x x)`    | => `t`                 | true for lists that look the "
"same              |\n"
"| `(equal x y)`    | => `nil`                  | ... and false for lists "
"that look different    |\n"
"| `(sort y #'>)`   | => `(3 2 1)`           | sort a list according to a "
"comparison function |\n"
"| `(subseq x 1 2)` | => `(B)`               | subsequence with given start "
"and end points    |"
msgstr ""
"| []()             |                        "
"|                                                |\n"
"|------------------|------------------------|------------------------------------------------|\n"
"| `(first x)`      | => `a`                 | первый элемент "
"списка                          |\n"
"| `(second x)`     | => `b`                 | второй элемент "
"списка                          |\n"
"| `(third x)`      | => `c`                 | третий элемент "
"списка                          |\n"
"| `(nth 0 x)`      | => `a`                 | n-ый элемент списка, начиная с "
"`0`             |\n"
"| `(rest x)`       | => `(b c)`             | все, кроме первого "
"элемента                    |\n"
"| `(car x)`        | => `a`                 | другое имя для получения "
"первого элемента списка\n"
"| `(cdr x)`        | => `(b c)`             | другое имя для получения, всех "
"кроме первого   |\n"
"| `(last x)`       | => `(c)`               | последняя cons ячейка в "
"списке                 |\n"
"| `(length x)`     | => 3                   | количество элементов в "
"списке                  |\n"
"| `(reverse x)`    | => `(c b a)`           | возвращает список в обратном "
"порядке           |\n"
"| `(cons 0 y)`     | => `(0 1 2 3)`         | добавляет элемент в начало "
"списка              |\n"
"| `(append x y)`   | => `(a b c 1 2 3)`     | соединяет элементы в один "
"список               |\n"
"| `(list x y)`     | => `((a b c) (1 2 3))` | создает новый "
"список                           |\n"
"| `(list* 1 2 x)`  | => `(1 2 a b c)`       | создает новый список добавляя "
"последний аргумент к другим|\n"
"| `(null nil)`     | => `T`                 | предикат возвращающий истину "
"если список пуст  |\n"
"| `(null x)`       | => `nil`               | ... и ложь если "
"нет                            |\n"
"| `(listp x)`      | => `T`                 | предикат возвращающий истину "
"для любого списка, включая `nil` |\n"
"| `(listp 3)`      | => `nil`               | ... и ложь если аргумент не "
"список             |\n"
"| `(consp x)`      | => `t`                 | предикат равный истине для "
"всех не nil списков |\n"
"| `(consp nil)`    | => `nil`               | ... и ложь для атомов, включая "
"`nil`           |\n"
"| `(equal x x)`    | => `t`                 | истина для списков являющихся "
"идентичными      |\n"
"| `(equal x y)`    | => `nil`               | ... и ложь для списков которые "
"разные          |\n"
"| ``(sort y #'>)``   | => `(3 2 1)`           | сортирует список используя "
"функцию сравнения   |\n"
"| `(subseq x 1 2)` | => `(B)`               | выделяет подпоследовательность "
"со стартовой точки до конечной|"

#: in/chapter3.md:940
msgid ""
"We said that (`cons` *a b*) builds a longer list by adding element *a* to "
"the front of list *b,* but what if *b* is not a list?\n"
"This is not an error; the result is an object *x* such that (`first` *x*) => "
"*a* (`rest`*x*) => *b,* and where *x* prints as (*a* . *b*).\n"
"This is known as *dotted pair* notation.\n"
"If *b* is a list, then the usual list notation is used for output rather "
"than the dotted pair notation.\n"
"But either notation can be used for input."
msgstr ""
"Мы сказали, что (`cons` *a b*) строит более длинный список, добавляя элемент "
"*a* в начало списка *b*, но что, если *b* не является списком?\n"
"Это не ошибка; результатом является объект *x* такой, что (`first` *x*) => "
"*a* (`rest` *x*) => *b* и где *x* печатается как (*a* . *b*).\n"
"Это известно как обозначение *точечной пара*.\n"
"Если *b* - это список, то для вывода используется обычная нотация списка, а "
"не нотация точечной пары.\n"
"Но для ввода можно использовать любую нотацию."

#: in/chapter3.md:948
msgid ""
"So far we have been thinking of lists as sequences, using phrases like \"a "
"list of three elements.\"\n"
"The list is a convenient abstraction, but the actual implementation of lists "
"relies on lower-level building blocks called *cons cells.*\n"
"A cons cell is a data structure with two fields: a first and a rest.\n"
"What we have been calling \"a list of three elements\" can also be seen as a "
"single cons cell, whose first field points to the first element and whose "
"rest field points to another cons cell that is a cons cell representing a "
"list of two elements.\n"
"This second cons cell has a rest field that is a third cons cell, one whose "
"rest field is nil.\n"
"All proper lists have a last cons cell whose rest field is nil.\n"
"[Figure 3.1](#f0010) shows the cons cell notation for the three-element list "
"(`one two three`), as well as for the result of (`cons 'one 'two`)."
msgstr ""
"До сих пор мы рассматривали списки как последовательности, используя фразы "
"типа \"список из трех элементов.\"\n"
"Список-это удобная абстракция, но фактическая реализация списков опирается "
"на строительные блоки более низкого уровня, называемые *cons ячейками*.\n"
"Ячейка cons - это структура данных с двумя полями: первое(first) и "
"остаток(rest).\n"
"То, что мы называем \"списком из трех элементов\", можно также рассматривать "
"как одну ячейку cons, первое поле которой указывает на первый элемент, а "
"поле rest указывает на другую ячейку cons, представляющую собой ячейку cons, "
"представляющий собой список из двух элементов.\n"
"У этой второй cons ячейки есть поле rest, которое ссылается на третью cons "
"ячейку, чьё поле rest равна nil.\n"
"Во всех списках в последней cons ячейке, поле rest равно nil.\n"
"[Рисунок 3.1] (#f0010) показывает обозначения cons ячеек для трехэлементного "
"списка (`one two three`), а также для результата (`cons 'one 'two`)."

#: in/chapter3.md:951
msgid ""
"![Figure 3.1: Cons Cell Diagrams](images/chapter3/f03-01.jpg)\n"
"**Figure 3.1: Cons Cell Diagrams**"
msgstr ""
"![Рисунок 3.1: Диаграмма Cons Ячеек](images/chapter3/f03-01.jpg)\n"
"**Рисунок 3.1: Диаграмма Cons Ячеек**"

#: in/chapter3.md:954
msgid ""
"&#9635; **Exercise 3.2 [s]** The function cons can be seen as a special case "
"of one of the other functions listed previously.\n"
"Which one?"
msgstr ""
"&#9635; **Упражнение 3.2 [s]** функцию cons можно рассматривать как частный "
"случай одной из других функций, перечисленных ранее.\n"
"Какой именно?"

#: in/chapter3.md:957
msgid ""
"&#9635; **Exercise 3.3 [m]** Write a function that will print an expression "
"in dotted pair notation.\n"
"Use the built-in function `princ` to print each component of the expression."
msgstr ""
"&#9635; **Упражнение 3.3 [m]** напишите функцию, которая выведет выражение в "
"виде нотации точечной пары.\n"
"Используйте встроенную функцию `princ` для печати каждого компонента "
"выражения."

#: in/chapter3.md:959
msgid ""
"&#9635; **Exercise 3.4 [m]** Write a function that, like the regular `print` "
"function, will print an expression in dotted pair notation when necessary "
"but will use normal list notation when possible."
msgstr ""
"&#9635; **Упражнение 3.4 [m]** напишите функцию, которая, как и обычная "
"функция `print`, будет печатать выражение в нотации точечной пары, когда это "
"необходимо, но будет использовать обычную нотацию списка, когда это возможно."

#: in/chapter3.md:961
msgid "## 3.4 Equality and Internal Representation"
msgstr "## 3.4 равенство и внутреннее представителение"

#: in/chapter3.md:966
msgid ""
"In Lisp there are five major equality predicates, because not all objects "
"are created equally equal.\n"
"The numeric equality predicate, `=`, tests if two numbers are the same.\n"
"It is an error to apply `=` to non-numbers.\n"
"The other equality predicates operate on any kind of object, but to "
"understand the difference between them, we need to understand some of the "
"internals of Lisp."
msgstr ""
"В Lisp есть пять основных предикатов равенства, потому что не все объекты "
"создаются одинаково равными.\n"
"Предикат числового равенства `=` проверяет, совпадают ли два числа.\n"
"Будет ошибкой-применять `=` к не-числам.\n"
"Другие предикаты равенства работают с любым типом объектов, но чтобы понять "
"разницу между ними, нам нужно понять некоторые внутренние элементы Lisp."

#: in/chapter3.md:973
msgid ""
"When Lisp reads a symbol in two different places, the result is guaranteed "
"to be the exact same symbol.\n"
"The Lisp system maintains a symbol table that the function read uses to map "
"between characters and symbols.\n"
"But when a list is read (or built) in two different places, the results are "
"*not* identically the same, even though the corresponding elements may be.\n"
"This is because `read` calls `cons` to build up the list, and each call to "
"`cons` returns a new cons cell.\n"
"[Figure 3.2](#f0015) shows two lists, `x` and `Y`, which are both equal to "
"(`one two`), but which are composed of different cons cells, and hence are "
"not identical.\n"
"[Figure 3.3](#f0020) shows that the expression (`rest x`) does not generate "
"new cons cells, but rather shares structure with `x`, and that the "
"expression (`cons 'zero x`) generates exactly one new cons cell, whose rest "
"is `x`."
msgstr ""
"Когда Lisp читает символ в двух разных местах, результат гарантированно "
"будет точно тем же символом.\n"
"Система Lisp поддерживает таблицу символов, которую функция read использует "
"для сопоставления между строками символьньных знаков(characters) и "
"символами(symbols).\n"
"Но когда читается список (или строится) в двух разных местах, результаты "
"*не* тождественны, даже если элементы могут быть теже самые.\n"
"Это происходит потому, что `read` вызвает `cons`, чтобы создать список, и "
"каждый вызов `cons` возвращает новую `cons` ячейку.\n"
"[Рисунок 3.2] (#f0015) показывает два списка, `x` и `Y`, которые оба "
"одинаковы (`one two`), но которые состоят из разных ячеек cons и, "
"следовательно, не идентичны.\n"
"[Рисунок 3.3] (#f0020) показывает, что выражение (`rest x`) не генерирует "
"новые ячейки cons, а скорее разделяет структуру с `x`, и что выражение "
"(`cons 'zero x`) генерирует ровно одну новую ячейку cons, rest которой равно "
"`x`."

#: in/chapter3.md:976
msgid ""
"![Figure 3.2: Equal But Nonidentical Lists](images/chapter3/f03-02.jpg)\n"
"**Figure 3.2: Equal But Nonidentical Lists**"
msgstr ""
"![Figure 3.2: Равные(Одинаковые), Но Неидентичные Списки](images/chapter3/"
"f03-02.jpg)\n"
"**Figure 3.2: Равные(Одинаковые), Но Неидентичные Списки**"

#: in/chapter3.md:979
msgid ""
"![Figure 3.3: Parts of Lists](images/chapter3/f03-03.jpg)\n"
"**Figure 3.3: Parts of Lists**"
msgstr ""
"![Figure 3.3: Части списков](images/chapter3/f03-03.jpg)\n"
"**Figure 3.3: Части списков**"

#: in/chapter3.md:990
msgid ""
"When two mathematically equal numbers are read (or computed) in two places, "
"they may or may not be the same, depending on what the designers of your "
"implementation felt was more efficient.\n"
"In most systems, two equal fixnums will be identical, but equal numbers of "
"other types will not (except possibly short floats).\n"
"Common Lisp provides four equality predicates of increasing generality.\n"
"All four begin with the letters `eq`, with more letters meaning the "
"predicate considers more objects to be equal.\n"
"The simplest predicate is `eq`, which tests for the exact same object.\n"
"Next, `eql` tests for objects that are either `eq` or are equivalent "
"numbers.\n"
"`equal` tests for objects that are either `eql` or are lists or strings with "
"`eql` elements.\n"
"Finally, `equalp` is like `equal` except it also matches upper- and "
"lowercase characters and numbers of different types.\n"
"The following table summarizes the results of applying each of the four "
"predicates to various values of *x* and *y*.\n"
"The ? value means that the result depends on your implementation: two "
"integers that are `eql` may or may not be `eq`."
msgstr ""
"Когда два математически равных числа считываются (или вычисляются) в двух "
"местах, они могут быть или не быть одинаковыми, в зависимости от того, что "
"разработчики вашей реализации считали более эффективным.\n"
"В большинстве систем два равных фиксированных числа будут идентичны, но "
"равные числа других типов не будут (за исключением, возможно, short "
"floats).\n"
"Common Lisp предоставляет четыре предиката равенства возрастающей общности.\n"
"Все четыре начинаются с букв `eq`, причем больше букв означает, что предикат "
"считает больше объектов равными.\n"
"Самый простой предикат - это `eq`, который проверяет является ли объект тем "
"же самым.\n"
"Далее `eql` тестирует объекты, которые являются либо `eq`, либо "
"эквивалентными числами.\n"
"`equal` тестирует объекты, являются ли они либо `eql`, либо списками или "
"строками с `eql` элементами.\n"
"Наконец, `equalp` похож на `equal`, за исключением того, что он также "
"считает соответствующими друг другу верхние и нижние буквы и числа разных "
"типов.\n"
"В следующей таблице приведены результаты применения каждого из четырех "
"предикатов к различным значениям *x* и *y*.\n"
"значение ? означает, что результат зависит от вашей реализации: два целых "
"числа, которые являются `eql`, могут быть или не быть `eq`."

#: in/chapter3.md:1000
msgid ""
"| *x*     | *y*     | `eq`  | `eql` | `equal` | `equalp` |\n"
"|---------|---------|-------|-------|---------|----------|\n"
"| `'X`    | `'x`    | `T`   | `T`   | `T`     | `T`      |\n"
"| `'0`    | `'0`    | `?`   | `T`   | `T`     | `T`      |\n"
"| `'(x)`  | `'(x)`  | `nil` | `nil` | `T`     | `T`      |\n"
"| `'\"xy\"` | `'\"xy\"` | `nil` | `nil` | `T`     | `T`      |\n"
"| `'\"Xy\"` | `'\"xY\"` | `nil` | `nil` | `nil`   | `T`      |\n"
"| `'0`    | `'0.0`  | `nil` | `nil` | `nil`   | `T`      |\n"
"| `'0`    | `'1`    | `nil` | `nil` | `nil`   | `nil`    |"
msgstr ""
"| *x*     | *y*     | `eq`  | `eql` | `equal` | `equalp` |\n"
"|---------|---------|-------|-------|---------|----------|\n"
"| `'X`    | `'x`    | `T`   | `T`   | `T`     | `T`      |\n"
"| `'0`    | `'0`    | `?`   | `T`   | `T`     | `T`      |\n"
"| ``'(x)``  | ``'(x)``  | `nil` | `nil` | `T`     | `T`      |\n"
"| ``'\"xy\"`` | ``'\"xy\"`` | `nil` | `nil` | `T`     | `T`      |\n"
"| ``'\"Xy\"`` | ``'\"xY\"`` | `nil` | `nil` | `nil`   | `T`      |\n"
"| `'0`    | `'0.0`  | `nil` | `nil` | `nil`   | `T`      |\n"
"| `'0`    | `'1`    | `nil` | `nil` | `nil`   | `nil`    |"

#: in/chapter3.md:1002
msgid ""
"In addition, there are specialized equality predicates such as =, `tree-"
"equal, char-equal,` and `string-equal,` which compare numbers, trees, "
"characters, and strings, respectively."
msgstr ""
"Кроме того, существуют специализированные предикаты равенства, такие как  =, "
"`tree-equal, char-equal,` и `string-equal`, которые сравнивают числа, "
"деревья, символьные знаки и строки соответственно."

#: in/chapter3.md:1004
msgid "## 3.5 Functions on Sequences"
msgstr "## 3.5 функции работы с последовательностями"

#: in/chapter3.md:1013
msgid ""
"Common Lisp is in a transitional position halfway between the Lisps of the "
"past and the Lisps of the future.\n"
"Nowhere is that more apparent than in the sequence functions.\n"
"The earliest Lisps dealt only with symbols, numbers, and lists, and provided "
"list functions like `append` and `length.`\n"
"More modern Lisps added support for vectors, strings, and other data types, "
"and introduced the term *sequence* to refer to both vectors and lists.\n"
"(A vector is a one-dimensional array.\n"
"It can be represented more compactly than a list, because there is no need "
"to store the `rest` pointers.\n"
"It is also more efficient to get at the *n*th element of a vector, because "
"there is no need to follow a chain of pointers.)\n"
"Modern Lisps also support strings that are vectors of characters, and hence "
"also a subtype of sequence."
msgstr ""
"Common Lisp находится в переходном положении на полпути между лиспами "
"прошлого и лиспами будущего.\n"
"Нигде это не проявляется так явно, как в функциях работы с "
"последовательностями.\n"
"Самые ранние Лиспы имели дело только с символами, числами и списками и "
"предоставляли функции работы со списками, такие как `append` и `length`.\n"
"Более современные Лиспы добавили поддержку векторов, строк и других типов "
"данных и ввели термин *sequence/последовательность* для обозначения как "
"векторов, так и списков.\n"
"(Вектор - это одномерный массив.\n"
"Он может быть представлен более компактно, чем список, потому что нет "
"необходимости хранить указатели `rest`.\n"
"Кроме того, более эффективно добираться до *n*-го элемента вектора, потому "
"что нет необходимости следовать цепочке указателей.)\n"
"Современные Лиспы также поддерживают строки, которые являются векторами "
"символьных знаков, а следовательно, и подтипом последовательности."

#: in/chapter3.md:1022
msgid ""
"With the new data types came the problem of naming functions that operated "
"on them.\n"
"In some cases, Common Lisp chose to extend an old function: `length` can "
"apply to vectors as well as lists.\n"
"In other cases, the old names were reserved for the list functions, and new "
"names were invented for generic sequence functions.\n"
"For example, `append` and `mapcar` only work on lists, but `concatenate` and "
"`map` work on any kind of sequence.\n"
"In still other cases, new functions were invented for specific data types.\n"
"For example, there are seven functions to pick the nth element out of a "
"sequence.\n"
"The most general is `elt`, which works on any kind of sequence, but there "
"are specific functions for lists, arrays, strings, bit vectors, simple bit "
"vectors, and simple vectors.\n"
"Confusingly, `nth` is the only one that takes the index as the first "
"argument:"
msgstr ""
"С появлением новых типов данных возникла проблема именования функций, "
"которые ими оперируют.\n"
"В некоторых случаях Common Lisp решил расширить старую функцию: `length` "
"может применяться как к векторам, так и к спискам.\n"
"В других случаях старые имена были зарезервированы для функций списка, а "
"новые имена были изобретены для общих функций последовательности.\n"
"Например, `append` и `mapcar` работают только в списках, но `concatenate` и "
"`map` работают с любой последовательностью.\n"
"В других случаях были изобретены новые функции для конкретных типов данных.\n"
"Например, существует семь функций для выбора n-го элемента из "
"последовательности.\n"
"Наиболее общей является `elt`, которая работает на любом виде "
"последовательности, но есть специальные функции для списков, массивов, "
"строк, битовых векторов, простых битовых векторов и простых векторов.\n"
"Как ни странно, `nth` - единственная из них, которая принимает индекс в "
"качестве первого аргумента:"

#: in/chapter3.md:1030
msgid ""
"* `(nth` *n list*)\n"
"* `(elt` *sequence n*)\n"
"* `(aref` *array n*)\n"
"* `(char` *string n*)\n"
"* `(bit` *bit vector n*)\n"
"* `(sbit` *simple-bit vector n*)\n"
"* `(svref` *simple-vector n*)"
msgstr ""

#: in/chapter3.md:1032
msgid ""
"The most important sequence functions are listed elsewhere in this chapter, "
"depending on their particular purpose."
msgstr ""
"Наиболее важные функции последовательности перечислены в другом месте этой "
"главы, в зависимости от их конкретного назначения."

#: in/chapter3.md:1034
msgid "## 3.6 Functions for Maintaining Tables"
msgstr "## 3.6 функции для поддержки таблиц"

#: in/chapter3.md:1043
msgid ""
"Lisp lists can be used to represent a one-dimensional sequence of objects.\n"
"Because they are so versatile, they have been put to other purposes, such as "
"representing tables of information.\n"
"The *association list* is a type of list used to implement tables.\n"
"An association list is a list of dotted pairs, where each pair consists of a "
"*key* and a *value.* Together, the list of pairs form a table: given a key, "
"we can retrieve the corresponding value from the table, or verify that there "
"is no such key stored in the table.\n"
"Here's an example for looking up the names of states by their two-letter "
"abbreviation.\n"
"The function `assoc` is used.\n"
"It returns the key/value pair (if there is one).\n"
"To get the value, we just take the `cdr` of the result returned by `assoc`."
msgstr ""
"Списки Lisp можно использовать для представления одномерной "
"последовательности объектов.\n"
"Поскольку они настолько универсальны, они были использованы для других "
"целей, таких как представления табличной информации.\n"
"*Ассоциативный список* - это тип списка, используемый для реализации "
"таблиц.\n"
"Ассоциациативный список - это список точечных пар, где каждая пара состоит "
"из *ключа/key* и *значения/value*. Вместе список пар образует таблицу: по "
"заданному ключу, мы можем получить соответствующее значение из таблицы или "
"проверить, что в таблице нет такого ключа.\n"
"Вот пример поиска названий государств по их двухбуквенной аббревиатуре.\n"
"Используется функция `assoc`.\n"
"Она возвращает пару ключ/значение (если таковая имеется).\n"
"Чтобы получить значение, мы просто берем `cdr` от результата возвращаемого "
"`assoc`."

#: in/chapter3.md:1047
msgid ""
"```lisp\n"
"(setf state-table\n"
"  '((AL . Alabama) (AK . Alaska) (AZ . Arizona) (AR . Arkansas)))"
msgstr ""

#: in/chapter3.md:1049
msgid "> (assoc 'AK state-table) => (AK . ALASKA)"
msgstr ""

#: in/chapter3.md:1051
msgid "> (cdr (assoc 'AK state-table)) => ALASKA"
msgstr ""

#: in/chapter3.md:1054
msgid ""
"> (assoc 'TX state-table) => NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1056
msgid ""
"If we want to search the table by value rather than by key, we can use "
"rassoc:"
msgstr ""
"Если мы хотим искать в таблице по значению, а не по ключу, мы можем "
"использовать rassoc:"

#: in/chapter3.md:1061
msgid ""
"```lisp\n"
"> (rassoc 'Arizona table) => (AZ . ARIZONA)\n"
"> (car (rassoc 'Arizona table)) => AZ\n"
"```"
msgstr ""

#: in/chapter3.md:1064
msgid ""
"Managing a table with `assoc` is simple, but there is one drawback: we have "
"to search through the whole list one element at a time.\n"
"If the list is very long, this may take a while."
msgstr ""
"Управлять таблицей с помощью `assoc` просто, но есть один недостаток: мы "
"должны искать по всему списку по одному элементу за раз.\n"
"Если список очень длинный, это может занять много времени."

#: in/chapter3.md:1069
msgid ""
"Another way to manage tables is with *hash tables.*\n"
"These are designed to handle large amounts of data efficiently but have a "
"degree of overhead that can make them inappropriate for small tables.\n"
"The function `gethash` works much like `get` - it takes two arguments, a key "
"and a table.\n"
"The table itself is initialized with a call to `make-hash-table` and "
"modified with a `setf` of `gethash`:"
msgstr ""
"Другой способ управления таблицами - это использование *хэш-таблиц*.\n"
"Они предназначены для эффективной обработки больших объемов данных, но имеют "
"определенную степень накладных расходов, что может сделать их неуместными "
"для небольших таблиц.\n"
"Функция `gethash` работает так же, как и `get` - она принимает два "
"аргумента, ключ и таблицу.\n"
"Сама таблица инициализируется с помощью вызова `make-hash-table` и "
"изменяется с помщью `setf` с `gethash`:"

#: in/chapter3.md:1072
msgid ""
"```lisp\n"
"(setf table (make-hash-table))"
msgstr ""

#: in/chapter3.md:1078
msgid ""
"(setf (gethash 'AL table) 'Alabama)\n"
"(setf (gethash 'AK table) 'Alaska)\n"
"(setf (gethash 'AZ table) 'Arizona)\n"
"(setf (gethash 'AR table) 'Arkansas)\n"
"```"
msgstr ""

#: in/chapter3.md:1080
msgid "Here we retrieve values from the table:"
msgstr "Здесь мы извлекаем значения из таблицы:"

#: in/chapter3.md:1085
msgid ""
"```lisp\n"
"> (gethash 'AK table) => ALASKA\n"
"> (gethash 'TX table) => NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1089
msgid ""
"The function `remhash` removes a key/value pair from a hash table, `clrhash` "
"removes all pairs, and `maphash` can be used to map over the key/value "
"pairs.\n"
"The keys to hash tables are not restricted; they can be any Lisp object.\n"
"There are many more details on the implementation of hash tables in Common "
"Lisp, and an extensive literature on their theory."
msgstr ""
"Функция `remhash` удаляет пару ключ/значение из хэш-таблицы, `clrhash` "
"удаляет все пары, а `maphash` можно использовать для отображения пар ключ/"
"значение с помощью пользовательской функции.\n"
"Ключи к хэш-таблицам не ограничены; ими может быть любой объект Lisp.\n"
"Существует еще много подробностей о реализации хэш-таблиц в Common Lisp, а "
"также обширная литература по их теории."

#: in/chapter3.md:1093
msgid ""
"A third way to represent table is with *property lists.*\n"
"A property list is a list of alternating key/value pairs.\n"
"Property lists (sometimes called p-lists or plists) and association lists "
"(sometimes called a-lists or alists) are similar:"
msgstr ""
"Третий способ представления таблицы - это использование *property lists/"
"списков свойств*.\n"
"Список свойств - это список чередующихся пар ключ/значение.\n"
"Списки свойств (иногда называемый p-lists или plists) и ассоциативные списки "
"(иногда называют a-lists или alists)) похожи:"

#: in/chapter3.md:1096
msgid ""
"> `a-list:` ((*key*<sub>1</sub> . *val*<sub>1</sub>) (*key*<sub>2</sub> . "
"*val*<sub>2</sub>) ... (*key*<sub>n</sub> . *val*<sub>n</sub>))  \n"
"> `p-list: (`*key*<sub>1</sub> *val*<sub>1</sub> *key*<sub>2</sub> "
"*val*<sub>2</sub> ... *key*<sub>n</sub> *val*<sub>n</sub>)"
msgstr ""
"> `a-list:` ((*key*<sub>1</sub> . *val*<sub>1</sub>) (*key*<sub>2</sub> . "
"*val*<sub>2</sub>) ... (*key*<sub>n</sub> . *val*<sub>n</sub>))  \n"
"> `p-list:` (*key*<sub>1</sub> *val*<sub>1</sub> *key*<sub>2</sub> "
"*val*<sub>2</sub> ... *key*<sub>n</sub> *val*<sub>n</sub>)"

#: in/chapter3.md:1106
msgid ""
"Given this representation, there is little to choose between a-lists and p-"
"lists.\n"
"They are slightly different permutations of the same information.\n"
"The difference is in how they are normally used.\n"
"Every symbol has a property list associated with it.\n"
"That means we can associate a property/value pair directly with a symbol.\n"
"Most programs use only a few different properties but have many instances of "
"property/value pairs for each property.\n"
"Thus, each symbol's p-list will likely be short.\n"
"In our example, we are only interested in one property: the state associated "
"with each abbreviation.\n"
"That means that the property lists will be very short indeed: one property "
"for each abbreviation, instead of a list of 50 pairs in the association list "
"implementation."
msgstr ""
"Учитывая это представление, различий между a-lists и p-lists немного.\n"
"Это несколько разные перестановки одной и той же информации.\n"
"Разница заключается в том, как они обычно используются.\n"
"Каждый символ имеет связанный с ним список свойств(property list).\n"
"Это означает, что мы можем связать пару свойство/значение непосредственно с "
"символом.\n"
"Большинство программ используют только несколько различных свойств, но имеют "
"множество экземпляров пар свойство/значение для каждого свойства.\n"
"Таким образом, p-list каждого символа, скорее всего, будет коротким.\n"
"В нашем примере нас интересует только одно свойство: состояние, связанное с "
"каждой аббревиатурой.\n"
"Это означает, что списки свойств будут действительно очень короткими: по "
"одному свойству для каждой аббревиатуры вместо списка из 50 пар в реализации "
"списка ассоциаций(alist)."

#: in/chapter3.md:1111
msgid ""
"Property values are retrieved with the function get, which takes two "
"arguments: the first is a symbol for which we are seeking information, and "
"the second is the property of that symbol that we are interested in.\n"
"get returns the value of that property, if one has been stored.\n"
"Property/value pairs can be stored under a symbol with a `setf` form.\n"
"A table would be built as follows:"
msgstr ""
"Значения свойств извлекаются с помощью функции get, которая принимает два "
"аргумента: первый-это символ, для которого мы ищем информацию, а второй-"
"свойство того символа, который нас интересует.\n"
"get возвращает значение этого свойства, если оно было сохранено.\n"
"Пары свойств/значений могут храниться связанные с символом  формой `setf`.\n"
"Таблица будет построена следующим образом:"

#: in/chapter3.md:1118
msgid ""
"```lisp\n"
"(setf (get 'AL 'state) 'Alabama)\n"
"(setf (get 'AK 'state) 'Alaska)\n"
"(setf (get 'AZ 'state) 'Arizona)\n"
"(setf (get 'AR 'state) 'Arkansas)\n"
"```"
msgstr ""

#: in/chapter3.md:1120
msgid "Now we can retrieve values with get:"
msgstr "Теперь мы можем получить значения с помощью get:"

#: in/chapter3.md:1125
msgid ""
"```lisp\n"
"> (get 'AK 'state) => ALASKA\n"
"> (get 'TX 'state) => NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1130
msgid ""
"This will be faster because we can go immediately from a symbol to its lone "
"property value, regardless of the number of symbols that have properties.\n"
"However, if a given symbol has more than one property, then we still have to "
"search linearly through the property list.\n"
"As Abraham Lincoln might have said, you can make some of the table lookups "
"faster some of the time, but you can't make all the table lookups faster all "
"of the time.\n"
"Notice that there is no equivalent of rassoc using property lists; if you "
"want to get from a state to its abbreviation, you could store the "
"abbreviation under a property of the state, but that would be a separate "
"`setf` form, as in:"
msgstr ""
"Это будет быстрее, потому что мы можем сразу перейти от символа к его "
"единственному значению свойства, независимо от количества символов, имеющих "
"свойства.\n"
"Однако, если данный символ имеет более одного свойства, то мы все равно "
"должны искать линейно по списку свойств.\n"
"Как сказал бы Авраам Линкольн, вы можете сделать некоторые из поисков в "
"таблице быстрее, но вы не можете навсегда сделать все поиски в таблице "
"быстрыми.\n"
"Обратите внимание, что нет эквивалента rassoc, использующего списки свойств; "
"если вы хотите перейти от состояния к его аббревиатуре, вы можете сохранить "
"аббревиатуру под свойством состояния, но это будет отдельная форма \"setf\", "
"как в:"

#: in/chapter3.md:1134
msgid ""
"```lisp\n"
"(setf (get 'Arizona 'abbrev) 'AZ)\n"
"```"
msgstr ""

#: in/chapter3.md:1137
msgid ""
"In fact, when source, property, and value are all symbols, there are quite a "
"few possibilities for how to use properties.\n"
"We could have mimicked the a-list approach, and listed all the properties "
"under a single symbol, using setf on the function `symbol-plist` (which "
"gives a symbol's complete property list):"
msgstr ""
"На самом деле, когда источник, свойство и значение являются символами, "
"существует довольно много возможностей для использования свойств.\n"
"Мы могли бы имитировать подход a-list и перечислить все свойства под одним "
"символом, используя setf в функции `symbol-plist` (которая дает полный "
"список свойств символа):"

#: in/chapter3.md:1144
msgid ""
"```lisp\n"
"(setf (symbol-plist 'state-table)\n"
"      '(AL Alabama AK Alaska AZ Arizona AR Arkansas))\n"
"> (get 'state-table 'AL) => ALASKA\n"
"> (get 'state-table 'Alaska) => NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1153
msgid ""
"Property lists have a long history in Lisp, but they are falling out of "
"favor as new alternatives such as hash tables are introduced.\n"
"There are two main reasons why property lists are avoided.\n"
"First, because symbols and their property lists are global, it is easy to "
"get conflicts when trying to put together two programs that use property "
"lists.\n"
"If two programs use the same property for different purposes, they cannot be "
"used together.\n"
"Even if two programs use *different* properties on the same symbols, they "
"will slow each other down.\n"
"Second, property lists are messy.\n"
"There is no way to remove quickly every element of a table implemented with "
"property lists.\n"
"In contrast, this can be done trivially with `clrhash` on hash tables, or by "
"setting an association list to nil."
msgstr ""
"Списки свойств(plist) имеют долгую историю в Lisp, но они попадают в "
"немилость по мере появления новых альтернатив, таких как хэш-таблицы.\n"
"Существует две основные причины, по которым избегают списков свойств.\n"
"Во-первых, поскольку символы и их списки свойств являются глобальными, легко "
"получить конфликты при попытке объединить две программы, использующие списки "
"свойств.\n"
"Если две программы используют одно и то же свойство для разных целей, они не "
"могут использоваться вместе.\n"
"Даже если две программы используют *разные* свойства для одних и тех же "
"символов, они будут замедлять друг друга.\n"
"Во-вторых, списки свойств не упорядочены.\n"
"Нет никакого способа быстро удалить каждый элемент таблицы, реализованной со "
"списками свойств.\n"
"В отличие от этого, это можно сделать тривиально с помощью \"clrhash\" в хэш-"
"таблицах или установив список ассоциаций в nil."

#: in/chapter3.md:1155
msgid "## 3.7 Functions on Trees"
msgstr "## 3.7 Функции для работы с деревьями"

#: in/chapter3.md:1159
msgid ""
"Many Common Lisp functions treat the expression `((a b) ((c)) (d e))` as a "
"sequence of three elements, but there are a few functions that treat it as a "
"tree with five non-null leaves.\n"
"The function `copy-tree` creates a copy of a tree, and `tree-equal` tests if "
"two trees are equal by traversing cons cells, but not other complex data "
"like vectors or strings.\n"
"In that respect, `tree-equal` is similar to `equal`, but `tree-equal` is "
"more powerful because it allows a `:test keyword`:"
msgstr ""
"Многие распространенные функции Lisp рассматривают выражение `((a b) ((c)) "
"(d e))` как последовательность из трех элементов, но есть несколько функций, "
"которые рассматривают её как дерево с пятью ненулевыми(non-null) листьями.\n"
"Функция `copy-tree` создает копию дерева, а `tree-equal` проверяет, равны ли "
"два дерева, проходя через cons ячейки, но не через другие сложные данные, "
"такие как векторы или строки.\n"
"В этом отношении `tree-equal` похож на `equal`, но `tree-equal` является "
"более мощным, поскольку она позволяет изменть тип теста: `:test keyword`:"

#: in/chapter3.md:1162
msgid ""
"```lisp\n"
"> (setf tree '((a b) ((c)) (d e)))"
msgstr ""

#: in/chapter3.md:1164
msgid "> (tree-equal tree (copy-tree tree)) => T"
msgstr ""

#: in/chapter3.md:1168
msgid ""
"(defun same-shape-tree (a b)\n"
"  \"Are two trees the same except for the leaves?\"\n"
"  (tree-equal a b :test #'true))"
msgstr ""

#: in/chapter3.md:1170
msgid "(defun true (&rest ignore) t)"
msgstr ""

#: in/chapter3.md:1174
msgid ""
"> (same-shape-tree tree '((1 2) ((3)) (4 5))) => T\n"
"> (same-shape-tree tree '((1 2) (3) (4 5))) => NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1176
msgid ""
"[Figure 3.4](#f0025) shows the tree `((a b) ((c)) (d e))` as a cons cell "
"diagram."
msgstr ""
"[Рис. 3.4] (#f0025) показывает дерево `((a b) ((c)) (d e))` в виде диаграммы "
"ячеек cons"

#: in/chapter3.md:1179
msgid ""
"![Figure 3.4: Cons Cell Diagram of a Tree](images/chapter3/f03-04.jpg)\n"
"**Figure 3.4: Cons Cell Diagram of a Tree**"
msgstr ""
"![Рисунок 3.4: схема cons ячеек дерева](images/chapter3/f03-04.jpg)\n"
"**Рисунок 3.4: схема cons ячеек дерева**"

#: in/chapter3.md:1184
msgid ""
"There are also two functions for substituting a new expression for an old "
"one anywhere within a tree.\n"
"`subst` substitutes a single value for another, while `sublis` takes a list "
"of substitutions in the form of an association list of (*old . new*) pairs.\n"
"Note that the order of old and new in the a-list for `sublis` is reversed "
"from the order of arguments to `subst`.\n"
"The name `sublis` is uncharacteristically short and confusing; a better name "
"would be `subst-list`."
msgstr ""
"Существуют также две функции для замены старого выражения новым в любом "
"месте дерева.\n"
"`subst` заменяет одно значение другим, в то время как `sublis` принимает "
"список замен в виде ассоциативного списка пар (*old . new*).\n"
"Обратите внимание, что порядок старого и нового в a-list для `sublis` "
"обратный, по сравнению с порядком аргументов в `subst`.\n"
"Имя `sublis` является нехарактерно коротким и запутанным; лучшем именем "
"будет `subst-list`."

#: in/chapter3.md:1187
msgid ""
"```lisp\n"
"> (subst 'new 'old '(old ((very old)))) => (NEW ((VERY NEW)))"
msgstr ""

#: in/chapter3.md:1189
msgid "> (sublis '((old . new)) '(old ((very old)))) => (NEW ((VERY NEW)))"
msgstr ""

#: in/chapter3.md:1191
msgid "> (subst 'new 'old 'old) => NEW"
msgstr ""

#: in/chapter3.md:1197
msgid ""
"(defun english->french (words)\n"
"  (sublis '((are . va) (book . libre) (friend . ami)\n"
"            (hello . bonjour) (how . comment) (my . mon)\n"
"            (red . rouge) (you . tu))\n"
"          words))"
msgstr ""

#: in/chapter3.md:1201
msgid ""
"> (english->french '(hello my friend - how are you today?)) =>\n"
"(BONJOUR MON AMI - COMMENT VA TU TODAY?)\n"
"```"
msgstr ""

#: in/chapter3.md:1203
msgid "## 3.8 Functions on Numbers"
msgstr "## 3.8 функции работы с числами"

#: in/chapter3.md:1206
msgid ""
"The most commonly used functions on numbers are listed here.\n"
"There are quite a few other numeric functions that have been omitted."
msgstr ""
"Здесь перечислены наиболее часто используемые функции для чисел.\n"
"Есть довольно много других числовых функций, которые были опущены."

#: in/chapter3.md:1225
msgid ""
"| []()           |          "
"|                                                                |\n"
"|----------------|----------|----------------------------------------------------------------|\n"
"| `(+ 4 2)`      | => `6`   | "
"add                                                            |\n"
"| `(- 4 2)`      | => `2`   | "
"subtract                                                       |\n"
"| `(* 4 2)`      | => `8`   | "
"multiply                                                       |\n"
"| `(/ 4 2)`      | => `2`   | "
"divide                                                         |\n"
"| `(> 100 99)`   | => `t`   | greater than (also `>=`, greater than or equal "
"to)             |\n"
"| `(= 100 100)`  | => `t`   | equal (also `/=`, not "
"equal)                                   |\n"
"| `(< 99 100)`   | => `t`   | less than (also `<=`, less than or equal "
"to)                   |\n"
"| `(random 100)` | `=> 42`  | random integer from 0 to "
"99                                    |\n"
"| `(expt 4 2)`   | => `16`  | exponentiation (also exp, *e<sup>x</sup>* and "
"`log`)           |\n"
"| `(sin pi)`     | => `0.0` | sine function (also `cos`, `tan,` "
"etc.)                        |\n"
"| `(asin 0)`     | => `0.0` | arcsine or sin<sup>-1</sup> function (also "
"`acos, atan`, etc.) |\n"
"| `(min 2 3 4)`  | => `2`   | minimum (also "
"`max`)                                           |\n"
"| `(abs -3)`     | => `3`   | absolute "
"value                                                 |\n"
"| `(sqrt 4)`     | => `2`   | square "
"root                                                    |\n"
"| `(round 4.1)`  | => `4`   | round off (also `truncate, floor, "
"ceiling`)                    |\n"
"| `(rem 11 5)`   | => 1     | remainder (also "
"`mod`)                                         |"
msgstr ""
"| пример         | результат| "
"расшифровка                                                    |\n"
"|----------------|----------|----------------------------------------------------------------|\n"
"| `(+ 4 2)`      | => `6`   | "
"add                                                            |\n"
"| `(- 4 2)`      | => `2`   | "
"subtract                                                       |\n"
"| `(* 4 2)`      | => `8`   | "
"multiply                                                       |\n"
"| `(/ 4 2)`      | => `2`   | "
"divide                                                         |\n"
"| `(> 100 99)`   | => `t`   | greater than (also `>=`, greater than or equal "
"to)             |\n"
"| `(= 100 100)`  | => `t`   | equal (also `/=`, not "
"equal)                                   |\n"
"| `(< 99 100)`   | => `t`   | less than (also `<=`, less than or equal "
"to)                   |\n"
"| `(random 100)` | `=> 42`  | random integer from 0 to "
"99                                    |\n"
"| `(expt 4 2)`   | => `16`  | exponentiation (also exp, *e<sup>x</sup>* and "
"`log`)           |\n"
"| `(sin pi)`     | => `0.0` | sine function (also `cos`, `tan,` "
"etc.)                        |\n"
"| `(asin 0)`     | => `0.0` | arcsine or sin<sup>-1</sup> function (also "
"`acos, atan`, etc.) |\n"
"| `(min 2 3 4)`  | => `2`   | minimum (also "
"`max`)                                           |\n"
"| `(abs -3)`     | => `3`   | absolute "
"value                                                 |\n"
"| `(sqrt 4)`     | => `2`   | square "
"root                                                    |\n"
"| `(round 4.1)`  | => `4`   | round off (also `truncate, floor, "
"ceiling`)                    |\n"
"| `(rem 11 5)`   | => 1     | remainder (also "
"`mod`)                                         |"

#: in/chapter3.md:1227
msgid "## 3.9 Functions on Sets"
msgstr "## 3.9 функции работы с множествами"

#: in/chapter3.md:1231
msgid ""
"One of the important uses of lists is to represent sets.\n"
"Common Lisp provides functions that treat lists in just that way.\n"
"For example, to see what elements the sets *r* = {*a, b, c, d*} and *s* = "
"{*c, d, e*} have in common, we could use:"
msgstr ""
"Одним из важных применений списков является представление множеств.\n"
"Common Lisp предоставляет функции, которые обрабатывают списки именно таким "
"образом.\n"
"Например, чтобы увидеть, какие общие элементы имеют множества *r* = {*a, b, "
"c, d*} и *s* = {*c, d, e*} мы могли бы использовать:"

#: in/chapter3.md:1237
msgid ""
"```lisp\n"
"> (setf r '(a b c d)) => (A B C D)\n"
"> (setf s '(c d e)) => (C D E)\n"
"> (intersection r s) => (C D)\n"
"```"
msgstr ""

#: in/chapter3.md:1241
msgid ""
"This implementation returned (`C D`) as the answer, but another might return "
"(`D C`).\n"
"They are equivalent sets, so either is valid, and your program should not "
"depend on the order of elements in the result.\n"
"Here are the main functions on sets:"
msgstr ""
"Эта реализация возвращает (`C D`) в качестве ответа, но может возвращать и в "
"другом порядке (`D C`).\n"
"Они являются эквивалентными множествами, поэтому любое из них допустимо, и "
"ваша программа не должна зависеть от порядка элементов в результате.\n"
"Вот основные функции для множеств:"

#: in/chapter3.md:1251
msgid ""
"| []()                   |                  "
"|                                               |\n"
"|------------------------|------------------|-----------------------------------------------|\n"
"| `(intersection r s)`   | => `(c d)`       | find common elements of two "
"sets              |\n"
"| `(union r s)`          | => `(a b c d e)` | find all elements in either of "
"two sets       |\n"
"| `(set-difference r s)` | => `(a b)`       | find elements in one but not "
"other set        |\n"
"| `(member 'd r)`        | => `(d)`         | check if an element is a "
"member of a set      |\n"
"| `(subsetp s r)`        | => `nil`         | see if all elements of one set "
"are in another |\n"
"| `(adjoin 'b s`)        | => `(b c d e)`   | add an element to a "
"set                       |\n"
"| `(adjoin 'c s)`        | => `(c d e)`     | ... but don't add "
"duplicates                  |"
msgstr ""
"| функция                | результат        | "
"расшифровка                                   |\n"
"|------------------------|------------------|-----------------------------------------------|\n"
"| `(intersection r s)`   | => `(c d)`       | найти общие элементы в двух "
"множествах        |\n"
"| `(union r s)`          | => `(a b c d e)` | найти все элементы имеющиеся в "
"двух множествах|\n"
"| `(set-difference r s)` | => `(a b)`       | найти элементы которых нет в "
"другом множестве |\n"
"| `(member 'd r)`        | => `(d)`         | проверить есть ли элемент в "
"множетсве         |\n"
"| `(subsetp s r)`        | => `nil`         | смотрит, все ли элементы "
"одного мн.есть в др. |\n"
"| `(adjoin 'b s`)        | => `(b c d e)`   | добавляет элемент в "
"множество                 |\n"
"| `(adjoin 'c s)`        | => `(c d e)`     | ... не не добавляет если он "
"уже есть          |"

#: in/chapter3.md:1256
msgid ""
"It is also possible to represent a set with a sequence of bits, given a "
"particular universe of discourse.\n"
"For example, if every set we are interested in must be a subset of (`a b c d "
"e`), then we can use the bit sequence 11110 to represent (`a b c d`), 00000 "
"to represent the empty set, and 11001 to represent (`a b e`).\n"
"The bit sequence can be represented in Common Lisp as a bit vector, or as an "
"integer in binary notation.\n"
"For example, (`a b e`) would be the bit vector `#*11001` or the integer 25, "
"which can also be written as `#b11001`."
msgstr ""
"Также возможно представить множество с помощью последовательности битов, "
"учитывая конкретную вселенную дискурса.\n"
"Например, если каждый интересующее нас множество должно быть подмножеством "
"(`a b c d e`), то мы можем использовать битовую последовательность 11110 для "
"представления (`a b c d`), 00000 для представления пустого множества и 11001 "
"для представления (`a b e`).\n"
"Битовая последовательность может быть представлена в Common Lisp как битовый "
"вектор или как целое число в двоичной записи.\n"
"Например, (`a b e`) будет битовым вектором `#*11001` или целым числом 25, "
"которое также можно записать как `#b11001`."

#: in/chapter3.md:1259
msgid ""
"The advantage of using bit sequences is that it takes less space to encode a "
"set, assuming a small universe.\n"
"Computation will be faster, because the computer's underlying instruction "
"set will typically process 32 elements at a time."
msgstr ""
"Преимущество использования битовых последовательностей состоит в том, что "
"для кодирования множества требуется меньше места, если предположить, что "
"Вселенная невелика.\n"
"Вычисления будут выполняться быстрее, поскольку базовый набор команд "
"компьютера обычно обрабатывает 32 элемента одновременно."

#: in/chapter3.md:1262
msgid ""
"Common Lisp provides a full complement of functions on both bit vectors and "
"integers.\n"
"The following table lists some, their correspondence to the list functions."
msgstr ""
"Common Lisp предоставляет полный набор функций как для битовых векторов, так "
"и для целых чисел.\n"
"В следующей таблице перечислены некоторые из них, их соответствие функциям "
"списка."

#: in/chapter3.md:1270
msgid ""
"| `lists`          | `integers` | `bit vectors` |\n"
"|------------------|------------|---------------|\n"
"| `intersection`   | `logand`   | `bit-and`     |\n"
"| `union`          | `logior`   | `bit-ior`     |\n"
"| `set-difference` | `logandc2` | `bit-andc2`   |\n"
"| `member`         | `logbitp`  | `bit`         |\n"
"| `length`         | `logcount` |               |"
msgstr ""

#: in/chapter3.md:1272
msgid "For example,"
msgstr "Например,"

#: in/chapter3.md:1278
msgid ""
"```lisp\n"
"(intersection '(a b c d) '(a b e)) =>  (A B)\n"
"(bit-and      #*11110    #*11001)  =>  #*11000\n"
"(logand       #b11110    #b11001)  =>  24 = #b11000\n"
"```"
msgstr ""

#: in/chapter3.md:1280
msgid "## 3.10 Destructive Functions"
msgstr "## 3.10 Разрушающие(Деструктивные) Функции"

#: in/chapter3.md:1286
msgid ""
"In mathematics, a function is something that computes an output value given "
"some input arguments.\n"
"Functions do not \"do\" anything, they just compute results.\n"
"For example, if I tell you that *x* = 4 and *y* = 5 and ask you to apply the "
"function \"plus\" to *x* and *y,* I expect you to tell me 9.\n"
"If I then ask, \"Now what is the value of *x*?\" it would be surprising if "
"*x* had changed.\n"
"In mathematics, applying an operator to *x* can have no effect on the value "
"of *x.*"
msgstr ""
"В математике функция-это то, что вычисляет выходное значение с учетом "
"некоторых входных аргументов.\n"
"Функции ничего не \"делают\", они просто вычисляют результаты.\n"
"Например, если я скажу вам, что *x* = 4 и *y* = 5, и попрошу вас применить "
"функцию \"плюс\" к *x* и *y, я ожидаю, что вы скажете мне 9.\n"
"Если я тогда спрошу: \"какова теперь величина *x*?- было бы удивительно, "
"если бы *x* изменилось.\n"
"В математике применение оператора к *x* не может иметь никакого влияния на "
"значение *X*."

#: in/chapter3.md:1293
msgid ""
"In Lisp, some functions *are* able to take effect beyond just computing the "
"result.\n"
"<a id=\"tfn03-2\"></a>\n"
"These \"functions\" are not functions in the mathematical sense,[[2]]"
"(#fn03-2) and in other languages they are known as \"procedures.\"\n"
"Of course, most of the Lisp functions *are* true mathematical functions, but "
"the few that are not can cause great problems.\n"
"They can also be quite useful in certain situations.\n"
"For both reasons, they are worth knowing about."
msgstr ""
"В Lisp некоторые функции способны давать сторонний эффект, помимо простого "
"вычисления результата.\n"
"<a id=\"tfn03-2\"></a>\n"
"Эти \"функции\" не являются функциями в математическом смысле,[[2]](#fn03-2) "
"и в других языках они известны как \"процедуры\".\n"
"Конечно, большинство функций Lisp являются истинными математическими "
"функциями, но те немногие, которые ими не являются, могут вызвать большие "
"проблемы.\n"
"Они также могут быть весьма полезны в определенных ситуациях.\n"
"По обеим причинам о них стоит знать."

#: in/chapter3.md:1295
msgid "Consider the following:"
msgstr "Рассмотрим следующее:"

#: in/chapter3.md:1301
msgid ""
"```lisp\n"
"> (setf x '(a b c)) => (A B C)\n"
"> (setf y '(1 2 3)) => (1 2 3)\n"
"> (append x y) => (A B C 1 2 3)\n"
"```"
msgstr ""

#: in/chapter3.md:1304
msgid ""
"`append` is a pure function, so after evaluating the call to `append,` we "
"can rightfully expect that `x` and `y` retain their values.\n"
"Now consider this:"
msgstr ""
"`append` - это чистая функция, поэтому после выполнения вызова `append` мы "
"можем с полным правом ожидать, что `x` и `y` сохранят свои значения.\n"
"Теперь рассмотрим это:"

#: in/chapter3.md:1310
msgid ""
"```lisp\n"
"> (nconc x y) => (A B C 1 2 3)\n"
"> x => (A B C 1 2 3)\n"
"> y => (1 2 3)\n"
"```"
msgstr ""

#: in/chapter3.md:1316
msgid ""
"The function `nconc` computes the same result as `append,` but it has the "
"side effect of altering its first argument.\n"
"It is called a *destructive* function, because it destroys existing "
"structures, replacing them with new ones.\n"
"This means that there is quite a conceptual load on the programmer who dares "
"to use `nconc`.\n"
"He or she must be aware that the first argument may be altered, and plan "
"accordingly.\n"
"This is far more complicated than the case with nondestructive functions, "
"where the programmer need worry only about the results of a function call."
msgstr ""
"Функция `nconc` вычисляет тот же результат, что и `append`, но имеет "
"побочный эффект изменения своего первого аргумента.\n"
"Она называется *деструктивной* или *разрушающей* функцией, потому что она "
"разрушает существующие структуры, заменяя их новыми.\n"
"Это означает, что существует довольно большая концептуальная нагрузка на "
"программиста, который осмеливается использовать `nconc`.\n"
"Он или она должны знать, что первый аргумент может быть изменен, и "
"планировать соответственно.\n"
"Это намного сложнее, чем в случае с неразрушающими функциями, когда "
"программисту нужно беспокоиться только о результатах вызова функции."

#: in/chapter3.md:1321
msgid ""
"The advantage of `nconc` is that it doesn't use any storage.\n"
"While `append` must make a complete copy of `x` and then have that copy end "
"with `y`, `nconc` does not need to copy anything.\n"
"Instead, it just changes the rest field of the last element of `x` to point "
"to `y.`\n"
"So use destructive functions when you need to conserve storage, but be aware "
"of the consequences."
msgstr ""
"Преимущество `nconc` заключается в том, что он не использует никакого "
"хранилища.\n"
"В то время как `append` должен сделать полную копию `x`, а затем скопировать "
"в конец `y`, `nconc` не нужно ничего копировать.\n"
"Вместо этого он просто изменяет поле rest последнего элемента `x`, чтобы "
"указать на `y`.\n"
"Поэтому используйте разрушающие функции, когда вам нужно сохранить память, "
"но помните о последствиях."

#: in/chapter3.md:1325
msgid ""
"Besides `nconc`, many of the destructive functions have names that start "
"with `n`, including `nreverse, nintersection, nunion, nset-difference`, and "
"`nsubst`.\n"
"An important exception is `delete`, which is the name used for the "
"destructive version of `remove`.\n"
"Of course, the `setf` special form can also be used to alter structures, but "
"it is the destructive functions that are most dangerous, because it is "
"easier to overlook their effects."
msgstr ""
"Помимо `nconc`, многие разрушающие функции имеют имена, начинающиеся с `n`, "
"включая `nreverse, nintersection, nunion, nset-difference` и `nsubst`.\n"
"Важным исключением является `delete`, которое является именем, используемым "
"для разрушающей версии `remove`.\n"
"Конечно, специальная форма `setf` также может быть использована для "
"изменения структур, но именно разрушающие функции наиболее опасны, потому "
"что легко не заметить их воздействие."

#: in/chapter3.md:1332
msgid ""
"&#9635; **Exercise 3.5 [h]** (Exercise in altering structure.)\n"
"Write a program that will play the role of the guesser in the game Twenty "
"Questions.\n"
"The user of the program will have in mind any type of thing.\n"
"The program will ask questions of the user, which must be answered yes or "
"no, or \"it\" when the program has guessed it.\n"
"If the program runs out of guesses, it gives up and asks the user what \"it"
"\" was.\n"
"At first the program will not play well, but each time it plays, it will "
"remember the user's replies and use them for subsequent guesses."
msgstr ""
"&#9635; **Упражнение 3.5 [h]** (упражнение на изменении структуры.)\n"
"Напишите программу, которая будет играть роль отгадчика в игре Twenty "
"Questions(20 вопросов).\n"
"Пользователь программы будет иметь в виду любой тип вещей.\n"
"Программа будет задавать вопросы пользователю, на которые необходимо "
"ответить \"да\" или \"нет\", или \"it/это\", когда программа догадается об "
"этом.\n"
"Если у программы заканчиваются догадки, она сдается и спрашивает "
"пользователя, что это было.\n"
"Сначала программа будет играть не очень хорошо, но каждый раз, когда она "
"проиграет, она будет запоминать ответы пользователя и использовать их для "
"последующих догадок."

#: in/chapter3.md:1334
msgid "## 3.11 Overview of Data Types"
msgstr "## 3.11 Обзор типов данных"

#: in/chapter3.md:1341
msgid ""
"This chapter has been organized around functions, with similar functions "
"grouped together.\n"
"But there is another way of organizing the Common Lisp world: by considering "
"the different data types.\n"
"This is useful for two reasons.\n"
"First, it gives an alternative way of seeing the variety of available "
"functionality.\n"
"Second, the data types themselves are objects in the Common Lisp language, "
"and as we shall see, there are functions that manipulate data types.\n"
"These are useful mainly for testing objects (as with the typecase macro) and "
"for making declarations."
msgstr ""
"Эта глава была организована вокруг функций, с аналогичными функциями, "
"сгруппированными вместе.\n"
"Но есть и другой способ организации мира Common Lisp: рассматривая различные "
"типы данных.\n"
"Это полезно по двум причинам.\n"
"Во-первых, это дает альтернативный способ увидеть разнообразие доступных "
"функциональных возможностей.\n"
"Во-вторых, сами типы данных являются объектами в языке Common Lisp, и, как "
"мы увидим, существуют функции, которые управляют типами данных.\n"
"Они полезны главным образом для проверки объектов (как в случае с макросом "
"typecase) и для создания объявлений."

#: in/chapter3.md:1343
msgid "Here is a table of the most commonly used data types:"
msgstr "Вот таблица наиболее часто используемых типов данных:"

#: in/chapter3.md:1365
msgid ""
"| Type         | Example        | "
"Explanation                                                |\n"
"|--------------|----------------|------------------------------------------------------------|\n"
"| `character`  | `#\\c`          | A single letter, number, or punctuation "
"mark.              |\n"
"| `number`     | `42`           | The most common numbers are floats and "
"integers.           |\n"
"| `float`      | `3.14159`      | A number with a decimal "
"point.                             |\n"
"| `integer`    | `42`           | A whole number, of either fixed or "
"indefinite size:        |\n"
"| `fixnum`     | `123`          | An integer that fits in a single word of "
"storage.          |\n"
"| `bignum`     | `123456789`    | An integer of unbounded "
"size.                              |\n"
"| `function`   | `#'sin`        | A function can be applied to an argument "
"list.             |\n"
"| `symbol`     | `sin`          | Symbols can name fns and vars, and are "
"themselves objects. |\n"
"| `null`       | `nil`          | The object `nil` is the only object of "
"type null.          |\n"
"| `keyword`    | `:key`         | Keywords are a subtype of "
"symbol.                          |\n"
"| `sequence`   | `(a b c)`      | Sequences include lists and "
"vectors.                       |\n"
"| `list`       | `(a b c)`      | A list is either a `cons` or "
"`null`.                       |\n"
"| `vector`     | `#(a b c)`     | A vector is a subtype of "
"sequence.                         |\n"
"| `cons`       | `(a b c)`      | A cons is a non-nil "
"list.                                  |\n"
"| `atom`       | `t`            | An atom is anything that is not a "
"cons.                    |\n"
"| `string`     | `\"abc\"`        | A string is a type of vector of "
"characters.                |\n"
"| `array`      | `#lA(a b c)`   | Arrays include vectors and higher-"
"dimensional arrays.      |\n"
"| `structure`  | `#S(type ...)` | Structures are defined by "
"`defstruct`.                     |\n"
"| `hash-table` | ...            | Hash tables are created by `make-hash-"
"table`.              |"
msgstr ""
"| Тип          | Пример         | "
"Объяснение                                                |\n"
"|--------------|----------------|------------------------------------------------------------|\n"
"| `character`  | `#\\c`          | Одна буква, цифра или знак "
"препинания.                     |\n"
"| `number`     | `42`           | Распростр. числа числ.с плав. точкой и "
"целые числа.        |\n"
"| `float`      | `3.14159`      | Число с десятичной "
"запятой.                                |\n"
"| `integer`    | `42`           | Целое число, фиксированного или "
"неопределенного размера:   |\n"
"| `fixnum`     | `123`          | Целое число, которое помещается в одно "
"слово памяти.       |\n"
"| `bignum`     | `123456789`    | Целое число неограниченного "
"размера.                       |\n"
"| `function`   | `#'sin`        | Функция, применимая к списку "
"аргументов.                   |\n"
"| `symbol`     | `sin`          | Символы могут быть именем fns и vars, и "
"сами явл.объектами |\n"
"| `null`       | `nil`          | Объект `nil` является единственным "
"объектом типа null.     |\n"
"| `keyword`    | `:key`         | Ключевые слова - это подтип "
"символа.                       |\n"
"| `sequence`   | `(a b c)`      | Последовательности включают в себя списки "
"и векторы.       |\n"
"| `list`       | `(a b c)`      | Список - это либо `cons` или "
"`null`.                       |\n"
"| `vector`     | `#(a b c)`     | Вектор - это подтип "
"последовательности.                    |\n"
"| `cons`       | `(a b c)`      | cons это не пустой "
"список.                                 |\n"
"| `atom`       | `t`            | atom(Атом)-это все, что не является "
"cons.                  |\n"
"| `string`     | `\"abc\"`        | Строка - это тип вектора символьных "
"знаков                 |\n"
"| `array`      | `#lA(a b c)`   | Массивы включают векторы и многомерные "
"массивы.            |\n"
"| `structure`  | `#S(type ...)` | Структуры определяются "
"`defstruct`                         |\n"
"| `hash-table` | ...            | Хэш-таблицы создаются с помощью `make-hash-"
"table`.         |"

#: in/chapter3.md:1371
msgid ""
"Almost every data type has a *recognizer predicate* - a function that "
"returns true for only elements of that type.\n"
"In general, a predicate is a function that always returns one of two values: "
"true or false.\n"
"In Lisp, the false value is `nil`, and every other value is considered true, "
"although the most common true value is `t`.\n"
"In most cases, the recognizer predicate's name is composed of the type name "
"followed by `p: characterp` recognizes characters, `numberp` recognizes "
"numbers, and so on.\n"
"For example, `(numberp 3)` returns `t` because 3 is a number, but `(numberp "
"\"x\")` returns `nil` because `\"x\"` is a string, not a number."
msgstr ""
"Почти каждый тип данных имеет *распознающий предикат* -функцию, которая "
"возвращает true только для элементов этого типа.\n"
"В общем случае предикат-это функция, которая всегда возвращает одно из двух "
"значений: true или false.\n"
"В Lisp значение false равно `nil`, а любое другое значение считается "
"истинным, хотя наиболее распространенным истинным значением является `t`.\n"
"В большинстве случаев имя распознающего предиката состоит из имени типа, за "
"которым следует `p: characterp` распознает символьные знаки, `numberp` "
"распознает числа и т. д.\n"
"Например, `(numberp 3)` возвращает `t`, потому что 3-это число, но `(numberp "
"\"x\")` возвращает `nil`, потому что `\"x\"` - это строка, а не число."

#: in/chapter3.md:1376
msgid ""
"Unfortunately, Common Lisp is not completely regular.\n"
"There are no recognizers for fixnums, bignums, sequences, and structures.\n"
"Two recognizers, `null` and `atom`, do not end in `p.` Also note that there "
"is a hyphen before the `p` in `hash-table-p,` because the type has a hyphen "
"in it.\n"
"In addition, all the recognizers generated by `defstruct` have a hyphen "
"before the `p.`"
msgstr ""
"К сожалению, язык Common Lisp не является до конца последовательным.\n"
"Нет никаких распознавателей для фиксированных чисел, больших чисел, "
"последовательностей и структур.\n"
"Два распознавателя, `null` и `atom`, не заканчиваются на `p`. Также обратите "
"внимание, что перед `p` в `hash-table-p` есть дефис, потому что имя типа "
"имеет внутри дефис.\n"
"Кроме того, все распознаватели, генерируемые `defstruct` имеют дефис перед "
"`p`."

#: in/chapter3.md:1380
msgid ""
"The function `type-of` returns the type of its argument, and `typep` tests "
"if an object is of a specified type.\n"
"The function `subtypep` tests if one type can be determined to be a subtype "
"of another.\n"
"For example:"
msgstr ""
"Функция `type-of` возвращает тип своего аргумента, а функция `typep` "
"проверяет, является ли объект заданным типом.\n"
"Функция `subtypep` проверяет, может ли один тип быть определен как подтип "
"другого.\n"
"Например:"

#: in/chapter3.md:1383
msgid ""
"```lisp\n"
"> (type-of 123) => FIXNUM"
msgstr ""

#: in/chapter3.md:1385
msgid "> (typep 123 'fixnum) => T"
msgstr ""

#: in/chapter3.md:1387
msgid "> (typep 123 'number) => T"
msgstr ""

#: in/chapter3.md:1389
msgid "> (typep 123 'integer) => T"
msgstr ""

#: in/chapter3.md:1391
msgid "> (typep 123.0 'integer) => NIL"
msgstr ""

#: in/chapter3.md:1394
msgid ""
"> (subtypep 'fixnum 'number) T\n"
"```"
msgstr ""

#: in/chapter3.md:1398
msgid ""
"The hierarchy of types is rather complicated in Common Lisp.\n"
"As the prior example shows, there are many different numeric types, and a "
"number like 123 is considered to be of type `fixnum, integer,` and `number."
"`\n"
"We will see later that it is also of type `rational` and `t.`"
msgstr ""
"Иерархия типов в Common Lisp довольно сложна.\n"
"Как показывает предыдущий пример, существует много различных числовых типов, "
"и число, подобное 123, считается типом `fixnum, integer` и `number`.\n"
"Позже мы увидим, что оно также относится к типу `rational` и `t`."

#: in/chapter3.md:1402
msgid ""
"The type hierarchy forms a graph, not just a tree.\n"
"For example, a vector is both a sequence and an array, although neither "
"array nor sequence are subtypes of each other.\n"
"Similarly, `null` is a subtype of both `symbol` and `list.`"
msgstr ""
"Иерархия типов формирует граф, а не просто дерево.\n"
"Например, вектор - это и последовательность, и массив, хотя ни массив, ни "
"последовательность не являются подтипами друг друга.\n"
"Аналогично, `null` является подтипом как `symbol`, так и `list`."

#: in/chapter3.md:1404
msgid ""
"The following table shows a number of more specialized data types that are "
"not used as often:"
msgstr ""
"В следующей таблице показан ряд более специализированных типов данных, "
"которые используются не так часто:"

#: in/chapter3.md:1419
msgid ""
"| Type           | Example               | "
"Explanation                                              |\n"
"|----------------|-----------------------|----------------------------------------------------------|\n"
"| `t`            | `42`                  | Every object is of type `t."
"`                             |\n"
"| `nil`          |                       | No object is of type "
"`nil`.                              |\n"
"| `complex`      | `#C(0 1)`             | Imaginary "
"numbers.                                       |\n"
"| `bit`          | `0`                   | Zero or "
"one.                                             |\n"
"| `rational`     | `2/3`                 | Rationals include integers and "
"ratios.                   |\n"
"| `ratio`        | `2/3`                 | Exact fractional "
"numbers.                                |\n"
"| `simple-array` | `#lA(x y)`            | An array that is not displaced or "
"adjustable.            |\n"
"| `readtable`    | `...`                 | A mapping from characters to "
"their meanings to read.     |\n"
"| `package`      | `...`                 | A collection of symbols that form "
"a module.              |\n"
"| `pathname`     | `#P\"/usr/spool/mail\"` | A file or directory "
"name.                                |\n"
"| `stream`       | `...`                 | A pointer to an open file; used "
"for reading or printing. |\n"
"| `random-state` | `...`                 | A state used as a seed by `random."
"`                      |"
msgstr ""
"| Тип            | Пример                | "
"Объяснение                                               |\n"
"|----------------|-----------------------|----------------------------------------------------------|\n"
"| `t`            | `42`                  | Каждый объект является типом "
"`t`.                        |\n"
"| `nil`          |                       | Ни один объект не имеет типа "
"`nil`.                      |\n"
"| `complex`      | `#C(0 1)`             | Мнимое "
"число.                                            |\n"
"| `bit`          | `0`                   | Ноль или "
"единица                                         |\n"
"| `rational`     | `2/3`                 | Рациональные числа включают целые "
"числа и рац.дроби      |\n"
"| `ratio`        | `2/3`                 | Точные дробные "
"числа.                                    |\n"
"| `simple-array` | `#lA(x y)`            | Массив, который не перемещается и "
"не регулируется.       |\n"
"| `readtable`    | `...`                 | Отображение строк знаков в их "
"значения для read.         |\n"
"| `package`      | `...`                 | Набор символов, содержащихся в "
"модуле                    |\n"
"| `pathname`     | `#P\"/usr/spool/mail\"` | Имя файла или "
"директории                                 |\n"
"| `stream`       | `...`                 | Указатль на открытый файл; "
"использ. для чтения или печати|\n"
"| `random-state` | `...`                 | Состояние, используемое в "
"качестве семени для `random`.  |"

#: in/chapter3.md:1423
msgid ""
"In addition, there are even more specialized types, such as `short-float`, "
"`compiled-function`, and `bit-vector`.\n"
"It is also possible to construct more exact types, such as (`vector (integer "
"0 3) 100`), which represents a vector of 100 elements, each of which is an "
"integer from 0 to 3, inclusive.\n"
"[Section 10.1](B9780080571157500108.xhtml#s0010) gives more information on "
"types and their use."
msgstr ""
"Кроме того, существуют еще более специализированные типы, такие как `short-"
"float`, `compiled-function` и `bit-vector`.\n"
"Также можно построить более точные типы, такие как (`vector (integer 0 3) "
"100`), который представляет собой вектор из 100 элементов, каждый из которых "
"является целым числом от 0 до 3 включительно.\n"
"[Раздел 10.1] (B9780080571157500108.xhtml#s0010) дает более подробную "
"информацию о типах и их использовании."

#: in/chapter3.md:1426
msgid ""
"While almost every type has a predicate, it is also true that there are "
"predicates that are not type recognizers but rather recognize some more "
"general condition.\n"
"For example, `oddp` is true only of odd integers, and `string-greaterp` is "
"true if one string is alphabetically greater than another."
msgstr ""
"Хотя почти каждый тип имеет предикат, также верно, что есть предикаты, "
"которые не являются распознавателями типов, а скорее распознают некоторые "
"более общие условия.\n"
"Например, `oddp` истинно, только для нечетных чисел, а `string-greaterp` "
"истинно, если в одна строка в алфавитном смысле больше, чем другая."

#: in/chapter3.md:1428
msgid "## 3.12 Input/Output"
msgstr "## 3.12 Ввод/Вывод"

#: in/chapter3.md:1436
msgid ""
"Input in Lisp is incredibly easy because a complete lexical and syntactic "
"parser is available to the user.\n"
"The parser is called `read`.\n"
"It is used to read and return a single Lisp expression.\n"
"If you can design your application so that it reads Lisp expressions, then "
"your input worries are over.\n"
"Note that the expression parsed by `read` need not be a legal *evaluable* "
"Lisp expression.\n"
"That is, you can read (`\"hello\" cons zzz`) just as well as (`+ 2 2`).\n"
"In cases where Lisp expressions are not adequate, the function `read-char` "
"reads a single character, and `read-line` reads everything up to the next "
"newline and returns it as a string."
msgstr ""
"Ввод в Lisp невероятно прост, потому что пользователю доступен полный "
"лексический и синтаксический парсер.\n"
"Парсер называется `read`.\n"
"Он используется для чтения и возврата одного выражения Lisp.\n"
"Если вы можете спроектировать свое приложение так, чтобы оно считывало "
"выражения Lisp, то ваши заботы о вводе данных закончатся.\n"
"Обратите внимание, что выражение, анализируемое `read`, не обязательно "
"должно быть реально *вычислимым* выражением Lisp.\n"
"То есть вы можете читать (`\"hello\" cons zzz`) так же хорошо, как и (`+ 2 "
"2`).\n"
"В тех случаях, когда выражения Lisp не годятся для ввода, функция `read-"
"char` считывает один символьный знак, а `read-line` считывает все до "
"следующей новой строки и возвращает результат в виде строки."

#: in/chapter3.md:1444
msgid ""
"To read from the terminal, the functions `read, read-char,` or `read-line` "
"(with no arguments) return an expression, a character, and a string up to "
"the end of line, respectively.\n"
"It is also possible to read from a file.\n"
"The function `open` or the macro `with-open-stream` can be used to open a "
"file and associate it with a *stream,* Lisp's name for a descriptor of an "
"input/output source.\n"
"All three read functions take three optional arguments.\n"
"The first is the stream to read from.\n"
"The second, if true, causes an error to be signaled at end of file.\n"
"If the second argument is nil, then the third argument indicates the value "
"to return at end of file."
msgstr ""
"Читая с терминала функции `read, read-char` или `read-line` (без аргументов) "
"возвращают выражение, символьный знак или строку без конца строки "
"соответственно.\n"
"Кроме того, можно читать из файла.\n"
"Функцию  `open` или макрос `with-open-stream` можно использовать для "
"открытия файла и связывания его с *stream/потоком* Lisp - именем дескриптора "
"источника ввода-вывода.\n"
"Все три функции чтения принимают три необязательных аргумента.\n"
"Первый-это поток, из которого нужно читать.\n"
"Второй, если он истинен, вызывает сообщение об ошибке в конце файла.\n"
"Если второй аргумент равен nil, то третий аргумент указывает значение, "
"возвращаемое при достижении конца файла."

#: in/chapter3.md:1455
msgid ""
"Output in Lisp is similar to output in other languages, such as C.\n"
"There are a few low-level functions to do specific kinds of output, and "
"there is a very general function to do formatted output.\n"
"The function `print` prints any object on a new line, with a space following "
"it.\n"
"`prin1` will print any object without the new line and space.\n"
"For both functions, the object is printed in a form that could be processed "
"by `read`.\n"
"For example, the string `\"hello there\"` would print as `\"hello there\".`\n"
"The function `princ` is used to print in a human-readable format.\n"
"The string in question would print as `hello there` with `princ`-the quote "
"marks are not printed.\n"
"This means that `read` cannot recover the original form; `read` would "
"interpret it as two symbols, not one string.\n"
"The function `write` accepts eleven different keyword arguments that control "
"whether it acts like `prin1` or `princ,` among other things."
msgstr ""
"Вывод в Lisp аналогичен выводу в других языках, таких как C.\n"
"Есть несколько низкоуровневых функций для выполнения определенных видов "
"вывода, и есть очень общая функция для выполнения форматированного вывода.\n"
"Функция `print` выводит любой объект с новой строки с пробелом после нее.\n"
"`prin1` будет печатать любой объект без новой строки и пробела.\n"
"Для обеих функций объект печатается в форме, которая может быть обработана с "
"помощью функции `read`.\n"
"Например, строка `\"hello there\"` будет напечатана как `\"hello there\".`\n"
"Функция `princ` используется для печати в удобочитаемом формате.\n"
"Строка, о которой идет речь, будет напечатана как `hello there` с `princ` -"
"кавычки не печатаются.\n"
"Это означает, что `read` не может восстановить исходную форму; `read` "
"интерпретирует ее как два символа, а не одну строку.\n"
"Между прочим, функция `write` принимает одиннадцать различных аргументов "
"ключевых слов, которые определяют, действительно ли он действует как `prin1` "
"и `princ`."

#: in/chapter3.md:1461
msgid ""
"The output functions also take a stream as an optional argument.\n"
"In the following, we create the file `test.text` and print two expressions "
"to it.\n"
"Then we open the file for reading, and try to read back the first "
"expression, a single character, and then two more expressions.\n"
"Note that the `read-char` returns the character `#\\G`, so the following "
"`read` reads the characters `OODBYE` and turns them into a symbol.\n"
"The final `read` hits the end of file, and so returns the specified value, "
"`eof`."
msgstr ""
"Выходные функции также принимают поток в качестве необязательного "
"аргумента.\n"
"Далее мы создадим файл `test.text` и печатаем в нем два выражения.\n"
"Затем мы открываем файл для чтения и пытаемся прочитать обратно первое "
"выражение, один символ, а затем еще два выражения.\n"
"Обратите внимание, что `read-char` возвращает символ `#\\G`, тогда как "
"последющая `read` читает символьные знаки OODBYE  и превращает их в символ.\n"
"Последнее `read` попадает в конец файла и таким образом возвращает указанное "
"значение `eof`."

#: in/chapter3.md:1467
msgid ""
"```lisp\n"
"> (with-open-file (stream \"test.text\" :direction :output)\n"
"    (print '(hello there) stream)\n"
"    (princ 'goodbye stream))=>\n"
"GOODBYE        :*and creates the file test.text"
msgstr ""

#: in/chapter3.md:1473
msgid ""
"> (with-open-file (stream \"test.text\" :direction :input)\n"
"    (list (read stream) (read-char stream) (read stream)\n"
"          (read stream nil 'eof)))=>\n"
"((HELLO THERE) #\\G OODBYE EOF)\n"
"```"
msgstr ""

#: in/chapter3.md:1476
msgid ""
"The function `terpri` stands for \"terminate print line,\" and it skips to "
"the next line.\n"
"The function `fresh-line` also skips to the next line, unless it can be "
"determined that the output is already at the start of a line."
msgstr ""
"Функция `terpri` расшифровывается как \"завершить печатаемую строку/"
"terminate print line\" и она приводит к переходу на следующую строку.\n"
"Функция `fresh-line` также переходит к следующей строке, если только не "
"будет определено, что вывод уже находится в начале строки."

#: in/chapter3.md:1484
msgid ""
"Common Lisp also provides a very general function for doing formatted "
"output, called `format.`\n"
"The first argument to `format` is always the stream to print to; use `t` to "
"print to the terminal.\n"
"The second argument is the format string.\n"
"It is printed out verbatim, except for *format directives*, which begin with "
"the character `\"~\"`.\n"
"These directives tell how to print out the remaining arguments.\n"
"Users of C's `printf` function or FORTRAN's `format` statement should be "
"familiar with this idea.\n"
"Here's an example:"
msgstr ""
"Common Lisp также предоставляет очень общую функцию для выполнения "
"форматированного вывода, называемую `format`.\n"
"Первый аргумент `format` -это всегда поток для печати; используйте `t`, "
"чтобы распечатывать на терминал.\n"
"Второй аргумент-это строка формата.\n"
"Он распечатывается дословно, за исключением *директив формата*, которые "
"начинаются с символа `\"~\"`.\n"
"Эти директивы указывают, как распечатать остальные аргументы.\n"
"Пользователи функции Cи `printf` или оператора FORTRAN `format` должны быть "
"знакомы с этой идеей.\n"
"Вот вам пример:"

#: in/chapter3.md:1490
msgid ""
"```lisp\n"
"> (format t \"hello, world\")\n"
"hello, world\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1492
msgid ""
"Things get interesting when we put in additional arguments and include "
"format directives:"
msgstr ""
"Все становится интересным, когда мы вводим дополнительные аргументы и "
"включаем директивы формата:"

#: in/chapter3.md:1498
msgid ""
"```lisp\n"
"> (format t \"~&~a plus ~s is ~f\" \"two\" \"two\" 4)\n"
"two plus \"two\" is 4.0\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1504
msgid ""
"The directive `~&` moves to a fresh line, `~a` prints the next argument as "
"`princ` would, `~s` prints the next argument as `prin1` would, and `~f` "
"prints a number in floating-point format.\n"
"If the argument is not a number, then `princ` is used.\n"
"`format` always returns nil.\n"
"There are 26 different format directives.\n"
"Here's a more complex example:"
msgstr ""
"Директива `~&` перемещает вывод на новую строку, `~a` печатает следующий "
"аргумент как `princ`, `~s` печатает следующий аргумент как `prin1`, а `~f` "
"печатает число в формате с плавающей запятой.\n"
"Если аргумент не является числом, то используется `princ`.\n"
"`format` всегда возвращает nil.\n"
"Существует 26 различных директив формата.\n"
"Вот более сложный пример:"

#: in/chapter3.md:1512
msgid ""
"```lisp\n"
"> (let ((numbers '(1 2 3 4 5)))\n"
"    (format t \"~&~{~r~^ plus ~} is ~@r\"\n"
"            numbers (apply #'+ numbers)))\n"
"one plus two plus three plus four plus five is XV\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1517
msgid ""
"The directive `~r` prints the next argument, which should be a number, in "
"English, and `~@r` prints a number as a roman numeral.\n"
"The compound directive `~{...~}` takes the next argument, which must be a "
"list, and formats each element of the list according to the format string "
"inside the braces.\n"
"Finally, the directive `~^` exits from the enclosing `~{...~}` loop if there "
"are no more arguments.\n"
"You can see that `format`, like `loop`, comprises almost an entire "
"programming language, which, also like `loop`, is not a very Lisplike "
"language."
msgstr ""
"Директива `~r` выводит следующий аргумент, который должен быть числом, на "
"английском языке, а `~@r` выводит число в виде римской цифры.\n"
"Составная директива `~{...~}` принимает следующий аргумент, который должен "
"быть списком, и форматирует каждый элемент списка в соответствии со строкой "
"формата внутри фигурных скобок.\n"
"Наконец, директива `~^` выходит из окружения цикла `~{...~}`, если больше "
"нет аргументов.\n"
"Вы можете видеть, что `format`, как и `loop`, включает в себя почти целый "
"язык программирования, который, также как и `loop`, не очень похож на "
"Лиспоподобный язык."

#: in/chapter3.md:1519
msgid "## 3.13 Debugging Tools"
msgstr "## 3.13 Инструменты отладки"

#: in/chapter3.md:1521
msgid ""
"In many languages, there are two strategies for debugging: (1) edit the "
"program to insert print statements, recompile, and try again, or (2) use a "
"debugging program to investigate (and perhaps alter) the internal state of "
"the running program."
msgstr ""
"Во многих языках существуют две стратегии отладки: (1) изменение программы, "
"вставляются инструкции print, программа перекомпилируется и повторно "
"запускается или (2) использование программы отладки для исследования (и , "
"возможно, изменения) внутреннего состояния запущенной программы."

#: in/chapter3.md:1526
msgid ""
"Common Lisp admits both these strategies, but it also offers a third: (3) "
"add annotations that are not part of the program but have the effect of "
"automatically altering the running program.\n"
"The advantage of the third strategy is that once you are done you don't have "
"to go back and undo the changes you would have introduced in the first "
"strategy.\n"
"In addition, Common Lisp provides functions that display information about "
"the program.\n"
"You need not rely solely on looking at the source code."
msgstr ""
"Common Lisp допускает обе эти стратегии, но он также предлагает третью: (3) "
"Добавление аннотаций, которые не являются частью программы, но имеют эффект "
"автоматического изменения запущенной программы.\n"
"Преимущество третьей стратегии состоит в том, что, как только вы закончите, "
"вам не придется возвращаться назад и отменять изменения, которые вы внесли "
"бы в первую стратегию.\n"
"Кроме того, Common Lisp предоставляет функции, отображающие информацию о "
"программе.\n"
"Вам не нужно полагаться только на просмотр исходного кода."

#: in/chapter3.md:1533
msgid ""
"We have already seen how `trace` and `untrace` can be used to provide "
"debugging information (page 65).\n"
"Another useful tool is `step`, which can be used to halt execution before "
"each subform is evaluated.\n"
"The form (`step` *expression*) will evaluate and return *expression*, but "
"pauses at certain points to allow the user to inspect the computation, and "
"possibly change things before proceeding to the next step.\n"
"The commands available to the user are implementation-dependent, but typing "
"a `?` should give you a list of commands.\n"
"As an example, here we step through an expression twice, the first time "
"giving commands to stop at each subevaluation, and the second time giving "
"commands to skip to the next function call.\n"
"In this implementation, the commands are control characters, so they do not "
"show up in the output."
msgstr ""
"Мы уже видели, как `trace` и `untrace` могут использоваться для "
"предоставления отладочной информации (стр. 65).\n"
"Еще одним полезным инструментом является `step`, который может быть "
"использован для остановки выполнения до того, как каждая подформа будет "
"вычислена.\n"
"Форма (`step` *expression*) вычисляет и возвращает *expression/выражение*, "
"но делает паузу в определенных точках, чтобы позволить пользователю "
"проверить вычисление и, возможно, изменить чтото, прежде чем перейти к "
"следующему шагу.\n"
"Команды, доступные пользователю, зависят от реализации, но введя `?`- лисп "
"должен дать вам список команд.\n"
"Например, здесь мы проходим через выражение дважды, в первый раз давая "
"команды останавки stop при каждом подвычислении, а во второй раз давая "
"команды skip, перехода к следующему вызову функции.\n"
"В этой реализации команды являются управляющими символьными знаками, поэтому "
"они не отображаются в выходных данных."

#: in/chapter3.md:1535
msgid ""
"All output, including the symbols <= and => are printed by the stepper "
"itself; I have added no annotation."
msgstr ""
"Все выходные данные, включая символы <= и =>, печатаются самим "
"степпером(процедурой пошагового прохождения); я не добавил никаких аннотаций."

#: in/chapter3.md:1551
msgid ""
"```lisp\n"
"> (step (+ 3 4 (* 5 6 (/ 7 8))))\n"
"<= (+ 3 4 (* 5 6 (/ 7 8)))\n"
"  <= 3 => 3\n"
"  <= 4 => 4\n"
"  <= (* 5 6 (/ 7 8))\n"
"  <= 5 => 5\n"
"  <= 6 => 6\n"
"  <= (/ 7 8)\n"
"    <= 7 => 7\n"
"  <= 8 => 8\n"
"    <=(/ 7 8) => 7/8\n"
"  <= (* 5 6 (/ 7 8)) => 105/4\n"
"  <= (+ 3 4 (* 5 6 (/ 7 8))) => 133/4\n"
"133/4"
msgstr ""

#: in/chapter3.md:1560
msgid ""
"> (step (+ 3 4 (* 5 6 (/ 7 8))))\n"
"<= (+ 3 4 (* 5 6 (/ 7 8)))\n"
"  /: 7 8 => 7/8\n"
"  *: 5 6 7/8 => 105/4\n"
"  +: 3 4 105/4 => 133/4\n"
"<= (+ 3 4 (* 5 6 (/ 7 8))) => 133/4\n"
"133/4\n"
"```"
msgstr ""

#: in/chapter3.md:1563
msgid ""
"The functions `describe`, `inspect, documentation,` and `apropos` provide "
"information about the state of the current program.\n"
"`apropos` prints information about all symbols whose name matches the "
"argument:"
msgstr ""
"Функции `describe(описание)`, `inspect(проверка), "
"documentation(документация)` и `apropos(кстати)`  предоставляют информацию о "
"состоянии текущей программы.\n"
"`apropos` выводит информацию обо всех символах, имя которых совпадает с "
"аргументом:"

#: in/chapter3.md:1572
msgid ""
"```lisp\n"
"> (apropos 'string)\n"
"MAKE-STRING            function (LENGTH &KEY INITIAL-ELEMENT)\n"
"PRIN1-T0-STRING        function (OBJECT)\n"
"PRINC-T0-STRING        function (OBJECT)\n"
"STRING                 function (X)\n"
"...\n"
"```"
msgstr ""

#: in/chapter3.md:1574
msgid ""
"Once you know what object you are interested in, `describe` can give more "
"information on it:"
msgstr ""
"Как только вы узнаете, какой объект вас интересует, `describe` может дать "
"больше информации о нем:"

#: in/chapter3.md:1589
msgid ""
"```lisp\n"
"> (describe 'make-string)\n"
"Symbol MAKE-STRING is in LISP package.\n"
"The function definition is #<FUNCTION MAKE-STRING -42524322 >:\n"
"  NAME:          MAKE-STRING\n"
"  ARGLIST:       (LENGTH &KEY INITIAL-ELEMENT)\n"
"  DOCUMENTATION: \"Creates and returns a string of LENGTH elements,\n"
"all set to INITIAL-ELEMENT.\"\n"
"  DEFINITION:    (LAMBDA (LENGTH &KEY INITIAL-ELEMENT)\n"
"                   (MAKE-ARRAY LENGTH : ELEMENT-TYPE 'CHARACTER\n"
"                               :INITIAL-ELEMENT (OR INITIAL-ELEMENT\n"
"                                                    #\\SPACE)))\n"
"MAKE-STRING has property INLINE: INLINE\n"
"MAKE-STRING has property :SOURCE-FILE: #P\"SYS:KERNEL; STRINGS\""
msgstr ""

#: in/chapter3.md:1594
msgid ""
"> (describe 1234.56)\n"
"1234.56 is a single-precision floating-point number.\n"
"  Sign 0, exponent #o211, 23-bit fraction #o6450754\n"
"```"
msgstr ""

#: in/chapter3.md:1596
msgid ""
"If all you want is a symbol's documentation string, the function "
"`documentation` will do the trick:"
msgstr ""
"Если все, что вам нужно, - это строка документации символа, функция "
"`documentation` сделает свое дело:"

#: in/chapter3.md:1601
msgid ""
"```lisp\n"
"> (documentation 'first 'function) => \"Return the first element of LIST.\"\n"
"> (documentation 'pi 'variable) =$> \"pi\"\n"
"```"
msgstr ""

#: in/chapter3.md:1604
msgid ""
"If you want to look at and possibly alter components of a complex structure, "
"then `inspect` is the tool.\n"
"In some implementations it invokes a fancy, window-based browser."
msgstr ""
"Если вы хотите посмотреть и, возможно, изменить компоненты сложной "
"структуры, то `inspect` - это необходимый вам инструмент.\n"
"В некоторых реализациях он вызывает причудливый оконный браузер."

#: in/chapter3.md:1611
msgid ""
"Common Lisp also provides a debugger that is entered automatically when an "
"error is signalled, either by an inadvertant error or by deliberate action "
"on the part of the program.\n"
"The details of the debugger vary between implementations, but there are "
"standard ways of entering it.\n"
"The function `break` enters the debugger after printing an optional "
"message.\n"
"It is intended as the primary method for setting debugging break points.\n"
"`break` is intended only for debugging purposes; when a program is deemed to "
"be working, all calls to `break` should be removed.\n"
"However, it is still a good idea to check for unusual conditions with "
"`error`, `cerror`, `assert,` or `check-type`, which will be described in the "
"following section."
msgstr ""
"Common Lisp также предоставляет отладчик, вход в который поисходит "
"автоматически, когда происходит вызов сигнала об ошибке, либо при "
"непреднамеренной ошибке, либо преднамеренным действием со стороны "
"программы.\n"
"Детали отладчика различаются в разных реализациях, но существуют стандартные "
"способы входа в него.\n"
"Функция `break` входит в отладчик после печати необязательного сообщения.\n"
"Она предназначена в качестве основного метода для установки точек останова "
"отладки.\n"
"`break` предназначена только для отладки; Когда программа считается рабочей, "
"все вызовы `break` должны быть удалены.\n"
"Тем не менее, это все еще хорошая идея проверять необычные условия с помощью "
"`error`, `cerror`, `assert` или `check-type`, которые будут описаны в "
"следующем разделе."

#: in/chapter3.md:1613
msgid "## 3.14 Antibugging Tools"
msgstr "## 3.14 Инструменты для борьбы  с ошибками"

#: in/chapter3.md:1616
msgid ""
"It is a good idea to include *antibugging* checks in your code, in addition "
"to doing normal debugging.\n"
"Antibugging code checks for errors and possibly takes corrective action."
msgstr ""
"Хорошей идеей, является включение *противоошибочной* проверки в ваш код, в "
"дополнение к выполнению обычной отладке.\n"
"Противоошибочный код проверяет наличие ошибок и, возможно, принимает "
"корректирующие меры."

#: in/chapter3.md:1622
msgid ""
"The functions `error` and `cerror` are used to signal an error condition.\n"
"These are intended to remain in the program even after it has been "
"debugged.\n"
"The function `error` takes a format string and optional arguments.\n"
"It signals a fatal error; that is, it stops the program and does not offer "
"the user any way of restarting it.\n"
"For example:"
msgstr ""
"Функции `error` и `cerror` используются для сигнализации об ошибке.\n"
"Они предназначены для того, чтобы остаться в программе даже после ее "
"отладки.\n"
"Функция `error` принимает строку формата и необязательные аргументы.\n"
"Она сигнализирует о фатальной ошибке, то есть останавливает программу и не "
"предлагает пользователю никакого способа ее перезапуска.\n"
"Например:"

#: in/chapter3.md:1630
msgid ""
"```lisp\n"
"(defun average (numbers)\n"
"  (if (null numbers)\n"
"      (error \"Average of the empty list is undefined.\")\n"
"      (/ (reduce #'+ numbers)\n"
"         (length numbers))))\n"
"```"
msgstr ""

#: in/chapter3.md:1637
msgid ""
"In many cases, a fatal error is a little drastic.\n"
"The function `cerror` stands for continuable error.\n"
"`cerror` takes two format strings; the first prints a message indicating "
"what happens if we continue, and the second prints the error message "
"itself.\n"
"`cerror` does not actually take any action to repair the error, it just "
"allows the user to signal that continuing is alright.\n"
"In the following implementation, the user continues by typing `:continue`.\n"
"In ANSI Common Lisp, there are additional ways of specifying options for "
"continuing."
msgstr ""
"Во многих случаях фатальная ошибка бывает не столь радикальной.\n"
"Функция `cerror` означает продолжаемую(continuable) ошибку, т.е ошибку после "
"которой, у программы есть возможность продолжить работу.\n"
"`cerror` принимает две строки формата; первая печатает сообщение, "
"указывающее, что произойдет, если мы продолжим, а вторая печатает само "
"сообщение об ошибке.\n"
"`cerror` на самом деле не предпринимает никаких действий для исправления "
"ошибки, она просто позволяет  сигнализировать пользователю, что можно "
"продолжить выполнение.\n"
"В следующей реализации пользователь выполняет продолжение, набрав `:"
"continue`.\n"
"В ANSI Common Lisp существуют дополнительные способы указания параметров для "
"продолжения работы."

#: in/chapter3.md:1647
msgid ""
"```lisp\n"
"(defun average (numbers)\n"
"  (if (null numbers)\n"
"      (progn\n"
"        (cerror \"Use 0 as the average.\"\n"
"                \"Average of the empty list is undefined.\")\n"
"        0)\n"
"      (/ (reduce #'+ numbers)\n"
"         (length numbers))))"
msgstr ""

#: in/chapter3.md:1655
msgid ""
"> (average '())\n"
"Error: Average of the empty list is undefined.\n"
"Error signaled by function AVERAGE.\n"
"If continued: Use 0 as the average.\n"
">> :continue\n"
"0\n"
"```"
msgstr ""

#: in/chapter3.md:1663
msgid ""
"In this example, adding error checking nearly doubled the length of the "
"code.\n"
"This is not unusual; there is a big difference between code that works on "
"the expected input and code that covers all possible errors.\n"
"Common Lisp tries to make it easier to do error checking by providing a few "
"special forms.\n"
"The form `ecase` stands for \"exhaustive case\" or \"error case.\"\n"
"It is like a normal case form, except that if none of the cases are "
"satisfied, an error message is generated.\n"
"The form `ccase` stands for \"continuable case.\" It is like `ecase`, except "
"that the error is continuable.\n"
"The system will ask for a new value for the test object until the user "
"supplies one that matches one of the programmed cases."
msgstr ""
"В этом примере добавление проверки ошибок почти удвоило длину кода.\n"
"В этом нет ничего необычного; существует большая разница между кодом, "
"который работает при ожидаемом вводе, и кодом, который покрывает все "
"возможные ошибки.\n"
"Common Lisp пытается упростить проверку ошибок, предоставляя несколько "
"специальных форм.\n"
"Форма `ecase` расшифровывается как \"exhaustive case/исчерпывающий случай\" "
"или \"error case/в случае ошибки\".\n"
"Она похожа на обычную форму case, за исключением того, что если ни один из "
"вариантов не выбран, генерируется сообщение об ошибке.\n"
"Форма `ccase` расшифровывается как \"continuable case/продолжаемый случай\". "
"Он похож на `ecase`, за исключением того, что ошибка является продолжаемой.\n"
"Система будет запрашивать новое значение для тестируемого объекта до тех "
"пор, пока пользователь не предоставит то, которое соответствует одному из "
"запрограммированных случаев."

#: in/chapter3.md:1668
msgid ""
"To make it easier to include error checks without inflating the length of "
"the code too much, Common Lisp provides the special forms `check-type` and "
"`assert`.\n"
"As the name implies, `check-type` is used to check the type of an argument.\n"
"It signals a continuable error if the argument has the wrong type.\n"
"For example:"
msgstr ""
"Чтобы упростить включение проверок на ошибки без чрезмерного увеличения "
"длины кода, Common Lisp предоставляет специальные формы `check-type` и "
"`assert`.\n"
"Как следует из названия, `check-type` используется для проверки типа "
"аргумента.\n"
"Она выдает сигнал о продолжаемой ошибке, если аргумент имеет неправильный "
"тип.\n"
"Например:"

#: in/chapter3.md:1675
msgid ""
"```lisp\n"
"(defun sqr (x)\n"
"  \"Multiply x by itself.\"\n"
"  (check-type x number)\n"
"  (* x x))\n"
"```"
msgstr ""

#: in/chapter3.md:1677
msgid ""
"If `sqr` is called with a non-number argument, an appropriate error message "
"is printed:"
msgstr ""
"Если `sqr` вызывается с не числовым аргументом, то выводится соответствующее "
"сообщение об ошибке:"

#: in/chapter3.md:1685
msgid ""
"```lisp\n"
"> (sqr \"hello\")\n"
"Error: the argument X was \"hello\", which is not a NUMBER.\n"
"If continued: replace X with new value\n"
">> :continue 4\n"
"16\n"
"```"
msgstr ""

#: in/chapter3.md:1689
msgid ""
"`assert` is more general than `check-type`.\n"
"In the simplest form, assert tests an expression and signals an error if it "
"is false.\n"
"For example:"
msgstr ""
"`assert` является более общей, чем `check-type`.\n"
"В простейшей форме assert проверяет выражение и сигнализирует об ошибке, "
"если оно ложно.\n"
"Например:"

#: in/chapter3.md:1696
msgid ""
"```lisp\n"
"(defun sqr (x)\n"
"  \"Multiply x by itself.\"\n"
"  (assert (numberp x))\n"
"  (* x x))\n"
"```"
msgstr ""

#: in/chapter3.md:1700
msgid ""
"There is no possibility of continuing from this kind of assertion.\n"
"It is also possible to give `assert` a list of places that can be modified "
"in an attempt to make the assertion true.\n"
"In this example, the variable `x` is the only thing that can be changed:"
msgstr ""
"Нет никакой возможности выполнить продолжение из утверждения такого рода.\n"
"Можно также дать `assert` список мест, которые могут быть изменены в попытке "
"сделать утверждение истинным.\n"
"В этом примере переменная `x`  - это единственное, что можно изменить:"

#: in/chapter3.md:1707
msgid ""
"```lisp\n"
"(defun sqr (x)\n"
"  \"Multiply x by itself.\"\n"
"  (assert (numberp x) (x))\n"
"  (* x x))\n"
"```"
msgstr ""

#: in/chapter3.md:1710
msgid ""
"If the assertion is violated, an error message will be printed and the user "
"will be given the option of continuing by altering `x`.\n"
"If `x` is given a value that satisfies the assertion, then the program "
"continues, `assert` always returns nil."
msgstr ""
"Если утверждение нарушено, будет выведено сообщение об ошибке, и "
"пользователю будет предоставлена возможность выполнить продолжение, изменив "
"`x`.\n"
"Если `x` получает значение, удовлетворяющее утверждению, то программа может "
"быть продолжена, 'assert' всегда возвращает nil."

#: in/chapter3.md:1713
msgid ""
"Finally, the user who wants more control over the error message can provide "
"a format control string and optional arguments.\n"
"So the most complex syntax for assert is:"
msgstr ""
"Наконец, пользователь, который хочет больше контролировать сообщение об "
"ошибке, может предоставить строку управления форматом и необязательные "
"аргументы.\n"
"Таким образом, самый сложный синтаксис для assert - это:"

#: in/chapter3.md:1715
msgid "> `(assert` *test-form* (*place...*) *format-ctl-string format-arg...*)"
msgstr ""

#: in/chapter3.md:1718
msgid ""
"Here is another example.\n"
"The assertion tests that the temperature of the bear's porridge is neither "
"too hot nor too cold."
msgstr ""
"Вот еще один пример.\n"
"Утверждение( assertion) проверяет, что температура медвежьей каши не слишком "
"горячая и не слишком холодная."

#: in/chapter3.md:1727
msgid ""
"```lisp\n"
"(defun eat-porridge (bear)\n"
"  (assert (< too-cold (temperature (bear-porridge bear)) too-hot)\n"
"          (bear (bear-porridge bear))\n"
"          \"~a's porridge is not just right: ~a\"\n"
"          bear (hotness (bear-porridge bear)))\n"
"  (eat (bear-porridge bear)))\n"
"```"
msgstr ""

#: in/chapter3.md:1730
msgid ""
"In the interaction below, the assertion failed, and the programmer's error "
"message was printed, along with two possibilities for continuing.\n"
"The user selected one, typed in a call to `make-porridge` for the new value, "
"and the function successfully continued."
msgstr ""
"В приведенном ниже взаимодействии утверждение потерпело неудачу, и сообщение "
"об ошибке программиста было напечатано вместе с двумя возможностями "
"продолжения программы.\n"
"Пользователь выбрал одни, введя вызов `make-porridge` в качестве нового "
"значения, и функция успешно продолжилась."

#: in/chapter3.md:1742
msgid ""
"```lisp\n"
"> (eat-porridge momma-bear)\n"
"Error: #<MOMMA BEAR>'s porridge is not just right: 39\n"
"Restart actions (select using :continue):\n"
" 0: Supply a new value for BEAR\n"
" 1: Supply a new value for (BEAR-PORRIDGE BEAR)\n"
">> :continue 1\n"
"Form to evaluate and use to replace (BEAR-PORRIDGE BEAR):\n"
"(make-porridge :temperature just-right)\n"
"nil\n"
"```"
msgstr ""

#: in/chapter3.md:1745
msgid ""
"It may seem like wasted effort to spend time writing assertions that (if all "
"goes well) will never be used.\n"
"However, for all but the perfect programmer, bugs do occur, and the time "
"spent antibugging will more than pay for itself in saving debugging time."
msgstr ""
"Может показаться напрасным тратить время на написание "
"утверждений(assertions), которые (если все пойдет хорошо) никогда не будут "
"использованы.\n"
"Однако для всех, кроме идеального программиста, ошибки действительно "
"случаются, и время, потраченное на противоошибочный код, с лихвой окупится в "
"экономии времени при отладке."

#: in/chapter3.md:1750
msgid ""
"Whenever you develop a complex data structure, such as some kind of data "
"base, it is a good idea to develop a corresponding consistency checker.\n"
"A consistency checker is a function that will look over a data structure and "
"test for all possible errors.\n"
"When a new error is discovered, a check for it should be incorporated into "
"the consistency checker.\n"
"Calling the consistency checker is the fastest way to help isolate bugs in "
"the data structure."
msgstr ""
"Всякий раз, когда вы разрабатываете сложную структуру данных, такую как "
"некоторая база данных, рекомендуется разработать соответствующую проверку "
"согласованности.\n"
"Проверка согласованности-это функция, которая просматривает структуру данных "
"и проверяет наличие всех возможных ошибок.\n"
"При обнаружении новой ошибки проверка ее наличия должна быть включена в "
"Средство проверки согласованности.\n"
"Вызов средства проверки согласованности-это самый быстрый способ изолировать "
"ошибки в структуре данных."

#: in/chapter3.md:1755
msgid ""
"In addition, it is a good idea to keep a list of difficult test cases on "
"hand.\n"
"That way, when the program is changed, it will be easy to see if the change "
"reintroduces a bug that had been previously removed.\n"
"This is called *regression testing,* and [Waters (1991)]"
"(B9780080571157500285.xhtml#bb1350) presents an interesting tool for "
"maintaining a suite of regression tests.\n"
"But it is simple enough to maintain an informal test suite with a function "
"that calls assert on a series of examples:"
msgstr ""
"Кроме того, хорошей идеей будет иметь под рукой список сложных тестовых "
"заданий.\n"
"Таким образом, когда программа будет изменена, будет легко увидеть, если "
"изменение повторно выводит ошибку, которая была ранее удалена.\n"
"Это называется * регрессионным тестированием/regression testing* и [Waters "
"(1991)] (B9780080571157500285.xhtml#bb1350) представляет собой интересный "
"инструмент для поддержания набора регрессионных тестов.\n"
"Но достаточно просто поддерживать неформальный набор тестов с функцией, "
"вызывающей assert на ряде примеров:"

#: in/chapter3.md:1764
msgid ""
"```lisp\n"
"(defun test-ex ()\n"
"  \"Test the program EX on a series of examples.\"\n"
"  (init-ex) ; Initialize the EX program first.\n"
"  (assert (equal (ex 3 4) 5))\n"
"  (assert (equal (ex 5 0) 0))\n"
"  (assert (equal (ex 'x 0) 0)))\n"
"```"
msgstr ""

#: in/chapter3.md:1766
msgid "### Timing Tools"
msgstr "### Инструменты учета времени"

#: in/chapter3.md:1772
msgid ""
"A program is not complete just because it gives the right output.\n"
"It must also deliver the output in a timely fashion.\n"
"The form (`time` *expression*) can be used to see how long it takes to "
"execute *expression.*\n"
"Some implementations also print statistics on the amount of storage "
"required.\n"
"For example:"
msgstr ""
"Программа не является законченой только потому, что она дает правильный "
"результат.\n"
"Она также должна своевременно предоставлять результаты своей деятельности.\n"
"Форма (`time` *expression*) может использоваться, чтобы увидеть, сколько "
"времени требуется для выполнения *expression*.\n"
"Некоторые реализации также печатают статистику по объему требуемого "
"хранилища.\n"
"Например:"

#: in/chapter3.md:1777
msgid ""
"```lisp\n"
"> (defun f (n) (dotimes (i n) nil)) => F\n"
"> (time (f 10000)) NIL\n"
"Evaluation of (F 10000) took 4.347272 Seconds of elapsed time, including 0.0 "
"seconds of paging time for 0 faults, Consed 27 words."
msgstr ""

#: in/chapter3.md:1779
msgid "> (compile 'f) F"
msgstr ""

#: in/chapter3.md:1783
msgid ""
"> (time (f 10000)) => NIL\n"
"Evaluation of (F 10000) took 0.011518 Seconds of elapsed time, including 0.0 "
"seconds of paging time for 0 faults, Consed 0 words.\n"
"```"
msgstr ""

#: in/chapter3.md:1790
msgid ""
"This shows that the compiled version is over 300 times faster and uses less "
"storage to boot.\n"
"Most serious Common Lisp programmers work exclusively with compiled "
"functions.\n"
"However, it is usually a bad idea to worry too much about efficiency details "
"while starting to develop a program.\n"
"It is better to design a flexible program, get it to work, and then modify "
"the most frequently used parts to be more efficient.\n"
"In other words, separate the development stage from the fine-tuning stage.\n"
"[Chapters 9](chapter9.md) and [10](chapter10.md) give more details on "
"efficiency consideration, and [chapter 25](chapter25.md) gives more advice "
"on debugging and antibugging techniques."
msgstr ""
"Он показывает, что скомпилированная версия более чем в 300 раз быстрее и "
"использует меньше места для загрузки.\n"
"Большинство серьезных программистов Common Lisp работают исключительно с "
"компилируемыми функциями.\n"
"Однако, как правило, это плохая идея, чтобы беспокоиться слишком много о "
"деталях эффективности, начиная разрабатывать программу.\n"
"Лучше разработать гибкую программу, заставить ее работать, а затем "
"модифицировать наиболее часто используемые части, чтобы быть более "
"эффективными.\n"
"Другими словами, отделите стадию разработки от стадии тонкой настройки.\n"
"[Главы 9](chapter9.md) и [10](chapter10.md) дают более подробную информацию "
"о рассмотрении эффективности и [глава 25] (chapter25.md) дает больше советов "
"по отладке и методам борьбы с ошибками."

#: in/chapter3.md:1792
msgid "## 3.15 Evaluation"
msgstr "## 3.15 Вычисление(оценка/Evaluation)"

#: in/chapter3.md:1798
msgid ""
"There are three functions for doing evaluation in Lisp: `funcall, apply,` "
"and `eval`.\n"
"`funcall` is used to apply a function to individual arguments, while `apply` "
"is used to apply a function to a list of arguments.\n"
"Actually, `apply` can be given one or more individual arguments before the "
"final argument, which is always a list.\n"
"`eval` is passed a single argument, which should be an entire form - a "
"function or special form followed by its arguments, or perhaps an atom.\n"
"The following five forms are equivalent:"
msgstr ""
"Есть три функции для выполнения вычислений в Lisp: `funcall, apply` и "
"`eval`.\n"
"`funcall` используется для применения функции к отдельным аргументам, в то "
"время как `apply` используется для применения функции к списку аргументов.\n"
"На самом деле, `apply` можно дать один или несколько отдельных аргументов "
"перед окончательным аргументом, который всегда является списком.\n"
"в `eval` передается один аргумент, который должен быть целой формой - "
"функцией или специальной формой, за которой следуют ее аргументы или, "
"возможно, атом.\n"
"Следующие пять форм эквивалентны:"

#: in/chapter3.md:1806
msgid ""
"```lisp\n"
"> (+ 1 2 3 4)             => 10\n"
"> (funcall #'+ 1 2 3 4)   => 10\n"
"> (apply #'+ '(1 2 3 4))  => 10\n"
"> (apply #'+ 1 2 '(3 4))  => 10\n"
"> (eval '(+  123 4))      => 10\n"
"```"
msgstr ""

#: in/chapter3.md:1811
msgid ""
"In the past, `eval` was seen as the key to Lisp's flexibility.\n"
"In modern Lisps with lexical scoping, such as Common Lisp, `eval` is used "
"less often (in fact, in Scheme there is no `eval` at all).\n"
"Instead, programmers are expected to use `lambda` to create a new function, "
"and then `apply` or `funcall` the function.\n"
"In general, if you find yourself using `eval,` you are probably doing the "
"wrong thing."
msgstr ""
"В прошлом `eval` считался ключом к гибкости Лиспа.\n"
"В современных Лиспах с лексическим охватом, таких как Common Lisp, `eval` "
"используется редко (на самом деле в Scheme вообще нет `eval`).\n"
"Вместо этого программисты должны использовать `lambda` для создания новой "
"функции, а затем функцию `apply` или `funcall`.\n"
"В общем, если вы обнаружите, что используете `eval`, вы, вероятно, делаете "
"что-то не так."

#: in/chapter3.md:1813
msgid "## 3.16 Closures"
msgstr "## 3.16 Замыкания"

#: in/chapter3.md:1817
msgid ""
"What does it mean to create a new function?\n"
"Certainly every time a `function` (or `#')` special form is evaluated, a "
"function is returned.\n"
"But in the examples we have seen and in the following one, it is always the "
"*same* function that is returned."
msgstr ""
"Что значит создать новую функцию?\n"
"Конечно, каждый раз, когда вычисляется специальная форма `function` (или "
"`#')`, возвращается функция.\n"
"Но в примерах, которые мы видели, и в следующем, всегда возвращается одна и "
"та же функция."

#: in/chapter3.md:1821
msgid ""
"```lisp\n"
"> (mapcar #'(lambda (x) (+ x x)) '(1 3 10)) => (2 6 20)\n"
"```"
msgstr ""

#: in/chapter3.md:1826
msgid ""
"Every time we evaluate the `#'(lambda ...)` form, it returns the function "
"that doubles its argument.\n"
"However, in the general case, a function consists of the body of the "
"function coupled with any *free lexical variables* that the function "
"references.\n"
"Such a pairing is called a *lexical closure,* or just a *closure,* because "
"the lexical variables are enclosed within the function.\n"
"Consider this example:"
msgstr ""
"Каждый раз, когда мы вычисляем форму `#'(lambda ...)`, она возвращает "
"функцию, которая удваивает свой аргумент.\n"
"Однако в общем случае функция состоит из тела функции, связанного с любыми "
"*свободными лексическими переменными*, на которые ссылается функция.\n"
"Такое сопряжение называется лексическим замыканием или просто замыканием, "
"потому что лексические переменные заключены внутри функции.\n"
"Рассмотрим этот пример:"

#: in/chapter3.md:1831
msgid ""
"```lisp\n"
"(defun adder (c)\n"
"  \"Return a function that adds c to its argument.\"\n"
"  #'(lambda (x) (+ x c)))"
msgstr ""
"```lisp\n"
"(defun adder (c)\n"
"  \"Возвращает функцию которая добавляет c к своему аргументу.\"\n"
"  #'(lambda (x) (+ x c)))"

#: in/chapter3.md:1833
msgid "> (mapcar (adder 3) '(1 3 10)) => (4 6 13)"
msgstr ""

#: in/chapter3.md:1836
msgid ""
"> (mapcar (adder 10) '(1 3 10)) => (11 13 20)\n"
"```"
msgstr ""

#: in/chapter3.md:1839
msgid ""
"Each time we call `adder` with a different value for `c`, it creates a "
"different function, the function that adds `c` to its argument.\n"
"Since each call to `adder` creates a new local variable named `c`, each "
"function returned by `adder` is a unique function."
msgstr ""
"Каждый раз, когда мы вызываем  `adder` с другим значением для   `c`, он "
"создает другую функцию, функцию, которая добавляет  `c` к своему аргументу.\n"
"Поскольку каждый вызов  'adder' создает новую локальную переменную с "
"именем   `c`, каждая функция, возвращаемая   `adder`, является уникальной "
"функцией."

#: in/chapter3.md:1844
msgid ""
"Here is another example.\n"
"The function `bank-account` returns a closure that can be used as a "
"representation of a bank account.\n"
"The closure captures the local variable balance.\n"
"The body of the closure provides code to access and modify the local "
"variable."
msgstr ""
"Вот еще один пример.\n"
"Функция `bank-account` возвращает замыкание, которое может быть использовано "
"в качестве представления банковского счета.\n"
"Замыкание захватывает локальную переменную balance.\n"
"Тело замыкания предоставляет код для доступа и изменения локальной "
"переменной."

#: in/chapter3.md:1853
msgid ""
"```lisp\n"
"(defun bank-account (balance)\n"
"  \"Open a bank account starting with the given balance.\"\n"
"  #'(lambda (action amount)\n"
"      (case action\n"
"        (deposit  (setf balance (+ balance amount)))\n"
"        (withdraw (setf balance (- balance amount))))))\n"
"```"
msgstr ""

#: in/chapter3.md:1856
msgid ""
"In the following, two calls to bank-account create two different closures, "
"each with a separate value for the lexical variable `balance`.\n"
"The subsequent calls to the two closures change their respective balances, "
"but there is no confusion between the two accounts."
msgstr ""
"В следующем примере два вызова bank-account создают два разных замыкания, "
"каждое из которых имеет отдельное значение для лексической переменной "
"`balance`.\n"
"Последующие вызовы этих двух замыканий изменяют их соответствующие балансы, "
"но между этими двумя счетами нет никакой путаницы."

#: in/chapter3.md:1859
msgid ""
"```lisp\n"
"> (setf my-account (bank-account 500.00)) => #<CLOSURE 52330407>"
msgstr ""

#: in/chapter3.md:1861
msgid "> (setf your-account (bank-account 250.00)) => #<CLOSURE 52331203>"
msgstr ""

#: in/chapter3.md:1863
msgid "> (funcall my-account 'withdraw 75.00) => 425.0"
msgstr ""

#: in/chapter3.md:1865
msgid "> (funcall your-account 'deposit 250.00) => 500.0"
msgstr ""

#: in/chapter3.md:1867
msgid "> (funcall your-account 'withdraw 100.00) => 400.0"
msgstr ""

#: in/chapter3.md:1870
msgid ""
"> (funcall my-account 'withdraw 25.00) => 400.0\n"
"```"
msgstr ""

#: in/chapter3.md:1872
msgid ""
"This style of programming will be considered in more detail in [chapter 13]"
"(chapter13.md)."
msgstr ""
"Этот стиль программирования будет рассмотрен более подробно в главе "
"13(chapter13.md)."

#: in/chapter3.md:1874
msgid "## 3.17 Special Variables"
msgstr "## 3.17 Специальные Переменные"

#: in/chapter3.md:1879
msgid ""
"Common Lisp provides for two kinds of variables: *lexical* and *special* "
"variables.\n"
"For the beginner, it is tempting to equate the special variables in Common "
"Lisp with global variables in other languages.\n"
"Unfortunately, this is not quite correct and can lead to problems.\n"
"It is best to understand Common Lisp variables on their own terms."
msgstr ""
"Common Lisp предоставляет два вида переменных: *lexical/лексические* и "
"*special/специальные* переменные.\n"
"Для новичка заманчиво приравнять специальные переменные в Common Lisp к "
"глобальным переменным в других языках.\n"
"К сожалению, это не совсем правильно и может привести к проблемам.\n"
"Лучше всего понимать общие переменные Lisp на их собственных терминах."

#: in/chapter3.md:1883
msgid ""
"By default, Common Lisp variables are *lexical variables.*\n"
"Lexical variables are introduced by some syntactic construct like `let` or "
"`defun` and get their name from the fact that they may only be referred to "
"by code that appears lexically within the body of the syntactic construct.\n"
"The body is called the *scope* of the variable."
msgstr ""
"По умолчанию переменные Common Lisp являются *лексическими переменными/"
"lexical variables*.\n"
"Лексические переменные вводятся некоторыми синтаксическими конструкциями, "
"такими как `let` или `defun` и получают свое название от того факта, что они "
"могут быть упомянуты только кодом, который лексически появляется в теле "
"синтаксической конструкции.\n"
"Тело называется *scope/областью действия* переменной."

#: in/chapter3.md:1889
msgid ""
"So far, there is no difference between Common Lisp and other languages.\n"
"The interesting part is when we consider the *extent,* or lifetime, of a "
"variable.\n"
"In other languages, the extent is the same as the scope: a new local "
"variable is created when a block is entered, and the variable goes away when "
"the block is exited.\n"
"But because it is possible to create new functions - closures - in Lisp, it "
"is therefore possible for code that references a variable to live on after "
"the scope of the variable has been exited.\n"
"Consider again the `bank-account` function, which creates a closure "
"representing a bank account:"
msgstr ""
"До сих пор нет никакой разницы между Common Lisp и другими языками.\n"
"Самое интересное, когда мы рассматриваем *extent* или время жизни, "
"переменной.\n"
"В других языках экстент(время жизни) совпадает с областью действия: новая "
"локальная переменная создается при входе в блок и переменная исчезает при "
"выходе из блока.\n"
"Но поскольку в Lisp можно создавать новые функции-замыкания, то код, "
"ссылающийся на переменную, может существовать и после выхода из области "
"действия переменной.\n"
"Рассмотрим еще раз функцию `bank-account`, которая создает замыкание, "
"представляющее банковский счет:"

#: in/chapter3.md:1898
msgid ""
"```lisp\n"
"(defun bank-account (balance)\n"
"  \"Open a bank account starting with the given balance.\"\n"
"  #'(lambda (action amount)\n"
"      (case action\n"
"        (deposit (setf balance (+ balance amount)))\n"
"        (withdraw (setf balance (- balance amount))))))\n"
"```"
msgstr ""

#: in/chapter3.md:1905
msgid ""
"The function introduces the lexical variable `balance`.\n"
"The scope of `balance` is the body of the function, and therefore references "
"to `balance` can occur only within this scope.\n"
"What happens when `bank-account` is called and exited?\n"
"Once the body of the function has been left, no other code can refer to that "
"instance of `balance.`\n"
"The scope has been exited, but the extent of `balance` lives on.\n"
"We can call the closure, and it can reference `balance`, because the code "
"that created the closure appeared lexically within the scope of `balance`."
msgstr ""
"Функция вводит лексическую переменную `balance`.\n"
"Областью действия `balance` является тело функции, и поэтому ссылки на "
"`balance` могут встречаться только в этой области.\n"
"Что происходит, когда `bank-account` вызывается и завершает вызов?\n"
"После того, как вычисление тела функции было завершено, никакой другой код "
"не может ссылаться на этот экземпляр `balance`.\n"
"Область охвата(scope) была покинута, но ссылка на `balance` продолжает "
"жить.\n"
"Мы можем вызвать замыкание, и оно может ссылаться на `balance`, потому что "
"код, который создал замыкание, лексически появился в области существования "
"`balance`."

#: in/chapter3.md:1907
msgid ""
"In summary, Common Lisp lexical variables are different because they can be "
"captured inside closures and referred to even after the flow of control has "
"left their scope."
msgstr ""
"Таким образом, лексические переменные Common Lisp отличаются тем, что они "
"могут быть захвачены внутри замыканий и ссылаться на них даже после того, "
"как поток управления покинул их область действия."

#: in/chapter3.md:1911
msgid ""
"Now we will consider special variables.\n"
"A variable is made special by a `defvar` or `defparameter` form.\n"
"For example, if we say"
msgstr ""
"Теперь рассмотрим специальные переменные.\n"
"Переменная становится Специальной с помощью формы `defvar` или "
"`defparameter`.\n"
"Например, если мы скажем:"

#: in/chapter3.md:1915
msgid ""
"```lisp\n"
"(defvar *counter* 0)\n"
"```"
msgstr ""

#: in/chapter3.md:1921
msgid ""
"then we can refer to the special variable `*counter*` anywhere in our "
"program.\n"
"This is just like a familiar global variable.\n"
"The tricky part is that the global binding of `*counter*` can be shadowed by "
"a local binding for that variable.\n"
"In most languages, the local binding would introduce a local lexical "
"variable, but in Common Lisp, special variables can be bound both locally "
"and globally.\n"
"Here is an example:"
msgstr ""
"затем мы можем обратиться к специальной переменной `*counter*` в любом месте "
"нашей программы.\n"
"Это очень похоже на знакомую глобальную переменную.\n"
"Сложность заключается в том, что глобальная привязка `*counter*` может быть "
"затенена локальной привязкой для этой переменной.\n"
"В большинстве языков локальная привязка вводит локальную лексическую "
"переменную, но в Common Lisp специальные переменные могут быть связаны как "
"локально, так и глобально.\n"
"Вот вам пример:"

#: in/chapter3.md:1925
msgid ""
"```lisp\n"
"(defun report ()\n"
"  (format t \"Counter = ~d\" *counter*))"
msgstr ""

#: in/chapter3.md:1929
msgid ""
"> (report)\n"
"Counter = 0\n"
"NIL"
msgstr ""

#: in/chapter3.md:1934
msgid ""
"> (let ((*counter* 100))\n"
"    (report))\n"
"Counter = 100\n"
"NIL"
msgstr ""

#: in/chapter3.md:1939
msgid ""
"> (report)\n"
"Counter = 0\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter3.md:1944
msgid ""
"There are three calls to `report` here.\n"
"In the first and third, `report` prints the global value of the special "
"variable `*counter*`.\n"
"In the second call, the `let` form introduces a new binding for the special "
"variable `*counter*`, which is again printed by `report.`\n"
"Once the scope of the `let` is exited, the new binding is disestablished, so "
"the final call to `report` uses the global value again."
msgstr ""
"Есть здесь три вызова `report`.\n"
"В первом и третьем `report` выводит глобальное значение специальной "
"переменной `*counter*`.\n"
"Во втором вызове форма `let` вводит новую привязку для специальной "
"переменной  `*counter*`, которая снова печатается с помощью `report`.\n"
"Как только область действия `let` заканчивается, новая привязка "
"уничтожается, поэтому последний вызов `report` снова использует глобальное "
"значение."

#: in/chapter3.md:1948
msgid ""
"In summary, Common Lisp special variables are different because they have "
"global scope but admit the possibility of local (dynamic) shadowing.\n"
"Remember: A lexical variable has lexical scope and indefinite extent.\n"
"A special variable has indefinite scope and dynamic extent."
msgstr ""
"Таким образом, специальные переменные Common Lisp отличаются тем, что они "
"имеют глобальную область действия, но допускают возможность локального "
"(динамического) затенения.\n"
"Помните: лексическая переменная имеет лексическую область действия и "
"неопределенный экстент(время существовани).\n"
"Специальная переменная имеет неопределенную область действия и динамический "
"экстент."

#: in/chapter3.md:1951
msgid ""
"The function call (`symbol-value` *var*), where *var* evaluates to a symbol, "
"can be used to get at the current value of a special variable.\n"
"To set a special variable, the following two forms are completely equivalent:"
msgstr ""
"Вызов функции (`symbol-value` *var*), где *var* вычисляется как символ, "
"может быть использован для получения текущего значения специальной "
"переменной.\n"
"Чтобы задать специальную переменную, следующие две формы полностью "
"эквивалентны:"

#: in/chapter3.md:1954
msgid ""
"> `(setf (symbol-value` *var*) *value*)  \n"
"> `(set` *var value*)"
msgstr ""
"> `(setf (symbol-value` *var*) *value*) \n"
" \n"
"> `(set` *var value*)\n"

#: in/chapter3.md:1960
msgid ""
"where both *var* and *value* are evaluated.\n"
"There are no corresponding forms for accessing and setting lexical "
"variables.\n"
"Special variables set up a mapping between symbols and values that is "
"accessible to the running program.\n"
"This is unlike lexical variables (and all variables in traditional "
"languages) where symbols (identifiers) have significance only while the "
"program is being compiled.\n"
"Once the program is running, the identifiers have been compiled away and "
"cannot be used to access the variables; only code that appears within the "
"scope of a lexical variable can reference that variable."
msgstr ""
"где и *var* и *value* вычисляются.\n"
"Не существует соответствующих форм для доступа и установки лексических "
"переменных.\n"
"Специальные переменные устанавливают отображение между символами и "
"значениями, доступное для запущенной программы.\n"
"Это не похоже на лексические переменные (и все переменные в традиционных "
"языках), где символы (идентификаторы) имеют значение только во время "
"компиляции программы.\n"
"Как только программа запущена, идентификаторы были скомпилированы и не могут "
"быть использованы для доступа к переменным; только код, который появляется в "
"области лексической переменной, может ссылаться на эту переменную."

#: in/chapter3.md:1962
msgid ""
"&#9635; **Exercise 3.6 [s]** Given the following initialization for the "
"lexical variable `a` and the special variable `*b*`, what will be the value "
"of the `let` form?"
msgstr ""
"&#9635; **Упражнение 3.6 [s]** учитывая следующую инициализацию для "
"лексической переменной `a` и специальной переменной `*b*`, каким будет "
"значение формы `let`?"

#: in/chapter3.md:1966
msgid ""
"```lisp\n"
"(setf a 'global-a)\n"
"(defvar *b* 'global-b)"
msgstr ""

#: in/chapter3.md:1968
msgid "(defun fn () *b*)"
msgstr ""

#: in/chapter3.md:1973
msgid ""
"(let ((a 'local-a)\n"
"      (*b* 'local-b))\n"
"  (list a *b* (fn) (symbol-value 'a) (symbol-value '*b*)))\n"
"```"
msgstr ""

#: in/chapter3.md:1975
msgid "## 3.18 Multiple Values"
msgstr "## 3.18 Множественные Значения"

#: in/chapter3.md:1985
msgid ""
"Throughout this book we have spoken of \"the value returned by a function."
"\"\n"
"Historically, Lisp was designed so that every function returns a value, even "
"those functions that are more like procedures than like functions.\n"
"But sometimes we want a single function to return more than one piece of "
"information.\n"
"Of course, we can do that by making up a list or structure to hold the "
"information, but then we have to go to the trouble of defining the "
"structure, building an instance each time, and then taking that instance "
"apart to look at the pieces.\n"
"Consider the function `round.`\n"
"One way it can be used is to round off a floating-point number to the "
"nearest integer.\n"
"So (`round 5.1`) is 5.\n"
"Sometimes, though not always, the programmer is also interested in the "
"fractional part.\n"
"The function `round` serves both interested and disinterested programmers by "
"returning two values: the rounded integer and the remaining fraction:"
msgstr ""
"На протяжении всей этой книги мы говорили о \"значении, возвращаемом "
"функцией.\"\n"
"Исторически Lisp был разработан таким образом, что каждая функция возвращает "
"значение, даже те функции, которые больше похожи на процедуры, чем на "
"функции.\n"
"Но иногда мы хотим, чтобы одна функция возвращала более одного фрагмента "
"информации.\n"
"Конечно, мы можем сделать это, составив список или структуру для хранения "
"информации, но тогда нам придется потрудиться над определением структуры, "
"каждый раз создавая экземпляр, а затем разбирая его на части, чтобы "
"посмотреть на фрагменты.\n"
"Рассмотрим функцию `round`.\n"
"Один из способов его использования-округление числа с плавающей запятой до "
"ближайшего целого числа.\n"
"Итак (`round 5.1`) - это 5.\n"
"Иногда, хотя и не всегда, программиста интересует и дробная часть.\n"
"Функция `round` служит как заинтересованным, так и незаинтересованным "
"программистам, возвращая два значения: округленное целое число и оставшуюся "
"дробь:"

#: in/chapter3.md:1989
msgid ""
"```lisp\n"
"> (round 5.1) => 5 .1\n"
"```"
msgstr ""

#: in/chapter3.md:1994
msgid ""
"There are two values after the => because `round` returns two values.\n"
"Most of the time, multiple values are ignored, and only the first value is "
"used.\n"
"So (`* 2 (round 5.1)`) is 10, just as if `round` had only returned a single "
"value.\n"
"If you want to get at multiple values, you have to use a special form, such "
"as `multiple-value-bind`:"
msgstr ""
"После => есть два значения, потому что `round` возвращает два значения.\n"
"В большинстве случаев множественные значения игнорируются, и используется "
"только первое значение.\n"
"Таким образом, (`* 2 (round 5.1)`) равно 10, как если бы `round` возвращал "
"только одно значение.\n"
"Если вы хотите получить несколько значений, вам нужно использовать "
"специальную форму, такую как `multiple-value-bind`:"

#: in/chapter3.md:2000
msgid ""
"```lisp\n"
"(defun show-both (x)\n"
"  (multiple-value-bind (int rem)\n"
"      (round x)\n"
"    (format t \"~f = ~d + ~f\" x int rem)))"
msgstr ""

#: in/chapter3.md:2004
msgid ""
">(show-both 5.1)\n"
"5.1 = 5 + 0.1\n"
"```"
msgstr ""

#: in/chapter3.md:2006
msgid ""
"You can write functions of your own that return multiple values using the "
"function `values`, which returns its arguments as multiple values:"
msgstr ""
"Вы можете написать свои собственные функции, возвращающие несколько "
"значений, используя функцию `values`, которая возвращает свои аргументы в "
"виде множественных значений:"

#: in/chapter3.md:2010
msgid ""
"```lisp\n"
"> (values 1 2 3) => 1 2 3\n"
"```"
msgstr ""

#: in/chapter3.md:2014
msgid ""
"Multiple values are a good solution because they are unobtrusive until they "
"are needed.\n"
"Most of the time when we are using `round,` we are only interested in the "
"integer value.\n"
"If `round` did not use multiple values, if it packaged the two values up "
"into a list or structure, then it would be harder to use in the normal cases."
msgstr ""
"Множественные значения-это хорошее решение, потому что они ненавязчивы, пока "
"не понадобятся.\n"
"Большую часть времени, когда мы используем `round`, нас интересует только "
"целочисленное значение.\n"
"Если бы `round` не использовал множественные значения, если бы он упаковал "
"два значения в список или структуру, то его было бы труднее использовать в "
"обычных случаях."

#: in/chapter3.md:2018
msgid ""
"It is also possible to return no values from a function with (`values`).\n"
"This is sometimes used by procedures that are called for effect, such as "
"printing.\n"
"For example, `describe` is defined to print information and then return no "
"values:"
msgstr ""
"Также можно не возвращать значения из функции используя (`values`).\n"
"Это иногда используется процедурами, которые вызываются ради стороннего "
"эффекта, например печати.\n"
"Например, `describe` определяется для печати информации, а затем не "
"возвращает никаких значений:"

#: in/chapter3.md:2024
msgid ""
"```\n"
"> (describe 'x)\n"
"Symbol X is in the USER package.\n"
"It has no value, definition or properties.\n"
"```"
msgstr ""

#: in/chapter3.md:2027
msgid ""
"However, when (`values`) or any other expression returning no values is "
"nested in a context where a value is expected, it still obeys the Lisp rule "
"of one-value-per-expression and returns `nil`.\n"
"In the following example, `describe` returns no values, but then `list` in "
"effect asks for the first value and gets `nil`."
msgstr ""
"Однако, когда (`values`) или любое другое выражение, не возвращающее никаких "
"значений, вложено в контекст, где ожидается значение, оно все еще "
"подчиняется правилу Lisp одного значения на выражение и возвращает `nil`.\n"
"В следующем примере `describe` не возвращает никаких значений, но затем "
"`list` фактически запрашивает первое значение и получает `nil`."

#: in/chapter3.md:2034
msgid ""
"```\n"
"> (list (describe 'x))\n"
"Symbol X is in AILP package.\n"
"It has no value, definition or properties.\n"
"(NIL)\n"
"```"
msgstr ""

#: in/chapter3.md:2036
msgid "## 3.19 More about Parameters"
msgstr "## 3.19 подробнее о параметрах"

#: in/chapter3.md:2042
msgid ""
"Common Lisp provides the user with a lot of flexibility in specifying the "
"parameters to a function, and hence the arguments that the function "
"accepts.\n"
"Following is a program that gives practice in arithmetic.\n"
"It asks the user a series of *n* problems, where each problem tests the "
"arithmetic operator op (which can be `+`, `-`, `*`, or `/`, or perhaps "
"another binary operator).\n"
"The arguments to the operator will be random integers from 0 to range.\n"
"Here is the program:"
msgstr ""
"Common Lisp предоставляет пользователю большую гибкость в определении "
"параметров функции и, следовательно, аргументов, которые принимает функция.\n"
"Ниже приводится программа, которая дает практику в арифметике.\n"
"Она задает пользователю ряд из *n* задач, где каждая задача проверяет "
"арифметический оператор op (который может быть `+`, `-`, `*`, или `/' или, "
"возможно, другой двоичный оператор).\n"
"Аргументами оператора будут случайные целые числа от 0 до range.\n"
"Вот программа:"

#: in/chapter3.md:2048
msgid ""
"```lisp\n"
"(defun math-quiz (op range n)\n"
"  \"Ask the user a series of math problems.\"\n"
"  (dotimes (i n)\n"
"    (problem (random range) op (random range))))"
msgstr ""

#: in/chapter3.md:2056
msgid ""
"(defun problem (x op y)\n"
"  \"Ask a math problem, read a reply, and say if it is correct.\"\n"
"  (format t \"~&How much is ~d ~a ~d?\" x op y)\n"
"  (if (eql (read) (funcall op x y))\n"
"      (princ \"Correct!\")\n"
"      (princ \"Sorry, that's not right.\")))\n"
"```"
msgstr ""

#: in/chapter3.md:2058
msgid "and here is an example of its use:"
msgstr "а вот пример её использования:"

#: in/chapter3.md:2066
msgid ""
"```lisp\n"
"> (math-quiz '+ 100 2)\n"
"How much is 32 + 60? 92\n"
"Correct!\n"
"How much is 91 + 19? 100\n"
"Sorry, that's not right.\n"
"```"
msgstr ""

#: in/chapter3.md:2070
msgid ""
"One problem with the function `math-quiz` is that it requires the user to "
"type three arguments: the operator, a range, and the number of iterations.\n"
"The user must remember the order of the arguments, and remember to quote the "
"operator.\n"
"This is quite a lot to expect from a user who presumably is just learning to "
"add!"
msgstr ""
"Одна из проблем с функцией `math-quiz` заключается в том, что она требует от "
"пользователя ввести три аргумента: оператор, диапазон и число итераций.\n"
"Пользователь должен запомнить порядок аргументов и не забыть процитировать "
"оператор.\n"
"Это довольно много, чтобы ожидать от пользователя, который, по-видимому, "
"только учится складывать!"

#: in/chapter3.md:2074
msgid ""
"Common Lisp provides two ways of dealing with this problem.\n"
"First, a programmer can specify that certain arguments are *optional* and "
"provide default values for those arguments.\n"
"For example, in `math-quiz` we can arrange to make `+` be the default "
"operator, `100` be the default number range, and `10` be the default number "
"of examples with the following definition:"
msgstr ""
"Common Lisp предоставляет два способа решения этой проблемы.\n"
"Во-первых, программист может указать, что некоторые аргументы являются "
"*optional/необязательными*, и предоставить значения по умолчанию для этих "
"аргументов.\n"
"Например, в `math-quiz` мы можем сделать так, чтобы `+` был оператором по "
"умолчанию, `100` - диапазоном чисел по умолчанию, а `10` - числом примеров "
"по умолчанию со следующим определением:"

#: in/chapter3.md:2081
msgid ""
"```lisp\n"
"(defun math-quiz (&optional (op '+) (range 100) (n 10))\n"
"  \"Ask the user a series of math problems.\"\n"
"  (dotimes (i n)\n"
"    (problem (random range) op (random range))))\n"
"```"
msgstr ""

#: in/chapter3.md:2086
msgid ""
"Now (`math-quiz`) means the same as (`math-quiz '+ 100 10`).\n"
"If an optional parameter appears alone without a default value, then the "
"default is `nil`.\n"
"Optional parameters are handy; however, what if the user is happy with the "
"operator and range but wants to change the number of iterations?\n"
"Optional parameters are still position-dependent, so the only solution is to "
"type in all three arguments: (`math-quiz '+ 100 5`)."
msgstr ""
"Теперь (`math-quiz`) означает то же, что (`math-quiz '+ 100 10`).\n"
"Если необязательный параметр появляется отдельно без значения по умолчанию, "
"то значение по умолчанию равно   `nil`.\n"
"Дополнительные параметры удобны; однако что делать, если пользователь "
"доволен оператором(op) и диапазоном(range), но хочет изменить количество "
"итераций(n)?\n"
"Необязательные параметры по-прежнему зависят от позиции, поэтому "
"единственное решение-ввести все три аргумента: ``(math-quiz '+ 100 5)``."

#: in/chapter3.md:2091
msgid ""
"Common Lisp also allows for parameters that are position-independent.\n"
"These *keyword* parameters are explicitly named in the function call.\n"
"They are useful when there are a number of parameters that normally take "
"default values but occasionally need specific values.\n"
"For example, we could have defined `math-quiz` as:"
msgstr ""
"Common Lisp также позволяет использовать параметры, не зависящие от "
"положения.\n"
"Эти параметры *keyword/ключевые слова* явно именуются в вызове функции.\n"
"Они полезны, когда есть ряд параметров, которые обычно принимают значения по "
"умолчанию, но иногда нуждаются в определенных значениях.\n"
"Например, мы могли бы определить `math-quiz` как:"

#: in/chapter3.md:2098
msgid ""
"```lisp\n"
"(defun math-quiz (&key (op '+) (range 100) (n 10))\n"
"  \"Ask the user a series of math problems.\"\n"
"  (dotimes (i n)\n"
"    (problem (random range) op (random range))))\n"
"```"
msgstr ""

#: in/chapter3.md:2102
msgid ""
"Now (`math-quiz :n 5`) and (`math-quiz :op '+ :n 5 :range 100`) mean the "
"same.\n"
"Keyword arguments are specified by the parameter name preceded by a colon, "
"and followed by the value.\n"
"The keyword/value pairs can come in any order."
msgstr ""
"Теперь (`math-quiz :n 5`) и (`math-quiz :op '+ :n 5 :range 100`) означает то "
"же самое.\n"
"Аргументы ключевые слова задаются именем параметра, которому предшествует "
"двоеточие, а за ним следует значение.\n"
"Пары ключевое слово/значение могут располагаться в любом порядке."

#: in/chapter3.md:2112
msgid ""
"A symbol starting with a colon is called a *keyword*, and can be used "
"anywhere, not just in argument lists.\n"
"The term *keyword* is used differently in Lisp than in many other "
"languages.\n"
"For example, in Pascal, keywords (or *reserved* words) are syntactic "
"symbols, like `if, else, begin`, and `end`.\n"
"In Lisp we call such symbols *special form operators* or just *special forms."
"*\n"
"<a id=\"tfn03-3\"></a>\n"
"Lisp keywords are symbols that happen to reside in the keyword package.[[3]]"
"(#fn03-3)\n"
"They have no special syntactic meaning, although they do have the unusual "
"property of being self-evaluating: they are constants that evaluate to "
"themselves, unlike other symbols, which evaluate to whatever value was "
"stored in the variable named by the symbol.\n"
"Keywords also happen to be used in specifying `&key` argument lists, but "
"that is by virtue of their value, not by virtue of some syntax rule.\n"
"It is important to remember that keywords are used in the function call, but "
"normal nonkeyword symbols are used as parameters in the function definition."
msgstr ""
"Символ, начинающийся с двоеточия, называется *ключевым словом* и может "
"использоваться в любом месте, а не только в списках аргументов.\n"
"Термин *ключевое слово* используется в Lisp иначе, чем во многих других "
"языках.\n"
"Например, в Паскале, ключевые слова (или *зарезервированые* слова) "
"синтаксические символы, как `if, else, begin` и `end`.\n"
"В Lisp мы называем такие символы *операторами специальных форм* или просто "
"*специальные формы*.\n"
"<a id=\"tfn03-3\"></a>\n"
"Ключевые слова в Lisp - это символы, которые находятся в пакете ключевых "
"слов(keyword) .[[3]](#fn03-3)\n"
"Они не имеют особого синтаксического значения, хотя и обладают необычным "
"свойством самовычисления: они являются константами, которые вычисляются сами "
"в себя, в отличие от других символов, которые вычисляются в любое значение, "
"сохраненное в переменной, именуемой символом.\n"
"Ключевые слова также используются при указании списков аргументов `&key`, но "
"это происходит в силу их значения, а не в силу какого-то синтаксического "
"правила.\n"
"Важно помнить, что ключевые слова используются при вызове функции, но в "
"качестве параметров в определении функции используются обычные символы "
"nonkeyword."

#: in/chapter3.md:2116
msgid ""
"Just to make things a little more confusing, the symbols `&optional, &rest,` "
"and `&key` are called *lambda-list keywords*, for historical reasons.\n"
"Unlike the colon in real keywords, the `&` in lambda-list keywords has no "
"special significance.\n"
"Consider these annotated examples:"
msgstr ""
"Просто чтобы сделать вещи немного более запутанными, символы `&optional, "
"&rest` и `&key` называются *ключевыми словами лямбда-списка* по историческим "
"причинам.\n"
"В отличие от двоеточия в реальных ключевых словах, `&` в ключевых словах "
"лямбда-списка не имеет особого значения.\n"
"Рассмотрим эти аннотированные примеры:"

#: in/chapter3.md:2119
msgid "`> :xyz => :XYZ`        *; keywords are self-evaluating*"
msgstr "`> :xyz => :XYZ`        ; *ключевые слова- вычисляются сами в себя*"

#: in/chapter3.md:2122
msgid ""
"`> &optional =>`        *; lambda-list keywords are normal symbols  \n"
"Error: the symbol &optional has no value*"
msgstr ""
"`> &optional =>`        ; *ключевые слова лямбда-списка это обычные "
"символы*  \n"
"Error: the symbol &optional has no value"

#: in/chapter3.md:2127
msgid ""
"```lisp\n"
"> '&optional => &OPTIONAL\n"
"```\n"
"`> (defun f (&xyz) (+ &xyz &xyz)) F` *;& has no significance*"
msgstr ""
"```lisp\n"
"> '&optional => &OPTIONAL\n"
"```\n"
"`> (defun f (&xyz) (+ &xyz &xyz)) F` ;& *не имеет никакого значения*"

#: in/chapter3.md:2134
msgid ""
"```lisp\n"
"> (f 3) => 6\n"
"> (defun f (:xyz) (+ :xyz :xyz)) =>\n"
"```\n"
"*Error: the keyword :xyz appears in a variable list.  \n"
"Keywords are constants, and so cannot be used as names of variables.*"
msgstr ""
"```lisp\n"
"> (f 3) => 6\n"
"> (defun f (:xyz) (+ :xyz :xyz)) =>\n"
"```\n"
"*Error: the keyword :xyz appears in a variable list.  \n"
"Ключевые слова являются константами и поэтому не могут использоваться в "
"качестве имен переменных.*"

#: in/chapter3.md:2143
msgid ""
"```lisp\n"
"> (defun g (&key x y) (list x y)) => G\n"
"```\n"
"```\n"
"> (let ((key s '(:x :y :z)))\n"
"   (g (second keys) 1 (first keys) 2)) => (2 1)\n"
"```\n"
"*; keyword args can be computed*"
msgstr ""
"```lisp\n"
"> (defun g (&key x y) (list x y)) => G\n"
"```\n"
"```\n"
"> (let ((key s '(:x :y :z)))\n"
"   (g (second keys) 1 (first keys) 2)) => (2 1)\n"
"```\n"
"; *ключевое слово в аргументах может быть вычислено*"

#: in/chapter3.md:2146
msgid ""
"Many of the functions presented in this chapter take keyword arguments that "
"make them more versatile.\n"
"For example, remember the function `find`, which can be used to look for a "
"particular element in a sequence:"
msgstr ""
"Многие функции, представленные в этой главе, используют аргументы ключевые "
"слова, что делает их более универсальными.\n"
"Например, вспомните функцию `find`, которая может быть использована для "
"поиска определенного элемента в последовательности:"

#: in/chapter3.md:2152
msgid ""
"```lisp\n"
"> (find 3 '(1 2 3 4 -5 6.0)) => 3\n"
"```\n"
"It turns out that `find` takes several optional keyword arguments.\n"
"For example, suppose we tried to find `6` in this sequence:"
msgstr ""
"```lisp\n"
"> (find 3 '(1 2 3 4 -5 6.0)) => 3\n"
"```\n"
"Оказывается, что `find` принимает несколько необязательных аргументов "
"ключевых слов.\n"
"Например, предположим, что мы попытались найти `6` в этой последовательности:"

#: in/chapter3.md:2156
msgid ""
"```lisp\n"
"> (find 6 '(1 2 3 4 -5 6.0)) => nil\n"
"```"
msgstr ""

#: in/chapter3.md:2159
msgid ""
"This fails because `find` tests for equality with `eql`, and `6` is not "
"`eql` to `6.0`.\n"
"However, `6` is `equalp` to 6.0, so we could use the `:test` keyword:"
msgstr ""
"Сделать это не удается, потому что `find` тестируен на равенство с помощью "
"\"eql\", а `6` не является равным с  `6.0` для `eql`.\n"
"Однако `6` является равным  6.0 для `equalp`, поэтому мы могли бы "
"использовать ключевое слово `:test` :"

#: in/chapter3.md:2163
msgid ""
"```lisp\n"
"> (find 6 '(1 2 3 4 -5 6.0) :test #'equalp) => 6.0\n"
"```"
msgstr ""

#: in/chapter3.md:2166
msgid ""
"In fact, we can specify any binary predicate for the `:test` keyword; it "
"doesn't have to be an equality predicate.\n"
"For example, we could find the first number that `4` is less than:"
msgstr ""
"Фактически, мы можем указать любой двухаргументный предикат для ключевого "
"слова `:test`; он не обязательно должен быть предикатом равенства.\n"
"Например, мы могли бы найти первое число, которое больше, чем `4`:"

#: in/chapter3.md:2170
msgid ""
"```lisp\n"
"> (find 4 '(1 2 3 4 -5 6.0) :test #'<) => 6.0\n"
"```"
msgstr ""

#: in/chapter3.md:2173
msgid ""
"Now suppose we don't care about the sign of the numbers; if we look for `5`, "
"we want to find the `-5`.\n"
"We can handle this with the key keyword to take the absolute value of each "
"element of the list with the `abs` function:"
msgstr ""
"Теперь предположим, что мы не заботимся о знаке чисел; если мы ищем `5`, мы "
"хотим найти `-5`.\n"
"Мы можем справиться с этим с помощью ключевого слова, чтобы взять абсолютное "
"значение каждого элемента списка с помощью функции `abs` :"

#: in/chapter3.md:2177
msgid ""
"```lisp\n"
"> (find 5 '(1 2 3 4 -5 6.0) :key #'abs) => -5\n"
"```"
msgstr ""

#: in/chapter3.md:2182
msgid ""
"Keyword parameters significantly extend the usefulness of built-in "
"functions, and they can do the same for functions you define.\n"
"Among the built-in functions, the most common keywords fall into two main "
"groups: `:test`, `:test-not` and `:key,` which are used for matching "
"functions, and `:start`, `:end,` and `:from-end,` which are used on sequence "
"functions.\n"
"Some functions accept both sets of keywords.\n"
"(*Common Lisp the Language*, 2d edition, discourages the use of `:test-not` "
"keywords, although they are still a part of the language.)"
msgstr ""
"Параметры ключевые слова значительно расширяют полезность встроенных "
"функций, и они могут делать то же самое для функций, которые определяете "
"вы.\n"
"Среди встроенных функций наиболее распространенные ключевые слова делятся на "
"две основные группы: `:test`, `:test-not` и `:key`, которые используются для "
"функций сопоставления, и `:start`, `:end` и `:from-end`, которые "
"используются для функций работающих с последовательностями.\n"
"Некоторые функции принимают оба набора ключевых слов.\n"
"(*Common Lisp The Language*, 2d edition, не поощряет использование ключевых "
"слов `:test-not`, хотя они все еще являются частью языка.)"

#: in/chapter3.md:2187
msgid ""
"The matching functions include `sublis`, `position`, `subst`, `union`, "
"`intersection`, `set-difference`, `remove`, `remove-if`, `subsetp`, `assoc`, "
"`find,` and `member.`\n"
"By default, each tests if some item is `eql` to one or more of a series of "
"other objects.\n"
"This test can be changed by supplying some other predicate as the argument "
"to `:test`, or it can be reversed by specifying `:test-not.`\n"
"In addition, the comparison can be made against some part of the object "
"rather than the whole object by specifying a selector function as the `:key` "
"argument."
msgstr ""
"Соответствующие функции включают `sublis`, `position`, `subst`, `union`, "
"`intersection`, `set-difference`, `remove`, `remove-if`, `subsetp`, `assoc`, "
"`find,` and `member.`\n"
"По умолчанию каждая тестирует, является ли какой-то элемент `eql`(равным для "
"этой функции) одному или нескольким из ряда других объектов.\n"
"Этот тест может быть изменен путем предоставления некоторого другого "
"предиката в качестве аргумента для `:test` или он может быть отменен путем "
"указания `:test-not`.\n"
"Кроме того, сравнение может быть выполнено с некоторой частью объекта, а не "
"со всем объектом, указав функцию селектор в качестве аргумента `:key`."

#: in/chapter3.md:2193
msgid ""
"The sequence functions include `remove`, `remove-if`, `position,` and "
"`find`.\n"
"The most common type of sequence is the list, but strings and vectors can "
"also be used as sequences.\n"
"A sequence function performs some action repeatedly for some elements of a "
"sequence.\n"
"The default is to go through the sequence from beginning to end, but the "
"reverse order can be specified with `:from-end t` and a subsequence can be "
"specifed by supplying a number for the `:start` or `:end` keyword.\n"
"The first element of a sequence is numbered 0, not 1, so be careful."
msgstr ""
"Функции последовательности включают в себя `remove`, `remove-if`, `position` "
"и `find`.\n"
"Наиболее распространенным типом последовательности является список, но "
"строки и векторы также могут использоваться в качестве последовательностей.\n"
"Функция работающая с последовательностью выполняет некоторое повторяющееся "
"действие  для некоторых элементов последовательности.\n"
"По умолчанию проход по последовательности должен проходить от начала до "
"конца, но обратный порядок может быть задан с помощью  `:from-end t`,  а "
"подпоследовательность может быть задана с помощью ключевого слова  `:start`  "
"или  `:end`.\n"
"Первый элемент последовательности имеет номер 0, а не 1, поэтому будьте "
"осторожны."

#: in/chapter3.md:2201
msgid ""
"As an example of keyword parameters, suppose we wanted to write sequence "
"functions that are similar to `find` and `find-if`, except that they return "
"a list of all matching elements rather than just the first matching "
"element.\n"
"We will call the new functions `find-all` and `find-all-if`.\n"
"Another way to look at these functions is as variations of remove.\n"
"Instead of removing items that match, they keep all the items that match, "
"and remove the ones that don't.\n"
"Viewed this way, we can see that the function `find-all-if` is actually the "
"same function as `remove-if-not`.\n"
"It is sometimes useful to have two names for the same function viewed in "
"different ways (like `not` and `null`).\n"
"The new name could be defined with a `defun`, but it is easier to just copy "
"over the definition:"
msgstr ""
"В качестве примера параметров ключевых слов предположим, что мы хотим "
"написать функции работы с последовательностями, которые похожи на `find` и "
"`find-if`, за исключением того, что они возвращают список всех совпадающих "
"элементов, а не только первый совпадающий элемент.\n"
"Мы будем называть новыми функциями `find-all` и `find-all-if`.\n"
"Другой способ взглянуть на эти функции-как на вариацию remove.\n"
"Вместо того чтобы удалять совпадающие элементы, они сохраняют все "
"совпадающие элементы и удаляют те, которые не совпадают.\n"
"Рассматривая это таким образом, мы можем видеть, что функция `find-all-if` "
"на самом деле является той же самой функцией, что и `remove-if-not`.\n"
"Иногда полезно иметь два имени для одной и той же функции, рассматриваемой "
"по-разному (например, `not` и `null`).\n"
"Новое имя можно было бы определить с помощью `defun`, но проще просто "
"скопировать определение:"

#: in/chapter3.md:2205
msgid ""
"```lisp\n"
"(setf (symbol-function 'find-all-if) #'remove-if-not)\n"
"```"
msgstr ""

#: in/chapter3.md:2210
msgid ""
"Unfortunately, there is no built-in function that corresponds exactly to "
"`find-all`, so we will have to define it.\n"
"Fortunately, `remove` can do most of the work.\n"
"All we have to do is arrange to pass remove the complement of the `:test` "
"predicate.\n"
"For example, finding all elements that are equal to 1 in a list is "
"equivalent to removing elements that are not equal to 1:"
msgstr ""
"К сожалению, нет встроенной функции, которая точно соответствует `find-all`, "
"поэтому нам придется ее определить.\n"
"К счастью, `remove` может сделать большую часть работы.\n"
"Все, что нам нужно сделать, это организовать передачу в remove дополнение "
"предиката `:test`.\n"
"Например, поиск всех элементов, равных 1 в списке, эквивалентен удалению "
"элементов, не равных 1:"

#: in/chapter3.md:2213
msgid ""
"```lisp\n"
"> (setf nums '(1 2 3 2 1)) => (1 2 3 2 1)"
msgstr ""

#: in/chapter3.md:2216
msgid ""
"> (find-all 1 nums :test #'=) = (remove 1 nums :test #'/=) => (1 1)\n"
"```"
msgstr ""

#: in/chapter3.md:2220
msgid ""
"Now what we need is a higher-order function that returns the complement of a "
"function.\n"
"In other words, given `=`, we want to return `/=`.\n"
"This function is called `complement` in ANSI Common Lisp, but it was not "
"defined in earlier versions, so it is given here:"
msgstr ""
"Теперь нам нужна функция более высокого порядка, которая возвращает "
"дополнение функции.\n"
"Другими словами, принимая `=`, мы хотим вернуть `/=`.\n"
"Эта функция называется  `complement/дополнением` в ANSI Common Lisp, но она "
"не была определена в более ранних версиях, поэтому она приведена здесь:"

#: in/chapter3.md:2228
msgid ""
"```lisp\n"
"(defun complement (fn)\n"
"  \"If FN returns y, then (complement FN) returns (not y).\"\n"
"  ;; This function is built-in in ANSI Common Lisp,\n"
"  ;; but is defined here for those with non-ANSI compilers.\n"
"  #'(lambda (&rest args) (not (apply fn args))))\n"
"```"
msgstr ""

#: in/chapter3.md:2234
msgid ""
"When `find-all` is called with a given `:test` predicate, all we have to do "
"is call `remove` with the complement as the `:test` predicate.\n"
"This is true even when the `:test` function is not specified, and therefore "
"defaults to `eql`.\n"
"We should also test for when the user specifies the `:test-not` predicate, "
"which is used to specify that the match succeeds when the predicate is "
"false.\n"
"It is an error to specify both a `:test` and `:test-not` argument to the "
"same call, so we need not test for that case.\n"
"The definition is:"
msgstr ""
"Когда   `find-all`   вызывается с заданным предикатом   `:test`, все, что "
"нам нужно сделать, это вызвать   `remove`   с дополнением в качестве "
"предиката   `:test`.\n"
"Это верно даже тогда, когда функция   `:test`   не задана и поэтому по "
"умолчанию используется значение `eql`.\n"
"Мы также должны проверить, когда пользователь указывает предикат   `:test-"
"not`, который используется для указания того, что совпадение завершается "
"успешно, когда предикат ложен.\n"
"Будет ошибкой- указывать одновременно как аргумент   `:test`, так и "
"аргумент    `:test-not`   для одного и того же вызова, поэтому нам не нужно "
"проверять такой случай.\n"
"Определение таково:"

#: in/chapter3.md:2246
msgid ""
"```lisp\n"
"(defun find-all (item sequence &rest keyword-args\n"
"                 &key (test #'eql) test-not &allow-other-keys)\n"
"  \"Find all those elements of sequence that match item,\n"
"  according to the keywords.  Doesn't alter sequence.\"\n"
"  (if test-not\n"
"      (apply #'remove item sequence\n"
"             :test-not (complement test-not) keyword-args)\n"
"      (apply #'remove item sequence\n"
"             :test (complement test) keyword-args)))\n"
"```"
msgstr ""

#: in/chapter3.md:2252
msgid ""
"The only hard part about this definition is understanding the parameter "
"list.\n"
"The `&rest` accumulates all the keyword/value pairs in the variable `keyword-"
"args`.\n"
"In addition to the `&rest` parameter, two specific keyword parameters, `:"
"test` and `:test-not`, are specified.\n"
"Any time you put a `&key` in a parameter list, you need an `&allow-other- "
"keys` if, in fact, other keywords are allowed.\n"
"In this case we want to accept keywords like `:start` and `:key` and pass "
"them on to `remove`."
msgstr ""
"Единственная трудная часть этого определения-понимание списка параметров.\n"
"`&rest` собирает в себе все пары ключевое слово/значение в переменой "
"`keyword-args`.\n"
"В дополнение к параметру  `&rest`  задаются два конкретных параметра "
"ключевых слова: `:test`  и  `:test-not`.\n"
"Каждый раз, когда вы помещаете  `&key`  в список параметров, вам нужно "
"(разрешить использовать другие ключевые слова)  `&allow-other-keys`,  если "
"на самом деле другие ключевые слова разрешены.\n"
"В этом случае мы хотим принимать ключевые слова подобные  `:start`  и  `:"
"key`  и передавать их в  `remove`."

#: in/chapter3.md:2255
msgid ""
"All the keyword/value pairs will be accumulated in the list `keyword-args`, "
"including the `:test` or `:test-not` values.\n"
"So we will have:"
msgstr ""
"Все пары ключевое слово/значение будут собираться в списке `keyword-args`, "
"включая значения `:test` или `:test-not`.\n"
"Так что у нас будет:"

#: in/chapter3.md:2261
msgid ""
"```lisp\n"
"(find-all 1 nums :test #'= :key #'abs)\n"
"  = (remove 1 nums :test (complement #'=) :test #'= :key #'abs)\n"
"  => (1 1)\n"
"```"
msgstr ""

#: in/chapter3.md:2264
msgid ""
"Note that the call to `remove` will contain two `:test` keywords.\n"
"This is not an error; Common Lisp declares that the leftmost value is the "
"one that counts."
msgstr ""
"Обратите внимание, что вызов `remove` будет содержать два ключевых слова `:"
"test`.\n"
"Это не ошибка; Common Lisp заявляет, что считается самое левое значение."

#: in/chapter3.md:2266
msgid ""
"&#9635; **Exercise 3.7 [s]** Why do you think the leftmost of two keys is "
"the one that counts, rather than the rightmost?"
msgstr ""
"&#9635; **Упражнение 3.7 [s]** как вы думаете, почему считается самый левый "
"из двух ключей, а не самый правый?"

#: in/chapter3.md:2269
msgid ""
"&#9635; **Exercise 3.8 [m]** Some versions of Kyoto Common Lisp (KCL) have a "
"bug wherein they use the rightmost value when more than one keyword/value "
"pair is specified for the same keyword.\n"
"Change the definition of `find-all` so that it works in KCL."
msgstr ""
"&#9635; **Упражнение 3.8 [m]** некоторые версии Kyoto Common Lisp (KCL) "
"имеют ошибку, при которой они используют самое правое значение, когда для "
"одного и того же ключевого слова задано более одной пары ключевое слово/"
"значение.\n"
"Измените определение 'find-all' так, чтобы оно работало в KCL."

#: in/chapter3.md:2274
msgid ""
"There are two more lambda-list keywords that are sometimes used by advanced "
"programmers.\n"
"First, within a macro definition (but not a function definition), the symbol "
"`&body` can be used as a synonym for `&rest`.\n"
"The difference is that `&body` instructs certain formatting programs to "
"indent the rest as a body.\n"
"Thus, if we defined the macro:"
msgstr ""
"Есть еще два ключевых слова лямбда-списка, которые иногда используются "
"продвинутыми программистами.\n"
"Во-первых, в макроопределении (но не в определении функции) символ `&body` "
"может использоваться как синоним `&rest`.\n"
"Разница в том, что `&body` дает указание определенным программам "
"форматирования делать отступы как тело(body).\n"
"Таким образом, если мы определили макрос:"

#: in/chapter3.md:2281
msgid ""
"```lisp\n"
"(defmacro while2 (test &body body)\n"
"  \"Repeat body while test is true.\"\n"
"  `(loop (if (not ,test) (return nil))\n"
"         . ,body))\n"
"```"
msgstr ""

#: in/chapter3.md:2283
msgid ""
"Then the automatic indentation of `while2` (on certain systems) is prettier "
"than `while`:"
msgstr ""
"Тогда автоматическое отступление `while2` (в некоторых системах) красивее, "
"чем `while`:"

#: in/chapter3.md:2288
msgid ""
"```lisp\n"
"(while (< i 10)\n"
"       (print (* i i))\n"
"       (setf i (+ i 1)))"
msgstr ""

#: in/chapter3.md:2293
msgid ""
"(while2 (< i 10)\n"
"  (print (* i i))\n"
"  (setf i (+ i 1)))\n"
"```"
msgstr ""

#: in/chapter3.md:2299
msgid ""
"Finally, an `&aux` can be used to bind a new local variable or variables, as "
"if bound with `let*`.\n"
"Personally, I consider this an abomination, because `&aux` variables are not "
"parameters at all and thus have no place in a parameter list.\n"
"I think they should be clearly distinguished as local variables with a "
"`let`.\n"
"But some good programmers do use `&aux`, presumably to save space on the "
"page or screen.\n"
"Against my better judgement, I show an example:"
msgstr ""
"Наконец, `&aux` можно использовать для привязки новой локальной переменной "
"или переменных, как если бы они были связаны с `let*`.\n"
"Лично я считаю это мерзостью, потому что переменные `&aux` вообще не "
"являются параметрами и поэтому не должны присутствовать в списке "
"параметров.\n"
"Я думаю, что они должны быть четко выделены как локальные переменные в  "
"`let`.\n"
"Но некоторые хорошие программисты используют `&aux`, вероятно, чтобы "
"сэкономить место на странице или экране.\n"
"Вопреки моему здравому смыслу, я показываю пример:"

#: in/chapter3.md:2305
msgid ""
"```lisp\n"
"(defun length14 (list &aux (len 0))\n"
"  (dolist (element list len)\n"
"    (incf len)))\n"
"```"
msgstr ""

#: in/chapter3.md:2307
msgid "## 3.20 The Rest of Lisp"
msgstr "## 3.20 остальная часть Лиспа"

#: in/chapter3.md:2311
msgid ""
"There is a lot more to Common Lisp than what we have seen here, but this "
"overview should be enough for the reader to comprehend the programs in the "
"chapters to come.\n"
"The serious Lisp programmer will further his or her education by continuing "
"to consult reference books and online documentation.\n"
"You may also find part V of this book to be helpful, particularly [chapter "
"24](chapter24.md), which covers advanced features of Common Lisp (such as "
"packages and error handling) and [chapter 25](chapter25.md), which is a "
"collection of troubleshooting hints for the perplexed Lisper."
msgstr ""
"В Common Lisp есть гораздо больше, чем то, что мы видели здесь, но этого "
"обзора должно быть достаточно, чтобы читатель понял программы в следующих "
"главах.\n"
"Серьезный программист Lisp продолжит свое образование, продолжая обращаться "
"к справочникам и онлайн-документации.\n"
"Вы также можете найти полезной Часть V этой книги, особенно [Главу 24] "
"(chapter24.md), которая охватывает расширенные функции Common Lisp (такие "
"как пакеты(package) и обработка ошибок(error handling)) и [главу 25]"
"(chapter25.md), который представляет собой набор советов по устранению "
"неполадок для озадаченного Лиспера."

#: in/chapter3.md:2314
msgid ""
"While it may be distracting for the beginner to be continually looking at "
"some reference source, the alternative - to explain every new function in "
"complete detail as it is introduced - would be even more distracting.\n"
"It would interrupt the description of the AI programs, which is what this "
"book is all about."
msgstr ""
"В то время как для новичка может быть отвлекающим то, что он постоянно "
"смотрит на какой - то справочный источник, альтернатива - объяснить каждую "
"новую функцию в полном объеме, когда она вводится, - была бы еще более "
"отвлекающей.\n"
"Это прервало бы описание программ искусственного интеллекта, о которых и "
"идет речь в этой книге."

#: in/chapter3.md:2316
msgid "## 3.21 Exercises"
msgstr "## 3.21 Упражнения"

#: in/chapter3.md:2318
msgid ""
"&#9635; **Exercise 3.9 [m]** Write a version of `length` using the function "
"`reduce`."
msgstr ""
"&#9635; **Упражнение 3.9 [m]** напишите версию `length`, используя функцию "
"`reduce`."

#: in/chapter3.md:2320
msgid ""
"&#9635; **Exercise 3.10 [m]** Use a reference manual or `describe` to figure "
"out what the functions `lcm` and `nreconc` do."
msgstr ""
"&#9635; **Упражнение 3.10 [m]** используйте справочное руководство или "
"`describe`, чтобы выяснить, что делают функции `lcm` и `nreconc`."

#: in/chapter3.md:2323
msgid ""
"&#9635; **Exercise 3.11** [m] There is a built-in Common Lisp function that, "
"given a key, a value, and an association list, returns a new association "
"list that is extended to include the key/value pair.\n"
"What is the name of this function?"
msgstr ""
"&#9635; **Упражнение 3.11** [m] существует встроенная функция Common Lisp, "
"которая, учитывая ключ, значение и список ассоциаций, возвращает новый "
"ассоциативный список, расширеный включенной парой ключ/значение.\n"
"Как называется эта функция?"

#: in/chapter3.md:2326
msgid ""
"&#9635; **Exercise 3.12 [m]** Write a single expression using format that "
"will take a list of words and print them as a sentence, with the first word "
"capitalized and a period after the last word.\n"
"You will have to consult a reference to learn new `format` directives."
msgstr ""
"&#9635; **Упражнение 3.12 [m]** напишите одно выражение, используя format, "
"который возьмет список слов и напечатает их как предложение, с заглавной "
"буквой первого слова и точкой после последнего слова.\n"
"Вам придется обратиться к справочнику, чтобы узнать новые директивы `format`."

#: in/chapter3.md:2328
msgid "## 3.22 Answers"
msgstr "## 3.22 Ответы"

#: in/chapter3.md:2330
msgid "**Answer 3.2** `(cons` *a b*) = (`list *` *a b*)"
msgstr ""

#: in/chapter3.md:2332
msgid "**Answer 3.3**"
msgstr ""

#: in/chapter3.md:2342
msgid ""
"```lisp\n"
"(defun dprint (x)\n"
"  \"Print an expression in dotted pair notation.\"\n"
"  (cond ((atom x) (princ x))\n"
"        (t (princ \"(\")\n"
"           (dprint (first x))\n"
"           (pr-rest (rest x))\n"
"           (princ \")\")\n"
"           x)))"
msgstr ""

#: in/chapter3.md:2347
msgid ""
"(defun pr-rest (x)\n"
"  (princ \" . \")\n"
"  (dprint x))\n"
"```"
msgstr ""

#: in/chapter3.md:2349
msgid ""
"**Answer 3.4** Use the same `dprint` function defined in the last exercise, "
"but change `pr-rest`."
msgstr ""
"**Answer 3.4** Используйте ту же самую функцию `dprint`, определенную в "
"последнем упражнении, но измените `pr-rest`."

#: in/chapter3.md:2356
msgid ""
"```lisp\n"
"(defun pr-rest (x)\n"
"  (cond ((null x))\n"
"        ((atom x) (princ \" . \") (princ x))\n"
"        (t (princ \" \") (dprint (first x)) (pr-rest (rest x)))))\n"
"```"
msgstr ""

#: in/chapter3.md:2362
msgid ""
"**Answer 3.5** We will keep a data base called `*db*`.\n"
"The data base is organized into a tree structure of nodes.\n"
"Each node has three fields: the name of the object it represents, a node to "
"go to if the answer is yes, and a node for when the answer is no.\n"
"We traverse the nodes until we either get an \"it\" reply or have to give "
"up.\n"
"In the latter case, we destructively modify the data base to contain the new "
"information."
msgstr ""
"**Ответ 3.5** мы будем называть базу данных `*db*`.\n"
"База данных организована в виде древовидной структуры узлов.\n"
"Каждый узел имеет три поля: Имя объекта, который он представляет, узел, к "
"которому нужно перейти, если ответ \"да\", и узел, когда ответ \"нет\".\n"
"Мы проходим через узлы, пока не получим ответ \"it/это\" или продолжать.\n"
"В последнем случае мы деструктивно модифицируем базу данных, чтобы она "
"содержала новую информацию."

#: in/chapter3.md:2368
msgid ""
"```lisp\n"
"(defstruct node\n"
"  name\n"
"  (yes nil)\n"
"  (no nil))"
msgstr ""

#: in/chapter3.md:2375
msgid ""
"(defvar *db*\n"
"  (make-node :name 'animal\n"
"             :yes (make-node :name 'mammal)\n"
"             :no (make-node\n"
"                   :name 'vegetable\n"
"                   :no (make-node :name 'mineral))))"
msgstr ""

#: in/chapter3.md:2389
msgid ""
"(defun questions (&optional (node *db*))\n"
"  (format t \"~&Is it a ~a? \" (node-name node))\n"
"  (case (read)\n"
"    ((y yes) (if (not (null (node-yes node)))\n"
"                 (questions (node-yes node))\n"
"                 (setf (node-yes node) (give-up))))\n"
"    ((n no)  (if (not (null (node-no node)))\n"
"                 (questions (node-no node))\n"
"                 (setf (node-no node) (give-up))))\n"
"    (it 'aha!)\n"
"    (t (format t \"Reply with YES, NO, or IT if I have guessed it.\")\n"
"       (questions node))))"
msgstr ""

#: in/chapter3.md:2394
msgid ""
"(defun give-up ()\n"
"  (format t \"~&I give up - what is it? \")\n"
"  (make-node :name (read)))\n"
"```"
msgstr ""

#: in/chapter3.md:2396
msgid "Here it is used:"
msgstr "Здесь он используется:"

#: in/chapter3.md:2403
msgid ""
"```lisp\n"
"> (questions)\n"
"Is it a ANIMAL? yes\n"
"Is it a MAMMAL? yes\n"
"I give up - what is it? bear\n"
"#S(NODE :NAME BEAR)"
msgstr ""

#: in/chapter3.md:2409
msgid ""
"> (questions)\n"
"Is it a ANIMAL? yes\n"
"Is it a MAMMAL? no\n"
"I give up - what is it? penguin\n"
"#S(NODE :NAME PENGUIN)"
msgstr ""

#: in/chapter3.md:2416
msgid ""
"> (questions)\n"
"Is it a ANIMAL? yes\n"
"Is it a MAMMAL? yes\n"
"Is it a BEAR? it\n"
"AHA!\n"
"```"
msgstr ""

#: in/chapter3.md:2418
msgid ""
"**Answer 3.6** The value is (`LOCAL-A LOCAL-B LOCAL-B GLOBAL-A LOCAL-B`)."
msgstr ""
"**Ответ 3.6** значение равно (`LOCAL-A LOCAL-B LOCAL-B GLOBAL-A LOCAL-B`)."

#: in/chapter3.md:2422
msgid ""
"The `let` form binds `a` lexically and `*b*` dynamically, so the references "
"to `a` and `*b*` (including the reference to `*b*` within `fn`) all get the "
"local values.\n"
"The function `symbol-value` always treats its argument as a special "
"variable, so it ignores the lexical binding for a and returns the global "
"binding instead.\n"
"However, the `symbol-value` of `*b*` is the local dynamic value."
msgstr ""
"Форма `let` связывает `a` лексически и `*b*` динамически, поэтому ссылки на "
"`a` и `*b*` (включая ссылку на `*b*` внутри `fn`) все получают локальные "
"значения.\n"
"Функция `symbol-value` всегда обрабатывает свой аргумент как специальную "
"переменную, поэтому она игнорирует лексическую привязку для a и возвращает "
"вместо нее глобальную привязку.\n"
"Однако `symbol-value` для  `*b*` является локальным динамическим значением."

#: in/chapter3.md:2425
msgid ""
"**Answer 3.7** There are two good reasons: First, it makes it faster to "
"search through the argument list: just search until you find the key, not "
"all the way to the end.\n"
"Second, in the case where you want to override an existing keyword and pass "
"the argument list on to another function, it is cheaper to `cons` the new "
"keyword/value pair on the front of a list than to append it to the end of a "
"list."
msgstr ""
"**Ответ 3.7** есть две веские причины: Во-первых, это ускоряет поиск по "
"списку аргументов: просто ищите, пока не найдете ключ, а не до конца.\n"
"Во-вторых, в случае, когда вы хотите переопределить существующее ключевое "
"слово и передать список аргументов другой функции, дешевле создать/`cons` "
"новую пару ключевое слово/значение в начале списка, чем добавлять ее в конец "
"списка."

#: in/chapter3.md:2427
msgid "**Answer 3.9**"
msgstr ""

#: in/chapter3.md:2432
msgid ""
"```lisp\n"
"(defun length-r (list)\n"
"  (reduce #'+ (mapcar #'(lambda (x) 1) list)))\n"
"```"
msgstr ""

#: in/chapter3.md:2434
msgid "or more efficiently:"
msgstr "или более эффективно:"

#: in/chapter3.md:2440
msgid ""
"```lisp\n"
"(defun length-r (list)\n"
"  (reduce #'(lambda (x y) (+ x 1)) list\n"
"          :initial-value 0))\n"
"```"
msgstr ""

#: in/chapter3.md:2442
msgid "or, with an ANSI-compliant Common Lisp, you can specify a `:` key"
msgstr "или с ANSI-compliant Common Lisp, вы можете указать ключ `:key`"

#: in/chapter3.md:2447
msgid ""
"```lisp\n"
"(defun length-r (list)\n"
"  (reduce #'+ list :key #'(lambda (x) 1)))\n"
"```"
msgstr ""

#: in/chapter3.md:2449
msgid "**Answer 3.12** `(format t \"~@(~{~a~^ ~).~)\" '(this is a test))`"
msgstr ""

#: in/chapter3.md:2451
msgid "----------------------"
msgstr ""

#: in/chapter3.md:2454
msgid ""
"<a id=\"fn03-1\"></a>\n"
"[[1]](#tfn03-1) Association lists are covered in section 3.6."
msgstr ""
"<a id=\"fn03-1\"></a>\n"
"[[1]](#tfn03-1) Списки ассоциаций рассматриваются в разделе 3.6."

#: in/chapter3.md:2457
msgid ""
"<a id=\"fn03-2\"></a>\n"
"[[2]](#tfn03-2) In mathematics, a function must associate a unique output "
"value with each input value."
msgstr ""
"<a id=\"fn03-2\"></a>\n"
"[[2]](#tfn03-2) В математике функция должна связывать уникальное выходное "
"значение с каждым входным значением."

#: in/chapter3.md:2459
msgid ""
"<a id=\"fn03-3\"></a>\n"
"[[3]](#tfn03-3) A *package* is a symbol table: a mapping between strings and "
"the symbols they name."
msgstr ""
"<a id=\"fn03-3\"></a>\n"
"[[3]](#tfn03-3) *package* - это таблица символов: отображение между строками "
"и символами, которые они именуют."
