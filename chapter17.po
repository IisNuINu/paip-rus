#
# NuINu <don't@send.my>, 2021.
#
#. extracted from in/chapter17.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-18 14:13+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter17.md:3
msgid ""
"# Chapter 17\n"
"## Line-Diagram Labeling by Constraint Satisfaction"
msgstr ""
"# Глава 17\n"
"## Маркировка линейных диаграмм удовлетворением ограничений"

#: in/chapter17.md:6
msgid ""
"> It is wrong to think of Waltz's work only as a statement of the "
"epistemology of line drawings of polyhedra.\n"
"Instead I think it is an elegant case study of a paradigm we can expect to "
"see again and again."
msgstr ""
"> Неверно думать о работе Вальса только как об изложении эпистемологии "
"штриховых рисунков многогранников.\n"
"Вместо этого я думаю, что это элегантный пример парадигмы, которую мы можем "
"ожидать увидеть снова и снова."

#: in/chapter17.md:8
msgid "> -Patrick Winston"
msgstr ""

#: in/chapter17.md:10
msgid "> The Psychology of Computer Vision (1975)"
msgstr ""

#: in/chapter17.md:16
msgid ""
"This book touches only the areas of AI that deal with abstract reasoning.\n"
"There is another side of AI, the field of *robotics,* that deals with "
"interfacing abstract reasoning with the real world through sensors and "
"motors.\n"
"A robot receives input from cameras, microphones, sonar, and touch-sensitive "
"devices, and produces \"ouput\" by moving its appendages or generating "
"sounds.\n"
"The real world is a messier place than the abstract worlds we have been "
"covering.\n"
"A robot must deal with noisy data, faulty components, and other agents and "
"events in the world that can affect changes in the environment."
msgstr ""
"Эта книга касается только тех областей ИИ, которые имеют дело с абстрактными "
"рассуждениями.\n"
"Есть и другая сторона искусственного интеллекта, область *робототехники*, "
"которая связана с взаимодействием абстрактных рассуждений с реальным миром с "
"помощью датчиков и двигателей.\n"
"Робот получает входные данные от камер, микрофонов, сонара и сенсорных "
"устройств и производит \"выходной сигнал\", перемещая свои придатки или "
"генерируя звуки.\n"
"Реальный мир - более беспорядочное место, чем абстрактные миры, которые мы "
"рассматривали.\n"
"Робот должен иметь дело с зашумленными данными, неисправными компонентами и "
"другими агентами и событиями в мире, которые могут повлиять на изменения в "
"окружающей среде."

#: in/chapter17.md:22
msgid ""
"Computer vision is the subfield of robotics that deals with interpreting "
"visual information.\n"
"Low-level vision takes its input directly from a camera and detects lines, "
"regions and textures.\n"
"We will not be concerned with this.\n"
"High-level vision uses the findings of the low-level component to build a "
"three-dimensional model of the objects depicted in the scene.\n"
"This chapter covers one small aspect of high-level vision."
msgstr ""
"Компьютерное зрение - это подраздел робототехники, который занимается "
"интерпретацией визуальной информации.\n"
"Низкоуровневое зрение принимает данные непосредственно с камеры и "
"обнаруживает линии, области и текстуры.\n"
"Мы не будем этим заниматься.\n"
"Высокоуровневое зрение использует результаты низкоуровневого компонента для "
"построения трехмерной модели объектов, изображенных на сцене.\n"
"В этой главе рассматривается один небольшой аспект видения(зрения) высокого "
"уровня."

#: in/chapter17.md:24
msgid "## 17.1 The Line-Labeling Problem"
msgstr "## 17.1 Проблема маркировки строк"

#: in/chapter17.md:27
msgid ""
"In this chapter we look at the line-diagram labeling problem: Given a list "
"of lines and the vertexes at which they intersect, how can we determine what "
"the lines represent?\n"
"For example, given the nine lines in [figure 17.1](#f0010), how can we "
"interpret the diagram as a cube?"
msgstr ""
"В этой главе мы рассмотрим проблему маркировки линейной диаграммы: имея "
"список линий и вершин, в которых они пересекаются, как мы можем определить, "
"что эти линии представляют?\n"
"Например, даны девять линий на [рис. 17.1](#f0010), как мы можем "
"интерпретировать диаграмму как куб?"

#: in/chapter17.md:32
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-01](images/chapter17/f17-01.jpg) |\n"
"| Figure 17.1: A Cube                    |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-01](images/chapter17/f17-01.jpg) |\n"
"| Рисунок 17.1: Куб                     |"

#: in/chapter17.md:41
msgid ""
"Before we can arrive at an interpretation, we have to agree on what the "
"candidates are.\n"
"After all, [figure 17.1](#f0010) could be just a hexagon with three lines in "
"the middle.\n"
"For the purposes of this chapter, we will consider only diagrams that depict "
"one or more *polyhedra-*three-dimensional solid figures whose surfaces are "
"flat faces bounded by straight lines.\n"
"In addition, we will only allow *trihedral* vertexes.\n"
"That is, each vertex must be formed by the intersection of three faces, as "
"in the corner of a cube, where the top, front, and side of the cube come "
"together.\n"
"A third restriction on diagrams is that no so-called *accidental* vertexes "
"are allowed.\n"
"For example, [figure 17.1](#f0010) might be a picture of three different "
"cubes hanging in space, which just happen to line up so that the edge of one "
"is aligned with the edge of another from our viewpoint.\n"
"We will assume that this is not the case."
msgstr ""
"Прежде чем мы сможем пререйти к интерпретации, мы должны договориться о "
"кандидатах.\n"
"В конце концов, [рисунок 17.1](#f0010) может быть просто шестиугольником с "
"тремя линиями посередине.\n"
"Для целей этой главы мы будем рассматривать только диаграммы, которые "
"изображают один или несколько *многогранников-* трехмерных твердых фигур, "
"поверхности которых являются плоскими гранями, ограниченными прямыми "
"линиями.\n"
"Кроме того, мы разрешаем только *трехгранные* вершины.\n"
"То есть каждая вершина должна быть образована пересечением трех граней, как "
"в углу куба, где вершина, передняя часть и сторона куба сходятся.\n"
"Третье ограничение на диаграммы - недопустимость так называемых \"случайных"
"\" вершин.\n"
"Например, [рисунок 17.1](#f0010) может быть изображением трех разных "
"кубиков, висящих в пространстве, которые случайно выстраиваются так, что "
"край одного выровнен с краем другого с нашей точки зрения.\n"
"Предположим, что это не так."

#: in/chapter17.md:43
msgid ""
"Given a diagram that fits these three restrictions, our goal is to identify "
"each line, placing it in one of three classes:"
msgstr ""
"Учитывая диаграмму, которая соответствует этим трем ограничениям, наша цель "
"- идентифицировать каждую линию, помещая ее в один из трех классов:"

#: in/chapter17.md:47
msgid ""
"1.  A convex line separates two visible faces of a polyhedron such that a "
"line from one face to the other would lie inside the polyhedron.\n"
"It will be marked with a plus sign:+.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Выпуклая линия разделяет две видимые грани многогранника так, что прямая "
"от одной грани до другой проходит внутри многогранника.\n"
"Он будет отмечен знаком плюс: +.\n"
"!!!(p) {:.numlist}"

#: in/chapter17.md:51
msgid ""
"2.  A concave line separates two faces of two polyhedra such that a line "
"between the two spaces would pass through empty space.\n"
"It will be marked with a minus sign:-.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  Вогнутая линия разделяет две грани двух многогранников, так что линия "
"между двумя пространствами проходит через пустое пространство.\n"
"Он будет отмечен знаком минус: -.\n"
"!!!(p) {:.numlist}"

#: in/chapter17.md:57
msgid ""
"3.  A boundary line denotes the same physical situation as a convex line, "
"but the diagram is oriented in such a way that only one of the two faces of "
"the polyhedron is visible.\n"
"Thus, the line marks the boundary between the polyhedron and the "
"background.\n"
"It will be marked with an arrow:&rarr;.\n"
"Traveling along the line from the tail to the point of the arrow, the "
"polyhedron is on the right, and the background is on the left.\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Граничная линия обозначает ту же физическую ситуацию, что и выпуклая "
"линия, но диаграмма ориентирована таким образом, что видна только одна из "
"двух граней многогранника.\n"
"Таким образом, линия отмечает границу между многогранником и фоном.\n"
"Он будет отмечен стрелкой: &rarr ;.\n"
"Двигаясь по линии от хвоста до точки стрелки, многогранник находится справа, "
"а фон - слева.\n"
"!!!(p) {:.numlist}"

#: in/chapter17.md:62
msgid ""
"[Figure 17.2](#f0015) shows a labeling of the cube using these conventions.\n"
"Vertex A is the near corner of the cube, and the three lines coming out of "
"it are all convex lines.\n"
"Lines GD and DF are concave lines, indicating the junction between the cube "
"and the surface on which it is resting.\n"
"The remaining lines are boundary lines, indicating that there is no physical "
"connection between the cube and the background there, but that there are "
"other sides of the cube that cannot be seen."
msgstr ""
"[Рисунок 17.2](#f0015) показывает маркировку куба с использованием этих "
"соглашений.\n"
"Вершина A - это ближний угол куба, а три выходящие из нее прямые - "
"выпуклые.\n"
"Линии GD и DF - вогнутые линии, обозначающие стык между кубом и "
"поверхностью, на которой он лежит.\n"
"Остальные линии являются граничными линиями, указывающими на то, что между "
"кубом и фоном нет физической связи, но есть другие стороны куба, которые "
"нельзя увидеть."

#: in/chapter17.md:67
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-02](images/chapter17/f17-02.jpg) |\n"
"| Figure 17.2: A Line-labeled Cube       |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-02](images/chapter17/f17-02.jpg) |\n"
"| Рисунок 17.2: Куб, помеченный линией       |"

#: in/chapter17.md:76
msgid ""
"The line-labeling technique developed in this chapter is based on a simple "
"idea.\n"
"First we enumerate all the possible vertexes, and all the possible labelings "
"for each vertex.\n"
"It turns out there are only four different vertex types in the trihedral "
"polygon world.\n"
"We call them L, Y, W, and T vertexes, because of their shape.\n"
"The Y and W vertexes are also known as forks and arrows, respectively.\n"
"The vertexes are listed in [figure 17.3](#f0020).\n"
"Each vertex imposes some constraints on the lines that compose it.\n"
"For example, in a W vertex, the middle line can be labeled with a + or -, "
"but not with an arrow."
msgstr ""
"Техника маркировки линий, разработанная в этой главе, основана на простой "
"идее.\n"
"Сначала мы перечисляем все возможные вершины и все возможные обозначения для "
"каждой вершины.\n"
"Оказывается, в мире трехгранных многоугольников всего четыре разных типа "
"вершин.\n"
"Мы называем их вершинами L, Y, W и T. из-за их формы.\n"
"Вершины Y и W также называются вилками и стрелками соответственно.\n"
"Вершины перечислены на [рисунок 17.3](#f0020).\n"
"Каждая вершина накладывает некоторые ограничения на составляющие ее линии.\n"
"Например, в вершине W средняя линия может быть помечена знаком + или -, но "
"не стрелкой."

#: in/chapter17.md:81
msgid ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-03](images/chapter17/f17-03.jpg)        |\n"
"| Figure 17.3: The Possible Vertexes and Labels |"
msgstr ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-03](images/chapter17/f17-03.jpg)        |\n"
"| Рисунок 17.3: Возможные вершины и метки       |"

#: in/chapter17.md:93
msgid ""
"Each line connects two vertexes, so it must satisfy both constraints.\n"
"This suggests a simple algorithm for labeling a diagram based on constraint "
"propagation: First, label each vertex with all the possible labelings for "
"the vertex type.\n"
"An L vertex has six possibilities, Y has five, T has four, and W has three.\n"
"Next, pick a vertex, V.\n"
"Consider a neighboring vertex, N (that is, N and V are connected by a "
"line).\n"
"N will also have a set of possible labelings.\n"
"If N and V agree on the possible labelings for the line between them, then "
"we have gained nothing.\n"
"But if the intersection of the two possibility sets is smaller than V's "
"possibility set, then we have found a constraint on the diagram.\n"
"We adjust N and V's possible labelings accordingly.\n"
"Every time we add a constraint at a vertex, we repeat the whole process for "
"all the neighboring vertexes, to give the constraint a chance to propagate "
"as far as possible.\n"
"When every vertex has been visited at least once and there are no more "
"constraints to propagate, then we are done."
msgstr ""
"Каждая линия соединяет две вершины, поэтому должна удовлетворять обоим "
"ограничениям.\n"
"Это предлагает простой алгоритм для разметки диаграммы, основанный на "
"распространении ограничений: сначала пометьте каждую вершину всеми "
"возможными метками для типа вершины.\n"
"L вершина имеет шесть возможностей, Y - пять, T - четыре, а W - три.\n"
"Затем выберите вершину V.\n"
"Рассмотрим соседнюю вершину N (то есть N и V соединены линией).\n"
"N также будет иметь набор возможных меток.\n"
"Если N и V согласовывают возможные обозначения линии между ними, то мы "
"ничего не выиграем.\n"
"Но если пересечение двух множеств возможностей меньше, чем множество "
"возможностей V, то мы нашли ограничение на диаграмме.\n"
"Мы соответствующим образом корректируем возможные маркировки N и V.\n"
"Каждый раз, когда мы добавляем ограничение в вершину, мы повторяем весь "
"процесс для всех соседних вершин, чтобы дать ограничению возможность "
"распространиться как можно дальше.\n"
"Когда каждая вершина была посещена хотя бы один раз и больше нет ограничений "
"для распространения, тогда мы закончили."

#: in/chapter17.md:100
msgid ""
"[Figure 17.4](#f0025) illustrates this process.\n"
"On the left we start with a cube.\n"
"All vertexes have all possible labelings, except that we know line GD is "
"concave (-), indicating that the cube is resting on a surface.\n"
"This constrains vertex D in such a way that line DA must be convex (+).\n"
"In the middle picture the constraint on vertex D has propagated to vertex A, "
"and in the right-hand picture it propagates to vertex B.\n"
"Soon, the whole cube will be uniquely labeled."
msgstr ""
"[Рисунок 17.4](#f0025) иллюстрирует этот процесс.\n"
"Слева начинаем с куба.\n"
"Все вершины имеют все возможные обозначения, за исключением того, что мы "
"знаем, что линия GD вогнута (-), что означает, что куб покоится на "
"поверхности.\n"
"Это ограничивает вершину D таким образом, что прямая DA должна быть выпуклой "
"(+).\n"
"На среднем рисунке ограничение на вершину D распространилось на вершину A, а "
"на правом рисунке оно распространяется на вершину B.\n"
"Скоро весь куб будет промаркирован уникальными метками."

#: in/chapter17.md:105
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-04](images/chapter17/f17-04.jpg) |\n"
"| Figure 17.4: Propagating Constraints   |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-04](images/chapter17/f17-04.jpg) |\n"
"| Рисунок 17.4: Распространение ограничений   |"

#: in/chapter17.md:112
msgid ""
"Many diagrams will be labeled uniquely by this constraint propagation "
"process.\n"
"Some diagrams, however, are ambiguous.\n"
"They will still have multiple labelings after constraint propagation has "
"finished.\n"
"In this case, we can search for a solution.\n"
"Simply choose an ambiguous vertex, choose one of the possible labelings for "
"that vertex, and repeat the constraint propagation/search process.\n"
"Keep going until the diagram is either unambiguous or inconsistent."
msgstr ""
"Многие диаграммы будут иметь уникальные(однозначно расставленные) метки в "
"процессе распространения ограничений.\n"
"Однако некоторые диаграммы неоднозначны.\n"
"У них все еще будет несколько меток после завершения распространения "
"ограничения.\n"
"В этом случае мы можем искать решение.\n"
"Просто выберите неоднозначную вершину, выберите одну из возможных меток для "
"этой вершины и повторите процесс распространения/поиска ограничения.\n"
"Продолжайте, пока диаграмма не станет однозначной или противоречивой."

#: in/chapter17.md:116
msgid ""
"That completes the sketch of the line-labeling algorithm.\n"
"We are now ready to implement a labeling program.\n"
"It's glossary is in [figure 17.5](#f0030)."
msgstr ""
"На этом набросок алгоритма маркировки линий завершен.\n"
"Теперь мы готовы к реализации программы маркировки.\n"
"Её глоссарий находится на [рис. 17.5](#f0030)."

#: in/chapter17.md:121
msgid ""
"| []()                                                |\n"
"|-----------------------------------------------------|\n"
"| ![f17-05](images/chapter17/f17-05.jpg)              |\n"
"| Figure 17.5: Glossary for the Line-Labeling Program |"
msgstr ""
"| []()                                                |\n"
"|-----------------------------------------------------|\n"
"| ![f17-05](images/chapter17/f17-05.jpg)              |\n"
"| Рисунок 17.5: Глоссарий программы маркировки линий |"

#: in/chapter17.md:123
msgid "*(ed: should be a markdown table)*"
msgstr ""

#: in/chapter17.md:126
msgid ""
"The two main data structures are the di agram and the vertex.\n"
"It would have been possible to implement a data type for `lines`, but it is "
"not necessary: lines are defined implicitly by the two vertexes at their end "
"points."
msgstr ""
"Две основные структуры данных - это диаграмма(diagram) и вершина(vertex).\n"
"Можно было бы реализовать тип данных для `lines`(линий), но это не "
"обязательно: линии неявно определяются двумя вершинами в их конечных точках."

#: in/chapter17.md:136
msgid ""
"A diagram is completely specified by its list of vertexes, so the structure "
"di agram needs only one slot.\n"
"A vertex, on the other hand, is a more complex structure.\n"
"Each vertex has an identifying name (usually a single letter), a vertex type "
"(L, Y, W, or T), a list of neighboring vertexes, and a list of possible "
"labelings.\n"
"A labeling is a list of line labels.\n"
"For example, a Y vertex will initially have a list of five possible "
"labelings.\n"
"If it is discovered that the vertex is the interior of a concave corner, "
"then it will have the single labeling ( - - - ).\n"
"We give type information on the slots of vertex because it is a complicated "
"data type.\n"
"The syntax of defstruct is such that you cannot specify a : type without "
"first specifying a default value.\n"
"We chose L as the default value for the type slot at random, but note that "
"it would have been an error to give `nil` as the default value, because "
"`nil` is not of the right type."
msgstr ""
"Диаграмма полностью определяется списком вершин, поэтому для структы  "
"diagram(диаграммы) нужен только один слот.\n"
"vertex(Вершина) же - более сложная структура.\n"
"Каждая вершина имеет идентифицирующее имя(name) (обычно из одной буквы), тип "
"вершины(type) (L, Y, W или T), список соседних вершин(neighboring) и список "
"возможных меток/марок(possible labelings).\n"
"Маркировка(labeling) - это список меток линии.\n"
"Например, вершина Y изначально будет иметь список из пяти возможных меток.\n"
"Если обнаруживается, что вершина является внутренней частью вогнутого угла, "
"то она будет иметь единственную маркировку (- - -).\n"
"Мы даем информацию о типе в слотах вершины, потому что это сложный тип "
"данных.\n"
"Синтаксис defstruct таков, что вы не можете указать: тип(type) без "
"предварительного указания значения по умолчанию.\n"
"Мы выбрали L в качестве значения по умолчанию для слота типа случайным "
"образом, но обратите внимание, что было бы ошибкой указать `nil` в качестве "
"значения по умолчанию, потому что `nil` не относится к правильному типу."

#: in/chapter17.md:139
msgid ""
"```lisp\n"
"(defstruct diagram \"A diagram is a list of vertexes.\" vertexes)"
msgstr ""

#: in/chapter17.md:146
msgid ""
"(defstruct (vertex (:print-function print-vertex))\n"
"  (name      nil :type atom)\n"
"  (type      'L  :type (member L Y W T))\n"
"  (neighbors nil :type list)  ; of vertex\n"
"  (labelings nil :type list)) ; of lists of (member + - L R)))))\n"
"```"
msgstr ""

#: in/chapter17.md:155
msgid ""
"An ambiguous vertex will have several labelings, while an unambiguous vertex "
"has exactly one, and a vertex with no labelings indicates an impossible "
"diagram.\n"
"Initially we don't know which vertexes are what, so they all start with "
"several possible labelings.\n"
"Note that a labeling is a list, not a set: the order of the labels is "
"significant and matches the order of the neighboring vertexes.\n"
"The function possible-labelings gives a list of all possible labelings for "
"each vertex type.\n"
"We use R and L instead of arrows as labels, because the orientation of the "
"arrows is significant.\n"
"An R means that as you travel from the vertex to its neighbor, the "
"polyhedron is on the right and the background object is on the left.\n"
"Thus, an R is equivalent to an arrow pointing away from the vertex.\n"
"The L is just the reverse."
msgstr ""
"Неоднозначная вершина будет иметь несколько маркировок, в то время как "
"однозначная вершина имеет ровно одну, а вершина без маркировки указывает на "
"невозможную диаграмму.\n"
"Изначально мы не знаем, какие вершины какие, поэтому все они начинаются с "
"нескольких возможных обозначений.\n"
"Обратите внимание, что маркировка - это список, а не набор: порядок меток "
"имеет значение и соответствует порядку соседних вершин.\n"
"Функция possible-labelings дает список всех возможных маркировок для каждого "
"типа вершины.\n"
"Мы используем R и L вместо стрелок в качестве меток, потому что ориентация "
"стрелок имеет значение.\n"
"R означает, что когда вы путешествуете от вершины к ее соседу, многогранник "
"находится справа, а фоновый объект - слева.\n"
"Таким образом, R эквивалентно стрелке, указывающей от вершины.\n"
"Буква L как раз наоборот."

#: in/chapter17.md:160
msgid ""
"```lisp\n"
"(defun ambiguous-vertex-p (vertex)\n"
"  \"A vertex is ambiguous if it has more than one labeling.\"\n"
"  (> (number-of-labelings vertex) 1))"
msgstr ""

#: in/chapter17.md:163
msgid ""
"(defun number-of-labelings (vertex)\n"
"  (length (vertex-labelings vertex)))"
msgstr ""

#: in/chapter17.md:167
msgid ""
"(defun impossible-vertex-p (vertex)\n"
"  \"A vertex is impossible if it has no labeling.\"\n"
"  (null (vertex-labelings vertex)))"
msgstr ""

#: in/chapter17.md:171
msgid ""
"(defun impossible-diagram-p (diagram)\n"
"  \"An impossible diagram is one with an impossible vertex.\"\n"
"  (some #'impossible-vertex-p (diagram-vertexes diagram)))"
msgstr ""

#: in/chapter17.md:182
msgid ""
"(defun possible-labelings (vertex-type)\n"
"  \"The list of possible labelings for a given vertex type.\"\n"
"  ;; In these labelings, R means an arrow pointing away from\n"
"  ;; the vertex, L means an arrow pointing towards it.\n"
"  (case vertex-type\n"
"    ((L) '((R L)   (L R)   (+ R)   (L +)   (- L)   (R -)))\n"
"    ((Y) '((+ + +) (- - -) (L R -) (- L R) (R - L)))\n"
"    ((T) '((R L +) (R L -) (R L L) (R L R)))\n"
"    ((W) '((L R +) (- - +) (+ + -)))))\n"
"```"
msgstr ""

#: in/chapter17.md:184
msgid "## 17.2 Combining Constraints and Searching"
msgstr "## 17.2 Комбинирование ограничений и поиска"

#: in/chapter17.md:187
msgid ""
"The main function `print-labelings` takes a diagram as input, reduces the "
"number of labelings on each vertex by constraint propagation, and then "
"searches for all consistent interpretations.\n"
"Output is printed before and after each step."
msgstr ""
"Основная функция `print-labelings` принимает диаграмму в качестве входных "
"данных, уменьшает количество меток на каждой вершине путем распространения "
"ограничений, а затем выполняет поиск всех согласованных интерпретаций.\n"
"Вывод печатается до и после каждого шага."

#: in/chapter17.md:205
msgid ""
"```lisp\n"
"(defun print-labelings (diagram)\n"
"  \"Label the diagram by propagating constraints and then\n"
"  searching for solutions if necessary.  Print results.\"\n"
"  (show-diagram diagram \"~&The initial diagram is:\")\n"
"  (every #'propagate-constraints (diagram-vertexes diagram))\n"
"  (show-diagram diagram\n"
"                \"~2&After constraint propagation the diagram is:\")\n"
"  (let* ((solutions (if (impossible-diagram-p diagram)\n"
"                        nil\n"
"                        (search-solutions diagram)))\n"
"         (n (length solutions)))\n"
"    (unless (= n 1)\n"
"      (format t \"~2&There are ~r solution~:p:\" n)\n"
"      (mapc #'show-diagram solutions)))\n"
"  (values))\n"
"```"
msgstr ""

#: in/chapter17.md:210
msgid ""
"The function `propagate-constraints` takes a vertex and considers the "
"constraints imposed by neighboring vertexes to get a list of all the "
"`consistent-labelings` for the vertex.\n"
"If the number of consistent labelings is less than the number before we "
"started, then the neighbors' constraints have had an effect on this vertex, "
"so we propagate the new-found constraints on this vertex back to each "
"neighbor.\n"
"The function returns nil and thus immediately stops the propagation if there "
"is an impossible vertex.\n"
"Otherwise, propagation continues until there are no more changes to the "
"labelings."
msgstr ""
"Функция `propagate-constraints`(распространять-ограничения) берет вершину и "
"рассматривает ограничения, налагаемые соседними вершинами, чтобы получить "
"список всех `propagate-constraints`(согласованных маркировок) для вершины.\n"
"Если количество согласованных маркировок меньше, чем количество до того, как "
"мы начали, тогда ограничения соседей повлияли на эту вершину, поэтому мы "
"распространяем вновь найденные ограничения на эту вершину обратно каждому "
"соседу.\n"
"Функция возвращает nil и, таким образом, немедленно останавливает "
"распространение, если есть невозможная вершина.\n"
"В противном случае распространение продолжается до тех пор, пока не "
"останется никаких изменений в маркировке."

#: in/chapter17.md:217
msgid ""
"The whole propagation algorithm is started by a call to `every in print-"
"labelings,` which propagates constraints from each vertex in the diagram.\n"
"But it is not obvious that this is all that is required.\n"
"After propagating from each vertex once, couldn't there be another vertex "
"that needs relabeling?\n"
"The only vertex that could possibly need relabeling would be one that had a "
"neighbor changed since its last update.\n"
"But any such vertex would have been visited by `propagate-constraint,` since "
"we propagate to all neighbors.\n"
"Thus, a single pass through the vertexes, compounded with recursive calls, "
"will find and apply all possible constraints."
msgstr ""
"Весь алгоритм распространения запускается вызовом `every in print-labelings,"
"` который распространяет ограничения из каждой вершины диаграммы.\n"
"Но не очевидно, что это все, что требуется.\n"
"Разве после однократного распространения из каждой вершины не может быть "
"другой вершины, которую нужно изменить?\n"
"Единственная вершина, которая может нуждаться в перемаркировке, - это та, у "
"которой был изменен сосед с момента ее последнего обновления.\n"
"Но любую такую вершину посетило бы `propagate-constraint` (распространение "
"ограничения), поскольку мы распространяемся на всех соседей.\n"
"Таким образом, за один проход по вершинам в сочетании с рекурсивными "
"вызовами будут найдены и применены все возможные ограничения."

#: in/chapter17.md:221
msgid ""
"The next question worth asking is if the algorithm is guaranteed to "
"terminate.\n"
"Clearly, it is, because `propagate-constraints` can only produce recursive "
"calls when it removes a labeling.\n"
"But since there are a finite number of labelings initially (no more than six "
"per vertex), there must be a finite number of calls to `propagate-"
"constraints.`"
msgstr ""
"Следующий вопрос, который стоит задать, - гарантировано ли завершение работы "
"алгоритма.\n"
"Ясно, что это так, потому что `propagate-constraints`(распространение "
"ограничения) может производить рекурсивные вызовы только тогда, когда "
"удаляет метку.\n"
"Но так как изначально существует конечное число разметок (не более шести на "
"вершину), должно быть конечное количество вызовов для `propagate-constraints."
"`"

#: in/chapter17.md:234
msgid ""
"```lisp\n"
"(defun propagate-constraints (vertex)\n"
"  \"Reduce the labelings on vertex by considering neighbors.\n"
"  If we can reduce, propagate the constraints to each neighbor.\"\n"
"  ;; Return nil only when the constraints lead to an impossibility\n"
"  (let ((old-num (number-of-labelings vertex)))\n"
"    (setf (vertex-labelings vertex) (consistent-labelings vertex))\n"
"    (unless (impossible-vertex-p vertex)\n"
"      (when (< (number-of-labelings vertex) old-num)\n"
"        (every #'propagate-constraints (vertex-neighbors vertex)))\n"
"      t)))\n"
"```"
msgstr ""

#: in/chapter17.md:239
msgid ""
"The function `consistent-labelings` is passed a vertex.\n"
"It gets all the labels for this vertex from the neighboring vertexes, "
"collecting them in `neighbor-labels`.\n"
"It then checks all the labels on the current vertex, keeping only the ones "
"that are consistent with all the neighbors' constraints.\n"
"The auxiliary function `labels-for` finds the labels for a particular "
"neighbor at a vertex, and reverse-1 abel accounts for the fact that L and R "
"labels are interpreted with respect to the vertex they point at."
msgstr ""
"Вершина передается функции `consistent-labelings`(согласовать метки).\n"
"Она получает все метки для этой вершины от соседних вершин, собирая их в "
"`neighbor-labels`(метки соседей).\n"
"Затем она проверяет все метки на текущей вершине, оставляя только те, "
"которые согласуются со всеми ограничениями соседей.\n"
"Вспомогательная функция `labels-for` находит метки для конкретного соседа у "
"вершины, и `reverse-label` учитывает тот факт, что метки L и R "
"интерпретируются относительно вершины, на которую они указывают."

#: in/chapter17.md:255
msgid ""
"```lisp\n"
"(defun consistent-labelings (vertex)\n"
"  \"Return the set of labelings that are consistent with neighbors.\"\n"
"  (let ((neighbor-labels\n"
"          (mapcar #'(lambda (neighbor) (labels-for neighbor vertex))\n"
"                  (vertex-neighbors vertex))))\n"
"    ;; Eliminate labelings that don't have all lines consistent\n"
"    ;; with the corresponding line's label from the neighbor.\n"
"    ;; Account for the L-R mismatch with reverse-label.\n"
"    (find-all-if\n"
"      #'(lambda (labeling)\n"
"          (every #'member (mapcar #'reverse-label labeling)\n"
"                 neighbor-labels))\n"
"      (vertex-labelings vertex))))\n"
"```"
msgstr ""

#: in/chapter17.md:264
msgid ""
"Constraint propagation is often sufficient to yield a unique "
"interpretation.\n"
"But sometimes the diagram is still underconstrained, and we will have to "
"search for solutions.\n"
"The function `search-solutions` first checks to see if the diagram is "
"ambiguous, by seeing if it has an ambiguous vertex, v.\n"
"If the diagram is unambiguous, then it is a solution, and we return it (in a "
"list, `since search-solutions` is designed to return a list of all "
"solutions).\n"
"Otherwise, for each of the possible labelings for the ambiguous vertex, we "
"create a brand new copy of the diagram and set v's labeling in the copy to "
"one of the possible labelings.\n"
"In effect, we are guessing that a labeling is a correct one.\n"
"We call `propagate-constraints;` if it falls, then we have guessed wrong, so "
"there are no solutions with this labeling.\n"
"But if it succeeds, then we call `search-solutions` recursively to give us "
"the list of solutions generated by this labeling."
msgstr ""
"Распространения ограничений часто бывает достаточно, чтобы получить "
"уникальную интерпретацию.\n"
"Но иногда диаграмма все же недостаточно ограничена, и нам придется выполнить "
"поиск для решения.\n"
"Функция `search-solutions` сначала проверяет, является ли диаграмма "
"неоднозначной, проверяя, есть ли у нее неоднозначная вершина v.\n"
"Если диаграмма недвусмысленна(т.е однозначна), то это решение, и мы его "
"возвращаем (в виде списка, поскольку `since search-solutions` предназначен "
"для возврата списка всех решений).\n"
"В противном случае для каждой из возможных меток для неоднозначной вершины "
"мы создаем новую копию диаграммы и устанавливаем метку вершины v в копии в "
"одну из возможных меток.\n"
"Фактически, мы предполагаем, что маркировка правильная.\n"
"Мы вызываем `propagate-constraints;` если она возвращает сбой(fails), "
"значит, мы ошиблись, поэтому нет никаких решений с такой маркировкой(метка "
"установлена не правильно).\n"
"Но если она возвращает успех, мы рекурсивно вызываем `search-solutions`, "
"чтобы получить список решений, сгенерированных с этой меткой."

#: in/chapter17.md:286
msgid ""
"```lisp\n"
"(defun search-solutions (diagram)\n"
"  \"Try all labelings for one ambiguous vertex, and propagate.\"\n"
"  ;; If there is no ambiguous vertex, return the diagram.\n"
"  ;; If there is one, make copies of the diagram trying each of\n"
"  ;; the possible labelings.  Propagate constraints and append\n"
"  ;; all the solutions together.\n"
"  (let ((v (find-if #'ambiguous-vertex-p\n"
"                    (diagram-vertexes diagram))))\n"
"    (if (null v)\n"
"        (list diagram)\n"
"        (mapcan\n"
"          #'(lambda (v-labeling)\n"
"              (let* ((diagram2 (make-copy-diagram diagram))\n"
"                     (v2 (find-vertex (vertex-name v) diagram2)))\n"
"                (setf (vertex-labelings v2) (list v-labeling))\n"
"                (if (propagate-constraints v2)\n"
"                    (search-solutions diagram2)\n"
"                    nil)))\n"
"          (vertex-labelings v)))))\n"
"```"
msgstr ""

#: in/chapter17.md:289
msgid ""
"That's all there is to the algorithm; all that remains are some auxiliary "
"functions.\n"
"Here are three of them:"
msgstr ""
"Вот и все, что касается алгоритма; остались лишь вспомогательные функции.\n"
"Вот три из них:"

#: in/chapter17.md:296
msgid ""
"```lisp\n"
"(defun labels-for (vertex from)\n"
"  \"Return all the labels for the line going to vertex.\"\n"
"  (let ((pos (position from (vertex-neighbors vertex))))\n"
"    (mapcar #'(lambda (labeling) (nth pos labeling))\n"
"            (vertex-labelings vertex))))"
msgstr ""

#: in/chapter17.md:300
msgid ""
"(defun reverse-label (label)\n"
"  \"Account for the fact that one vertex's right is another's left.\"\n"
"  (case label (L 'R) (R 'L) (otherwise label)))"
msgstr ""

#: in/chapter17.md:305
msgid ""
"(defun find-vertex (name diagram)\n"
"  \"Find the vertex in the given diagram with the given name.\"\n"
"  (find name (diagram-vertexes diagram) :key #'vertex-name))\n"
"```"
msgstr ""

#: in/chapter17.md:311
msgid ""
"Here are the printing functions.\n"
"`print-vertex` prints a vertex in short form.\n"
"It obeys the `print` convention of returning the first argument.\n"
"The functions `show-vertex` and `show-diagram` print more de tailed forms.\n"
"They obey the convention f or `describe`-like functions of returning no "
"values at all."
msgstr ""
"Вот функции печати.\n"
"`print-vertex` печатает вершину в краткой форме.\n"
"Она подчиняется соглашению `print` о возврате первого аргумента.\n"
"Функции `show-vertex` и `show-diagram` печатают более подробные формы.\n"
"Они подчиняются соглашению о функциях, подобных `describe`, т.е. о том, что "
"они вообще не возвращают никаких значений."

#: in/chapter17.md:319
msgid ""
"```lisp\n"
"(defun print-vertex (vertex stream depth)\n"
"  \"Print a vertex in the short form.\"\n"
"  (declare (ignore depth))\n"
"  (format stream \"~a/~d\" (vertex-name vertex)\n"
"          (number-of-labelings vertex))\n"
"  vertex)"
msgstr ""

#: in/chapter17.md:329
msgid ""
"(defun show-vertex (vertex &optional (stream t))\n"
"  \"Print a vertex in a long form, on a new line.\"\n"
"  (format stream \"~&   ~a ~d:\" vertex (vertex-type vertex))\n"
"  (mapc #'(lambda (neighbor labels)\n"
"            (format stream \" ~a~a=[~{~a~}]\" (vertex-name vertex)\n"
"                    (vertex-name neighbor) labels))\n"
"        (vertex-neighbors vertex)\n"
"        (matrix-transpose (vertex-labelings vertex)))\n"
"  (values))"
msgstr ""

#: in/chapter17.md:341
msgid ""
"(defun show-diagram (diagram &optional (title \"~2&Diagram:\")\n"
"                             (stream t))\n"
"  \"Print a diagram in a long form.  Include a title.\"\n"
"  (format stream title)\n"
"  (mapc #'show-vertex (diagram-vertexes diagram))\n"
"  (let ((n (reduce #'* (mapcar #'number-of-labelings\n"
"                               (diagram-vertexes diagram)))))\n"
"  (when (> n 1)\n"
"    (format stream \"~&For ~:d interpretation~:p.\" n))\n"
"  (values)))\n"
"```"
msgstr ""

#: in/chapter17.md:344
msgid ""
"`Note` that `matrix-transpose` is called by `show-vertex` to turn the matrix "
"of labelings on its side.\n"
"It works like this:"
msgstr ""
"Обратите внимание, что `matrix-transpose` вызывается `show-vertex`, чтобы "
"перевернуть матрицу меток на свою сторону.\n"
"Это работает так:"

#: in/chapter17.md:357
msgid ""
"```lisp\n"
"(possible-labelings 'Y)\n"
"((+ + +)\n"
"  (- - -)\n"
"  (L R -)\n"
"  (- L R)\n"
"  (R - L))\n"
"(matrix-transpose (possible-labelings 'Y))\n"
"((+ - L - R)\n"
"  (+ - R L -)\n"
"  (+ - - R L))\n"
"```"
msgstr ""

#: in/chapter17.md:360
msgid ""
"The implementation of `matrix-transpose` is surprisingly concise.\n"
"It is an old Lisp trick, and well worth understanding:"
msgstr ""
"Реализация `matrix-transpose` на удивление лаконична.\n"
"Это старый Lisp-трюк, и его стоит понять:"

#: in/chapter17.md:366
msgid ""
"```lisp\n"
"(defun matrix-transpose (matrix)\n"
"  \"Turn a matrix on its side.\"\n"
"  (if matrix (apply #'mapcar #'list matrix)))\n"
"```"
msgstr ""

#: in/chapter17.md:376
msgid ""
"The remaining code has to do with creating diagrams.\n"
"We need some handy way of specifying diagrams.\n"
"One way would be with a line-recognizing program operating on digitized "
"input from a camera or bitmap display.\n"
"Another possibility is an interactive drawing program using a mouse and "
"bitmap display.\n"
"But since there is not yet a Common Lisp standard for interacting with such "
"devices, we will have to settle for a textual description.\n"
"The macro `defdiagram` defines and names a diagram.\n"
"The name is followed by a list of vertex descriptions.\n"
"Each description is a list consisting of the name of a vertex, the vertex "
"type (Y, A, L, or T), and the names of the neighboring vertexes.\n"
"Here again is the `defdiagram` description for the cube shown in [figure "
"17.6](#f0035)."
msgstr ""
"Оставшийся код связан с созданием диаграмм.\n"
"Нам нужен удобный способ задания диаграмм.\n"
"Один из способов - программа распознавания линий, работающая на оцифрованном "
"вводе с камеры или растрового изображения.\n"
"Другая возможность - интерактивная программа рисования, использующая мышь и "
"отображение растрового изображения.\n"
"Но поскольку пока нет стандарта Common Lisp для взаимодействия с такими "
"устройствами, нам придется довольствоваться текстовым описанием.\n"
"Макрос `defdiagram` определяет диаграмму и дает ей имя.\n"
"За именем следует список описаний вершин.\n"
"Каждое описание представляет собой список, состоящий из имени вершины, типа "
"вершины (Y, A, L или T) и имен соседних вершин.\n"
"Вот снова описание `defdiagram` для куба, показанного на [рис. 17.6](#f0035)."

#: in/chapter17.md:381
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-06](images/chapter17/f17-06.jpg) |\n"
"| Figure 17.6: A Cube                    |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-06](images/chapter17/f17-06.jpg) |\n"
"| Рисунок 17.6: Куб                      |"

#: in/chapter17.md:392
msgid ""
"```lisp\n"
"(defdiagram cube\n"
"  (a Y b c d)\n"
"  (b W g e a)\n"
"  (c W e f a)\n"
"  (d W f g a)\n"
"  (e L c b)\n"
"  (f L d c)\n"
"  (g L b d))\n"
"```"
msgstr ""

#: in/chapter17.md:400
msgid ""
"The macro `defdiagram` calls `construct-diagram` to do the real work.\n"
"It would be feasible to have `defdiagram` expand into a `defvar,` making the "
"names be special variables.\n"
"But then it would be the user`'s` responsibility to make copies of such a "
"variable before passing it to a destructive function.\n"
"Instead, I use `put-diagram` and `diagram` to put and get diagrams in a "
"table, `diagram` retrieves the named diagram and makes a copy of it.\n"
"Thus, the user cannot corrupt the original diagrams stored in the table.\n"
"Another possibility would be to have `defdiagram` expand into a function "
"definition for `name` that returns a copy of the diagram.\n"
"I chose to keep the diagram name space separate from the function name "
"space, since names like `cube` make sense in both spaces."
msgstr ""
"Макрос `defdiagram` вызывает `construct-diagram` для выполнения реальной "
"работы.\n"
"Было бы возможно преобразовать `defdiagram` в `defvar`, сделав имена "
"специальными переменными.\n"
"Но тогда ответственность за создание копий такой переменной перед ее "
"передачей деструктивной функции будет лежать на пользователе.\n"
"Вместо этого я использую `put-diagram` и `diagram` для размещения и "
"получения диаграмм в таблице, `diagram` извлекает названную диаграмму и "
"делает ее копию.\n"
"Таким образом, пользователь не может повредить исходные диаграммы, "
"хранящиеся в таблице.\n"
"Другой возможностью было бы расширение `defdiagram` в определение функции "
"для `name`, возвращающей копию диаграммы.\n"
"Я решил хранить пространство имен диаграммы отдельно от пространства имен "
"функций, поскольку имена вроде `cube` имеют смысл в обоих пространствах."

#: in/chapter17.md:406
msgid ""
"```lisp\n"
"(defmacro defdiagram (name &rest vertex-descriptors)\n"
"  \"Define a diagram.  A copy can be gotten by (diagram name).\"\n"
"  `(put-diagram ',name (construct-diagram\n"
"                         (check-diagram ',vertex-descriptors))))"
msgstr ""

#: in/chapter17.md:408
msgid "(let ((diagrams (make-hash-table)))"
msgstr ""

#: in/chapter17.md:412
msgid ""
"(defun diagram (name)\n"
"  \"Get a fresh copy of the diagram with this name.\"\n"
"  (make-copy-diagram (gethash name diagrams)))"
msgstr ""

#: in/chapter17.md:418
msgid ""
"(defun put-diagram (name diagram)\n"
"  \"Store a diagram under a name.\"\n"
"  (setf (gethash name diagrams) diagram)\n"
"  name))\n"
"```"
msgstr ""

#: in/chapter17.md:420
msgid ""
"The function `construct-diagram` translates each vertex description, using "
"`construct-vertex`, and then fills in the neighbors of each vertex."
msgstr ""
"Функция `construct-diagram` переводит описание каждой вершины, используя "
"`construct-vertex`, а затем заполняет соседей каждой вершины."

#: in/chapter17.md:435
msgid ""
"```lisp\n"
"(defun construct-diagram (vertex-descriptors)\n"
"  \"Build a new diagram from a set of vertex descriptor.\"\n"
"  (let ((diagram (make-diagram)))\n"
"    ;; Put in the vertexes\n"
"    (setf (diagram-vertexes diagram)\n"
"          (mapcar #'construct-vertex vertex-descriptors))\n"
"    ;; Put in the neighbors for each vertex\n"
"    (dolist (v-d vertex-descriptors)\n"
"      (setf (vertex-neighbors (find-vertex (first v-d) diagram))\n"
"            (mapcar #'(lambda (neighbor)\n"
"                        (find-vertex neighbor diagram))\n"
"                    (v-d-neighbors v-d))))\n"
"    diagram))"
msgstr ""

#: in/chapter17.md:443
msgid ""
"(defun construct-vertex (vertex-descriptor)\n"
"  \"Build the vertex corresponding to the descriptor.\"\n"
"  ;; Descriptors are like: (x L y z)\n"
"  (make-vertex\n"
"    :name (first vertex-descriptor)\n"
"    :type (second vertex-descriptor)\n"
"    :labelings (possible-labelings (second vertex-descriptor))))"
msgstr ""

#: in/chapter17.md:448
msgid ""
"(defun v-d-neighbors (vertex-descriptor)\n"
"  \"The neighboring vertex names in a vertex descriptor.\"\n"
"  (rest (rest vertex-descriptor)))\n"
"```"
msgstr ""

#: in/chapter17.md:451
msgid ""
"The `defstruct` for `diagram` automatically creates the function `copy-"
"diagram,` but it just copies each field, without copying the contents of "
"each field.\n"
"Thus we need `make-copy-diagram` to create a copy that shares no structure "
"with the original."
msgstr ""
"`defstruct` для `diagram` автоматически создает функцию `copy-diagram`, но "
"она просто копирует каждое поле, не копируя содержимое каждого поля.\n"
"Таким образом, нам нужно `make-copy-diagram` для создания копии, не имеющей "
"общей структуры с оригиналом."

#: in/chapter17.md:466
msgid ""
"```lisp\n"
"(defun make-copy-diagram (diagram)\n"
"  \"Make a copy of a diagram, preserving connectivity.\"\n"
"  (let* ((new (make-diagram\n"
"                :vertexes (mapcar #'copy-vertex\n"
"                                  (diagram-vertexes diagram)))))\n"
"    ;; Put in the neighbors for each vertex\n"
"    (dolist (v (diagram-vertexes new))\n"
"      (setf (vertex-neighbors v)\n"
"            (mapcar #'(lambda (neighbor)\n"
"                        (find-vertex (vertex-name neighbor) new))\n"
"                    (vertex-neighbors v))))\n"
"    new))\n"
"```"
msgstr ""

#: in/chapter17.md:468
msgid "## 17.3 Labeling Diagrams"
msgstr "## 17.3 Маркировка Диаграм"

#: in/chapter17.md:471
msgid ""
"We are now ready to try labeling diagrams.\n"
"First the cube:"
msgstr ""
"Теперь мы готовы попробовать маркировку диаграмм.\n"
"Сначала куб:"

#: in/chapter17.md:483
msgid ""
"```lisp\n"
"> (print-labelings (diagram 'cube))\n"
"The initial diagram is:\n"
"  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]\n"
"  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]\n"
"  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]\n"
"  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]\n"
"  E/6 L: EC=[RL+L-R] EB=[LRR+L-]\n"
"  F/6 L: FD=[RL+L-R] FC=[LRR+L-]\n"
"  G/6 L: GB=[RL+L-R] GD=[LRR+L-]\n"
"```"
msgstr ""

#: in/chapter17.md:485
msgid "`For 29,160 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:496
msgid ""
"```lisp\n"
"After constraint propagation the diagram is:\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/2 W: BG=[L-] BE=[R-] BA=[++]\n"
"  C/2 W: CE=[L-] CF=[R-] CA=[++]\n"
"  D/2 W: DF=[L-] DG=[R-] DA=[++]\n"
"  E/3 L: EC=[R-R] EB=[LL-]\n"
"  F/3 L: FD=[R-R] FC=[LL-]\n"
"  G/3 L: GB=[R-R] GD=[LL-]\n"
"```"
msgstr ""

#: in/chapter17.md:498
msgid "`For 216 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:534
msgid ""
"```lisp\n"
"There are four solutions:\n"
"Diagram:\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/1 W: BG=[L] BE=[R] BA=[+]\n"
"  C/l W: CE=[L] CF=[R] CA=[+]\n"
"  D/1 W: DF=[L] DG=[R] DA=[+]\n"
"  E/l L: EC=[R] EB=[L]\n"
"  F/1 L: FD=[R] FC=[L]\n"
"  G/1 L: GB=[R] GD=[L]\n"
"  Diagram:\n"
"  A/1 Y: AD=[+] AC=[+] AD=[+]\n"
"  B/1 W: BG=[L] BE=[R] BA=[+]\n"
"  C/l W: CE=[L] CF=[R] CA=[+]\n"
"  D/1 W: DF=[-] DG=[-] DA=[+]\n"
"  E/l L: EC=[R] EB=[L]\n"
"  F/1 L: FD=[-] FC=[L]\n"
"  G/1 L: GB=[R] GD=[-]\n"
"Diagram:\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/1 W: BG=[L] BE=[R] BA=[+]\n"
"  C/l W: CE=[-] CF=[-] CA=[+]\n"
"  D/1 W: DF=[L] DG=[R] DA=[+]\n"
"  E/l L: EC=[-] EB=[L]\n"
"  F/1 L: FD=[R] FC=[-]\n"
"  G/1 L: GB=[R] GD=[L]\n"
"Diagram:\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/1 W: BG=[-] BE=[-] BA=[+]\n"
"  C/1 W: CE=[L] CF=[R] CA=[+]\n"
"  D/1 W: DF=[L] DG=[R] DA=[+]\n"
"  E/1 L: EC=[R] EB=[-]\n"
"  F/1 L: FD=[R] FC=[L]\n"
"  G/1 L: GB=[-] GD=[L]\n"
"```"
msgstr ""

#: in/chapter17.md:539
msgid ""
"The four interpretations correspond, respectively, to the cases where the "
"cube is free floating, attached to the floor (GD and DF = -), attached to a "
"wall on the right (EC and CF = -), or attached to a wall on the left (BG and "
"BE = -).\n"
"These are shown in [figure 17.7](#f0040).\n"
"It would be nice if we could supply information about where the cube is "
"attached, and see if we can get a unique interpretation.\n"
"The function ground takes a diagram and modifies it by making one or more "
"lines be grounded lines-lines that have a concave (-) label, corresponding "
"to a junction with the ground."
msgstr ""
"Четыре интерпретации соответствуют, соответственно, случаям, когда куб "
"свободно плавает, прикреплен к полу (GD и DF = -), прикреплен к стене справа "
"(EC и CF = -) или прикреплен к стене на слева (BG и BE = -).\n"
"Они показаны на [рисунок 17.7](#f0040).\n"
"Было бы неплохо, если бы мы могли предоставить информацию о том, где "
"прикреплен куб, и посмотреть, сможем ли мы получить уникальную "
"интерпретацию.\n"
"Функция `ground`(земля) принимает диаграмму и модифицирует ее, делая одну "
"или несколько линий линиями примыкающими к земле - линиями, имеющими "
"вогнутую (-) метку, соответствующую месту соединения с землей."

#: in/chapter17.md:544
msgid ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-07](images/chapter17/f17-07.jpg)        |\n"
"| Figure 17.7: Four Interpretations of the Cube |"
msgstr ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-07](images/chapter17/f17-07.jpg)        |\n"
"| Рисунок 17.7: Четыре интерпретации куба |"

#: in/chapter17.md:558
msgid ""
"```lisp\n"
"(defun ground (diagram vertex-a vertex-b)\n"
"  \"Attach the line between the two vertexes to the ground.\n"
"  That is, label the line with a -\"\n"
"  (let* ((A (find-vertex vertex-a diagram))\n"
"         (B (find-vertex vertex-b diagram))\n"
"         (i (position B (vertex-neighbors A))))\n"
"    (assert (not (null i)))\n"
"    (setf (vertex-labelings A)\n"
"          (find-all-if #'(lambda (l) (eq (nth i l) '-))\n"
"                     (vertex-labelings A)))\n"
"    diagram))\n"
"```"
msgstr ""

#: in/chapter17.md:560
msgid "We can see how this works on the cube:"
msgstr "Мы можем увидеть, как это работает на кубе:"

#: in/chapter17.md:572
msgid ""
"```lisp\n"
"> (print-labelings (ground (diagram 'cube) 'g 'd))\n"
"The initial diagram is:\n"
"  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]\n"
"  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]\n"
"  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]\n"
"  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]\n"
"  E/6 L: EC=[RL+L-R] EB[LRR+L-]\n"
"  F/6 L: FD=[RL+L-R] FC=[LRR+L-]\n"
"  G/1 L: GB=[R] GD=[-]\n"
"```"
msgstr ""

#: in/chapter17.md:574
msgid "`For 4,860 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:585
msgid ""
"```lisp\n"
"After constraint propagation the diagram is:\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/l W: BG=[L] BE=[R] BA=[+]\n"
"  C/l W: CE=[L] CF=[R] CA=[C  +]\n"
"  D/l W: DF=[-] DG=[-] DA=[+]\n"
"  E/l L: EC=[R] EB=[L]\n"
"  F/1 L: FD=[-] FC=[L]\n"
"  G/1 L: GB=[R] GD=[-]\n"
"```"
msgstr ""

#: in/chapter17.md:590
msgid ""
"Note that the user only had to specify one of the two ground lines, GD.\n"
"The program found that DF is also grounded.\n"
"Similarly, in programming `ground-line`, we only had to update one of the "
"vertexes.\n"
"The rest is done by constraint propagation."
msgstr ""
"Обратите внимание, что пользователю нужно было указать только одну из двух "
"линий примыкающих к земле, GD.\n"
"Программа обнаружила, что DF тоже заземлен.\n"
"Точно так же при программировании `ground-line`(наземной линии) нам нужно "
"было обновить только одну из вершин.\n"
"Остальное делается путем распространения ограничений."

#: in/chapter17.md:593
msgid ""
"The next example yields the same four interpretations, in the same order "
"(free floating, attached at bottom, attached at right, and attached at left) "
"when interpreted ungrounded.\n"
"The grounded version yields the unique solution shown in the following "
"output and in [figure 17.9](#f0050)."
msgstr ""
"Следующий пример дает те же четыре интерпретации в том же порядке (свободно "
"плавающий, прикрепленный снизу, прикрепленный справа и прикрепленный слева) "
"при интерпретации без земли.\n"
"Заземленная версия дает уникальное решение, показанное в следующих выходных "
"данных и на [рис. 17.9](#f0050)."

#: in/chapter17.md:598
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-08](images/chapter17/f17-08.jpg) |\n"
"| Figure 17.8: Cube on a Plate           |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-08](images/chapter17/f17-08.jpg) |\n"
"| Рисунок 17.8: Куб на тарелке           |"

#: in/chapter17.md:603
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-09](images/chapter17/f17-09.jpg) |\n"
"| Figure 17.9: Labeled Cube on a Plate   |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-09](images/chapter17/f17-09.jpg) |\n"
"| Рисунок 17.9: Промаркированный куб на тарелке   |"

#: in/chapter17.md:635
msgid ""
"```lisp\n"
"(defdiagram cube-on-plate\n"
"  (a Y b c d)\n"
"  (b W g e a)\n"
"  (c W e f a)\n"
"  (d W f g a)\n"
"  (e L c b)\n"
"  (f Y d c i)\n"
"  (g Y b d h)\n"
"  (h W l g j)\n"
"  (i W f m j)\n"
"  (j Y h i k)\n"
"  (k W m l j)\n"
"  (l L h k)\n"
"  (m L k i))\n"
"> (print-labelings (ground (diagram 'cube-on-plate) 'k 'm))\n"
"The initial diagram is:\n"
"  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]\n"
"  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]\n"
"  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]\n"
"  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]\n"
"  E/6 L: EC=[RL+L-R] EB=[LRR+L-]\n"
"  F/5 Y: FD=C+-L-R] FC=[+-RL-] FI=[+--RL]\n"
"  G/5 Y: GB=[+-L-R] GD=[+-RL-] GH=[+--RL]\n"
"  H/3 W: HL=[L-+] HG=[R-+] HJ=[++-]\n"
"  I/3 W: IF=[L-+] IM=[R-+] IJ=[++-]\n"
"  J/5 Y: JH=[+-L-R] JI=[+-RL-] JK=[+--RL]\n"
"  K/1 W: KM=[-] KL=[-] KJ=[+]\n"
"  L/6 L: LH=[RL+L-R] LK=[LRR+L-]\n"
"  M/6 L: MK=[RL+L-R] MI=[LRR+L-]\n"
"```"
msgstr ""

#: in/chapter17.md:637
msgid "`For 32.805.000 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:654
msgid ""
"```lisp\n"
"After constraint propagation the diagram is\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/2 W: BG=[L-] BE=[R-] BA=[++]\n"
"  C/2 W: CE=[L-] CF=[R-] CA=[++]\n"
"  D/2 W: DF=[L-] DG=[R-] DA=[++]\n"
"  E/1 L: EC=[R] EB=[L]\n"
"  F/1 Y: FD=[-] FC=[L] FI=[R]\n"
"  G/1 Y: GB=[R] GD=[-] GH=[L]\n"
"  H/1 W: HL=[L] HG=[R] HJ=[+]\n"
"  I/1 W: IF=[L] IM=[R] IJ=[+]\n"
"  J/1 Y: JH=[+] JI=[+] JK=[+]\n"
"  K/1 W: KM=[-] KL=[-] KJ=[+]\n"
"  L/1 L: LH=[R] LK=[-]\n"
"  M/1 L: MK=[-] MI=[L]\n"
"```"
msgstr ""

#: in/chapter17.md:657
msgid ""
"It is interesting to try the algorithm on an \"impossible\" diagram.\n"
"It turns out the algorithm correctly finds no interpretation for this well-"
"known illusion:"
msgstr ""
"Интересно опробовать алгоритм на \"невозможной\" диаграмме.\n"
"Оказывается, алгоритм не находит никакой интерпретации этой хорошо известной "
"иллюзии:"

#: in/chapter17.md:687
msgid ""
"```lisp\n"
"(defdiagram poiuyt\n"
"  (a L b g)\n"
"  (b L j a)\n"
"  (c L d l)\n"
"  (d L h c)\n"
"  (e L f i)\n"
"  (f L k e)\n"
"  (g L a l)\n"
"  (h L l d)\n"
"  (i L e k)\n"
"  (j L k b)\n"
"  (k W j i f)\n"
"  (l W h g c))\n"
"> (print-1 abel ings (diagram 'poiuyt))\n"
"The initial diagram is:\n"
"  A/6 L: AB=[RL+L-R] AG=[LRR+L-]\n"
"  B/6 L: BJ=[RL+L-R] BA=[LRR+L-]\n"
"  C/6 L: CD=[RL+L-R] CL=[LRR+L-]\n"
"  D/6 L: DH=[RL+L-R] DC=[LRR+L-]\n"
"  E/6 L: EF=[RL+L-R] EI=[LRR+L-]\n"
"  F/6 L: FK=[RL+L-R] FE=[LRR+L-]\n"
"  G/6 L: GA=[RL+L-R] GL=[LRR+L-]\n"
"  H/6 L: HL=[RL+L-R] HD=[LRR+L-]\n"
"  I/6 L: IE=[RL+L-R] IK=[LRR+L-]\n"
"  J/6 L: JK=[RL+L-R] JB=[LRR+L-]\n"
"  K/3 W: KJ=[L-+] KI=[R-+] KF=[++-]\n"
"  L/3 W: LH=[L-+] LG=[R-+] LC=[++-]\n"
"```"
msgstr ""

#: in/chapter17.md:689
msgid "`For 544,195.584 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:705
msgid ""
"```lisp\n"
"After constraint propagation the diagram is:\n"
"  A/5 L: AB=[RL+-R] AG=[LRRL-]\n"
"  B/5 L: BJ=[RLL-R] BA=[LR+L-]\n"
"  C/2 L: CD=[LR] CL=[+-]\n"
"  D/3 L: DH=[RL-] DC=[LRL]\n"
"  E/3 L: EF=[RLR] EI=[LR-]\n"
"  F/2 L: FK=[+-] FE=[RL]\n"
"  G/4 L: GA=[RL-R] GL=[L+L-]\n"
"  H/4 L: HL=[R+-R] HD=[LRL-]\n"
"  I/4 L: IE=[RL-R] IK=[L+L-]\n"
"  J/4 L: JK=[R+-R] JB=[LRL-]\n"
"  K/3 W: KJ=[L-+] KI=[R-+] KF=[++-]\n"
"  L/3 W: LH=[L-+] LG=[R-+] LC=[++-]\n"
"```"
msgstr ""

#: in/chapter17.md:707
msgid "`For 2,073,600 interpr`e`tations.`"
msgstr ""

#: in/chapter17.md:709
msgid "`There are z`e`ro solutions:`"
msgstr ""

#: in/chapter17.md:711
msgid "Now we try a more complex diagram:"
msgstr "Теперь попробуем более сложную диаграмму(схему):"

#: in/chapter17.md:749
msgid ""
"```lisp\n"
"(defdiagram tower\n"
"  (a Y b c d)    (n L q o)\n"
"  (b W g e a)    (o W y j n)\n"
"  (c W e f a)    (P L r i)\n"
"  (d W f g a)    (q W n s w)\n"
"  (e L c b)      (r W s p x)\n"
"  (f Y d c i)    (s L r q)\n"
"  (g Y b d h)    (t W w x z)\n"
"  (h W l g J)    (u W x y z)\n"
"  (i W f m p)    (v W y w z)\n"
"  (j Y h o k)    (w Y t v q)\n"
"  (k W m l j)    (x Y r u t)\n"
"  (l L h k)      (y Y v u o)\n"
"  (m L k i)      (z Y t u v))\n"
"> (print-labelings (ground (diagram 'tower) 'l 'k))\n"
"The initial diagram is:\n"
"  A/5 Y: AB=[+-L-R] AC=[+-RL-] AD=[+--RL]\n"
"  B/3 W: BG=[L-+] BE=[R-+] BA=[++-]\n"
"  C/3 W: CE=[L-+] CF=[R-+] CA=[++-]\n"
"  D/3 W: DF=[L-+] DG=[R-+] DA=[++-]\n"
"  E/6 L: EC[RL+L-R] EB=[LRR+L-]\n"
"  F/5 Y: FD=[+-L-R] FC=[+-RL-] FI=[+--RL]\n"
"  G/5 Y: GB=[+-L-R] GD=[+-RL-] GH=[+--RL]\n"
"  H/3 W: HL=[L-+] HG=[R-+] HJ=[++-]\n"
"  I/3 W: IF=[L-+] IM=[R-+] IP=[++-]\n"
"  J/5 Y: JH=[+-L-R] JO=[+-RL-] JK=[+--RL]\n"
"  K/3 W: KM=[L-+] KL=[R-+] KJ=[++-]\n"
"  L/1 L: LH=[R] LK=[-]\n"
"  M/6 L: MK=[RL+L-R] MI=[LRR+L-]\n"
"  N/6 L: NQ=[RL+L-R] NO=[LRR+L-]\n"
"  O/3 W: OY=[L-+] OJ=[R-+] ON=[++-]\n"
"  P/6 L: PR=[RL+L-R] PI=[LRR+L-]\n"
"  Q/3 W: QN=[L-+] QS=[R-+] QW=[++-]\n"
"  R/3 W: RS=[L-+] RP=[R-+] RX=[++-]\n"
"  S/6 L: SR=[RL+L-R] SQ=[LRR+L-]\n"
"```"
msgstr ""

#: in/chapter17.md:751
msgid "`  T/3 W:` TW=[L-+] `TX=[R-+] TZ=[++-]`"
msgstr ""

#: in/chapter17.md:761
msgid ""
"```lisp\n"
"  U/3 W: UX=[L-+] UY=[R-+] UZ=[++-]\n"
"  V/3 W: VY=[L-+] VW=[R-+] VZ=[++-]\n"
"  W/5 Y: WT=[+-L-R] WV=[+-RL-] WQ=[+--RL]\n"
"  X/5 Y: XR=[+-L-R] XU=[+-RL-] XT=[+--RL]\n"
"  Y/5 Y: YV=[+-L-R] YU=[+-RL-] YO=[+--RL]\n"
"  Z/5 Y: ZT=[+-L-R] ZU=[+-RL-] ZV=[+--RL]\n"
"For 1,614,252,037,500,000 interpretations.\n"
"```"
msgstr ""

#: in/chapter17.md:763
msgid "After constraint propagation the diagram is:"
msgstr "После распространения ограничения диаграмма выглядит так:"

#: in/chapter17.md:792
msgid ""
"```lisp\n"
"  A/1 Y: AB=[+] AC=[+] AD=[+]\n"
"  B/l W: BG=[L] BE=[R] BA=[+]\n"
"  C/1 W: CE=[L] CF=[R] CA=[+]\n"
"  D/l W: DF=[-] DG=[-] DA=[+]\n"
"  E/1 L: EC=[R] EB=[L]\n"
"  F/1 Y: FD=[-] FC=[L] FI=[R]\n"
"  G/1 Y: GB=[R] GD=[-]GH=[L]\n"
"  H/1 W: HL=[L] HG=[R] HJ=[+]\n"
"  I/1 W: IF=[L] IM=[R] IP=[+]\n"
"  J/l Y: JH=[+] JO=[+] JK=[+]\n"
"  K/l W: KM=[-] KL=[-] KJ=[+]\n"
"  L/l L: LH=[R] LK=[-]\n"
"  M/1 L: MK=[-] MI=[L]\n"
"  N/l L: NQ=[R] NO[-]\n"
"  O/l W: OY=[+] OJ=[+] ON=[-]\n"
"  P/l L: PR=[L] PI=[+]\n"
"  Q/1 W: QN=[L] QS=[R] QW=[+]\n"
"  R/1 W: RS=[L] RP=[R] RX=[+]\n"
"  S/1 L: SR=[R] SQ=[L]\n"
"  T/1 W: TW=[+] TX=[+] TZ=[-]\n"
"  U/1 W: UX=[+] UY=[+] UZ=[-]\n"
"  V/l W: VY=[+] VW=[+] VZ=[-]\n"
"  W/l Y: WT=[+] WV=[+] WQ=[+]\n"
"  X/1 Y: XR=[+] XU=[+] XT=[+]\n"
"  Y/1 Y: YV=[+] YU=[+] YO=[+]\n"
"  Z/l Y: ZT=[-] ZU=[-] ZV=[-]\n"
"```"
msgstr ""

#: in/chapter17.md:796
msgid ""
"We see that the algorithm was able to arrive at a single interpretation.\n"
"Moreover, even though there were a large number of possibilities-over a "
"quadrillion-the computation is quite fast.\n"
"Most of the time is spent printing, so to get a good measurement, we define "
"a function to find solutions without printing anything:"
msgstr ""
"Мы видим, что алгоритм смог прийти к единственной интерпретации.\n"
"Более того, даже несмотря на то, что было большое количество возможностей - "
"более квадриллиона, - вычисления выполняются довольно быстро.\n"
"Большая часть времени уходит на печать, поэтому для получения точных "
"результатов мы определяем функцию для поиска решений, ничего не печатая:"

#: in/chapter17.md:803
msgid ""
"```lisp\n"
"(defun find-labelings (diagram)\n"
"  \"Return a list of all consistent labelings of the diagram.\"\n"
"  (every #'propagate-constraints (diagram-vertexes diagram))\n"
"  (search-solutions diagram))\n"
"```"
msgstr ""

#: in/chapter17.md:808
msgid ""
"When we time the application of `find-labelings` to the grounded tower and "
"the poiuyt, we find the tower takes 0.11 seconds, and the poiuyt 21 "
"seconds.\n"
"This is over 180 times longer, even though the poiuyt has only half as many "
"vertexes and only about half a million interpretations, compared to the "
"tower's quadrillion.\n"
"The poiuyt takes a long time to process because there are few local "
"constraints, so violations are discovered only by considering several widely "
"separated parts of the figure all at the same time.\n"
"It is interesting that the same fact that makes the processing of the poiuyt "
"take longer is also responsible for its interest as an illusion."
msgstr ""
"Когда мы измеряем время применения `find-labelings` к расположенной на земле "
"башне и poiuyt, мы обнаруживаем, что расчет башни занимает 0,11 секунды, а "
"poiuyt 21 секунду.\n"
"Это более чем в 180 раз дольше, даже несмотря на то, что у poiuyt вдвое "
"меньше вершин и всего около полумиллиона интерпретаций по сравнению с "
"квадриллионом башни.\n"
"Обработка poiuyt занимает много времени из-за небольшого количества "
"локальных ограничений, поэтому нарушения обнаруживаются только при "
"одновременном рассмотрении нескольких широко разделенных частей фигуры.\n"
"Интересно, что тот же факт, из-за которого обработка poiuyt занимает больше "
"времени, также ответственен за его восприятие как иллюзию."

#: in/chapter17.md:810
msgid "## 17.4 Checking Diagrams for Errors"
msgstr "## 17.4 Проверка диаграмм на наличие ошибок"

#: in/chapter17.md:813
msgid ""
"This section considers one more example, and considers what to do when there "
"are apparent errors in the input.\n"
"The example is taken from Charniak and McDermott's *Introduction to "
"Artificial Intelligence*, page 138, and shown in [figure 17.12](#f0065)."
msgstr ""
"В этом разделе рассматривается еще один пример и рассматривается, что "
"делать, если во входных данных есть очевидные ошибки.\n"
"Пример взят из книги Чарняка и Макдермотта *Introduction to Artificial "
"Intelligence*(Введение в искусственный интеллект), стр. 138, и показан на "
"[рис. 17.12](#f0065)."

#: in/chapter17.md:818
msgid ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-10](images/chapter17/f17-10.jpg)        |\n"
"| Figure 17.10: An Impossible Figure (A Poiuyt) |"
msgstr ""
"| []()                                          |\n"
"|-----------------------------------------------|\n"
"| ![f17-10](images/chapter17/f17-10.jpg)        |\n"
"| Рисунок 17.10: Невозможная фигура (Poiuyt) |"

#: in/chapter17.md:823
msgid ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-11](images/chapter17/f17-11.jpg) |\n"
"| Figure 17.11: A Tower                  |"
msgstr ""
"| []()                                   |\n"
"|----------------------------------------|\n"
"| ![f17-11](images/chapter17/f17-11.jpg) |\n"
"| Рисунок 17.11: Башня                  |"

#: in/chapter17.md:828
msgid ""
"| []()                                   |\n"
"| ---------------------------------------|\n"
"| ![f17-12](images/chapter17/f17-12.jpg) |\n"
"| Figure 17.12: Diagram of an arch       |"
msgstr ""
"| []()                                   |\n"
"| ---------------------------------------|\n"
"| ![f17-12](images/chapter17/f17-12.jpg) |\n"
"| Рисунок 17.12: Диаграмма(Схема) арки       |"

#: in/chapter17.md:847
msgid ""
"```lisp\n"
"(defdiagram arch\n"
"  (a W e b c)    (p L o q)\n"
"  (b L d a)      (q T P i r)\n"
"  (c Y a d g)    (r T j s q)\n"
"  (d Y c b m)    (s L r t)\n"
"  (e L a f)      (t W v s k)\n"
"  (f T e g n)    (u L t l)\n"
"  (g W h f c)    (v L t l)\n"
"  (h T g i o)    (w W x l y)\n"
"  (i T h j q)    (x L w z)\n"
"  (j T i k r)    (y Y w 2 z)\n"
"  (k T J l t)    (z W 3 x y)\n"
"  (l T k m v)    (l T n o w)\n"
"  (m L l d)      (2 W v 3 y)\n"
"  (n L f 1)      (3 L z 2)\n"
"  (o W P 1 h)    (4 T u l v))\n"
"```"
msgstr ""

#: in/chapter17.md:851
msgid ""
"Unfortunately, running this example results in no consistent interpretations "
"after constraint propagation.\n"
"This seems wrong.\n"
"Worse, when we try to ground the diagram on the line XZ and call `print-"
"labelings` on that, we get the following error:"
msgstr ""
"К сожалению, выполнение этого примера не дает согласованных интерпретаций "
"после распространения ограничения.\n"
"Это кажется неправильным.\n"
"Хуже того, когда мы пытаемся заземлить(приложить к земле) диаграмму по линии "
"XZ и вызывать для неё `print-labelings`, мы получаем следующую ошибку:"

#: in/chapter17.md:855
msgctxt "in/chapter17.md:855"
msgid ""
"```lisp\n"
">>>ERROR: The first argument to NTH was of the wrong type.\n"
"```"
msgstr ""

#: in/chapter17.md:857
msgctxt "in/chapter17.md:857"
msgid "`The function expected a fixnum >= z`e`ro.`"
msgstr ""

#: in/chapter17.md:859
msgctxt "in/chapter17.md:859"
msgid "`While in the function LABELS-FOR`<= `CONSISTENT-LABELINGS`"
msgstr ""

#: in/chapter17.md:863
msgctxt "in/chapter17.md:863"
msgid ""
"```lisp\n"
"Debugger entered while in the following function:\n"
"```"
msgstr ""

#: in/chapter17.md:866
msgctxt "in/chapter17.md:866"
msgid ""
"`LABELS-FOR (P.C.\n"
"= 23)`"
msgstr ""

#: in/chapter17.md:871
msgid ""
"```lisp\n"
"  Arg 0 (VERTEX): U/6\n"
"  Arg 1 (FROM): 4/4\n"
"```"
msgstr ""

#: in/chapter17.md:877
msgid ""
"What has gone wrong?\n"
"A good guess is that the diagram is somehow inconsistent- somewhere an error "
"was made in transcribing the diagram.\n"
"It could be that the diagram is in fact impossible, like the poiuyt.\n"
"But that is unlikely, as it is easy for us to provide an intuitive "
"interpretation.\n"
"We need to debug the diagram, and it would also be a good idea to handle the "
"error more gracefully."
msgstr ""
"Что пошло не так?\n"
"Хорошее предположение - что диаграмма непоследовательна - где-то была "
"допущена ошибка при расшифровке диаграммы.\n"
"Может быть, диаграмма на самом деле невозможна, как и poiuyt.\n"
"Но это маловероятно, поскольку нам легко дать интуитивную интерпретацию.\n"
"Нам нужно отладить диаграмму, и было бы неплохо обработать ошибку более "
"изящно."

#: in/chapter17.md:880
msgid ""
"One property of the diagram that is easy to check for is that every line "
"should be mentioned twice.\n"
"If there is a line between vertexes A and B, there should be two entries in "
"the vertex descriptors of the following form:"
msgstr ""
"Одно свойство диаграммы, которое легко проверить, - это то, что каждая линия "
"должна упоминаться дважды.\n"
"Если между вершинами A и B есть линия, в дескрипторах вершин должно быть две "
"записи следующего вида:"

#: in/chapter17.md:885
msgid ""
"```lisp\n"
"(A ? ... B ...)\n"
"(B ? ... A ...)\n"
"```"
msgstr ""

#: in/chapter17.md:889
msgid ""
"Here the symbol \"?\" means we aren't concerned about the type of the "
"vertexes, only with the presence of the line in two places.\n"
"The following code makes this check when a diagram is defined.\n"
"It also checks that each vertex is one of the four legal types, and has the "
"right number of neighbors."
msgstr ""
"Здесь символ \"?\" означает, что нас не беспокоит тип вершин, только наличие "
"линии в двух местах.\n"
"Следующий код выполняет эту проверку при определении диаграммы.\n"
"Он также проверяет, что каждая вершина относится к одному из четырех "
"допустимых типов и имеет правильное количество соседей."

#: in/chapter17.md:893
msgid ""
"```lisp\n"
"(defmacro defdiagram (name &rest vertex-descriptors)\n"
"```"
msgstr ""

#: in/chapter17.md:896
msgid ""
"`  \"Define a diagram.\n"
"A copy can be gotten by (diagram name).\"`"
msgstr ""

#: in/chapter17.md:900
msgid ""
"```lisp\n"
"  '(put-diagram '.name (construct-diagram\n"
"                    (check-diagram ',vertex-descriptors))))"
msgstr ""

#: in/chapter17.md:929
msgid ""
"(defun check-diagram (vertex-descriptors)\n"
"  \"Check if the diagram description appears consistent.\"\n"
"  (let ((errors 0))\n"
"    (dolist (v-d vertex-descriptors)\n"
"      ;; v-d is like: (a Y b c d)\n"
"      (let ((A (first v-d))\n"
"            (v-type (second v-d)))\n"
"        ;; Check that the number of neighbors is right for\n"
"        ;; the vertex type (and that the vertex type is legal)\n"
"        (when (/= (length (v-d-neighbors v-d))\n"
"                  (case v-type ((W Y T) 3) ((L) 2) (t -1)))\n"
"          (warn \"Illegal type/neighbor combo: ~a\" v-d)\n"
"          (incf errors))\n"
"        ;; Check that each neighbor B is connected to\n"
"        ;; this vertex, A, exactly once\n"
"        (dolist (B (v-d-neighbors v-d))\n"
"          (when (/= 1 (count-if\n"
"                        #'(lambda (v-d2)\n"
"                            (and (eql (first v-d2) B)\n"
"                                 (member A (v-d-neighbors v-d2))))\n"
"                        vertex-descriptors))\n"
"            (warn \"Inconsistent vertex: ~a-~a\" A B)\n"
"            (incf errors)))))\n"
"    (when (> errors 0)\n"
"      (error \"Inconsistent diagram.  ~d total error~:p.\"\n"
"             errors)))\n"
"  vertex-descriptors)\n"
"```"
msgstr ""

#: in/chapter17.md:931
msgid "Now let's try the arch again:"
msgstr "Теперь попробуем еще раз арку:"

#: in/chapter17.md:956
msgid ""
"```lisp\n"
"(defdiagram arch\n"
"  (a W e b c)    (p L o q)\n"
"  (b L d a)      (q T p i r)\n"
"  (c Y a d g)    (r T j s q)\n"
"  (d Y c b m)    (s L r t)\n"
"  (e L a f)      (t W v s k)\n"
"  (f T e g n)    (u L t l)\n"
"  (g W h f c)    (v L 2 4)\n"
"  (h T g i o)    (w W x l y)\n"
"  (i T h j q)    (x L w z)\n"
"  (j T i k r)    (y Y w 2 z)\n"
"  (k T j l t)    (z W 3 x y)\n"
"  (l T k m v)    (1 T n o w)\n"
"  (m L l d)      (2 W v 3 y)\n"
"  (n L f 1)      (3 L z 2)\n"
"  (o W P 1 h)    (4 T u l v))\n"
"Warning: Inconsistent vertex: T-V\n"
"Warning: Inconsistent vertex: U-T\n"
"Warning: Inconsistent vertex: U-L\n"
"Warning: Inconsistent vertex: L-V\n"
"Warning: Inconsistent vertex: 4-U\n"
"Warning: Inconsistent vertex: 4-L\n"
"```"
msgstr ""

#: in/chapter17.md:959
msgid ""
"`>>ERROR: Inconsistent diagram.\n"
"6 total errors.`"
msgstr ""

#: in/chapter17.md:962
msgid ""
"The `defdiagram` was transcribed from a hand-labeled diagram, and it appears "
"that the transcription has fallen prey to one of the oldest problems in "
"mathematical notation: confusing a \"u\" with a \"v.\" The other problem was "
"in seeing the line U-L as a single line, when in fact it is broken up into "
"two segments, U-4 and 4-L.\n"
"Repairing these bugs gives the diagram:"
msgstr ""
"`defdiagram` выполнял расшифровку из промаркированной вручную диаграммы, и "
"похоже, что эта транскрипция стала жертвой одной из старейших проблем "
"математической записи: путать \"u\" с \"v\". Другая проблема заключалась в "
"том, чтобы рассматривать линию U-L как единую линию, когда на самом деле она "
"разбита на два сегмента, U-4 и 4-L.\n"
"Исправление этих ошибок дает диаграмму:"

#: in/chapter17.md:981
msgid ""
"```lisp\n"
"(defdiagram arch\n"
"  (a W e b c)    (P L o q)\n"
"  (b L d a)      (q T P i r)\n"
"  (c Y a d g)    (r T j s q)\n"
"  (d Y c b m)    (s L r t)\n"
"  (e L a f)      (t W u s k)        *;t-u not t-v*\n"
"  (f T e g n)    (u L t 4)          *;u-4 not u-l*\n"
"  (g W h f c)    (v L 2 4)\n"
"  (h T g i o)    (w W x l y)\n"
"  (i T h j q)    (x L w z)\n"
"  (j T i k r)    (y Y w 2 z)\n"
"  (k T J l t)    (z W 3 x y)\n"
"  (l T k m 4)    (1 T n o w)          *;l-4 not l-v*\n"
"  (m L l d)      (2 W v 3 y)\n"
"  (n L f 1)      (3 L z 2)\n"
"  (o W P 1 h)    (4 T u l v))\n"
"```"
msgstr ""

#: in/chapter17.md:984
msgid ""
"This time there arenoerrorsdetected by `check-diagram,` butrunning `print-"
"labelings` again still does not give a solution.\n"
"`To` get more information about which constraints are applied, `I` modified "
"`propagate-constraints` to print out some information:"
msgstr ""
"На этот раз `check-diagram` ошибок не обнаружила, но запуск `print-"
"labelings` еще раз не дает решения.\n"
"`Чтобы` получить больше информации о том, какие ограничения применяются, `я` "
"изменил `progate-constraints`, чтобы распечатать некоторую информацию:"

#: in/chapter17.md:1000
msgid ""
"```lisp\n"
"(defun propagate-constraints (vertex)\n"
"  \"Reduce the number of labelings on vertex by considering neighbors.\n"
"  If we can reduce, propagate the new constraint to each neighbor.\"\n"
"  :: Return nil only when the constraints lead to an impossibility\n"
"  (let ((old-num (number-of-labelings vertex)))\n"
"    (setf (vertex-labelings vertex) (consistent-labelings vertex))\n"
"    (unless (impossible-vertex-p vertex)\n"
"      (when (< (number-of-labelings vertex) old-num)\n"
"        (format t \"~&; ~a: ~14a ~a\" vertex ;***\n"
"                (vertex-neighbors vertex) ;***\n"
"                (vertex-labelings vertex)) ;***\n"
"        (every #'propagate-constraints (vertex-neighbors vertex)))\n"
"      vertex)))\n"
"```"
msgstr ""

#: in/chapter17.md:1002
msgid "Running the problem again gives the following trace:"
msgstr "Повторный запуск проблемы дает следующую трассу:"

#: in/chapter17.md:1098
msgid ""
"```lisp\n"
"> (print-labelings (ground (diagram 'arch) 'x 'z))\n"
"The initial diagram is:\n"
"  A/3 W: AE=[L-+] AB-CR-+] AC=[++-]\n"
"  P/6 L: P0=[RL+L-R] PQ=[LRR+L-]\n"
"  B/6 L: BD=[RL+L-R] BA=[LRR+L-]\n"
"  Q/4 T: QP=[RRRR] QI=[LLLL] QR=[+-LR]\n"
"  C/5 Y: CA=[+-L-R] CD=[+-RL-] CG=[+--RL]\n"
"  R/4 T: RJ=[RRRR] RS=[LLLL] RQ=[+-LR]\n"
"  D/5 Y: DC=[+-L-R] DB=[+-RL-] DM=[+--RL]\n"
"  S/6 L: SR=[RL+L-R] ST=[LRR+L-]\n"
"  S/6 L: EA=[RL+L-R] EF=[LRR+L-]\n"
"  T/3 W: TU=[L-+] TS=[R-+] TK=[++-]\n"
"  F/4 T: FE=[RRRR] FG=[LLLL] FN=[+-LR]\n"
"  U/6 L: UT=[RL+L-R] U4=[LRR+L-]\n"
"  G/3 W: GH=[L-+] GF=[R-+] GC=[++-]\n"
"  V/6 L: V2=[RL+L-R] V4=[LRR+L-]\n"
"  H/4 T: HG=[RRRR] HI=[LLLL] Ho=[+-LR]\n"
"  W/3 W: WX=[L-+] W1=[R-+] WY=[++-]\n"
"  I/4 T: IH=[RRRR] IJ=[LLLL] IQ=[+-LR]\n"
"  X/1 L: XW=[R] XZ=[-]\n"
"  J/4 T: JI=[RRRR] JK=[LLLL] JR=[+-LR]\n"
"  Y/5 Y: YW=[+-L-R] Y2=[+-RL-] YZ=[+--RL]\n"
"  K/4 T: KJ=[RRRR] KL=[LLLL] KT=[+-LR]\n"
"  Z/3 W: Z3=[L-+] ZX=[R-+] ZY=[++-]\n"
"  L/4 T: LK=[RRRR] LM=[LLLL] L4=[+-LR]\n"
"  1/4 T: 1N=[RRRR] 10=[LLLL] 1 W=[+-LR]\n"
"  M/6 L: ML=[RL+L-R] MD=[LRR+L-]\n"
"  2/3 W: 2 V=[L-+] 23=[R-+] 2Y=[++-]\n"
"  N/6 L: NF=[RL+L-R] N1=[LRR+L-]\n"
"  3/6 L: 3Z=[RL+L-R] 32=[LRR+L-]\n"
"  0/3 W: 0P=[L-+] 01=[R-+] 0H=[++-]\n"
"  4/4 T: 4U=[RRRR] 4 L=[LLLL] 4 V=[+-LR]\n"
"For 2,888, 816, 545.234, 944,000 interpretations\n"
": P/2: (0/3 Q/4)        ((R L) (- L))\n"
": 0/1: (P/2 1/4 H/4)    ((L R +))\n"
": P/1: (0/1 Q/4)        ((R L))\n"
": 1/3: (N/6 0/1 W/3)    ((R L +) (R L -) (R L L))\n"
": N/2: (F/4 1/3)        ((R L) (- L))\n"
": F/2: (E/6 G/3 N/2)    ((R L -) (R L L))\n"
": E/2: (A/3 F/2)      ((R L) (- L))\n"
": A/2: (E/2 B/6 C/5)    ((L R +) (- - +))\n"
": B/3: (D/5 A/2)      ((R L) (- L) (R -))\n"
": D/3: (C/5 B/3 M/6)    ((- - -) (- L R) (R - L))\n"
": W/1: (X/l 1/3 Y/5)    ((L R +))\n"
": 1/1: (N/2 0/1 W/l)    ((R L L))\n"
": Y/1: (W/l 2/3 Z/3)    ((+ + +))\n"
": 2/2: (V/6 3/6 Y/1)    ((L R +) (- - +))\n"
": V/3: (2/2 4/4)      ((R L) (- L) (R -))\n"
": 4/2: (U/6 L/4 V/3)    ((R L -) (R L R))\n"
": U/2: (T/3 4/2)      ((R L) (- L))\n"
": T/2: (U/2 S/6 K/4)    ((L R +) (- - +))\n"
": S/2: (R/4 T/2)      ((R L) (R -))\n"
": K/1: (J/4 L/4 T/2)    ((R L +))\n"
": J/1: (1/4 K/1 R/4)    ((R L L))\n"
": I/1: (H/4 J/1 Q/4)    ((R L R))\n"
": L/1: (K/l M/6 4/2)    ((R L R))\n"
": M/2: (L/1 D/3)      ((R L) (R -))\n"
": 3/3: (Z/3 2/2)      ((R L) (- L) (R -))\n"
": Z/1 : (3/3 X/1 Y/1)    ((- - +))\n"
": 3/1: (Z/l 2/2)    ((- L))\n"
": 2/1: (V/3 3/1 Y/1)    ((L R +))\n"
": V/2: (2/1 4/2)      ((R L) (R -))\n"
"After constraint propagation the diagram is:\n"
"  A/0 W:\n"
"  P/l L: P0=[R] PQ=CL]\n"
"  B/0 L:\n"
"  Q/4 T: QP=[RRRR] QI=[LLLL] QR=[+-LR]\n"
"  C/0 Y:\n"
"  R/4 T: RJ=[RRRR] RS=[LLLL] RQ=[+-LR]\n"
"  D/0 Y:\n"
"  S/2 L: SR=[RR] ST=[L-]\n"
"  E/2 L: EA=[R-] EF=[LL]\n"
"  T/2 W: TU=[L-] TS=CR-] TK=[++]\n"
"  F/2 T: FE=[RR] FG=[LL] FN=[-  L]\n"
"  U/2 L: UT=[R-] U4=[LL]\n"
"  G/0 W:\n"
"  V/2 L: V2=[RR] V4=[L-]\n"
"  H/0 T:\n"
"  W/l W: WX=[L] W1=[R] WY=[+]\n"
"  I/1 T: IH=[R] IJ=[L] IQ=[R]\n"
"  X/1 L: XW=[R] XZ=[-]\n"
"  J/1 T: JI=[R] JK=[L] JR=[L]\n"
"  Y/1 Y: YW=[+] Y2=[+] YZ=[+]\n"
"  K/1 T: KJ=[R] KL=[L] KT=[+]\n"
"  Z/1 W: Z3=[-] ZX=[-] ZY=[+]\n"
"  L/1 T: LK=[R] LM=[L] L4=[R]\n"
"  1/1 T: 1 N=[R] 10=[L] 1 W=[L]\n"
"  M/2 L: ML=[RR] MD=[L-]\n"
"  2/1 W: 2 V=[L] 23=[R] 2Y=[+]\n"
"  N/2 L: NF=[R-] N1=[LL]\n"
"  3/1 L: 3Z=[-] 32=[L]\n"
"  0/1 W: 0P=[L] 01=[R] 0H=[+]\n"
"  4/2 T: 4U=[RR] 4 L=[LL] 4 V=[-  R]\n"
"```"
msgstr ""

#: in/chapter17.md:1101
msgid ""
"From the diagram after constraint propagation we can see that the vertexes A,"
"B,C,D,G, and H have no interpretations, so they are a good place to look "
"first for an error.\n"
"From the trace generated by `propagate-constraints` (the lines beginning "
"with a semicolon), we see that constraint propagation started at P and after "
"seven propagations reached some of the suspect vertexes:"
msgstr ""
"На диаграмме после распространения ограничений мы видим, что вершины A, B, "
"C, D, G и H не имеют интерпретаций, поэтому они являются хорошим местом для "
"поиска ошибки в первую очередь.\n"
"Из трассы(распечатанного следа), генерируемого `propagate-"
"constraints`(распространением ограничений (линии, начинающиеся с точки с "
"запятой), мы видим, что распространение ограничений началось в точке P и "
"после семи распространений достигло некоторых подозрительных вершин:"

#: in/chapter17.md:1107
msgid ""
"```lisp\n"
": A/2: (E/2 B/6 C/5)    ((L R +) (- - + ))\n"
": B/3: (D/5 A/2)        ((R L) (- L) (R -))\n"
": D/3: (C/5 B/3 M/6)    ((- - -) (- L R) (R - L))\n"
"```"
msgstr ""

#: in/chapter17.md:1114
msgid ""
"A and B look acceptable, but look at the entry for vertex D.\n"
"It shows three interpretations, and it shows that the neighbors are C, B, "
"and M.\n"
"Note that line DC, the first entry in each of the interpretations, must be "
"either -, - or R.\n"
"But this is an error, because the \"correct\" interpretation has DC as a + "
"line.\n"
"Looking more closely, we notice that D is in fact a W-type vertex, not a Y "
"vertex as written in the definition.\n"
"We should have:"
msgstr ""
"A и B выглядят приемлемо, но посмотрите на запись для вершины D.\n"
"Она показывает три интерпретации и показывает, что соседями являются C, B и "
"M.\n"
"Обратите внимание, что линия DC, первая запись в каждой из интерпретаций, "
"должна быть либо -, либо R.\n"
"Но это ошибка, потому что \"правильная\" интерпретация имеет DC как линию "
"+.\n"
"При более внимательном рассмотрении мы замечаем, что D на самом деле "
"является вершиной W-типа, а не вершиной Y, как написано в определении.\n"
"Мы должны иметь:"

#: in/chapter17.md:1133
msgid ""
"```lisp\n"
"(defdiagram arch\n"
"  (a W e b c)    (p L o q)\n"
"  (b L d a)      (q T p i r)\n"
"  (c Y a d g)    (r T j s q)\n"
"  (d W b m c)    (s L r t)          ;*d is a W, not Y*\n"
"  (e L a f)      (t W u s k)\n"
"  (f T e g n)    (u L t 4)\n"
"  (g W h f c)    (v L 2 4)\n"
"  (h T g i o)    (w W x 1 y)\n"
"  (i T h j q)    (x L w z)\n"
"  (j T i k r)    (y Y w 2 z)\n"
"  (k T J l t)    (z W 3 x y)\n"
"  (1 T k m 4)    (1 T n o w)\n"
"  (m L l d)      (2 W v 3 y)\n"
"  (n L f 1)      (3 L z 2)\n"
"  (o W P 1 h)    (4 T u l v))\n"
"```"
msgstr ""

#: in/chapter17.md:1140
msgid ""
"By running the problem again and inspecting the trace output, we soon "
"discover the real root of the problem: the most natural interpretation of "
"the diagram is beyond the scope of the program!\n"
"There are many interpretations that involve blocks floating in air, but if "
"we ground lines OP, TU and XZ, we run into trouble.\n"
"Remember, we said that we were considering trihedral vertexes only.\n"
"But vertex 1 would be a quad-hedral vertex, formed by the intersection of "
"four planes: the top and back of the base, and the bottom and left-hand side "
"of the left pillar.\n"
"The intuitively correct labeling for the diagram would have O1 be a concave "
"(-) line and Al be an occluding line, but our repertoire of labelings for T "
"vertexes does not allow this.\n"
"Hence, the diagram cannot be labeled consistently."
msgstr ""
"Запустив задачу еще раз и проверив вывод трассировки, мы вскоре обнаружим "
"настоящий корень проблемы: наиболее естественная интерпретация диаграммы "
"выходит за рамки программы!\n"
"Есть много интерпретаций, в которых блоки летают в воздухе, но если мы "
"заземлим линии OP, TU и XZ, мы столкнемся с проблемами.\n"
"Помните, мы говорили, что рассматриваем только трехгранные вершины.\n"
"Но вершина 1 будет четырехгранной вершиной, образованной пересечением "
"четырех плоскостей: верхней и задней части основания, а также нижней и левой "
"стороны левой колонны.\n"
"Интуитивно правильная маркировка для диаграммы будет иметь O1 вогнутой (-) "
"линией, а Al - закрывающей линией, но наш репертуар разметки для T вершин не "
"позволяет этого.\n"
"Следовательно, диаграмма не может быть корректно промаркирована."

#: in/chapter17.md:1144
msgid ""
"Let's go back and consider the error that came up in the first version of "
"the diagram.\n"
"Even though the error no longer occurs on this diagram, we want to make sure "
"that it won't show up in another case.\n"
"Here's the error:"
msgstr ""
"Вернемся назад и рассмотрим ошибку, появившуюся в первой версии диаграммы.\n"
"Несмотря на то, что ошибка больше не появляется на этой диаграмме, мы хотим "
"убедиться, что она не появится в другом случае.\n"
"Вот ошибка:"

#: in/chapter17.md:1148
msgctxt "in/chapter17.md:1148"
msgid ""
"```lisp\n"
">>>ERROR: The first argument to NTH was of the wrong type.\n"
"```"
msgstr ""

#: in/chapter17.md:1150
msgctxt "in/chapter17.md:1150"
msgid "`The function expected a fixnum >= z`e`ro.`"
msgstr "Функция ожидала fixnum >= `zero.`"

#: in/chapter17.md:1152
msgctxt "in/chapter17.md:1152"
msgid "`While in the function LABELS-FOR`<= `CONSISTENT-LABELINGS`"
msgstr "`Находясь в функции LABELS-FOR` <= `CONSISTENT-LABELINGS`"

#: in/chapter17.md:1156
msgctxt "in/chapter17.md:1156"
msgid ""
"```lisp\n"
"Debugger entered while in the following function:\n"
"```"
msgstr ""

#: in/chapter17.md:1159
msgctxt "in/chapter17.md:1159"
msgid ""
"`LABELS-FOR (P.C.\n"
"= 23)`"
msgstr ""

#: in/chapter17.md:1164
msgid ""
"```lisp\n"
"      Arg 0 (VERTEX): U/6\n"
"      Arg 1 (FROM): 4/4\n"
"```"
msgstr ""

#: in/chapter17.md:1170
msgid ""
"Looking at the definition of `labels-for`, we see that it is looking for the "
"from vertex, which in this case is 4, among the neighbors of U.\n"
"It was not found, so pos became nil, and the function nth complained that it "
"was not given an integer as an argument.\n"
"So this error, if we had pursued it earlier, would have pointed out that 4 "
"was not listed as a neighbor of U, when it should have been.\n"
"Of course, we found that out by other means.\n"
"In any case, there is no bug here to fix-as long as a diagram is guaranteed "
"to be consistent, the `labels-for` bug will not appear again."
msgstr ""
"Глядя на определение `labels-for`, мы видим, что он ищет исходную вершину, "
"которая в данном случае равна 4, среди соседей U.\n"
"Она не была найдена, поэтому pos стал nil, а функция nth пожаловалась, что "
"ей не было дано целое число в качестве аргумента.\n"
"Таким образом, эта ошибка, если бы мы преследовали ее раньше, указала бы на "
"то, что 4 не был указан как сосед U, хотя должен был быть.\n"
"Конечно, мы выяснили это другими способами.\n"
"В любом случае, здесь нет ошибки, которую нужно исправить - до тех пор, пока "
"диаграмма будет непротиворечивой, ошибка `label-for` больше не появится."

#: in/chapter17.md:1173
msgid ""
"This section has made two points: First, write code that checks the input as "
"thoroughly as possible.\n"
"Second, even when input checking is done, it is still up to the user to "
"understand the limitations of the program."
msgstr ""
"В этом разделе выделены два момента. Во-первых, пишите код, который "
"проверяет ввод как можно тщательнее.\n"
"Во-вторых, даже когда проверка ввода выполнена, пользователю по-прежнему "
"остается понять ограничения программы."

#: in/chapter17.md:1175
msgid "## 17.5 History and References"
msgstr "## 17.5 История и Ссылки"

#: in/chapter17.md:1184
msgid ""
"[Guzman (1968)](B9780080571157500285.xhtml#bb0500) was one of the first to "
"consider the problem of interpreting line diagrams.\n"
"He classified vertexes, and defined some heuristics for combining "
"information from adjacent vertexes.\n"
"[Huffman (1971)](B9780080571157500285.xhtml#bb0560) and [Clowes (1971)]"
"(B9780080571157500285.xhtml#bb0215) independently came up with more formai "
"and complete analyses, and David [Waltz (1975)](B9780080571157500285."
"xhtml#bb1300) extended the analysis to handle shadows, and introduced the "
"constraint propagation algorithm to eut down on the need for search.\n"
"The algorithm is sometimes called \"Waltz filtering\" in his honor.\n"
"With shadows and nontrihedral angles, there are thousands of vertex "
"labelings instead of 18, but there are also more constraints, so the "
"constraint propagation actually does better than it does in our limited "
"world.\n"
"Waltz's approach and the Huf f man-Clowes labels are covered in most "
"introductory AI books, including Rich and Knight 1990, [Charniak and "
"McDermott 1985](B9780080571157500285.xhtml#bb0175), and [Winston 1984]"
"(B9780080571157500285.xhtml#bb1405).\n"
"Waltz's original paper appears in *The Psychology of Computer Vision* "
"([Winston 1975](B9780080571157500285.xhtml#bb1400)), an influential volume "
"collecting early work done at MIT.\n"
"He also contributed a summary article on Waltz filtering ([Waltz 1990]"
"(B9780080571157500285.xhtml#bb1305))."
msgstr ""

#: in/chapter17.md:1187
msgid ""
"Many introductory AI texts give vision short coverage, but [Charniak and "
"McDermott (1985)](B9780080571157500285.xhtml#bb0175) and [Tanimoto (1990)]"
"(B9780080571157500285.xhtml#bb1220) provide good overviews of the field.\n"
"[Zucker (1990)](B9780080571157500285.xhtml#bb1450) provides an overview of "
"low-level vision."
msgstr ""

#: in/chapter17.md:1190
msgid ""
"[Ramsey and Barrett (1987)](B9780080571157500285.xhtml#bb0975) give an "
"implementation of a line-recognition program.\n"
"It would make a good project to connect their program to the one presented "
"in this chapter, and thereby go all the way from pixels to 3-D descriptions."
msgstr ""

#: in/chapter17.md:1192
msgid "## 17.6 Exercises"
msgstr "## 17.6 Упражнения"

#: in/chapter17.md:1195
msgid ""
"This chapter has solved the problem of line-labeling for polyhedra made of "
"trihedral vertexes.\n"
"The following exercises extend this solution."
msgstr ""

#: in/chapter17.md:1198
msgid ""
"**Exercise  17.1 [h]** Use the line-labeling to produce a face labeling.\n"
"Write a function that takes a labeled diagram as input and produces a list "
"of the faces (planes) that comprise the diagram."
msgstr ""

#: in/chapter17.md:1201
msgid ""
"**Exercise  17.2 [h]** Use the face labeling to produce a polyhedron "
"labeling.\n"
"Write a function that takes a list of faces and a diagram and produces a "
"list of polyhedra (blocks) that comprise the diagram."
msgstr ""

#: in/chapter17.md:1205
msgid ""
"**Exercise  17.3 [d]** Extend the system to include quad-hedral vertexes and/"
"or shadows.\n"
"There is no conceptual difficulty in this, but it is a very demanding task "
"to find all the possible vertex types and labelings for them.\n"
"Consult [Waltz 1975](B9780080571157500285.xhtml#bb1300)."
msgstr ""

#: in/chapter17.md:1207
msgid ""
"**Exercise  17.4 [d]** Implement a program to recognize lines from pixels."
msgstr ""

#: in/chapter17.md:1210
msgid ""
"**Exercise  17.5 [d]** If you have access to a workstation with a graphical "
"interface, implement a program to allow a user to draw diagrams with a "
"mouse.\n"
"Have the program generate output in the form expected by `construct-diagram`"
msgstr ""
