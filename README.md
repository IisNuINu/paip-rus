# paip-rus
Перевод книги Питера Норвига "Парадигмы программирования Искуственного Интелекта".
# *Парадигмы программирования искусственного интеллекта* 

![PAIP](https://norvig.com/paip-cover.gif)

# Содержание

- Предисловие
  * Почему Lisp? Почему Common Lisp?
  * Набросок книги
  * Как пользоваться этой книгой
  * Дополнительные тексты и справочники
  * Примечание по упражнениям
  * Благодарности
- **Часть I  Введение в Common Lisp**
- **1  Введение в Lisp**
  * 1.1  Символьные вычисления
  * 1.2  Переменные
  * 1.3  Специальные Формы
  * 1.4  списки
  * 1.5  Определение Новых Функций
  * 1.6  Использование Функций
  * 1.7  Функции Высшего Порядка
  * 1.8  Другие Типы Данных/
  * 1.9  Резюме: Правило Вычисления(Оценки) в Lisp
  * 1.10 Что Делает Лисп - Особенным?
  * 1.11 упражнения
  * 1.12 ответы
- **2  Простая Лисп Программа**
  * 2.1  Грамматика для подмножества английского языка
  * 2.2  Простое Решение
  * 2.3  Решение, Основанное На Правилах
  * 2.4  два пути следования
  * 2.5  изменение грамматики без изменения программы
  * 2.6  использование одних и тех же данных для нескольких программ
  * 2.7  упражнения
  * 2.8  ответы
- **3  Обзор Lisp**
  * 3.1  руководство по стилю Lisp
  * 3.2  Специальные Формы
      * Специальные формы для определений
      * Специальные формы для условий
      * Специальные формы для работы с переменными и местами
      * Функции и специальные формы для повторения
      * Повторение через рекурсию
      * Другие Специальные Формы
      * Макросы
      * Нотация Обратной Кавычки(Backquote)
  * 3.3  функции на списках
  * 3.4  равенство и внутреннее представителение
  * 3.5  функции на последовательностях
  * 3.6  функции для поддержки таблиц
  * 3.7  функции на деревьях
  * 3.8  функции работы с числами
  * 3.9  функции работы с множествами
  * 3.10 Разрушающие(Деструктивные) Функции
  * 3.11 обзор типов данных
  * 3.12 Ввод/Вывод
  * 3.13 инструменты отладки
  * 3.14 Инструменты борьбы  с ошибками
      * Инструменты Синхронизации
  * 3.15 Вычисление(оценка)
  * 3.16 Замыкания
  * 3.17 Специальные Переменные
  * 3.18 Множественные Значения
  * 3.19 подробнее о параметрах
  * 3.20 остальная часть Лиспа
  * 3.21 упражнения
  * 3.22 ответы
- **Часть II  Ранние программы искусственного интеллекта**
- **4  GPS:  Универсальный решатель проблем(General problem Solver)**
  * 4.1  Этап 1: Описание
  * 4.2  Этап 2: Спецификация
  * 4.3  Этап 3: Реализация
  * 4.4  Этап 4: Испытание
  * 4.5  Этап 5: Анализ, или &quot;мы солгали о G&quot;
  * 4.6  проблема блока - бег по кругу
  * 4.7  Проблема брат ломающий цель.
  * 4.8  проблема просмотре, прыжок перед вами
  * 4.9  проблема рекурсивная подцель
  * 4.10  проблема отсутствия промежуточной информации
  * 4.11  GPS Версия 2: более общий решатель проблем
  * 4.12  новая доменная проблема: обезьяна и бананы
  * 4.13  Домен Поиска Лабиринта
  * 4.14  Домен Мира Блоков(Blocks World)
      *  Аномалия Сассмана
  * 4.15 повторение этапа 5: Анализ версии 2
  * 4.16 отсутствие присмотра за вами не является проблемой прыжка
  * 4.17 проблема отсутствия описательной мощности
  * 4.18 Идеальная Информационная Проблема
  * 4.19 Проблема Взаимодействующих Целей
  * 4.20 Завершение GPS
  * 4.21 история и ссылки
  * 4.22 упражнения
  * 4.23 ответы
- **5  Элиза: Диалог с машиной **
   * 5.1  Описание и Спецификация Элизы
   * 5.2  Сопоставление с образцом
   * 5.3  Сопоставление сегментов образцов
   * 5.4  Программа Элиза: Преобразователь на основе правил
   * 5.5  История и ссылки
   * 5.6  Упражнения
   * 5.7  Ответы
- **6 Построение Программных Средств**
   * 6.1  Интерактивный Инструмент Интерпретатора
   * 6.2  Инструмент Сопоставления с образцом
   * 6.3  Инструмент Преобразования На Основе Правил
   * 6.4  набор инструментов поиска
       *  Поиск по Дереву
       *  Руководство поиском
       *  поиск пути
       *  Угадывание против гарантирования хорошего решения
       *  Поиск по Графу
   * 6.5  GPS как поиск
   * 6.6  истории и литературы
   * 6.7  упражнения
   * 6.8  ответы
- **7  Student:  Решение алгебраических задач со словами **
   * 7.1  Перевод английского языка в уравнения
   * 7.2  Решение алгебраических уравнений
   * 7.3  Примеры
   * 7.4  История и ссылки
   * 7.5  Упражнения
   * 7.6  Ответы
- **8  Символьная математика: программа упрощения **
   * 8.1  Преобразование инфиксной в префиксную нотацию
   * 8.2  Правила упрощения
   * 8.3  Ассоциативность и коммутативность
   * 8.4  Логарифмы(Logs), Тригонометрия(Trig), и Дифференциалы(Diff)
   * 8.5  Пределы подход основанный на правилах
   * 8.6  Интегрирование
   * 8.7  История и ссылки
   * 8.8  упражнения
- **Part III  Инструменты и Техники**
- **9  Вопросы эффективности**
   * 9.1. Кэширование результатов предыдущих вычислений: запоминание
   * 9.2  Компиляция одного языка на другой
   * 9.3  Задержка вычислений
   * 9.4  Индексация данных
   * 9.5  Инструментарий: решение, что оптимизировать
   * 9.6  Пример эффективности: программа SIMPLIFY(упрощение)
       *  Запоминание результатов(Memoization)
       *  Индексирование
       *  Компиляция 
       *  Компилятор с одним правилом
       *  Компилятор с набором правил
   * 9.7  История и ссылки
   * 9.8  Упражнения
   * 9.9  Ответы
- **10  Проблемы Эффективности на Низком Уровне **
   * 10.1  Используйте Обявлений(Declarations)
   * 10.2  Избегайте Общих Функций
   * 10.3  Избегайте Сложных Списков Аргументов
   * 10.4  Избегайте Ненужного создания списков(Consing)
        * Избегайте лишних списков: Уникальные Списки
        * Избегайте лишних списков: множественные Значения
        * Избегайте лишних списков: Ресурсы
   * 10.5  Используйте правильные структуры данных
        * Правильная Структура Данных: Переменные
        * Правильная Структура Данных: Очередь
        * Правильная Структура Данных: Таблицы
   * 10.6  упражнения
   * 10.7  ответы
- **11  Логическое программирование**
   * 11.1  Идея 1: Единая База Данных
   * 11.2  Идея 2: унификация логических переменных
       * Программирование с помощью пролога
   * 11.3  Идея 3: Автоматическая Трасировка вызовов
       * Подходы к обратному отслеживанию
       * Анонимные Переменные
   * 11.4  Головоломка Зебра
   * 11.5  Синергия трассировки вызовов и унификации
   * 11.6  Разрушающая Унификация
   * 11.7  Пролог В прологе
   * 11.8  пролог в сравнении с Lisp
   * 11.9  история и литература
   * 11.10 упражнения
   * 11.11 ответы
- **12  Компиляция Логических Программ**
  * 12.1  Компилятор Пролога
  * 12.2  Исправление ошибок в компиляторе
  * 12.3  совершенствование компилятора
  * 12.4  совершенствование компиляции, унификация
  * 12.5  дальнейшее совершенствование унификации
  * 12.6  пользовательский интерфейс компилятора
  * 12.7  измерение скорости компилятора
  * 12.8  Добавление Дополнительных Примитивов
  * 12.9  Разрез(Cut)
  * 12.10 &quot;Реальный&quot; Пролог
  * 12.11 история и ссылки
  * 12.12 упражнения
  * 12.13 ответы
- **13  Объектно-Ориентированное Программирование**
  * 13.1  Объектно-Ориентированное Программирование
  * 13.2  Объекты
  * 13.3  Обобщенные Функции
  * 13.4  Классы
  * 13.5  Делегирование
  * 13.6  наследование
  * 13.7  CLOS: система объектов Common Lisp
  * 13.8  пример CLOS: инструменты поиска
      *  Поиск По Первому Наилучшему(Best-First)
  * 13.9  является ли CLOS объектно-ориентированным?
  * 13.10 преимущества объектно-ориентированного программирования
  * 13.11 история и ссылки
  * 13.12 упражнения
- **14 Представление знаний и рассуждение**
  * 14.1  таксономия языков представления
  * 14.2  исчисление предикатов и его проблемы
  * 14.3  Логический Язык: Пролог
  * 14.4  проблемы с выразительностью пролога
  * 14.5  проблемы с выразительностью исчисления предикатов
  * 14.6  проблемы с полнотой
  * 14.7  проблемы с эффективностью: индексация
  * 14.8  решение проблемы индексации
  * 14.9  решение проблемы полноты
  * 14.10 решения проблем выразительности
      * Предикаты Более Высокого Порядка
      * Усовершенствованния
      * Язык Фреймов
      * Возможные миры: истина, отрицание и дизъюнкция
      * Унификация, равенство, типы и константы Сколема
  * 14.11 истории и литературы
  * 14.12 упражнения
  * 14.13 ответов
- **Part IV  Продвинутые программы искусственного интеллекта**
- **15 символическая математика с каноническими формами**
  * 15.1  каноническая форма для многочленов
  * 15.2  Дифференцирование Полиномов
  * 15.3  преобразование между Инфиксной и Префиксной формой
  * 15.4  сравнительный анализ полиномиального Упростеля
  * 15.5  каноническая форма для рациональных выражений
  * 15.6  Расширение Рациональных Выражений
  * 15.7  история и литература
  * 15.8  упражнения
  * 15.9  ответов
- **16  Экспертные Системы**
  * 16.1  Работа с неопределенностью
  * 16.2  Кэширование Производных(Выведенных) Фактов
  * 16.3  Задавать Вопросы
  * 16.4  контексты вместо переменных
  * 16.5  Повторный просмотр Обратной Цепочки
  * 16.6  взаимодействие с экспертом
  * 16.7  взаимодействие с клиентом
  * 16.8  MYCIN, медицинская экспертная система
  * 16.9  альтернативы определенным факторам
  * 16.10 история и литература
  * 16.11 упражнения
  * 16.12 ответы
- **17  Маркированные линейные диаграммы по удовлетворению ограничений**
  * 17.1  Проблема Линейной Маркировки
  * 17.2  комбинирование ограничений и поиск
  * 17.3  Схемы Маркировки
  * 17.4  проверка диаграмм на наличие ошибок
  * 17.5  история и литература
  * 17.6  упражнения
- **18  Поиск и игра Отелло**
  * 18.1  правила игры
  * 18.2  Выбор Представления
  * 18.3  Вычисление(Оценка) Позиций
  * 18.4  Поиск Впереди: Минимакс
  * 18.5  Интеллектуальный Поиск: Альфа-Бета-Поиск
  * 18.6  анализ некоторых игр
  * 18.7  турнирная версия Отелло
  * 18.8  игра в серию игр
  * 18.9  Более Эффективный Поиск
  * 18.10 это платит за Предцикл
  * 18.11 Убийственные Ходы
  * 18.12 чемпионские программы: Яго и Билл
      * Мобильность
      * Стабильность Края
      * Комбинирование факторов
  * 18.13 Другие Методы
      * Интерактивное Углубление
      * Прямая Обрезка
      * Неспецифическая Прямая Обрезка
      * Поиск Устремленности
      * думать наперед
      * Хеширование и открытие книжных ходов
      * Конец Игры
      * Метареазонирование
      * Обучение
  * 18.14 история и ссылки
  * 18.15 упражнения
  * 18.16 ответы
- **19  Введение в Естественные Языки**
  * 19.1  Синтаксический разбор с грамматикой структуры фразы
  * 19.2  расширение грамматики и признание двусмысленности
  * 19.3  более эффективный синтаксический анализ
  * 19.4  Проблема Неизвестного Слова
  * 19.5  синтаксический анализ в семантическое представление
  * 19.6  синтаксический анализ с предпочтениями
  * 19.7  проблема с контекстно-свободными правилами построения фраз
  * 19.8  история и ссылки
  * 19.9  упражнения
  * 19.10 ответы
- **20  Унификация Грамматики**
  * 20.1  синтаксический анализ как дедукция
  * 20.2  Определенние Грамматики  Предложений
  * 20.3  простая грамматика в формате DCG
  * 20.4  грамматика DCG с Кванторами
  * 20.5  Сохранение неопределенности квантификатора
  * 20.6  Зависимости На Больших Расстояниях
  * 20.7  расширение правил DCG
  * 20.8  история и литература
  * 20.9  упражнения
  * 20.10 ответы
- **21 Грамматика английского языка **
   * 21.1 Фразы существительных
   * 21.2 Модификаторы
   * 21.3 Модификаторы существительных
   * 21.4 Определители
   * 21,5 Глагольные фразы
   * 21,6 Наречия
   * 21,7 Предложения
   * 21,8 Изречения
   * 21,9 XPs
   * 21.10 Категории слов
   * 21.11 Лексикон
       * Глаголы
       * Вспомогательные глаголы
       * Существительные
       * Местоимения
       * Имена
       * Прилагательные
       * Наречия
       * Артикли
       * Кардинальные и Порядковые Числа
       * Предлоги
   * 21.12 Поддержка лексики
   * 21.13 Другие примитивы
   * 21.14 Примеры
   * 21.15 История и ссылки
   * 21.16 Упражнение
- **Part V  Остальная часть Лиспа **
- ** 22 Scheme: необычный Лисп **
   * 22.1 Интерпретатор Scheme
   * 22.2 Синтаксическое расширение с помощью макросов
   * 22.3 Правильный интерпретатор хвостовой рекурсии
   * 22.4 Throw, Catch и Call/cc
   * 22.5 Интерпретатор поддерживающий Call/CC
   * 22.6 История и ссылки
   * 22.7 Упражнения
   * 22.8 ответы
- **23  Компиляция Лисп**
   * 23.1. Правильно обрабатывающий хвостовую рекурсию компилятор Lisp
   * 23.2 Введение в Call/CC
   * 23.3 Абстрактная машина
   * 23.4 Оптимизатор Peephole(Смотрового отверстия)
   * 23.5 Языки с различными лексическими соглашениями
   * 23.6 История и ссылки
   * 23.7 Упражнения
   * 23.8 ответы
- **24  ANSI Common Lisp**
   * 24.1  Пакеты
       * Семь Пространств Имен
   * 24.2 Условия и обработка ошибок
       * Сигналы об шибках
       * Обработка ошибок
   * 24.3 Симпатичная печать
   * 24,4 Последовательности
   * 24.5 Макрос Loop(петля)
       * Анатомия Loop
       * Контроль итераций (26.6)
       * Контроль проверки завершения (26.7)
       * Значение Аккумулятора (26.8)
       * Инициализация переменной (26,9)
       * Условное исполнение (26.10)
       * Безусловное выполнение (26.11)
       * Разные особенности (26.12)
   * 24.6 Функции работы с последовательностями
       * Один раз: урок науки о макросах(Macrology)
       * Избегайте чрезмерного использования макросов
       * MAP-INTO
       * REDUCE с :key
   * 24.7 Упражнения
   * 24.8 ответы
- **25  Решение проблем**
   * 25.1  Ничего Не Происходит
   * 25.2  изменение переменной не имеет никакого эффекта
   * 25.3  изменение функции не имеет никакого эффекта
   * 25.4  значения меняются "сами по себе".;
   * 25.5  встроенные функции не находят элементы
   * 25.6  Несколько Значений Теряются
   * 25.7  Декларации Игнорируются
   * 25.8  мой Лисп делает что-то не так
   * 25.9  как найти нужную функцию
   * 25.10 синтаксис LOOP
   * 25.11 синтаксис COND
   * 25.12 синтаксис CASE
   * 25.13 синтаксис LET и LET*
   * 25.14 проблемы с макросами
   * 25.15 руководство по стилю Lisp
       * Для определения функции
       * Когда следует определить специальную переменную
       * Когда связывать лексическую переменную
       * Как выбрать имя
       * Принятие решения о порядке следования параметров
   * 25.16 работа с файлами, пакетами и системами
   * 25.17 Проблемы Переносимости
   * 25.18 упражнения
   * 25.19 ответы
- Приложение
- Библиография
- Индекс