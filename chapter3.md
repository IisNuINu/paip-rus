# Глава 3
## Обзор Lisp

> Никаких сомнений.

>Common Lisp - это *большой* язык.


> -Guy L. Steele, Jr.

> Предисловие к Кошману 1990

В этой главе кратко рассматриваются наиболее важные специальные формы и функции в Lisp.
Она может быть безопасно пропущена или пропущена опытным программистом Common Lisp, но необходима для чтения начинающим программистом Lisp или тем, кто новичок в диалекте Common Lisp.

Эта глава может быть использована в качестве справочного источника, но окончательная ссылка-это Стил *Common Lisp The Language*, 2d edition, к которому следует обращаться всякий раз, когда возникает какая-либо путаница.
Поскольку эта книга в 25 раз длиннее, чем эта глава, ясно, что мы можем коснуться здесь только важных моментов.
Более подробное освещение дается ниже в этой книге, поскольку каждая функция используется в реальной программе.

## 3.1 Руководство по Лисп стилю

Начинающий программист Common Lisp часто перегружен количеством опций, которые предоставляет язык.
В этой главе мы покажем четырнадцать различных способов определения длины списка.
Как программисту выбирать между ними?
Один из ответов - это чтение примеров хороших программ, как показано в этой книге, и копирование этого стиля.
В общем, есть шесть Максим(Заповедей), которым должен следовать каждый программист:

* Быть конкретными.
* Использовать абстракции.
* Быть кратким.
* Использовать предоставленные инструменты.
* Не быть непонятным.
* Быть последовательным.

Они требуют некоторого объяснения

Использование максимально конкретной формы облегчает читателю вашей программы понимание ваших намерений.
Например, условная специальная форма `when`(когда) более конкретна, чем `if`(если).
Читатель, который видит `when`, знает, что нужно искать только одну вещь: предложение, которое нужно учитывать, когда тест истинен.
Читатель, который видит `if`, может с полным правом ожидать двух предложений: одно для ситуации, когда тест истинен, и одно для того, когда тест ложен.
Даже если можно использовать `if`, когда есть только одно предложение, предпочтительнее использовать `when`, потому что `when` более конкретно.

Одним из важных способов быть конкретным является использование абстракций.
Lisp предоставляет очень общие структуры данных, такие как списки и массивы.
Они могут быть использованы для реализации конкретных структур данных, которые будут использоваться вашей программой, но вы не должны совершать ошибку, вызывая примитивные функции напрямую.
Если вы определяете список имен

```lisp
(defvar *names* '((Robert E. Lee) ...))
```

затем вы также должны определить функции, чтобы добраться до компонентов каждого имени.
Чтобы добраться до `Lee`, используйте `(last-name (first *names*))`, а не `(caddar *names*)`.

Часто Максимы(Заповеди) находятся в согласии.
Например, если ваш код пытается найти элемент в списке, вы должны использовать `find` (или, возможно, `find-if`), а не `loop` или `do`.
`find`(найти) более конкретна, чем общие конструкции цикла `loop` или `do` - эта абстракция более лаконична, является встроенным инструментом и ее легко понять.

Иногда, однако, заповеди вступают в конфликт, и опыт подскажет вам, какую из них предпочесть.
<a id="tfn03-1"></a>
Рассмотрим следующие два способа размещения новой пары ключ/значение в ассоциативном списке:[[1]](#fn03-1)

```lisp
(push (cons key val) a-list)
(setf a-list (acons key val a-list))
```

Первый более лаконичен.
Но второй более специфичен/конкретен, так как он использует функцию `acons`, которая разработана специально для ассоциативных списков.
Выбор между ними, вероятно, зависит от известности функций: те, кто считает `acons` знакомой функцией, предпочтут второй вариант, а те, кто считает ее непонятной(или малоизвестной), предпочтут первый.

Аналогичный выбор возникает и в вопросе о присвоении переменной значения.
Некоторые предпочтут `(setq x val)`, потому что он наиболее специфичен для данной ситуации; другие используют `(setf x val)`, чувствуя, что более последовательно использовать одну форму, `setf`, для всех обновлений.
Какой бы выбор вы ни сделали в таких вопросах, помните шестую Максиму: будьте последовательны.

## 3.2 Специальные Формы

Как отмечалось в [главе 1] (chapter1.md), "специальная форма" - это термин, используемый для обозначения как синтаксических конструкций Common Lisp, так и зарезервированных слов, которые обозначают/маркируют эти конструкции.

Наиболее часто используемые специальные формы:

| определения    | условия     | переменные| итерации  | другое     |
|----------------|-------------|-----------|-----------|------------|
| `defun`        | `and`       | `let`     | `do`      | `declare`  |
| `defstruct`    | `case`      | `let*`    | `do*`     | `function` |
| `defvar`       | `cond`      | `pop`     | `dolist`  | `progn`    |
| `defparameter` | `if`        | `push`    | `dotimes` | `quote`    |
| `defconstant`  | `or`        | `setf`    | `loop`    | `return`   |
| `defmacro`     | `unless`    | `incf`    |           | `trace`    |
| `labels`       | `when`      | `decf`    |           | `untrace`  |

Если быть точным, то только `declare`, `function`, `if`, `labels`, `let`, `let*`, `progn` и `quote` настоящие специальные формы.
Остальные фактически определяются как макросы, которые расширяются в вызовы более примитивных специальных форм и функций.
Для программиста нет никакой реальной разницы, и реализации Common Lisp могут свободно реализовывать макросы как специальные формы и наоборот, поэтому для простоты мы будем продолжать использовать "специальную форму" в качестве общего термина как для истинных специальных форм, так и для встроенных макросов.

### Специальные формы для определений

В этом разделе мы рассмотрим специальные формы, которые могут быть использованы для введения новых глобальных функций, макросов, переменных и структур.
Мы уже видели форму `defun` для определения функций; форма `defmacro` аналогична и рассматривается на [стр. 66](#p66).

> `(defun` *function-name (parameter...) "optional documentation" body...*)
>
> `(defmacro` *macro-name (parameter...) "optional documentation" body...*)

Существует три формы введения специальных переменных.
`defvar` определяет специальную переменную и может быть дополнительно использован для предоставления начального значения и строки документации.
Начальное значение вычисляется и присваивается только в том случае, если переменная еще не имеет никакого значения, `defparameter` аналогичен, за исключением того, что значение является обязательным, и он будет использоваться для изменения любого существующего значения, `defconstant` используется для объявления того, что символ всегда будет означать определенное значение.

> `(defvar` *variable-name initial-value "optional documentation"* )

> `(defparameter` *variable-name value "optional documentation"*)

> `(defconstant` *variable-name value "optional documentation"*)

Все формы "def -" определяют глобальные объекты.
Кроме того, как мы увидим, можно определить локальные переменные с помощью `let`, а локальные функции - с помощью `labels`.

Большинство языков программирования предоставляют возможность группировать связанные данные в структуру.
Common Lisp не является исключением.
Специальная форма `defstruct` определяет тип структуры (известный как тип *record* в Pascal) и автоматически определяет функции для доступа к компонентам структуры.
Общий синтаксис таков:

> `(defstruct` *structure-name "optional documentation" slot...*)

Например, мы могли бы определить структуру для имен:

```lisp
(defstruct name
  first
  (middle nil)
  last)
```

Она автоматически определяет функцию конструктора `make-name`, предикат распознавателя `name-p` и функции доступа `name-first, name-middle` и `name-last`.
`(middle nil)` означает, что каждое новое имя(name), построенное с помощью `make-name`, по умолчанию будет иметь среднее имя(middle) равное `nil`.
Здесь мы можем создавать, получать доступ и изменять структуру:

```lisp
> (setf b (make-name :first 'Barney :last 'Rubble)) =>
#S(NAME :FIRST BARNEY :LAST RUBBLE)

> (name-first b) => BARNEY

> (name-middle b) => NIL

> (name-last b) => RUBBLE

> (name-p b) => T

> (name-p 'Barney) => NIL ; only the results of make-name are names

> (setf (name-middle b) 'Q) => Q

> b => #S(NAME :FIRST BARNEY :MIDDLE Q :LAST RUBBLE)
```

Печатное представление структуры начинается с буквы `#S` и сопровождается списком, состоящим из типа структуры и чередующихся пар имен слотов и значений.
Не позволяйте этому представлению обмануть вас: это удобный способ печати структуры, но это не точная картина того, как структуры представлены внутри.
Структуры на самом деле реализуются очень похоже на векторы.
Для структуры `name`, это тип который будет находиться в нулевом элементе вектора, первое имя(first)-в первом элементе, среднее(middle)-во втором и последнее(last)-в третьем.
Это означает, что структуры более эффективны, чем списки: они занимают меньше места, и любой элемент может быть доступен в один шаг.
Список требует *n* шагов для доступа к *n*-му элементу.

Есть опции, которые дают больше контроля над самой структурой и отдельными слотами.
Они будут описаны позже, когда появится в них необходимость.

### Специальные формы для условий

Мы видели специальную форму `if`, которая имеет вид (`if` *test then-part else-part*), где *then-part* или *else-part* даст значение формы, в зависимости от успешности теста *test.*
Помните, что только `nil` считается ложью; все остальные значения считаются истинными для целей условных обозначений.
Однако константа `t` - это всеми принимаемое значение, используемое для обозначения истины (если только нет веской причины использовать какое-то другое значение).

На самом деле существует довольно много специальных форм для выполнения условных вычислений.
Технически, `if` определяется как специальная форма, в то время как другие условные обозначения являются макросами, поэтому в некотором смысле `if` считается самой базовой формой.
Некоторые программисты предпочитают использовать `if` для большинства своих условных обозначений; другие предпочитают `cond`, потому что он был самым длинным и универсальным (если не особенно красивым).
Наконец, некоторые программисты выбирают стиль, больше похожий на английскую прозу, и свободно используют `when, unless, if` и все остальные.

В следующей таблице показано, как каждое условие может быть выражено в терминах `if` и `cond`.
На самом деле эти преобразования не совсем верны, потому что `or, case` и `cond` заботятся о том, чтобы не вычислять какое-либо выражение более одного раза, в то время как преобразования с `if` могут привести к многократному вычислению некоторых выражений.
В таблице также есть преобразования в `cond`. Синтаксис `cond` представляет собой ряд предложений *cond-clauses*, каждое из которых состоит из тестового выражения, за которым следует произвольное количество *result* выражений:

```
(cond (test result...)
      (test result...)
      ...)
```

`cond` проходит по предложениям cond-clauses по одному за раз, вычисляя каждое тестовое выражение.
Как только тестовое выражение вычисляет не-nil значение, вычисляется каждое результирующее выражение для этого предложения, и последнее выражение в предложении является значением всего `cond`.
В частности, если предложение cond-clause состоит только из теста и никаких результирующих выражений, то значением `cond` является значение самого тестового выражения, если оно не равно nil.
Если все выражения вычисляются в nil, то nil будет возвращен как значение `cond.` Распространенная идиома состоит в том, чтобы сделать последнее предложение cond-clause выражением по умолчанию `(t *result...*)`.

Формы `when` и `unless` действуют как единичное предложение `cond`.
Обе формы состоят из теста, за которым следует любое количество последовательных выражений, которые вычисляются, если тест удовлетворен - то есть, если тест истинен для `when` или ложен для `unless`.

Форма `and` проверяет, истинно ли каждое из условий списка, а форма `or` проверяет, истинно ли какое-либо из них.
Оба вычисляют аргументы слева направо и останавливаются, как только можно определить окончательный результат.
Вот таблица эквивалентностей:

| **conditional**                  | `if` **form**                       | `cond` **form**                    |
|----------------------------------|-------------------------------------|------------------------------------|
| `(when` *test a b c*)            | `(if` *test* `(progn` *a  b c*))    | `(cond` (*test a b c*))            |
| `(unless` *test x y*)            | `(if (not` *test*) `(progn` *x y*)) | `(cond ((not` *test*) *x y*))      |
| `(and` *a b c*)                  | `(if` *a* `(if` *b c*))             | `(cond` (*a* `(cond` (*b c*))))    |
| `(or` *a b c*)                   | `(if` *a a* `(if` *b b c*))         | `(cond (a)` (*b*) (*c*))           |
| `(*case*` *a* (*b c*) `*(t x*))` | `(if (eql` *a 'b*) *c x*)           | `(cond ((eql `*a 'b*) *c*) (*tx*)) |

Считается плохим стилем использовать `and` и `or` для чего-либо, кроме проверки логического условия, `when, unless` и `if` могут быть использованы для выполнения условных действий.
Например:

```lisp
(and (> n 100)
     (princ "N is large."))    ; Bad style!
(or (<= n 100)
    (princ "N is large."))    ; Even worse style!
(cond ((> n 100)        ; OK, but not MY preference
      (princ "N is large."))
(when (> n 100)
  (princ "N is large."))    ; Good style.
```

Когда основная цель состоит в том, чтобы вернуть значение, а не предпринимать действия,  предпочтительнее использовать `cond` и `if`(с явным `nil` для случая else), чем `when` и `unless`, которые неявно возвращают `nil` в случае else, `when` и `unless` предпочтительнее, когда есть только одна возможность, `if` (или, для некоторых людей, `cond`), когда их два, и `cond`, когда их больше двух:

```lisp
(defun tax-bracket (income)
  "Determine what percent tax should be paid for this income."
  (cond ((< income 10000.00) 0.00)
        ((< income 30000.00) 0.20)
        ((< income 50000.00) 0.25)
        ((< income 70000.00) 0.30)
        (t                   0.35)))
```

Если существует несколько тестов, сравнивающих выражение с константами, то `case` является подходящим.
Форма `case` выглядит следующим образом:

> `(case` *expression*  
      (*match result*...)...)

*expression* вычисляется и сравнивается с каждым последующим *match*.
Как только одно из них становится равным в смысле: `eql`, вычисляются выражения *result* и возвращается значение последнего.
Обратите внимание, что выражения *match* не вычисляются.
Если выражение *match* является списком, то case проверяет, является ли *expression* равным в `eql` для любого члена списка.
Если выражение *match* является символом `otherwise` (или символом `t`), то оно соответствует чему угодно.
(Это имеет смысл только для того, чтобы это предложение `otherwise` было последним.)

Существует также другая специальная форма, `typecase`, которая сравнивает тип выражения с несколькими возможностями и, как и `case`, выбирает первое предложение, которое соответствует.
Кроме того, специальные формы `ecase` и `etypecase` подобные `case` и `typecase` за исключением того, что они сигнализируют об ошибке, если нет соответствия.

Вы можете думать, что буква `e` означает либо "exhaustive/исчерпывающий", либо "error/ошибка".
Формы "ccase" и "ctypecase" также сигнализируют об ошибках, но они могут быть continuable ошибками (в отличие от фатальных ошибок): пользователю предлагается возможность изменить выражение на то, что удовлетворяет одному из искомых соответствий.
Вот несколько примеров case форм и их `cond` эквивалентов:

| []()                 |                                    |
|----------------------|------------------------------------|
| `(case x`            | `(cond`                            |
| `(1 10)`             | `((eql x 1) 10)`                   |
| `(2 20))`            | `((eql x 2) 20))`                  |
|                      |                                    |
| `(typecase x`        | `(cond`                            |
| `(number (abs x))`   | `((typep x 'number) (abs x))`      |
| `(list (length x)))` | `((typep x 'list) (length x)))`    |
|                      |                                    |
| `(ecase x`           | `(cond`                            |
| `(1 10)`             | `((eql x 1) 10)`                   |
| `(2 20))`            | `((eql x 2) 20)`                   |
|                      | `(t (error "no valid case")))`     |
|                      |                                    |
| `(etypecase x`       | `(cond`                            |
| `(number (abs x))`   | `((typep x 'number) (abs x))`      |
| `(list (length x)))` | `((typep x 'list) (length x))`     |
|                      | `(t (error "no valid typecase")))` |

### Специальные формы для работы с переменными и местами

Специальная форма `setf` используется для присвоения нового значения переменной или *place/месту*, так же как оператор присваивания  `=` или `:=` используется в других языках.
Место(place), или *обобщенная переменная* - это наименование местоположения, в котором может храниться значение.
Вот таблица соответствующих форм присвоения в Lisp и Pascal:

| []()                        |                      |
|-----------------------------|----------------------|
| `;; Lisp`                   | `/* Pascal */`       |
| `(setf x 0)`                | `x := 0;`            |
| `(setf (aref A i j) 0)`     | `A[i,j] := 0;`       |
| `(setf (rest list) nil)`    | `list^.rest := nil;` |
| `(setf (name-middle b) 'Q)` | `b\middle := "Q";`   |

`setf` можно использовать как для установки компонента структуры, так и для установки переменной.
В таких языках, как Pascal, выражения, которые могут появляться в левой части инструкции присваивания, ограничены синтаксисом языка.
В Лиспе, пользователь может расширить выражения, которые допустимы в форме `setf` используя специальные формы `defsetf` или `define-setf-method`
Они представлены на [страницах 514](B9780080571157500157.xhtml#p514) и [884](B978008057115750025X.xhtml#p884) соответственно.

Есть также некоторые встроенные функции, которые изменяют места.
Например, (`rplacd список nil`) имеет такой же эффект, как (`setf` (`rest list`) `nil`), за исключением того, что он возвращает `list` вместо `nil`.
Большинство программистов Common Lisp предпочитают использовать формы  `setf`, а не специализированные функции.

Если вы хотите установить только переменную, то вместо нее можно использовать специальную форму setq.
В этой книге я предпочитаю использовать `setf` повсюду, предпочитая последовательность специфике.

Обсуждение в этом разделе заставляет думать, что переменным (и слотам структур) все время присваиваются новые значения.
На самом деле, многие программы Lisp вообще не выполняют никаких присваиваний.
Очень часто используется Lisp в функциональном стиле, где могут быть введены новые переменные, но как только новая переменная установлена, она никогда не меняется.
Один из способов ввести новую переменную - это ввести ее в качестве параметра функции.
Кроме того, можно ввести локальные переменные, используя специальную форму `let`.
Ниже приводится общая форма `let`, а также пример.
Каждая переменная привязывается к соответствующему значению, а затем тело вычисляется:

> `(let` ((*variable value*)...)  
> *body*...)

```lisp
(let ((x 40)
       (y (+ 1 1)))
  (+ x y)) => 42
```

Определение локальной переменной с помощью формы `let` на самом деле ничем не отличается от определения параметров анонимной функции.
Первое эквивалентно:

| []()                        |
|-----------------------------|
| ((`lambda` (*variable*... ) |
| `  ` *body*... )            |
| *value*...)                 |

```lisp
((lambda (x y)
     (+ x y))
40
(+ 1 1))
```

Во-первых, все значения вычисляются.
Затем они привязываются к переменным (параметрам лямбда-выражения), и, наконец, тело вычисляется, используя эти привязки.

Специальная форма `let*` подходит, когда вы хотите использовать одну из вновь введенных переменных в последующем вычислении *value*.
Например:

```lisp
(let* ((x 6)
       (y (* x x)))
  (+ x y)) => 42
```

Мы не могли бы использовать здесь `let`, потому что тогда переменная `x` была бы несвязана во время вычисления значения `y`.

&#9635; **Упражнение 3.1 [m]** покажите выражение `lambda`, эквивалентное приведенному выше выражению `let*`.
Вам может понадобиться больше, чем одна `lambda.`

Поскольку списки очень важны для Lisp, существуют специальные формы для добавления и удаления элементов из передней части списка - другими словами, для обработки списка как стека.
Если '`list` - это имя местоположения, содержащего список, то (`push` *x* `list`) изменит `list`, чтобы иметь *x* в качестве его первого элемента, и (`pop list`) вернет первый элемент и, как побочный эффект, изменит `list`, чтобы он больше не содерал первый элемент.
`push` и `pop` эквивалентны следующим выражениям:

```lisp
(push x list) = (setf list (cons x list))
(pop list)    = (let ((result (first list)))
                 (setf list (rest list))
                 result)
```

Точно так же, как список может использоваться для накопления элементов, вызов sum может использоваться для накопления чисел.
Lisp предоставляет еще две специальные формы, `incf` и `decf`, которые могут быть использованы для увеличения или уменьшения суммы.
Для обеих форм первым аргументом должно быть местоположение (переменная или другая `setf` - подобная форма), а вторым аргументом, который является необязательным, является число, на которое нужно увеличивать или уменьшать.
Для тех, кто знает Си, (`incf x`) эквивалентно `++x`, а (`incf x 2`) эквивалентно `x+=2`.
В Лиспе эквивалентны формы:

```lisp
(incf x) = (incf x 1) = (setf x (+ x 1))
(decf x) = (decf x 1) = (setf x (- x 1))
```

Когда расположение представляет собой сложную форму, а не переменную, Lisp осторожно расширяется в код, который не вычисляет ни одну подформу более одного раза.
Это справедливо для `push`, `pop`, `incf` и `decf`.
В следующем примере у нас есть список игроков, и мы хотим решить, какой игрок имеет самый высокий балл и, таким образом, выигрывает игру.
Структура `player` имеет слоты для счета(score) игрока и количества побед, а функция `determine-winner` увеличивает поле `wins` победившего игрока.
Расширение формы 'incf' связывает временную переменную, так что сортировка не выполняется дважды.

```lisp
(defstruct player (score 0) (wins 0))

(defun determine-winner (players)
  "Increment the WINS for the player with highest score."
  (incf (player-wins (first (sort players #'>
                                  :key #'player-score)))))

(defun determine-winner (players)
   "Increment the WINS for the player with highest score."
   (let ((temp (first (sort players #'> :key #'player-score))))
      (setf (player-wins temp) (+ (player-wins temp) 1))))
```

### Функции и специальные формы для повторения

Многие языки имеют небольшое количество зарезервированных слов для формирования итерационных циклов.
Например, Паскаль имеет выражения `while, repeat` и `for`
В отличие от него, Common Lisp обладает почти ошеломляющим диапазоном возможностей, как показано ниже:

| []()                  |                                 |
|-----------------------|---------------------------------|
| `dolist`              | loop over elements of a list    |
| `dotimes`             | loop over successive integers   |
| `do, do*`             | general loop, sparse syntax     |
| `loop`                | general loop, verbose syntax    |
| `mapc, mapcar`        | loop over elements of lists(s)  |
| `some, every`         | loop over list until condition  |
| `find, reduce,`*etc.* | more specific looping functions |
| *recursion*           | general repetition              |

Для объяснения каждой возможности мы представим версии функции `length`, которая возвращает количество элементов в списке.
Во-первых, специальная форма `dolist` может использоваться для перебора элементов списка.
Синтаксис таков:

> `(dolist (`*variable list optional-result*) *body...*)

Это означает, что тело выполняется один раз для каждого элемента списка, причем *variable* связывается к первому элементу, затем ко второму элементу и так далее.
В конце концов, `dolist` вычисляет и возвращает выражение *optional-result*, или nil, если нет выражения для возврата результата.

Ниже приведена версия `length` с использованием `dolist`.
Форма `let` вводит новую переменную, `len`, которая изначально привязана к нулю.
Затем форма `dolist` выполняет тело один раз для каждого элемента списка, причем тело каждый раз увеличивает `len` на единицу.
Это использование необычно тем, что переменная итерации цикла, `element`, не используется в теле.

```lisp
(defun length1 (list)
  (let ((len 0))            ; start with LEN=0
    (dolist (element list)  ; and on each iteration
      (incf len))           ;  increment LEN by 1
    len))                   ; and return LEN
```

Также можно использовать необязательный результат `dolist`, как показано ниже.
В то время как многие программисты используют этот стиль, я нахожу, что слишком легко потерять след результата, и поэтому я предпочитаю явно размещать результат последним.

```lisp
(defun length1.1 (list)         ; alternate version:
  (let ((len 0))                ; (not my preference)
    (dolist (element list len)  ; uses len as result here
      (incf len))))
```

Функция `mapc` выполняет такие же операции, как и специальная форма `dolist`.
В простейшем случае `mapc` принимает два аргумента: первый-функцию, второй-список.
Она применяет эту функцию к каждому элементу списка.
Здесь `length`, использует  `mapc`:

```lisp
(defun length2 (list)
  (let ((len 0))                    ; start with LEN=0
    (mapc #'(lambda (element)       ; and on each iteration
              (incf len))           ;  increment LEN by 1
          list)
    len))                           ; and return LEN
```

Существует семь различных функций отображения(mapping), из которых наиболее полезными являются `mapc` и `mapcar`.
`mapcar` выполняет те же вызовы функций, что и `mapc`, но затем возвращает результаты в виде списка.

Существует также форма `dotimes`, которая имеет синтаксис:

> (`dotimes` (*variable number optional-result*) *body...*)

и выполняет тело с *variable* привязанной сначала к нулю, затем к единице, вплоть до *number*-1 (в общей сложности *number* раз).
Конечно, `dotimes` не подходит для реализации `length`, так как мы не знаем количество итераций заранее.

Есть две очень общие формы цикла `do` и `loop`.
Синтаксис `do` выглядит следующим образом:

```lisp
(do ((variable initial next)...)
    (exit-test result)
  body...)
```

Каждая *variable/переменная* изначально привязана к *initial/исходному* значению.
Если вычисление *exit-test*  дает значение true, то возвращается *result*.
В противном случае выполняется тело/body, и каждая *variable/переменная* устанавливается в соответствующее значение *next*, и повторяется вычисление *exit-test*.
Цикл повторяется до тех пор, пока *exit-test* не станет истинным.
Если значение *next* опущено, то соответствующая переменная не обновляется каждый раз в цикле.
Скорее, с ней обращаются так, как если бы она был связана с формой `let`.

Здесь `length` реализована с помощью `do`, используя две переменные: `len` для подсчета количества элементов и `l` для прохода вниз по списку.
Это часто называют *cdr-ингом вниз по списку*, потому что при каждой операции мы применяем функцию `cdr` к списку.
(На самом деле, здесь мы использовали более мнемоническое(запоминающееся) название `rest` вместо `cdr`.)
Обратите внимание, что цикл `do` не имеет тела!
Все вычисления выполняются в переменной инициализации и пошаговом выполнении, а также в тесте завершения цикла.

```lisp
(defun length3 (list)
  (do ((len 0 (+ len 1))   ; start with LEN=0, increment
       (l list (rest l)))  ; ... on each iteration
      ((null l) len)))     ; (until the end of the list)
```

Я нахожу форму `do` немного запутанной, потому что она не ясно говорит, что мы проходим через список.
Чтобы увидеть, что он действительно проходит по списку, необходимо посмотреть как на переменную `l`, так и на тест завершения цикла.
Хуже того, нет переменной, которая обозначает текущий элемент списка; нам нужно было бы сказать (`first l`), чтобы добраться до него.
И `dolist`, и `mapc` заботяться о выполнении шагов и проверки на завершение списка, и автоматическому именованию переменной.
Они являются примерами принципа "быть конкретным".
Из-за того, что она так неконкретна,  `do` не будет часто использоваться в этой книге.
Однако многие хорошие программисты используют её, поэтому важно знать, как читать циклы `do`, даже если вы решили никогда их не писать.

Синтаксис `loop` -это целый язык сам по себе, и это определенно не Лиспоподобный язык.
Вместо того, чтобы перечислять все возможности для `loop`, мы просто приведем примеры здесь, и отсылаем читателя к *Common Lisp The Language*, 2d edition или главе 24.5 для получения более подробной информации.
Вот три версии `length` с использованием `loop`:

```lisp
(defun length4 (list)
  (loop for element in list      ; go through each element
        count t))                ;   counting each one

(defun length5 (list)
  (loop for element in list      ; go through each element
        summing 1))              ;   adding 1 each time

(defun length6 (list)
  (loop with len = 0             ; start with LEN=0
        until (null list)        ; and (until end of list)
        for element = (pop list) ; on each iteration
        do (incf len)            ;  increment LEN by 1
        finally (return len)))   ; and return LEN
```

Каждый программист знает, что существуют определенные типы циклов, которые используются снова и снова.
Их часто называют *программными идиомами* или *клише*. Пример-это перебор элементов списка или массива и выполнение некоторой операции для каждого элемента.
В большинстве языков эти идиомы не имеют явного синтаксического маркера.
Вместо этого они реализуются с помощью общей конструкции цикла, и только читатель программы может распознать, что делает программист.

Lisp необычен тем, что он предоставляет способы явно инкапсулировать такие идиомы и ссылаться на них используя явный синтаксичес и функциональные формамы.
`dolist` и `dotimes` являются двумя примерами этого - они оба следуют принципу "быть конкретным".
Большинство программистов предпочитают использовать `dolist`, а не эквивалентное `do`, потому что оно кричит: "этот цикл проходит по элементам списка."
Конечно, соответствующая форма `do` также говорит то же самое, но читателю требуется больше работы, чтобы обнаружить это.

В дополнение к специальным формам, таким как `dolist` и `dotimes`, существует довольно много функций, предназначенных для обработки общих идиом.
Два примера: `count-if`, которая подсчитывает количество элементов последовательности, удовлетворяющих предикату, и `position-if`, которая возвращает индекс элемента, удовлетворяющего предикату.
Обе могут быть использованы для реализации `length.`
В `length7` ниже, `count-if` определяет количество элементов в списке-`list`, которые удовлетворяют предикату, т.е для всех них он возвращает `true`.
Поскольку `true` определяется как всегда true, функция возвращает длину списка.

```lisp
(defun length7 (list)
  (count-if #'true list))

(defun true (x) t)
```

В `length8` функция `position-if` находит позицию элемента, удовлетворяющего предикату true, начиная с конца списка.
Это будет самый последний элемент списка, и поскольку индексация начинается с нуля, мы добавим единицу, чтобы получить длину.
По общему признанию, это не самая простая реализация `length.`

```lisp
(defun length8 (list)
  (if (null list)
      0
      (+ 1 (position-if #'true list :from-end t))))
```

Ниже приведена часть таблицы функций, реализующих циклические идиомы.
Эти функции разработаны так, чтобы быть достаточно гибкими для обработки почти всех операций над последовательностями.
Гибкость проявляется в трех формах.
Во-первых, такие функции, как `mapcar` , могут применяться к произвольному числу списков, а не только к одному:

```lisp
> (mapcar #'- '(1 2 3)) => (-1 -2 -3)
> (mapcar #'+ '(1 2) '(10 20)) => (11 22)
> (mapcar #'+ '(1 2) '(10 20) '(100 200)) => (111 222)
```

Во-вторых, многие функции принимают ключевые слова, которые позволяют пользователю изменять тест(test) для сравнения элементов или рассматривать только часть последовательности.

```lisp
> (remove 1 '(1 2 3 2 1 0 -1)) => (2 3 2 0 -1)

> (remove 1 '(1 2 3 2 1 0 -1) :key #'abs) => (2 3 2 0)

> (remove 1 '(1 2 3 2 1 0 -1) :test #'<) => (1 1 0 -1)

> (remove 1 '(1 2 3 2 1 0 -1) :start 4) => (1 2 3 2 0 -1)
```

В-третьих, некоторые из них имеют соответствующие функции, заканчивающиеся на `-if` или `-if-not`, которые принимают предикат, а не элемент для сопоставления с ним:

```lisp
> (remove-if #'oddp '(1 2 3 2 1 0 -1)) => (2 2 0)

> (remove-if-not #'oddp '(1 2 3 2 1 0 -1)) => (1 3 1 -1)

> (find-if #'evenp '(1 2 3 2 1 0 -1)) => 2
```

Следующие две таблицы предполагают эти два значения:

```lisp
(setf x '(a b c))
(setf y '(1 2 3))
```

В первой таблице перечислены функции, которые работают с любым количеством списков, но не принимают ключевые слова:

| пример              | результат        |    пояснение                                          |
|---------------------|------------------|-------------------------------------------------------|
| ``(every #'oddp y)``  | => `nil`         | проверяет, удовлетворяет ли каждый элемент предикату   |
| ``(some #'oddp y)``   | => `t`           | проверяет, удовлетворяет ли какой-нибудь эл-т предикату|
| ``(mapcar #'- y)``    | => `(-1 -2 -3)`  | применяет функцию к каждому элементу и возвр. результат|
| ``(mapc #'print y)``  | *prints* `1 2 3` | выполняет операцию над каждым элементом                |

Во второй таблице перечислены функции, которые имеют версии `-if` и `-if-not`, а также принимают аргументы ключевые слова:

| функция              | результат    |  объяснение                                  |
|----------------------|--------------|----------------------------------------------|
| `(member 2 y)`       | =>`(2 3)`    | проверяет есть ли элемент в списке           |
| `(count 'b x)`       | => 1         | считает количество совпавших элементов       |
| `(delete 1 y)`       | => `(2 3)`   | изымает совпавшие элементы                   |
| `(find 2 y)`         | => `2`       | ищет первый совпадающий элемент              |
| `(position 'a x)`    | => 0         | ищет индек элемента в последовательности     |
| ``(reduce #'+ y)``     | => `6`       | применяет функцию к последовательным элементам |
| `(remove 2 y)`       | => `(1 3)`   | подобно `delete`, но создает новую копию     |
| `(substitute 4 2 y)` | => `(1 4 3)` | заменяет элементы новыми                     |

### Повторение через рекурсию
Lisp приобрел репутацию "рекурсивного" языка, что означает, что Lisp поощряет программистов писать функции, которые вызывают сами себя.
Как мы видели выше, существует головокружительное количество функций и специальных форм для записи циклов в Common Lisp, но также верно, что многие программы реализуют повторение через рекурсию, а не с помощью синтаксического цикла.

Одно из простых определений `length` таково:" пустой список имеет длину 0, а любой другой список имеет длину, которая на единицу больше длины остатка(rest) списка (после первого элемента)."
Оно переводится непосредственно в рекурсивную функцию:

```lisp
(defun length9 (list)
  (if (null list)
      0
      (+ 1 (length9 (rest list)))))
```

Эта версия `length` естественным образом возникает из рекурсивного определения списка: "список-это либо пустой список, либо элемент, `cons`-ед(присоединенный) к другому списку."
В общем, большинство рекурсивных функций вытекают из рекурсивной природы данных, с которыми они работают.
Некоторые виды данных, такие как бинарные деревья, трудно обрабатывать иначе, чем рекурсивно.
Другие, такие как списки и целые числа, могут быть определены либо рекурсивно (приводя к рекурсивным функциям), либо как последовательность (приводя к итеративным функциям).
В этой книге я склонен использовать представление "список-как-последовательность", а не "список-как-первый-и-остальные".
Причина в том, что определение списка как первого и остальных-это произвольное и искусственное различие, основанное на реализации списков, которые Лисп случайно использует.
Но есть много других способов разложить список.
Мы могли бы разбить его на последний элемент и все-кроме-последних элементов, например, или на первую половину и вторую половину.
Представление "список как последовательность" не делает такого искусственного различия.
Оно относится ко всем элементам одинаково.

Одно из возражений против использования рекурсивных функций состоит в том, что они неэффективны, поскольку компилятор должен выделять память для каждого рекурсивного вызова.
Это может быть верно для функции `length9`, но это не обязательно верно для всех рекурсивных вызовов.
Рассмотрим следующее определение:

```lisp
(defun length10 (list)
  (length10-aux list 0))

(defun length10-aux (sublist len-so-far)
  (if (null sublist)
      len-so-far
      (length10-aux (rest sublist) (+ 1 len-so-far))))
```

`length10` использует `length10-aux` в качестве вспомогательной функции, передавая ей 0 в качестве длины списка вычисленной до сих пор(length of the list so far, т.е. len-so-far).
`length10-aux` затем проходит вниз по списку до конца, добавляя по 1 для каждого элемента.
Инвариантное отношение состоит в том, что длина подсписка плюс `len-so-far` всегда равна длине исходного списка.
Таким образом, когда подсписока становиться равна nil, то `len-so-far` - это длина исходного списка.
Переменные, такие как `len-so-far`, отслеживающие промежуточные результаты называются *accumulators/аккумуляторы*.
Другие примеры функций, использующих аккумуляторы, включают `flatten-all` на стр. 329; `one-unknown` на стр. 237; предикаты пролога, обсуждаемые на стр. 686; и `anonymous-variables-in` на стр. 400 и 433, которая использует два аккумулятора.

Важное различие между `length9` и `length10` заключается в том, *когда* выполняется сложение.
В `length9` функция вызывает саму себя, затем возвращается, а затем добавляет 1.
В `length10-aux` функция добавляет 1, затем вызывает саму себя, а затем возвращается.
После возврата рекурсивного вызова отложенные операции не выполняются, поэтому компилятор может освободить любую память, выделенную для исходного вызова, перед выполнением рекурсивного вызова.
`length10-aux` называется *tail-recursive/хвосто-рекурсивной* функцией, потому что рекурсивный вызов является последним, что делает функция, т.е - хвостом.
Многие компиляторы оптимизируют хвостовые рекурсивные вызовы, хотя это делают не все.
([Глава 22](chapter22.md) рассматривает хвостовую рекурсию более подробно и указывает, что компиляторы Scheme гарантируют, что хвостовые рекурсивные вызовы будут оптимизированы.)

Некоторые находят уродливым введение функции `length10-aux`.
Для них есть две альтернативы.
Во-первых, мы могли бы объединить `length10` и `length10-aux` в единую функцию с дополнительным параметром:

```lisp
(defun length11 (list &optional (len-so-far 0))
  (if (null list)
      len-so-far
      (length11 (rest list) (+ 1 len-so-far))))
```

Во-вторых, мы могли бы ввести *локальную/local* функцию внутри определения главной функции.
Это делается с помощью специальной формы `labels`:

```lisp
(defun length12 (the-list)
  (labels
    ((length13 (list len-so-far)
       (if (null list)
           len-so-far
           (length13 (rest list) (+ 1 len-so-far)))))
    (length13 the-list 0)))
```

В общем случае форма `labels` (или аналогичная форма `flet`) может быть использована для введения одной или нескольких локальных функций.
Она имеет следующий синтаксис:

```lisp
(labels ((function-name (parameter...) function-body)...)
 body-of-labels)
```

### Другие Специальные Формы

Еще несколько специальных форм не вписываются точно ни в одну категорию.
Мы уже видели две специальные формы для создания констант и функций: `quote` и `function.`
Они настолько распространены, что имеют аббревиатуры(сокращения): `'x` для `(quote x`) и `#'f` для `(function f).`

Специальная форма `progn` может быть использована для вычисления последовательности форм и возврата значения последней из них:

```lisp
(progn (setf x 0) (setf x (+ x 1)) x) => 1
```

`progn` - это эквивалент блока `begin...end` в других языках, но он используется очень редко в Lisp.
Для этого есть две причины.
Во-первых, программы, написанные в функциональном стиле, никогда не нуждаются в последовательности действий, потому что они не имеют побочных эффектов.
Во-вторых, даже когда используются побочные эффекты, Многие специальные формы допускают тело, которое является последовательностью-неявным `progn`.
Я знаю только о трех местах, где применение   `progn`   оправдано.
Во-первых, для реализации побочных эффектов в ветви двухветвленного условного обозначения можно использовать либо  `if`  с   `progn`,   либо   `cond`:

```lisp
(if (> x 100)                             (cond ((> x 100)
    (progn (print "too big")                     (print "too big")
           (setf x 100))                         (setf x 100))
    x)                                          (t x))
```

Если условие имеет только одну ветвь, то следует использовать `when` или `unless`, поскольку они допускают неявный `progn`.
Если существует более двух ветвей, то следует использовать `cond`.

Во-вторых, `progn` иногда требуется в макросах, которые расширяются более чем в одну форму верхнего уровня, как в макросе `defun*` на стр. 326, [раздел 10.3](B9780080571157500108.xhtml#s0020).
В-третьих, `defun*` иногда необходим в продвинутом макросе `unwind-protect`.
Примером этого является макрос `with-resource` на [стр. 338] (B9780080571157500108.xhtml#p338), [раздел 10.4](B9780080571157500108.xhtml#s0025).

Формы `trace` и `untrace` используются для управления отладочной информацией о входе и выходе в функцию:

```lisp
> (trace length9) => (LENGTH9)
> (length9 '(a b c))=>
(1 ENTER LENGTH9: (ABC))
  (2 ENTER LENGTH9: (B C))
    (3 ENTER LENGTH9: (C))
      (4 ENTER LENGTH9: NIL)
      (4 EXIT LENGTH9: 0)
    (3 EXIT LENGTH9: 1)
  (2 EXIT LENGTH9: 2)
(1 EXIT LENGTH9: 3)
3

> (untrace length9) => (LENGTH9)

> (length9 '(a b c)) => 3
```

Наконец, специальная форма `return` может быть использована для выхода из блока кода.
Блоки устанавливает специальная форма `block`, или циклические формы `(do, do*, dolist, dotimes` или `loop`).
Например, следующая функция вычисляет произведение списка чисел, но если любое число равно нулю, то все произведение должно быть равно нулю, поэтому мы немедленно возвращаем ноль из цикла `dolist`.
Обратите внимание, что она возвращается только из `dolist`, а не из самой функции (хотя в этом случае значение, возвращаемое `dolist`, становится значением, возвращаемым функцией, потому что это последнее выражение в функции).
Я использовал прописные буквы в `RETURN`, чтобы подчеркнуть тот факт, что это необычный шаг для выхода из цикла.

```lisp
(defun product (numbers)
  "Multiply all the numbers together to compute their product."
  (let ((prod 1))
    (dolist (n numbers prod)
      (if (= n 0)
          (RETURN 0)
          (setf prod (* n prod))))))
```

### Макросы

Предыдущее обсуждение было несколько бесцеремонным с термином "особая/специальная форма".
На самом деле некоторые из этих специальных форм на самом деле являются *макросами*, формами, которые компилятор расширяет в какой-то другой код.
Common Lisp предоставляет ряд встроенных макросов и позволяет пользователю расширять язык, определяя новые макросы.
(Однако пользователь не может определить новые специальные формы.)

Макросы определяются с помощью специальной формы `defmacro`.
Предположим, мы хотим определить макрос `while`, который будет действовать как оператор цикла `while` в Pascal.
Написание макроса - это четырехэтапный процесс:

* Решите, действительно ли макрос необходим.
* Запишите синтаксис макроса.
* Определите, во что должен расширяться макрос.
* Используйте `defmacro` для реализации соответствия синтаксиса/расширения.

Первый шаг при написании макроса заключается в том, чтобы признать, что каждый раз, когда вы пишете его, вы определяете новый язык, который похож на Lisp, за исключением вашего нового макроса.
Программист, который так думает, по праву будет крайне скуп в определении макросов.
(Кроме того, когда кто-то спрашивает: "Что ты сегодня сделал?" это звучит более впечатляюще, чтобы сказать: "я определил новый язык и написал компилятор для него", чем сказать: "я только что написал пару макросов.")
Введение макроса накладывает гораздо большую нагрузку на память читателя вашей программы, чем введение функции, переменной или типа данных, поэтому его не следует воспринимать легкомысленно.
Вводите макросы только тогда, когда есть явная необходимость, и когда макрос хорошо вписывается в существующую систему.
Как выразился К. А. Р. Хоар, "одна вещь, которую не должен делать языковой дизайнер, - это включать в него свои собственные неопробованные идеи."

Следующий шаг - решить, в какой код должен расширяться макрос.
Хорошей идеей будет, следование установленным соглашениям Lisp для синтаксиса макросов, когда это возможно.
Для примера, посмотрите на макросы циклов `(dolist, dotimes, do-symbols),` определяющих макросов `(defun, defvar, defparameter, defstruct),` или макросов ввода/вывода `(with-open-file`, `with-open-stream`, `with-input-from-string)`.
Если вы будете следовать правилам именования и синтаксиса для одного из них вместо того, чтобы изобретать свои собственные правила, вы окажете услугу читателю вашей программы.
Для `while`, хороший синтаксис - это:

> `(while` *test body...*)

Третий шаг - написать код, в который вы хотите развернуть вызов макроса:

```lisp
loop
  unless test (return nil))
  body
```

Последний шаг - написать определение макроса, используя `defmacro`.
Форма `defmacro` похожа на форму `defun` в том смысле, что она содержит список параметров, необязательную строку документации и тело.
Есть несколько различий в том, что разрешено в списке параметров, которые будут рассмотрены позже.
Вот определение макроса `while`, который принимает тест(test) и тело(body) и строит код `цикла/loop`, показанный ранее:

```lisp
(defmacro while (test &rest body)
  "Repeat body while test is true."
  (list* 'loop
         (list 'unless test '(return nil))
         body))
```

(Функция `list*` похожа на `list`, за исключением того, что последний аргумент добавляется в конец списка других аргументов.)
Мы можем увидеть, во что расширяется этот макрос, используя `macroexpand`, и посмотреть, как он работает, набрав пример:

```lisp
> (macroexpand-1 '(while (< i 10)
                   (print (* i i))
                   (setf i (+ i 1))))=>
(LOOP (UNLESS (< I 10) (RETURN NIL))
      (PRINT (* I I))
      (SETF I (+ I 1)))
> (setf i 7) =>7
> (while (< i 10)
    (print (* i i))
    (setf i (+ i 1)))
49
64
81
NIL
```

[Раздел 24.6] (B9780080571157500248.xhtml) (стр. 853) описывает более сложный макрос и некоторые подробности о подводных камнях написания сложных макросов (стр. 855).

### Нотация Обратной Кавычки(Backquote)

Самое сложное в определении `while` - это построение кода, который является расширением макроса.
Было бы неплохо, если бы существовал более непосредственный способ построения кода.
Следующая версия `while` предпринимает попытку сделать именно это.
Она определяет локальную переменную `code` как шаблон для кода, который мы хотим получить, а затем подставляет реальные значения переменных test и body в заполнители в переменной `code`.
Это делается с помощью функции `subst`; (`subst` *new old tree*) заменяет на *new* каждое вхождение *old* в любом месте внутри *tree.*

```lisp
(defmacro while (test &rest body)
  "Repeat body while test is true."
  (let ((code '(loop (unless test (return nil)) . body)))
    (subst test 'test (subst body 'body code))))
```

Необходимость создавать код (и некодовые данные) из компонентов настолько часта, что для этого существует специальная нотация(форма записи) - нотация обратной кавычки(*backquote*).
Символ обратной кавычки ``"`"`` аналогичен символу кавычки ``"'"``.
Обратная кавычка указывает на то, что нижеследующее является *в основном* буквальным выражением(не требующем вычисления), но может содержать некоторые компоненты, которые должны быть вычислены.
Все, что помечено ведущей запятой `","`, вычисляется и вставляется в структуру, а все, что помечено ведущей запятой с собакой `",@"`, должно вычисляться в список, который сращивается со структурой: т.е. каждый элемент списка вставляется без скобок верхнего уровня.
Более подробно эта нотация описана в [разделе 23.5] (B9780080571157500236.xhtml#s0030).
Здесь мы используем комбинацию обратной кавычки и запятой, чтобы переписать `while`:

```lisp
(defmacro while (test &rest body)
  "Repeat body while test is true."
  `(loop (unless ,test (return nil))
         ,@body))
```

Вот еще несколько примеров использовавния обратной кавычки.
Обратите внимание, что в конце списка `",@"` имеет тот же эффект, что и `"."` - с последующей за 
ним запятой - `","`.
В середине списка возможно только `",@"`.

```lisp
> (setf test1 '(a test)) => (A TEST)

> `(this is ,test1) => (THIS IS (A TEST))

> `(this is ,@ test1) => (THIS IS A TEST)

> `(this is . ,test1) => (THIS IS A TEST)

> `(this is ,@ test1 -- this is only ,@ test1) =>
(THIS IS A TEST -- THIS IS ONLY A TEST)
```

На этом завершается раздел о специальных формах и макросах.
В остальных разделах этой главы дается обзор важных функций встроенных в Common Lisp.

## 3.3 Функции работающие со списками

Для примера предположим, что у нас есть следующие присвоения переменным:

```lisp
(setf x '(a b c))
(setf y '(1 2 3))
```

Здесь собраны наиболее важные функции работы со списками.
Более сложные из них объясняются более подробно, когда они будут использоваться.

| []()             |                        |                                                |
|------------------|------------------------|------------------------------------------------|
| `(first x)`      | => `a`                 | первый элемент списка                          |
| `(second x)`     | => `b`                 | второй элемент списка                          |
| `(third x)`      | => `c`                 | третий элемент списка                          |
| `(nth 0 x)`      | => `a`                 | n-ый элемент списка, начиная с `0`             |
| `(rest x)`       | => `(b c)`             | все, кроме первого элемента                    |
| `(car x)`        | => `a`                 | другое имя для получения первого элемента списка
| `(cdr x)`        | => `(b c)`             | другое имя для получения, всех кроме первого   |
| `(last x)`       | => `(c)`               | последняя cons ячейка в списке                 |
| `(length x)`     | => 3                   | количество элементов в списке                  |
| `(reverse x)`    | => `(c b a)`           | возвращает список в обратном порядке           |
| `(cons 0 y)`     | => `(0 1 2 3)`         | добавляет элемент в начало списка              |
| `(append x y)`   | => `(a b c 1 2 3)`     | соединяет элементы в один список               |
| `(list x y)`     | => `((a b c) (1 2 3))` | создает новый список                           |
| `(list* 1 2 x)`  | => `(1 2 a b c)`       | создает новый список добавляя последний аргумент к другим|
| `(null nil)`     | => `T`                 | предикат возвращающий истину если список пуст  |
| `(null x)`       | => `nil`               | ... и ложь если нет                            |
| `(listp x)`      | => `T`                 | предикат возвращающий истину для любого списка, включая `nil` |
| `(listp 3)`      | => `nil`               | ... и ложь если аргумент не список             |
| `(consp x)`      | => `t`                 | предикат равный истине для всех не nil списков |
| `(consp nil)`    | => `nil`               | ... и ложь для атомов, включая `nil`           |
| `(equal x x)`    | => `t`                 | истина для списков являющихся идентичными      |
| `(equal x y)`    | => `nil`               | ... и ложь для списков которые разные          |
| ``(sort y #'>)``   | => `(3 2 1)`           | сортирует список используя функцию сравнения   |
| `(subseq x 1 2)` | => `(B)`               | выделяет подпоследовательность со стартовой точки до конечной|

Мы сказали, что (`cons` *a b*) строит более длинный список, добавляя элемент *a* в начало списка *b*, но что, если *b* не является списком?
Это не ошибка; результатом является объект *x* такой, что (`first` *x*) => *a* (`rest` *x*) => *b* и где *x* печатается как (*a* . *b*).
Это известно как обозначение *точечной пара*.
Если *b* - это список, то для вывода используется обычная нотация списка, а не нотация точечной пары.
Но для ввода можно использовать любую нотацию.

До сих пор мы рассматривали списки как последовательности, используя фразы типа "список из трех элементов."
Список-это удобная абстракция, но фактическая реализация списков опирается на строительные блоки более низкого уровня, называемые *cons ячейками*.
Ячейка cons - это структура данных с двумя полями: первое(first) и остаток(rest).
То, что мы называем "списком из трех элементов", можно также рассматривать как одну ячейку cons, первое поле которой указывает на первый элемент, а поле rest указывает на другую ячейку cons, представляющую собой ячейку cons, представляющий собой список из двух элементов.
У этой второй cons ячейки есть поле rest, которое ссылается на третью cons ячейку, чьё поле rest равна nil.
Во всех списках в последней cons ячейке, поле rest равно nil.
[Рисунок 3.1] (#f0010) показывает обозначения cons ячеек для трехэлементного списка (`one two three`), а также для результата (`cons 'one 'two`).

![Рисунок 3.1: Диаграмма Cons Ячеек](images/chapter3/f03-01.jpg)
**Рисунок 3.1: Диаграмма Cons Ячеек**

&#9635; **Упражнение 3.2 [s]** функцию cons можно рассматривать как частный случай одной из других функций, перечисленных ранее.
Какой именно?

&#9635; **Упражнение 3.3 [m]** напишите функцию, которая выведет выражение в виде нотации точечной пары.
Используйте встроенную функцию `princ` для печати каждого компонента выражения.

&#9635; **Упражнение 3.4 [m]** напишите функцию, которая, как и обычная функция `print`, будет печатать выражение в нотации точечной пары, когда это необходимо, но будет использовать обычную нотацию списка, когда это возможно.

## 3.4 равенство и внутреннее представителение

В Lisp есть пять основных предикатов равенства, потому что не все объекты создаются одинаково равными.
Предикат числового равенства `=` проверяет, совпадают ли два числа.
Будет ошибкой-применять `=` к не-числам.
Другие предикаты равенства работают с любым типом объектов, но чтобы понять разницу между ними, нам нужно понять некоторые внутренние элементы Lisp.

Когда Lisp читает символ в двух разных местах, результат гарантированно будет точно тем же символом.
Система Lisp поддерживает таблицу символов, которую функция read использует для сопоставления между строками символьньных знаков(characters) и символами(symbols).
Но когда читается список (или строится) в двух разных местах, результаты *не* тождественны, даже если элементы могут быть теже самые.
Это происходит потому, что `read` вызвает `cons`, чтобы создать список, и каждый вызов `cons` возвращает новую `cons` ячейку.
[Рисунок 3.2] (#f0015) показывает два списка, `x` и `Y`, которые оба одинаковы (`one two`), но которые состоят из разных ячеек cons и, следовательно, не идентичны.
[Рисунок 3.3] (#f0020) показывает, что выражение (`rest x`) не генерирует новые ячейки cons, а скорее разделяет структуру с `x`, и что выражение (`cons 'zero x`) генерирует ровно одну новую ячейку cons, rest которой равно `x`.

![Figure 3.2: Равные(Одинаковые), Но Неидентичные Списки](images/chapter3/f03-02.jpg)
**Figure 3.2: Равные(Одинаковые), Но Неидентичные Списки**

![Figure 3.3: Части списков](images/chapter3/f03-03.jpg)
**Figure 3.3: Части списков**

Когда два математически равных числа считываются (или вычисляются) в двух местах, они могут быть или не быть одинаковыми, в зависимости от того, что разработчики вашей реализации считали более эффективным.
В большинстве систем два равных фиксированных числа будут идентичны, но равные числа других типов не будут (за исключением, возможно, short floats).
Common Lisp предоставляет четыре предиката равенства возрастающей общности.
Все четыре начинаются с букв `eq`, причем больше букв означает, что предикат считает больше объектов равными.
Самый простой предикат - это `eq`, который проверяет является ли объект тем же самым.
Далее `eql` тестирует объекты, которые являются либо `eq`, либо эквивалентными числами.
`equal` тестирует объекты, являются ли они либо `eql`, либо списками или строками с `eql` элементами.
Наконец, `equalp` похож на `equal`, за исключением того, что он также считает соответствующими друг другу верхние и нижние буквы и числа разных типов.
В следующей таблице приведены результаты применения каждого из четырех предикатов к различным значениям *x* и *y*.
значение ? означает, что результат зависит от вашей реализации: два целых числа, которые являются `eql`, могут быть или не быть `eq`.

| *x*     | *y*     | `eq`  | `eql` | `equal` | `equalp` |
|---------|---------|-------|-------|---------|----------|
| `'X`    | `'x`    | `T`   | `T`   | `T`     | `T`      |
| `'0`    | `'0`    | `?`   | `T`   | `T`     | `T`      |
| ``'(x)``  | ``'(x)``  | `nil` | `nil` | `T`     | `T`      |
| ``'"xy"`` | ``'"xy"`` | `nil` | `nil` | `T`     | `T`      |
| ``'"Xy"`` | ``'"xY"`` | `nil` | `nil` | `nil`   | `T`      |
| `'0`    | `'0.0`  | `nil` | `nil` | `nil`   | `T`      |
| `'0`    | `'1`    | `nil` | `nil` | `nil`   | `nil`    |

Кроме того, существуют специализированные предикаты равенства, такие как  =, `tree-equal, char-equal,` и `string-equal`, которые сравнивают числа, деревья, символьные знаки и строки соответственно.

## 3.5 функции работы с последовательностями

Common Lisp находится в переходном положении на полпути между лиспами прошлого и лиспами будущего.
Нигде это не проявляется так явно, как в функциях работы с последовательностями.
Самые ранние Лиспы имели дело только с символами, числами и списками и предоставляли функции работы со списками, такие как `append` и `length`.
Более современные Лиспы добавили поддержку векторов, строк и других типов данных и ввели термин *sequence/последовательность* для обозначения как векторов, так и списков.
(Вектор - это одномерный массив.
Он может быть представлен более компактно, чем список, потому что нет необходимости хранить указатели `rest`.
Кроме того, более эффективно добираться до *n*-го элемента вектора, потому что нет необходимости следовать цепочке указателей.)
Современные Лиспы также поддерживают строки, которые являются векторами символьных знаков, а следовательно, и подтипом последовательности.

С появлением новых типов данных возникла проблема именования функций, которые ими оперируют.
В некоторых случаях Common Lisp решил расширить старую функцию: `length` может применяться как к векторам, так и к спискам.
В других случаях старые имена были зарезервированы для функций списка, а новые имена были изобретены для общих функций последовательности.
Например, `append` и `mapcar` работают только в списках, но `concatenate` и `map` работают с любой последовательностью.
В других случаях были изобретены новые функции для конкретных типов данных.
Например, существует семь функций для выбора n-го элемента из последовательности.
Наиболее общей является `elt`, которая работает на любом виде последовательности, но есть специальные функции для списков, массивов, строк, битовых векторов, простых битовых векторов и простых векторов.
Как ни странно, `nth` - единственная из них, которая принимает индекс в качестве первого аргумента:

* `(nth` *n list*)
* `(elt` *sequence n*)
* `(aref` *array n*)
* `(char` *string n*)
* `(bit` *bit vector n*)
* `(sbit` *simple-bit vector n*)
* `(svref` *simple-vector n*)

Наиболее важные функции последовательности перечислены в другом месте этой главы, в зависимости от их конкретного назначения.

## 3.6 функции для поддержки таблиц

Списки Lisp можно использовать для представления одномерной последовательности объектов.
Поскольку они настолько универсальны, они были использованы для других целей, таких как представления табличной информации.
*Ассоциативный список* - это тип списка, используемый для реализации таблиц.
Ассоциациативный список - это список точечных пар, где каждая пара состоит из *ключа/key* и *значения/value*. Вместе список пар образует таблицу: по заданному ключу, мы можем получить соответствующее значение из таблицы или проверить, что в таблице нет такого ключа.
Вот пример поиска названий государств по их двухбуквенной аббревиатуре.
Используется функция `assoc`.
Она возвращает пару ключ/значение (если таковая имеется).
Чтобы получить значение, мы просто берем `cdr` от результата возвращаемого `assoc`.

```lisp
(setf state-table
  '((AL . Alabama) (AK . Alaska) (AZ . Arizona) (AR . Arkansas)))

> (assoc 'AK state-table) => (AK . ALASKA)

> (cdr (assoc 'AK state-table)) => ALASKA

> (assoc 'TX state-table) => NIL
```

Если мы хотим искать в таблице по значению, а не по ключу, мы можем использовать rassoc:

```lisp
> (rassoc 'Arizona table) => (AZ . ARIZONA)
> (car (rassoc 'Arizona table)) => AZ
```

Управлять таблицей с помощью `assoc` просто, но есть один недостаток: мы должны искать по всему списку по одному элементу за раз.
Если список очень длинный, это может занять много времени.

Другой способ управления таблицами - это использование *хэш-таблиц*.
Они предназначены для эффективной обработки больших объемов данных, но имеют определенную степень накладных расходов, что может сделать их неуместными для небольших таблиц.
Функция `gethash` работает так же, как и `get` - она принимает два аргумента, ключ и таблицу.
Сама таблица инициализируется с помощью вызова `make-hash-table` и изменяется с помщью `setf` с `gethash`:

```lisp
(setf table (make-hash-table))

(setf (gethash 'AL table) 'Alabama)
(setf (gethash 'AK table) 'Alaska)
(setf (gethash 'AZ table) 'Arizona)
(setf (gethash 'AR table) 'Arkansas)
```

Здесь мы извлекаем значения из таблицы:

```lisp
> (gethash 'AK table) => ALASKA
> (gethash 'TX table) => NIL
```

Функция `remhash` удаляет пару ключ/значение из хэш-таблицы, `clrhash` удаляет все пары, а `maphash` можно использовать для отображения пар ключ/значение с помощью пользовательской функции.
Ключи к хэш-таблицам не ограничены; ими может быть любой объект Lisp.
Существует еще много подробностей о реализации хэш-таблиц в Common Lisp, а также обширная литература по их теории.

Третий способ представления таблицы - это использование *property lists/списков свойств*.
Список свойств - это список чередующихся пар ключ/значение.
Списки свойств (иногда называемый p-lists или plists) и ассоциативные списки (иногда называют a-lists или alists)) похожи:

> `a-list:` ((*key*<sub>1</sub> . *val*<sub>1</sub>) (*key*<sub>2</sub> . *val*<sub>2</sub>) ... (*key*<sub>n</sub> . *val*<sub>n</sub>))  
> `p-list:` (*key*<sub>1</sub> *val*<sub>1</sub> *key*<sub>2</sub> *val*<sub>2</sub> ... *key*<sub>n</sub> *val*<sub>n</sub>)

Учитывая это представление, различий между a-lists и p-lists немного.
Это несколько разные перестановки одной и той же информации.
Разница заключается в том, как они обычно используются.
Каждый символ имеет связанный с ним список свойств(property list).
Это означает, что мы можем связать пару свойство/значение непосредственно с символом.
Большинство программ используют только несколько различных свойств, но имеют множество экземпляров пар свойство/значение для каждого свойства.
Таким образом, p-list каждого символа, скорее всего, будет коротким.
В нашем примере нас интересует только одно свойство: состояние, связанное с каждой аббревиатурой.
Это означает, что списки свойств будут действительно очень короткими: по одному свойству для каждой аббревиатуры вместо списка из 50 пар в реализации списка ассоциаций(alist).

Значения свойств извлекаются с помощью функции get, которая принимает два аргумента: первый-это символ, для которого мы ищем информацию, а второй-свойство того символа, который нас интересует.
get возвращает значение этого свойства, если оно было сохранено.
Пары свойств/значений могут храниться связанные с символом  формой `setf`.
Таблица будет построена следующим образом:

```lisp
(setf (get 'AL 'state) 'Alabama)
(setf (get 'AK 'state) 'Alaska)
(setf (get 'AZ 'state) 'Arizona)
(setf (get 'AR 'state) 'Arkansas)
```

Теперь мы можем получить значения с помощью get:

```lisp
> (get 'AK 'state) => ALASKA
> (get 'TX 'state) => NIL
```

Это будет быстрее, потому что мы можем сразу перейти от символа к его единственному значению свойства, независимо от количества символов, имеющих свойства.
Однако, если данный символ имеет более одного свойства, то мы все равно должны искать линейно по списку свойств.
Как сказал бы Авраам Линкольн, вы можете сделать некоторые из поисков в таблице быстрее, но вы не можете навсегда сделать все поиски в таблице быстрыми.
Обратите внимание, что нет эквивалента rassoc, использующего списки свойств; если вы хотите перейти от состояния к его аббревиатуре, вы можете сохранить аббревиатуру под свойством состояния, но это будет отдельная форма "setf", как в:

```lisp
(setf (get 'Arizona 'abbrev) 'AZ)
```

На самом деле, когда источник, свойство и значение являются символами, существует довольно много возможностей для использования свойств.
Мы могли бы имитировать подход a-list и перечислить все свойства под одним символом, используя setf в функции `symbol-plist` (которая дает полный список свойств символа):

```lisp
(setf (symbol-plist 'state-table)
      '(AL Alabama AK Alaska AZ Arizona AR Arkansas))
> (get 'state-table 'AL) => ALASKA
> (get 'state-table 'Alaska) => NIL
```

Списки свойств(plist) имеют долгую историю в Lisp, но они попадают в немилость по мере появления новых альтернатив, таких как хэш-таблицы.
Существует две основные причины, по которым избегают списков свойств.
Во-первых, поскольку символы и их списки свойств являются глобальными, легко получить конфликты при попытке объединить две программы, использующие списки свойств.
Если две программы используют одно и то же свойство для разных целей, они не могут использоваться вместе.
Даже если две программы используют *разные* свойства для одних и тех же символов, они будут замедлять друг друга.
Во-вторых, списки свойств не упорядочены.
Нет никакого способа быстро удалить каждый элемент таблицы, реализованной со списками свойств.
В отличие от этого, это можно сделать тривиально с помощью "clrhash" в хэш-таблицах или установив список ассоциаций в nil.

## 3.7 Функции для работы с деревьями

Многие распространенные функции Lisp рассматривают выражение `((a b) ((c)) (d e))` как последовательность из трех элементов, но есть несколько функций, которые рассматривают её как дерево с пятью ненулевыми(non-null) листьями.
Функция `copy-tree` создает копию дерева, а `tree-equal` проверяет, равны ли два дерева, проходя через cons ячейки, но не через другие сложные данные, такие как векторы или строки.
В этом отношении `tree-equal` похож на `equal`, но `tree-equal` является более мощным, поскольку она позволяет изменть тип теста: `:test keyword`:

```lisp
> (setf tree '((a b) ((c)) (d e)))

> (tree-equal tree (copy-tree tree)) => T

(defun same-shape-tree (a b)
  "Are two trees the same except for the leaves?"
  (tree-equal a b :test #'true))

(defun true (&rest ignore) t)

> (same-shape-tree tree '((1 2) ((3)) (4 5))) => T
> (same-shape-tree tree '((1 2) (3) (4 5))) => NIL
```

[Рис. 3.4] (#f0025) показывает дерево `((a b) ((c)) (d e))` в виде диаграммы ячеек cons

![Рисунок 3.4: схема cons ячеек дерева](images/chapter3/f03-04.jpg)
**Рисунок 3.4: схема cons ячеек дерева**

Существуют также две функции для замены старого выражения новым в любом месте дерева.
`subst` заменяет одно значение другим, в то время как `sublis` принимает список замен в виде ассоциативного списка пар (*old . new*).
Обратите внимание, что порядок старого и нового в a-list для `sublis` обратный, по сравнению с порядком аргументов в `subst`.
Имя `sublis` является нехарактерно коротким и запутанным; лучшем именем будет `subst-list`.

```lisp
> (subst 'new 'old '(old ((very old)))) => (NEW ((VERY NEW)))

> (sublis '((old . new)) '(old ((very old)))) => (NEW ((VERY NEW)))

> (subst 'new 'old 'old) => NEW

(defun english->french (words)
  (sublis '((are . va) (book . libre) (friend . ami)
            (hello . bonjour) (how . comment) (my . mon)
            (red . rouge) (you . tu))
          words))

> (english->french '(hello my friend - how are you today?)) =>
(BONJOUR MON AMI - COMMENT VA TU TODAY?)
```

## 3.8 функции работы с числами

Здесь перечислены наиболее часто используемые функции для чисел.
Есть довольно много других числовых функций, которые были опущены.

| пример         | результат| расшифровка                                                    |
|----------------|----------|----------------------------------------------------------------|
| `(+ 4 2)`      | => `6`   | add                                                            |
| `(- 4 2)`      | => `2`   | subtract                                                       |
| `(* 4 2)`      | => `8`   | multiply                                                       |
| `(/ 4 2)`      | => `2`   | divide                                                         |
| `(> 100 99)`   | => `t`   | greater than (also `>=`, greater than or equal to)             |
| `(= 100 100)`  | => `t`   | equal (also `/=`, not equal)                                   |
| `(< 99 100)`   | => `t`   | less than (also `<=`, less than or equal to)                   |
| `(random 100)` | `=> 42`  | random integer from 0 to 99                                    |
| `(expt 4 2)`   | => `16`  | exponentiation (also exp, *e<sup>x</sup>* and `log`)           |
| `(sin pi)`     | => `0.0` | sine function (also `cos`, `tan,` etc.)                        |
| `(asin 0)`     | => `0.0` | arcsine or sin<sup>-1</sup> function (also `acos, atan`, etc.) |
| `(min 2 3 4)`  | => `2`   | minimum (also `max`)                                           |
| `(abs -3)`     | => `3`   | absolute value                                                 |
| `(sqrt 4)`     | => `2`   | square root                                                    |
| `(round 4.1)`  | => `4`   | round off (also `truncate, floor, ceiling`)                    |
| `(rem 11 5)`   | => 1     | remainder (also `mod`)                                         |

## 3.9 функции работы с множествами

Одним из важных применений списков является представление множеств.
Common Lisp предоставляет функции, которые обрабатывают списки именно таким образом.
Например, чтобы увидеть, какие общие элементы имеют множества *r* = {*a, b, c, d*} и *s* = {*c, d, e*} мы могли бы использовать:

```lisp
> (setf r '(a b c d)) => (A B C D)
> (setf s '(c d e)) => (C D E)
> (intersection r s) => (C D)
```

Эта реализация возвращает (`C D`) в качестве ответа, но может возвращать и в другом порядке (`D C`).
Они являются эквивалентными множествами, поэтому любое из них допустимо, и ваша программа не должна зависеть от порядка элементов в результате.
Вот основные функции для множеств:

| функция                | результат        | расшифровка                                   |
|------------------------|------------------|-----------------------------------------------|
| `(intersection r s)`   | => `(c d)`       | найти общие элементы в двух множествах        |
| `(union r s)`          | => `(a b c d e)` | найти все элементы имеющиеся в двух множествах|
| `(set-difference r s)` | => `(a b)`       | найти элементы которых нет в другом множестве |
| `(member 'd r)`        | => `(d)`         | проверить есть ли элемент в множетсве         |
| `(subsetp s r)`        | => `nil`         | смотрит, все ли элементы одного мн.есть в др. |
| `(adjoin 'b s`)        | => `(b c d e)`   | добавляет элемент в множество                 |
| `(adjoin 'c s)`        | => `(c d e)`     | ... не не добавляет если он уже есть          |

Также возможно представить множество с помощью последовательности битов, учитывая конкретную вселенную дискурса.
Например, если каждый интересующее нас множество должно быть подмножеством (`a b c d e`), то мы можем использовать битовую последовательность 11110 для представления (`a b c d`), 00000 для представления пустого множества и 11001 для представления (`a b e`).
Битовая последовательность может быть представлена в Common Lisp как битовый вектор или как целое число в двоичной записи.
Например, (`a b e`) будет битовым вектором `#*11001` или целым числом 25, которое также можно записать как `#b11001`.

Преимущество использования битовых последовательностей состоит в том, что для кодирования множества требуется меньше места, если предположить, что Вселенная невелика.
Вычисления будут выполняться быстрее, поскольку базовый набор команд компьютера обычно обрабатывает 32 элемента одновременно.

Common Lisp предоставляет полный набор функций как для битовых векторов, так и для целых чисел.
В следующей таблице перечислены некоторые из них, их соответствие функциям списка.

| `lists`          | `integers` | `bit vectors` |
|------------------|------------|---------------|
| `intersection`   | `logand`   | `bit-and`     |
| `union`          | `logior`   | `bit-ior`     |
| `set-difference` | `logandc2` | `bit-andc2`   |
| `member`         | `logbitp`  | `bit`         |
| `length`         | `logcount` |               |

Например,

```lisp
(intersection '(a b c d) '(a b e)) =>  (A B)
(bit-and      #*11110    #*11001)  =>  #*11000
(logand       #b11110    #b11001)  =>  24 = #b11000
```

## 3.10 Разрушающие(Деструктивные) Функции

В математике функция-это то, что вычисляет выходное значение с учетом некоторых входных аргументов.
Функции ничего не "делают", они просто вычисляют результаты.
Например, если я скажу вам, что *x* = 4 и *y* = 5, и попрошу вас применить функцию "плюс" к *x* и *y, я ожидаю, что вы скажете мне 9.
Если я тогда спрошу: "какова теперь величина *x*?- было бы удивительно, если бы *x* изменилось.
В математике применение оператора к *x* не может иметь никакого влияния на значение *X*.

В Lisp некоторые функции способны давать сторонний эффект, помимо простого вычисления результата.
<a id="tfn03-2"></a>
Эти "функции" не являются функциями в математическом смысле,[[2]](#fn03-2) и в других языках они известны как "процедуры".
Конечно, большинство функций Lisp являются истинными математическими функциями, но те немногие, которые ими не являются, могут вызвать большие проблемы.
Они также могут быть весьма полезны в определенных ситуациях.
По обеим причинам о них стоит знать.

Рассмотрим следующее:

```lisp
> (setf x '(a b c)) => (A B C)
> (setf y '(1 2 3)) => (1 2 3)
> (append x y) => (A B C 1 2 3)
```

`append` - это чистая функция, поэтому после выполнения вызова `append` мы можем с полным правом ожидать, что `x` и `y` сохранят свои значения.
Теперь рассмотрим это:

```lisp
> (nconc x y) => (A B C 1 2 3)
> x => (A B C 1 2 3)
> y => (1 2 3)
```

Функция `nconc` вычисляет тот же результат, что и `append`, но имеет побочный эффект изменения своего первого аргумента.
Она называется *деструктивной* или *разрушающей* функцией, потому что она разрушает существующие структуры, заменяя их новыми.
Это означает, что существует довольно большая концептуальная нагрузка на программиста, который осмеливается использовать `nconc`.
Он или она должны знать, что первый аргумент может быть изменен, и планировать соответственно.
Это намного сложнее, чем в случае с неразрушающими функциями, когда программисту нужно беспокоиться только о результатах вызова функции.

Преимущество `nconc` заключается в том, что он не использует никакого хранилища.
В то время как `append` должен сделать полную копию `x`, а затем скопировать в конец `y`, `nconc` не нужно ничего копировать.
Вместо этого он просто изменяет поле rest последнего элемента `x`, чтобы указать на `y`.
Поэтому используйте разрушающие функции, когда вам нужно сохранить память, но помните о последствиях.

Помимо `nconc`, многие разрушающие функции имеют имена, начинающиеся с `n`, включая `nreverse, nintersection, nunion, nset-difference` и `nsubst`.
Важным исключением является `delete`, которое является именем, используемым для разрушающей версии `remove`.
Конечно, специальная форма `setf` также может быть использована для изменения структур, но именно разрушающие функции наиболее опасны, потому что легко не заметить их воздействие.

&#9635; **Упражнение 3.5 [h]** (упражнение на изменении структуры.)
Напишите программу, которая будет играть роль отгадчика в игре Twenty Questions(20 вопросов).
Пользователь программы будет иметь в виду любой тип вещей.
Программа будет задавать вопросы пользователю, на которые необходимо ответить "да" или "нет", или "it/это", когда программа догадается об этом.
Если у программы заканчиваются догадки, она сдается и спрашивает пользователя, что это было.
Сначала программа будет играть не очень хорошо, но каждый раз, когда она проиграет, она будет запоминать ответы пользователя и использовать их для последующих догадок.

## 3.11 Обзор типов данных

Эта глава была организована вокруг функций, с аналогичными функциями, сгруппированными вместе.
Но есть и другой способ организации мира Common Lisp: рассматривая различные типы данных.
Это полезно по двум причинам.
Во-первых, это дает альтернативный способ увидеть разнообразие доступных функциональных возможностей.
Во-вторых, сами типы данных являются объектами в языке Common Lisp, и, как мы увидим, существуют функции, которые управляют типами данных.
Они полезны главным образом для проверки объектов (как в случае с макросом typecase) и для создания объявлений.

Вот таблица наиболее часто используемых типов данных:

| Тип          | Пример         | Объяснение                                                |
|--------------|----------------|------------------------------------------------------------|
| `character`  | `#\c`          | Одна буква, цифра или знак препинания.                     |
| `number`     | `42`           | Распростр. числа числ.с плав. точкой и целые числа.        |
| `float`      | `3.14159`      | Число с десятичной запятой.                                |
| `integer`    | `42`           | Целое число, фиксированного или неопределенного размера:   |
| `fixnum`     | `123`          | Целое число, которое помещается в одно слово памяти.       |
| `bignum`     | `123456789`    | Целое число неограниченного размера.                       |
| `function`   | `#'sin`        | Функция, применимая к списку аргументов.                   |
| `symbol`     | `sin`          | Символы могут быть именем fns и vars, и сами явл.объектами |
| `null`       | `nil`          | Объект `nil` является единственным объектом типа null.     |
| `keyword`    | `:key`         | Ключевые слова - это подтип символа.                       |
| `sequence`   | `(a b c)`      | Последовательности включают в себя списки и векторы.       |
| `list`       | `(a b c)`      | Список - это либо `cons` или `null`.                       |
| `vector`     | `#(a b c)`     | Вектор - это подтип последовательности.                    |
| `cons`       | `(a b c)`      | cons это не пустой список.                                 |
| `atom`       | `t`            | atom(Атом)-это все, что не является cons.                  |
| `string`     | `"abc"`        | Строка - это тип вектора символьных знаков                 |
| `array`      | `#lA(a b c)`   | Массивы включают векторы и многомерные массивы.            |
| `structure`  | `#S(type ...)` | Структуры определяются `defstruct`                         |
| `hash-table` | ...            | Хэш-таблицы создаются с помощью `make-hash-table`.         |

Почти каждый тип данных имеет *распознающий предикат* -функцию, которая возвращает true только для элементов этого типа.
В общем случае предикат-это функция, которая всегда возвращает одно из двух значений: true или false.
В Lisp значение false равно `nil`, а любое другое значение считается истинным, хотя наиболее распространенным истинным значением является `t`.
В большинстве случаев имя распознающего предиката состоит из имени типа, за которым следует `p: characterp` распознает символьные знаки, `numberp` распознает числа и т. д.
Например, `(numberp 3)` возвращает `t`, потому что 3-это число, но `(numberp "x")` возвращает `nil`, потому что `"x"` - это строка, а не число.

К сожалению, язык Common Lisp не является до конца последовательным.
Нет никаких распознавателей для фиксированных чисел, больших чисел, последовательностей и структур.
Два распознавателя, `null` и `atom`, не заканчиваются на `p`. Также обратите внимание, что перед `p` в `hash-table-p` есть дефис, потому что имя типа имеет внутри дефис.
Кроме того, все распознаватели, генерируемые `defstruct` имеют дефис перед `p`.

Функция `type-of` возвращает тип своего аргумента, а функция `typep` проверяет, является ли объект заданным типом.
Функция `subtypep` проверяет, может ли один тип быть определен как подтип другого.
Например:

```lisp
> (type-of 123) => FIXNUM

> (typep 123 'fixnum) => T

> (typep 123 'number) => T

> (typep 123 'integer) => T

> (typep 123.0 'integer) => NIL

> (subtypep 'fixnum 'number) T
```

Иерархия типов в Common Lisp довольно сложна.
Как показывает предыдущий пример, существует много различных числовых типов, и число, подобное 123, считается типом `fixnum, integer` и `number`.
Позже мы увидим, что оно также относится к типу `rational` и `t`.

Иерархия типов формирует граф, а не просто дерево.
Например, вектор - это и последовательность, и массив, хотя ни массив, ни последовательность не являются подтипами друг друга.
Аналогично, `null` является подтипом как `symbol`, так и `list`.

В следующей таблице показан ряд более специализированных типов данных, которые используются не так часто:

| Тип            | Пример                | Объяснение                                               |
|----------------|-----------------------|----------------------------------------------------------|
| `t`            | `42`                  | Каждый объект является типом `t`.                        |
| `nil`          |                       | Ни один объект не имеет типа `nil`.                      |
| `complex`      | `#C(0 1)`             | Мнимое число.                                            |
| `bit`          | `0`                   | Ноль или единица                                         |
| `rational`     | `2/3`                 | Рациональные числа включают целые числа и рац.дроби      |
| `ratio`        | `2/3`                 | Точные дробные числа.                                    |
| `simple-array` | `#lA(x y)`            | Массив, который не перемещается и не регулируется.       |
| `readtable`    | `...`                 | Отображение строк знаков в их значения для read.         |
| `package`      | `...`                 | Набор символов, содержащихся в модуле                    |
| `pathname`     | `#P"/usr/spool/mail"` | Имя файла или директории                                 |
| `stream`       | `...`                 | Указатль на открытый файл; использ. для чтения или печати|
| `random-state` | `...`                 | Состояние, используемое в качестве семени для `random`.  |

Кроме того, существуют еще более специализированные типы, такие как `short-float`, `compiled-function` и `bit-vector`.
Также можно построить более точные типы, такие как (`vector (integer 0 3) 100`), который представляет собой вектор из 100 элементов, каждый из которых является целым числом от 0 до 3 включительно.
[Раздел 10.1] (B9780080571157500108.xhtml#s0010) дает более подробную информацию о типах и их использовании.

Хотя почти каждый тип имеет предикат, также верно, что есть предикаты, которые не являются распознавателями типов, а скорее распознают некоторые более общие условия.
Например, `oddp` истинно, только для нечетных чисел, а `string-greaterp` истинно, если в одна строка в алфавитном смысле больше, чем другая.

## 3.12 Ввод/Вывод

Ввод в Lisp невероятно прост, потому что пользователю доступен полный лексический и синтаксический парсер.
Парсер называется `read`.
Он используется для чтения и возврата одного выражения Lisp.
Если вы можете спроектировать свое приложение так, чтобы оно считывало выражения Lisp, то ваши заботы о вводе данных закончатся.
Обратите внимание, что выражение, анализируемое `read`, не обязательно должно быть реально *вычислимым* выражением Lisp.
То есть вы можете читать (`"hello" cons zzz`) так же хорошо, как и (`+ 2 2`).
В тех случаях, когда выражения Lisp не годятся для ввода, функция `read-char` считывает один символьный знак, а `read-line` считывает все до следующей новой строки и возвращает результат в виде строки.

Читая с терминала функции `read, read-char` или `read-line` (без аргументов) возвращают выражение, символьный знак или строку без конца строки соответственно.
Кроме того, можно читать из файла.
Функцию  `open` или макрос `with-open-stream` можно использовать для открытия файла и связывания его с *stream/потоком* Lisp - именем дескриптора источника ввода-вывода.
Все три функции чтения принимают три необязательных аргумента.
Первый-это поток, из которого нужно читать.
Второй, если он истинен, вызывает сообщение об ошибке в конце файла.
Если второй аргумент равен nil, то третий аргумент указывает значение, возвращаемое при достижении конца файла.

Вывод в Lisp аналогичен выводу в других языках, таких как C.
Есть несколько низкоуровневых функций для выполнения определенных видов вывода, и есть очень общая функция для выполнения форматированного вывода.
Функция `print` выводит любой объект с новой строки с пробелом после нее.
`prin1` будет печатать любой объект без новой строки и пробела.
Для обеих функций объект печатается в форме, которая может быть обработана с помощью функции `read`.
Например, строка `"hello there"` будет напечатана как `"hello there".`
Функция `princ` используется для печати в удобочитаемом формате.
Строка, о которой идет речь, будет напечатана как `hello there` с `princ` -кавычки не печатаются.
Это означает, что `read` не может восстановить исходную форму; `read` интерпретирует ее как два символа, а не одну строку.
Между прочим, функция `write` принимает одиннадцать различных аргументов ключевых слов, которые определяют, действительно ли он действует как `prin1` и `princ`.

Выходные функции также принимают поток в качестве необязательного аргумента.
Далее мы создадим файл `test.text` и печатаем в нем два выражения.
Затем мы открываем файл для чтения и пытаемся прочитать обратно первое выражение, один символ, а затем еще два выражения.
Обратите внимание, что `read-char` возвращает символ `#\G`, тогда как последющая `read` читает символьные знаки OODBYE  и превращает их в символ.
Последнее `read` попадает в конец файла и таким образом возвращает указанное значение `eof`.

```lisp
> (with-open-file (stream "test.text" :direction :output)
    (print '(hello there) stream)
    (princ 'goodbye stream))=>
GOODBYE        :*and creates the file test.text

> (with-open-file (stream "test.text" :direction :input)
    (list (read stream) (read-char stream) (read stream)
          (read stream nil 'eof)))=>
((HELLO THERE) #\G OODBYE EOF)
```

Функция `terpri` расшифровывается как "завершить печатаемую строку/terminate print line" и она приводит к переходу на следующую строку.
Функция `fresh-line` также переходит к следующей строке, если только не будет определено, что вывод уже находится в начале строки.

Common Lisp также предоставляет очень общую функцию для выполнения форматированного вывода, называемую `format`.
Первый аргумент `format` -это всегда поток для печати; используйте `t`, чтобы распечатывать на терминал.
Второй аргумент-это строка формата.
Он распечатывается дословно, за исключением *директив формата*, которые начинаются с символа `"~"`.
Эти директивы указывают, как распечатать остальные аргументы.
Пользователи функции Cи `printf` или оператора FORTRAN `format` должны быть знакомы с этой идеей.
Вот вам пример:

```lisp
> (format t "hello, world")
hello, world
NIL
```

Все становится интересным, когда мы вводим дополнительные аргументы и включаем директивы формата:

```lisp
> (format t "~&~a plus ~s is ~f" "two" "two" 4)
two plus "two" is 4.0
NIL
```

Директива `~&` перемещает вывод на новую строку, `~a` печатает следующий аргумент как `princ`, `~s` печатает следующий аргумент как `prin1`, а `~f` печатает число в формате с плавающей запятой.
Если аргумент не является числом, то используется `princ`.
`format` всегда возвращает nil.
Существует 26 различных директив формата.
Вот более сложный пример:

```lisp
> (let ((numbers '(1 2 3 4 5)))
    (format t "~&~{~r~^ plus ~} is ~@r"
            numbers (apply #'+ numbers)))
one plus two plus three plus four plus five is XV
NIL
```

Директива `~r` выводит следующий аргумент, который должен быть числом, на английском языке, а `~@r` выводит число в виде римской цифры.
Составная директива `~{...~}` принимает следующий аргумент, который должен быть списком, и форматирует каждый элемент списка в соответствии со строкой формата внутри фигурных скобок.
Наконец, директива `~^` выходит из окружения цикла `~{...~}`, если больше нет аргументов.
Вы можете видеть, что `format`, как и `loop`, включает в себя почти целый язык программирования, который, также как и `loop`, не очень похож на Лиспоподобный язык.

## 3.13 Инструменты отладки

Во многих языках существуют две стратегии отладки: (1) изменение программы, вставляются инструкции print, программа перекомпилируется и повторно запускается или (2) использование программы отладки для исследования (и , возможно, изменения) внутреннего состояния запущенной программы.

Common Lisp допускает обе эти стратегии, но он также предлагает третью: (3) Добавление аннотаций, которые не являются частью программы, но имеют эффект автоматического изменения запущенной программы.
Преимущество третьей стратегии состоит в том, что, как только вы закончите, вам не придется возвращаться назад и отменять изменения, которые вы внесли бы в первую стратегию.
Кроме того, Common Lisp предоставляет функции, отображающие информацию о программе.
Вам не нужно полагаться только на просмотр исходного кода.

Мы уже видели, как `trace` и `untrace` могут использоваться для предоставления отладочной информации (стр. 65).
Еще одним полезным инструментом является `step`, который может быть использован для остановки выполнения до того, как каждая подформа будет вычислена.
Форма (`step` *expression*) вычисляет и возвращает *expression/выражение*, но делает паузу в определенных точках, чтобы позволить пользователю проверить вычисление и, возможно, изменить чтото, прежде чем перейти к следующему шагу.
Команды, доступные пользователю, зависят от реализации, но введя `?`- лисп должен дать вам список команд.
Например, здесь мы проходим через выражение дважды, в первый раз давая команды останавки stop при каждом подвычислении, а во второй раз давая команды skip, перехода к следующему вызову функции.
В этой реализации команды являются управляющими символьными знаками, поэтому они не отображаются в выходных данных.

Все выходные данные, включая символы <= и =>, печатаются самим степпером(процедурой пошагового прохождения); я не добавил никаких аннотаций.

```lisp
> (step (+ 3 4 (* 5 6 (/ 7 8))))
<= (+ 3 4 (* 5 6 (/ 7 8)))
  <= 3 => 3
  <= 4 => 4
  <= (* 5 6 (/ 7 8))
  <= 5 => 5
  <= 6 => 6
  <= (/ 7 8)
    <= 7 => 7
  <= 8 => 8
    <=(/ 7 8) => 7/8
  <= (* 5 6 (/ 7 8)) => 105/4
  <= (+ 3 4 (* 5 6 (/ 7 8))) => 133/4
133/4

> (step (+ 3 4 (* 5 6 (/ 7 8))))
<= (+ 3 4 (* 5 6 (/ 7 8)))
  /: 7 8 => 7/8
  *: 5 6 7/8 => 105/4
  +: 3 4 105/4 => 133/4
<= (+ 3 4 (* 5 6 (/ 7 8))) => 133/4
133/4
```

Функции `describe(описание)`, `inspect(проверка), documentation(документация)` и `apropos(кстати)`  предоставляют информацию о состоянии текущей программы.
`apropos` выводит информацию обо всех символах, имя которых совпадает с аргументом:

```lisp
> (apropos 'string)
MAKE-STRING            function (LENGTH &KEY INITIAL-ELEMENT)
PRIN1-T0-STRING        function (OBJECT)
PRINC-T0-STRING        function (OBJECT)
STRING                 function (X)
...
```

Как только вы узнаете, какой объект вас интересует, `describe` может дать больше информации о нем:

```lisp
> (describe 'make-string)
Symbol MAKE-STRING is in LISP package.
The function definition is #<FUNCTION MAKE-STRING -42524322 >:
  NAME:          MAKE-STRING
  ARGLIST:       (LENGTH &KEY INITIAL-ELEMENT)
  DOCUMENTATION: "Creates and returns a string of LENGTH elements,
all set to INITIAL-ELEMENT."
  DEFINITION:    (LAMBDA (LENGTH &KEY INITIAL-ELEMENT)
                   (MAKE-ARRAY LENGTH : ELEMENT-TYPE 'CHARACTER
                               :INITIAL-ELEMENT (OR INITIAL-ELEMENT
                                                    #\SPACE)))
MAKE-STRING has property INLINE: INLINE
MAKE-STRING has property :SOURCE-FILE: #P"SYS:KERNEL; STRINGS"

> (describe 1234.56)
1234.56 is a single-precision floating-point number.
  Sign 0, exponent #o211, 23-bit fraction #o6450754
```

Если все, что вам нужно, - это строка документации символа, функция `documentation` сделает свое дело:

```lisp
> (documentation 'first 'function) => "Return the first element of LIST."
> (documentation 'pi 'variable) =$> "pi"
```

Если вы хотите посмотреть и, возможно, изменить компоненты сложной структуры, то `inspect` - это необходимый вам инструмент.
В некоторых реализациях он вызывает причудливый оконный браузер.

Common Lisp также предоставляет отладчик, вход в который поисходит автоматически, когда происходит вызов сигнала об ошибке, либо при непреднамеренной ошибке, либо преднамеренным действием со стороны программы.
Детали отладчика различаются в разных реализациях, но существуют стандартные способы входа в него.
Функция `break` входит в отладчик после печати необязательного сообщения.
Она предназначена в качестве основного метода для установки точек останова отладки.
`break` предназначена только для отладки; Когда программа считается рабочей, все вызовы `break` должны быть удалены.
Тем не менее, это все еще хорошая идея проверять необычные условия с помощью `error`, `cerror`, `assert` или `check-type`, которые будут описаны в следующем разделе.

## 3.14 Инструменты для борьбы  с ошибками

Хорошей идеей, является включение *противоошибочной* проверки в ваш код, в дополнение к выполнению обычной отладке.
Противоошибочный код проверяет наличие ошибок и, возможно, принимает корректирующие меры.

Функции `error` и `cerror` используются для сигнализации об ошибке.
Они предназначены для того, чтобы остаться в программе даже после ее отладки.
Функция `error` принимает строку формата и необязательные аргументы.
Она сигнализирует о фатальной ошибке, то есть останавливает программу и не предлагает пользователю никакого способа ее перезапуска.
Например:

```lisp
(defun average (numbers)
  (if (null numbers)
      (error "Average of the empty list is undefined.")
      (/ (reduce #'+ numbers)
         (length numbers))))
```

Во многих случаях фатальная ошибка бывает не столь радикальной.
Функция `cerror` означает продолжаемую(continuable) ошибку, т.е ошибку после которой, у программы есть возможность продолжить работу.
`cerror` принимает две строки формата; первая печатает сообщение, указывающее, что произойдет, если мы продолжим, а вторая печатает само сообщение об ошибке.
`cerror` на самом деле не предпринимает никаких действий для исправления ошибки, она просто позволяет  сигнализировать пользователю, что можно продолжить выполнение.
В следующей реализации пользователь выполняет продолжение, набрав `:continue`.
В ANSI Common Lisp существуют дополнительные способы указания параметров для продолжения работы.

```lisp
(defun average (numbers)
  (if (null numbers)
      (progn
        (cerror "Use 0 as the average."
                "Average of the empty list is undefined.")
        0)
      (/ (reduce #'+ numbers)
         (length numbers))))

> (average '())
Error: Average of the empty list is undefined.
Error signaled by function AVERAGE.
If continued: Use 0 as the average.
>> :continue
0
```

В этом примере добавление проверки ошибок почти удвоило длину кода.
В этом нет ничего необычного; существует большая разница между кодом, который работает при ожидаемом вводе, и кодом, который покрывает все возможные ошибки.
Common Lisp пытается упростить проверку ошибок, предоставляя несколько специальных форм.
Форма `ecase` расшифровывается как "exhaustive case/исчерпывающий случай" или "error case/в случае ошибки".
Она похожа на обычную форму case, за исключением того, что если ни один из вариантов не выбран, генерируется сообщение об ошибке.
Форма `ccase` расшифровывается как "continuable case/продолжаемый случай". Он похож на `ecase`, за исключением того, что ошибка является продолжаемой.
Система будет запрашивать новое значение для тестируемого объекта до тех пор, пока пользователь не предоставит то, которое соответствует одному из запрограммированных случаев.

Чтобы упростить включение проверок на ошибки без чрезмерного увеличения длины кода, Common Lisp предоставляет специальные формы `check-type` и `assert`.
Как следует из названия, `check-type` используется для проверки типа аргумента.
Она выдает сигнал о продолжаемой ошибке, если аргумент имеет неправильный тип.
Например:

```lisp
(defun sqr (x)
  "Multiply x by itself."
  (check-type x number)
  (* x x))
```

Если `sqr` вызывается с не числовым аргументом, то выводится соответствующее сообщение об ошибке:

```lisp
> (sqr "hello")
Error: the argument X was "hello", which is not a NUMBER.
If continued: replace X with new value
>> :continue 4
16
```

`assert` является более общей, чем `check-type`.
В простейшей форме assert проверяет выражение и сигнализирует об ошибке, если оно ложно.
Например:

```lisp
(defun sqr (x)
  "Multiply x by itself."
  (assert (numberp x))
  (* x x))
```

Нет никакой возможности выполнить продолжение из утверждения такого рода.
Можно также дать `assert` список мест, которые могут быть изменены в попытке сделать утверждение истинным.
В этом примере переменная `x`  - это единственное, что можно изменить:

```lisp
(defun sqr (x)
  "Multiply x by itself."
  (assert (numberp x) (x))
  (* x x))
```

Если утверждение нарушено, будет выведено сообщение об ошибке, и пользователю будет предоставлена возможность выполнить продолжение, изменив `x`.
Если `x` получает значение, удовлетворяющее утверждению, то программа может быть продолжена, 'assert' всегда возвращает nil.

Наконец, пользователь, который хочет больше контролировать сообщение об ошибке, может предоставить строку управления форматом и необязательные аргументы.
Таким образом, самый сложный синтаксис для assert - это:

> `(assert` *test-form* (*place...*) *format-ctl-string format-arg...*)

Вот еще один пример.
Утверждение( assertion) проверяет, что температура медвежьей каши не слишком горячая и не слишком холодная.

```lisp
(defun eat-porridge (bear)
  (assert (< too-cold (temperature (bear-porridge bear)) too-hot)
          (bear (bear-porridge bear))
          "~a's porridge is not just right: ~a"
          bear (hotness (bear-porridge bear)))
  (eat (bear-porridge bear)))
```

В приведенном ниже взаимодействии утверждение потерпело неудачу, и сообщение об ошибке программиста было напечатано вместе с двумя возможностями продолжения программы.
Пользователь выбрал одни, введя вызов `make-porridge` в качестве нового значения, и функция успешно продолжилась.

```lisp
> (eat-porridge momma-bear)
Error: #<MOMMA BEAR>'s porridge is not just right: 39
Restart actions (select using :continue):
 0: Supply a new value for BEAR
 1: Supply a new value for (BEAR-PORRIDGE BEAR)
>> :continue 1
Form to evaluate and use to replace (BEAR-PORRIDGE BEAR):
(make-porridge :temperature just-right)
nil
```

Может показаться напрасным тратить время на написание утверждений(assertions), которые (если все пойдет хорошо) никогда не будут использованы.
Однако для всех, кроме идеального программиста, ошибки действительно случаются, и время, потраченное на противоошибочный код, с лихвой окупится в экономии времени при отладке.

Всякий раз, когда вы разрабатываете сложную структуру данных, такую как некоторая база данных, рекомендуется разработать соответствующую проверку согласованности.
Проверка согласованности-это функция, которая просматривает структуру данных и проверяет наличие всех возможных ошибок.
При обнаружении новой ошибки проверка ее наличия должна быть включена в Средство проверки согласованности.
Вызов средства проверки согласованности-это самый быстрый способ изолировать ошибки в структуре данных.

Кроме того, хорошей идеей будет иметь под рукой список сложных тестовых заданий.
Таким образом, когда программа будет изменена, будет легко увидеть, если изменение повторно выводит ошибку, которая была ранее удалена.
Это называется * регрессионным тестированием/regression testing* и [Waters (1991)] (B9780080571157500285.xhtml#bb1350) представляет собой интересный инструмент для поддержания набора регрессионных тестов.
Но достаточно просто поддерживать неформальный набор тестов с функцией, вызывающей assert на ряде примеров:

```lisp
(defun test-ex ()
  "Test the program EX on a series of examples."
  (init-ex) ; Initialize the EX program first.
  (assert (equal (ex 3 4) 5))
  (assert (equal (ex 5 0) 0))
  (assert (equal (ex 'x 0) 0)))
```

### Инструменты учета времени

Программа не является законченой только потому, что она дает правильный результат.
Она также должна своевременно предоставлять результаты своей деятельности.
Форма (`time` *expression*) может использоваться, чтобы увидеть, сколько времени требуется для выполнения *expression*.
Некоторые реализации также печатают статистику по объему требуемого хранилища.
Например:

```lisp
> (defun f (n) (dotimes (i n) nil)) => F
> (time (f 10000)) NIL
Evaluation of (F 10000) took 4.347272 Seconds of elapsed time, including 0.0 seconds of paging time for 0 faults, Consed 27 words.

> (compile 'f) F

> (time (f 10000)) => NIL
Evaluation of (F 10000) took 0.011518 Seconds of elapsed time, including 0.0 seconds of paging time for 0 faults, Consed 0 words.
```

Он показывает, что скомпилированная версия более чем в 300 раз быстрее и использует меньше места для загрузки.
Большинство серьезных программистов Common Lisp работают исключительно с компилируемыми функциями.
Однако, как правило, это плохая идея, чтобы беспокоиться слишком много о деталях эффективности, начиная разрабатывать программу.
Лучше разработать гибкую программу, заставить ее работать, а затем модифицировать наиболее часто используемые части, чтобы быть более эффективными.
Другими словами, отделите стадию разработки от стадии тонкой настройки.
[Главы 9](chapter9.md) и [10](chapter10.md) дают более подробную информацию о рассмотрении эффективности и [глава 25] (chapter25.md) дает больше советов по отладке и методам борьбы с ошибками.

## 3.15 Вычисление(оценка/Evaluation)

Есть три функции для выполнения вычислений в Lisp: `funcall, apply` и `eval`.
`funcall` используется для применения функции к отдельным аргументам, в то время как `apply` используется для применения функции к списку аргументов.
На самом деле, `apply` можно дать один или несколько отдельных аргументов перед окончательным аргументом, который всегда является списком.
в `eval` передается один аргумент, который должен быть целой формой - функцией или специальной формой, за которой следуют ее аргументы или, возможно, атом.
Следующие пять форм эквивалентны:

```lisp
> (+ 1 2 3 4)             => 10
> (funcall #'+ 1 2 3 4)   => 10
> (apply #'+ '(1 2 3 4))  => 10
> (apply #'+ 1 2 '(3 4))  => 10
> (eval '(+  123 4))      => 10
```

В прошлом `eval` считался ключом к гибкости Лиспа.
В современных Лиспах с лексическим охватом, таких как Common Lisp, `eval` используется редко (на самом деле в Scheme вообще нет `eval`).
Вместо этого программисты должны использовать `lambda` для создания новой функции, а затем функцию `apply` или `funcall`.
В общем, если вы обнаружите, что используете `eval`, вы, вероятно, делаете что-то не так.

## 3.16 Замыкания

Что значит создать новую функцию?
Конечно, каждый раз, когда вычисляется специальная форма `function` (или `#')`, возвращается функция.
Но в примерах, которые мы видели, и в следующем, всегда возвращается одна и та же функция.

```lisp
> (mapcar #'(lambda (x) (+ x x)) '(1 3 10)) => (2 6 20)
```

Каждый раз, когда мы вычисляем форму `#'(lambda ...)`, она возвращает функцию, которая удваивает свой аргумент.
Однако в общем случае функция состоит из тела функции, связанного с любыми *свободными лексическими переменными*, на которые ссылается функция.
Такое сопряжение называется лексическим замыканием или просто замыканием, потому что лексические переменные заключены внутри функции.
Рассмотрим этот пример:

```lisp
(defun adder (c)
  "Возвращает функцию которая добавляет c к своему аргументу."
  #'(lambda (x) (+ x c)))

> (mapcar (adder 3) '(1 3 10)) => (4 6 13)

> (mapcar (adder 10) '(1 3 10)) => (11 13 20)
```

Каждый раз, когда мы вызываем  `adder` с другим значением для   `c`, он создает другую функцию, функцию, которая добавляет  `c` к своему аргументу.
Поскольку каждый вызов  'adder' создает новую локальную переменную с именем   `c`, каждая функция, возвращаемая   `adder`, является уникальной функцией.

Вот еще один пример.
Функция `bank-account` возвращает замыкание, которое может быть использовано в качестве представления банковского счета.
Замыкание захватывает локальную переменную balance.
Тело замыкания предоставляет код для доступа и изменения локальной переменной.

```lisp
(defun bank-account (balance)
  "Open a bank account starting with the given balance."
  #'(lambda (action amount)
      (case action
        (deposit  (setf balance (+ balance amount)))
        (withdraw (setf balance (- balance amount))))))
```

В следующем примере два вызова bank-account создают два разных замыкания, каждое из которых имеет отдельное значение для лексической переменной `balance`.
Последующие вызовы этих двух замыканий изменяют их соответствующие балансы, но между этими двумя счетами нет никакой путаницы.

```lisp
> (setf my-account (bank-account 500.00)) => #<CLOSURE 52330407>

> (setf your-account (bank-account 250.00)) => #<CLOSURE 52331203>

> (funcall my-account 'withdraw 75.00) => 425.0

> (funcall your-account 'deposit 250.00) => 500.0

> (funcall your-account 'withdraw 100.00) => 400.0

> (funcall my-account 'withdraw 25.00) => 400.0
```

Этот стиль программирования будет рассмотрен более подробно в главе 13(chapter13.md).

## 3.17 Специальные Переменные

Common Lisp предоставляет два вида переменных: *lexical/лексические* и *special/специальные* переменные.
Для новичка заманчиво приравнять специальные переменные в Common Lisp к глобальным переменным в других языках.
К сожалению, это не совсем правильно и может привести к проблемам.
Лучше всего понимать общие переменные Lisp на их собственных терминах.

По умолчанию переменные Common Lisp являются *лексическими переменными/lexical variables*.
Лексические переменные вводятся некоторыми синтаксическими конструкциями, такими как `let` или `defun` и получают свое название от того факта, что они могут быть упомянуты только кодом, который лексически появляется в теле синтаксической конструкции.
Тело называется *scope/областью действия* переменной.

До сих пор нет никакой разницы между Common Lisp и другими языками.
Самое интересное, когда мы рассматриваем *extent* или время жизни, переменной.
В других языках экстент(время жизни) совпадает с областью действия: новая локальная переменная создается при входе в блок и переменная исчезает при выходе из блока.
Но поскольку в Lisp можно создавать новые функции-замыкания, то код, ссылающийся на переменную, может существовать и после выхода из области действия переменной.
Рассмотрим еще раз функцию `bank-account`, которая создает замыкание, представляющее банковский счет:

```lisp
(defun bank-account (balance)
  "Open a bank account starting with the given balance."
  #'(lambda (action amount)
      (case action
        (deposit (setf balance (+ balance amount)))
        (withdraw (setf balance (- balance amount))))))
```

Функция вводит лексическую переменную `balance`.
Областью действия `balance` является тело функции, и поэтому ссылки на `balance` могут встречаться только в этой области.
Что происходит, когда `bank-account` вызывается и завершает вызов?
После того, как вычисление тела функции было завершено, никакой другой код не может ссылаться на этот экземпляр `balance`.
Область охвата(scope) была покинута, но ссылка на `balance` продолжает жить.
Мы можем вызвать замыкание, и оно может ссылаться на `balance`, потому что код, который создал замыкание, лексически появился в области существования `balance`.

Таким образом, лексические переменные Common Lisp отличаются тем, что они могут быть захвачены внутри замыканий и ссылаться на них даже после того, как поток управления покинул их область действия.

Теперь рассмотрим специальные переменные.
Переменная становится Специальной с помощью формы `defvar` или `defparameter`.
Например, если мы скажем:

```lisp
(defvar *counter* 0)
```

затем мы можем обратиться к специальной переменной `*counter*` в любом месте нашей программы.
Это очень похоже на знакомую глобальную переменную.
Сложность заключается в том, что глобальная привязка `*counter*` может быть затенена локальной привязкой для этой переменной.
В большинстве языков локальная привязка вводит локальную лексическую переменную, но в Common Lisp специальные переменные могут быть связаны как локально, так и глобально.
Вот вам пример:

```lisp
(defun report ()
  (format t "Counter = ~d" *counter*))

> (report)
Counter = 0
NIL

> (let ((*counter* 100))
    (report))
Counter = 100
NIL

> (report)
Counter = 0
NIL
```

Есть здесь три вызова `report`.
В первом и третьем `report` выводит глобальное значение специальной переменной `*counter*`.
Во втором вызове форма `let` вводит новую привязку для специальной переменной  `*counter*`, которая снова печатается с помощью `report`.
Как только область действия `let` заканчивается, новая привязка уничтожается, поэтому последний вызов `report` снова использует глобальное значение.

Таким образом, специальные переменные Common Lisp отличаются тем, что они имеют глобальную область действия, но допускают возможность локального (динамического) затенения.
Помните: лексическая переменная имеет лексическую область действия и неопределенный экстент(время существовани).
Специальная переменная имеет неопределенную область действия и динамический экстент.

Вызов функции (`symbol-value` *var*), где *var* вычисляется как символ, может быть использован для получения текущего значения специальной переменной.
Чтобы задать специальную переменную, следующие две формы полностью эквивалентны:

> `(setf (symbol-value` *var*) *value*) 
 
> `(set` *var value*)


где и *var* и *value* вычисляются.
Не существует соответствующих форм для доступа и установки лексических переменных.
Специальные переменные устанавливают отображение между символами и значениями, доступное для запущенной программы.
Это не похоже на лексические переменные (и все переменные в традиционных языках), где символы (идентификаторы) имеют значение только во время компиляции программы.
Как только программа запущена, идентификаторы были скомпилированы и не могут быть использованы для доступа к переменным; только код, который появляется в области лексической переменной, может ссылаться на эту переменную.

&#9635; **Упражнение 3.6 [s]** учитывая следующую инициализацию для лексической переменной `a` и специальной переменной `*b*`, каким будет значение формы `let`?

```lisp
(setf a 'global-a)
(defvar *b* 'global-b)

(defun fn () *b*)

(let ((a 'local-a)
      (*b* 'local-b))
  (list a *b* (fn) (symbol-value 'a) (symbol-value '*b*)))
```

## 3.18 Множественные Значения

На протяжении всей этой книги мы говорили о "значении, возвращаемом функцией."
Исторически Lisp был разработан таким образом, что каждая функция возвращает значение, даже те функции, которые больше похожи на процедуры, чем на функции.
Но иногда мы хотим, чтобы одна функция возвращала более одного фрагмента информации.
Конечно, мы можем сделать это, составив список или структуру для хранения информации, но тогда нам придется потрудиться над определением структуры, каждый раз создавая экземпляр, а затем разбирая его на части, чтобы посмотреть на фрагменты.
Рассмотрим функцию `round`.
Один из способов его использования-округление числа с плавающей запятой до ближайшего целого числа.
Итак (`round 5.1`) - это 5.
Иногда, хотя и не всегда, программиста интересует и дробная часть.
Функция `round` служит как заинтересованным, так и незаинтересованным программистам, возвращая два значения: округленное целое число и оставшуюся дробь:

```lisp
> (round 5.1) => 5 .1
```

После => есть два значения, потому что `round` возвращает два значения.
В большинстве случаев множественные значения игнорируются, и используется только первое значение.
Таким образом, (`* 2 (round 5.1)`) равно 10, как если бы `round` возвращал только одно значение.
Если вы хотите получить несколько значений, вам нужно использовать специальную форму, такую как `multiple-value-bind`:

```lisp
(defun show-both (x)
  (multiple-value-bind (int rem)
      (round x)
    (format t "~f = ~d + ~f" x int rem)))

>(show-both 5.1)
5.1 = 5 + 0.1
```

Вы можете написать свои собственные функции, возвращающие несколько значений, используя функцию `values`, которая возвращает свои аргументы в виде множественных значений:

```lisp
> (values 1 2 3) => 1 2 3
```

Множественные значения-это хорошее решение, потому что они ненавязчивы, пока не понадобятся.
Большую часть времени, когда мы используем `round`, нас интересует только целочисленное значение.
Если бы `round` не использовал множественные значения, если бы он упаковал два значения в список или структуру, то его было бы труднее использовать в обычных случаях.

Также можно не возвращать значения из функции используя (`values`).
Это иногда используется процедурами, которые вызываются ради стороннего эффекта, например печати.
Например, `describe` определяется для печати информации, а затем не возвращает никаких значений:

```
> (describe 'x)
Symbol X is in the USER package.
It has no value, definition or properties.
```

Однако, когда (`values`) или любое другое выражение, не возвращающее никаких значений, вложено в контекст, где ожидается значение, оно все еще подчиняется правилу Lisp одного значения на выражение и возвращает `nil`.
В следующем примере `describe` не возвращает никаких значений, но затем `list` фактически запрашивает первое значение и получает `nil`.

```
> (list (describe 'x))
Symbol X is in AILP package.
It has no value, definition or properties.
(NIL)
```

## 3.19 подробнее о параметрах

Common Lisp предоставляет пользователю большую гибкость в определении параметров функции и, следовательно, аргументов, которые принимает функция.
Ниже приводится программа, которая дает практику в арифметике.
Она задает пользователю ряд из *n* задач, где каждая задача проверяет арифметический оператор op (который может быть `+`, `-`, `*`, или `/' или, возможно, другой двоичный оператор).
Аргументами оператора будут случайные целые числа от 0 до range.
Вот программа:

```lisp
(defun math-quiz (op range n)
  "Ask the user a series of math problems."
  (dotimes (i n)
    (problem (random range) op (random range))))

(defun problem (x op y)
  "Ask a math problem, read a reply, and say if it is correct."
  (format t "~&How much is ~d ~a ~d?" x op y)
  (if (eql (read) (funcall op x y))
      (princ "Correct!")
      (princ "Sorry, that's not right.")))
```

а вот пример её использования:

```lisp
> (math-quiz '+ 100 2)
How much is 32 + 60? 92
Correct!
How much is 91 + 19? 100
Sorry, that's not right.
```

Одна из проблем с функцией `math-quiz` заключается в том, что она требует от пользователя ввести три аргумента: оператор, диапазон и число итераций.
Пользователь должен запомнить порядок аргументов и не забыть процитировать оператор.
Это довольно много, чтобы ожидать от пользователя, который, по-видимому, только учится складывать!

Common Lisp предоставляет два способа решения этой проблемы.
Во-первых, программист может указать, что некоторые аргументы являются *optional/необязательными*, и предоставить значения по умолчанию для этих аргументов.
Например, в `math-quiz` мы можем сделать так, чтобы `+` был оператором по умолчанию, `100` - диапазоном чисел по умолчанию, а `10` - числом примеров по умолчанию со следующим определением:

```lisp
(defun math-quiz (&optional (op '+) (range 100) (n 10))
  "Ask the user a series of math problems."
  (dotimes (i n)
    (problem (random range) op (random range))))
```

Теперь (`math-quiz`) означает то же, что (`math-quiz '+ 100 10`).
Если необязательный параметр появляется отдельно без значения по умолчанию, то значение по умолчанию равно   `nil`.
Дополнительные параметры удобны; однако что делать, если пользователь доволен оператором(op) и диапазоном(range), но хочет изменить количество итераций(n)?
Необязательные параметры по-прежнему зависят от позиции, поэтому единственное решение-ввести все три аргумента: ``(math-quiz '+ 100 5)``.

Common Lisp также позволяет использовать параметры, не зависящие от положения.
Эти параметры *keyword/ключевые слова* явно именуются в вызове функции.
Они полезны, когда есть ряд параметров, которые обычно принимают значения по умолчанию, но иногда нуждаются в определенных значениях.
Например, мы могли бы определить `math-quiz` как:

```lisp
(defun math-quiz (&key (op '+) (range 100) (n 10))
  "Ask the user a series of math problems."
  (dotimes (i n)
    (problem (random range) op (random range))))
```

Теперь (`math-quiz :n 5`) и (`math-quiz :op '+ :n 5 :range 100`) означает то же самое.
Аргументы ключевые слова задаются именем параметра, которому предшествует двоеточие, а за ним следует значение.
Пары ключевое слово/значение могут располагаться в любом порядке.

Символ, начинающийся с двоеточия, называется *ключевым словом* и может использоваться в любом месте, а не только в списках аргументов.
Термин *ключевое слово* используется в Lisp иначе, чем во многих других языках.
Например, в Паскале, ключевые слова (или *зарезервированые* слова) синтаксические символы, как `if, else, begin` и `end`.
В Lisp мы называем такие символы *операторами специальных форм* или просто *специальные формы*.
<a id="tfn03-3"></a>
Ключевые слова в Lisp - это символы, которые находятся в пакете ключевых слов(keyword) .[[3]](#fn03-3)
Они не имеют особого синтаксического значения, хотя и обладают необычным свойством самовычисления: они являются константами, которые вычисляются сами в себя, в отличие от других символов, которые вычисляются в любое значение, сохраненное в переменной, именуемой символом.
Ключевые слова также используются при указании списков аргументов `&key`, но это происходит в силу их значения, а не в силу какого-то синтаксического правила.
Важно помнить, что ключевые слова используются при вызове функции, но в качестве параметров в определении функции используются обычные символы nonkeyword.

Просто чтобы сделать вещи немного более запутанными, символы `&optional, &rest` и `&key` называются *ключевыми словами лямбда-списка* по историческим причинам.
В отличие от двоеточия в реальных ключевых словах, `&` в ключевых словах лямбда-списка не имеет особого значения.
Рассмотрим эти аннотированные примеры:

`> :xyz => :XYZ`        ; *ключевые слова- вычисляются сами в себя*

`> &optional =>`        ; *ключевые слова лямбда-списка это обычные символы*  
Error: the symbol &optional has no value

```lisp
> '&optional => &OPTIONAL
```
`> (defun f (&xyz) (+ &xyz &xyz)) F` ;& *не имеет никакого значения*

```lisp
> (f 3) => 6
> (defun f (:xyz) (+ :xyz :xyz)) =>
```
*Error: the keyword :xyz appears in a variable list.  
Ключевые слова являются константами и поэтому не могут использоваться в качестве имен переменных.*

```lisp
> (defun g (&key x y) (list x y)) => G
```
```
> (let ((key s '(:x :y :z)))
   (g (second keys) 1 (first keys) 2)) => (2 1)
```
; *ключевое слово в аргументах может быть вычислено*

Многие функции, представленные в этой главе, используют аргументы ключевые слова, что делает их более универсальными.
Например, вспомните функцию `find`, которая может быть использована для поиска определенного элемента в последовательности:

```lisp
> (find 3 '(1 2 3 4 -5 6.0)) => 3
```
Оказывается, что `find` принимает несколько необязательных аргументов ключевых слов.
Например, предположим, что мы попытались найти `6` в этой последовательности:

```lisp
> (find 6 '(1 2 3 4 -5 6.0)) => nil
```

Сделать это не удается, потому что `find` тестируен на равенство с помощью "eql", а `6` не является равным с  `6.0` для `eql`.
Однако `6` является равным  6.0 для `equalp`, поэтому мы могли бы использовать ключевое слово `:test` :

```lisp
> (find 6 '(1 2 3 4 -5 6.0) :test #'equalp) => 6.0
```

Фактически, мы можем указать любой двухаргументный предикат для ключевого слова `:test`; он не обязательно должен быть предикатом равенства.
Например, мы могли бы найти первое число, которое больше, чем `4`:

```lisp
> (find 4 '(1 2 3 4 -5 6.0) :test #'<) => 6.0
```

Теперь предположим, что мы не заботимся о знаке чисел; если мы ищем `5`, мы хотим найти `-5`.
Мы можем справиться с этим с помощью ключевого слова, чтобы взять абсолютное значение каждого элемента списка с помощью функции `abs` :

```lisp
> (find 5 '(1 2 3 4 -5 6.0) :key #'abs) => -5
```

Параметры ключевые слова значительно расширяют полезность встроенных функций, и они могут делать то же самое для функций, которые определяете вы.
Среди встроенных функций наиболее распространенные ключевые слова делятся на две основные группы: `:test`, `:test-not` и `:key`, которые используются для функций сопоставления, и `:start`, `:end` и `:from-end`, которые используются для функций работающих с последовательностями.
Некоторые функции принимают оба набора ключевых слов.
(*Common Lisp The Language*, 2d edition, не поощряет использование ключевых слов `:test-not`, хотя они все еще являются частью языка.)

Соответствующие функции включают `sublis`, `position`, `subst`, `union`, `intersection`, `set-difference`, `remove`, `remove-if`, `subsetp`, `assoc`, `find,` and `member.`
По умолчанию каждая тестирует, является ли какой-то элемент `eql`(равным для этой функции) одному или нескольким из ряда других объектов.
Этот тест может быть изменен путем предоставления некоторого другого предиката в качестве аргумента для `:test` или он может быть отменен путем указания `:test-not`.
Кроме того, сравнение может быть выполнено с некоторой частью объекта, а не со всем объектом, указав функцию селектор в качестве аргумента `:key`.

Функции последовательности включают в себя `remove`, `remove-if`, `position` и `find`.
Наиболее распространенным типом последовательности является список, но строки и векторы также могут использоваться в качестве последовательностей.
Функция работающая с последовательностью выполняет некоторое повторяющееся действие  для некоторых элементов последовательности.
По умолчанию проход по последовательности должен проходить от начала до конца, но обратный порядок может быть задан с помощью  `:from-end t`,  а подпоследовательность может быть задана с помощью ключевого слова  `:start`  или  `:end`.
Первый элемент последовательности имеет номер 0, а не 1, поэтому будьте осторожны.

В качестве примера параметров ключевых слов предположим, что мы хотим написать функции работы с последовательностями, которые похожи на `find` и `find-if`, за исключением того, что они возвращают список всех совпадающих элементов, а не только первый совпадающий элемент.
Мы будем называть новыми функциями `find-all` и `find-all-if`.
Другой способ взглянуть на эти функции-как на вариацию remove.
Вместо того чтобы удалять совпадающие элементы, они сохраняют все совпадающие элементы и удаляют те, которые не совпадают.
Рассматривая это таким образом, мы можем видеть, что функция `find-all-if` на самом деле является той же самой функцией, что и `remove-if-not`.
Иногда полезно иметь два имени для одной и той же функции, рассматриваемой по-разному (например, `not` и `null`).
Новое имя можно было бы определить с помощью `defun`, но проще просто скопировать определение:

```lisp
(setf (symbol-function 'find-all-if) #'remove-if-not)
```

К сожалению, нет встроенной функции, которая точно соответствует `find-all`, поэтому нам придется ее определить.
К счастью, `remove` может сделать большую часть работы.
Все, что нам нужно сделать, это организовать передачу в remove дополнение предиката `:test`.
Например, поиск всех элементов, равных 1 в списке, эквивалентен удалению элементов, не равных 1:

```lisp
> (setf nums '(1 2 3 2 1)) => (1 2 3 2 1)

> (find-all 1 nums :test #'=) = (remove 1 nums :test #'/=) => (1 1)
```

Теперь нам нужна функция более высокого порядка, которая возвращает дополнение функции.
Другими словами, принимая `=`, мы хотим вернуть `/=`.
Эта функция называется  `complement/дополнением` в ANSI Common Lisp, но она не была определена в более ранних версиях, поэтому она приведена здесь:

```lisp
(defun complement (fn)
  "If FN returns y, then (complement FN) returns (not y)."
  ;; This function is built-in in ANSI Common Lisp,
  ;; but is defined here for those with non-ANSI compilers.
  #'(lambda (&rest args) (not (apply fn args))))
```

Когда   `find-all`   вызывается с заданным предикатом   `:test`, все, что нам нужно сделать, это вызвать   `remove`   с дополнением в качестве предиката   `:test`.
Это верно даже тогда, когда функция   `:test`   не задана и поэтому по умолчанию используется значение `eql`.
Мы также должны проверить, когда пользователь указывает предикат   `:test-not`, который используется для указания того, что совпадение завершается успешно, когда предикат ложен.
Будет ошибкой- указывать одновременно как аргумент   `:test`, так и аргумент    `:test-not`   для одного и того же вызова, поэтому нам не нужно проверять такой случай.
Определение таково:

```lisp
(defun find-all (item sequence &rest keyword-args
                 &key (test #'eql) test-not &allow-other-keys)
  "Find all those elements of sequence that match item,
  according to the keywords.  Doesn't alter sequence."
  (if test-not
      (apply #'remove item sequence
             :test-not (complement test-not) keyword-args)
      (apply #'remove item sequence
             :test (complement test) keyword-args)))
```

Единственная трудная часть этого определения-понимание списка параметров.
`&rest` собирает в себе все пары ключевое слово/значение в переменой `keyword-args`.
В дополнение к параметру  `&rest`  задаются два конкретных параметра ключевых слова: `:test`  и  `:test-not`.
Каждый раз, когда вы помещаете  `&key`  в список параметров, вам нужно (разрешить использовать другие ключевые слова)  `&allow-other-keys`,  если на самом деле другие ключевые слова разрешены.
В этом случае мы хотим принимать ключевые слова подобные  `:start`  и  `:key`  и передавать их в  `remove`.

Все пары ключевое слово/значение будут собираться в списке `keyword-args`, включая значения `:test` или `:test-not`.
Так что у нас будет:

```lisp
(find-all 1 nums :test #'= :key #'abs)
  = (remove 1 nums :test (complement #'=) :test #'= :key #'abs)
  => (1 1)
```

Обратите внимание, что вызов `remove` будет содержать два ключевых слова `:test`.
Это не ошибка; Common Lisp заявляет, что считается самое левое значение.

&#9635; **Упражнение 3.7 [s]** как вы думаете, почему считается самый левый из двух ключей, а не самый правый?

&#9635; **Упражнение 3.8 [m]** некоторые версии Kyoto Common Lisp (KCL) имеют ошибку, при которой они используют самое правое значение, когда для одного и того же ключевого слова задано более одной пары ключевое слово/значение.
Измените определение 'find-all' так, чтобы оно работало в KCL.

Есть еще два ключевых слова лямбда-списка, которые иногда используются продвинутыми программистами.
Во-первых, в макроопределении (но не в определении функции) символ `&body` может использоваться как синоним `&rest`.
Разница в том, что `&body` дает указание определенным программам форматирования делать отступы как тело(body).
Таким образом, если мы определили макрос:

```lisp
(defmacro while2 (test &body body)
  "Repeat body while test is true."
  `(loop (if (not ,test) (return nil))
         . ,body))
```

Тогда автоматическое отступление `while2` (в некоторых системах) красивее, чем `while`:

```lisp
(while (< i 10)
       (print (* i i))
       (setf i (+ i 1)))

(while2 (< i 10)
  (print (* i i))
  (setf i (+ i 1)))
```

Наконец, `&aux` можно использовать для привязки новой локальной переменной или переменных, как если бы они были связаны с `let*`.
Лично я считаю это мерзостью, потому что переменные `&aux` вообще не являются параметрами и поэтому не должны присутствовать в списке параметров.
Я думаю, что они должны быть четко выделены как локальные переменные в  `let`.
Но некоторые хорошие программисты используют `&aux`, вероятно, чтобы сэкономить место на странице или экране.
Вопреки моему здравому смыслу, я показываю пример:

```lisp
(defun length14 (list &aux (len 0))
  (dolist (element list len)
    (incf len)))
```

## 3.20 остальная часть Лиспа

В Common Lisp есть гораздо больше, чем то, что мы видели здесь, но этого обзора должно быть достаточно, чтобы читатель понял программы в следующих главах.
Серьезный программист Lisp продолжит свое образование, продолжая обращаться к справочникам и онлайн-документации.
Вы также можете найти полезной Часть V этой книги, особенно [Главу 24] (chapter24.md), которая охватывает расширенные функции Common Lisp (такие как пакеты(package) и обработка ошибок(error handling)) и [главу 25](chapter25.md), который представляет собой набор советов по устранению неполадок для озадаченного Лиспера.

В то время как для новичка может быть отвлекающим то, что он постоянно смотрит на какой - то справочный источник, альтернатива - объяснить каждую новую функцию в полном объеме, когда она вводится, - была бы еще более отвлекающей.
Это прервало бы описание программ искусственного интеллекта, о которых и идет речь в этой книге.

## 3.21 Упражнения

&#9635; **Упражнение 3.9 [m]** напишите версию `length`, используя функцию `reduce`.

&#9635; **Упражнение 3.10 [m]** используйте справочное руководство или `describe`, чтобы выяснить, что делают функции `lcm` и `nreconc`.

&#9635; **Упражнение 3.11** [m] существует встроенная функция Common Lisp, которая, учитывая ключ, значение и список ассоциаций, возвращает новый ассоциативный список, расширеный включенной парой ключ/значение.
Как называется эта функция?

&#9635; **Упражнение 3.12 [m]** напишите одно выражение, используя format, который возьмет список слов и напечатает их как предложение, с заглавной буквой первого слова и точкой после последнего слова.
Вам придется обратиться к справочнику, чтобы узнать новые директивы `format`.

## 3.22 Ответы

**Answer 3.2** `(cons` *a b*) = (`list *` *a b*)

**Answer 3.3**

```lisp
(defun dprint (x)
  "Print an expression in dotted pair notation."
  (cond ((atom x) (princ x))
        (t (princ "(")
           (dprint (first x))
           (pr-rest (rest x))
           (princ ")")
           x)))

(defun pr-rest (x)
  (princ " . ")
  (dprint x))
```

**Answer 3.4** Используйте ту же самую функцию `dprint`, определенную в последнем упражнении, но измените `pr-rest`.

```lisp
(defun pr-rest (x)
  (cond ((null x))
        ((atom x) (princ " . ") (princ x))
        (t (princ " ") (dprint (first x)) (pr-rest (rest x)))))
```

**Ответ 3.5** мы будем называть базу данных `*db*`.
База данных организована в виде древовидной структуры узлов.
Каждый узел имеет три поля: Имя объекта, который он представляет, узел, к которому нужно перейти, если ответ "да", и узел, когда ответ "нет".
Мы проходим через узлы, пока не получим ответ "it/это" или продолжать.
В последнем случае мы деструктивно модифицируем базу данных, чтобы она содержала новую информацию.

```lisp
(defstruct node
  name
  (yes nil)
  (no nil))

(defvar *db*
  (make-node :name 'animal
             :yes (make-node :name 'mammal)
             :no (make-node
                   :name 'vegetable
                   :no (make-node :name 'mineral))))

(defun questions (&optional (node *db*))
  (format t "~&Is it a ~a? " (node-name node))
  (case (read)
    ((y yes) (if (not (null (node-yes node)))
                 (questions (node-yes node))
                 (setf (node-yes node) (give-up))))
    ((n no)  (if (not (null (node-no node)))
                 (questions (node-no node))
                 (setf (node-no node) (give-up))))
    (it 'aha!)
    (t (format t "Reply with YES, NO, or IT if I have guessed it.")
       (questions node))))

(defun give-up ()
  (format t "~&I give up - what is it? ")
  (make-node :name (read)))
```

Здесь он используется:

```lisp
> (questions)
Is it a ANIMAL? yes
Is it a MAMMAL? yes
I give up - what is it? bear
#S(NODE :NAME BEAR)

> (questions)
Is it a ANIMAL? yes
Is it a MAMMAL? no
I give up - what is it? penguin
#S(NODE :NAME PENGUIN)

> (questions)
Is it a ANIMAL? yes
Is it a MAMMAL? yes
Is it a BEAR? it
AHA!
```

**Ответ 3.6** значение равно (`LOCAL-A LOCAL-B LOCAL-B GLOBAL-A LOCAL-B`).

Форма `let` связывает `a` лексически и `*b*` динамически, поэтому ссылки на `a` и `*b*` (включая ссылку на `*b*` внутри `fn`) все получают локальные значения.
Функция `symbol-value` всегда обрабатывает свой аргумент как специальную переменную, поэтому она игнорирует лексическую привязку для a и возвращает вместо нее глобальную привязку.
Однако `symbol-value` для  `*b*` является локальным динамическим значением.

**Ответ 3.7** есть две веские причины: Во-первых, это ускоряет поиск по списку аргументов: просто ищите, пока не найдете ключ, а не до конца.
Во-вторых, в случае, когда вы хотите переопределить существующее ключевое слово и передать список аргументов другой функции, дешевле создать/`cons` новую пару ключевое слово/значение в начале списка, чем добавлять ее в конец списка.

**Answer 3.9**

```lisp
(defun length-r (list)
  (reduce #'+ (mapcar #'(lambda (x) 1) list)))
```

или более эффективно:

```lisp
(defun length-r (list)
  (reduce #'(lambda (x y) (+ x 1)) list
          :initial-value 0))
```

или с ANSI-compliant Common Lisp, вы можете указать ключ `:key`

```lisp
(defun length-r (list)
  (reduce #'+ list :key #'(lambda (x) 1)))
```

**Answer 3.12** `(format t "~@(~{~a~^ ~).~)" '(this is a test))`

----------------------

<a id="fn03-1"></a>
[[1]](#tfn03-1) Списки ассоциаций рассматриваются в разделе 3.6.

<a id="fn03-2"></a>
[[2]](#tfn03-2) В математике функция должна связывать уникальное выходное значение с каждым входным значением.

<a id="fn03-3"></a>
[[3]](#tfn03-3) *package* - это таблица символов: отображение между строками и символами, которые они именуют.