#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter14.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-11 13:12+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter14.md:3
msgid ""
"# Chapter 14\n"
"## Knowledge Representation and Reasoning"
msgstr ""
"# Глава 14\n"
"## Представление знаний и рассуждения"

#: in/chapter14.md:5
msgid "> Knowledge itself is power."
msgstr "> Само знание - сила."

#: in/chapter14.md:7
msgid "> -Francis Bacon (1561-1626)"
msgstr ""

#: in/chapter14.md:9
msgid "> The power resides in the knowledge."
msgstr "> Сила заключается в знании."

#: in/chapter14.md:11
msgid "> -Edward Feigenbaum"
msgstr ""

#: in/chapter14.md:13
msgctxt "in/chapter14.md:13"
msgid "> Stanford University Heuristic Programming Project"
msgstr ""

#: in/chapter14.md:15
msgid "> Knowledge is Knowledge, and vice versa."
msgstr "> Знание есть Знание, и наоборот."

#: in/chapter14.md:17
msgid "> -Tee shirt"
msgstr ""

#: in/chapter14.md:19
msgctxt "in/chapter14.md:19"
msgid "> Stanford University Heuristic Programming Project"
msgstr ""

#: in/chapter14.md:23
msgid ""
"In the 1960s, much of AI concentrated on search techniques.\n"
"In particular, a lot of work was concerned with *theorem proving:* stating a "
"problem as a small set of axioms and searching for a proof of the problem.\n"
"The implicit assumption was that the power resided in the inference "
"mechanism-if we could just find the right search technique, then all our "
"problems would be solved, and all our theorems would be proved."
msgstr ""
"В 1960-х годах большая часть ИИ была сосредоточена на методах поиска.\n"
"В частности, много работы было связано с *доказательством теорем:* "
"формулированием проблемы в виде небольшого набора аксиом и поиском "
"доказательства проблем.\n"
"Неявное предположение заключалось в том, что сила заключена в механизме "
"вывода - если бы мы могли просто найти правильную технику поиска, тогда все "
"наши проблемы были бы решены, и все наши теоремы были бы доказаны."

#: in/chapter14.md:28
msgid ""
"Starting in the 1970s, this began to change.\n"
"The theorem-proving approach falled to live up to its promise.\n"
"AI workers slowly began to realize that they were not going to solve NP-hard "
"problems by coming up with a clever inference algorithm.\n"
"The general inferencing mechanisms that worked on toy examples just did not "
"scale up when the problem size went into the thousands (or sometimes even "
"into the dozens)."
msgstr ""
"Начиная с 1970-х годов это начало меняться.\n"
"Подход к доказательству теорем не оправдал своих ожиданий.\n"
"Работники ИИ постепенно начали понимать, что они не собираются решать NP-"
"сложные проблемы, изобретая умный алгоритм вывода.\n"
"Общие механизмы логического вывода, которые работали на игрушечных примерах, "
"просто не масштабировались, когда размер проблемы достигал тысяч (а иногда и "
"десятков)."

#: in/chapter14.md:35
msgid ""
"The *expert-system* approach offered an alternative.\n"
"The key to solving hard problems was seen to be the acquisition of special-"
"case rules to break the problem into easier problems.\n"
"According to Feigenbaum, the lesson learned from expert systems like MYCIN "
"(which we will see in [chapter 16](B9780080571157500169.xhtml)) is that the "
"choice of inferencing mechanism is not as important as having the right "
"knowledge.\n"
"In this view it doesn't matter very much if MYCIN uses forward- or backward-"
"chaining, or if it uses certainty factors, probabilities, or fuzzy set "
"theory.\n"
"What matters crucially is that we know pseudomonas is a gram-negative, rod-"
"shaped organism that can infect patients with compromised immune systems.\n"
"In other words, the key problem is acquiring and representing knowledge."
msgstr ""
"Альтернативой был подход *экспертной системы*.\n"
"Ключом к решению сложных проблем было усвоение особых правил, позволяющих "
"разбить проблему на более простые.\n"
"Согласно Фейгенбауму, урок, извлеченный из экспертных систем, таких как "
"MYCIN (который мы увидим в [главе 16] (B9780080571157500169.xhtml)), "
"заключается в том, что выбор механизма вывода не так важен, как наличие "
"правильных знаний.\n"
"С этой точки зрения не имеет большого значения, использует ли MYCIN прямую "
"или обратную цепочку, или использует ли он факторы достоверности, "
"вероятности или теорию нечетких множеств.\n"
"Важно то, что мы знаем, что псевдомонады - это грамотрицательные "
"палочковидные организмы, которые могут инфицировать пациентов с ослабленной "
"иммунной системой.\n"
"Другими словами, ключевая проблема - получение и представление знаний."

#: in/chapter14.md:42
msgid ""
"While the expert system approach had some successes, it also had fallures, "
"and researchers were interested in learning the limits of this new "
"technology and understanding exactly how it works.\n"
"Many found it troublesome that the meaning of the knowledge used in some "
"systems was never clearly defined.\n"
"For example, does the assertion `(color apple red)` mean that a particular "
"apple is red, that all apples are red, or that some/most apples are red?\n"
"The field of *knowledge representation* concentrated on providing clear "
"semantics for such representations, as well as providing algorithms for "
"manipulating the knowledge.\n"
"Much of the emphasis was on finding a good trade-off between "
"*expressiveness* and *efficiency.* An efficient language is one for which "
"all queries (or at least the average query) can be answered quickly.\n"
"If we want to guarantee that queries will be answered quickly, then we have "
"to limit what can be expressed in the language."
msgstr ""
"Хотя подход экспертной системы имел некоторые успехи, он также имел "
"недостатки, и исследователи были заинтересованы в изучении ограничений этой "
"новой технологии и понимании того, как именно она работает.\n"
"Многих беспокоило то, что значение знаний, используемых в некоторых "
"системах, никогда не было четко определено.\n"
"Например, означает ли утверждение `(color apple red)`-цвет яблока красный, "
"что конкретное яблоко красное, все яблоки красные или что некоторые/"
"большинство яблок красные?\n"
"Область *представления знаний* сосредоточена на обеспечении четкой семантики "
"для таких представлений, а также предоставлении алгоритмов для "
"манипулирования знаниями.\n"
"Большое внимание уделялось поиску компромисса между *выразительностью* и "
"*эффективностью*. Эффективный язык - это такой язык, для которого можно "
"быстро ответить на все запросы (или, по крайней мере, на средний запрос).\n"
"Если мы хотим гарантировать быстрое получение ответов на запросы, мы должны "
"ограничить то, что может быть выражено на языке."

#: in/chapter14.md:45
msgid ""
"In the late 1980s, a series of results shed doubt on the hopes of finding an "
"efficient language with any reasonable degree of expressiveness at all.\n"
"Using mathematical techniques based on worst-case analysis, it was shown "
"that even seemingly trivial languages were *intractable-*in the worst case, "
"it would take an exponential amount of time to answer a simple query."
msgstr ""
"В конце 1980-х годов ряд результатов поставил под сомнение надежды найти "
"эффективный язык с хоть сколько-нибудь разумной степенью выразительности.\n"
"Используя математические методы, основанные на анализе наихудшего случая, "
"было показано, что даже кажущиеся тривиальными языки были "
"*трудноразрешимыми* -  в худшем случае требовалось экспоненциальное "
"количество времени, чтобы ответить на простой запрос. "

#: in/chapter14.md:48
msgid ""
"Thus, in the 1990s the emphasis has shifted to *knowledge representation and "
"reasoning,* a field that encompasses both the expressiveness and efficiency "
"of languages but recognizes that the average case is more important than the "
"worst case.\n"
"No amount of knowledge can help solve an intractable problem in the worse "
"case, but in practice the worst case rarely occurs."
msgstr ""
"Таким образом, в 1990-х годах акцент сместился на *представление знаний и "
"рассуждения*, область, которая охватывает как выразительность, так и "
"эффективность языков, но признает, что средний случай более важен, чем "
"наихудший случай.\n"
"Никакие знания не помогут решить неразрешимую проблему в худшем случае, но "
"на практике худший случай случается редко. "

#: in/chapter14.md:50
msgid "## 14.1 A Taxonomy of Representation Languages"
msgstr "## 14.1 A Таксономия языков представления"

#: in/chapter14.md:54
msgid ""
"AI researchers have investigated hundreds of knowledge representation "
"languages, trying to find languages that are convenient, expressive, and "
"efficient.\n"
"The languages can be classified into four groups, depending on what the "
"basic unit of representation is.\n"
"Here are the four categories, with some examples:"
msgstr ""
"Исследователи искусственного интеллекта исследовали сотни языков "
"представления знаний, пытаясь найти удобные, выразительные и эффективные "
"языки.\n"
"Языки можно разделить на четыре группы, в зависимости от того, какова "
"основная единица представления.\n"
"Вот четыре категории с некоторыми примерами:"

#: in/chapter14.md:56
msgid "*   *Logical Formulae* (Prolog)"
msgstr "*   *Логические формулы* (Prolog)"

#: in/chapter14.md:58
msgid "*   *Networks* (semantic nets, conceptual graphs)"
msgstr "*   *Сети* (семантические сети, концептуальные графы)"

#: in/chapter14.md:60
msgid "*   *Objects* (scripts, frames)"
msgstr "*   *Объекты* (скрипты, фреймы)"

#: in/chapter14.md:62
msgid "*   *Procedures* (Lisp, production systems)"
msgstr "*   *Процедуры* (Лисп, производственные системы)"

#: in/chapter14.md:64
msgid "We have already dealt with *logic-based* languages like Prolog."
msgstr "Мы уже имели дело с *логическими* языками, такими как Prolog."

#: in/chapter14.md:68
msgid ""
"*Network-based* languages can be seen as a syntactic variation on logical "
"languages.\n"
"A link *L* between nodes *A* and *B* is just another way of expressing the "
"logical relation *L(A, B).* The difference is that network-based languages "
"take their links more seriously: they are intended to be implemented "
"directly by pointers in the computer, and inference is done by traversing "
"these pointers.\n"
"So placing a link *L* between *A* and *B* not only asserts that *L(A, B)* is "
"true, but it also says something about how the knowledge base is to be "
"searched."
msgstr ""
"*Сетевые* языки можно рассматривать как синтаксическую вариацию логических "
"языков.\n"
"Связь *L* между узлами *A* и *B* - это просто еще один способ выражения "
"логической связи *L(A, B).* Разница в том, что сетевые языки относятся к "
"своим ссылкам более серьезно: они предназначены для возможности быть "
"реализованы непосредственно с помощью указателей в компьютере, а вывод "
"выполняется путем обхода этих указателей.\n"
"Таким образом, размещение ссылки *L* между *A* и *B* не только утверждает, "
"что *L(A, B)* истинно, но также говорит кое-что о том, как следует искать в "
"базе знаний."

#: in/chapter14.md:71
msgid ""
"*Object-oriented* languages can also be seen as syntactic variants of "
"predicate calculus.\n"
"Here is a statement in a typical slot-filler frame language:"
msgstr ""
"*Объектно-ориентированные* языки также можно рассматривать как "
"синтаксические варианты исчисления предикатов.\n"
"Вот утверждение на типичном языке фреймов для заполнения слотов:"

#: in/chapter14.md:77
msgid ""
"```lisp\n"
"(a person\n"
"  (name = Jan)\n"
"  (age = 32))\n"
"```"
msgstr ""

#: in/chapter14.md:79
msgid "This is equivalent to the logical formula:"
msgstr "Это эквивалентно логической формуле:"

#: in/chapter14.md:81
msgid "&exist;p: person(p) &and; name(p,Jan) &and; age(p,32)"
msgstr ""

#: in/chapter14.md:86
msgid ""
"The frame notation has the advantage of being easier to read, in some "
"people's opinion.\n"
"However, the frame notation is less expressive.\n"
"There is no way to say that the person's name is either Jan or John, or that "
"the person's age is not 34.\n"
"In predicate calculus, of course, such statements can be easily made."
msgstr ""
"Фреймовое обозначение имеет то преимущество, что, по мнению некоторых, его "
"легче читать.\n"
"Однако фреймовое обозначение менее выразительно.\n"
"Невозможно сказать, что человека зовут Ян или Джон, или что ему не 34 года.\n"
"Конечно, в исчислении предикатов такие утверждения можно легко сделать."

#: in/chapter14.md:88
msgid ""
"Finally, *procedural* languages are to be contrasted with representation "
"languages: procedural languages compute answers without explicit "
"representation of knowledge."
msgstr ""
"Наконец, *процедурные* языки должны быть противопоставлены языкам "
"представления: процедурные языки вычисляют ответы без явного представления "
"знаний."

#: in/chapter14.md:92
msgid ""
"There are also hybrid representation languages that use different methods to "
"encode different kinds of knowledge.\n"
"The KL-ONE family of languages uses both logical formulae and objects "
"arranged into a network, for example.\n"
"Many frame languages allow *procedural attachment,* a technique that uses "
"arbitrary procedures to compute values for expressions that are inconvenient "
"or impossible to express in the frame language itself."
msgstr ""
"Существуют также гибридные языки представления, которые используют разные "
"методы для кодирования разных видов знаний.\n"
"В семействе языков KL-ONE используются, например, как логические формулы, "
"так и объекты, объединенные в сеть.\n"
"Многие фреймовые языки допускают *процедурное присоединение* - метод, "
"который использует произвольные процедуры для вычисления значений для "
"выражений, которые неудобно или невозможно выразить на самом языке фреймов."

#: in/chapter14.md:94
msgid "## 14.2 Predicate Calculus and its Problems"
msgstr "## 14.2 Исчисление предикатов и его проблемы"

#: in/chapter14.md:100
msgid ""
"So far, many of our representations have been based on predicate calculus, a "
"notation with a distinguished position in AI: it serves as the universal "
"standard by which other representations are defined and evaluated.\n"
"The previous section gave an example expression from a frame language.\n"
"The frame language may have many merits in terms of the ease of use of its "
"syntax or the efficiency of its internal representation of data.\n"
"However, to understand what expressions in the language mean, there must be "
"a clear definition.\n"
"More often than not, that definition is given in terms of predicate calculus."
msgstr ""
"До сих пор многие из наших представлений были основаны на исчислении "
"предикатов, системе обозначений, занимающей особое место в ИИ: она служит "
"универсальным стандартом, по которому определяются и вычисляются другие "
"представления.\n"
"В предыдущем разделе был приведен пример выражения из фреймового языка.\n"
"Язык фреймов может иметь много достоинств с точки зрения простоты "
"использования синтаксиса или эффективности внутреннего представления "
"данных.\n"
"Однако, чтобы понять, что означают выражения в языке, должно быть четкое "
"определение.\n"
"Чаще всего это определение дается в терминах исчисления предикатов. "

#: in/chapter14.md:104
msgid ""
"A predicate calculus representation assumes a universe of individuals, with "
"relations and functions on those individuals, and sentences formed by "
"combining relations with the logical connectives `and`, `or`, and `not`.\n"
"Philosophers and psychologists will argue the question of how appropriate "
"predicate calculus is as a model of human thought, but one point stands "
"clear: predicate calculus is sufficient to represent anything that can be "
"represented in a digital computer.\n"
"This is easy to show: assuming the computer's memory has *n* bits, and the "
"equation *bi* = 1 means that bit *i* is on, then the entire state of the "
"computer is represented by a conjunction such as:"
msgstr ""
"Представление исчисления предикатов предполагает универсум индивидов с "
"отношениями и функциями этих индивидов, а также предложения, сформированные "
"путем комбинирования отношений с логическими связками `and`(и), `or`(или) и "
"`not`(не).\n"
"Философы и психологи будут спорить о том, насколько уместно исчисление "
"предикатов в качестве модели человеческого мышления, но одно ясно: "
"исчисления предикатов достаточно, чтобы представить все, что может быть "
"представлено в цифровом компьютере.\n"
"Это легко показать: если в памяти компьютера есть *n* битов, а уравнение "
"*bi* = 1 означает, что бит *i* включен(on), тогда все состояние компьютера "
"представимо конъюнкцией, например:"

#: in/chapter14.md:106
msgid "b0=0&and;b1=0&and;b2=1...&and;bn=0"
msgstr ""

#: in/chapter14.md:108
msgid "![si1_e](images/chapter14/si1_e.gif)"
msgstr ""

#: in/chapter14.md:111
msgid ""
"Once we can represent a state of the computer, it becomes possible to "
"represent any computer program in predicate calculus as a set of axioms that "
"map one state onto another.\n"
"Thus, predicate calculus is shown to be a *sufficient* language for "
"representing anything that goes on inside a computer-it can be used as a "
"tool for analyzing any program from the outside."
msgstr ""
"Как только мы можем представить состояние компьютера, становится возможным "
"представить любую компьютерную программу в исчислении предикатов как набор "
"аксиом, отображающих одно состояние на другое.\n"
"Таким образом, показано, что исчисление предикатов является *достаточным* "
"языком для представления всего, что происходит внутри компьютера - его можно "
"использовать как инструмент для анализа любой программы извне."

#: in/chapter14.md:117
msgid ""
"This does not prove that predicate calculus is an *appropriate* tool for all "
"applications.\n"
"There are good reasons why we may want to represent knowledge in a form that "
"is quite different from predicate calculus, and manipulate the knowledge "
"with procedures that are quite different from logical inference.\n"
"But we should still be able to describe our system in terms of predicate "
"calculus axioms, and prove theorems about it.\n"
"To do any less is to be sloppy.\n"
"For example, we may want to manipulate numbers inside the computer by using "
"the arithmetic instructions that are built into the CPU rather than by "
"manipulating predicate calculus axioms, but when we write a square-root "
"routine, it had better satisfy the axiom:"
msgstr ""
"Это не доказывает, что исчисление предикатов является *подходящим* "
"инструментом для всех приложений.\n"
"Есть веские причины, по которым мы можем захотеть представить знания в "
"форме, которая сильно отличается от исчисления предикатов, и манипулировать "
"знаниями с помощью процедур, которые сильно отличаются от логического "
"вывода.\n"
"Но мы по-прежнему должны суметь описать нашу систему в терминах аксиом "
"исчисления предикатов и доказать теоремы о ней.\n"
"Делать меньше - значит быть небрежным.\n"
"Например, мы можем захотеть манипулировать числами внутри компьютера, "
"используя арифметические инструкции, встроенные в ЦП, а не манипулируя "
"аксиомами исчисления предикатов, но когда мы пишем процедуру извлечения "
"квадратного корня, она лучше удовлетворяет аксиоме:"

#: in/chapter14.md:119
msgid "x=y=>yxy=x"
msgstr ""

#: in/chapter14.md:121
msgid "![si2_e](images/chapter14/si2_e.gif)"
msgstr ""

#: in/chapter14.md:125
msgid ""
"Predicate calculus also serves another purpose: as a tool that can be used "
"*by* a program rather than *on* a program.\n"
"All programs need to manipulate data, and some programs will manipulate data "
"that is considered to be in predicate calculus notation.\n"
"It is this use that we will be concerned with."
msgstr ""
"Исчисление предикатов также служит другой цели: как инструмент, который "
"может использоваться программой, а не *в* программе.\n"
"Все программы должны манипулировать данными, а некоторые программы будут "
"манипулировать данными, которые, как считается, находятся в нотации "
"исчисления предикатов.\n"
"Именно этим использованием мы и займемся."

#: in/chapter14.md:128
msgid ""
"Predicate calculus makes it easy to start writing down facts about a "
"domain.\n"
"But the most straightforward version of predicate calculus suffers from a "
"number of serious limitations:"
msgstr ""
"Исчисление предикатов позволяет легко начать записывать факты о предметной "
"области.\n"
"Но самая простая версия исчисления предикатов страдает рядом серьезных "
"ограничений:"

#: in/chapter14.md:130
msgid ""
"*   *Decidability-*given a set of axioms and a goal, it may be that neither "
"the goal nor its negation can be derived from the axioms."
msgstr ""
"*   *Разрешимость* -  с учетом набора аксиом и цели может оказаться, что ни "
"цель, ни ее отрицание не могут быть выведены из аксиом."

#: in/chapter14.md:132
msgid ""
"*   *Tractability-even* when a goal is provable, it may take too long to "
"find the proof using the available inferencing mechanisms."
msgstr ""
"*   *Последовательность* - даже если цель доказуема, поиск доказательства с "
"использованием доступных механизмов вывода может занять слишком много "
"времени."

#: in/chapter14.md:134
msgid ""
"*   *Uncertainty-*it can be inconvenient to deal with relations that are "
"probable to a degree but not known to be definitely true or false."
msgstr ""
"*   *Неопределенность* - может быть неудобно иметь дело с отношениями, "
"которые в определенной степени вероятны, но не известны как однозначно "
"истинные или ложные."

#: in/chapter14.md:137
msgid ""
"*   *Monotonicity-*in pure predicate calculus, once a theorem is proved, it "
"is true forever.\n"
"But we would like a way to derive tentative theorems that rely on "
"assumptions, and be able to retract them when the assumptions prove false."
msgstr ""
"*   *Монотонность* - в чистом исчислении предикатов, как только теорема "
"доказана, она верна навсегда.\n"
"Но мы хотели бы получить способ вывести предварительные теоремы, основанные "
"на предположениях, и иметь возможность отказаться от них, когда "
"предположения оказываются ложными."

#: in/chapter14.md:141
msgid ""
"*   *Consistency-*pure predicate calculus admits no contradictions.\n"
"If by accident both *P* and &not;*P* are derived, then *any* theorem can be "
"proved.\n"
"In effect, a single contradiction corrupts the entire data base."
msgstr ""
"*   *Непротиворечивость* - чистое исчисление предикатов не допускает "
"противоречий.\n"
"Если случайно выведены и *P*, и &not; *P*, то может быть доказана *любая* "
"теорема.\n"
"Фактически, одно противоречие портит всю базу данных."

#: in/chapter14.md:144
msgid ""
"*   *Omniscience-*it can be difficult to distinguish what is provable from "
"what should be proved.\n"
"This can lead to the unfounded assumption that an agent believes all the "
"consequences of the facts it knows."
msgstr ""
"*   *Всеведение* -  бывает трудно отличить доказуемое от того, что следует "
"доказать.\n"
"Это может привести к необоснованному предположению, что агент верит во все "
"последствия известных ему фактов."

#: in/chapter14.md:146
msgid ""
"*   *Expressiveness-*the first-order predicate calculus makes it awkward to "
"talk about certain things, such as the relations and propositions of the "
"language itself."
msgstr ""
"*   *Выразительность* -  исчисление предикатов первого порядка затрудняет "
"разговоры о некоторых вещах, таких как отношения и предложения самого языка."

#: in/chapter14.md:151
msgid ""
"The view held predominantly today is that it is best to approach these "
"problems with a dual attack that is both within and outside of predicate "
"calculus.\n"
"It is considered a good idea to invent new notations to address the problems-"
"both for convenience and to facilitate special-purpose reasoners that are "
"more efficient than a general-purpose theorem prover.\n"
"However, it is also important to define scrupulously the meaning of the new "
"notation in terms of familiar predicate-calculus notation.\n"
"As Drew McDermott put it, \"No notation without denotation!\" (1978)."
msgstr ""
"Сегодня преобладает мнение, что лучше всего решать эти проблемы с помощью "
"двойной атаки, которая находится как внутри, так и вне исчисления "
"предикатов.\n"
"Считается хорошей идеей изобрести новые обозначения для решения проблем - "
"как для удобства, так и для облегчения работы специалистов по рассуждению, "
"которые более эффективны, чем средство доказательства теорем общего "
"назначения.\n"
"Однако также важно скрупулезно определить значение новой нотации в терминах "
"знакомой нотации исчисления предикатов.\n"
"Как выразился Дрю Макдермотт: \"Никаких обозначений без обозначений!\"(No "
"notation without denotation!) (1978)."

#: in/chapter14.md:156
msgid ""
"In this chapter we show how new notations (and their corresponding meanings) "
"can be used to extend an existing representation and reasoning system.\n"
"Prolog is chosen as the language to extend.\n"
"This is not meant as an endorsement for Prolog as the ultimate knowledge "
"representation language.\n"
"Rather, it is meant solely to give us a clear and familiar foundation from "
"which to build."
msgstr ""
"В этой главе мы покажем, как новые обозначения (и их соответствующие "
"значения) могут быть использованы для расширения существующей системы "
"представлений и рассуждений.\n"
"В качестве языка для расширения выбран Пролог.\n"
"Это не означает одобрения Пролога как языка окончательного представления "
"знаний.\n"
"Скорее, он предназначен исключительно для того, чтобы дать нам ясную и "
"знакомую основу для построения."

#: in/chapter14.md:158
msgid "## 14.3 A Logical Language: Prolog"
msgstr "## 14.3 Логический язык: пролог"

#: in/chapter14.md:164
msgid ""
"Prolog has been proposed as the answer to the problem of programming in "
"logic.\n"
"Why isn't it accepted as the universal representation language?\n"
"Probably because Prolog is a compromise between a representation language "
"and a programming language.\n"
"Given two specifications that are logically equivalent, one can be an "
"efficient Prolog program, while the other is not.\n"
"Kowalski's famous equation \"*algorithm = logic + control\"* expresses the "
"limits of logic alone: *logic = algorithm - control.* Many problems "
"(especially in AI) have large or infinite search spaces, and if Prolog is "
"not given some advice on how to search that space, it will not come up with "
"the answer in any reasonable length of time."
msgstr ""
"Пролог был предложен как ответ на проблему программирования в логике.\n"
"Почему он не принят в качестве универсального языка представления?\n"
"Вероятно потому, что Пролог - это компромисс между языком представления и "
"языком программирования.\n"
"При наличии двух логически эквивалентных спецификаций одна может быть "
"эффективной программой на Прологе, а другая - нет.\n"
"Знаменитое уравнение Ковальского \"*algorithm = logic + control\"* (алгоритм "
"= логика + управление) выражает пределы одной только логики: *логика = "
"алгоритм - управление.* Многие задачи (особенно в ИИ) имеют большие или "
"бесконечные пространства поиска, и если Прологу не дается какой-либо совет "
"по как найти это место, ответ не найдется за разумный промежуток времени."

#: in/chapter14.md:172
msgid ""
"Prolog's problems fall into three classes.\n"
"First, in order to make the language efficient, its expressiveness was "
"restricted.\n"
"It is not possible to assert that a person's name is either Jan or John in "
"Prolog (although it is possible to *ask* if the person's name is one of "
"those).\n"
"Similarly, it is not possible to assert that a fact is false; Prolog does "
"not distinguish between false and unknown.\n"
"Second, Prolog's inference mechanism is neither sound nor complete.\n"
"Because it does not check for circular unification, it can give incorrect "
"answers, and because it searches depth-first it can miss correct answers.\n"
"Third, Prolog has no good way of adding control information to the "
"underlying logic, making it inefficient on certain problems."
msgstr ""
"Проблемы Пролога делятся на три класса.\n"
"Во-первых, чтобы сделать язык эффективным, его выразительность была "
"ограничена.\n"
"Невозможно утверждать, что человека зовут Ян или Джон в Прологе (хотя можно "
"*спросить*, является ли имя человека одним из таких).\n"
"Точно так же нельзя утверждать, что факт ложен; Пролог не делает различий "
"между ложным и неизвестным.\n"
"Во-вторых, механизм вывода Пролога не является ни надежным, ни полным.\n"
"Поскольку он не проверяет круговую унификацию, он может давать неправильные "
"ответы, а поскольку он ищет в глубину, он может пропустить правильные "
"ответы.\n"
"В-третьих, в Prolog нет хорошего способа добавления управляющей информации к "
"базовой логике, что делает его неэффективным для решения определенных "
"проблем."

#: in/chapter14.md:174
msgid "## 14.4 Problems with Prolog's Expressiveness"
msgstr "## 14.4 Проблемы с выразительностью Пролога"

#: in/chapter14.md:181
msgid ""
"If Prolog is programming in logic, it is not the full predicate logic we are "
"familiar with.\n"
"The main problem is that Prolog can't express certain kinds of indefinite "
"facts.\n"
"It can represent definite facts: the capital of Rhode Island is Providence.\n"
"It can represent conjunctions of facts: the capital of Rhode Island is "
"Providence and the capital of California is Sacramento.\n"
"But it can not represent disjunctions or negations: that the capital of "
"California is *not* Los Angeles, or that the capital of New York is *either* "
"New York City *or* Albany.\n"
"We could try this:"
msgstr ""
"Если Пролог занимается логическим программированием, это не полная знакомая "
"нам логика предикатов.\n"
"Основная проблема заключается в том, что Пролог не может выражать "
"определенные виды неопределенных фактов.\n"
"Он может отражать определенные факты: столица Род-Айленда - Провиденс.\n"
"Он может представлять собой соединение(conjunctions) фактов: столица Род-"
"Айленда - Провиденс, и столица Калифорнии - Сакраменто.\n"
"Но он не может представлять собой разобщение(disjunctions) или "
"отрицание(negations): что столица Калифорнии *не* Лос-Анджелес или что "
"столица Нью-Йорка *либо* Нью-Йорк, *либо* Олбани.\n"
"Мы могли бы попробовать это:"

#: in/chapter14.md:186
msgid ""
"```lisp\n"
"(<- (not (capital LA CA)))\n"
"(<- (or (capital Albany NY) (capital NYC NY)))\n"
"```"
msgstr ""

#: in/chapter14.md:190
msgid ""
"but note that these last two facts concern the relation `not` and `or`, not "
"the relation `capital`.\n"
"Thus, they will not be considered when we ask a query about `capital`.\n"
"Fortunately, the assertion \"Either NYC or Albany is the capital of NY\" can "
"be rephrased as two assertions: \"Albany is the capital of NY if NYC is not"
"\" and \"NYC is the capital of NY if Albany is not:\""
msgstr ""
"но заметьте, что эти последние два факта касаются отношения `не`(not) и "
"`или`(or), а не отношения `capital`(столица).\n"
"Таким образом, они не будут рассматриваться, когда мы зададим вопрос о "
"`столице`(capital).\n"
"К счастью, утверждение \"Either NYC or Albany is the capital of NY\"(Либо "
"Нью-Йорк, либо Олбани является столицей штата Нью-Йорк) можно "
"перефразировать как два утверждения: \"Albany is the capital of NY if NYC is "
"not\"(Олбани является столицей Нью-Йорка, если Нью-Йорк не является) и \"NYC "
"is the capital of NY if Albany is not:\"(Нью-Йорк является столицей Нью-"
"Йорка, если Олбани не является):"

#: in/chapter14.md:195
msgid ""
"```lisp\n"
"(<- (capital Albany NY) (not (capital NYC NY)))\n"
"(<- (capital NYC NY) (not (capital Albany NY)))\n"
"```"
msgstr ""

#: in/chapter14.md:204
msgid ""
"Unfortunately, Prolog's not is different from logic's `not`.\n"
"When Prolog answers \"no\" to a query, it means the query cannot be proven "
"from the known facts.\n"
"If everything is known, then the query must be false, but if there are facts "
"that are not known, the query may in fact be true.\n"
"This is hardly surprising; we can't expect a program to come up with answers "
"using knowledge it doesn't have.\n"
"But in this case, it causes problems.\n"
"Given the previous two clauses and the query `(capital ?c NY)`, Prolog will "
"go into an infinite loop.\n"
"If we remove the first clause, Prolog would fall to prove that Albany is the "
"capital, and hence conclude that NYC is.\n"
"If we remove the second clause, the opposite conclusion would be drawn."
msgstr ""
"К сожалению, не(not) Пролог отличается от логического `не`(not).\n"
"Когда Prolog отвечает \"no\" на запрос, это означает, что запрос не может "
"быть доказан на основе известных фактов.\n"
"Если все известно, то запрос должен быть ложным, но если есть факты, которые "
"неизвестны, запрос действительно может быть истинным.\n"
"В этом нет ничего удивительного; мы не можем ожидать, что программа "
"предложит ответы, используя знания, которых у неё нет.\n"
"Но в этом случае возникают проблемы.\n"
"Учитывая предыдущие два предложения и запрос `(capital ?c NY)`, Prolog "
"перейдет в бесконечный цикл.\n"
"Если мы удалим первое предложение, Пролог потерпит неудачу, при "
"доказательстве, что Олбани является столицей, и, следовательно, придет к "
"выводу, что это Нью-Йорк.\n"
"Если убрать второй пункт, будет сделан противоположный вывод."

#: in/chapter14.md:208
msgid ""
"The problem is that Prolog equates \"not proven\" with \"false.\" Prolog "
"makes what is called the *closed world assumption*-it assumes that it knows "
"everything that is true.\n"
"The closed world assumption is reasonable for most programs, because the "
"programmer does know all the relevant information.\n"
"But for knowledge representation in general, we would like a system that "
"does not make the closed world assumption and has three ways to answer a "
"query: \"yes,\" \"no,\" or \"unknown.\" In this example, we would not be "
"able to conclude that the capital of NY is or is not NYC, hence we would not "
"be able to conclude anything about Albany."
msgstr ""
"Проблема в том, что Пролог приравнивает \"не доказано\" к \"ложному\". "
"Пролог делает то, что называется *предположением о закрытом мире* - он "
"предполагает, что знает все, что истинно.\n"
"Предположение о закрытом мире является разумным для большинства программ, "
"потому что программист знает всю необходимую информацию.\n"
"Но для представления знаний в целом нам нужна система, которая не делает "
"предположение о замкнутом мире и имеет три способа ответить на запрос: \"да"
"\"(yes), \"нет\"(no) или \"неизвестно\"(unknown). В этом примере мы не "
"сможем сделать вывод о том, что столица Нью-Йорка является или не является "
"Нью-Йорком, поэтому мы не сможем сделать никаких выводов об Олбани."

#: in/chapter14.md:210
msgid "As another example, consider the clauses:"
msgstr "В качестве другого примера рассмотрим предложения:"

#: in/chapter14.md:215
msgid ""
"```lisp\n"
"(<- (damned) (do))\n"
"(<- (damned) (not (do)))\n"
"```"
msgstr ""

#: in/chapter14.md:225
msgid ""
"With these rules, the query `(?\n"
"(damned))` should logically be answered \"yes.\" Furthermore, it should be "
"possible to conclude `(damned)` without even investigating if `(do)` is "
"provable or not.\n"
"What Prolog does is first try to prove `(do)`.\n"
"If this succeeds, then `(damned)` is proved.\n"
"Either way, Prolog then tries again to prove `(do)`, and this time if the "
"proof falls, then `(damned)` is proved.\n"
"So Prolog is doing the same proof twice, when it is unnecessary to do the "
"proof at all.\n"
"Introducing negation wrecks havoc on the simple Prolog evaluation scheme.\n"
"It is no longer sufficient to consider a single clause at a time.\n"
"Rather, multiple clauses must be considered together if we want to derive "
"all the right answers."
msgstr ""
"С этими правилами запрос `(? (damned))` следует логически ответить \"yes"
"\"(да). \n"
"Более того, должна быть возможность сделать вывод `(damned)`(проклятый) даже "
"без расследования, доказуемо ли `(do)`.\n"
"Пролог сначала пытается доказать `(do)`(делать).\n"
"Если это удается, то `(damned)` доказано.\n"
"В любом случае, Prolog затем снова пытается доказать `(do)`, и на этот раз, "
"если доказательство не удастся, то `(damned)` доказано.\n"
"Таким образом, Prolog выполняет одно и то же доказательство дважды, когда в "
"этом нет необходимости.\n"
"Введение отрицания разрушает простую схему вычисления Пролога.\n"
"Теперь уже недостаточно рассматривать по одному предложению за раз.\n"
"Скорее, несколько предложений должны рассматриваться вместе, если мы хотим "
"получить все правильные ответы."

#: in/chapter14.md:230
msgid ""
"Robert [Moore 1982](B9780080571157500285.xhtml#bb0865) gives a good example "
"of the power of disjunctive reasoning.\n"
"His problem concerned three colored blocks, but we will update it to deal "
"with three countries.\n"
"Suppose that a certain Eastern European country, *E*, has just decided if it "
"will remain under communist rule or become a democracy, but we do not know "
"the outcome of the decision.\n"
"*E* is situated between the democracy *D* and the communist country *C*:"
msgstr ""
"Роберт [Мур, 1982] (B9780080571157500285.xhtml#bb0865) дает хороший пример "
"силы дизъюнктивного мышления.\n"
"Его проблема касалась трех цветных блоков, но мы обновим ее для трех стран.\n"
"Предположим, что некая восточноевропейская страна *E* только что решила, "
"останется ли она под коммунистическим правлением или станет демократией, но "
"мы не знаем результата этого решения.\n"
"*E* находится между демократией *D* и коммунистической страной *C*:"

#: in/chapter14.md:232
msgid "![u14-02](images/chapter14/u14-02.jpg)"
msgstr ""

#: in/chapter14.md:240
msgid ""
"The question is: Is there a communist country next to a democracy?\n"
"Moore points out that the answer is \"yes,\" but discovering this requires "
"reasoning by cases.\n"
"If *E* is a democracy then it is next to *C* and the answer is yes.\n"
"But if *E* is communist then it is next to *D* and the answer is still yes.\n"
"Since those are the only two possibilities, the answer must be yes in any "
"case.\n"
"Logical reasoning gives us the right answer, but Prolog can not.\n"
"We can describe the problem with the following seven assertions and one "
"query, but Prolog can not deal with the or in the final assertion."
msgstr ""
"Возникает вопрос: есть ли коммунистическая страна рядом с демократией?\n"
"Мур отмечает, что ответ - \"да\", но для того, чтобы это обнаружить, "
"необходимо рассуждать по конкретным случаям.\n"
"Если *E* - демократия, то это рядом с *C*, и ответ - да.\n"
"Но если *E* коммунистическая, то она стоит рядом с *D*, и ответ все равно "
"положительный.\n"
"Поскольку это единственные две возможности, в любом случае ответ должен быть "
"положительным.\n"
"Логические рассуждения дают нам правильный ответ, а Пролог - нет.\n"
"Мы можем описать проблему с помощью следующих семи утверждений и одного "
"запроса, но Пролог не может иметь дело с или в окончательном утверждении."

#: in/chapter14.md:248
msgid ""
"```lisp\n"
"(<- (next-to D E))    (<- (next-to E D))\n"
"(<- (next-to E C))    (<- (next-to C E))\n"
"(<- (democracy D))    (<- (communist C))\n"
"(<- (or (democracy E)  (communist E)))\n"
"(?- (next-to ?A ?B) (democracy ?A) (communist ?B))\n"
"```"
msgstr ""

#: in/chapter14.md:252
msgid ""
"We have seen that Prolog is not very good at representing disjunctions and "
"negations.\n"
"It also has difficulty representing existentials.\n"
"Consider the following statement in English, logic, and Prolog:"
msgstr ""
"Мы увидели, что Пролог не очень хорош для представления дизъюнкций и "
"отрицаний.\n"
"Ему также трудно представить экзистенциальные элементы.\n"
"Рассмотрим следующее утверждение на английском языке, logic и Prolog:"

#: in/chapter14.md:254
msgid "Jan likes everyone."
msgstr "Jan likes everyone.(Яну все нравятся)."

#: in/chapter14.md:256
msgid "&forall; *x* person(*x*) => likes(Jan,*x*)"
msgstr ""

#: in/chapter14.md:260
msgid ""
"```lisp\n"
"(<- (likes Jan ?x) (person ?x))\n"
"```"
msgstr ""

#: in/chapter14.md:263
msgid ""
"The Prolog translation is faithful.\n"
"But there is no good translation for \"Jan likes someone.\" The closest we "
"can get is:"
msgstr ""
"Перевод Пролога точен.\n"
"Но нет хорошего перевода для фразы \"Jan likes someone\"(Ян любит кого-то). "
"Ближайшее, что мы можем получить:"

#: in/chapter14.md:265
msgid "Jan likes someone."
msgstr "Jan likes someone.(Ян любит кого-то)"

#: in/chapter14.md:267
msgid "&exist; *x* person(x) => likes(Jan,x)"
msgstr ""

#: in/chapter14.md:272
msgid ""
"```lisp\n"
"(<- (likes Jan pl))\n"
"(<- (person pl))\n"
"```"
msgstr ""

#: in/chapter14.md:279
msgid ""
"Here we have invented a new symbol, `p1`, to represent the unknown person "
"that Jan likes, and have asserted that `p1` is a person.\n"
"Notice that `p1` is a constant, not a variable.\n"
"This use of a constant to represent a specific but unknown entity is called "
"a *Skolem constant,* after the logician Thoralf Skolem (1887-1963).\n"
"The intent is that `p1` may be equal to some other person that we know "
"about.\n"
"If we find out that Adrian is the person Jan likes, then in logic we can "
"just add the assertion p1 = Adrian.\n"
"But that does not work in Prolog, because Prolog implicitly uses the *unique "
"name assumption-*all atoms represent distinct individuals."
msgstr ""
"Здесь мы изобрели новый символ `p1`, чтобы представить неизвестного "
"человека, который нравится Яну, и заявили, что `p1` - это человек.\n"
"Обратите внимание, что `p1` - это константа, а не переменная.\n"
"Такое использование константы для представления определенной, но неизвестной "
"сущности называется *константой Сколема* в честь логика Торальфа Сколема "
"(1887-1963).\n"
"Смысл в том, что `p1` может быть равно какому-то(любому) другому человеку, о "
"котором мы знаем.\n"
"Если мы выясним, что Адриан - это человек, который нравится Яну, то по "
"логике мы можем просто добавить утверждение p1 = Adrian.\n"
"Но это не работает в Prolog, потому что Prolog неявно использует "
"*предположение об уникальности имени* -  все атомы представляют отдельных "
"людей."

#: in/chapter14.md:282
msgid ""
"A Skolem constant is really just a special case of a *Skolem function-*an "
"unknown entity that depends on one or more variable.\n"
"For example, to represent \"Everyone likes someone\" we could use:"
msgstr ""
"Константа Сколема - это просто частный случай *функции Сколема* -  "
"неизвестной сущности, которая зависит от одной или нескольких переменных.\n"
"Например, чтобы представить \"Всем кто-то нравится\"(Everyone likes someone) "
"мы могли бы использовать:"

#: in/chapter14.md:284
msgid "Everyone likes someone."
msgstr "Everyone likes someone.(Всем кто-то нравится)."

#: in/chapter14.md:286
msgid "&forall;*y*&exist; *x* person (*x*) => likes (*y, x*)"
msgstr ""

#: in/chapter14.md:291
msgid ""
"```lisp\n"
"(<- (likes ?y (p2 ?y)))\n"
"(<- (person (p2 ?y)))\n"
"```"
msgstr ""

#: in/chapter14.md:294
msgid ""
"Here `p2` is a Skolem function that depends on the variable `?y`.\n"
"In other words, everyone likes some person, but not necessarily the same "
"person."
msgstr ""
"Здесь `p2` - функция Сколема, которая зависит от переменной `?y`.\n"
"Другими словами, всем нравится какой-то человек(everyone likes some person), "
"но не обязательно один и тот же человек."

#: in/chapter14.md:296
msgid "## 14.5 Problems with Predicate Calculus's Expressiveness"
msgstr "## 14.5 Проблемы с выразительностью исчисления предикатов"

#: in/chapter14.md:299
msgid ""
"In the previous section we saw that Prolog has traded some expressiveness "
"for efficiency.\n"
"This section explores the limits of predicate calculus's expressiveness."
msgstr ""
"В предыдущем разделе мы видели, что Prolog променял выразительность в пользу "
"эффективности.\n"
"В этом разделе исследуются пределы выразительности исчисления предикатов."

#: in/chapter14.md:302
msgid ""
"Suppose we want to assert that lions, tigers, and bears are kinds of "
"animais.\n"
"In predicate calculus or in Prolog we could write an implication for each "
"case:"
msgstr ""
"Предположим, мы хотим утверждать, что львы, тигры и медведи - это разные "
"животные.\n"
"В исчислении предикатов или в Прологе мы могли бы написать импликацию для "
"каждого случая:"

#: in/chapter14.md:308
msgid ""
"```lisp\n"
"(<- (animal ?x) (lion ?x))\n"
"(<- (animal ?x) (tiger ?x))\n"
"(<- (animal ?x) (bear ?x))\n"
"```"
msgstr ""

#: in/chapter14.md:311
msgid ""
"These implications allow us to prove that any known lion, tiger, or bear is "
"in fact an animal.\n"
"However, they do not allow us to answer the question \"What kinds of animais "
"are there?\" It is not hard to imagine extending Prolog so that the query"
msgstr ""
"Эти выводы позволяют нам доказать, что любой известный лев, тигр или медведь "
"на самом деле является животным.\n"
"Однако они не позволяют нам ответить на вопрос \"Какие бывают виды животных?"
"\" Нетрудно представить расширение Prolog таким образом, чтобы запрос"

#: in/chapter14.md:315
msgid ""
"```lisp\n"
"(?- (<- (animal ?x) ?proposition))\n"
"```"
msgstr ""

#: in/chapter14.md:320
msgid ""
"would be legal.\n"
"However, this happens not to be valid Prolog, and it is not even valid first-"
"order predicate calculus (or FOPC).\n"
"In FOPC the variables must range over constants in the language, not over "
"relations or propositions.\n"
"Higher-order predicate calculus removes this limitation, but it has a more "
"complicated proof theory."
msgstr ""
"было бы законным.\n"
"Однако оказывается, что это неверный Пролог, и это даже не действительное "
"исчисление предикатов первого порядка (first-order predicate calculus или "
"FOPC).\n"
"В FOPC переменные должны меняться над константами языка, а не над "
"отношениями или предложениями.\n"
"Исчисление предикатов более высокого порядка снимает это ограничение, но "
"имеет более сложную теорию доказательств."

#: in/chapter14.md:324
msgid ""
"It is not even clear what the values of `?proposition` should be in the "
"query above.\n"
"Surely `(lion ?x)` would be a valid answer, but so would `(animal ?x), (or "
"(tiger ?x) (bear ?x))`, and an infinite number of other propositions.\n"
"Perhaps we should have two types of queries, one that asks about \"kinds,\" "
"and another that asks about propositions."
msgstr ""
"Непонятно даже, какими должны быть значения `?proposition` в запросе выше.\n"
"Несомненно, `(lion ?x)` будет правильным ответом, но то же самое будет с "
"``(animal ?x), (or (tiger ?x) (bear ?x))` и бесконечным количеством других "
"предложений.\n"
"Возможно, нам следует иметь два типа запросов: один спрашивает о \"видах"
"\"(\"kinds\"), а другой спрашивает о утверждениях(propositions)."

#: in/chapter14.md:328
msgid ""
"There are other questions that we might want to ask about relations.\n"
"Just as it is useful to declare the types of parameters to a Lisp function, "
"it can be useful to declare the types of the parameters of a relation, and "
"later query those types.\n"
"For example, we might say that the `likes` relation holds between a person "
"and an object."
msgstr ""
"Есть и другие вопросы, которые мы могли бы задать об отношениях.\n"
"Так же, как полезно объявлять типы параметров функции Lisp, может быть "
"полезно объявить типы параметров отношения, а затем запросить эти типы.\n"
"Например, мы можем сказать, что между человеком и объектом существует "
"отношение `likes`(нравится)."

#: in/chapter14.md:332
msgid ""
"In general, a sentence in the predicate calculus that uses a relation or "
"sentence as a term is called a higher-order sentence.\n"
"There are some quite subtle problems that come into play when we start to "
"allow higher-order expressions.\n"
"Allowing sentences in the calculus to talk about the truth of other "
"sentences can lead to a paradox: is the sentence \"This sentence is false\" "
"true or false?"
msgstr ""
"В общем, предложение в исчислении предикатов, в котором в качестве термина "
"используется отношение или предложение, называется предложением более "
"высокого порядка(higher-order sentence).\n"
"Когда мы начинаем разрешать выражения более высокого порядка, возникают "
"некоторые довольно тонкие проблемы.\n"
"Разрешение предложениям в исчислении говорить об истинности других "
"предложений может привести к парадоксу: истинно ли предложение \"This "
"sentence is false\"(Это предложение ложно)?"

#: in/chapter14.md:340
msgid ""
"Predicate calculus is defined in terms of a universe of individuals and "
"their properties and relations.\n"
"Thus it is well suited for a model of the world that picks out individuals "
"and categorizes them-a person here, a building there, a sidewalk between "
"them.\n"
"But how well does predicate calculus fare in a world of continuous "
"substances?\n"
"Consider a body of water consisting of an indefinite number of "
"subconstituents that are all water, with some of the water evaporating into "
"the air and rising to form clouds.\n"
"It is not at all obvious how to define the individuals here.\n"
"However, Patrick Hayes has shown that when the proper choices are made, "
"predicate calculus can describe this kind of situation quite well.\n"
"The detalls are in Hayes 1985."
msgstr ""
"Исчисление предикатов определяется в терминах вселенной индивидов, их "
"свойств и отношений.\n"
"Таким образом, оно хорошо подходит для модели мира, которая выбирает людей и "
"классифицирует их: человек здесь, здание там, тротуар между ними.\n"
"Но насколько хорошо работает исчисление предикатов в мире непрерывных "
"субстанций?\n"
"Представьте себе водоем, состоящий из неопределенного числа составляющих, "
"которые все являются водой, при этом часть воды испаряется в воздух и "
"поднимается, образуя облака.\n"
"Совершенно не очевидно, как здесь определять индивидуумов.\n"
"Однако Патрик Хейз показал, что когда сделан правильный выбор, исчисление "
"предикатов может достаточно хорошо описать такую ситуацию.\n"
"Детали в Hayes 1985."

#: in/chapter14.md:346
msgid ""
"The need to define categories is a more difficult problem.\n"
"Predicate calculus works very well for crisp, mathematical categories: a; is "
"a triangle if and only if *x* is a polygon with three sides.\n"
"Unfortunately, most categories that humans deal with in everyday life are "
"not defined so rigorously.\n"
"The category *friend* refers to someone you have mostly positive feelings "
"for, whom you can usually trust, and so on.\n"
"This \"definition\" is not a set of necessary and sufficient conditions but "
"rather is an open-ended list of ill-defined qualities that are highly "
"correlated with the category *friend.* We have a prototype for what an ideal "
"friend should be, but no clear-cut boundaries that separate *friend* from, "
"say, *acquaintance.* Furthermore, the boundaries seem to vary from one "
"situation to another: a person you describe as a good friend in your work "
"place might be only an acquaintance in the context of your home life."
msgstr ""
"Исчисление предикатов очень хорошо подходит для четких математических "
"категорий: a; является треугольником тогда и только тогда, когда *x* - "
"многоугольник с тремя сторонами.\n"
"К сожалению, большинство категорий, с которыми люди сталкиваются в "
"повседневной жизни, не определены так строго.\n"
"Категория *друг*(friend) относится к тем, к кому вы испытываете в основном "
"положительные чувства, кому вы обычно можете доверять, и так далее.\n"
"Это \"определение\" не является набором необходимых и достаточных условий, "
"а, скорее, представляет собой неограниченный список плохо определенных "
"качеств, которые сильно коррелируют с категорией *друг*. У нас есть прототип "
"того, каким должен быть идеальный друг, но нет четких границ, отделяющих "
"*друга*, скажем, от *знакомого*. в контексте вашей семейной жизни."

#: in/chapter14.md:349
msgid ""
"There are versions of predicate calculus that admit quantifiers like \"most"
"\" in addition to \"for all\" and \"there exists,\" and there have been "
"attempts to define prototypes and measure distances from them.\n"
"However, there is no consensus on the way to approach this problem."
msgstr ""
"Существуют версии исчисления предикатов, которые допускают такие кванторы, "
"как \"most\"(большинство) в дополнение к \"for all\"(для всех) и \"there "
"exists\"(существует), и были попытки определить прототипы и измерить "
"расстояния от них.\n"
"Однако единого мнения о подходе к этой проблеме нет."

#: in/chapter14.md:351
msgid "## 14.6 Problems with Completeness"
msgstr "## 14.6 Проблемы с полнотой"

#: in/chapter14.md:354
msgid ""
"Because Prolog searches depth-first, it can get caught in one branch of the "
"search space and never examine the other branches.\n"
"This problem can show up, for example, in trying to define a commutative "
"relation, like `sibling`:"
msgstr ""
"Поскольку Prolog выполняет поиск в глубину, он может попасть в одну ветвь "
"области поиска и никогда не исследовать другие ветки.\n"
"Эта проблема может проявиться, например, при попытке определить "
"коммутативное отношение, например `sibling`(брат/сестра):"

#: in/chapter14.md:359
msgid ""
"```lisp\n"
"(<- (sibling lee kim))\n"
"(<- (sibling ?x ?y) (sibling ?y ?x))\n"
"```"
msgstr ""

#: in/chapter14.md:362
msgid ""
"With these clauses, we expect to be able to conclude that Lee is Kim's "
"sibling, and Kim is Lee's.\n"
"Let's see what happens:"
msgstr ""
"С помощью этих пунктов мы надеемся сделать вывод, что Ли(Lee) является "
"братом Ким(Kim), а Ким - Ли.\n"
"Давай посмотрим что происходит:"

#: in/chapter14.md:375
msgid ""
"```lisp\n"
"> (?- (sibling ?x ?y))\n"
"?X = LEE\n"
"?Y = KIM;\n"
"?X = KIM\n"
"?Y = LEE;\n"
"?X = LEE\n"
"?Y = KIM;\n"
"?X = KIM\n"
"?Y = LEE.\n"
"No.\n"
"```"
msgstr ""

#: in/chapter14.md:381
msgid ""
"We get the expected conclusions, but they are deduced repeatedly, because "
"the commutative clause for siblings is applied over and over again.\n"
"This is annoying, but not critical.\n"
"Far worseis when we ask `(?- (sibling fred ?x))`.\n"
"This query loops forever.\n"
"Happily, this particular type of example has an easy fix: just introduce two "
"predicates, one for data-base level facts, and one at the level of axioms "
"and queries:"
msgstr ""
"Мы получаем ожидаемые выводы, но они выводятся неоднократно, потому что "
"коммутативное предложение для братьев и сестер применяется снова и снова.\n"
"Это раздражает, но не критично.\n"
"Намного хуже, когда мы спрашиваем `(?- (sibling fred ?x))`.\n"
"Этот запрос повторяется вечно.\n"
"К счастью, этот конкретный пример можно легко исправить: просто введите два "
"предиката, один для фактов уровня базы данных, а другой на уровне аксиом и "
"запросов:"

#: in/chapter14.md:387
msgid ""
"```lisp\n"
"(<- (sibling-fact lee kim))\n"
"(<- (sibling ?x ?y) (sibling-fact ?x ?y))\n"
"(<- (sibling ?x ?y) (sibling-fact ?y ?x))\n"
"```"
msgstr ""

#: in/chapter14.md:392
msgid ""
"Another fix would be to change the interpreter to fall when a repeated goal "
"was detected.\n"
"This was the approach taken in GPS.\n"
"However, even if we eliminated repeated goals, Prolog can still get stuck in "
"one branch of a depth-first search.\n"
"Consider the example:"
msgstr ""
"Еще одно исправление - изменить интерпретатор так, чтобы он падал при "
"обнаружении повторяющейся цели.\n"
"Это был подход, использованный в GPS.\n"
"Однако, даже если мы исключим повторяющиеся цели, Prolog все равно может "
"застрять в одной ветви поиска в глубину.\n"
"Рассмотрим пример:"

#: in/chapter14.md:397
msgid ""
"```lisp\n"
"(<- (natural 0))\n"
"(<- (natural (1  + ?n)) (natural ?n))\n"
"```"
msgstr ""

#: in/chapter14.md:403
msgid ""
"These rules define the natural numbers (the non-negative integers).\n"
"We can use the rules either to confirm queries like `(natural (1  + (1  + "
"(1  + 0))))` or to generate the natural numbers, as in the query `(natural ?"
"n)`.\n"
"So far, everything is fine.\n"
"But suppose we wanted to define all the integers.\n"
"One approach would be this:"
msgstr ""
"Эти правила определяют натуральные числа (неотрицательные целые числа).\n"
"Мы можем использовать правила либо для подтверждения запросов типа `(natural "
"(1  + (1  + (1  + 0))))`, либо для генерации натуральных чисел, как в "
"запросе `(natural ?n)`.\n"
"Пока все нормально.\n"
"Но предположим, что мы хотим определить все целые числа.\n"
"Один из подходов был бы таким:"

#: in/chapter14.md:409
msgid ""
"```lisp\n"
"(<- (integer 0))\n"
"(<- (integer ?n) (integer (1  + ?n)))\n"
"(<- (integer (1  + ?n)) (integer ?n))\n"
"```"
msgstr ""

#: in/chapter14.md:414
msgid ""
"These rules say that 0 is an integer, and any *n* is an integer if *n* + 1 "
"is, and *n* + 1 is if *n* is.\n"
"While these rules are correct in a logical sense, they don't work as a "
"Prolog program.\n"
"Asking `(integer *x*)` will resuit in an endless series of ever-increasing "
"queries: `(integer (1  + *x*)), (integer (1  + (1  + *x*)))`, and so on.\n"
"Each goal is different, so no check can stop the recursion."
msgstr ""
"Эти правила говорят, что 0 - это целое число, а любое *n* - целое, если *n* "
"+ 1 целое, и *n* + 1 - если *n* целое.\n"
"Хотя эти правила верны в логическом смысле, они не работают как программа на "
"Прологе.\n"
"Запрос `(integer *x*)` приведет к бесконечной серии постоянно растущих "
"запросов: `(integer (1  + *x*)), (integer (1  + (1  + *x*)))` и т.д.\n"
"Каждая цель отличается, поэтому никакая проверка не может остановить "
"рекурсию."

#: in/chapter14.md:420
msgid ""
"The occurs check may or may not introduce problems into Prolog, depending on "
"your interpretation of infinite trees.\n"
"Most Prolog systems do not do the occurs check.\n"
"The reasoning is that unifying a variable with some value is the Prolog "
"equivalent of assigning a value to a variable, and programmers expect such a "
"basic operation to be fast.\n"
"With the occurs check turned off, it will in fact be fast.\n"
"With checking on, it takes time proportional to the size of the value, which "
"is deemed unacceptable."
msgstr ""
"В зависимости от вашей интерпретации бесконечных деревьев эта проверка может "
"или не может вызвать проблемы в Прологе.\n"
"Большинство систем Prolog не выполняют проверку встречаемости(occurs "
"check).\n"
"Причина в том, что объединение переменной с некоторым значением является в "
"Прологе эквивалентом присвоения значения переменной, и программисты ожидают, "
"что такая базовая операция будет быстрой.\n"
"Если проверка встречаемости отключена, это действительно будет быстро.\n"
"При включенной проверке требуется время, пропорциональное размеру значения, "
"что считается неприемлемым."

#: in/chapter14.md:423
msgid ""
"With occurs checking off, the programmer gets the benefit of fast "
"unification but can run into problems with circular structures.\n"
"Consider the following clauses:"
msgstr ""
"Если проверка встречаемости отключена, программист получает преимущество "
"быстрой унификации, но может столкнуться с проблемами с круговыми "
"структурами.\n"
"Обратите внимание на следующие предложения:"

#: in/chapter14.md:428
msgid ""
"```lisp\n"
"(<- (parent ?x (mother-of ?x)))\n"
"(<- (parent ?x (father-of ?x)))\n"
"```"
msgstr ""

#: in/chapter14.md:431
msgid ""
"These clauses say that, for any person, the mother of that person and the "
"father of that person are parents of that person.\n"
"Now let us ask if there is a person who is his or her own parent:"
msgstr ""
"В этих предложениях говорится, что для любого человека мать этого человека и "
"отец этого человека являются родителями этого человека.\n"
"Теперь давайте спросим, есть ли человек, который является своим собственным "
"родителем:"

#: in/chapter14.md:434
msgid ""
"`> (?\n"
"(parent ?y ?y))`"
msgstr ""

#: in/chapter14.md:438
msgid ""
"```lisp\n"
"?Y = [Abort]\n"
"```"
msgstr ""

#: in/chapter14.md:441
msgid ""
"The system has found an answer, where `?y = (mother-of ?y).` The answer "
"can't be printed, though, because `deref` (or `subst-bindings` in the "
"interpreter) goes into an infinite loop trying to figure out what `?y` is.\n"
"Without the printing, there would be no infinite loop:"
msgstr ""
"Система нашла ответ, где `?y = (mother-of ?y)`. Однако ответ не может быть "
"напечатан, потому что `deref` (или `subst-bindings` в интерпретаторе) "
"переходит в бесконечное число циклов пытаясь выяснить, что такое `?y``.\n"
"Без печати не было бы бесконечного цикла:"

#: in/chapter14.md:445
msgid ""
"```lisp\n"
"(<- (self-parent) (parent ?y ?y))\n"
"```"
msgstr ""

#: in/chapter14.md:448
msgid ""
"`> (?\n"
"(self-parent))`"
msgstr ""

#: in/chapter14.md:454
msgid ""
"```lisp\n"
"Yes;\n"
"Yes;\n"
"No.\n"
"```"
msgstr ""

#: in/chapter14.md:460
msgid ""
"The `self-parent` query succeeds twice, once with the mother clause and once "
"with the father clause.\n"
"Has Prolog done the right thing here?\n"
"It depends on your interpretation of infinite circular trees.\n"
"If you accept them as valid objects, then the answer is consistent.\n"
"If you don't, then leaving out the occurs check makes Prolog *unsound:* it "
"can come up with incorrect answers."
msgstr ""
"Запрос `self-parent` завершается успешно дважды: один раз с предложением "
"mother и один раз с предложением  father(отца).\n"
"Правильно ли поступил здесь Prolog?\n"
"Это зависит от вашей интерпретации бесконечных циклических деревьев.\n"
"Если вы принимаете их как допустимые объекты, то ответ будет однозначным.\n"
"Если вы этого не сделаете, то пропуск проверки встречаемости делает Prolog "
"*ненадежным:* он может давать неправильные ответы."

#: in/chapter14.md:463
msgid ""
"The same problem comes up if we ask if there are any sets that include "
"themselves as members.\n"
"The query `(member ?set ?set)` will succeed, but we will not be able to "
"print the value of `?set`."
msgstr ""
"Та же проблема возникает, если мы спросим, есть ли какие-нибудь группы, "
"которые включают себя в качестве членов.\n"
"Запрос `(member ?set ?set)` будет успешным, но мы не сможем распечатать "
"значение `?set`."

#: in/chapter14.md:465
msgid "## 14.7 Problems with Efficiency: Indexing"
msgstr "## 14.7 Проблемы с эффективностью: индексирование"

#: in/chapter14.md:469
msgid ""
"Our Prolog compiler is designed to handle \"programlike\" predicates-"
"predicates with a small number of rules, perhaps with complex bodies.\n"
"The compiler does much worse on \"tablelike\" predicates-predicates with a "
"large number of simple facts.\n"
"Consider the predicate `pb`, which encodes phone-book facts in the form:"
msgstr ""
"Наш компилятор пролога предназначен для обработки \"программоподобных\" "
"предикатов - предикатов с небольшим количеством правил, возможно, со "
"сложными телами.\n"
"Компилятор гораздо хуже справляется с \"табличноподобными\" предикатами - "
"предикатами с большим количеством простых фактов.\n"
"Рассмотрим предикат 'pb`, который кодирует факты телефонной книги в виде:"

#: in/chapter14.md:473
msgid ""
"```lisp\n"
"(pb (name Jan Doe) (num 415 555 1212))\n"
"```"
msgstr ""

#: in/chapter14.md:476
msgid ""
"Suppose we have a few thousand entries of this kind.\n"
"A typical query for this data base would be:"
msgstr ""
"Предположим, у нас есть несколько тысяч таких записей.\n"
"Типичный запрос к этой базе данных:"

#: in/chapter14.md:480
msgid ""
"```lisp\n"
"(pb (name Jan Doe) ?num)\n"
"```"
msgstr ""

#: in/chapter14.md:484
msgid ""
"It would be inefficient to search through the facts linearly, matching each "
"one against the query.\n"
"It would also be inefficient to recompile the whole `pb/2` predicate every "
"time a new entry is added.\n"
"But that is just what our compiler does."
msgstr ""
"Было бы неэффективно искать факты линейно, сопоставляя каждый из них с "
"запросом.\n"
"Также было бы неэффективно перекомпилировать весь предикат `pb/2` каждый "
"раз, когда добавляется новая запись.\n"
"Но это именно то, что делает наш компилятор."

#: in/chapter14.md:486
msgid ""
"The solutions to the three problems-expressiveness, completeness, and "
"indexing-will be considered in reverse order, so that the most difficult "
"one, expressiveness, will come last."
msgstr ""
"Решения трех проблем - выразительности, полноты и индексации - будут "
"рассмотрены в обратном порядке, так что самая сложная - выразительность - "
"будет последней."

#: in/chapter14.md:488
msgid "## 14.8 A Solution to the Indexing Problem"
msgstr "## 14.8 Решение проблемы индексации"

#: in/chapter14.md:492
msgid ""
"A better solution to the phone-book problem is to index each phone-book "
"entry in some kind of table that makes it easy to add, delete, and retrieve "
"entries.\n"
"That is what we will do in this section.\n"
"We will develop an extension of the trie or discrimination tree data "
"structure built in [section 10.5](B9780080571157500108.xhtml#s0030) ([page "
"344](B9780080571157500108.xhtml#p344))."
msgstr ""
"Лучшее решение проблемы телефонной книги - это индексировать каждую запись "
"телефонной книги в некоторой таблице, которая упрощает добавление, удаление "
"и извлечение записей.\n"
"Этим мы и займемся в этом разделе.\n"
"Мы разработаем расширение структуры данных trie или дерева дискриминации, "
"построенное в [раздел 10.5] (B9780080571157500108.xhtml#s0030) ([страница "
"344] (B9780080571157500108.xhtml#p344))."

#: in/chapter14.md:498
msgid ""
"Making a discrimination tree for Prolog facts is complicated by the presence "
"of variables in both the facts and the query.\n"
"Either facts with variables in them will have to be indexed in several "
"places, or queries with variables will have to look in several places, or "
"both.\n"
"We also have to decide if the discrimination tree itself will handle "
"variable binding, or if it will just return candidate matches which are then "
"checked by some other process.\n"
"It is not clear what to store in the discrimination tree: copies of the "
"fact, functions that can be passed continuations, or something else.\n"
"More design choices will come up as we proceed."
msgstr ""
"Создание дерева дискриминации(различения) для фактов Пролога осложняется "
"наличием переменных как в фактах, так и в запросе.\n"
"Либо факты с переменными в них нужно будет проиндексировать в нескольких "
"местах, либо запросы с переменными придется искать в нескольких местах, либо "
"и то, и другое.\n"
"Мы также должны решить, будет ли само дерево дискриминации обрабатывать "
"привязку переменных или будет просто возвращать совпадения кандидатов, "
"которые затем проверяются каким-либо другим процессом.\n"
"Непонятно, что хранить в дереве дискриминации: копии фактов, функции, "
"которым можно передавать продолжения, или что-то еще.\n"
"По мере продолжения работы появятся новые варианты дизайна."

#: in/chapter14.md:502
msgid ""
"It is difficult to make design choices when we don't know exactly how the "
"system will be used.\n"
"We don't know what typical facts will look like, nor typical queries.\n"
"Therefore, we will design a fairly abstract tool, forgetting for the moment "
"that it will be used to index Prolog facts."
msgstr ""
"Трудно сделать выбор дизайна, когда мы не знаем точно, как будет "
"использоваться система.\n"
"Мы не знаем, как будут выглядеть типичные факты или типичные запросы.\n"
"Поэтому мы разработаем довольно абстрактный инструмент, забыв на время, что "
"он будет использоваться для индексации фактов Пролога."

#: in/chapter14.md:507
msgid ""
"We will address the problem of a discrimination tree where both the keys and "
"queries are predicate structures with wild cards.\n"
"A wild card is a variable, but with the understanding thatthere is no "
"variable binding; each instance of a variable can match anything.\n"
"A predicate structure is a list whose first element is a nonvariable "
"symbol.\n"
"The discrimination tree supports three operations:"
msgstr ""
"Мы рассмотрим проблему дерева дискриминации, в котором и ключи, и запросы "
"являются структурами предикатов с подстановочными знаками.\n"
"Подстановочный знак - это переменная, но с пониманием того, что привязки "
"переменной нет; каждый экземпляр переменной может соответствовать чему "
"угодно.\n"
"Структура предиката - это список, первым элементом которого является "
"неизменяемый символ.\n"
"Дерево дискриминации поддерживает три операции:"

#: in/chapter14.md:509
msgid "*   `index`-add a key/value pair to the tree"
msgstr "*   `index`-добавить в дерево пару ключ/значение"

#: in/chapter14.md:511
msgid "*   `fetch`-find all values that potentially match a given key"
msgstr ""
"*   `fetch`-найти все значения, которые потенциально соответствуют заданному "
"ключу"

#: in/chapter14.md:513
msgid "*   `unindex`-remove all key/value pairs that match a given key"
msgstr ""
"*   `unindex`-удалить все пары ключ/значение, соответствующие заданному ключу"

#: in/chapter14.md:517
msgid ""
"To appreciate the problems, we need an example.\n"
"Suppose we have the following six keys to index.\n"
"For simplicity, the value of each key will be the key itself:"
msgstr ""
"Чтобы оценить проблемы, нам нужен пример.\n"
"Предположим, у нас есть следующие шесть ключей для индексации.\n"
"Для простоты значение каждого ключа будет самим ключом:"

#: in/chapter14.md:526
msgid ""
"```lisp\n"
"1 (p a b)\n"
"2 (p a c)\n"
"3 (p a ?x)\n"
"4 (p b c)\n"
"5 (p b (f c))\n"
"6 (p a (f . ?x))\n"
"```"
msgstr ""

#: in/chapter14.md:535
msgid ""
"Now assume the query `(p ?y c)`.\n"
"This should match keys 2, 3, and 4.\n"
"How could we efficiently arrive at this set?\n"
"One idea is to list the key/value pairs under every atom that they contain.\n"
"Thus, all six would be listed under the atom `p`, while 2, 4, and 5 would be "
"listed under the atom c.\n"
"A unification check could elimina te 5, but we still would be missing 3.\n"
"Key 3 (and every key with a variable in it) could potentially contain the "
"atom `c`.\n"
"So to get the right answers under this approach, we will need to index every "
"key that contains a variable under every atom-not an appealing situation."
msgstr ""
"Теперь предположим, что запрос `(p ?y c)`.\n"
"Это должно соответствовать ключам 2, 3 и 4.\n"
"Как мы можем эффективно получить этот набор?\n"
"Одна из идей - перечислить пары ключ/значение под каждым атомом, который они "
"содержат.\n"
"Таким образом, все шесть будут перечислены под атомом `p`, а 2, 4 и 5 будут "
"перечислены под атомом c.\n"
"Проверка унификации может исключить 5, но нам все равно не хватит 3.\n"
"Ключ 3 (и каждый ключ с переменной в нем) потенциально может содержать атом "
"c.\n"
"Таким образом, чтобы получить правильные ответы при таком подходе, нам нужно "
"будет проиндексировать каждый ключ, который содержит переменную под каждым "
"атомом, что не является привлекательной ситуацией."

#: in/chapter14.md:542
msgid ""
"An alternative is to create indices based on both atoms and their position.\n"
"So now we would be retrieving all the keys that have a c in the second "
"argument position: 2 and 4, plus the keys that have a variable as the second "
"argument: 3.\n"
"This approach seems to work much better, at least for the example shown.\n"
"To create the index, we essentially superimpose the list structure of all "
"the keys on top of each other, to arrive at one big discrimination tree.\n"
"At each position in the tree, we create an index of the keys that have "
"either an atom or a variable at that position.\n"
"[Figure 14.1](#f0010) shows the discrimination tree for the six keys."
msgstr ""
"Альтернативой является создание индексов на основе как атомов, так и их "
"положения(позиции).\n"
"Итак, теперь мы будем извлекать все ключи, у которых есть c во второй "
"позиции аргумента: 2 и 4, плюс ключи, у которых есть переменная в качестве "
"второго аргумента: 3.\n"
"Этот подход работает намного лучше, по крайней мере, для показанного "
"примера.\n"
"Чтобы создать индекс, мы, по сути, накладываем структуру списка всех ключей "
"друг на друга, чтобы получить одно большое дерево дискриминации.\n"
"В каждой позиции в дереве мы создаем индекс ключей, которые имеют либо атом, "
"либо переменную в этой позиции.\n"
"[Рисунок 14.1] (# f0010) показывает дерево дискриминации для шести ключей."

#: in/chapter14.md:547
msgid ""
"| []()                                           |\n"
"|------------------------------------------------|\n"
"| ![f14-01](images/chapter14/f14-01.jpg)         |\n"
"| Figure 14.1: Discrimination Tree with Six Keys |"
msgstr ""

#: in/chapter14.md:552
msgid ""
"Consider the query `(p ?y c)`.\n"
"Either the `p` or the `c` could be used as an index.\n"
"The `p` in the predicate position retrieves all six keys.\n"
"But the c in the second argument position retrieves only three keys: 2 and "
"4, which are indexed under c itself, and 3, which is indexed under the "
"variable in that position."
msgstr ""
"Рассмотрим запрос `(p ?y c)`.\n"
"В качестве индекса можно использовать либо `p`, либо `c`.\n"
"`p` в позиции предиката возвращает все шесть ключей.\n"
"Но c во второй позиции аргумента возвращает только три ключа: 2 и 4, которые "
"индексируются под самой c, и 3, которые индексируются под переменной в этой "
"позиции."

#: in/chapter14.md:557
msgid ""
"Now consider the query `(p ?y (f ?z))`.\n"
"Again, the `p` serves as an index to all six keys.\n"
"The `f` serves as an index to only three keys: the 5 and 6, which are "
"indexed directly under f in that position, and 3, which is indexed under the "
"variable in a position along the path that lead to f.\n"
"In general, all the keys indexed under variables along the path must be "
"considered."
msgstr ""
"Теперь рассмотрим запрос `(p ?y (f ?z))`.\n"
"Опять же, `p` служит индексом для всех шести ключей.\n"
"`f` служит индексом только для трех ключей: 5 и 6, которые индексируются "
"непосредственно под f в этой позиции, и 3, который индексируется под "
"переменной в позиции вдоль пути, ведущего к f.\n"
"Как правило, необходимо учитывать все ключи, проиндексированные под "
"переменными по пути."

#: in/chapter14.md:562
msgid ""
"The retrieval mechanism can overretrieve.\n"
"Given the query `(p a (f ?x))`, the atom `p` will again retrieve all six "
"keys, the atom a retrieves 1, 2, 3, and 6, and f again retrieves 5, 6, and "
"3.\n"
"So `f` retrieves the shortest list, and hence it will be used to determine "
"the final resuit.\n"
"But key 5 is `(p b (f c))`, which does not match the query `(pa (f?x))`."
msgstr ""
"Механизм извлечения может перегружать извлечиние.\n"
"Учитывая запрос `(p a (f ?x))`, атом `p` снова получит все шесть ключей, "
"атом a получит 1, 2, 3 и 6, а f снова получит 5, 6 и 3.\n"
"Таким образом, `f` извлекает самый короткий список и, следовательно, он "
"будет использоваться для определения окончательного результата.\n"
"Но ключ 5 - это `(p b (f c))`, что не соответствует запросу `(pa (f ?x))`."

#: in/chapter14.md:569
msgid ""
"We could eliminate this problem by intersecting all the lists instead of "
"just taking the shortest list.\n"
"It is perhaps feasible to do the intersection using bit vectors, but "
"probably too slow and wasteful of space to do it using lists.\n"
"Even if we did intersect keys, we would still overretrieve, for two "
"reasons.\n"
"First, we don't use nil as an index, so we are ignoring the difference "
"between `(f ?x)` and `(f . ?x)`.\n"
"Second, we are using wild-card semantics, so the query `(p ?x ?x)` would "
"retrieve all six keys, when it should only retrieve three.\n"
"Because of these problems, we make a design choice: we will first build a "
"data base retrieval function that retrieves potential matches, and later "
"worry about the unification process that will eliminate mismatches."
msgstr ""
"Мы могли бы устранить эту проблему, пересекая все списки вместо того, чтобы "
"просто выбирать самый короткий список.\n"
"Возможно, возможно выполнить пересечение с использованием битовых векторов, "
"но, вероятно, делать это слишком медленно и расточительно, по "
"использованному пространству, с помощью списков.\n"
"Даже если бы мы действительно пересечем ключи, мы все равно выполняли бы "
"повторное извлечение по двум причинам.\n"
"Во-первых, мы не используем nil в качестве индекса, поэтому мы игнорируем "
"разницу между `(f ?x)` и `(f . ?x)`.\n"
"Во-вторых, мы используем семантику подстановочных знаков(wild-card), поэтому "
"запрос `(p ?x ?x)` извлечет все шесть ключей, тогда как он должен получить "
"только три.\n"
"Из-за этих проблем мы делаем выбор дизайна: сначала мы создадим функцию "
"извлечения базы данных, которая извлекает потенциальные совпадения, а затем "
"позаботимся о процессе унификации, который устранит несоответствия."

#: in/chapter14.md:571
msgid ""
"We are ready for a more complete specification of the indexing strategy:"
msgstr "Мы готовы к более полному уточнению стратегии индексации:"

#: in/chapter14.md:575
msgid ""
"*   The value will be indexed under each non-nil nonvariable atom in the "
"key, with a separate index for each position.\n"
"For example, given the preceding data base, the atom a in the first argument "
"position would index values 1,2,3, and 6, while the atom b in the second "
"argument position would index value 4 and 5.\n"
"The atom p in the predicate position would index all six values."
msgstr ""
"*   Значение будет проиндексировано под каждым непеременным атомом ключа, "
"отличным от nil, с отдельным индексом для каждой позиции.\n"
"Например, с учетом предыдущей базы данных атом a в позиции первого аргумента "
"будет индексировать значения 1,2,3 и 6, а атом b во второй позиции аргумента "
"будет индексировать значения 4 и 5.\n"
"Атом p в позиции предиката будет индексировать все шесть значений."

#: in/chapter14.md:578
msgid ""
"*   In addition, we will maintain a separate index for variables at each "
"position.\n"
"For example, value 3 would be stored under the index \"variable in second "
"argument position.\""
msgstr ""
"*   Кроме того, мы будем поддерживать отдельный индекс для переменных в "
"каждой позиции.\n"
"Например, значение 3 будет сохранено под индексом \"переменная во второй "
"позиции аргумента\"."

#: in/chapter14.md:581
msgid ""
"*   \"Position\" does not refer solely to the linear position in the top-"
"level list.\n"
"For example, value 5 would be indexed under atom f in the caaddr position."
msgstr ""
"*   \"Позиция\" не относится исключительно к линейной позиции в списке "
"верхнего уровня.\n"
"Например, значение 5 будет индексировано под атомом f в позиции caaddr."

#: in/chapter14.md:583
msgid ""
"*   It follows that a key with *n* atoms will be indexed in *n* different "
"ways."
msgstr ""
"*   Отсюда следует, что ключ с *n* атомами будет индексироваться *n* разными "
"способами."

#: in/chapter14.md:585
msgid "For retrieval, the strategy is:"
msgstr "Стратегия поиска такова:"

#: in/chapter14.md:588
msgid ""
"*   For each non-nil nonvariable atom in the retrieval key, generate a list "
"of possible matches.\n"
"Choose the shortest such list."
msgstr ""
"*   Для каждого непеременного атома, отличного от nil, в ключе поиска "
"сгенерируйте список возможных совпадений.\n"
"Выберите самый короткий из таких списков."

#: in/chapter14.md:590
msgid ""
"*   Each list of possible matches will have to be augmented with the values "
"indexed under a variable at every position \"above.\" For example, `f` in "
"the `caaddr` position retrieves value 5, but it also must retrieve value 3, "
"because the third key has a variable in the `caddr` position, and `caddr` is "
"\"above\" `caaddr.`"
msgstr ""
"*   Каждый список возможных совпадений должен быть дополнен значениями, "
"индексированными под переменной в каждой позиции \"выше/над\". Например, `f` "
"в позиции `caaddr` извлекает значение 5, но он также должен извлекать "
"значение 3, потому что третий ключ имеет переменную в позиции `caddr`, а "
"`caddr` находится \"выше/над\"  `caaddr.`"

#: in/chapter14.md:593
msgid ""
"*   The discrimination tree may return values that are not valid matches.\n"
"The purpose of the discrimination tree is to reduce the number of values we "
"will have to unify against, not to determine the exact set of matches."
msgstr ""
"*   Дерево дискриминации может возвращать значения, которые не являются "
"допустимыми совпадениями.\n"
"Цель дерева дискриминации - уменьшить количество значений, с которыми нам "
"придется объединяться, а не определять точный набор совпадений."

#: in/chapter14.md:603
msgid ""
"It is important that the retrieval function execute quickly.\n"
"If it is slow, we might just as well match against every key in the table "
"linearly.\n"
"Therefore, we will take care to implement each part efficiently.\n"
"Note that we will have to compare the length of lists to choose the shortest "
"possibility.\n"
"Of course, it is trivial to compare lengths using `length,` but `length` "
"requires traversing the whole list.\n"
"We can do better if we store the length of the list explicitly.\n"
"A list with its length will be called an `nlist`.\n"
"It will be implemented as a cons cell containing the number of elements and "
"a list of the elements themselves.\n"
"An alternative would be to use extensible vectors with fill pointers."
msgstr ""
"Важно, чтобы функция поиска выполнялась быстро.\n"
"Если она медленна, мы могли бы точно сопоставить каждый ключ в таблице "
"линейно.\n"
"Поэтому мы позаботимся о том, чтобы каждую часть реализовать эффективно.\n"
"Обратите внимание, что нам нужно будет сравнить длину списков, чтобы выбрать "
"самый короткий вариант.\n"
"Конечно, сравнивать длины с помощью `length` тривиально, но `length` требует "
"обхода всего списка.\n"
"Мы можем добиться большего, если явно сохраним длину списка.\n"
"Список с его длиной будет называться `nlist`.\n"
"Он будет реализован как cons-ячейка, содержащая количество элементов и "
"список самих элементов.\n"
"Альтернативой было бы использование расширяемых векторов с указателями "
"заполнения(заполннености)."

#: in/chapter14.md:609
msgid ""
"```lisp\n"
";; An nlist is implemented as a (count . elements) pair:\n"
"(defun make-empty-nlist ()\n"
"  \"Create a new, empty nlist.\"\n"
"  (cons 0 nil))"
msgstr ""

#: in/chapter14.md:612
msgid ""
"(defun nlist-n (x) \"The number of elements in an nlist.\" (car x))\n"
"(defun nlist-list (x) \"The elements in an nlist.\" (cdr x))"
msgstr ""

#: in/chapter14.md:619
msgid ""
"(defun nlist-push (item nlist)\n"
"  \"Add a new element to an nlist.\"\n"
"  (incf (car nlist))\n"
"  (push item (cdr nlist))\n"
"  nlist)\n"
"```"
msgstr ""

#: in/chapter14.md:624
msgid ""
"Now we need a place to store these nlists.\n"
"We will build the data base out of discrimination tree nodes called dtree "
"nodes.\n"
"Each dtree node has a field to hold the variable index, the atom indices, "
"and pointers to two subnodes, one for the `first` and one for the `rest`.\n"
"We implement dtrees as vectors for efficiency, and because we will never "
"need a `dtree-p` predicate."
msgstr ""
"Теперь нам нужно место для хранения этих nlists.\n"
"Мы построим базу данных из узлов дерева дискриминации, называемых узлами "
"dtree.\n"
"Каждый узел dtree имеет поле для хранения индекса переменной, индексов "
"атомов и указателей на два подузла, один для `first(первого)` и один для "
"`rest(остальных)`.\n"
"Мы реализуем dtrees как векторы для повышения эффективности и потому, что "
"нам никогда не понадобится предикат dtree-p."

#: in/chapter14.md:629
msgid ""
"```lisp\n"
"(defstruct (dtree (:type vector))\n"
"  (first nil) (rest nil) (atoms nil) (var (make-empty-nlist)))\n"
"```"
msgstr ""

#: in/chapter14.md:633
msgid ""
"A separate dtree will be stored for each predicate.\n"
"Since the predicates must be symbols, it is possible to store the dtrees on "
"the predicate's property list.\n"
"In most implementations, this will be faster than alternatives such as hash "
"tables."
msgstr ""
"Для каждого предиката будет храниться отдельное dtree.\n"
"Поскольку предикаты должны быть символами, можно сохранить деревья dtrees в "
"списке свойств предиката.\n"
"В большинстве реализаций это будет быстрее, чем альтернативы, такие как хеш-"
"таблицы."

#: in/chapter14.md:638
msgid ""
"```lisp\n"
";; Not all Lisps handle the closure properly, so change the local "
"PREDICATES\n"
";; to a global *predicates* - norvig Jun 11 1996\n"
"(defvar *predicates* nil)"
msgstr ""

#: in/chapter14.md:644
msgid ""
"(defun get-dtree (predicate)\n"
"  \"Fetch (or make) the dtree for this predicate.\"\n"
"  (cond ((get predicate 'dtree))\n"
"\t(t (push predicate *predicates*)\n"
"\t   (setf (get predicate 'dtree) (make-dtree)))))"
msgstr ""

#: in/chapter14.md:651
msgid ""
"(defun clear-dtrees ()\n"
"  \"Remove all the dtrees for all the predicates.\"\n"
"  (dolist (predicate *predicates*)\n"
"    (setf (get predicate 'dtree) nil))\n"
"  (setf *predicates* nil))\n"
"```"
msgstr ""

#: in/chapter14.md:654
msgid ""
"The function `index` takes a relation as key and stores it in the dtree for "
"the predicate of the relation.\n"
"It calls `dtree-index` to do all the work of storing a value under the "
"proper indices for the key in the proper dtree node."
msgstr ""
"Функция index принимает отношение как ключ и сохраняет его в dtree для "
"предиката отношения.\n"
"Она вызывает dtree-index, чтобы выполнить всю работу по сохранению значения "
"под соответствующими индексами для ключа в соответствующем узле dtree."

#: in/chapter14.md:661
msgid ""
"The atom indices are stored in an association list.\n"
"Property lists would not work, because they are searched using eq and atoms "
"can be numbers, which are not necessarily `eq`.\n"
"Association lists are searched using `eql` by default.\n"
"An alternative would be to use hash tables for the index, or even to use a "
"scheme that starts with association lists and switches to a hash table when "
"the number of entries gets large.\n"
"I use `lookup` to look up the value of a key in a property list.\n"
"This function, and its `setf` method, are defined on [page 896]"
"(B978008057115750025X.xhtml#p896)."
msgstr ""
"Индексы атомов хранятся в списке ассоциаций(a-list).\n"
"Списки свойств не будут работать, потому что они производят поиск с помощью "
"eq, а атомы могут быть числами, которые не обязательно являются `eq`.\n"
"Списки ассоциаций по умолчанию производят поиск с использованием `eql`.\n"
"Альтернативой может быть использование хеш-таблиц для индекса или даже "
"использование схемы, по которой начинается работа со списков ассоциаций и "
"переключается на хеш-таблицу, когда количество записей становится большим.\n"
"Я использую `lookup`, чтобы найти значение ключа в списке свойств.\n"
"Эта функция и ее метод `setf` определены на [стр. 896](B978008057115750025X."
"xhtml#p896)."

#: in/chapter14.md:667
msgid ""
"```lisp\n"
"(defun index (key)\n"
"  \"Store key in a dtree node.  Key must be (predicate . args);\n"
"  it is stored in the predicate's dtree.\"\n"
"  (dtree-index key key (get-dtree (predicate key))))"
msgstr ""

#: in/chapter14.md:683
msgid ""
"(defun dtree-index (key value dtree)\n"
"  \"Index value under all atoms of key in dtree.\"\n"
"  (cond\n"
"    ((consp key)               ; index on both first and rest\n"
"     (dtree-index (first key) value\n"
"                  (or (dtree-first dtree)\n"
"                      (setf (dtree-first dtree) (make-dtree))))\n"
"     (dtree-index (rest key) value\n"
"                  (or (dtree-rest dtree)\n"
"                      (setf (dtree-rest dtree) (make-dtree)))))\n"
"    ((null key))               ; don't index on nil\n"
"    ((variable-p key)          ; index a variable\n"
"     (nlist-push value (dtree-var dtree)))\n"
"    (t ;; Make sure there is an nlist for this atom, and add to it\n"
"     (nlist-push value (lookup-atom key dtree)))))"
msgstr ""

#: in/chapter14.md:691
msgid ""
"(defun lookup-atom (atom dtree)\n"
"  \"Return (or create) the nlist for this atom in dtree.\"\n"
"  (or (lookup atom (dtree-atoms dtree))\n"
"      (let ((new (make-empty-nlist)))\n"
"        (push (cons atom new) (dtree-atoms dtree))\n"
"        new)))\n"
"```"
msgstr ""

#: in/chapter14.md:694
msgid ""
"Now we define a function to test the indexing routine.\n"
"Compare the output with [figure 14.1](#f0010)."
msgstr ""
"Теперь мы определяем функцию для проверки процедуры индексирования.\n"
"Сравните вывод с [рис. 14.1](#f0010)."

#: in/chapter14.md:704
msgid ""
"```lisp\n"
"(defun test-index ()\n"
"  (let ((props '((p a b) (p a c) (p a ?x) (p b c)\n"
"                 (p b (f c)) (p a (f . ?x)))))\n"
"    (clear-dtrees)\n"
"    (mapc #'index props)\n"
"    (write (list props (get-dtree 'p))\n"
"           :circle t :array t :pretty t)\n"
"    (values)))"
msgstr ""

#: in/chapter14.md:724
msgid ""
"> (test-index)\n"
"((#1=(P A B)\n"
"  #2=(P A C)\n"
"  #3=(P A ?X)\n"
"  #4=(P B C)\n"
"  #5=(P B (F C))\n"
"  #6=(P A (F . ?X)))\n"
"  #(#(NIL NIL (P (6 #6# #5# #4# #3# #2# #1#)) (0))\n"
"  #(#(NIL NIL (B (2 #5# #4#) A (4 #6# #3# #2# #1#)) (0))\n"
"    #(#(#(NIL NIL (F (2 #6# #5#)) (0))\n"
"      #(#(NIL NIL (C (1 #5#)) (0))\n"
"        #(NIL NIL NIL (0)) NIL (1 #6#))\n"
"      (C (2 #4# #2#) B (1 #1#))\n"
"      (1 #3#))\n"
"    #(NIL NIL NIL (0))\n"
"    NIL (0))\n"
"  NIL (0))\n"
"  NIL (0)))\n"
"```"
msgstr ""

#: in/chapter14.md:728
msgid ""
"The next step is to fetch matches from the dtree data base.\n"
"The function `fetch` takes a query, which must be a valid relation, as its "
"argument, and returns a list of possible matches.\n"
"It calls `dtree-fetch` to do the work:"
msgstr ""
"Следующим шагом будет получение совпадений из базы данных dtree.\n"
"Функция `fetch` принимает запрос, который должен быть допустимым отношением, "
"в качестве аргумента и возвращает список возможных совпадений.\n"
"Она вызывает `dtree-fetch` для выполнения работы:"

#: in/chapter14.md:736
msgid ""
"```lisp\n"
"(defun fetch (query)\n"
"  \"Return a list of buckets potentially matching the query,\n"
"  which must be a relation of form (predicate . args).\"\n"
"  (dtree-fetch query (get-dtree (predicate query))\n"
"               nil 0 nil most-positive-fixnum))\n"
"```"
msgstr ""

#: in/chapter14.md:742
msgid ""
"`dtree-fetch` must be passed the query and the dtree, of course, but it is "
"also passed four additional arguments.\n"
"First, we have to accumulate matches indexed under variables as we are "
"searching through the dtree.\n"
"So two arguments are used to pass the actual matches and a count of their "
"total number.\n"
"Second, we want `dtree-fetch` to return the shortest possible index, so we "
"pass it the shortest answer found so far, and the size of the shortest "
"answer.\n"
"That way, as it is making its way down the tree, accumulating values indexed "
"under variables, it can be continually comparing the size of the evolving "
"answer with the best answer found so far."
msgstr ""
"`dtree-fetch`, конечно, должна передавать запрос и dtree, но ей также "
"передаются четыре дополнительных аргумента.\n"
"Во-первых, мы должны накапливать совпадения, индексированные по переменным, "
"когда мы ищем в dtree.\n"
"Таким образом, два аргумента используются для передачи фактических "
"совпадений и подсчета их общего количества.\n"
"Во-вторых, мы хотим, чтобы `dtree-fetch` возвращала самый короткий из "
"возможных индексов, поэтому мы передаем ей самый короткий ответ, найденный "
"на данный момент, и размер самого короткого ответа.\n"
"Таким образом, по мере того, как она продвигается вниз по дереву, накапливая "
"значения, индексированные по переменным, она может постоянно сравнивать "
"размер развивающегося ответа с лучшим ответом, найденным на данный момент."

#: in/chapter14.md:747
msgid ""
"We could use nlists to pass around count/values pairs, but nlists only "
"support a push operation, where one new item is added.\n"
"We need to append together lists of values coming from the variable indices "
"with values indexed under an atom.\n"
"Append is expensive, so instead we make a list-of-lists and keep the count "
"in a separate variable.\n"
"When we are done, `dtree-fetch` and hence `fetch` does a multiple-value "
"return, yielding the list-of-lists and the total count."
msgstr ""
"Мы могли бы использовать nlists для передачи пар счет/значения, но nlists "
"поддерживают только операцию push, когда добавляется один новый элемент.\n"
"Нам нужно объединить списки значений, поступающих из индексов переменных, со "
"значениями, индексированными под атомом.\n"
"Добавление(append) стоит дорого, поэтому вместо этого мы составляем список "
"списков и сохраняем счетчик в отдельной переменной.\n"
"Когда мы закончим, `dtree-fetch` и, следовательно, `fetch` возвращают "
"несколько значений, в результате чего получается список списков и общее "
"количество."

#: in/chapter14.md:754
msgid ""
"There are four cases to consider in `dtree-fetch.` If the dtree is null or "
"the query pattern is either null or a variable, then nothing will be "
"indexed, so we should just return the best answer found so far.\n"
"Otherwise, we bind `var-n` and `var-list` to the count and list-of-lists of "
"variable matches found so far, including at the current node.\n"
"If the count `var-n` is greater than the best count so far, then there is no "
"sense continuing, and we return the best answer found.\n"
"Otherwise we look at the query pattern.\n"
"If it is an atom, we use `dtree-atom-fetch` to return either the current "
"index (along with the accumulated variable index) or the accumulated best "
"answer, whichever is shorter.\n"
"If the query is a cons, then we use `dtree-fetch` on the first part of the "
"cons, yielding a new best answer, which is passed along to the call of "
"`dtree-fetch` on the rest of the cons."
msgstr ""
"В `dtree-fetch` следует рассмотреть четыре случая. Если dtree имеет значение "
"null, или  образец запроса является null, либо переменная, то ничего не "
"будет проиндексировано, поэтому мы должны просто вернуть лучший ответ, "
"найденный на данный момент.\n"
"В противном случае мы привязываем var-n и var-list к количеству и списку "
"списков совпадений переменных, найденных на данный момент, в том числе на "
"текущем узле.\n"
"Если счетчик `var-n` больше, чем лучший до сих пор, то продолжать нет "
"смысла, и мы возвращаем лучший найденный ответ.\n"
"В противном случае мы смотрим на образец запроса.\n"
"Если это атом, мы используем `dtree-atom-fetch` для возврата либо текущего "
"индекса (вместе с накопленным индексом переменной), либо накопленного "
"лучшего ответа, в зависимости от того, какой из них короче.\n"
"Если запрос является cons, то мы используем `dtree-fetch` для первой части "
"cons, давая новый лучший ответ, который передается при вызове `dtree-fetch` "
"для остатка(rest) cons."

#: in/chapter14.md:776
msgid ""
"```lisp\n"
"(defun dtree-fetch (pat dtree var-list-in var-n-in best-list best-n)\n"
"  \"Return two values: a list-of-lists of possible matches to pat,\n"
"  and the number of elements in the list-of-lists.\"\n"
"  (if (or (null dtree) (null pat) (variable-p pat))\n"
"      (values best-list best-n)\n"
"      (let* ((var-nlist (dtree-var dtree))\n"
"             (var-n (+ var-n-in (nlist-n var-nlist)))\n"
"             (var-list (if (null (nlist-list var-nlist))\n"
"                           var-list-in\n"
"                           (cons (nlist-list var-nlist)\n"
"                                 var-list-in))))\n"
"        (cond\n"
"          ((>= var-n best-n) (values best-list best-n))\n"
"          ((atom pat) (dtree-atom-fetch pat dtree var-list var-n\n"
"                                        best-list best-n))\n"
"          (t (multiple-value-bind (list1 n1)\n"
"                 (dtree-fetch (first pat) (dtree-first dtree)\n"
"                              var-list var-n best-list best-n)\n"
"               (dtree-fetch (rest pat) (dtree-rest dtree)\n"
"                            var-list var-n list1 n1)))))))"
msgstr ""

#: in/chapter14.md:788
msgid ""
"(defun dtree-atom-fetch (atom dtree var-list var-n best-list best-n)\n"
"  \"Return the answers indexed at this atom (along with the vars),\n"
"  or return the previous best answer, if it is better.\"\n"
"  (let ((atom-nlist (lookup atom (dtree-atoms dtree))))\n"
"    (cond\n"
"      ((or (null atom-nlist) (null (nlist-list atom-nlist)))\n"
"       (values var-list var-n))\n"
"      ((and atom-nlist (< (incf var-n (nlist-n atom-nlist)) best-n))\n"
"       (values (cons (nlist-list atom-nlist) var-list) var-n))\n"
"      (t (values best-list best-n)))))\n"
"```"
msgstr ""

#: in/chapter14.md:791
msgid ""
"Here we see a call to `fetch` on the data base created by `test-index`.\n"
"It returns two values: a list-of-lists of facts, and the total number of "
"facts, three."
msgstr ""
"Здесь мы видим вызов `fetch` в базе данных, созданной `test-index`.\n"
"Она возвращает два значения: список-списков фактов и общее количество фактов "
"- три."

#: in/chapter14.md:798
msgid ""
"```lisp\n"
"(fetch '(p ? c))\n"
"(((P B C) (P A C))\n"
"  ((P A ?X)))\n"
"3\n"
"```"
msgstr ""

#: in/chapter14.md:805
msgid ""
"Now let's stop and see what we have accomplished.\n"
"The functions `fetch and dtree-fetch` fulfill their contract of returning "
"potential matches.\n"
"However, we still need to integrate the dtree facility with Prolog.\n"
"We need to go through the potential matches and determine which candidates "
"are actual matches.\n"
"For simplicity we will use the version of `unify` with binding lists defined "
"in [section 11.2](B978008057115750011X.xhtml#s0020).\n"
"(It is also possible to construct a more efficient version that uses the "
"compiler and the destructive function `unify!`.)"
msgstr ""
"А теперь остановимся и посмотрим, чего мы достигли.\n"
"Функции `fetch и dtree-fetch` выполняют свой контракт на возврат "
"потенциальных совпадений.\n"
"Однако нам все еще нужно интегрировать функциональность dtree с Prolog.\n"
"Нам нужно просмотреть потенциальные совпадения и определить, какие из "
"кандидатов действительно совпадают.\n"
"Для простоты мы будем использовать версию `unify` со списками привязки, "
"определенными в [разделе 11.2] (B978008057115750011X.xhtml#s0020).\n"
"(Также можно создать более эффективную версию, которая использует компилятор "
"и деструктивную функцию `unify!`.)"

#: in/chapter14.md:808
msgid ""
"The function `mapc-retrieve` calls `fetch` to get a list-of-lists of "
"potential matches and then calls `unify` to see if the match is a true one.\n"
"If the match is true, it calls the supplied function with the binding list "
"that represents the unification as the argument, `mapc-retrieve` is "
"proclaimed `inline` so that functions passed to it can also be compiled in "
"place."
msgstr ""
"Функция `mapc-retrieve` вызывает `fetch`, чтобы получить список списков "
"потенциальных совпадений, а затем вызывает `unify`, чтобы проверить, "
"является ли совпадение истинным.\n"
"Если совпадение истинно, она вызывает предоставленную функцию со списком "
"привязки, который представляет объединение в качестве аргумента, `mapc-"
"retrieve` объявляетсяс `inline`, так что переданные ему функции также могут "
"быть скомпилированы на месте."

#: in/chapter14.md:811
msgid ""
"```lisp\n"
"(proclaim '(inline mapc-retrieve))"
msgstr ""

#: in/chapter14.md:821
msgid ""
"(defun mapc-retrieve (fn query)\n"
"  \"For every fact that matches the query,\n"
"  apply the function to the binding list.\"\n"
"  (dolist (bucket (fetch query))\n"
"    (dolist (answer bucket)\n"
"      (let ((bindings (unify query answer)))\n"
"        (unless (eq bindings fail)\n"
"          (funcall fn bindings))))))\n"
"```"
msgstr ""

#: in/chapter14.md:824
msgid ""
"There are many ways to use this retriever.\n"
"The function `retrieve` returns a list of the matching binding lists, and "
"`retrieve-matches` substitutes each binding list into the original query so "
"that the resuit is a list of expressions that unify with the query."
msgstr ""
"Есть много способов использовать этот retriever(извлекатель).\n"
"Функция `retrieve` возвращает список совпадающих списков привязки, а "
"`retrieve-matches` заменяет каждый список привязки в исходном запросе, так "
"что результат является списком выражений, которые объединяются с запросом."

#: in/chapter14.md:832
msgid ""
"```lisp\n"
"(defun retrieve (query)\n"
"  \"Find all facts that match query.  Return a list of bindings.\"\n"
"  (let ((answers nil))\n"
"    (mapc-retrieve #'(lambda (bindings) (push bindings answers))\n"
"                   query)\n"
"    answers))"
msgstr ""

#: in/chapter14.md:839
msgid ""
"(defun retrieve-matches (query)\n"
"  \"Find all facts that match query.\n"
"  Return a list of expressions that match the query.\"\n"
"  (mapcar #'(lambda (bindings) (subst-bindings bindings query))\n"
"          (retrieve query)))\n"
"```"
msgstr ""

#: in/chapter14.md:846
msgid ""
"There is one further complication to consider.\n"
"Recall that in our original Prolog interpreter, the function prove had to "
"rename the variables in each clause as it retrieved it from the data base.\n"
"This was to insure that there was no conflict between the variables in the "
"query and the variables in the clause.\n"
"We could do that in `retrieve`.\n"
"However, if we assume that the expressions indexed in discrimination trees "
"are tablelike rather than rulelike and thus are not recursive, then we can "
"get away with renaming the variables only once, when they are entered into "
"the data base.\n"
"This is done by changing `index`:"
msgstr ""
"Следует учитывать еще одну сложность.\n"
"Напомним, что в нашем исходном интерпретаторе Пролога функция `verify` "
"должна была переименовывать переменные в каждом предложении при получении их "
"из базы данных.\n"
"Это должно было гарантировать отсутствие конфликта между переменными в "
"запросе и переменными в предложении.\n"
"Мы могли бы сделать это в `retrieve`.\n"
"Однако, если мы предположим, что выражения, проиндексированные в деревьях "
"дискриминации, похожи на таблицы, а не на правила и, следовательно, не "
"рекурсивны, тогда мы можем переименовать переменные только один раз, когда "
"они вводятся в базу данных.\n"
"Это делается путем изменения `index`:"

#: in/chapter14.md:850
msgid ""
"```lisp\n"
"(defun index (key)\n"
"```"
msgstr ""

#: in/chapter14.md:853
msgctxt "in/chapter14.md:853"
msgid ""
"`  \"Store key in a dtree node.\n"
"Key must be (predicate . args);`"
msgstr ""

#: in/chapter14.md:859
msgid ""
"```lisp\n"
"  it is stored in the predicate's dtree.\"\n"
"  (dtree-index key (rename-variables key) ; store unique vars\n"
"          (get-dtree (predicate key))))\n"
"```"
msgstr ""

#: in/chapter14.md:861
msgid ""
"With the new `index` in place, and after calling `test-index` to rebuild the "
"data base, we are now ready to test the retrieval mechanism:"
msgstr ""
"С новым `index` и после вызова `test-index` для перестройки базы данных мы "
"готовы протестировать механизм извлечения:"

#: in/chapter14.md:876
msgid ""
"```lisp\n"
"> (fetch '(p ?x c))\n"
"(((P B C) (P A C))\n"
"  ((P A ?X3408)))\n"
"3\n"
"> (retrieve '(p ?x c))\n"
"(((?X3408 . C) (?X . A))\n"
"  ((?X . A))\n"
"  ((?X . B)))\n"
"> (retrieve-matches '(p ?x c))\n"
"((P A C) (P A C) (P B C))\n"
"> (retrieve-matches '(p ?x (?fn c)))\n"
"((P A (?FN C)) (P A (F C)) (P B (F C)))\n"
"```"
msgstr ""

#: in/chapter14.md:883
msgid ""
"Actually, it is better to use `mapc-retrieve` when possible, since it "
"doesn't cons up answers the way `retrieve` and `retrieve-matches` do.\n"
"The macro `query-bind` is provided as a nice interface to `mapc-retrieve`.\n"
"The macro takes as arguments a list of variables to bind, a query, and one "
"or more forms to apply to each retrieved answer.\n"
"Within this list of forms, the variables will be bound to the values that "
"satisfy the query.\n"
"The syntax was chosen to be the same as `multiple-value-bind`.\n"
"Here we see a typical use of `query-bind`, its resuit, and its macro-"
"expansion:"
msgstr ""
"На самом деле, по возможности лучше использовать `mapc-retrieve`, поскольку "
"она не требует ответов, как это делают `retrieve` и `retrieve-matches`.\n"
"Макрос `query-bind` предоставляется как удобный интерфейс для `mapc-"
"retrieve`.\n"
"Макрос принимает в качестве аргументов список переменных для связывания, "
"запрос и одну или несколько форм для применения к каждому полученному "
"ответу.\n"
"В этом списке форм переменные будут привязаны к значениям, удовлетворяющим "
"запросу.\n"
"Синтаксис был выбран таким же, как у `multiple-value-bind`.\n"
"Здесь мы видим типичное использование `query-bind`, его результат и его "
"макрорасширение:"

#: in/chapter14.md:887
msgid ""
"```lisp\n"
"> (query-bind (?x ?fn) '(p ?x (?fn c))\n"
"```"
msgstr ""

#: in/chapter14.md:889
msgid "`  (format t \"~&P holds between ~a and ~a of c.\" ?x ?fn))`=>"
msgstr ""

#: in/chapter14.md:902
msgid ""
"```lisp\n"
"P holds between B and F of c.\n"
"P holds between A and F of c.\n"
"P holds between A and ?FN of c.\n"
"NIL\n"
"= (mapc-retrieve\n"
"  #'(lambda (#:bindings6369)\n"
"    (let ((?x (subst-bindings #:bindings6369 *?x))\n"
"            (?fn (subst-bindings #:bindings6369 *?fn)))\n"
"      (format t \"~&P holds between ~a and ~a of c.\" ?x ?fn)))\n"
"  '(p ?x (?fn c)))\n"
"```"
msgstr ""

#: in/chapter14.md:904
msgid "Here is the implementation:"
msgstr "Вот реализация:"

#: in/chapter14.md:921
msgid ""
"```lisp\n"
"(defmacro query-bind (variables query &body body)\n"
"  \"Execute the body for each match to the query.\n"
"  Within the body, bind each variable.\"\n"
"  (let* ((bindings (gensym \"BINDINGS\"))\n"
"         (vars-and-vals\n"
"           (mapcar\n"
"             #'(lambda (var)\n"
"                 (list var `(subst-bindings ,bindings ',var)))\n"
"             variables)))\n"
"    `(mapc-retrieve\n"
"       #'(lambda (,bindings)\n"
"           (let ,vars-and-vals\n"
"             ,@body))\n"
"       ,query)))\n"
"```"
msgstr ""

#: in/chapter14.md:923
msgid "## 14.9 A Solution to the Completeness Problem"
msgstr "## 14.9 Решение проблемы полноты"

#: in/chapter14.md:927
msgid ""
"We saw in [chapter 6](B9780080571157500066.xhtml) that iterative deepening "
"is an efficient way to cover a search space without falling into an infinite "
"loop.\n"
"Iterative deepening can also be used to guide the search in Prolog.\n"
"It will insure that all valid answers are found eventually, but it won't "
"turn an infinite search space into a finite one."
msgstr ""
"Мы видели в [главе 6](B9780080571157500066.xhtml), что итеративное "
"углубление - это эффективный способ охватить пространство поиска без "
"попадания в бесконечный цикл.\n"
"Итеративное углубление также можно использовать для направления поиска в "
"Прологе.\n"
"Оно гарантирует, что в конечном итоге будут найдены все верные ответы, но не "
"превратит бесконечное пространство поиска в конечное."

#: in/chapter14.md:933
msgid ""
"In the interpreter, iterative deepening is implemented by passing an extra "
"argument to `prove` and `prove-all` to indicate the depth remaining to be "
"searched.\n"
"When that argument is zero, the search is eut off, and the proof falls.\n"
"On the next iteration the bounds will be increased and the proof may "
"succeed.\n"
"If the search is never eut off by a depth bound, then there is no reason to "
"go on to the next iteration, because all proofs have already been found.\n"
"The special variable `*search-cut-off*` keeps track of this."
msgstr ""
"В интерпретаторе итеративное углубление реализуется путем передачи "
"дополнительного аргумента для `prove` и `prove-all`, чтобы указать "
"оставшуюся глубину для поиска.\n"
"Когда этот аргумент равен нулю, поиск прекращается, и доказательство "
"падает.\n"
"На следующей итерации границы будут увеличены, и доказательство может быть "
"успешным.\n"
"Если поиск никогда не завершается границами глубины, то нет причин "
"переходить к следующей итерации, потому что все доказательства уже найдены.\n"
"Специальная переменная `*search-cut-off*` отслеживает это."

#: in/chapter14.md:936
msgid ""
"```lisp\n"
"(defvar *search-cut-off* nil \"Has the search been stopped?\")"
msgstr ""

#: in/chapter14.md:943
msgid ""
"(defun prove-all (goals bindings depth)\n"
"  \"Find a solution to the conjunction of goals.\"\n"
"  ;; This version just passes the depth on to PROVE.\n"
"  (cond ((eq bindings fail) fail)\n"
"        ((null goals) bindings)\n"
"        (t (prove (first goals) bindings (rest goals) depth))))"
msgstr ""

#: in/chapter14.md:965
msgid ""
"(defun prove (goal bindings other-goals depth)\n"
"  \"Return a list of possible solutions to goal.\"\n"
"  ;; Check if the depth bound has been exceeded\n"
"  (if (= depth 0)                            ;***\n"
"      (progn (setf *search-cut-off* t)       ;***\n"
"             fail)                           ;***\n"
"      (let ((clauses (get-clauses (predicate goal))))\n"
"        (if (listp clauses)\n"
"            (some\n"
"              #'(lambda (clause)\n"
"                  (let ((new-clause (rename-variables clause)))\n"
"                    (prove-all\n"
"                      (append (clause-body new-clause) other-goals)\n"
"                      (unify goal (clause-head new-clause) bindings)\n"
"                      (- depth 1))))          ;***\n"
"              clauses)\n"
"            ;; The predicate's \"clauses\" can be an atom:\n"
"            ;; a primitive function to call\n"
"            (funcall clauses (rest goal) bindings\n"
"                     other-goals depth)))))   ;***\n"
"```"
msgstr ""

#: in/chapter14.md:969
msgid ""
"`prove` and `prove-all` now implement search cutoff, but we need something "
"to control the iterative deepening of the search.\n"
"First we define parameters to control the iteration: one for the initial "
"depth, one for the maximum depth, and one for the increment between "
"iterations.\n"
"Setting the initial and increment values to one will make the results come "
"out in strict breadth-first order, but will duplicate more effort than a "
"slightly larger value."
msgstr ""
"`prove` и `prove-all` теперь реализуют ограничение поиска, но нам нужно что-"
"то, чтобы контролировать итеративное углубление поиска.\n"
"Сначала мы определяем параметры для управления итерацией: один для начальной "
"глубины, один для максимальной глубины и один для приращения между "
"итерациями.\n"
"Установка начального значения и значения приращения в единицу приведет к "
"тому, что результаты будут выводиться в строгом порядке в ширину, но будут "
"дублировать больше усилий, чем немного большее значение."

#: in/chapter14.md:978
msgid ""
"```lisp\n"
"(defparameter *depth-start* 5\n"
"  \"The depth of the first round of iterative search.\")\n"
"(defparameter *depth-incr* 5\n"
"  \"Increase each iteration of the search by this amount.\")\n"
"(defparameter *depth-max* most-positive-fixnum\n"
"  \"The deepest we will ever search.\")\n"
"```"
msgstr ""

#: in/chapter14.md:982
msgid ""
"A new version of `top-level-prove` will be used to control the iteration.\n"
"It calls `prove-all` for all depths from the starting depth to the maximum "
"depth, increasing by the increment.\n"
"However, it only proceeds to the next iteration if the search was eut off at "
"some point in the previous iteration."
msgstr ""
"Новая версия `top-level-prove` будет использоваться для управления "
"итерацией.\n"
"Он вызывает `prove-all` для всех глубин от начальной до максимальной, "
"увеличиваясь с шагом.\n"
"Однако он переходит к следующей итерации, только если поиск был прекращен в "
"какой-то момент на предыдущей итерации."

#: in/chapter14.md:994
msgid ""
"```lisp\n"
"(defun top-level-prove (goals)\n"
"  (let ((all-goals\n"
"          `(,@goals (show-prolog-vars ,@(variables-in goals)))))\n"
"    (loop for depth from *depth-start* to *depth-max* by *depth-incr*\n"
"          while (let ((*search-cut-off* nil))\n"
"                  (prove-all all-goals no-bindings depth)\n"
"                  *search-cut-off*)))\n"
"  (format t \"~&No.\")\n"
"  (values))\n"
"```"
msgstr ""

#: in/chapter14.md:998
msgid ""
"There is one final complication.\n"
"When we increase the depth of search, we may find some new proof s, but we "
"will also find all the old proof s that were found on the previous "
"iteration.\n"
"We can modify `show-prolog-vars` to only print proofs that are found with a "
"depth less than the increment-that is, those that were not found on the "
"previous iteration."
msgstr ""
"Есть еще одно осложнение.\n"
"Когда мы увеличиваем глубину поиска, мы можем найти новые доказательства s, "
"но мы также найдем все старые доказательства, которые были найдены на "
"предыдущей итерации.\n"
"Мы можем изменить `show-prolog-vars`, чтобы печатать только те "
"доказательства, которые были найдены с глубиной меньше, чем приращение, то "
"есть те, которые не были найдены на предыдущей итерации."

#: in/chapter14.md:1015
msgid ""
"```lisp\n"
"(defun show-prolog-vars (vars bindings other-goals depth)\n"
"  \"Print each variable with its binding.\n"
"  Then ask the user if more solutions are desired.\"\n"
"  (if (> depth *depth-incr*)\n"
"      fail\n"
"      (progn\n"
"        (if (null vars)\n"
"            (format t \"~&Yes\")\n"
"            (dolist (var vars)\n"
"              (format t \"~&~a = ~a\" var\n"
"                      (subst-bindings bindings var))))\n"
"        (if (continue-p)\n"
"            fail\n"
"            (prove-all other-goals bindings depth)))))\n"
"```"
msgstr ""

#: in/chapter14.md:1018
msgid ""
"To test that this works, try setting `*depth-max*` to 5 and running the "
"following assertions and query.\n"
"The infinite loop is avoided, and the first four solutions are found."
msgstr ""
"Чтобы проверить, что это работает, попробуйте установить для `*depth-max*` "
"значение 5 и выполнить следующие утверждения и запросы.\n"
"Бесконечный цикл избегается, и первые четыре решения найдены."

#: in/chapter14.md:1029
msgid ""
"```lisp\n"
"(<- (natural 0))\n"
"(<- (natural (1  + ?n)) (natural ?n))\n"
"> (?- (natural ?n))\n"
"?N = 0;\n"
"?N = (1  + 0);\n"
"?N = (1  + (1  + 0));\n"
"?N = (1  + (1  + (1  + 0)));\n"
"No.\n"
"```"
msgstr ""

#: in/chapter14.md:1031
msgid "## 14.10 Solutions to the Expressiveness Problems"
msgstr "## 14.10 Решения проблем выразительности"

#: in/chapter14.md:1033
msgid ""
"In this section we present solutions to three of the limitations described "
"above:"
msgstr ""
"В этом разделе мы представляем решения трех описанных выше ограничений:"

#: in/chapter14.md:1035
msgid "*   Treatment of (limited) higher-order predications."
msgstr "*   Обработка (ограниченных) предсказаний более высокого порядка."

#: in/chapter14.md:1037
msgid "*   Introduction of a frame-based syntax."
msgstr "*   Введение синтаксиса на основе фреймов."

#: in/chapter14.md:1039
msgid "*   Support for possible worlds, negation, and disjunction."
msgstr "*   Поддержка возможных миров, отрицания и дизъюнкции."

#: in/chapter14.md:1041
msgid ""
"We also introduce a way to attach functions to predicates to do forward-"
"chaining and error detection, and we discuss ways to extend unification to "
"handle Skolem constants and other problems."
msgstr ""
"Мы также представляем способ присоединения функций к предикатам для "
"выполнения прямой цепочки и обнаружения ошибок, а также обсуждаем способы "
"расширения унификации для обработки констант Сколема и других проблем."

#: in/chapter14.md:1043
msgid "### Higher-Order Predications"
msgstr "### Предсказания высшего порядка"

#: in/chapter14.md:1046
msgid ""
"First we will tackle the problem of answering questions like \"What kinds of "
"animais are there?\" Paradoxically, the key to allowing more expressiveness "
"in this case is to invent a new, more limited language and insist that all "
"assertions and queries are made in that language.\n"
"That way, queries that would have been higher-order in the original language "
"become first-order in the restricted language."
msgstr ""
"Сначала мы займемся проблемой ответов на вопросы типа \"What kinds of "
"animais are there?\"(Какие виды животных существуют?). Как это ни "
"парадоксально, ключом к большей выразительности в этом случае является "
"изобретение нового, более ограниченного языка и требование, чтобы все "
"утверждения и запросы делались на этом языке.\n"
"Таким образом, запросы, которые были бы более высокого порядка на исходном "
"языке, становятся первого порядка на ограниченном языке."

#: in/chapter14.md:1049
msgid ""
"The language admits three types of objects: *categories, relations*, and "
"*individuals.* A category corresponds to a one-place predicate, a relation "
"to a two-place predicate, and an individual to constant, or zero-place "
"predicate.\n"
"Statements in the language must have one of five primitive operators: `sub, "
"rel, ind, val`, and `and.` They have the following form:"
msgstr ""
"Язык допускает три типа объектов: *категории, отношения* и *индивиды.* "
"Категория(category) соответствует одноместному предикату, "
"отношение(relation) к двухместному предикату и индивидуум(individual) "
"константному или нулевому предикату.\n"
"Выражения на языке должны иметь один из пяти примитивных операторов: `sub, "
"rel, ind, val` и `and`. Они имеют следующую форму:"

#: in/chapter14.md:1051
msgid "`(sub`*subcategory super category*)"
msgstr ""

#: in/chapter14.md:1053
msgid "`(rel`*relation domain-category range-category*)"
msgstr ""

#: in/chapter14.md:1055
msgid "`(ind`*individual category*)"
msgstr ""

#: in/chapter14.md:1057
msgid "`(val`*relation individual value*)"
msgstr ""

#: in/chapter14.md:1059
msgid "`(and`*assertion...*)"
msgstr ""

#: in/chapter14.md:1061
msgid ""
"The following table gives some examples, along with English translations:"
msgstr ""
"В следующей таблице приведены некоторые примеры, а также их перевод на "
"английский язык:"

#: in/chapter14.md:1069
msgid ""
"| []()                         "
"|                                                                |\n"
"|------------------------------|----------------------------------------------------------------|\n"
"| `(sub dog animal)`           | Dog is a kind of "
"animal.                                       |\n"
"| `(rel birthday animal date)` | The birthday relation holds between each "
"animal and some date. |\n"
"| `(ind fido dog)`             | The individual Fido is categorized as a "
"dog.                   |\n"
"| `(val birthday fido july-1)` | The birthday of Fido is "
"July-1.                                |\n"
"| `(and *AB*)`                 | Both *A* and *B* are "
"true.                                     |"
msgstr ""

#: in/chapter14.md:1073
msgid ""
"For those who feel more comfortable with predicate calculus, the following "
"table gives the formal definition of each primitive.\n"
"The most complicated definition is for rel.\n"
"The form (rel *R A B*) means that every *R* holds between an individual of "
"*A* and an individual of *B,* and furthermore that every individual of *A* "
"participates in at least one *R* relation."
msgstr ""
"Для тех, кто чувствует себя более комфортно с исчислением предикатов, "
"следующая таблица дает формальное определение каждого примитива.\n"
"Наиболее сложное определение для rel.\n"
"Форма (rel *R A B*) означает, что каждое *R* выполняется между индивидуумом "
"из *A* и индивидуумом из *B* и, кроме того, что каждый индивидуум из *A* "
"участвует по крайней мере в одном отношении *R*."

#: in/chapter14.md:1081
msgid ""
"| []()            "
"|                                                                                                                    "
"|\n"
"|-----------------|--------------------------------------------------------------------------------------------------------------------|\n"
"| `(sub`*AB*)     | &forall;*x:A*(*x*) &Superset; "
"*B*(*x*)                                                                             "
"|\n"
"| `(rel`*RAB*)    | &forall;*x,y* : *R*(*x,y*) &Superset; *A*(*x*) A "
"*B*(*y*) *^*&forall;*xA*(*x*) &Superset; &exist;*y* : *R*(*x, y*) |\n"
"| `(ind`*IC)*     | "
"*C*(*I*)                                                                                                           "
"|\n"
"| `(val`*RIV*)    | *R*(*I, "
"V*)                                                                                                        "
"|\n"
"| `(and`*P Q...*) | *P ^ Q..."
"*                                                                                                         "
"|"
msgstr ""

#: in/chapter14.md:1086
msgid ""
"Queries in the language, not surprisingly, have the same form as assertions, "
"except that they may contain variables as well as constants.\n"
"Thus, to find out what kinds of animais there are, use the query `(sub ?kind "
"animal)`.\n"
"To find out what individual animais there are, use the query `(ind ?x "
"animal)`.\n"
"To find out what individual animais of what kinds there are, use:"
msgstr ""
"Неудивительно, что запросы в языке имеют ту же форму, что и утверждения, за "
"исключением того, что они могут содержать переменные, а также константы.\n"
"Таким образом, чтобы узнать, какие существуют виды животных, используйте "
"запрос `(sub ?kind animal)`.\n"
"Чтобы узнать, какие есть отдельные(индивидуальные) животные, используйте "
"запрос `(ind ?x animal)`.\n"
"Чтобы узнать, какие существуют отдельные животные, каких видов, используйте:"

#: in/chapter14.md:1090
msgid ""
"```lisp\n"
"(and (sub ?kind animal) (ind ?x ?kind))\n"
"```"
msgstr ""

#: in/chapter14.md:1094
msgid ""
"The implemention of this new language can be based directly on the previous "
"implementation of dtrees.\n"
"Each assertion is stored as a fact in a dtree, except that the components of "
"an and assertion are stored separately.\n"
"The function `add-fact` does this:"
msgstr ""
"Реализация этого нового языка может быть основана непосредственно на "
"предыдущей реализации dtrees.\n"
"Каждое утверждение хранится как факт в dtree, за исключением того, что "
"компоненты утверждения и хранятся отдельно.\n"
"Функция `add-fact` делает следующее:"

#: in/chapter14.md:1102
msgid ""
"```lisp\n"
"(defun add-fact (fact)\n"
"  \"Add the fact to the data base.\"\n"
"  (if (eq (predicate fact) 'and)\n"
"      (mapc #'add-fact (args fact))\n"
"      (index fact)))\n"
"```"
msgstr ""

#: in/chapter14.md:1105
msgid ""
"Querying this new data base consists of querying the dtree just as before, "
"but with a special case for conjunctive (and) queries.\n"
"Conceptually, the function to do this, `retrieve-fact`, should be as simple "
"as the following:"
msgstr ""
"Запросы к этой новой базе данных состоят из запросов к dtree, как и раньше, "
"но с особым случаем для конъюнктивных (and/и) запросов.\n"
"По идее, функция для этого, `retrieve-fact`, должна быть такой же простой, "
"как следующая:"

#: in/chapter14.md:1109
msgid ""
"```lisp\n"
"(defun retrieve-fact (query)\n"
"```"
msgstr ""

#: in/chapter14.md:1112
msgid ""
"`  \"Find all facts that match query.\n"
"Return a list of bindings.`"
msgstr ""

#: in/chapter14.md:1115
msgid ""
"`  Warning!!\n"
"this version is incomplete.\"`"
msgstr ""

#: in/chapter14.md:1121
msgid ""
"```lisp\n"
"  (if (eq (predicate query) 'and)\n"
"    (retrieve-conjunction (args query))\n"
"    (retrieve query bindings)))\n"
"```"
msgstr ""

#: in/chapter14.md:1126
msgid ""
"Unfortunately, there are some complications.\n"
"Think about what must be done in `retrieve-conjunction`.\n"
"It is passed a list of conjuncts and must return a list of binding lists, "
"where each binding list satisfies the query.\n"
"For example, to find out what people were born on July Ist, we could use the "
"query:"
msgstr ""
"К сожалению, есть некоторые сложности.\n"
"Подумайте о том, что должно быть сделано в `retrieve-conjunction`.\n"
"Ему передается список конъюнктов, и он должен возвращать список списков "
"привязок, где каждый список привязок удовлетворяет запросу.\n"
"Например, чтобы узнать, какие люди родились 1 июля, мы могли бы использовать "
"запрос:"

#: in/chapter14.md:1130
msgid ""
"```lisp\n"
"(and (val birthday ?p july-1) (ind ?p person))\n"
"```"
msgstr ""

#: in/chapter14.md:1137
msgid ""
"`retrieve-conjunction` could solve this problem by first calling `retrieve-"
"fact` on `(val birthday ?p july-1)`.\n"
"Once that is done, there is only one conjunct remaining, but in general "
"there could be several, so we need to call `retrieve-conjunction` "
"recursively with two arguments: the remainingconjuncts, and the resultthat "
"`retrieve-fact` gave for the first solution.\n"
"Since `retrieve-fact` returns a list of binding lists, it will be easiest if "
"`retrieve-conjunction` accepts such a list as its second argument.\n"
"Furthermore, when it comes time to call `retrieve-fact` on the second "
"conjunct, we will want to respect the bindings set up by the first "
"conjunct.\n"
"So `retrieve-fact` must accept a binding list as its second argument.\n"
"Thus we have:"
msgstr ""
"`retrieve-conjunction` может решить эту проблему, сначала вызвав `retrieve-"
"fact` на `(val birthday ?p july-1)`.\n"
"Как только это будет сделано, останется только один конъюнкт, но в целом их "
"может быть несколько, поэтому нам нужно рекурсивно вызвать `retrieve-"
"conjunction` с двумя аргументами: оставшиеся конъюнкты и результат, который "
"`retrieve-fact` дал для первого решения.\n"
"Так как `retrieve-fact` возвращает список списков привязки, будет проще, "
"если `retrieve-conjunction` примет такой список в качестве второго "
"аргумента.\n"
"Более того, когда придет время вызвать `retrieve-fact` для второго "
"конъюнкта, мы захотим уважать привязки, установленные первым конъюнктом.\n"
"Таким образом, `retrieve-fact` должно принимать список привязки в качестве "
"второго аргумента.\n"
"Таким образом, мы имеем:"

#: in/chapter14.md:1144
msgid ""
"```lisp\n"
"(defun retrieve-fact (query &optional (bindings no-bindings))\n"
"  \"Find all facts that match query.  Return a list of bindings.\"\n"
"  (if (eq (predicate query) 'and)\n"
"      (retrieve-conjunction (args query) (list bindings))\n"
"      (retrieve query bindings)))"
msgstr ""

#: in/chapter14.md:1158
msgid ""
"(defun retrieve-conjunction (conjuncts bindings-lists)\n"
"  \"Return a list of binding lists satisfying the conjuncts.\"\n"
"  (mapcan\n"
"    #'(lambda (bindings)\n"
"        (cond ((eq bindings fail) nil)\n"
"              ((null conjuncts) (list bindings))\n"
"              (t (retrieve-conjunction\n"
"                   (rest conjuncts)\n"
"                   (retrieve-fact\n"
"                     (subst-bindings bindings (first conjuncts))\n"
"                     bindings)))))\n"
"    bindings-lists))\n"
"```"
msgstr ""

#: in/chapter14.md:1162
msgid ""
"Notice that `retrieve` and therefore `mapc-retrieve` now also must accept a "
"binding list.\n"
"The changes to them are shown in the following.\n"
"In each case the extra argument is made optional so that previously written "
"functions that call these functions without passing in the extra argument "
"will still work."
msgstr ""
"Обратите внимание, что `retrieve` и, следовательно, `mapc-retrieve` теперь "
"также должны принимать список привязки.\n"
"Изменения в них показаны ниже.\n"
"В каждом случае дополнительный аргумент делается необязательным, так чтобы "
"ранее написанные функции, вызывающие эти функции без передачи "
"дополнительного аргумента, все равно работали."

#: in/chapter14.md:1172
msgid ""
"```lisp\n"
"(defun mapc-retrieve (fn query &optional (bindings no-bindings))\n"
"  \"For every fact that matches the query,\n"
"  apply the function to the binding list.\"\n"
"  (dolist (bucket (fetch query))\n"
"    (dolist (answer bucket)\n"
"      (let ((new-bindings (unify query answer bindings)))\n"
"        (unless (eq new-bindings fail)\n"
"          (funcall fn new-bindings))))))"
msgstr ""

#: in/chapter14.md:1180
msgid ""
"(defun retrieve (query &optional (bindings no-bindings))\n"
"  \"Find all facts that match query.  Return a list of bindings.\"\n"
"  (let ((answers nil))\n"
"    (mapc-retrieve #'(lambda (bindings) (push bindings answers))\n"
"                   query bindings)\n"
"    answers))\n"
"```"
msgstr ""

#: in/chapter14.md:1183
msgid ""
"Now `add-fact` and `retrieve-fact` comprise all we need to implement the "
"language.\n"
"Here is a short example where `add-fact` is used to add facts about bears "
"and dogs, both as individuals and as species:"
msgstr ""
"Теперь `add-fact` и `retrieve-fact` - это все, что нам нужно для реализации "
"языка.\n"
"Вот краткий пример, в котором `add-fact` используется для добавления фактов "
"о медведях(bears) и собаках(dogs), как отдельных индивидумах, так и видах:"

#: in/chapter14.md:1185
msgid "`> (add-fact '(sub dog animal))`=> `T`"
msgstr ""

#: in/chapter14.md:1187
msgid "`> (add-fact '(sub bear animal))`=> `T`"
msgstr ""

#: in/chapter14.md:1189
msgid "`> (add-fact '(ind Fido dog))`=> `T`"
msgstr ""

#: in/chapter14.md:1191
msgid "`> (add-fact '(ind Yogi bear))`=> `T`"
msgstr ""

#: in/chapter14.md:1193
msgid "`> (add-fact '(val color Yogi brown))`=> `T`"
msgstr ""

#: in/chapter14.md:1195
msgid "`> (add-fact '(val color Fido golden))`=> `T`"
msgstr ""

#: in/chapter14.md:1197
msgid "`> (add-fact '(val latin-name bear ursidae))`=> `T`"
msgstr ""

#: in/chapter14.md:1199
msgid "`> (add-fact '(val latin-name dog canis-familiaris))`=> `T`"
msgstr ""

#: in/chapter14.md:1203
msgid ""
"Now `retrieve-fact` is used to answer three questions: What kinds of animais "
"are there?\n"
"What are the Latin names of each kind of animal?\n"
"and What are the colors of each individual bear?"
msgstr ""
"Теперь с помощью`retrieve-fact`  можно ответить на три вопроса: Какие виды "
"животных существуют?\n"
"Каковы латинские названия каждого вида животных?\n"
"и Какого цвета каждый медведь?"

#: in/chapter14.md:1215
msgid ""
"```lisp\n"
"> (retrieve-fact '(sub ?kind animal))\n"
"(((?KIND . DOG))\n"
"((?KIND . BEAR)))\n"
"> (retrieve-fact '(and (sub ?kind animal)\n"
"          (val latin-name ?kind ?latin)))\n"
"(((?LATIN . CANIS-FAMILIARIS) (?KIND . DOG))\n"
"  ((?LATIN . URSIDAE) (?KIND . BEAR)))\n"
"> (retrieve-fact '(and (ind ?x bear) (val color ?x ?c)))\n"
"(((?C . BROWN) (?X . YOGI)))\n"
"```"
msgstr ""

#: in/chapter14.md:1217
msgid "### Improvements"
msgstr "### Улучшения"

#: in/chapter14.md:1221
msgid ""
"There are quite a few improvements that can be made to this system.\n"
"One direction is to provide different kinds of answers to queries.\n"
"The following two functions are similar to `retrieve-matches` in that they "
"return lists of solutions that match the query, rather than lists of "
"possible bindings:"
msgstr ""
"В эту систему можно внести несколько улучшений.\n"
"Одно из направлений - давать разные ответы на вопросы.\n"
"Следующие две функции похожи на `retrieve-matches` в том, что они возвращают "
"списки решений, соответствующих запросу, а не списки возможных привязок:"

#: in/chapter14.md:1228
msgid ""
"```lisp\n"
"(defun retrieve-bagof (query)\n"
"  \"Find all facts that match query.\n"
"  Return a list of queries with bindings filled in.\"\n"
"  (mapcar #'(lambda (bindings) (subst-bindings bindings query))\n"
"          (retrieve-fact query)))"
msgstr ""

#: in/chapter14.md:1234
msgid ""
"(defun retrieve-setof (query)\n"
"  \"Find all facts that match query.\n"
"  Return a list of unique queries with bindings filled in.\"\n"
"  (remove-duplicates (retrieve-bagof query) :test #'equal))\n"
"```"
msgstr ""

#: in/chapter14.md:1244
msgid ""
"Another direction to take is to provide better error checking.\n"
"The current system does not complain if a fact or query is ill-formed.\n"
"It also relies on the user to input all facts, even those that could be "
"derived automatically from the semantics of existing facts.\n"
"For example, the semantics of `sub` imply that if `(sub bear animal)` and "
"`(sub polar-bear bear)` are true, then `(sub polar-bear animal)` must also "
"be true.\n"
"This kind of implication can be handled in two ways.\n"
"The typical Prolog approach would be to write rules that derive the "
"additional `sub` facts by backward-chaining.\n"
"Then every query would have to check if there were rules to run.\n"
"The alternative is to use a *forward-chaining* approach, which caches each "
"new `sub` fact by adding it to the data base.\n"
"This latter alternative takes more storage, but because it avoids rederiving "
"the same facts over and over again, it tends to be faster."
msgstr ""
"Еще одно направление - улучшить проверку ошибок.\n"
"Текущая система не жалуется, если факт или запрос неправильно "
"сформулированы.\n"
"Она также полагается на то, что пользователь вводит все факты, даже те, "
"которые могут быть получены автоматически из семантики существующих фактов.\n"
"Например, семантика `sub` подразумевает, что если `(sub bear animal)` и "
"`(sub polar-bear bear)` истинны, то `(sub polar-bear animal)` также должно "
"быть истинным.\n"
"С подобным подтекстом можно справиться двумя способами.\n"
"Типичный подход Пролога заключается в написании правил, которые выводят "
"дополнительные `sub` факты путем обратной цепочки.\n"
"Тогда каждый запрос должен будет проверять, есть ли правила для выполнения.\n"
"Альтернативой является использование подхода *forward-chaining*(прямой "
"цепочки), которая кэширует каждый новый `sub` факт, добавляя его в базу "
"данных.\n"
"Последний вариант требует больше места для хранения, но поскольку он "
"позволяет избежать повторного вывода одних и тех же фактов снова и снова, он "
"обычно выполняется быстрее."

#: in/chapter14.md:1248
msgid ""
"The following version of `add-fact` does error checking, and it "
"automatically caches facts that can be derived from existing facts.\n"
"Both of these things are done by a set of functions that are attached to the "
"primitive operators.\n"
"It is done in a data-driven style to make it easier to add new primitives, "
"should that become necessary."
msgstr ""
"Следующая версия `add-fact` выполняет проверку ошибок и автоматически "
"кэширует факты, которые могут быть получены из существующих фактов.\n"
"Обе эти вещи выполняются набором функций, прикрепленных к примитивным "
"операторам.\n"
"Это сделано в стиле, управляемом данными, чтобы упростить добавление новых "
"примитивов, если в этом возникнет необходимость."

#: in/chapter14.md:1251
msgid ""
"The function `add-fact` checks that each argument to a primitive relation is "
"a nonvariable atom, and it also calls `fact-present-p` to check if the fact "
"is already present in the data base.\n"
"If not, it indexes the fact and calls `run-attached-fn` to do additional "
"checking and caching:"
msgstr ""
"Функция `add-fact` проверяет, что каждый аргумент примитивного отношения "
"является неизменяемым атомом, а также вызывает `fact-present-p`, чтобы "
"проверить, присутствует ли уже факт в базе данных.\n"
"Если нет, она индексирует факт и вызывает `run-attached-fn` для "
"дополнительной проверки и кэширования:"

#: in/chapter14.md:1270
msgid ""
"```lisp\n"
"(defparameter *primitives* '(and sub ind rel val))\n"
"(defun add-fact (fact)\n"
"  \"Add the fact to the data base.\"\n"
"  (cond ((eq (predicate fact) 'and)\n"
"      (mapc #'add-fact (args fact)))\n"
"    ((or (not (every #'atom (args fact)))\n"
"        (some #'variable-p (args fact))\n"
"        (not (member (predicate fact) *primitives*)))\n"
"      (error \"Ill-formed fact: ~a\" fact))\n"
"    ((not (fact-present-p fact))\n"
"      (index fact)\n"
"      (run-attached-fn fact)))\n"
"  t)\n"
"(defun fact-present-p (fact)\n"
"  \"Is this fact present in the data base?\"\n"
"  (retrieve fact))\n"
"```"
msgstr ""

#: in/chapter14.md:1272
msgid ""
"The attached functions are stored on the operator's property list under the "
"indicator `attached-fn:`"
msgstr ""
"Присоединенные функции хранятся в списке свойств оператора под индикатором "
"`attached-fn:`"

#: in/chapter14.md:1277
msgid ""
"```lisp\n"
"(defun run-attached-fn (fact)\n"
"  \"Run the function associated with the predicate of this fact.\"\n"
"  (apply (get (predicate fact) 'attached-fn) (args fact)))"
msgstr ""

#: in/chapter14.md:1283
msgid ""
"(defmacro def-attached-fn (pred args &body body)\n"
"  \"Define the attached function for a primitive.\"\n"
"  `(setf (get ',pred 'attached-fn)\n"
"         #'(lambda ,args .,body)))\n"
"```"
msgstr ""

#: in/chapter14.md:1288
msgid ""
"The attached functions for `ind` and `val` are fairly simple.\n"
"If we know `(sub bear animal)`, then when `(ind Yogi bear)` is asserted, we "
"have to also assert `(ind Yogi animal)`.\n"
"Similarly, the values in a `val` assertion must be individuals of the "
"categories in the relation's `rel` assertion.\n"
"That is, if `(rel birthday animal date)` is a fact and `(val birthday Lee "
"july-1)` is added, then we can conclude `(ind Lee animal)` and `(ind july-1 "
"date).` The following functions add the appropriate facts:"
msgstr ""
"Прилагаемые функции для `ind` и `va`l довольно просты.\n"
"Если мы знаем `(sub bear animal)`(животное-медведь), тогда, когда "
"утверждается `(ind Yogi animal)`(инд.медведь-йоги), мы должны также "
"утверждать `(ind Yogi animal)`(инд.животное-йоги).\n"
"Точно так же значения в утверждении `val` должны быть индивидуумами "
"категорий в утверждении отношения `rel`.\n"
"То есть, если `(rel birthday animal date)` является фактом и добавляется "
"`(val birthday Lee july-1)`, то мы можем заключить `(ind Lee animal)` и "
"`(ind july-1 date)`. Следующие функции добавляют соответствующие факты:"

#: in/chapter14.md:1294
msgid ""
"```lisp\n"
"(def-attached-fn ind (individual category)\n"
"  ;; Cache facts about inherited categories\n"
"  (query-bind (?super) `(sub ,category ?super)\n"
"    (add-fact `(ind ,individual ,?super))))"
msgstr ""

#: in/chapter14.md:1301
msgid ""
"(def-attached-fn val (relation ind1 ind2)\n"
"  ;; Make sure the individuals are the right kinds\n"
"  (query-bind (?cat1 ?cat2) `(rel ,relation ?cat1 ?cat2)\n"
"    (add-fact `(ind ,ind1 ,?cat1))\n"
"    (add-fact `(ind ,ind2 ,?cat2))))\n"
"```"
msgstr ""

#: in/chapter14.md:1305
msgid ""
"The attached function for rel simply runs the attached function for any "
"individual of the given relation.\n"
"Normally one would make all `rel` assertions before `ind` assertions, so "
"this will have no effect at all.\n"
"But we want to be sure the data base stays consistent even if facts are "
"asserted in an unusual order."
msgstr ""
"Присоединенная функция для rel просто запускает присоединенную функцию для "
"любого индивидуума данного отношения.\n"
"Обычно все утверждения `rel` делаются перед утверждениями `ind`, так что это "
"не будет иметь никакого эффекта.\n"
"Но мы хотим быть уверены в том, что база данных остается последовательной, "
"даже если факты утверждаются в необычном порядке."

#: in/chapter14.md:1312
msgid ""
"```lisp\n"
"(def-attached-fn rel (relation cat1 cat2)\n"
"  ;; Run attached function for any IND's of this relation\n"
"  (query-bind (?a ?b) `(ind ,relation ?a ?b)\n"
"    (run-attached-fn `(ind ,relation ,?a ,?b))))\n"
"```"
msgstr ""

#: in/chapter14.md:1315
msgid ""
"The most complicated attached function is for `sub`.\n"
"Adding a fact such as `(sub bear animal)` causes the following to happen:"
msgstr ""
"Самая сложная присоединенная функция - для `sub`.\n"
"Добавление такого факта, как `(sub bear animal)`(животное-медведь), приводит "
"к следующему:"

#: in/chapter14.md:1317
msgid ""
"*   All of `animal`'s supercategories (such as `living-thing)` become "
"supercategories of all of `bear`'s subcategories (such as `polar-bear)`."
msgstr ""
"*   Все суперкатегории `animal`(животных) (например, `living-thing`-живые "
"существа) становятся суперкатегориями всех подкатегорий `bear`-медведей "
"(таких как `polar-bear`-белый медведь)."

#: in/chapter14.md:1319
msgid ""
"*   `animal` itself becomes a supercategory all of `bear`'s subcategories."
msgstr ""
"*   Само `animal`-животное становится суперкатегорией всех подкатегорий "
"`bear`-медведей."

#: in/chapter14.md:1321
msgid ""
"*   bear itself becomes a subcategory of all of `animal`'s supercategories."
msgstr ""
"*   bear-медведь сам становится подкатегорией всех суперкатегорий `animal`-"
"животных."

#: in/chapter14.md:1323
msgid ""
"*   All of the individuals of bear become individuals of `animal` and its "
"supercategories."
msgstr ""
"*   Все особи(individuals) медведя становятся особями(individuals) `animal`-"
"животного и его суперкатегорий."

#: in/chapter14.md:1327
msgid ""
"The following accomplishes these four tasks.\n"
"It does it with four calls to `index-new-fact`, which is used instead of "
"`add-fact` because we don't need to run the attached function on the new "
"facts.\n"
"We do, however, need to make sure that we aren't indexing the same fact "
"twice."
msgstr ""
"Следующий код выполняет эти четыре задачи.\n"
"Он делает это с помощью четырех вызовов `index-new-fact`, который "
"используется вместо `add-fact`, потому что нам не нужно запускать "
"присоединенную функцию для новых фактов.\n"
"Однако нам необходимо убедиться, что мы не индексируем один и тот же факт "
"дважды."

#: in/chapter14.md:1342
msgid ""
"```lisp\n"
"(def-attached-fn sub (subcat supercat)\n"
"  ;; Cache SUB facts\n"
"  (query-bind (?super-super) `(sub ,supercat ?super-super)\n"
"    (index-new-fact `(sub ,subcat ,?super-super))\n"
"    (query-bind (?sub-sub) `(sub ?sub-sub ,subcat)\n"
"      (index-new-fact `(sub ,?sub-sub ,?super-super))))\n"
"  (query-bind (?sub-sub) `(sub ?sub-sub ,subcat)\n"
"    (index-new-fact `(sub ,?sub-sub ,supercat)))\n"
"  ;; Cache IND facts\n"
"  (query-bind (?super-super) `(sub ,subcat ?super-super)\n"
"    (query-bind (?sub-sub) `(sub ?sub-sub ,supercat)\n"
"      (query-bind (?ind) `(ind ?ind ,?sub-sub)\n"
"        (index-new-fact `(ind ,?ind ,?super-super))))))"
msgstr ""

#: in/chapter14.md:1348
msgid ""
"(defun index-new-fact (fact)\n"
"  \"Index the fact in the data base unless it is already there.\"\n"
"  (unless (fact-present-p fact)\n"
"    (index fact)))\n"
"```"
msgstr ""

#: in/chapter14.md:1351
msgid ""
"The following function tests the attached functions.\n"
"It shows that adding the single fact `(sub bear animal)` to the given data "
"base causes 18 new facts to be added."
msgstr ""
"Следующая функция проверяет прикрепленные функции.\n"
"Она показывает, что добавление единственного факта `(sub bear animal)` - "
"(животное-медведь) в данную базу данных приводит к добавлению 18 новых "
"фактов."

#: in/chapter14.md:1402
msgid ""
"```lisp\n"
"(defun test-bears ()\n"
"  (clear-dtrees)\n"
"  (mapc #'add-fact\n"
"      '((sub animal living-thing)\n"
"        (sub living-thing thing) (sub polar-bear bear)\n"
"        (sub grizzly bear) (ind Yogi bear) (ind Lars polar-bear)\n"
"        (ind Helga grizzly)))\n"
"  (trace index)\n"
"  (add-fact '(sub bear animal))\n"
"  (untrace index))\n"
">(test-bears)\n"
"(1 ENTER INDEX: (SUB BEAR ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB BEAR THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB GRIZZLY THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB POLAR-BEAR THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB BEAR LIVING-THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB GRIZZLY LIVING-THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB POLAR-BEAR LIVING-THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB GRIZZLY ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (SUB POLAR-BEAR ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND LARS LIVING-THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND HELGA LIVING-THING)\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND YOGI LIVING-THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND LARS THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND HELGA THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND YOGI THING))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND LARS ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND HELGA ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(1 ENTER INDEX: (IND YOGI ANIMAL))\n"
"(1 EXIT INDEX: T)\n"
"(INDEX)\n"
"```"
msgstr ""

#: in/chapter14.md:1404
msgid "### A Frame Language"
msgstr "### Фреймовый язык"

#: in/chapter14.md:1409
msgid ""
"Another direction we can take is to provide an alternative syntax that will "
"be easier to read and write.\n"
"Many representation languages are based on the idea of *frames,* and their "
"syntax reflects this.\n"
"A frame is an object with slots.\n"
"We will continue to use the same data base in the same format, but we will "
"provide an alternative syntax that consider s the individuals and categories "
"as frames, and the relations as slots."
msgstr ""
"Еще одно направление, которое мы можем выбрать, - это предоставить "
"альтернативный синтаксис, который будет легче читать и писать.\n"
"Многие языки представления основаны на идее *фреймов*-frames, и их синтаксис "
"отражает это.\n"
"Фрейм - это объект со слотами.\n"
"Мы продолжим использовать ту же базу данных в том же формате, но мы "
"предоставим альтернативный синтаксис, который рассматривает индивидуумов и "
"категории как фреймы, а отношения как слоты."

#: in/chapter14.md:1412
msgid ""
"Here is an example of the frame syntax for individuals, which uses the "
"operator a.\n"
"Note that it is more compact than the equivalent notation using the "
"primitives."
msgstr ""
"Вот пример синтаксиса фрейма для индивидуумов, в котором используется "
"оператор a.\n"
"Обратите внимание, что это более компактно, чем эквивалентная запись с "
"использованием примитивов."

#: in/chapter14.md:1419
msgid ""
"```lisp\n"
"(a person (name Joe) (age 27)) =\n"
"(and (ind person1 person)\n"
"  (val name person1 Joe)\n"
"  (val age person1 27))\n"
"```"
msgstr ""

#: in/chapter14.md:1423
msgid ""
"The syntax also allows for nested expressions to appear as the values of "
"slots.\n"
"Notice that the Skolem constant `person1` was generated automatically; an "
"alternative is to supply a constant for the individual after the category "
"name.\n"
"For example, the following says that Joe is a person of age 27 whose best "
"friend is a person named Fran who is 28 and whose best friend is Joe:"
msgstr ""
"Синтаксис также позволяет отображать вложенные выражения как значения "
"слотов.\n"
"Обратите внимание, что константа Сколема `person1` была сгенерирована "
"автоматически; альтернативой является предоставление константы для "
"индивидуума после названия категории.\n"
"Например, следующее говорит, что Джо - человек 27 лет, лучший друг которого "
"- 28-летний человек по имени Фрэн, и лучший друг - Джо:"

#: in/chapter14.md:1433
msgid ""
"```lisp\n"
"(a person p1 (name Joe) (age 27)\n"
"  (best-friend (a person (name Fran) (age 28)\n"
"          (best-friend pl)))) =\n"
"(and (ind p1 person) (val name p1 joe) (val age p1 27)\n"
"  (ind person2 person) (val name person2 fran)\n"
"  (val age person2 28) (val best-friend person2 pl)\n"
"  (val best-friend p1 person2))\n"
"```"
msgstr ""

#: in/chapter14.md:1436
msgid ""
"The frame syntax for categories uses the operator `each`.\n"
"For example:"
msgstr ""
"В синтаксисе фрейма для категорий используется оператор `each`-каждый.\n"
"Например:"

#: in/chapter14.md:1443
msgid ""
"```lisp\n"
"(each person (isa animal) (name person-name) (age integer)) =\n"
"(and (sub person animal)\n"
"  (rel name person person-name)\n"
"  (rel age person integer))\n"
"```"
msgstr ""

#: in/chapter14.md:1446
msgid ""
"The syntax for queries is the same as for assertions, except that variables "
"are used instead of the Skolem constants.\n"
"This is true even when the Skolem constants are automatically generated, as "
"in the following query:"
msgstr ""
"Синтаксис запросов такой же, как и для утверждений, за исключением того, что "
"вместо констант Сколема используются переменные.\n"
"Это верно даже тогда, когда константы Сколема генерируются автоматически, "
"как в следующем запросе:"

#: in/chapter14.md:1450
msgid ""
"```lisp\n"
"(a person (age 27)) = (AND (IND ?3 PERSON) (VAL AGE ?3 27))\n"
"```"
msgstr ""

#: in/chapter14.md:1452
msgid ""
"To support the frame notation, we define the macros `a` and `each` to make "
"assertions and `??` to make queries."
msgstr ""
"Для поддержки фреймовой нотации мы определяем макросы `a` и `each` для "
"выполнения утверждений и `??` для выполнения запросов."

#: in/chapter14.md:1461
msgid ""
"```lisp\n"
"(defmacro a (&rest args)\n"
"  \"Define a new individual and assert facts about it in the data base.\"\n"
"  '(add-fact ',(translate-exp (cons 'a args))))\n"
"(defmacro each (&rest args)\n"
"  \"Define a new category and assert facts about it in the data base.\"\n"
"  '(add-fact ',(transiate-exp (cons 'each args))))\n"
"```"
msgstr ""

#: in/chapter14.md:1464
msgid ""
"`(defmacro ??\n"
"(&rest queries)`"
msgstr ""

#: in/chapter14.md:1471
msgid ""
"```lisp\n"
"  \"Return a list of answers satisfying the query or queries.\"\n"
"  '(retrieve-setof\n"
"    '.(translate-exp (maybe-add 'and (replace-?-vars queries))\n"
"          :query)))\n"
"```"
msgstr ""

#: in/chapter14.md:1480
msgid ""
"All three of these macros call on `translate-exp` to translate from the "
"frame syntax to the primitive syntax.\n"
"Note that an `a` or `each` expression is computing a conjunction of "
"primitive relations, but it is also computing a *term* when it is used as "
"the nested value of a slot.\n"
"It would be possible to do this by returning multiple values, but it is "
"easier to build `transiate-exp` as a set of local functions that construct "
"facts and push them on the local variable `conjuncts`.\n"
"At the end, the list of `conjuncts` is returned as the value of the "
"translation.\n"
"The local functions `transiate-a` and `transiate-each` return the atom that "
"represents the term they are translating.\n"
"The local function `translate` translates any kind of expression, `transiate-"
"siot` handles a slot, and `collect-fact` is responsible for pushing a fact "
"onto the list of conjuncts.\n"
"The optional argument `query-mode-p` tells what to do if the individual is "
"not provided in an `a` expression.\n"
"If `query-mode-p` is true, the individual will be represented by a variable; "
"otherwise it will be a Skolem constant."
msgstr ""
"Все три этих макроса вызывают `translate-exp` для преобразования синтаксиса "
"фрейма в примитивный синтаксис (?синтаксис примитивов).\n"
"Обратите внимание, что выражение `a` или `each` вычисляет конъюнкцию "
"примитивных отношений, но оно также вычисляет *term* - термин, когда он "
"используется как вложенное значение слота.\n"
"Это можно было бы сделать, возвращая несколько значений, но проще построить "
"`transiate-exp` как набор локальных функций, которые конструируют факты и "
"помещают их в локальную переменную `conjuncts`.\n"
"В конце список `conjuncts`-конъюнктов возвращается как значение translation-"
"преобразования.\n"
"Локальные функции `transiate-a` и `transiate-each` возвращают атом, который "
"представляет термин, который они преобразуют.\n"
"Локальная функция `translate` преобразует/транслирует любые выражения, "
"`transiate-siot` обрабатывает слот, а `collect-fact` отвечает за добавление "
"факта в список conjuncts-конъюнктов.\n"
"Необязательный аргумент `query-mode-p` сообщает, что делать, если индивидуум "
"не указан в выражении `a`.\n"
"Если `query-mode-p` истинен, индивидуум будет представлен переменной; в "
"противном случае это будет константа Сколема."

#: in/chapter14.md:1523
msgid ""
"```lisp\n"
"(defun translate-exp (exp &optional query-mode-p)\n"
"  \"Translate exp into a conjunction of the four primitives.\"\n"
"  (let ((conjuncts nil))\n"
"    (labels\n"
"      ((collect-fact (&rest terms) (push terms conjuncts))\n"
"        (translate (exp)\n"
"          ;; Figure out what kind of expression this is\n"
"          (cond\n"
"            ((atom exp) exp)\n"
"            ((eq (first exp) 'a) (translate-a (rest exp)))\n"
"            ((eq (first exp) 'each) (translate-each (rest exp)))\n"
"            (t (apply #'collect-fact exp) exp)))\n"
"        (translate-a (args)\n"
"          ;; translate (A category [ind] (rel filler)*)\n"
"          (let* ((category (pop args))\n"
"              (self (cond ((and args (atom (first args)))\n"
"                  (pop args))\n"
"                (query-mode-p (gentemp \"?\"))\n"
"                (t (gentemp (string category))))))\n"
"            (collect-fact 'ind self category)\n"
"            (dolist (slot args)\n"
"              (translate-slot 'val self slot))\n"
"            self))\n"
"        (translate-each (args)\n"
"          ;; translate (EACH category [(isa cat*)] (slot cat)*)\n"
"          (let* ((category (pop args)))\n"
"            (when (eq (predicate (first args)) 'isa)\n"
"              (dolist (super (rest (pop args)))\n"
"                (collect-fact 'sub category super)))\n"
"            (dolist (slot args)\n"
"              (translate-slot 'rel category slot))\n"
"            category))\n"
"        (translate-slot (primitive self slot)\n"
"          ;; translate (relation value) into a REL or SUB\n"
"          (assert (= (length slot) 2))\n"
"          (collect-fact primitive (first slot) self\n"
"                  (translate (second slot)))))\n"
"      ;; Body of translate-exp:\n"
"      (translate exp) ;; Build up the list of conjuncts\n"
"      (maybe-add 'and (nreverse conjuncts)))))\n"
"```"
msgstr ""

#: in/chapter14.md:1525
msgid ""
"The auxiliary functions `maybe-add` and `replace-?-vars` are shown in the "
"following:"
msgstr "Вспомогательные функции `might-add` и `replace-?-vars` показаны ниже:"

#: in/chapter14.md:1545
msgid ""
"```lisp\n"
"(defun maybe-add (op exps &optional if-nil)\n"
"  \"For example, (maybe-add 'and exps t) returns\n"
"  t if exps is nil, (first exps) if there is only one,\n"
"  and (and expl exp2...) if there are several exps.\"\n"
"  (cond ((null exps) if-nil)\n"
"    ((length=1 exps) (first exps))\n"
"    (t (cons op exps))))\n"
"(defun length=1 (x)\n"
"  \"Is x a list of length 1?\"\n"
"  (and (consp x) (null (cdr x))))\n"
"(defun replace-?-vars (exp)\n"
"  \"Replace each ? in exp with a temporary var: ?123\"\n"
"  (cond ((eq exp '?) (gentemp \"?\"))\n"
"    ((atom exp) exp)\n"
"    (t (reuse-cons (replace-?-vars (first exp))\n"
"          (replace-?-vars (rest exp))\n"
"          exp))))\n"
"```"
msgstr ""

#: in/chapter14.md:1547
msgid "### Possible Worlds: Truth, Negation, and Disjunction"
msgstr "### Возможные миры: правда, отрицание и разъединение(Disjunction)"

#: in/chapter14.md:1551
msgid ""
"In this section we address four problems: distinguishing `unknown` from "
"`false`, representing negations, representing disjunctions, and representing "
"multiple possible states of affairs.\n"
"It turns out that all four problems can be solved by introducing two new "
"techniques: possible worlds and negated predicates.\n"
"The solution is not completely general, but it is practical in a wide "
"variety of applications."
msgstr ""
"В этом разделе мы обращаемся к четырем проблемам: различение `unknown`-"
"неизвестного от `false`-ложного, представление negations-отрицаний, "
"представление disjunctions-дизъюнкций и представление нескольких возможных "
"состояний дел.\n"
"Оказывается, все четыре проблемы можно решить, введя два новых метода: "
"возможные миры и отрицательные предикаты.\n"
"Решение не является полностью общим, но его можно использовать в самых "
"разных приложениях."

#: in/chapter14.md:1557
msgid ""
"There are two basic ways to distinguish unknown from false.\n"
"The first possibility is to store a truth value-`true` or `false`-along with "
"each proposition.\n"
"The second possibility is to include the truth value as part of the "
"proposition.\n"
"There are several syntactic variations on this theme.\n"
"The following table shows the possibilities for the propositions \"Jan likes "
"Dean is true\" and \"Jan likes Ian is false:\""
msgstr ""
"Есть два основных способа отличить неизвестное от ложного.\n"
"Первая возможность - сохранить значение истинности - `true`(истина) или "
"`false`(ложь) - вместе с каждым proposition(предложением/утверждением).\n"
"Вторая возможность состоит в том, чтобы включить значение истинности как "
"часть утверждения.\n"
"На эту тему есть несколько синтаксических вариаций.\n"
"В следующей таблице показаны возможности утверждений \"Jan likes Dean is true"
"\"(Ян нравится Дин - это правда) и \"Jan likes Ian is false:\"(Ян нравится "
"Иан - это ложь):"

#: in/chapter14.md:1564
msgid ""
"| Approach | True Prop.                 | False Prop.                |\n"
"|----------|----------------------------|----------------------------|\n"
"| 1)       | `(likes Jan Dean) -- true` | `(likes Jan Ian) -- false` |\n"
"| (2a)     | `(likes true Jan Dean)`    | `(likes false Jan Ian)`    |\n"
"| (2b)     | `(likes Jan Dean)`         | `(not (likes Jan Dean))`   |\n"
"| (2c)     | `(likes Jan Dean)`         | `(~  likes Jan Dean)`      |"
msgstr ""

#: in/chapter14.md:1569
msgid ""
"The difference between (1) and (2) shows up when we want to make a query.\n"
"With (1), we make the single query `(likes Jan Dean)` (or perhaps `(likes "
"Jan ?x))`, and the answers will tell us who Jan does and does not like.\n"
"With (2), we make one query to find out what liking relationships are true, "
"and another to find out which ones are false.\n"
"In either approach, if there are no responses then the answer is truly "
"unknown."
msgstr ""
"Разница между (1) и (2) проявляется, когда мы хотим сделать запрос.\n"
"С помощью (1) мы делаем единственный запрос `(likes Jan Dean)`-(любит Ян "
"Дин) (или, возможно, `(likes Jan ?x))` - (любит Ян ?x))`, и ответы скажут "
"нам, кого Ян любит, а кого не любит.\n"
"С помощью (2) мы делаем один запрос, чтобы выяснить, какие отношения likes-"
"симпатии/любви истинны, и другой, чтобы выяснить, какие из них ложны.\n"
"При любом подходе, если нет ответов, то ответ действительно неизвестен."

#: in/chapter14.md:1572
msgid ""
"Approach (1) is better for applications where most queries are of the form "
"\"Is this sentence true or false?\" But applications that include backward-"
"chaining rules are not like this.\n"
"The typical backward-chaining rule says \"Conclude X is true if Y is true.\" "
"Thus, most queries will be of the type \"Is Y true?\" Therefore, some "
"version of approach (2) is preferred."
msgstr ""
"Подход (1) лучше подходит для приложений, где большинство запросов имеют "
"форму \"Верно это высказывание или ложно?\" Но приложения, которые включают "
"правила обратной цепочки, не такие.\n"
"Типичное правило обратной цепочки гласит: \"Сделайте вывод, что X истинно, "
"если Y истинно\". Таким образом, большинство запросов будут иметь тип "
"\"Верно ли Y?\"(\"Is Y true?\") Поэтому предпочтительнее какой-либо вариант "
"подхода (2)."

#: in/chapter14.md:1575
msgid ""
"Representing true and false opens the door to a host of possible "
"extensions.\n"
"First, we could add multiple truth values beyond the simple \"true\" and "
"\"false.\" These could be symbolic values like \"probably-true\" or \"false-"
"by-default\" or they could be numeric values representing probabilities or "
"certainty factors."
msgstr ""
"Представление истинного и ложного открывает двери для множества возможных "
"расширений.\n"
"Во-первых, мы могли бы добавить несколько значений истинности помимо простых "
"\"true\"-истина и \"false\"-ложь. Это могут быть символьные значения, такие "
"как \"probably-true\"/вероятно-истинно или \"false-by-default\"/ложно-по-"
"умолчанию, или они могут быть числовыми значениями, представляющими "
"вероятности или факторы достоверности."

#: in/chapter14.md:1578
msgid ""
"Second, we could introduce the idea of *possible worlds.* That is, the truth "
"of a proposition could be unknown in the current world, but true if we "
"assume *p*, and false if we assume *q.* In the possible world approach, this "
"is handled by calling the current world *W*, and then creating a new world "
"*W*1, which is just like *W* except that *p* is true, and *W*2, which is "
"just like *W* except that *q* is true.\n"
"By doing reasoning in different worlds we can make predictions about the "
"future, resolve ambiguitites about the current state, and do reasoning by "
"cases."
msgstr ""
"Во-вторых, мы могли бы ввести идею *возможных миров*. То есть истинность "
"утверждения может быть неизвестна в текущем мире, но истинна, если мы "
"предполагаем *p*, и ложно, если мы предполагаем *q*. В возможных мирах, оно "
"обрабатывается путем вызова текущего мира *W*, а затем создания нового мира "
"*W*1, который похож на *W*, за исключением того, что *p* истинно, а *W* 2 - "
"просто как *W*, за исключением того, что *q* истинно.\n"
"Рассуждая в разных мирах, мы можем делать прогнозы о будущем, разрешать "
"неоднозначности в отношении текущего состояния и рассуждать по конкретным "
"случаям."

#: in/chapter14.md:1584
msgid ""
"For example, possible worlds allow us to solve Moore's communism/democracy "
"problem ([page 466](#p466)).\n"
"We create two new possible worlds, one where *E* is a democracy and one "
"where it is communist.\n"
"In each world it is easy to derive that there is a democracy next to a "
"communist country.\n"
"The trick is to realize then that the two worlds form a partition, and that "
"therefore the assertion holds in the original \"real\" world as well.\n"
"This requires an interaction between the Prolog-based tactical reasoning "
"going on within a world and the planning-based strategie reasoning that "
"decides which worlds to consider."
msgstr ""
"Например, возможные миры позволяют нам решить проблему Мура коммунизм/"
"демократия ([страница 466](#p466)).\n"
"Мы создаем два новых возможных мира: в одном *E* демократическая, а в другом "
"- коммунистическая.\n"
"В любом мире легко сделать вывод, что есть демократия рядом с "
"коммунистической страной.\n"
"Уловка состоит в том, чтобы понять, что два мира образуют раздел, и что, "
"следовательно, утверждение справедливо и в исходном \"реальном\" мире.\n"
"Это требует взаимодействия между основанными на Прологе тактическими "
"рассуждениями, происходящими в мире, и основанными на планировании "
"стратегическими рассуждениями, которые решают, какие миры рассматривать."

#: in/chapter14.md:1588
msgid ""
"We could also add a *truth maintenance system* (or TMS) to keep track of the "
"assumptions or justifications that lead to each fact being considered true.\n"
"A truth maintenance system can lessen the need to backtrack in a search for "
"a global solution.\n"
"Although truth maintenance systems are an important part of AI programming, "
"they will not be covered in this book."
msgstr ""
"Мы также могли бы добавить *систему поддержания истины * (или TMS-*truth "
"maintenance system*), чтобы отслеживать предположения или обоснования, "
"которые приводят к тому, что каждый факт считается истинным.\n"
"Система поддержания истины может уменьшить необходимость откатываться в "
"поисках глобального решения.\n"
"Хотя системы поддержания истины являются важной частью программирования ИИ, "
"они не будут рассматриваться в этой книге."

#: in/chapter14.md:1594
msgid ""
"In this section we extend the dtree facility ([section 14.8](#s0045)) to "
"handle truth values and possible worlds.\n"
"With so many options, it is difficult to make design choices.\n"
"We will choose a fairly simple system, one that remains close to the "
"simplicity and speed of Prolog but offers additional functionality when "
"needed.\n"
"We will adopt approach (2c) to truth values, using negated predicates.\n"
"For example, the negated predicate of `likes` is `~likes`, which is "
"pronounced \"not likes.\""
msgstr ""
"В этом разделе мы расширяем возможность dtree ([раздел 14.8](#s0045)) для "
"обработки значений истинности и возможных миров.\n"
"При таком большом количестве вариантов сложно выбрать дизайн.\n"
"Мы выберем довольно простую систему, которая по простоте и скорости близка к "
"Prolog, но при необходимости предлагает дополнительные функции.\n"
"Мы примем подход (2c) к значениям истинности, используя отрицательные "
"предикаты.\n"
"Например, отрицательный предикат `likes`-любит, это `~likes`, что "
"произносится как \"не любит\"."

#: in/chapter14.md:1602
msgid ""
"We will also provide minimal support for possible worlds.\n"
"Assume that there is always a current world, *W,* and that there is a way to "
"create alternative worlds and change the current world to an alternative "
"one.\n"
"Assertions and queries will always be made with respect to the current "
"world.\n"
"Each fact is indexed by the atoms it contains, just as before.\n"
"The difference is that the facts are also indexed by the current world.\n"
"To support this, we need to modify the notion of the numbered list, or "
"`nlist`, to include a numbered association list, or `nalist`.\n"
"The following is an `nalist` showing six facts indexed under three different "
"worlds: `W0, Wl`, and `W2`:"
msgstr ""
"Мы также обеспечим минимальную поддержку возможных миров.\n"
"Предположим, что всегда существует текущий мир, *W* и что есть способ "
"создать альтернативные миры и изменить текущий мир на альтернативный.\n"
"Утверждения и запросы всегда будут относиться к текущему миру.\n"
"Каждый факт индексируется содержащимися в нем атомами, как и раньше.\n"
"Разница в том, что факты также индексируются текущим миром.\n"
"Чтобы поддержать это, нам нужно изменить понятие нумерованного списка или "
"`nlist`, чтобы включить нумерованный список ассоциаций, или `nalist`.\n"
"Ниже приводится `nalist`, показывающий шесть фактов, проиндексированных в "
"трех разных мирах: `W0, Wl` и `W2`:"

#: in/chapter14.md:1606
msgid ""
"```lisp\n"
"(6 (W0 #1# #2# #3#) (Wl #4#) (W2 #5# #6#))\n"
"```"
msgstr ""

#: in/chapter14.md:1611
msgid ""
"The fetching routine will remain unchanged, but the postfetch processing "
"will have to sort through the nalists to find only the facts in the current "
"world.\n"
"It would also be possible for `fetch` to do this work, but the reasoning is "
"that most facts will be indexed under the \"real world,\" and only a few "
"facts will exist in alternative, hypothetical worlds.\n"
"Therefore, we should delay the effort of sorting through the answers to "
"elimina te those answers in the wrong world-it may be that the first answer "
"fetched will suffice, and then it would have been a waste to go through and "
"eliminate other answers.\n"
"The following changes to `index` and `dtree-index` add support for worlds:"
msgstr ""
"Процедура выборки останется неизменной, но обработка после выборки должна "
"будет отсортировать nalist-ы, чтобы найти только факты в текущем мире.\n"
"`fetch` также мог бы выполнять эту работу, но аргументация состоит в том, "
"что большинство фактов будет проиндексировано в \"реальном мире\", и только "
"несколько фактов будут существовать в альтернативных, гипотетических мирах.\n"
"Следовательно, мы должны отложить усилия по сортировке ответов, чтобы "
"исключить эти ответы в неправильном мире - может оказаться, что первого "
"полученного ответа будет достаточно, и тогда было бы напрасной тратой пройти "
"и исключить другие ответы.\n"
"Следующие изменения в `index` и `dtree-index` добавляют поддержку миров:"

#: in/chapter14.md:1616
msgid ""
"```lisp\n"
"(defvar *world* 'W0 \"The current world used by index and fetch.\")\n"
"(defun index (key &optional (world *world*))\n"
"```"
msgstr ""

#: in/chapter14.md:1619
msgctxt "in/chapter14.md:1619"
msgid ""
"`  \"Store key in a dtree node.\n"
"Key must be (predicate . args);`"
msgstr ""

#: in/chapter14.md:1637
msgid ""
"```lisp\n"
"  it is stored in the dtree, indexed by the world.\"\n"
"  (dtree-index key key world (get-dtree (predicate key))))\n"
"(defun dtree-index (key value world dtree)\n"
"  \"Index value under all atoms of key in dtree.\"\n"
"  (cond\n"
"    ((consp key)    ; index on both first and rest\n"
"      (dtree-index (first key) value world\n"
"            (or (dtree-first dtree)\n"
"              (setf (dtree-first dtree) (make-dtree))))\n"
"      (dtree-index (rest key) value world\n"
"            (or (dtree-rest dtree)\n"
"              (setf (dtree-rest dtree) (make-dtree)))))\n"
"    ((null key))    ; don't index on nil\n"
"    ((variable-p key)    ; index a variable\n"
"      (nalist-push world value (dtree-var dtree)))\n"
"```"
msgstr ""

#: in/chapter14.md:1640
msgid ""
"`    (t ;; Make sure there is an nlist for this atom.\n"
"and add to it`"
msgstr ""

#: in/chapter14.md:1644
msgid ""
"```lisp\n"
"      (nalist-push world value (lookup-atom key dtree)))))\n"
"```"
msgstr ""

#: in/chapter14.md:1646
msgid ""
"The new function `nalist-push` adds a value to an nalist, either by "
"inserting the value in an existing key's list or by adding a new key/value "
"list:"
msgstr ""
"Новая функция `nalist-push` добавляет значение в nalist, либо путем вставки "
"значения в существующий список ключей, либо путем добавления нового списка "
"ключей/значений:"

#: in/chapter14.md:1658
msgid ""
"```lisp\n"
"(defun nalist-push (key val nalist)\n"
"  \"Index val under key in a numbered al ist.\"\n"
"  ;; An nalist is of the form (count (key val*)*)\n"
"  ;; Ex: (6 (nums 12 3) (letters a b c))\n"
"  (incf (car nalist))\n"
"  (let ((pair (assoc key (cdr nalist))))\n"
"    (if pair\n"
"      (push val (cdr pair))\n"
"      (push (list key val) (cdr nalist)))))\n"
"```"
msgstr ""

#: in/chapter14.md:1662
msgid ""
"In the following, `fetch` is used on the same data base created by `test-"
"index`, indexed under the world `W0`.\n"
"This time the resuit is a list-of-lists of world/values a-lists.\n"
"The count, 3, is the same as before."
msgstr ""
"Далее `fetch` используется в той же базе данных, созданной `test-index`, "
"проиндексированной в мире `W0`.\n"
"На этот раз результат - это список ассоциативных списков миров/значений.\n"
"Счетчик 3 такой же, как и раньше."

#: in/chapter14.md:1669
msgid ""
"```lisp\n"
">(fetch '(p ?x c))\n"
"(((W0 (P B C) (P A C)))\n"
"  ((W0 (P A ?X))))\n"
"3\n"
"```"
msgstr ""

#: in/chapter14.md:1674
msgid ""
"So far, worlds have been represented as symbols, with the implication that "
"different symbols represent completely distinct worlds.\n"
"That doesn't make worlds very easy to use.\n"
"We would like to be able to use worlds to explore alternatives-create a new "
"hypothetical world, make some assumptions (by asserting them as facts in the "
"hypothetical world), and see what can be derived in that world.\n"
"It would be tedious to have to copy all the facts from the real world into "
"each hypothetical world."
msgstr ""
"До сих пор миры представлялись как символы, подразумевая, что разные символы "
"представляют совершенно разные миры.\n"
"Это не делает миры очень простыми в использовании.\n"
"Мы хотели бы иметь возможность использовать миры для исследования "
"альтернатив - создания нового гипотетического мира, делать некоторые "
"предположения (утверждая их как факты в гипотетическом мире) и смотреть, что "
"можно извлечь из этого мира.\n"
"Было бы утомительно копировать все факты из реального мира в каждый "
"гипотетический мир."

#: in/chapter14.md:1677
msgid ""
"An alternative is to establish an inheritance hierarchy among worlds.\n"
"Then a fact is considered true if it is indexed in the current world or in "
"any world that the current world inherits from."
msgstr ""
"Альтернативой является установление иерархии наследования между мирами.\n"
"Тогда факт считается истинным, если он индексируется в текущем мире или в "
"любом мире, который наследуется от текущего мира."

#: in/chapter14.md:1681
msgid ""
"To support inheritance, we will implement worlds as structures with a name "
"field and a field for the list of parents the world inherits from.\n"
"Searching through the inheritance lattice could become costly, so we will do "
"it only once each time the user changes worlds, and mark all the current "
"worlds by setting the `current` field on or off.\n"
"Here is the definition for the world structure:"
msgstr ""
"Для поддержки наследования мы реализуем миры как структуры с полем имени и "
"полем для списка родителей, от которых наследуется мир.\n"
"Поиск в решетке наследования может оказаться дорогостоящим, поэтому мы будем "
"делать это только один раз, каждый раз, когда пользователь меняет миры, и "
"отмечать все текущие миры, устанавливая или отключая поле `current`.\n"
"Вот определение структуры world - мир:"

#: in/chapter14.md:1686
msgid ""
"```lisp\n"
"(defstruct (world (:print-function print-world))\n"
"  name parents current)\n"
"```"
msgstr ""

#: in/chapter14.md:1692
msgid ""
"We will need a way to get from the name of a world to the world structure.\n"
"Assuming names are symbols, we can store the structure on the name's "
"property list.\n"
"The function `get-world` gets the structure for a name, or builds a new one "
"and stores it.\n"
"`get-world` can also be passed a world instead of a name, in which case it "
"just returns the world.\n"
"We also include a definition of the default initial world."
msgstr ""
"Нам понадобится способ перейти от названия мира к его структуре.\n"
"Предполагая, что имена являются символами, мы можем сохранить структуру в "
"списке свойств имени.\n"
"Функция `get-world` получает структуру для имени или создает новую и "
"сохраняет ее.\n"
"`get-world` также может передавать мир вместо имени, и в этом случае он "
"просто возвращает мир.\n"
"Мы также включаем определение исходного мира по умолчанию."

#: in/chapter14.md:1705
msgid ""
"```lisp\n"
"(defun get-world (name &optional current (parents (list *world*)))\n"
"  \"Look up or create the world with this name.\n"
"  If the world is new, give it the list of parents.\"\n"
"  (cond ((world-p name) name) ; ok if it already is a world\n"
"      ((get name 'world))\n"
"      (t (setf (get name 'world)\n"
"          (make-world :name name :parents parents\n"
"            :current current)))))\n"
"(defvar *world* (get-world 'W0 nil nil)\n"
"  \"The current world used by index and fetch.\")\n"
"```"
msgstr ""

#: in/chapter14.md:1710
msgid ""
"The function `use-world` is used to switch to a new world.\n"
"It first makes the current world and all its parents no longer current, and "
"then makes the new chosen world and all its parents current.\n"
"The function `use-new-world` is more efficient in the common case where you "
"want to create a new world that inherits from the current world.\n"
"It doesn't have to turn any worlds off; it j ust crea tes the new world and "
"makes it current."
msgstr ""
"Функция `use-world` используется для переключения в новый мир.\n"
"Сначала она делает текущий мир и всех его родителей устаревшими, а затем "
"делает новый выбранный мир и всех его родителей текущими.\n"
"Функция `use-new-world` более эффективна в общем случае, когда вы хотите "
"создать новый мир, унаследованный от текущего мира.\n"
"Она не должна выключать какие-либо миры; она просто создает новый мир и "
"делает его актуальным."

#: in/chapter14.md:1735
msgid ""
"```lisp\n"
"(defun use-world (world)\n"
"  \"Make this world current.\"\n"
"  ;; If passed a name, look up the world it names\n"
"  (setf world (get-world world))\n"
"  (unless (eq world *world*)\n"
"    ;; Turn the old world(s) off and the new one(s) on,\n"
"    ;; unless we are already using the new world\n"
"    (set-world-current *world* nil)\n"
"    (set-world-current world t)\n"
"    (setf *world* world)))\n"
"(defun use-new-world ()\n"
"  \"Make up a new world and use it.\n"
"  The world inherits from the current world.\"\n"
"  (setf *wor1d* (get-world (gensym \"W\")))\n"
"  (setf (world-current *world*) t)\n"
"  *world*)\n"
"(defun set-world-current (world on/off)\n"
"  \"Set the current field of world and its parents on or off.\"\n"
"  ;; nil is off, anything else is on.\n"
"  (setf (world-current world) on/off)\n"
"  (dolist (parent (world-parents world))\n"
"    (set-world-current parent on/off)))\n"
"```"
msgstr ""

#: in/chapter14.md:1737
msgid ""
"We also add a print function for worlds, which just prints the world's name."
msgstr ""
"Мы также добавляем функцию печати для миров, которая просто печатает "
"название мира."

#: in/chapter14.md:1743
msgid ""
"```lisp\n"
"(defun print-world (world &optional (stream t) depth)\n"
"  (declare (ignore depth))\n"
"  (prin1 (world-name world) stream))\n"
"```"
msgstr ""

#: in/chapter14.md:1747
msgid ""
"The format of the dtree data base has changed to include worlds, so we need "
"new retrieval functions to search through this new format.\n"
"Here the functions `mapc-retrieve, retrieve`, and `retrieve-bagof` are "
"modified to give new versions that treat worlds.\n"
"To reflect this change, the new functions all have names ending in -`in-"
"world`:"
msgstr ""
"Формат базы данных dtree был изменен и теперь включает миры, поэтому нам "
"нужны новые функции поиска, для поиска в этом новом формате.\n"
"Здесь функции `mapc-retrieve, retrieve` и `retrieve-bagof` изменены, чтобы "
"дать новые версии, которые обрабатывают миры.\n"
"Чтобы отразить это изменение, все новые функции имеют имена, заканчивающиеся "
"на -`in-world`:"

#: in/chapter14.md:1761
msgid ""
"```lisp\n"
"(defun mapc-retrieve-in-world (fn query)\n"
"  \"For every fact in the current world that matches the query,\n"
"  apply the function to the binding list.\"\n"
"  (dolist (bucket (fetch query))\n"
"    (dolist (world/entries bucket)\n"
"      (when (world-current (first world/entries))\n"
"        (dolist (answer (rest world/entries))\n"
"          (let ((bindings (unify query answer)))\n"
"            (unless (eq bindings fall)\n"
"              (funcall fn bindings))))))))\n"
"(defun retrieve-in-world (query)\n"
"```"
msgstr ""

#: in/chapter14.md:1764
msgid ""
"`  \"Find all facts that match query.\n"
"Return a list of bindings.\"`"
msgstr ""
"`  \"Найти все факты, соответствующие запросу.\n"
"Вернуть список привязок.\"`"

#: in/chapter14.md:1777
msgid ""
"```lisp\n"
"  (let ((answers nil))\n"
"    (mapc-retrieve-in-world\n"
"      #'(lambda (bindings) (push bindings answers))\n"
"      query)\n"
"    answers))\n"
"(defun retrieve-bagof-in-world (query)\n"
"  \"Find all facts in the current world that match query.\n"
"  Return a list of queries with bindings filled in.\"\n"
"  (mapcar #'(lambda (bindings) (subst-bindings bindings query))\n"
"          (retrieve-in-world query)))\n"
"```"
msgstr ""

#: in/chapter14.md:1780
msgid ""
"Now let's see how these worlds work.\n"
"First, in `W0` we see that the facts from `test-index` are still in the data "
"base:"
msgstr ""
"Теперь посмотрим, как работают эти миры.\n"
"Во-первых, в `W0` мы видим, что факты из `test-index` все еще находятся в "
"базе данных:"

#: in/chapter14.md:1784
msgid ""
"```lisp\n"
"> *world* => W0\n"
"```"
msgstr ""

#: in/chapter14.md:1786
msgctxt "in/chapter14.md:1786"
msgid "`> (retrieve-bagof-in-world '(p ?z c))`=>"
msgstr ""

#: in/chapter14.md:1790
msgid ""
"```lisp\n"
"((P A C) (P A C) (P B C))\n"
"```"
msgstr ""

#: in/chapter14.md:1793
msgid ""
"Now we create and use a new world that inherits from `W0`.\n"
"Two new facts are added to this new world:"
msgstr ""
"Теперь мы создаем и используем новый мир, унаследованный от `W0`.\n"
"В этот новый мир добавлены два новых факта:"

#: in/chapter14.md:1795
msgid "`> (use-new-world)`=> `W7031`"
msgstr ""

#: in/chapter14.md:1797
msgid "`> (index '(p new c))`=> `T`"
msgstr ""

#: in/chapter14.md:1799
msgid "`> (index '(~p b b))`=> `T`"
msgstr ""

#: in/chapter14.md:1801
msgid "We see that the two new facts are accessible in this world:"
msgstr "Мы видим, что в этом мире доступны два новых факта:"

#: in/chapter14.md:1803
msgctxt "in/chapter14.md:1803"
msgid "`> (retrieve-bagof-in-world '(p ?z c))`=>"
msgstr ""

#: in/chapter14.md:1807
msgid ""
"```lisp\n"
"((P A C) (P A C) (P B C) (P NEW C))\n"
"```"
msgstr ""

#: in/chapter14.md:1809
msgctxt "in/chapter14.md:1809"
msgid "`> (retrieve-bagof-in-world '(~p ?x ?y))`=>"
msgstr ""

#: in/chapter14.md:1813
msgid ""
"```lisp\n"
"((~P B B))\n"
"```"
msgstr ""

#: in/chapter14.md:1815
msgid ""
"Now we create another world as an alternative to the current one by first "
"switching back to the original `W0`, then creating the new world, and then "
"adding some facts:"
msgstr ""
"Теперь мы создаем другой мир как альтернативу текущему, сначала переключаясь "
"обратно на исходный `W0`, затем создавая новый мир, а затем добавляя "
"некоторые факты:"

#: in/chapter14.md:1817
msgid "`> (use-world 'W0)`=> `W0`"
msgstr ""

#: in/chapter14.md:1819
msgid "`> (use-new-world)`=> `W7173`"
msgstr ""

#: in/chapter14.md:1821
msgid "`> (index '(p newest c))`=> `T`"
msgstr ""

#: in/chapter14.md:1823
msgid "`> (index '(~p c newest))`=> `T`"
msgstr ""

#: in/chapter14.md:1825
msgid ""
"Here we see that the facts entered in `W7031` are not accessible, but the "
"facts in the new world and in `W0` are:"
msgstr ""
"Здесь мы видим, что факты, введенные в `W7031`, недоступны, но факты в новом "
"мире и в `W0` следующие:"

#: in/chapter14.md:1827
msgctxt "in/chapter14.md:1827"
msgid "`> (retrieve-bagof-in-world '(p ?z c))`=>"
msgstr ""

#: in/chapter14.md:1831
msgid ""
"```lisp\n"
"((P A C) (P A C) (P B C) (P NEWEST C))\n"
"```"
msgstr ""

#: in/chapter14.md:1833
msgctxt "in/chapter14.md:1833"
msgid "`> (retrieve-bagof-in-world '(~p ?x ?y))`=>"
msgstr ""

#: in/chapter14.md:1837
msgid ""
"```lisp\n"
"((~P C NEWEST))\n"
"```"
msgstr ""

#: in/chapter14.md:1839
msgid "### Unification, Equality, Types, and Skolem Constants"
msgstr "### Унификация(Объединение), равенство, типы и константы Сколема "

#: in/chapter14.md:1843
msgid ""
"The lesson of the zebra puzzle in [section 11.4](B978008057115750011X."
"xhtml#s0040) was that unification can be used to lessen the need for "
"backtracking, because an uninstantiated logic variable or partially "
"instantiated term can stand for a whole range of possible solutions.\n"
"However, this advantage can quickly disappear when the representation forces "
"the problem solver to enumerate possible solutions rather than treating a "
"whole range of solutions as one.\n"
"For example, consider the following query in the frame language and its "
"expansion into primitives:"
msgstr ""
"Урок головоломки \"Зебра\" в [раздел 11.4](B978008057115750011X.xhtml#s0040) "
"заключался в том, что унификацию можно использовать для уменьшения "
"потребности в обратном отслеживании(backtracking), потому что "
"неустановленная логическая переменная или частично конкретизированный термин "
"может означать целый ряд возможных решений.\n"
"Однако это преимущество может быстро исчезнуть, когда представление "
"заставляет решателя проблемы перечислять возможные решения, а не "
"рассматривать весь диапазон решений как одно.\n"
"Например, рассмотрим следующий запрос на языке фреймов и его расширение на "
"примитивы:"

#: in/chapter14.md:1848
msgid ""
"```lisp\n"
"(a person (name Fran))\n"
"= (and (ind ?p person) (val name ?p fran))\n"
"```"
msgstr ""

#: in/chapter14.md:1853
msgid ""
"The way to answer this query is to enumerate all individuals `?p` of type "
"`person` and then check the `name` slot of each such person.\n"
"It would be more efficient if `(ind ?p person)` did not act as an "
"enumeration, but rather as a constraint on the possible values of `?p`.\n"
"This would be possible if we changed the definition of variables (and of the "
"unification function) so that each variable had a type associated with it.\n"
"In fact, there are at least three sources of information that have been "
"implemented as constraints on variables terms:"
msgstr ""
"Чтобы ответить на этот запрос, нужно перечислить всех индивидов `?p` типа "
"`person`, а затем проверить слот `name` каждого такого человека.\n"
"Было бы более эффективно, если бы `(ind ?p person)` действовал не как "
"перечисление, а как ограничение на возможные значения `?p`.\n"
"Это было бы возможно, если бы мы изменили определение переменных (и функции "
"объединения) так, чтобы каждая переменная имела связанный с ней тип.\n"
"Фактически, есть по крайней мере три источника информации, которые были "
"реализованы как ограничения на термины переменных:"

#: in/chapter14.md:1855
msgid "*   The type or category of the term."
msgstr "*   Тип или категория термина."

#: in/chapter14.md:1857
msgid "*   The members or size of a term considered as a set or list."
msgstr "*   Состав или размер термина, рассматриваемого как набор или список"

#: in/chapter14.md:1859
msgid "*   Other terms this term is equal or not equal to."
msgstr "*   В остальном этот срок равен или не равен."

#: in/chapter14.md:1864
msgid ""
"Note that with a good solution to the problem of equality, we can solve the "
"problem of Skolem constants.\n"
"The idea is that a regular constant unifies with itself but no other regular "
"constant.\n"
"On the other hand, a Skolem constant can potentially unify with any other "
"constant (regular or Skolem).\n"
"The equality mechanism is used to keep track of each Skolem variable's "
"possible bindings."
msgstr ""
"Обратите внимание, что при хорошем решении проблемы равенства мы можем "
"решить проблему констант Сколема.\n"
"Идея состоит в том, что обычная константа объединяется сама с собой, но не "
"другой регулярной константой.\n"
"С другой стороны, константа Сколема потенциально может объединяться с любой "
"другой константой (обычной или Сколемской).\n"
"Механизм равенства используется для отслеживания возможных привязок каждой "
"переменной Сколема."

#: in/chapter14.md:1866
msgid "## 14.11 History and References"
msgstr "## 14.11 История и Ссылки"

#: in/chapter14.md:1872
msgid ""
"[Brachman and Levesque (1985)](B9780080571157500285.xhtml#bb0115) collect "
"thirty of the key papers in knowledge representation.\n"
"Included are some early approaches to semantic network based ([Quillian 1967]"
"(B9780080571157500285.xhtml#bb0965)) and logic-based ([McCarthy 1968]"
"(B9780080571157500285.xhtml#bb0805)) representation.\n"
"Two thoughtful critiques of the ad hoc use of representations without "
"defining their meaning are by [Woods (1975)](B9780080571157500285."
"xhtml#bb1430) and [McDermott (1978)](B9780080571157500285.xhtml#bb0820).\n"
"It is interesting to contrast the latter with [McDermott 1987]"
"(B9780080571157500285.xhtml#bb0825), which argues that logic by itself is "
"not sufficient to solve the problems of AI.\n"
"This argument should not be surprising to those who remember the slogan "
"*logic = algorithm - control.*"
msgstr ""

#: in/chapter14.md:1875
msgid ""
"[Genesereth and Nilsson's textbook (1987)](B9780080571157500285."
"xhtml#bb0455) cover the predicate-calculus-based approach to knowledge "
"representation and AI in general.\n"
"[Ernest Davis (1990)](B9780080571157500285.xhtml#bb0275) presents a good "
"overview of the field that includes specialized representations for time, "
"space, qualitative physics, propositional attitudes, and the interaction "
"between agents."
msgstr ""

#: in/chapter14.md:1879
msgid ""
"Many representation languages focus on the problem of defining descriptions "
"for categories of objects.\n"
"These have come to be known as *term-subsumption languages.* Examples "
"include KL-ONE ([Schmolze and Lipkis 1983](B9780080571157500285."
"xhtml#bb1060)) and KRYPTON ([Brachman, Fikes, and Levesque 1983]"
"(B9780080571157500285.xhtml#bb0120)).\n"
"See [Lakoff 1987](B9780080571157500285.xhtml#bb0685) for much more on the "
"problem of categories and prototypes."
msgstr ""

#: in/chapter14.md:1884
msgid ""
"Hector [Levesque (1986)](B9780080571157500285.xhtml#bb0720) points out that "
"the areas Prolog has difficulty with-disjunction, negation, and existentials-"
"all involve a degree of vagueness.\n"
"In his term, they lack *vividness.* A vivid proposition is one that could be "
"represented directly in a picture: the car is blue; she has a martini in her "
"left hand; Albany is the capital of New York.\n"
"Nonvivid propositions cannot be so represented: the car is not blue; she has "
"a martini in one hand; either Albany or New York City is the capital of New "
"York.\n"
"There is interest in separating vivid from nonvivid reasoning, but no "
"current systems are actually built this way."
msgstr ""

#: in/chapter14.md:1892
msgid ""
"The possible world approach of [section 14.10](#s0055) was used in the MRS "
"system ([Russell 1985](B9780080571157500285.xhtml#bb1020)).\n"
"More recent knowledge representation systems tend to use truth maintenance "
"systems instead of possible worlds.\n"
"This approach was pioneered by [Doyle (1979)](B9780080571157500285."
"xhtml#bb0340) and [McAllester (1982)](B9780080571157500285.xhtml#bb0785).\n"
"Doyle tried to change the name to \"reason maintenance,' in (1983), but it "
"was too late.\n"
"The version in widest used today is the assumption-based truth maintenance "
"system, or ATMS, developed by de Kleer (1986a,b,c).\n"
"[Charniak et al.\n"
"(1987)](B9780080571157500285.xhtml#bb0180) present a complete Common Lisp "
"implementation of a McAllester-styleTMS."
msgstr ""

#: in/chapter14.md:1900
msgid ""
"There is little communication between the logic programming and knowledge "
"representation communities, even though they cover overlapping territory.\n"
"[Colmerauer (1990)](B9780080571157500285.xhtml#bb0250) and [Cohen (1990)]"
"(B9780080571157500285.xhtml#bb0230) describe Logic Programming languages "
"that address some of the issues covered in this chapter.\n"
"Key papers in equality reasoning include Galler and Fisher 1974, [Kornfeld "
"1983](B9780080571157500285.xhtml#bb0645),[1](#fn0015) Jaffar, Lassez, and "
"Maher 1984, and [van Emden and Yukawa 1987](B9780080571157500285."
"xhtml#bb1265).\n"
"[H&ouml;lldobler's book (1987)](B9780080571157500285.xhtml#bb0550) includes "
"an overview of the area.\n"
"Papers on extending unification in ways other than equality include [A&iuml;"
"t-Kaci et al.\n"
"1987](B9780080571157500285.xhtml#bb0025) and [Staples and Robinson 1988]"
"(B9780080571157500285.xhtml#bb1125).\n"
"Finally, papers on extending Prolog to cover disjunction and negation (i.e., "
"non-Horn clauses) include [Loveland 1987](B9780080571157500285."
"xhtml#bb0755), [Plaisted 1988](B9780080571157500285.xhtml#bb0960), and "
"[Stickel 1988](B9780080571157500285.xhtml#bb1200)."
msgstr ""

#: in/chapter14.md:1902
msgid "## 14.12 Exercises"
msgstr "## 14.12 Упражнения"

#: in/chapter14.md:1904
msgid ""
"**Exercise  14.1 [m]** Arrange to store dtrees in a hash table rather than "
"on the property list of predicates."
msgstr ""

#: in/chapter14.md:1906
msgid ""
"**Exercise  14.2 [m]** Arrange to store the `dtree-atoms` in a hash table "
"rather than in an association list."
msgstr ""

#: in/chapter14.md:1909
msgid ""
"**Exercise  14.3 [m]** Change the `dtree` code so that `nil` is used as an "
"atom index.\n"
"Time the performance on an application and see if the change helps or hurts."
msgstr ""

#: in/chapter14.md:1914
msgid ""
"**Exercise  14.4 [m]** Consider the query `(p a b c d e f g)`.\n"
"If the index under a returns only one or two keys, then it is probably a "
"waste of time for `dtree-fetch` to consider the other keys in the hope of "
"finding a smaller bucket.\n"
"It is certainly a waste if there are no keys at all indexed under `a`.\n"
"Make appropriate changes to `dtree-fetch`."
msgstr ""

#: in/chapter14.md:1916
msgid "**Exercise  14.5 [h]** Arrange to delete elements from a `dtree`."
msgstr ""

#: in/chapter14.md:1919
msgid ""
"**Exercise  14.6 [h]** Implement iterative-deepening search in the Prolog "
"compiler.\n"
"You will have to change each function to accept the depth as an extra "
"argument, and compile in checks for reaching the maximum depth."
msgstr ""

#: in/chapter14.md:1922
msgid ""
"**Exercise  14.7 [d]** Integrate the Prolog compiler with the dtree data "
"base.\n"
"Use the dtrees for predicates with a large number of clauses, and make sure "
"that each predicate that is implemented as a dtree has a Prolog primitive "
"accessing the dtree."
msgstr ""

#: in/chapter14.md:1925
msgid ""
"**Exercise  14.8 [d]** Add support for possible worlds to the Prolog "
"compiler with dtrees.\n"
"This support has already been provided for dtrees, but you will have to "
"provide it for ordinary Prolog rules."
msgstr ""

#: in/chapter14.md:1927
msgid ""
"**Exercise  14.9 [h]** Integrate the language described in [section 14.10]"
"(#s0055) and the frame syntax from [section 14.10](#s0055) with the extended "
"Prolog compiler from the previous exercise."
msgstr ""

#: in/chapter14.md:1930
msgid ""
"**Exercise  14.10 [d]** Build a strategie reasoner that decides when to "
"create a possible world and does reasoning by cases over these worlds.\n"
"Use it to solve Moore 's problem ([page 466](#p466))."
msgstr ""

#: in/chapter14.md:1932
msgid "## 14.13 Answers"
msgstr "## 14.13 Ответы"

#: in/chapter14.md:1934
msgid "**Answer 14.1**"
msgstr ""

#: in/chapter14.md:1946
msgid ""
"```lisp\n"
"(let ((dtrees (make-hash-table :test #'eq)))\n"
"  (defun get-dtree (predicate)\n"
"    \"Fetch (or make) the dtree for this predicate.\"\n"
"    (setf (gethash predicate dtrees)\n"
"        (or (gethash predicate dtrees)\n"
"          (make-dtree))))\n"
"  (defun clear-dtrees ()\n"
"  \"Remove all the dtrees for all the predicates.\"\n"
"  (clrhash dtrees)))\n"
"```"
msgstr ""

#: in/chapter14.md:1949
msgid ""
"**Answer 14.5** Hint: here is the code for `nlist-delete`.\n"
"Now figure out how to find all the nlists that an item is indexed under."
msgstr ""

#: in/chapter14.md:1958
msgid ""
"```lisp\n"
"(defun nlist-delete (item nlist)\n"
"  \"Remove an element from an nlist.\n"
"  Assumes that item is present exactly once.\"\n"
"  (decf (car nlist))\n"
"  (setf (cdr nlist) (delete item (cdr nlist) :count 1))\n"
"  nlist)\n"
"```"
msgstr ""

#: in/chapter14.md:1960
msgid "----------------------"
msgstr ""

#: in/chapter14.md:1963
msgid ""
"[1](#xfn0015) A commentary on this paper appears in [Elcock and Hoddinott "
"1986](B9780080571157500285.xhtml#bb0360).\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter14.md:1967
msgid ""
"Part IV\n"
"Advanced AI Programs\n"
"!!!(p) {:.parttitle}"
msgstr ""
