# Глава 13
## Объектно-Ориентированное Программирование

Программы в этой книге охватывают широкий круг задач.
Вполне естественно, что для решения этих проблем был введен широкий спектр стилей программирования.
Еще не рассмотренный стиль, завоевавший популярность в последние годы, называется объектно-ориентированным программированием.
Чтобы понять, что влечет за собой объектно-ориентированное программирование, нам нужно поместить его в контекст других стилей.

Исторически первые компьютерные программы были написаны в стиле *императивного программирования*.
Программа была построена как последовательность инструкций, каждая из которых выполняет какое-либо действие: изменение значения ячейки памяти, печать результата и т. д.
Ассемблер - пример императивного языка.

По мере роста опыта (и амбиций) программисты искали способы контролировать сложность программ.
Изобретение подпрограмм обозначило стиль *алгоритмического* или *процедурного программирования*, подкласса императивного стиля.
Подпрограммы полезны по двум причинам: разбиение проблемы на маленькие части упрощает понимание каждой части, а также дает возможность повторно использовать части.
Примерами процедурных языков являются FORTRAN, C, Pascal и Lisp с `setf`.

Подпрограммы по-прежнему зависят от глобального состояния, поэтому они не являются полностью отдельными частями.
Использование большого количества глобальных переменных подвергалось критике как фактор, затрудняющий разработку и сопровождение больших программ.
Чтобы устранить эту проблему, придуман стиль *функционального программирования* требующий, чтобы функции обращались только к переданным им параметрам и всегда возвращали один и тот же результат для тех же входных данных.
Функциональные программы имеют то преимущество, что они математически чисты - их свойства легко доказать.
Однако некоторые приложения более естественно воспринимаются как выполняющие действия, а не вычисляющие функциональные значения, и поэтому их неестественно программировать в функциональном стиле.
Примерами функциональных языков являются FP и Lisp без `setf`.

В отличие от императивных языков есть *декларативные* языки, которые пытаются выразить "что делать", а не "как это сделать". Один из типов декларативного программирования - это программирование *основанное на правилах*, где набор правил определяет, как преобразовать проблему в решение.
Примерами систем на основе правил являются ELIZA и STUDENT.

Важным видом декларативного программирования является *логическое программирование*, в котором аксиомы используются для описания ограничений, а вычисления выполняются путем конструктивного доказательства цели.
Примером логичесого языка является Пролог.

*Объектно-ориентированное программирование* - еще один способ решить проблему глобального состояния.
Вместо того, чтобы запрещать глобальное состояние (как это делает функциональное программирование), объектно-ориентированное программирование разбивает непослушную массу глобального состояния и инкапсулирует его на небольшие управляемые части или объекты.
В этой главе рассматривается объектно-ориентированный подход.

## 13.1 Объектно-Ориентированное Программирование(Object-Oriented Programming)

Объектно-ориентированное программирование переворачивает мир вычислений на свою сторону: вместо того, чтобы рассматривать программу в первую очередь как набор действий, которые манипулируют объектами, она рассматривается как набор объектов, которыми управляют действия.
Состояние каждого объекта и действия, которые управляют этим состоянием, определяются раз и навсегда при создании объекта.
Это может привести к появлению модульных и надежных систем, которые легко использовать и расширять.
Это также может сделать системы более близкими к "реальному миру", который нам, людям, легче воспринимается как состоящий из объектов, а не действий.
Примерами объектно-ориентированных языков являются Simula, C++ и CLOS - объектная система Common Lisp.
Эта глава сначала представит объектно-ориентированное программирование в целом, а затем сконцентрируется на объектной системе Common Lisp.

Многие люди продвигают объектно-ориентированное программирование как решение проблемы разработки программного обеспечения, но трудно заставить людей прийти к единому мнению о том, что такое объектная ориентация.
[Питер Вегнер, 1987](B9780080571157500285.xhtml#bb1355) предлагает следующую формулу в качестве определения:

*Object-orientation = Objects + Classes + Inheritance* (Объектно ориентированное = Объекты + Классы + Наследование)

Вкратце, *объекты* - это модули, которые инкапсулируют некоторые данные и операции с этими данными.
Идея *сокрытия информации* - изоляции представления этих данных от операций вне объекта - является важной частью этой концепции.
*Классы* - это группы похожих объектов с одинаковым поведением.
Объекты называются экземплярами классов.
*Наследование* - это средство определения новых классов как вариантов существующих классов.
Новый класс наследует поведение родительского класса, и программисту нужно только указать, чем новый класс отличается.

Объектно-ориентированный стиль приносит с собой новый словарь, который кратко изложен в следующем глоссарии.
Каждый термин будет объяснен более подробно, когда он появится.

*Класс(class):* Группа похожих объектов с одинаковым поведением.

*переменная класса(class variable):* Переменная, совместно используемая всеми членами класса.

*делегирование(delegation): * Передача сообщения от объекта одному из его компонентов.

*Обобщенная функция(generic function):* Функция, которая принимает различные типы или классы аргументов.

*наследование(inheritance): * средство определения новых классов как вариантов существующих классов.

*Экземпляр(instance):* Экземпляр класса - это объект.

*экземпляр переменной(instance variable):* Переменная, заключенная в объект.

*Сообщение(message):* Имя действия.
Эквивалентно обобщенной функции.

*Метод(method):* Средство обработки сообщения для определенного класса.

*Мультиметод(multimethod):* Метод, зависящий от нескольких аргументов.

*Множественное наследование(multiple inheritance):* Наследование от более чем одного родительского класса.

*Объект(object):* Инкапсуляция локального состояния и поведения.

## 13.2 Объекты

Объектно-ориентированное программирование, по определению, связано с *объектами*.
Любые данные, которые могут быть сохранены в памяти компьютера, можно рассматривать как объект.
Таким образом, число 3, атом x и строка `"hello"` - это всё объекты.
Обычно, как мы увидим, термин *объект* используется для обозначения более сложного объекта.

Конечно, всё программирование связано с объектами и процедурами, работающими с этими объектами.
Написание программы для решения конкретной проблемы обязательно потребует написания определений как для объектов, так и для процедур.
Что отличает объектно-ориентированное программирование, так это то, что основной способ декомпозиции проблемы на модули основан на объектах, а не на процедурах.
Разницу лучше всего увидеть на примере.
Вот простая программа для создания банковских счетов и отслеживания снятия средств, депозитов и накопления процентов.
Во-первых, программа написана в традиционном процедурном стиле:

```lisp
(defstruct account
  (name "") (balance 0.00) (interest-rate .06))

(defun account-withdraw (account amt)
  "Make a withdrawal from this account."
  (if (<= amt (account-balance account))
      (decf (account-balance account) amt)
      'insufficient-funds))

(defun account-deposit (account amt)
  "Make a deposit to this account."
  (incf (account-balance account) amt))

(defun account-interest (account)
  "Accumulate interest in this account."
  (incf (account-balance account)
        (* (account-interest-rate account)
           (account-balance account))))
```

Мы можем создавать новые банковские счета с помощью `make-account` и изменять их с помощью `account-withdraw, account-deposit` и `account-interest`. Это простая проблема, и этого простого решения достаточно.
Проблемы возникают, когда мы меняем спецификацию проблемы или когда мы предполагаем, что эта реализация может быть случайно использована по ошибке.
Например, предположим, что программист смотрит на структуру `account` и решает использовать `(decf (account-balance account) `) напрямую вместо того, чтобы использовать функцию `account-remove`.
Это могло привести к отрицательному сальдо счетов, чего не планировалось.
Или предположим, что мы хотим создать новый тип учетной записи, в которой одновременно может быть снята только определенная максимальная сумма.
Невозможно гарантировать, что `account-withdraw` не будет применяться к этой новой ограниченной учетной записи.

Проблема в том, что после создания счета(account) мы не можем контролировать, какие действия к нему будут применены.
Объектно-ориентированный стиль предназначен для обеспечения такого контроля.
Вот та же программа, написанная в объектно-ориентированном стиле (с использованием простого Lisp):

```lisp
(defun new-account (name &optional (balance 0.00)
                    (interest-rate .06))
  "Create a new account that knows the following messages:"
  #'(lambda (message)
      (case message
        (withdraw #'(lambda (amt)
                      (if (<= amt balance)
                          (decf balance amt)
                          'insufficient-funds)))
        (deposit  #'(lambda (amt) (incf balance amt)))
        (balance  #'(lambda () balance))
        (name     #'(lambda () name))
        (interest #'(lambda ()
                      (incf balance
                            (* interest-rate balance)))))))
```

Функция `new-account` создает объекты счета, которые реализованы как замыкания, которые инкапсулируют три переменные: имя, баланс и процентную ставку счета.
Объект счет(account) также инкапсулирует функции для обработки пяти сообщений, на которые объект может ответить.
Объект account может делать только одно: получать сообщение и возвращать соответствующую функцию для выполнения этого сообщения.
Например, если вы передадите сообщение объекту account `withdraw`, он вернет функцию, которая при применении к одному аргументу (сумме для снятия) выполнит действие по снятию средств.
Эта функция называется *методом*, реализующим сообщение.
Преимущество этого подхода в том, что объекты account полностью инкапсулированы; информация, соответствующая имени, балансу и процентной ставке, доступна только через пять сообщений.
У нас есть гарантия, что никакой другой код не сможет манипулировать информацией в account каким-либо иным образом. [1](#fn0015)

Функция `get-method` находит метод, реализующий сообщение для данного объекта.
Функция `send` получает метод и применяет его к списку аргументов.
Название `send` происходит от объектно-ориентированной системы Flavors, которая обсуждается в разделе истории.([page 456](#p456)).

```lisp
(defun get-method (object message)
  "Return the method that implements message for this object."
  (funcall object message))

(defun send (object message &rest args)
  "Get the function to implement the message,
  and apply the function to the args."
  (apply (get-method object message) args))
```

Вот пример использования `new-account` и `send`:

`> (setf acct (new-account "J.
Random Customer" 1000.00))`=>

```lisp
#<CLOSURE 23652465>
> (send acct 'withdraw 500.00) => 500.0
> (send acct 'deposit 123.45) => 623.45
```

`> (send acct 'name) => "J.
Random Customer"`

```lisp
> (send acct 'balance) => 623.45
```

## 13.3 Обобщенные функции

Синтаксис send неудобен, так как он отличается от обычного синтаксиса вызова функций Lisp и не подходит для других инструментов Lisp.
Например, мы могли бы сказать (`mapcar 'balance accounts`), но в сообщениях мы должны написать это как:

```lisp
(mapcar #'(lambda (acct) (send acct 'balance)) accounts)
```

Мы можем решить эту проблему, определив *обобщенные* функции, которые находят правильный метод для выполнения сообщения.
Например, мы могли бы определить:

```lisp
(defun withdraw (object &rest args)
  "Define withdraw as a generic function on objects."
  (apply (get-method object 'withdraw) args))
```

а затем написать `(withdraw acct x)` вместо `(send acct 'withdraw x)`.
Функция `withdraw` является обобщенной, потому что она работает не только с объектами account, но также работает с любым другим классом объектов, которые обрабатывают сообщение `withdraw`.
Например, у нас может быть совершенно не связанный класс, `army`, который также реализует метод `withdraw`.
Затем мы могли бы сказать `(send 5th-army 'withdraw)` или `(withdraw 5th-army)` и выполнить правильный метод.
Таким образом, объектно-ориентированное программирование устраняет многие проблемы, связанные с конфликтами имен, которые возникают в обычных программах.

Многие встроенные функции Common Lisp можно считать обобщенными, поскольку они работают с разными типами данных.
Например, sqrt выполняет одно действие при передаче целого числа и совсем другое при передаче мнимого числа.
Функции работы с последовательностями (например, find или delete) работают со списками, векторами или строками.
Эти функции не реализованы, как `withdraw`, но они по-прежнему действуют как обобщенные функции.[2](#fn0020)

## 13.4 Классы

Можно писать макросы, чтобы упростить чтение и запись в объектно-ориентированном стиле.
Макрос `define-class` определяет класс со связанными с ним методами обработки сообщений.
Он также определяет обобщенную функцию для каждого сообщения.
Наконец, он позволяет программисту различать переменные, которые связаны с каждым объектом, и переменные, которые связаны с классом и являются общими для всех членов класса.
Например, вы можете захотеть, чтобы все экземпляры класса `account` имели одинаковую процентную ставку, но не хотели бы, чтобы у них был одинаковый баланс.

```lisp
(defmacro define-class (class inst-vars class-vars &body methods)
  "Define a class for object-oriented programming."
  ;; Define constructor and generic functions for methods
  `(let ,class-vars
     (mapcar #'ensure-generic-fn ',(mapcar #'first methods))
     (defun ,class ,inst-vars
       #'(lambda (message)
           (case message
             ,@(mapcar #'make-clause methods))))))

(defun make-clause (clause)
  "Translate a message from define-class into a case clause."
  `(,(first clause) #'(lambda ,(second clause) .,(rest2 clause))))

(defun ensure-generic-fn (message)
  "Define an object-oriented dispatch function for a message,
  unless it has already been defined as one."
  (unless (generic-fn-p message)
    (let ((fn #'(lambda (object &rest args)
                  (apply (get-method object message) args))))
      (setf (symbol-function message) fn)
      (setf (get message 'generic-fn) fn))))

(defun generic-fn-p (fn-name)
  "Is this a generic function?"
  (and (fboundp fn-name)
       (eq (get fn-name 'generic-fn) (symbol-function fn-name))))
```

Теперь мы определяем класс account с помощью этого макроса.
Мы делаем процентную ставку - `interest-rate` переменной класса, которая используется всеми экземплярами account:

```lisp
(define-class account (name &optional (balance 0.00))
```

                `((interest-rate .06))`

  `(withdraw (amt) (if (<= amt balance)`

                        `(decf balance amt)`

                        `'insufficient-funds))`

  `(deposit (amt) (incf balance amt))`

  `(balance () balance)`

  `(name () name)`

  `(interest () (incf balance (* interest-rate balance))))`

Здесь мы используем обобщенные функции, определенные этим макросом:

`> (setf acct2 (account "A.
User" 2000.00)) => #<CLOSURE 24003064>`

```lisp
> (deposit acct2 42.00) => 2042.0
> (interest acct2) => 2164.52
> (balance acct2) => 2164.52
> (balance acct) => 623.45
```

В этой последней строке обобщенная функция `balance` применяется к `acct`, объекту, который был создан до того, как мы даже определили класс account и функцию `balance`. Но `balance` по-прежнему правильно работает с этим объектом, потому что он подчиняется протоколу передачи сообщений.

## 13.5 Делегирование

Предположим, мы хотим создать account нового типа, в котором для каждого действия требуется пароль.
Мы можем определить новый класс `password-account`, который имеет два предложения сообщений.
Первое предложение позволяет изменить пароль (если у вас есть исходный пароль), а второе - предложение `otherwise`, которое проверяет заданный пароль и, если он правильный, передает остальные аргументы account, который защищен паролем.

Определение `password-account` использует внутренние детали `define-class` двумя способами: оно использует тот факт, что `otherwise` может использоваться как универсальное предложение в форме `case`, и он использует тот факт, что диспетчерская переменная называется `message`. Обычно полагаться на подробности реализации макроса - не лучшая идея, и вскоре мы увидим более чистые способы определения классов.
Но пока работает и этот простой подход:

```lisp
(define-class password-account (password acct) ()
```

  `(change-password (pass new-pass)`

              `(if (equal pass password)`

                `(setf password new-pass)`

                `'wrong-password))`

  `(otherwise (pass &rest args)`

              `(if (equal pass password)`

                `(apply message acct args)`

                `'wrong-password)))`

Теперь мы видим, как класс `password-account` может использоваться для защиты существующего account:

```lisp
(setf acct3 (password-account "secret" acct2)) => #<CLOSURE 33427277>
> (balance acct3 "secret") => 2164.52
> (withdraw acct3 "guess" 2000.00) => WRONG-PASSWORD
> (withdraw acct3 "secret" 2000.00) => 164.52
```

А теперь попробуем еще один пример.
Предположим, мы хотим иметь новый класс счетов - account, у которого в любое время может быть снята только ограниченная сумма денег.
Мы могли бы определить класс `limited-account`:

```lisp
(define-class limited-account (limit acct) ()
```

  `(withdraw (amt)`

              `(if (> amt limit)`

                    `'over-limit`

                    `(withdraw acct amt)))`

  `(otherwise (&rest args)`

              `(apply message acct args)))`

Это определение переопределяет сообщение `withdraw`, чтобы проверить, превышен ли лимит перед передачей сообщения, и использует предложение `withdraw` просто для передачи всех других сообщений без изменений.
В следующем примере мы настраиваем account с паролем и лимитом:

```lisp
> (setf acct4 (password-account "pass"
```

              `(limited-account 100.00`

                `(account "A.
Thrifty Spender" 500.00))))`=>

```lisp
#<CLOSURE 34136775>
> (withdraw acct4 "pass" 200.00) => OVER-LIMIT
> (withdraw acct4 "pass" 20.00) => 480.0
> (withdraw acct4 "guess" 20.00) => WRONG-PASSWORD
```

Обратите внимание, что такие функции, как `withdraw`, по-прежнему являются простыми обобщенными функциями, которые просто находят правильный метод и применяют его к аргументам.
Хитрость в том, что каждый класс определяет свой способ обработки сообщения withdraw.
Вызов `withdraw` с acct4 в качестве аргумента приводит к следующему потоку управления.
Сначала метод класса `password-account` проверяет правильность пароля.
Если это так, он вызывает метод из класса `limited-account`.
Если лимит не превышен, мы, наконец, вызываем метод из класса `account`, который уменьшает баланс.
Передача управления/контроля методу компонента называется *делегированием*.

Преимущество объектно-ориентированного стиля состоит в том, что мы можем ввести новый класс, написав одно локализованное определение, не требующее изменения какого-либо существующего кода.
Если бы мы написали это в традиционном процедурном стиле, мы бы получили следующие функции:

```lisp
(defun withdraw (acct amt &optional pass)
```

  `(cond ((and (typep acct 'password-account)`

                `(not (equal pass (account-password acct))))`

            `'wrong-password)`

            `((and (typep acct 'limited-account)`

                `(> amt (account-limit account)))`

            `'over-limit)`

            `((> amt balance)`

            `'insufficient-funds)`

            `(t (decf balance amt))))`

В этом нет ничего плохого, как в индивидуальной функции.
Проблема в том, что, когда банк решает предложить новый тип счета(account), нам придется изменить эту функцию вместе со всеми другими функциями, реализующими действия.
"Определение" нового счета(account) разрознено, а не локализовано, и изменение набора существующих функций обычно более подвержено ошибкам, чем написание нового определения класса.

## 13.6 Наследование

В следующей таблице типы данных (классы) перечислены по горизонтальной оси, а функции (сообщения) перечислены сверху в вниз по вертикальной оси.
Полная программа должна заполнить все поля, но вопрос в том, как организовать процесс их заполнения.
В традиционном процедурном стиле мы пишем определения функций, которые заполняют строку за раз.
В объектно-ориентированном стиле мы пишем определения классов, которые заполняют столбец за раз.
Третий стиль, *управляемый данными* или *обобщенный* стиль, заполняет только одно поле за раз.

|            | `account limited-account` | `password-account` | `...` |
| ---        | ---                       | ---                | ---   |
| `name`     |                           | *object*           |       |
| `deposit`  |                           | *oriented*         |       |
| `withdraw` | *function oriented*       |                    |       |
| `balance`  |                           |                    |       |
| `interest` | *generic*                 |                    |       |
| `...`      |                           |                    |       |

В этой таблице нет определенной организации ни для одной из осей; и сообщения, и классы перечислены в случайном порядке.
Это игнорирует тот факт, что классы организованы иерархически: как limited-account, так и password-account являются подклассами account.
Это подразумевается в определении классов, потому что и `limited-account` и `password-account` содержат счета в качестве компонентов и делегируют сообщения этим компонентам.
Но было бы проще сделать эту связь явной.

Механизм `defstruct` допускает именно такое явное наследование.
Если бы мы определили `account` как структуру, то мы могли бы определить `limited-account` с помощью:

```lisp
(defstruct (limited-account (:include account)) limit)
```

Для обеспечения возможности наследования классов необходимы две вещи.
Во-первых, мы должны изменить `define-class` так, чтобы он принимал имя класса для наследования в качестве второго аргумента.
Это будет сигналом того, что новый класс унаследует все переменные экземпляра, переменные класса и методы от родительского класса.
Новый класс, конечно, может определять новые переменные и методы или может затенять родительские переменные и методы.
В приведенной ниже форме мы определяем `limited-account` как подкласс `account`, который добавляет новую переменную экземпляра `limit` и переопределяет метод `withdraw`, чтобы он проверял суммы, превышающие лимит.
Если сумма приемлема, то он использует функцию `call-next-method` (еще не определенную), чтобы получить метод `withdraw`  для родительского класса `account`.

```lisp
(define-class limited-account account (limit) ()
```

  `(withdraw (amt)`

                `(if (> amt limit)`

                    `'over-limit`

                    `(call-next-method))))`

Если наследование - это хорошо, то множественное наследование еще лучше.
Например, предполагая, что мы определили классы `limited-account` и `password-account`, очень удобно определить следующий класс, который наследуется от них обоих:

```lisp
(define-class limited-account-with-password
```

                      `(password-account limited-account))`

Обратите внимание, что этот новый класс не добавляет новых переменных или методов.
Все, что он делает, это объединяет функциональность двух родительских классов в один.

**Exercise  13.1 [d]** Определите версию `define-class`, которая обрабатывает наследование и `call-next-method`

**Exercise  13.2 [d]** Определите версию `define-class`, которая обрабатывает множественное наследование.

## 13.7 CLOS: Common Lisp Object System - Объектная Система Common Lisp

До сих пор мы разрабатывали объектно-ориентированную систему программирования с использованием макроса, `define-class` и протокола для реализации объектов как замыканий.
Было много предложений по добавлению объектно-ориентированных функций в Lisp, некоторые из них похожи на наш подход, некоторые совсем другие.
Недавно был одобрен один подход, который стал официальной частью Common Lisp, поэтому мы откажемся от нашего специального подхода и посвятим оставшуюся часть этой главы CLOS, объектной системе Common Lisp.
Соответствие между нашей системой и CLOS резюмируется здесь:

| our system                   | CLOS                      |
|------------------------------|---------------------------|
| `define-class`               | `defclass`                |
| *`methods defined in class`* | `defmethod`               |
| *`class-name`*               | `make-instance`           |
| `call-next-method`           | `call-next-method`        |
| `ensure-generic-fn`          | `ensure-generic-function` |

Как и большинство объектно-ориентированных систем, CLOS в первую очередь занимается определением классов и методов для них, а также созданием экземпляров этих классов.
В CLOS макрос `defclass` определяет класс, `defmethod` определяет метод, а `make-instance` создает экземпляр класса - как объект.
Общая форма макроса `defclass`:

(`defclass`*class-name* (*superclass...*) (*slot-specifier...*) *optional-class-option...*)

Опции классов используются редко.
`defclass` может использоваться для определения класса `account`:

```lisp
(defclass account ()
```

  `((name :initarg :name ireader name)`

      `(balance :initarg :balance :initform 0.00 :accessor balance)`

      `(interest-rate :allocation :class :initform .06`

                `:reader interest-rate)))`

В определении учетной записи мы видим, что список суперклассов пуст, потому что account не наследуется ни от каких классов.
Есть три спецификатора слотов: для слотов `name`, `balance` и `interest-rate`.
За каждым именем слота могут следовать необязательные пары ключевое слово/значение, определяющие, как используется слот.
В слоте `name` есть опция `:initarg`, которая говорит, что имя может быть указано при создании новой учетной записи с помощью `make-instance`.
Слот `:reader` создает метод с именем `name` для получения текущего значения слота.

Слот баланса - balance имеет три опции: еще один `: initarg`, говорящий о том, что баланс может быть указан при создании новой учетной записи; `: initform`, который говорит, что если баланс не указан, по умолчанию он равен `0.00` и `: accessor`, который создает метод для получения значения слота так же, как `:reader`, а также создает метод обновления слота с помощью `setf`.

В слоте (процентная ставка)`interest-rate` есть опция `:initform` для присвоения ему значения по умолчанию и опция `:allocation`, указывающая, что этот слот является частью класса, а не каждого экземпляра класса.

Здесь мы видим создание объекта и применение к нему автоматически определенных методов.

```lisp
> (setf al (make-instance 'account :balance 5000.00
```

                          `:name "Fred")) => #<ACCOUNT 26726272>`

```lisp
> (name al) => "Fred"
> (balance al) => 5000.0
> (interest-rate al) => 0.06
```

CLOS отличается от большинства объектно-ориентированных систем тем, что методы определяются отдельно от классов.
Чтобы определить метод (помимо тех, которые автоматически определяются параметрами `:reader`, `:writer` или `:accessor`), мы используем макрос `defmethod`.
По форме он похож на defun:

`(defmethod`*method-name* (*parameter...*) *body...*)

Обязательные параметры для `defmethod` могут иметь форму (*var class*), что означает, что это метод, который применяется только когда аргументы являются экземплярами этого класса.
Вот способ вывода средств(withdrawing) со счета.
Обратите внимание, что CLOS не имеет понятия переменной экземпляра(instance variable), только слот экземпляра(instance slot).
Поэтому мы должны использовать метод (`balance acct`), а не переменную экземпляра `balance`:

```lisp
(defmethod withdraw ((acct account) amt)
```

  `(if (< amt (balance acct))`

    `(decf (balance acct) amt)`

    `'insufficient-funds))`

С помощью CLOS легко определить `limited-account` как подкласс `account` и определить метод `withdraw` для `limited-accounts`:

```lisp
(defclass limited-account (account)
```

  `((limit :initarg :limit :reader limit)))`

```lisp
(defmethod withdraw ((acct limited-account) amt)
```

  `(if (> amt (limit acct))`

          `'over-limit`

          `(call-next-method)))`

Обратите внимание на использование `call-next-method` для вызова метода `withdraw` для класса `account`.
Также обратите внимание, что все другие методы для счетов(account) автоматически работают с экземплярами класса `limited-account`, поскольку он определен как наследованик от `account`. В следующем примере мы показываем, что метод `name` наследуется, а метод `withdraw` для `limited-account` вызывается первым, а метод `withdraw` для account вызывается функцией `call-next-method`:

```lisp
> (setf a2 (make-instance 'limited-account
```

                        `:name "A.
Thrifty Spender"`

                        `:balance 500.00 :limit 100.00))`=>

```lisp
#<LIMITED-ACCOUNT 24155343>
```

`> (name a2) => "A.
Thrifty Spender"`

```lisp
> (withdraw a2 200.00) => OVER-LIMIT
> (withdraw a2 20.00) => 480.0
```

В общем, для данного сообщения может быть несколько методов.
В этом случае все подходящие методы собираются вместе и сортируются, в первую очередь ставяться наиболее конкретные/специфичные.
Затем вызывается наиболее конкретный метод.
Вот почему сначала вызывается метод для `limited-account`, а не метод для `account.`. Функция `call-next-method` может использоваться в теле метода для вызова следующего наиболее конкретного метода.

Полная история на самом деле даже сложнее, чем эта.
В качестве одного из примеров усложнения рассмотрим класс `audited-account`, который распечатывает и отслеживает все депозиты и снятие средств.
Его можно определить следующим образом, используя новую функциональность CLOS, методы `:before` и `:after`:

```lisp
(defclass audited-account (account)
```

  `((audit-trail :initform nil :accessor audit-trail)))`

```lisp
(defmethod withdraw :before ((acct audited-account) amt)
```

  `(push (print '(withdrawing ,amt))`

    `(audit-trail acct)))`

```lisp
(defmethod withdraw :after ((acct audited-account) amt)
```

  `(push (print '(withdrawal (,amt) done))`

    `(audit-trail acct)))`

Теперь вызов функции `withdraw` с `audited-account` в качестве первого аргумента дает три применимых метода: основной метод из `account` и методы `:before` и `:after`.
В общем, таких методов может быть несколько.
В этом случае все методы `:before` вызываются по порядку, сначала наиболее конкретные.
Затем вызывается наиболее конкретный первичный метод.
Он может выбрать вызов `cal1-next-method` для доступа к другим методам.
(Для метода :`before` или :`after` использование метода `call-next-method` является ошибкой.) Наконец, вызываются все методы :`after`, наименее специфичные в первую очередь.

Значения из методов `:before` и `:after` игнорируются, и возвращается значение из основного метода.
Вот пример:

```lisp
> (setf a3 (make-instance 'audited-account :balance 1000.00))
#<AUDITED-ACCOUNT 33555607>
> (withdraw a3 100.00)
(WITHDRAWING 100.0)
(WITHDRAWAL (100.0) DONE)
900.0
> (audit-trail a3)
((WITHDRAWAL (100.0) DONE) (WITHDRAWING 100.0))
> (setf (audit-trail a3) nil)
NIL
```

Последнее взаимодействие показывает самый большой недостаток CLOS: он не может инкапсулировать информацию.
Чтобы сделать `audit-trail` доступным для методов `withdraw`, мы должны были предоставить ему методы доступа.
Мы хотели бы инкапсулировать функцию записи для `audit-trail`, чтобы ее можно было использовать только с `депозитом` и `withdraw`.
Но как только функция записи определена, ее можно использовать где угодно, поэтому недобросовестный посторонний может уничтожить журнал аудита(`audit-trail`), установив для него значение nil или что-то еще.

## 13.8 A CLOS Example: Searching Tools

CLOS является наиболее подходящим, когда есть несколько типов, которые разделяют связанное поведение.
Хорошим примером приложения, которое соответствует этому описанию, является набор инструментов для поиска, определенных в  [разделе 6.4](B9780080571157500066.xhtml#s0025).
Там мы определили функции для поиска в ширину(breadth-first), в глубину(depth-first) и поиска первого лучшего(best-first), а также по дереву или графу.
Мы также определили функции для поиска в определенных доменах(областях), таких как планирование маршрута между городами.

Если бы мы писали инструменты в простом, процедурном стиле, мы получили бы десятки похожих функций.
Вместо этого мы использовали функции высшего порядка для управления сложностью.
В этом разделе мы увидим как CLOS можно использовать для уменьшения сложности немного другим способом.

Начнем мы с определения класса поисковых задач.
Задачи будут классифицироваться в соответствии с их предметной областью (планирование маршрутов и т.д.), их топологией (дерево или граф) и их стратегией поиска(в ширину(breadth-first) или в глубину(depth-first) и т.д.).
Каждая комбинация этих признаков приводит к  новому классу задач.
Это позволяет пользователю легко добавлять новый класс для представления  нового домена(области) или  новой стратегии поиска.
Базовый класс поисковых задач - `problem`, содержит переменную существующую в одном экземпляре для хранения неисследованных состояний задачи.

```lisp
(defclass problem ()
```

  `((states :initarg :states :accessor problem-states)))`

Функция поиска - searcher аналогична функции `tree-search` из [раздела 6.4](B9780080571157500066.xhtml#s0025).
Основное отличие состоит в том, что searcher использует обобщенные функции вместо передачи функциональных аргументов.

```lisp
(defmethod searcher ((prob problem))
```

  `"Find a state that solves the search problem."`

  `(cond ((no-states-p prob) fail)`

    `((goal-p prob) (current-state prob))`

    `(t (let ((current (pop-state prob)))`

              `(setf (problem-states prob)`

                  `(problem-combiner`

                    `prob`

                    `(problem-successors prob current)`

                    `(problem-states prob))))`

            `(searcher prob))))`

searcher не предполагает, что состояния проблемы организованы в виде списка; скорее он использует обобщенную функцию `no-states-p` для проверки наличия каких-либо состояний, `pop-state` для удаления и возврата первого состояния и `current-state` для доступа к первому состоянию.
Для базового класса `problem`, мы фактически реализуем состояния в виде списка, но другой класс задач(проблем) может использовать другое представление.

```lisp
(defmethod current-state ((prob problem))
```

  `"The current state is the first of the possible states."`

  `(first (problem-states prob)))`

```lisp
(defmethod pop-state ((prob problem))
```

  `"Remove and return the current state."`

  `(pop (problem-states prob)))`

```lisp
(defmethod no-states-p ((prob problem))
```

  `"Are there any more unexplored states?"`

  `(null (problem-states prob)))`

В `tree-search` мы включили оператор для вывода отладочной информации.
Мы можем сделать это и здесь, но мы можем скрыть это в отдельном методе, чтобы не загромождать основное определение `searcher`.
Это метод `:before`, поскольку мы ходтим увидеть вывод перед выполнением операции.

```lisp
(defmethod searcher :before ((prob problem))
```

  `(dbg 'search ";; Search: ~a" (problem-states prob)))`

Обобщенные функции, которе еще предстоит определить, это `goal-p, problem-combiner,` и `problem-successors`.
Сначала мы обратимся к `goal-p`, осознавая, что для многих проблем мы будем скать состояние, которое соответствует, в смысле - `eql` указанному состоянию цели.
Мы определяем класс `eql-problem` для ссылки на такие проблемы, и указываем `goal-p` для этого класса.
Обратите внимание, что мы позволяем указывать цель при создании проблемы, но не изменять цель:

```lisp
(defclass eql-problem (problem)
```

  `((goal rinitarg :goal :reader problem-goal)))`

```lisp
(defmethod goal-p ((prob eql-problem))
```

  `(eql (current-state prob) (problem-goal prob)))`

Теперь мы готовы определить две стратегии: поиск в глубину(depth-first) и поиск в ширину(breadth-first).
Мы определяем классы задач для каждой стратегии и указываем функцию `problem-combiner`:

```lisp
(defclass dfs-problem (problem) ()
```

  `(:documentation "Depth-first search problem."))`

```lisp
(defclass bfs-problem (problem) ()
```

  `(:documentation "Breadth-first search problem."))`

```lisp
(defmethod problem-combiner ((prob dfs-problem) new old)
```

  `"Depth-first search looks at new states first."`

  `(append new old))`

```lisp
(defmethod problem-combiner ((prob bfs-problem) new old)
```

  `"Depth-first search looks at old states first."`

  `(append old new))`

Хотя этого кода будет достаточно длял наших целей, он далеко не идеален, поскольку разрушает барьер, скрывающей информацию.
Он обрабатывает набор старых состояний как список, который используется по умолчанию для класса `problem`, но это не обзяательно является реализацией, которую будет использовать каждый класс.
Было бы проще(чище) определить обобщенные функции `add-states-to-end` и `add-states-to-front`,  а затем определить с их помощью `append` в классе по умолчанию.
Но Лисп предоставляет такие удобные примитивы для работы со списками, что трудно избежать соблазна использовать их напрямую.

Конечно, пользователь определяющий новую реализацию для `problem-states` может просто переопределить `problem-combiner` для нарушающих классов, но это именно то, чего объектно-ориентированное программирование призвано избегать: указание однойо асбтрации (состояний/states) не долна нас заставлять что-либо менять в другой абстракции (стратегии поиска).

Последний шаг - это определение класса, представляющего определенный домен(область), и определение `problem-successors` для этого домена.
В качестве первого примера рассмотрим простой поиск по бинарному дереву из [раздела 6.4](B9780080571157500066.xhtml#s0025).
Естественно, он будет представлен в виде класса:

```lisp
(defclass binary-tree-problem (problem) ())
(defmethod problem-successors ((prob binary-tree-problem) state)
```

  `(let ((n (* 2 state)))`

      `(list n (+ n 1))))`

Теперь предположим мы хотим решить проблему определенную в виде бинарного дерева (binary-tree problem) с помощью поиска в ширину, ища конкретную цель.
Просто создадим класс, который сочетает в `binary-tree-problem, eql-problem` и `bfs-problem,` создадим экземпляр этого класса и вызовем `searcher` для этого экземпляра:

```lisp
(defclass binary-tree-eql-bfs-problem
```

            `(binary-tree-problem eql-problem bfs-problem) ())`

```lisp
> (setf pl (make-instance 'binary-tree-eql-bfs-problem
```

                          `:states '(1) :goal 12))`

```lisp
#<BINARY-TREE-EQL-BFS-PROBLEM 26725536>
> (searcher pl)
;; Search: (1)
;; Search: (2 3)
;; Search: (3 4 5)
;; Search: (4 5 6 7)
;; Search: (5 6 7 8 9)
;; Search: (6 7 8 9 10 11)
;; Search: (7 8 9 10 11 12 13)
;; Search: (8 9 10 11 12 13 14 15)
;; Search: (9 10 11 12 13 14 15 16 17)
;; Search: (10 11 12 13 14 15 16 17 18 19)
;; Search: (11 12 13 14 15 16 17 18 19 20 21)
;; Search: (12 13 14 15 16 17 18 19 20 21 22 23)
12
```

### Поиск первого лучшего(Best-First)

Должно быть ясно, как продолжить определение поиска первый лучший(best-first): определить класс для представления задачи поиска первого лучшего, а затем определить необходимые методы для этого класса.
Так как стратегия поиска влияет только на порядок в котором исследуются состояния, единственный необходимый метод - это `problem-combiner`.

```lisp
(defclass best-problem (problem) ()
```

  `(:documentation "A Best-first search problem."))`

```lisp
(defmethod problem-combiner ((prob best-problem) new old)
```

  `"Best-first search sorts new and old according to cost-fn."`

  `(sort (append new old) #'<`

            `:key #'(lambda (state) (cost-fn prob state))))`

Здесь вводится новая функция `cost-fn`; естественно, это будет обобщенная функция.
Ниже приводится `cost-fn`, которая подходит для любой `eql-problem` имеющей дело с числами, но ожидается что большинство доменов(областей) будут сами определять эту функцию.

```lisp
(defmethod cost-fn ((prob eql-problem) state)
```

  `(abs (- state (problem-goal prob))))`

Поиск по лучу - это модификация поиска первый лучший(best-first), где все состояния, кроме b лучших состояний, отбрасываются на каждой итерации.
Задача поиска по лучу представлена классом, в котором переменная экземпляра `beam-width` содержит параметр *b*.
Если он nil, то выполняется полный поиск первого лучшего(best-first).
Поиск по лучу реализуется методом `:around` над `problem-combiner`.
Он вызывает следующий метод, чтобы получить список состояний, полученных с помощью поиска первого лучшего(best-first), а затем извлекает *b* первых элементов.

```lisp
(defclass beam-problem (problem)
```

  `((beam-width :initarg :beam-width :initform nil`

                  `:reader problem-beam-width)))`

```lisp
(defmethod problem-combiner :around ((prob beam-problem) new old)
```

  `(let ((combined (call-next-method)))`

      `(subseq combined 0 (min (problem-beam-width prob)`

                          `(length combined)))))`

Теперь мы применяем поиск по лучу к задаче бинарного дерева(binary-tree problem).
Как обычно, мы должны создать другой класс, чтобы представить этот тип проблемы:

```lisp
(defclass binary-tree-eql-best-beam-problem
```

  `(binary-tree-problem eql-problem best-problem beam-problem)`

  `())`

```lisp
> (setf p3 (make-instance 'binary-tree-eql-best-beam-problem
```

                          `:states '(1) :goal 12 :beam-width 3))`

```lisp
#<BINARY-TREE-EQL-BEST-BEAM-PROBLEM 27523251>
> (searcher p3)
;; Search: (1)
;; Search: (3 2)
;; Search: (7 6 2)
;; Search: (14 15 6)
;; Search: (15 6 28)
;; Search: (6 28 30)
;; Search: (12 13 28)
12
```

Пока аргументы в пользу CLOS неубедительны.
Код в этом разделе дублирует функциональность кода из [раздела 6.4](B9780080571157500066.xhtml#s0025), но код CLOS имеет тенденцию быть более многословным, и несколько беспокоит то, что нам пришлось составлять так много длинных имен классов.
Однако, такая многословность прибодит к гибкости и код CLOS проще расширить, добавив н овые специализированные классы.
Полезно проводить различие между системным программистом и прикладным программистом.
Системный программист предоставит библиотеку классов, подобную `dfs-problem` и обобщенных функций, таких как `searcher`.
Затем прикладной программист просто выбирает из библиотеки то, что нужно.
Из следующего мы видим, что выбрать правильный код для определения поисковика(searcher) планирования поездки не так уж и сложно.
Сравните его с определением `trip` со страници 198, чтобы увидеть предпочтете ли вы CLOS в этом случае.
Основное отличие состоит в том, что здесь мы говорим, что функция стоимости это `air-distance`, а преемники(successors) являются соседями - `neighbors` по определению методов; в `trip` мы сделали это, передав их в виде параметров.
Последнее немного более кратко, но первое может быть более понятным, тем более что количество параметров растет.

```lisp
(defclass trip-problem (binary-tree-eql-best-beam-problem)
```

  `((beam-width :initform 1)))`

```lisp
(defmethod cost-fn ((prob trip-problem) city)
```

  `(air-distance (problem-goal prob) city))`

```lisp
(defmethod problem-successors ((prob trip-problem) city)
```

  `(neighbors city))`

With the definitions in place, it is easy to use the searching tool:

```lisp
> (setf p4 (make-instance 'trip-problem
```

                        `:states (list (city 'new-york))`

                        `:goal (city 'san-francisco)))`

```lisp
#<TRIP-PROBLEM 31572426>
> (searcher p4)
;; Search: ((NEW-YORK 73.58 40.47))
;; Search: ((PITTSBURG 79.57 40.27))
;; Search: ((CHICAGO 87.37 41.5))
;; Search: ((KANSAS-CITY 94.35 39.06))
;; Search: ((DENVER 105.0 39.45))
;; Search: ((FLAGSTAFF 111.41 35.13))
;; Search: ((RENO 119.49 39.3))
;; Search: ((SAN-FRANCISCO 122.26 37.47))
(SAN-FRANCISCO 122.26 37.47)
```

## 13.9 Действительно ли CLOS Объектно-Ориентированный?

Есть некоторые аргументы в пользу того, действительно ли CLOS вообще объектно-ориентирован.
Аргументы следующие:

CLOS *является* объектно-ориентированной системой, потому что она обеспечивает все три основных критерия объектной ориентации: объекты с внутренним состоянием, классы объектов со специализированным поведением для каждого класса и наследованием между классами.

CLOS *не* объектно-ориентированная система, потому что она не предоставляет модульным объектам сокрытие информации.
В примере `audited-account` мы хотели бы инкапсулировать переменную экземпляра `audit-trail`, чтобы только методы `withdraw` могли ее изменить.
Но поскольку методы написаны отдельно от определений классов, мы не можем этого сделать.
Вместо этого нам пришлось определить метод доступа для `audit-trail`.
Это позволило нам написать методы `withdraw`, но также позволяет кому-либо еще изменить контрольный журнал.

CLOS является *более общей, чем* объектно-ориентированная система, потому что позволяет использовать методы, которые специализируются на более чем одном аргументе.
В настоящих объектно-ориентированных системах методы связаны с объектами определенного класса.
Эта ассоциация лексически очевидна (и метафора передачи сообщений ясна), когда мы пишем методы внутри определения класса, как в нашем макросе `define-class`.
Метафора передачи сообщений по-прежнему очевидна, когда мы пишем обобщенные функции, применение которых определяется/выбирается по классу их первого аргумента, как мы до сих пор использовали CLOS.

Но методы CLOS могут определяться по классу любого требуемого аргумента или любой их комбинации.
Рассмотрим следующее определение `conc`, которое похоже на `append`, за исключением того, что оно работает как для векторов, так и для списков.
Вместо того, чтобы писать `conc` с использованием условных операторов, мы можем использовать возможности диспетчеризации мультиметодов CLOS для определения четырех случаев: (1) первый аргумент равен nil, (2) второй аргумент равен nil, (3) оба аргумента являются списками , и (4) оба аргумента являются векторами.
Обратите внимание, что если один из аргументов равен nil, будут применяться два метода, но будет использоваться метод для `null`, потому что класс `null` более специфичен, чем класс `list`.

```lisp
(defmethod conc ((x null) y) y)
(defmethod conc (x (y null)) x)
(defmethod conc ((x list) (y list))
```

  `(cons (first x) (conc (rest x) y)))`

```lisp
(defmethod conc ((x vector) (y vector))
```

  `(let ((vect (make-array (+ (length x) (length y)))))`

      `(replace vect x)`

      `(replace vect y :startl (length x))))`

Здесь мы видим, что это определение работает:

```lisp
> (conc nil '(a b c)) => (A B C)
> (conc '(a b c) nil) => (A B C)
> (conc '(a b c) '(d e f)) => (A B C D E F)
```

`> (conc '#(a b c) '#(d e f))`=> `#(A B C D E F)`

Это работает, но можно спросить: а где объекты?
Метафора передачи сообщения объекту здесь неприменима, если только мы не рассматриваем объект как список аргументов, а не как один привилегированный аргумент.

Поразительно, что этот стиль определения метода очень похож на стиль, используемый в Prolog.
В качестве другого примера сравним следующие два определения `len`, отношения/функции для вычисления длины списка:

```
;; CLOS
(defmethod len ((x null)) 0)
(defmethod len ((x cons))
(+  1 (len (rest x))))
```

```
%% Prolog
len([],0).
len(CXIL].N1) :-
len(L.N). NI is N+1.
```

## 13.10 Преимущества объектно-ориентированного программирования

Бертран Мейер в своей книге об объектно-ориентированном языке Eiffel (1988) перечисляет пять качеств, которые влияют на качество программного обеспечения:

*   *Правильность*.
Ясно, что правильная программа имеет первостепенное значение.

*   *Надежность*.
Программы должны продолжать работать надлежащим образом даже при вводе, выходящем за рамки исходных спецификаций.

*   *Расширяемость*.
Программы должны легко изменяться при изменении технических характеристик.

*   *Возможность повторного использования *.
Компоненты программы должны легко переноситься в новые программы, тем самым окупая затраты на разработку программного обеспечения на нескольких проектах.

*   *Совместимость*.
Программы должны хорошо взаимодействовать с другими программами.
Например, программа для работы с электронными таблицами должна не только правильно манипулировать числами, но и быть совместимой с программами обработки текстов, чтобы таблицы можно было легко включать в документы.

Здесь мы перечисляем, как объектно-ориентированный подход в целом и CLOS в частности могут повлиять на эти показатели качества:

*   *Правильность *.
Правильность обычно достигается в два этапа: правильность отдельных модулей и правильность всей системы.
Объектно-ориентированный подход упрощает доказательство правильности модулей, поскольку они четко определены, и может облегчить анализ взаимодействия между модулями, поскольку интерфейс строго ограничен.
CLOS не обеспечивает сокрытие информации, как это делают другие системы.

*   *Надежность*.
Обобщенные функции дают возможность функциям принимать во время выполнения класс аргумента, который программист не ожидал во время компиляции.
Это особенно верно в случае CLOS, потому что множественное наследование позволяет писать методы по умолчанию, которые могут использоваться широким спектром классов.

*   *Расширяемость *.
Объектно-ориентированные системы с наследованием позволяют легко определять новые классы, которые являются незначительными отличиями существующих.
Опять же, множественное наследование CLOS делает процесс расширения даже проще, чем в системах с одиночным наследованием.

*   *Возможность повторного использования*.
Это та область, где объектно-ориентированный стиль вносит наибольший вклад.
Вместо того, чтобы писать каждую новую программу с нуля, объектно-ориентированные программисты могут просматривать библиотеку классов и либо повторно использовать существующие классы как есть, либо специализировать существующий класс посредством наследования.
Большие библиотеки классов CLOS еще не появились.
Возможно, они сделают это, когда язык станет более устоявшимся.

*   *Совместимость*.
Чем больше программ использует стандартные компоненты, тем больше они смогут взаимодействовать друг с другом.
Таким образом, объектно-ориентированная программа, вероятно, будет совместима с другими программами, разработанными на основе той же библиотеки классов.

## 13.11 История и Ссылки

The first object-oriented language was Simula, which was designed by Ole-Johan Dahl and Krysten Nygaard ([1966](B9780080571157500285.xhtml#bb0265), [Nygaard and Dahl 1981](B9780080571157500285.xhtml#bb0920)) as an extension of Algol 60.
It is still in use today, mostly in Norway and Sweden.
Simula provides the ability to define classes with single inheritance.
Methods can be inherited from a superclass or overridden by a subclass.
It also provides *coroutines*, class instances that execute continuously, saving local state in instance variables but periodically pausing to let other coroutines run.
Although Simula is a general-purpose language, it provides special support for simulation, as the name implies.
The built-in class `simulation` allows a programmer to keep track of simulated time while running a set of processes as coroutines.

In 1969 Alan Kay was a graduate student at the University of Utah.
He became aware of Simula and realized that the object-oriented style was well suited to his research in graphies ([Kay 1969](B9780080571157500285.xhtml#bb0600)).
A few years later, at Xerox, he joined with Adele Goldberg and Daniel Ingalls to develop the Smalltalk language (see [Goldberg and Robinson 1983](B9780080571157500285.xhtml#bb0475)).
While Simula can be viewed as an attempt to add object-oriented features to strongly typed Algol 60, Smalltalk can be seen as an attempt to use the dynamic, loosely typed features of Lisp, but with methods and objects replacing functions and s-expressions.
In Simula, objects existed alongside traditional data types like numbers and strings; in Smalltalk, every datum is an object.
This gave Smalltalk the feel of an integra ted Lisp environment, where the user can inspect, copy, or edit any part of the environment.
In fact, it was not the object-oriented features of Smalltalk per se that have made a lasting impression but rather the then-innovative idea that every user would have a large graphical display and could interact with the system using a mouse and menus rather than by typing commands.

Guy Steele's *LAMBDA: The Ultimate Declarative* (1976a and b) was perhaps the first paper to demonstrate how object-oriented programming can be done in Lisp.
As the title suggests, it was all done using `lambda,` in a similar way to our `define-class` example.
Steele summarized the approach with the equation "Actors = Closures (mod Syntax)," refering to Cari Hewitt's "Actors" object-oriented formalism.

In 1979, the MIT Lisp Machine group developed the Flavors system based on this approach but offering considerable extensions ([Cannon 1980](B9780080571157500285.xhtml#bb0155), [Weinreb 1980](B9780080571157500285.xhtml#bb1360), [Moon et al.
1983](B9780080571157500285.xhtml#bb0860)).
"Flavor" was a popular jargon word for "type" or "kind" at MIT, so it was natural that it became the term for what we call classes.

The Flavor system was the first to support multiple inheritance.
Other languages shunned multiple inheritance because it was too dynamic.
With single inheritance, each instance variable and method could be assigned a unique offset number, and looking up a variable or method was therefore trivial.
But with multiple inheritance, these computations had to be done at run time.
The Lisp tradition enabled programmers to accept this dynamic computation, when other languages would not.
Once it was accepted, the MIT group soon came to embrace it.
They developed complex protocols for combining different flavors into new ones.
The concept of *mix-ins* was developed by programmers who frequented Steve's Ice Cream parlor in nearby Davis Square.
Steve's offered a list of ice cream flavors every day but also offered to create new flavors-dynamically-by mixing in various cookies, candies, or fruit, at the request of the individual customer.
For example, Steve's did not have chocolate-chip ice cream on the menu, but you could always order vanilla ice cream with chocolate chips mixed in.[3](#fn0025)

This kind of "flavor hacking" appealed to the MIT Lisp Machine group, who adopted the metaphor for their object-oriented programming system.
All flavors inherited from the top-mostflavor in the hierarchy: vanilla.
In the window system, for example, the flavor `basic-window` was defined to support the minimal functionality of all windows, and then new flavors of window were defined by combining mix-in flavors such as `scroll-bar-mixin`, `label-mixin`, and `border-mixin`.
These mix-in flavors were used only to define other flavors.
Just as you couldn't go into Steve's and order "crushed Heath bars, hold the ice cream," there was a mechanism to prohibit instantiation of mix-ins.

A complicated repetoire of *method combinations* was developed.
The default method combination on Flavors was similar to CLOS: first do all the :`before` methods, then the most specific primary method, then the `:after` methods.
But it was possible to combine methods in other ways as well.
For example, consider the `inside-width` method, which returns the width in pixels of the usuable portion of a window.
A programmer could specify that the combined method for `inside-width` was to be computed by calling all applicable methods and summing them.
Then an `inside-width` method for the `basic-window` flavor would be defined to return the width of the full window, and each mix-in would have a simple method to say how much of the width it consumed.
For example, if borders are 8 pixels wide and scroll bars are 12 pixels wide, then the `inside-width` method for `border-mixin` returns `-8` and `scroll-bar-mixin` returns `-  12`.
Then any window, no matter how many mix-ins it is composed of, automatically computes the proper inside width.

In 1981, Symbolics came out with a more efficient implementation of Flavors.
Objects were no longer just closures.
They were still funcallable, but there was additional hardware support that distinguished them from other functions.
After a few years Symbolics abandoned the (send *object message*) syntax in favor of a new syntax based on generic functions.
This system was known as New Flavors.
It had a strong influence on the eventual CLOS design.

The other strong influence on CLOS was the CommonLoops system developed at Xerox PARC.
(See [Bobrow 1982](B9780080571157500285.xhtml#bb0095), [Bobrow et al.
1986](B9780080571157500285.xhtml#bb0105), [Stefik and Bobrow 1986](B9780080571157500285.xhtml#bb1185).) CommonLoops continued the New Flavors trend away from message passing by introducing *multimethods*: methods that specialize on more than one argument.

As of summer 1991, CLOS itself is in a state of limbo.
It was legitimized by its appearance in *Common Lisp the Language*, 2d edition, but it is not yet official, and an important part, the metaobject protocol, is not yet complete.
A tutorial on CLOS is [Keene 1989](B9780080571157500285.xhtml#bb0620).

We have seen how easy it is to build an object-oriented system on top of Lisp, using `lambda` as the primary tool.
An interesting alternative is to build Lisp on top of an object-oriented system.
That is the approach taken in the Oaklisp system of [Lang and Perlmutter (1988)](B9780080571157500285.xhtml#bb0695).
Instead of defining methods using `lambda` as the primitive, Oaklisp has `add-method` as a primitive and defines `lambda` as a macro that adds a method to an anonymous, empty operation.

Of course, object-oriented systems are thriving outside the Lisp world.
With the success of UNIX-based workstations, C has become one of the most widely available programming languages.
C is a fairly low-level language, so there have been several attempts to use it as a kind of portable assembly language.
The most successful of these attempts is C++, a language developed by Bjarne Stroustrup of AT&T Bell Labs ([Stroustrup 1986](B9780080571157500285.xhtml#bb1210)).
C++ provides a number of extensions, including the ability to define classes.
However, as an add-on to an existing language, it does not provide as many features as the other languages discussed here.
Crucially, it does not provide garbage collection, nor does it support fully generic functions.

Eiffel ([Meyer 1988](B9780080571157500285.xhtml#bb0830)) is an attempt to define an object-oriented system from the ground up rather than tacking it on to an existing language.
Eiffel supports multiple inheritance and garbage collection and a limited amount of dynamic dispatching.

So-called modern languages like Ada and Modula support information-hiding through generic functions and classes, but they do not provide inheritance, and thus can not be classified as true object-oriented languages.

Despite these other languages, the Lisp-based object-oriented systems are the only ones since Smalltalk to introduce important new concepts: multiple inheritance and method combination from Flavors, and multimethods from CommonLoops.

## 13.12 Упражнения

**Exercise  13.3 [m]** Implement `deposit` and `interest` methods for the `account` class using CLOS.

**Exercise  13.4 [m]** Implement the `password-account` class using CLOS.
Can it be done as cleanly with inheritance as it was done with delegation?
Or should you use delegation within CLOS?

**Exercise  13.5 [h]** Implement graph searching, search paths, and A* searching as classes in CLOS.

**Exercise  13.6 [h]** Implement a priority queue to hold the states of a problem.
Instead of a list, the `problem-states` will be a vector of lists, each initially null.
Each new state will have a priority (determined by the generic function `priority`) which must be an integer between zero and the length of the vector, where zero indicates the highest priority.
A new state with priority *p* is pushed onto element *p* of the vector, and the state to be explored next is the first state in the first nonempty position.
As stated in the text, some of the previously defined methods made the unwarranted assumption that `problem-states` would always hold a list.
Change these methods.

----------------------

[1](#xfn0015) More accurately, we have a guarantee that there is no way to get at the inside of a closure using portable Common Lisp code.
Particular implementations may provide debugging tools for getting at this hidden information, such as `inspect`.
So closures are not perfect at hiding information from these tools.
Of course, no information-hiding method will be guaranteed against such covert channels-even with the most sophisticated software security measures, it is always possible to, say, wipe a magnet over the computer's disks and alter sensitive data.
!!!(p) {:.ftnote1}

[2](#xfn0020) There is a technical sense of "generic function" that is used within CLOS.
These functions are not generic according to this technical sense.
!!!(p) {:.ftnote1}

[3](#xfn0025) Flavor fans will be happy to know that Steve's Ice Cream is now sold nationally in the United States.
Alas, it is not possible to create flavors dynamically.
Also, be warned that Steve's was bought out by his Teal Square rival, Joey's.
The original Steve retired from the business for years, then came back with a new line of stores under his last name, Harrell.
!!!(p) {:.ftnote1}