#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter4.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-10-16 11:25+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter4.md:3
msgid ""
"# Chapter 4\n"
"## GPS: The General Problem Solver"
msgstr ""
"# Глава 4\n"
"## GPS:  Универсальный решатель проблем(General problem Solver)"

#: in/chapter4.md:5
msgid "> *There are now in the world machines that think.*"
msgstr "> *Сейчас в мире есть машины, которые думают.*"

#: in/chapter4.md:7
msgid "> -Herbert Simon"
msgstr ""

#: in/chapter4.md:9
msgid "> Nobel Prize-winning Al researcher"
msgstr ""

#: in/chapter4.md:13
msgid ""
"The General Problem Solver, developed in 1957 by Alan Newell and Herbert "
"Simon, embodied a grandiose vision: a single computer program that could "
"solve *any* problem, given a suitable description of the problem.\n"
"GPS caused quite a stir when it was introduced, and some people in AI felt "
"it would sweep in a grand new era of intelligent machines.\n"
"Simon went so far as to make this statement about his creation:"
msgstr ""
"Универсальный решатель проблем, разработанный в 1957 году Аланом Ньюэллом и "
"Гербертом Саймоном, воплощал грандиозное видение: единую компьютерную "
"программу, которая могла бы решить любую проблему, получив соответствующее "
"описание проблемы.\n"
"GPS вызвал настоящий ажиотаж, когда он был представлен, и некоторые люди в "
"ИИ чувствовали, что он открыл грандиозную новую эру интеллектуальных машин.\n"
"Саймон зашел так далеко, что сделал это заявление о своем творении:"

#: in/chapter4.md:16
msgid ""
"> *It is not my aim to surprise or shock you.... But the simplest way I can "
"summarize is to say that there are now in the world machines that think, "
"that learn and create.\n"
"Moreover, their ability to do these things is going to increase rapidly "
"until-in a visible future-the range of problems they can handle will be "
"coextensive with the range to which the human mind has been applied.*"
msgstr ""
"> *В мои намерения не входит удивлять или шокировать вас.... Но самый "
"простой способ подвести итог-это сказать, что сейчас в мире существуют "
"машины, которые думают, учатся и творят.*\n"
">*Более того, их способность делать эти вещи будет быстро возрастать до тех "
"пор, пока - в обозримом будущем - диапазон проблем, с которыми они могут "
"справиться, не станет соразмерным с диапазоном, к которому может быть "
"применен человеческий разум.*"

#: in/chapter4.md:20
msgid ""
"Although GPS never lived up to these exaggerated claims, it was still an "
"important program for historical reasons.\n"
"It was the first program to separate its problem solving strategy from its "
"knowledge of particular problems, and it spurred much further research in "
"problem solving.\n"
"For all these reasons, it is a fitting object of study."
msgstr ""
"Хотя GPS никогда не соответствовала этим преувеличенным заявлениям, она все "
"же является важной программой по историческим причинам.\n"
"Это была первая программа, которая отделила свою стратегию решения проблем "
"от знания конкретных проблем, и она стимулировала дальнейшие исследования в "
"области решения проблем.\n"
"По всем этим причинам она является подходящим для изучения объектом."

#: in/chapter4.md:27
msgid ""
"The original GPS program had a number of minor features that made it quite "
"complex.\n"
"In addition, it was written in an obsolete low-level language, IPL, that "
"added gratuitous complexity.\n"
"In fact, the confusing nature of IPL was probably an important reason for "
"the grand claims about GPS.\n"
"If the program was that complicated, it *must* do something important.\n"
"We will be ignoring some of the subtleties of the original program, and we "
"will use Common Lisp, a much more perspicuous language than IPL.\n"
"The result will be a version of GPS that is quite simple, yet illustrates "
"some important points about AI."
msgstr ""
"Оригинальная программа GPS имела ряд незначительных особенностей, которые "
"делали ее довольно сложной.\n"
"Кроме того, она была написана на устаревшем низкоуровневом языке IPL, что "
"добавляло ей неоправданной сложности.\n"
"На самом деле запутанная природа IPL, вероятно, была важной причиной для "
"грандиозных заявлений о GPS.\n"
"Если программа была настолько сложной, она должна была сделать что-то "
"важное.\n"
"Мы будем игнорировать некоторые тонкости оригинальной программы, и мы будем "
"использовать Common Lisp, гораздо более ясный язык, чем IPL.\n"
"Результатом будет версия GPS, которая довольно проста, но иллюстрирует "
"некоторые важные моменты ИИ."

#: in/chapter4.md:37
msgid ""
"On one level, this chapter is about GPS.\n"
"But on another level, it is about the process of developing an AI computer "
"program.\n"
"We distinguish five stages in the development of a program.\n"
"First is the problem description, which is a rough idea-usually written in "
"English prose-of what we want to do.\n"
"Second is the program specification, where we redescribe the problem in "
"terms that are closer to a computable procedure.\n"
"The third stage is the implementation of the program in a programming "
"language such as Common Lisp, the fourth is testing, and the fifth is "
"debugging and analysis.\n"
"The boundaries between these stages are fluid, and the stages need not be "
"completed in the order stated.\n"
"Problems at any stage can lead to a change in the previous stage, or even to "
"complete redesign or abandonment of the project.\n"
"A programmer may prefer to complete only a partial description or "
"specification, proceed directly to implementation and testing, and then "
"return to complete the specification based on a better understanding."
msgstr ""
"С одной стороны, эта глава посвящена GPS.\n"
"Но на другом уровне речь идет о процессе разработки компьютерной программы "
"искусственного интеллекта.\n"
"Мы выделяем пять этапов в разработке программы.\n"
"Во-первых, это описание проблемы, которое представляет собой приблизительное "
"представление - обычно написанное простым текстом - о том, что мы хотим "
"сделать.\n"
"Во-вторых, это спецификация программы, где мы заново описываем проблему в "
"терминах, которые ближе к вычислительной процедуре.\n"
"Третий этап-это реализация программы на таком языке программирования, как "
"Common Lisp, Четвертый-тестирование, и Пятый-отладка и анализ.\n"
"Границы между этими стадиями изменчивы, и стадии не обязательно завершаются "
"в указанном порядке.\n"
"Проблемы на любом этапе могут привести к изменению предыдущего этапа или "
"даже к полному перепроектированию или отказу от проекта.\n"
"Программист может предпочесть завершить только частичное описание или "
"спецификацию, перейти непосредственно к реализации и тестированию, а затем "
"вернуться к завершению спецификации на основе улучшевшегося понимания."

#: in/chapter4.md:40
msgid ""
"We follow all five stages in the development of our versions of GPS, with "
"the hope that the reader will understand GPS better and will also come to "
"understand better how to write a program of his or her own.\n"
"To summarize, the five stages of an AI programming project are:"
msgstr ""
"Мы пройдем по всем пяти этапам разработки наших версий GPS, надеясь, что "
"читатель лучше поймет GPS, а также лучше поймет, как написать собственную "
"программу.\n"
"Подводя итог, можно выделить пять этапов проекта по программированию "
"искусственного интеллекта:"

#: in/chapter4.md:42
msgid "1.  **Describe** the problem in vague terms"
msgstr "1.  **Опишите** проблему в расплывчатых терминах"

#: in/chapter4.md:44
msgid "2.  **Specify** the problem in algorithmic terms"
msgstr "2.  **Определите** задачу в алгоритмических терминах"

#: in/chapter4.md:46
msgid "3.  **Implement** the problem in a programming language"
msgstr "3.  **Реализуйте** задачу на языке программирования"

#: in/chapter4.md:48
msgid "4.  **Test** the program on representative examples"
msgstr "4.  **Проверьте** программу на репрезентативных примерах"

#: in/chapter4.md:50
msgid ""
"5.  **Debug** and **analyze** the resulting program, and repeat the process"
msgstr ""
"5.  **Отладьте** и **проанализируйте** полученную программу и повторите "
"процесс"

#: in/chapter4.md:53
msgid "## 4.1 Stage 1: Description"
msgstr "## 4.1 Этап 1: Описание"

#: in/chapter4.md:55
msgid ""
"As our problem description, we will start with a quote from Newell and "
"Simon's 1972 book, *Human Problem Solving:*"
msgstr ""
"В качестве описания нашей проблемы мы начнем с цитаты из книги Ньюэлла и "
"Саймона 1972 года: *Решение Человеческих Проблем*"

#: in/chapter4.md:58
msgid ""
"> *The main methods of GPS jointly embody the heuristic of means-ends "
"analysis.\n"
"Means-ends analysis is typified by the following kind of common-sense "
"argument:*"
msgstr ""
"> *Основные методы GPS совместно воплощают эвристику анализа конечных "
"целей.\n"
"Анализ конечных целей характеризуется следующим типом аргументов здравого "
"смысла:*"

#: in/chapter4.md:74
msgid ""
"*I want to take my son to nursery school.\n"
"What's the difference between what I have and what I want?\n"
"One of distance.\n"
"What changes distance?\n"
"My automobile.\n"
"My automobile won't work.\n"
"What is needed to make it work?\n"
"A new battery.\n"
"What has new batteries?\n"
"An auto repair shop.\n"
"I want the repair shop to put in a new battery; but the shop doesn't know I "
"need one.\n"
"What is the difficulty?\n"
"One of communication.\n"
"What allows communication?\n"
"A telephone... and so on.*"
msgstr ""
"*Я хочу отвести своего сына в детский сад.\n"
"Какая разница между тем, что у меня есть, и тем, что я хочу?\n"
"Одна из дистанций.\n"
"Что изменяет расстояние?\n"
"Мой автомобиль.\n"
"Мой автомобиль не работает.\n"
"Что нужно для того, чтобы он заработал?\n"
"Новая батарея.\n"
"У кого есть новые батареи?\n"
"В Мастерской по ремонту автомобилей.\n"
"Я хочу, чтобы ремонтная мастерская поставила новую батарею, но мастерская не "
"знает, что она мне нужна.\n"
"В чем же затруднение?\n"
"Один из способов общения.\n"
"Что позволяет общаться?\n"
"Телефон... и так далее.*"

#: in/chapter4.md:76
msgid ""
"> *The kind of analysis-classifying things in terms of the functions they "
"serve and oscillating among ends, functions required, and means that perform "
"them-forms the basic system of heuristic of GPS.*"
msgstr ""
"> *Тип анализа, классифицирующий вещи в терминах функций, которые они "
"выполняют и который колеблется(переключается) между целями, требуемыми "
"функциями и средствами, которые их выполняют, формирует базовую систему "
"эвристики GPS.*\n"

#: in/chapter4.md:80
msgid ""
"Of course, this kind of analysis is not exactly new.\n"
"The theory of means-ends analysis was laid down quite elegantly by Aristotle "
"2300 years earlier in the chapter entitled \"The nature of deliberation and "
"its objects\" of the *Nicomachean Ethics* (Book III.\n"
"3,1112b):"
msgstr ""
"Конечно, этот вид анализа не совсем новый.\n"
"Теория анализа конечных целей была довольно изящно изложена Аристотелем 2300 "
"годами ранее в главе под названием \"Природа размышлений и ее объекты\" "
"*Никомаховой этики* (Книга III. 3,1112b)"

#: in/chapter4.md:85
msgid ""
"> *We deliberate not about ends, but about means.\n"
"For a doctor does not deliberate whether he shall heal, nor an orator "
"whether he shall persuade, nor a statesman whether he shall produce law and "
"order, nor does anyone else deliberate about his end.\n"
"They assume the end and consider how and by what means it is attained; and "
"if it seems to be produced by several means they consider by which it is "
"most easily and best produced, while if it is achieved by one only they "
"consider how it will be achieved by this and by what means this will be "
"achieved, till they come to the first cause, which in the order of discovery "
"is last... and what is last in the order of analysis seems to be first in "
"the order of becoming.\n"
"And if we come on an impossibility, we give up the search, e.g., if we need "
"money and this cannot be got; but if a thing appears possible we try to do "
"it.*"
msgstr ""
"> *Мы размышляем не о целях, а о средствах.\n"
"Ибо врач не обдумывает, будет ли он исцелять, или оратор, будет ли он "
"убеждать, или государственный деятель, будет ли он создавать закон и "
"порядок, и никто другой не обдумывает об этом.\n"
"Они предполагают цель и рассматривают, как и какими средствами она "
"достигается; и если кажется, что она может быть достигнута несколькими "
"средствами, они рассматривают, с помощью которых она наиболее легко и "
"наилучшим образом достигается, в то время как если она достигается только "
"одним, они рассматривают, как она будет им достигнута и какими "
"дополнительными средствами это средство будет достигнуто, пока они не придут "
"к первой причине, которая в порядке открытия является последней... и то, что "
"является последним в порядке анализа, кажется первым в порядке "
"установления.\n"
"И если мы приходим к невозможности, мы отказываемся от поиска, например, "
"если нам нужны деньги, а их нельзя получить; но если что-то кажется "
"возможным, мы пытаемся это сделать.*"

#: in/chapter4.md:92
msgid ""
"Given this description of a theory of problem solving, how should we go "
"about writing a program?\n"
"First, we try to understand more fully the procedure outlined in the "
"quotes.\n"
"The main idea is to solve a problem using a process called means-ends "
"analysis, where the problem is stated in terms of what we want to happen.\n"
"In Newell and Simon's example, the problem is to get the kid to school, but "
"in general we would like the program to be able to solve a broad class of "
"problems.\n"
"We can solve a problem if we can find some way to eliminate \"the difference "
"between what I have and what I want.\" For example, if what I have is a "
"child at home, and what I want is a child at school, then driving may be a "
"solution, because we know that driving leads to a change in location.\n"
"We should be aware that using means-ends analysis is a choice: it is also "
"possible to start from the current situation and search forward to the goal, "
"or to employ a mixture of different search strategies."
msgstr ""
"Учитывая это описание теории решения проблем, как мы должны писать "
"программу?\n"
"Сначала мы пытаемся более полно понять процедуру, изложенную в кавычках.\n"
"Основная идея состоит в том, чтобы решить проблему, используя процесс, "
"называемый анализом конечных целей, где проблема формулируется в терминах "
"того, что нам надо чтобы это произошло.\n"
"В примере Ньюэлла и Саймона проблема состоит в том, чтобы доставить ребенка "
"в школу, но в целом мы хотели бы, чтобы программа могла решать широкий класс "
"проблем.\n"
"Мы можем решить проблему, если найдем способ устранить «разницу между тем, "
"что у меня есть, и тем, что я хочу». Например, если у меня есть ребенок "
"дома, а то, что я хочу, это ребенок в школе, то поездка может быть решением, "
"потому что мы знаем, что езда на машине ведет к изменению местоположения.\n"
"Нам следует помнить, что использование анализа конечных целей - это наш "
"выбор: также можно начать с текущей ситуации и идти к цели или использовать "
"смесь различных поисковых стратегий."

#: in/chapter4.md:101
msgid ""
"Some actions require the solving of *preconditions* as subproblems.\n"
"Before we can drive the car, we need to solve the subproblem of getting the "
"car in working condition.\n"
"It may be that the car is already working, in which case we need do nothing "
"to solve the subproblem.\n"
"So a problem is solved either by taking appropriate action directly, or by "
"first solving for the preconditions of an appropriate action and then taking "
"the action.\n"
"It is clear we will need some description of allowable actions, along with "
"their preconditions and effects.\n"
"We will also need to develop a definition of appropriateness.\n"
"However, if we can define these notions better, it seems we won't need any "
"new notions.\n"
"Thus, we will arbitrarily decide that the problem description is complete, "
"and move on to the problem specification."
msgstr ""
"Некоторые действия требуют решения *предварительных условий* как подзадач.\n"
"Прежде чем мы сможем управлять автомобилем, нам нужно решить подзадачу "
"приведения автомобиля в рабочее состояние.\n"
"Возможно, что машина уже работает, и в этом случае нам ничего не нужно "
"делать, чтобы решить эту подзадачу.\n"
"Таким образом, проблема решается либо путем принятия соответствующего "
"действия непосредственно, либо путем предварительного решения для "
"предварительных условий для выполнения этого действия, а затем уже и "
"выполнения самого действия.\n"
"Понятно, что нам потребуется некоторое описание допустимых действий, а также "
"их предпосылок и последствий(результатов/effects).\n"
"Нам также необходимо разработать определение уместности.\n"
"Однако если мы сможем лучше определить эти понятия, то, похоже, нам не "
"понадобятся никакие новые понятия.\n"
"Таким образом, мы произвольно решаем, что описание проблемы завершено и "
"перейдем к спецификации проблемы."

#: in/chapter4.md:103
msgid "## 4.2 Stage 2: Specification"
msgstr "## 4.2 Этап 2: Спецификация(Детализация)"

#: in/chapter4.md:105
msgid ""
"At this point we have an idea-admittedly vague-of what it means to solve a "
"problem in `GPS`. We can refine these notions into representations that are "
"closer to Lisp as follows:"
msgstr ""
"На данный момент у нас есть представление, правда смутное, о том, что значит "
"решать проблему в `GPS`. Мы можем уточнить эти понятия в представления, "
"которые ближе к Lisp следующим образом:"

#: in/chapter4.md:110
msgid ""
"*   We can represent the current state of the world-\"what I have\"-or the "
"goal state-\"what I want\"-as sets of conditions.\n"
"Common Lisp doesn't have a data type for sets, but it does have lists, which "
"can be used to implement sets.\n"
"Each condition can be represented by a symbol.\n"
"Thus, a typical goal might be the list of two conditions (`rich famous`), "
"and a typical current state might be (`unknown poor`)."
msgstr ""
"*   Мы можем представить текущее состояние мира как \"то, что у меня есть\" "
"и состояние цели, как \"то, что я хочу\", как набор условий.\n"
"Common Lisp не имеет типа данных для множеств, но у него есть списки, "
"которые можно использовать для реализации множеств.\n"
"Каждое условие может быть представлено символом.\n"
"Таким образом, типичной целью может быть список двух состояний (`rich "
"famous`)/(`богатый знаменитый`), а типичным текущим состоянием может быть "
"(`unknown poor`)/(`неизвестный бедный`)."

#: in/chapter4.md:113
msgid ""
"*   We need a list of allowable operators.\n"
"This list will be constant over the course of a problem, or even a series of "
"problems, but we want to be able to change it and tackle a new problem "
"domain."
msgstr ""
"*   Нам нужен список допустимых операторов.\n"
"Этот список будет постоянным  течение проблемы или даже серии проблем, но мы "
"хотим иметь возможность изменять его и искать решение в новой проблемной "
"области."

#: in/chapter4.md:119
msgid ""
"*   An operator can be represented as a structure composed of an action, a "
"list of preconditions, and a list of effects.\n"
"We can place limits on the kinds of possible effects by saying that an "
"effect either adds or deletes a condition from the current state.\n"
"Thus, the list of effects can be split into an add-list and a delete-list.\n"
"This was the approach taken by the Strips [1](#fn0010) implementation of "
"GPS, which we will be in effect reconstructing in this chapter.\n"
"The original GPS allowed more flexibility in the specification of effects, "
"but flexibility leads to inefficiency."
msgstr ""
"*  Оператор может быть представлен в виде структуры, состоящей из "
"действия(action), списка предварительных условий(preconditions) и списка "
"эффектов(effects).\n"
"Мы можем установить ограничения на виды возможных эффектов, сказав, что "
"эффект либо добавляет, либо удаляет условие из текущего состояния.\n"
"Таким образом, список эффектов можно разделить на список добавления(add-"
"list) и список удаления(delete-list).\n"
"Это был подход, принятый в Stripes [1](#fn0010) реализации GPS, который мы "
"фактически реконструируем в этой главе.\n"
"Оригинальный GPS позволял большую гибкость в спецификации/определении "
"эффектов, но гибкость приводит к неэффективности."

#: in/chapter4.md:126
msgid ""
"*   A complete problem is described to GPS in terms of a starting state, a "
"goal state, and a set of known operators.\n"
"Thus, GPS will be a function of three arguments.\n"
"For example, a sample call might be: `(GPS '(unknown poor)'(rich famous) "
"list-of-ops)` In other words, starting from the state of being poor and "
"unknown, achieve the state of being rich and famous, using any combination "
"of the known operators.\n"
"GPS should return a true value only if it solves the problem, and it should "
"print a record of the actions taken.\n"
"The simplest approach is to go through the conditions in the goal state one "
"at a time and try to achieve each one.\n"
"If they can all be achieved, then the problem is solved."
msgstr ""
"*   Полная задача описывается для GPS в терминах начального "
"состояния(starting state), целевого состояния(goal state) и набора/множества "
"известных операторов(known operators).\n"
"Таким образом, GPS будет функцией трех аргументов.\n"
"Например, пример вызова может быть:  `(GPS  '(unknown poor)  '(rich famous) "
"list-of-ops)`,  другими словами, начиная с состояния быть бедным(poor) и "
"неизвестным(unknown), надо достичь состояния быть богатым(rich) и "
"знаменитым(famous), используя любую комбинацию известных операторов(list-of-"
"ops).\n"
"GPS должен возвращать истинное значение только в том случае, если он решает "
"проблему, и он должен напечатать запись о предпринятых действиях.\n"
"Самый простой подход состоит в том, чтобы пройти через условия к состоянию "
"цели по одному(условию цели) за раз и попытаться достичь каждого из них.\n"
"Если все они могут быть достигнуты, то проблема решена."

#: in/chapter4.md:130
msgid ""
"*   A single goal condition can be achieved in two ways.\n"
"If it is already in the current state, the goal is trivially achieved with "
"no effort.\n"
"Otherwise, we have to find some appropriate operator and try to apply it."
msgstr ""
"*   Одно условие цели может быть достигнуто двумя способами.\n"
"Если оно(целевое условие) уже находится в текущем состоянии, то цель "
"тривиально достигается без каких-либо усилий.\n"
"В противном случае мы должны найти какой-то подходящий оператор(добавляющий "
"это условие) и попытаться применить его."

#: in/chapter4.md:132
msgid ""
"*   An operator is appropriate if one of the effects of the operator is to "
"add the goal in question to the current state; in other words, if the goal "
"is in the operator's add-list."
msgstr ""
"*   Оператор уместен/применим, если одним из эффектов оператора является "
"добавление рассматриваемой цели в текущее состояние; другими словами, если "
"цель находится в списке добавлений(add-list) оператора."

#: in/chapter4.md:137
msgid ""
"*   We can apply an operator if we can achieve all the preconditions.\n"
"But this is easy, because we just defined the notion of achieving a goal in "
"the previous paragraph.\n"
"Once the preconditions have been achieved, applying an operator means "
"executing the action and updating the current state in term of the "
"operator's add-list and delete-list.\n"
"Since our program is just a simulation-it won't be actually driving a car or "
"dialling a telephone-we must be content simply to print out the action, "
"rather than taking any real action."
msgstr ""
"*  Мы можем применить оператор, если мы можем достичь всех предварительных "
"условий.\n"
"Но это легко, потому что мы только что определили понятие достижения цели в "
"предыдущем абзаце.\n"
"После выполнения предварительных условий применение оператора означает "
"выполнение действия и обновление текущего состояния в терминах  операторов "
"списка добавлений(add-list) и списка удалений(delete-list).\n"
"Поскольку наша программа-это всего лишь симуляция, а не фактическое вождение "
"автомобиля или набора номера телефона, мы должны довольствоваться просто "
"распечаткой действия, а не выполнением каких-либо реальных действий."

#: in/chapter4.md:139
msgid "## 4.3 Stage 3: Implementation"
msgstr "## 4.3 Этап 3: Реализация"

#: in/chapter4.md:142
msgid ""
"The specification is complete enough to lead directly to a complete Common "
"Lisp program.\n"
"[Figure 4.1](#f0010) summarizes the variables, data types, and functions "
"that make up the GPS program, along with some of the Common Lisp functions "
"used to implement it."
msgstr ""
"Спецификация достаточно полна, чтобы привести непосредственно к полной "
"программе Common Lisp.\n"
"[Рисунок 4.1](#f0010) суммирует переменные, типы данных и функции, "
"составляющие программу GPS, а также некоторые из функций Common Lisp, "
"используемых для ее реализации."

#: in/chapter4.md:164
msgid ""
"| Symbol             | Use                                                   "
"|\n"
"| ------             | ---                                                   "
"|\n"
"|                    | **Top-Level Function**                                "
"|\n"
"| `GPS`              | Solve a goal from a state using a list of operators.  "
"|\n"
"|                    | **Special Variables**                                 "
"|\n"
"| `*state*`          | The current state, a list of conditions.              "
"|\n"
"| `*ops*`            | A list of available operators.                        "
"|\n"
"|                    | **Data Types**                                        "
"|\n"
"| `op`               | An operation with preconds, add-list and del-list.    "
"|\n"
"|                    | **Functions**                                         "
"|\n"
"| `achieve`          | Achieve an individual goal.                           "
"|\n"
"| `appropriate-p`    | Decide if an operator is appropriate for a goal.      "
"|\n"
"| `apply-op`         | Apply operator to current state.                      "
"|\n"
"|                    | **Selected Common Lisp Functions**                    "
"|\n"
"| `member`           | Test if an elementis a member of a list. (p.78)       "
"|\n"
"| `set-difference`   | All elements in one set but not the other.            "
"|\n"
"| `union`            | All elements in either of the two sets.               "
"|\n"
"| `every`            | Test if every element of a list passes a test. (p. "
"62)|\n"
"| `some`             | Test if any element of a list passes a test.          "
"|\n"
"|                    | **Previously Defined Functions**                      "
"|\n"
"| `find-all`         | A list of all matching elements. (p. 101)             "
"|"
msgstr ""
"| Символ             | "
"Использование                                                |\n"
"| ------             | "
"---                                                          |\n"
"|                    | **Функция верхнего "
"уровня**                                  |\n"
"| `GPS`              | Решает задачу из сост., используя список "
"операторов.         |\n"
"|                    | **Специальные "
"переменные**                                   |\n"
"| `*state*`          | Текущее состояние, это список "
"условий.                       |\n"
"| `*ops*`            | Список доступных "
"операций.                                   |\n"
"|                    | **Типы "
"Данных**                                              |\n"
"| `op`               | Операции с preconds, add-list и del-"
"list.                    |\n"
"|                    | "
"**Функции**                                                  |\n"
"| `achieve`          | Достижение индивидуальной "
"цели.                              |\n"
"| `appropriate-p`    | Решает, подходит ли оператор для достижения "
"цели.            |\n"
"| `apply-op`         | Применяет оператор к текущему "
"состоянию.                     |\n"
"|                    | **Выбранные Функции Common "
"Lisp**                            |\n"
"| `member`           | Проверяет содержиться ли элемент в списке. "
"(p.78)            |\n"
"| `set-difference`   | Все элементы из одного можества, которых нет в "
"другом.       |\n"
"| `union`            | Все элементы из обоих "
"мноожеств                              |\n"
"| `every`            | Проверяет, проходит ли тест каждый элемент списка. "
"(p. 62)   |\n"
"| `some`             | Проверяет, проходит ли тест какой-либо элемент "
"списка.       |\n"
"|                    | **Ранее Определенные "
"Функции**                             |\n"
"| `find-all`         | Список всех совпадающих элементов. (p. "
"101)                    |"

#: in/chapter4.md:166
msgid "Here is the complete GPS program itself:"
msgstr "Вот полная программа GPS сама по себе:"

#: in/chapter4.md:169
msgid ""
"```lisp\n"
"(defvar *state* nil \"The current state: a list of conditions.\")"
msgstr ""

#: in/chapter4.md:171
msgid "(defvar *ops* nil \"A list of available operators.\")"
msgstr ""

#: in/chapter4.md:174
msgctxt "in/chapter4.md:174"
msgid ""
"(defstruct op \"An operation\"\n"
"  (action nil) (preconds nil) (add-list nil) (del-list nil))"
msgstr ""

#: in/chapter4.md:178
msgid ""
"(defun GPS (*state* goals *ops*)\n"
"  \"General Problem Solver: achieve all goals using *ops*.\"\n"
"  (if (every #'achieve goals) 'solved))"
msgstr ""

#: in/chapter4.md:185
msgid ""
"(defun achieve (goal)\n"
"  \"A goal is achieved if it already holds,\n"
"  or if there is an appropriate op for it that is applicable.\"\n"
"  (or (member goal *state*)\n"
"    (some #'apply-op\n"
"      (find-all goal *ops* :test #'appropriate-p))))"
msgstr ""

#: in/chapter4.md:189
msgid ""
"(defun appropriate-p (goal op)\n"
"  \"An op is appropriate to a goal if it is in its add list.\"\n"
"  (member goal (op-add-list op)))"
msgstr ""

#: in/chapter4.md:204
msgid ""
"(defun apply-op (op)\n"
"  \"Print a message and update *state* if op is applicable.\"\n"
"  (when (every #'achieve (op-preconds op))\n"
"    (print (list 'executing (op-action op)))\n"
"    (setf *state* (set-difference *state* (op-del-list op)))\n"
"    (setf *state* (union *state* (op-add-list op)))\n"
"  t))\n"
"```\n"
"We can see the program is made up of seven definitions.\n"
"These correspond to the seven items in the specification above.\n"
"In general, you shouldn't expect such a perfect fit between specification "
"and implementation.\n"
"There are two `defvar` forms, one `defstruct`, and four `defun` forms.\n"
"These are the Common Lisp forms for defining variables, structures, and "
"functions, respectively.\n"
"They are the most common toplevel forms in Lisp, but there is nothing magic "
"about them; they are just special forms that have the side effect of adding "
"new definitions to the Lisp environment."
msgstr ""
"(defun apply-op (op)\n"
"  \"Print a message and update *state* if op is applicable.\"\n"
"  (when (every #'achieve (op-preconds op))\n"
"    (print (list 'executing (op-action op)))\n"
"    (setf *state* (set-difference *state* (op-del-list op)))\n"
"    (setf *state* (union *state* (op-add-list op)))\n"
"  t))\n"
"```\n"
"Мы видим, что программа состоит из семи определений.\n"
"Они соответствуют семи пунктам приведенной выше спецификации.\n"
"В общем, вы не должны ожидать такого идеального соответствия между "
"спецификацией и реализацией.\n"
"Существует две формы `defvar`, одна `defstruct` и четыре формы `defun`.\n"
"Это формы Lisp для определения переменных, структур и функций "
"соответственно.\n"
"Они являются наиболее распространенными формами верхнего уровня в Lisp, но в "
"них нет ничего волшебного; это просто специальные формы, которые имеют "
"побочный эффект добавления новых определений в среду Lisp."

#: in/chapter4.md:206
msgid ""
"The two `defvar` forms, repeated below, declare special variables named "
"`*state*` and `*ops*,` which can then be accessed from anywhere in the "
"program."
msgstr ""
"Две формы `defvar`, повторенные ниже, объявляют специальные переменные с "
"именами  `*state*` и `*ops*,` к которым затем можно получить доступ из любой "
"точки программы."

#: in/chapter4.md:218
msgid ""
"```lisp\n"
"(defvar *state* nil \"The current state: a list of conditions.\")\n"
"(defvar *ops* nil \"A list of available operators.\")\n"
"```\n"
"The `defstruct` form defines a structure called an `op`, which has slots "
"called `action`, `preconds`, `add-list`, and `del-list`.\n"
"Structures in Common Lisp are similar to structures in C, or records in "
"Pascal.\n"
"The `defstruct` automatically defines a constructor function, which is "
"called `make-op`, and an access function for each slot of the structure.\n"
"The access functions are called `op-action`, `op-preconds`, `op-add-list`, "
"and `op-del-list`.\n"
"The `defstruct` also defines a copier function, `copy-op`, a predicate, `op-"
"p`, and `setf` definitions for changing each slot.\n"
"None of those are used in the GPS program.\n"
"Roughly speaking, it is as if the `defstruct` form"
msgstr ""
"```lisp\n"
"(defvar *state* nil \"The current state: a list of conditions.\")\n"
"(defvar *ops* nil \"A list of available operators.\")\n"
"```\n"
"Форма `defstruct` определяет структуру называемую `op`, которая имеет слоты "
"под названием `action`, `preconds`, `add-list` и `del-list`(действие, "
"предварительные условия, списко добавления и список удаления).\n"
"Структуры в Common Lisp подобны структурам в Си или записям в Pascal.\n"
"`defstruct` автоматически определяет функцию конструктора, которая "
"называется `make-op` и функцию доступа для каждого слота структуры.\n"
"Функции доступа называются `op-action`, `op-preconds`, `op-add-list` и `op-"
"del-list`.\n"
"В `defstruct` также определяется функция копирования `copy-op`, предикат `op-"
"p` и определения `setf` для изменения каждого слота.\n"
"Ни одина из них не используется в программе GPS.\n"
"Грубо говоря, это как если бы форма `defstruct`"

#: in/chapter4.md:224
msgid ""
"```lisp\n"
"(defstruct op \"An operation\"\n"
"  (action nil) (preconds nil) (add-list nil) (del-list nil))\n"
"```\n"
"expanded into the following definitions:"
msgstr ""
"```lisp\n"
"(defstruct op \"An operation\"\n"
"  (action nil) (preconds nil) (add-list nil) (del-list nil))\n"
"```\n"
"расширялась бы в следующие определения:"

#: in/chapter4.md:228
msgid ""
"```lisp\n"
"(defun make-op (&key action preconds add-list del-list)\n"
"  (vector 'op action preconds add-list del-list))"
msgstr ""

#: in/chapter4.md:230
msgid "(defun op-action (op) (elt op 1))"
msgstr ""

#: in/chapter4.md:232
msgid "(defun op-preconds (op) (elt op 2))"
msgstr ""

#: in/chapter4.md:234
msgid "(defun op-add-list (op) (elt op 3))"
msgstr ""

#: in/chapter4.md:236
msgid "(defun op-del-list (op) (elt op 4))"
msgstr ""

#: in/chapter4.md:238
msgid "(defun copy-op (op) (copy-seq op))"
msgstr ""

#: in/chapter4.md:241
msgid ""
"(defun op-p (op)\n"
"  (and (vectorp op) (eq (elt op 0) 'op)))"
msgstr ""

#: in/chapter4.md:249
msgid ""
"(setf (documentation 'op 'structure) \"An operation\")\n"
"```\n"
"Next in the GPS program are four function definitions.\n"
"The main function `GPS`, is passed three arguments.\n"
"The first is the current state of the world, the second the goal state, and "
"the third a list of allowable operators.\n"
"The body of the function says simply that if we can achieve every one of the "
"goals we have been given, then the problem is solved.\n"
"The unstated alternative is that otherwise, the problem is not solved."
msgstr ""
"(setf (documentation 'op 'structure) \"An operation\")\n"
"```\n"
"Далее в программе GPS идут четыре определения функций.\n"
"Основная функция `GPS`, принимает три аргумента.\n"
"Первый - это текущее состояние мира, второй - целевое состояние, а третий - "
"список допустимых операций(операторов).\n"
"Тело функции просто говорит, что если мы сможем достичь каждой из "
"поставленных целей, то проблема будет решена.\n"
"Неназванная альтернатива заключается в том, что в противном случае проблема "
"не будет решена."

#: in/chapter4.md:255
msgid ""
"The function achieve is given as an argument a single goal.\n"
"The function succeeds if that goal is already true in the current state (in "
"which case we don't have to do anything) or if we can apply an appropriate "
"operator.\n"
"This is accomplished by first building the list of appropriate operators and "
"then testing each in turn until one can be applied.\n"
"`achieve` calls `find-all`, which we defined on [page 101]"
"(B9780080571157500030.xhtml#p101).\n"
"In this use, `find-all` returns a list of operators that match the current "
"goal, according to the predicate `appropriate-p`."
msgstr ""
"Функция achieve принимает в качестве аргумента единственную цель(goal).\n"
"Функция работает успешно, если эта цель уже верна(достигнута) в текущем "
"состоянии (в этом случае нам ничего не нужно делать) или если мы можем "
"применить соответствующий оператор.\n"
"Это достигается путем предварительного построения списка подходящих "
"операторов, а затем тестирования каждого по очереди, пока один из них не "
"сможет быть применен.\n"
"`achieve` вызывает `find-all`, который мы определили на [page 101]"
"(B9780080571157500030.xhtml#p101).\n"
"При таком использовании `find-all` возвращает список операторов, "
"соответствующих текущей цели, в соответствии с предикатом `appropriate-p`."

#: in/chapter4.md:258
msgid ""
"The function `appropriate-p` tests if an operator is appropriate for "
"achieving a goal.\n"
"(It follows the Lisp naming convention that predicates end in `-p`.)"
msgstr ""
"Функция `appropriate-p` проверяет, подходит ли оператор для достижения "
"цели.\n"
"(Это следует из соглашения об именовании Lisp, что предикаты заканчиваются "
"на `-p`.)"

#: in/chapter4.md:262
msgid ""
"Finally, the function `apply-op` says that if we can achieve all the "
"preconditions for an appropriate operator, then we can apply the operator.\n"
"This involves printing a message to that effect and changing the state of "
"the world by deleting what was in the delete-list and adding what was in the "
"add-list.\n"
"`apply-op` is also a predicate; it returns `t` only when the operator can be "
"applied."
msgstr ""
"Наконец, функция `apply-op` говорит, что если мы можем достичь всех "
"предварительных условий для соответствующего оператора, то мы можем "
"применить оператор.\n"
"Это включает в себя печать сообщения об этом эффекте и изменение состояния "
"мира путем удаления того, что было в списке удаления(delete-list), и "
"добавления того, что было в списке добавления(add-list).\n"
"`apply-op` также является предикатом; он возвращает `t` только тогда, когда "
"оператор может быть применен."

#: in/chapter4.md:264
msgid "## 4.4 Stage 4: Test"
msgstr "## 4.4 Этап 4: Тестирование"

#: in/chapter4.md:268
msgid ""
"This section will define a list of operators applicable to the \"driving to "
"nursery school\" domain and will show how to pose and solve some problems in "
"that domain.\n"
"First, we need to construct the list of operators for the domain.\n"
"The `defstruct` form for the type `op` automatically defines the function "
"`make-op`, which can be used as follows:"
msgstr ""
"В этом разделе будет определен список операторов, применимых к домену "
"\"вождение в детский сад\", и показано, как ставить и решать некоторые "
"проблемы в этом домене.\n"
"Во-первых, нам нужно построить список операторов для домена.\n"
"Форма `defstruct` для типа `op` автоматически определяет функцию `make-op`, "
"которую можно использовать следующим образом:"

#: in/chapter4.md:277
msgid ""
"```lisp\n"
"(make-op :action 'drive-son-to-school\n"
"    :preconds '(son-at-home car-works)\n"
"    :add-list '(son-at-school)\n"
"    :del-list '(son-at-home))\n"
"```\n"
"This expression returns an operator whose action is the symbol `drive-son-to-"
"school` and whose preconditions, add-list and delete-list are the specified "
"lists.\n"
"The intent of this operator is that whenever the son is at home and the car "
"works, `drive-son-to-school` can be applied, changing the state by deleting "
"the fact that the son is at home, and adding the fact that he is at school."
msgstr ""
"```lisp\n"
"(make-op :action 'drive-son-to-school\n"
"    :preconds '(son-at-home car-works)\n"
"    :add-list '(son-at-school)\n"
"    :del-list '(son-at-home))\n"
"```\n"
"Это выражение возвращает оператор, чьим действием является символ `drive-son-"
"to-school` и чьи предварительные условия, список добавления(add-list) и "
"список удаления(delete-list) являются указанными списками.\n"
"Цель этого оператора заключается в том, что всякий раз, когда сын находится "
"дома(son-at-home) и машина работает(car-works), можно применить `drive-son-"
"to-school`(\"отвезти сына в школу\"), изменяя состояние, удалив тот факт, "
"что сын находится дома(son-at-home), и добавив тот факт, что он находится в "
"школе(son-at-school)."

#: in/chapter4.md:285
msgid ""
"It should be noted that using long hyphenated atoms like `son-at-home` is a "
"useful approach only for very simple examples like this one.\n"
"A better representation would break the atom into its components: perhaps "
"(`at son home`).\n"
"The problem with the atom-based approach is one of combinatorics.\n"
"If there are 10 predicates (such as `at`) and 10 people or objects, then "
"there will be 10 x 10 x 10 = 1000 possible hyphenated atoms, but only 20 "
"components.\n"
"Clearly, it would be easier to describe the components.\n"
"In this chapter we stick with the hyphenated atoms because it is simpler, "
"and we do not need to describe the whole world.\n"
"Subsequent chapters take knowledge representation more seriously."
msgstr ""
"Следует отметить, что использование длинных атомов с разделлительными "
"дефисами, таких как `son-at-home`, является полезным подходом только для "
"очень простых примеров, подобных этому.\n"
"Более точное представление разбило бы атом на его компоненты: возможно (`at "
"son home`)..\n"
"Проблема атомного подхода - это комбинаторная проблема.\n"
"Если есть 10 предикатов (таких как, `at`) и 10 людей или объектов, то будет "
"10 x 10 x 10 = 1000 возможных атомов разделенных дефисом, но только 20 "
"компонентов.\n"
"Очевидно, что было бы проще описать компоненты.\n"
"В этой главе мы придерживаемся разделенных дефисами атомов, потому что это "
"проще, и нам не нужно описывать весь мир.\n"
"В последующих главах представление знаний рассматривается более серьезно."

#: in/chapter4.md:289
msgid ""
"With this operator as a model, we can define other operators corresponding "
"to Newell and Simon's quote on [page 109](B9780080571157500042.xhtml#p109).\n"
"There will be an operator for installing a battery, telling the repair shop "
"the problem, and telephoning the shop.\n"
"We can fill in the \"and so on\" by adding operators for looking up the "
"shop's phone number and for giving the shop money:"
msgstr ""
"Используя этот оператор в качестве модели, мы можем определить другие "
"операторы, соответствующие цитате Ньюэлла и Саймона на [page 109]"
"(B9780080571157500042.в XHTML#р109).\n"
"Там будет оператор для установки батареи, сообщающий в ремонтную мастерскую "
"о проблеме и звонящий в мастерскую.\n"
"Мы можем заполнить \"и так далее\", добавив операторы для поиска номера "
"телефона магазина и для передаче магазину денег:"

#: in/chapter4.md:319
msgid ""
"```lisp\n"
"(defparameter *school-ops*\n"
"  (list\n"
"    (make-op :action 'drive-son-to-school\n"
"      :preconds '(son-at-home car-works)\n"
"      :add-list '(son-at-school)\n"
"      :del-list '(son-at-home))\n"
"    (make-op :action 'shop-installs-battery\n"
"      :preconds '(car-needs-battery shop-knows-problem shop-has-money)\n"
"      :add-list '(car-works))\n"
"    (make-op :action 'tell-shop-problem\n"
"      :preconds '(in-communication-with-shop)\n"
"      :add-list '(shop-knows-problem))\n"
"    (make-op :action 'telephone-shop\n"
"      :preconds '(know-phone-number)\n"
"      :add-list '(in-communication-with-shop))\n"
"    (make-op :action 'look-up-number\n"
"      :preconds '(have-phone-book)\n"
"      :add-list '(know-phone-number))\n"
"    (make-op :action 'give-shop-money\n"
"      :preconds '(have-money)\n"
"      :add-list '(shop-has-money)\n"
"      :del-list '(have-money))))\n"
"```\n"
"The next step is to pose some problems to GPS and examine the solutions.\n"
"Following are three sample problems.\n"
"In each case, the goal is the same: to achieve the single condition `son-at-"
"school`.\n"
"The list of available operators is also the same in each problem; the "
"difference is in the initial state.\n"
"Each of the three examples consists of the prompt, \">\", which is printed "
"by the Lisp system, followed by a call to GPS, \" ( `gps`... )\", which is "
"typed by the user, then the output from the program, \"(`EXECUTING`...)\", "
"and finally the result of the function call, which can be either `SOLVED` or "
"`NIL`."
msgstr ""
"```lisp\n"
"(defparameter *school-ops*\n"
"  (list\n"
"    (make-op :action 'drive-son-to-school\n"
"      :preconds '(son-at-home car-works)\n"
"      :add-list '(son-at-school)\n"
"      :del-list '(son-at-home))\n"
"    (make-op :action 'shop-installs-battery\n"
"      :preconds '(car-needs-battery shop-knows-problem shop-has-money)\n"
"      :add-list '(car-works))\n"
"    (make-op :action 'tell-shop-problem\n"
"      :preconds '(in-communication-with-shop)\n"
"      :add-list '(shop-knows-problem))\n"
"    (make-op :action 'telephone-shop\n"
"      :preconds '(know-phone-number)\n"
"      :add-list '(in-communication-with-shop))\n"
"    (make-op :action 'look-up-number\n"
"      :preconds '(have-phone-book)\n"
"      :add-list '(know-phone-number))\n"
"    (make-op :action 'give-shop-money\n"
"      :preconds '(have-money)\n"
"      :add-list '(shop-has-money)\n"
"      :del-list '(have-money))))\n"
"```\n"
"Следующий шаг-поставить некоторые проблемы перед GPS и изучить их решения.\n"
"Ниже приведены три примера проблем.\n"
"В каждом случае цель одна и та же: достичь единственного условия `son-at-"
"school`(сын-в-школе).\n"
"Список доступных операторов также одинаков в каждой задаче; разница "
"заключается в исходном состоянии.\n"
"Каждый из трех примеров состоит из подсказки \">\", которая печатается "
"системой Lisp, а затем следует вызов GPS  \" ( `gps`... )\", который "
"набирается пользователем, а затем выводится  программой \"(`EXECUTING`...)\" "
"и, наконец, результат вызова функции, который может быть либо "
"`SOLVED`(решен), либо `NIL`(не решен)."

#: in/chapter4.md:347
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"NIL\n"
"> (gps '(son-at-home car-works)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"In all three examples the goal is to have the son at school.\n"
"The only operator that has `son-at-school` in its add-list is `drive-son-to-"
"school`, so GPS selects that operator initially.\n"
"Before it can execute the operator, GPS has to solve for the preconditions.\n"
"In the first example, the program ends up working backward through the "
"operators `shop-installs-battery`, `give-shop-money`, `tell-shop-problem`, "
"and `telephone-shop` to `look-up-number`, which has no outstanding "
"preconditions.\n"
"Thus, the `look-up-number` action can be executed, and the program moves on "
"to the other actions.\n"
"As Aristotle said, \"What is the last in the order of analysis seems to be "
"first in the order of becoming.\""
msgstr ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"NIL\n"
"> (gps '(son-at-home car-works)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"Во всех трех примерах цель состоит в том, чтобы  `son-at-school`(сын был в "
"школе).\n"
"Единственный оператор, у которого есть `son-at-school` в своем списке "
"добавлениядополнений(add-list) -это `drive-son-to-school`(отвезти/"
"переместить сына в школу), поэтому GPS изначально выбирает этот оператор.\n"
"Прежде чем он сможет выполнить этот оператор, GPS должен решить для себя "
"предварительные условия этого оператора.\n"
"В первом примере программа работает в обратном направлении через операторы "
"`shop-installs-battery`, `give-shop-money`, `tell-shop-problem` и `telephone-"
"shop` к `look-up-number`, который не имеет никаких значимых предварительных "
"условий.\n"
"Таким образом, действие `look-up-number`(поиск номера) может быть выполнено, "
"и программа переходит к другим действиям.\n"
"Как сказал Аристотель: \"то, что появляется последним в порядке анализа, "
"будет первым в порядке становления(выполнения).\""

#: in/chapter4.md:350
msgid ""
"The second example starts out exactly the same, but the `look-up-number` "
"operator fails because its precondition, `have-phone-book`, cannot be "
"achieved.\n"
"Knowing the phone number is a precondition, directly or indirectly, of all "
"the operators, so no action is taken and GPS returns `NIL`."
msgstr ""
"Второй пример начинается точно так же, но оператор  `look-up-number` терпит "
"неудачу, потому что его предварительное условие `have-phone-book`, не может "
"быть достигнуто.\n"
"Знание номера телефона является обязательным условием, прямо или косвенно, "
"для всех операторов, поэтому никаких действий не предпринимается и GPS "
"возвращает `NIL`."

#: in/chapter4.md:352
msgid ""
"Finally, the third example is much more direct; the initial state specifies "
"that the car works, so the driving operator can be applied immediately."
msgstr ""
"Наконец, третий пример является гораздо более прямым; начальное состояние "
"указывает, что автомобиль работает, поэтому оператор вождения может быть "
"применен немедленно."

#: in/chapter4.md:354
msgid "## 4.5 Stage 5: Analysis, or \"We Lied about the G\""
msgstr ""
"## 4.5 Стадия 5: анализ, или \"мы солгали о G(Общности решателя проблем)\""

#: in/chapter4.md:357
msgid ""
"In the sections that follow, we examine the question of just how general "
"this General Problem Solver is.\n"
"The next four sections point out limitations of our version of GPS, and we "
"will show how to correct these limitations in a second version of the "
"program."
msgstr ""
"В следующих разделах мы рассмотрим вопрос о том, насколько общим является "
"этот общий решатель проблем.\n"
"Следующие четыре раздела указывают на ограничения нашей версии GPS, и мы "
"покажем, как исправить эти ограничения во второй версии программы."

#: in/chapter4.md:362
msgid ""
"One might ask if \"limitations\" is just a euphemism for \"bugs.\" Are we "
"\"enhancing\" the program, or are we \"correcting\" it?\n"
"There are no clear answers on this point, because we never insisted on an "
"unambiguous problem description or specification.\n"
"AI programming is largely exploratory programming; the aim is often to "
"discover more about the problem area rather than to meet a clearly defined "
"specification.\n"
"This is in contrast to a more traditional notion of programming, where the "
"problem is completely specified before the first line of code is written."
msgstr ""
"Можно было бы спросить, не является ли \"ограничения\" просто "
"эвфемизмом(хорошим термином) для \"ошибок\".- Мы \"расширяем\" программу или "
"\"корректируем\" ее?\n"
"На этот вопрос нет четких ответов, потому что мы никогда не настаивали на "
"однозначном описании или спецификации проблемы.\n"
"Программирование ИИ в значительной степени является исследовательским "
"программированием; цель часто состоит в том, чтобы узнать больше о "
"проблемной области, а не соответствовать четко определенной спецификации.\n"
"Это противоречит более традиционному представлению о программировании, где "
"задача полностью определяется до того, как будет написана первая строка кода."

#: in/chapter4.md:364
msgid "## 4.6 The Running Around the Block Problem"
msgstr "## 4.6 Проблема бега вокруг блока."

#: in/chapter4.md:369
msgid ""
"Representing the operator \"driving from home to school\" is easy: the "
"precondition and delete-list includes being at home, and the add-list "
"includes being at school.\n"
"But suppose we wanted to represent \"running around the block.\" There would "
"be no net change of location, so does that mean there would be no add or "
"delete-list?\n"
"If so, there would be no reason ever to apply the operator.\n"
"Perhaps the add-list should contain something like \"got some exercise\" or "
"\"feel tired,\" or something more general like \"experience running around "
"the block.\" We will return to this question later."
msgstr ""
"Представление оператора \"вождение из дома в школу\" простое: "
"предварительное условие и список удалений включают в себя пребывание дома, а "
"список добавлений включает в себя пребывание в школе.\n"
"Но предположим, что мы хотим изобразить \"бег вокруг блока\".\"Не будет "
"никакого чистого изменения местоположения, так означает ли это, что не будет "
"никакого списка добавления или удаления?\n"
"Если бы это было так, то не было бы никакой причины когда-либо применять "
"какой-либо оператор.\n"
"Возможно, список дополнений должен содержать что-то вроде \"немного "
"потренировался\" или \"чувствую усталость\", или что-то более общее, "
"например \"опыт бега вокруг блока\".- Мы вернемся к этому вопросу позже."

#: in/chapter4.md:371
msgid "## 4.7 The Clobbered Sibling Goal Problem"
msgstr "## 4.7 Проблема цели - сломаный брат"

#: in/chapter4.md:374
msgid ""
"Consider the problem of not only getting the child to school but also having "
"some money left over to use for the rest of the day.\n"
"GPS can easily solve this problem from the following initial condition:"
msgstr ""
"Подумайте о том, чтобы не только доставить ребенка в школу, но и иметь "
"немного денег, чтобы использовать их до конца дня.\n"
"GPS может легко решить эту проблему из следующего начального условия:"

#: in/chapter4.md:383
msgid ""
"```lisp\n"
"(gps '(son-at-home have-money car-works)\n"
"    '(have-money son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"However, in the next example GPS incorrectly reports success, when in fact "
"it has spent the money on the battery."
msgstr ""
"```lisp\n"
"(gps '(son-at-home have-money car-works)\n"
"    '(have-money son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"Однако в следующем примере GPS неверно сообщает об успехе, когда на самом "
"деле он потратил деньги на батарею."

#: in/chapter4.md:400
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(have-money son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"The \"bug\" is that GPS uses the expression (`every #'achieve goals`) to "
"achieve a set of goals.\n"
"If this expression returns true, it means that every one of the goals has "
"been achieved in sequence, but it doesn't mean they are all still true at "
"the end.\n"
"In other words, the goal (`have-money son-at-school`), which we intended to "
"mean \"end up in a state where both have-money and son-at-school are true,\" "
"was interpreted by GPS to mean \"first achieve `have-money`, and then "
"achieve `son-at-school`.\" Sometimes achieving one goal can undo another, "
"previously achieved goal.\n"
"We will call this the \"prerequisite clobbers sibling goal\" problem.[2]"
"(#fn0015) That is, `have-money` and `son-at-school` are sibling goals, one "
"of the prerequisites for the plan for `son-at-school` is `car-works`, and "
"achieving that goal clobbers the `have-money goal`."
msgstr ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(have-money son-at-school)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"SOLVED\n"
"```\n"
"\"Ошибка\" заключается в том, что GPS использует выражение (`every #'achieve "
"goals`) для достижения набора целей.\n"
"Если это выражение возвращает true, это означает, что каждая из целей была "
"достигнута последовательно, но это не значит, что все они по-прежнему верны "
"в конце.\n"
"Иными словами, цель (`have-money son-at-school`), который у нас означает "
"\"оказаться в состоянии, когда есть деньги и сын в школе - истина\" было "
"истолковано GPS так: \"вначале достичь\"   `have-money`, а затем достичь   "
"`son-at-school`. Иногда достижение одной цели может отменить другую, ранее "
"достигнутую цель.\n"
"Мы назовем это проблемой \"предпосылок для достижения братской цели\".[2]"
"(#fn0015) то есть `have-money` и `son-at-school` -это родственные цели, одна "
"из предпосылок для плана `son-at-school` - это работающая машина(`car-"
"works`), и достижение этой цели разрушает цель `have-money`."

#: in/chapter4.md:404
msgid ""
"Modifying the program to recognize the \"prerequisite clobbers sibling goal"
"\" problem is straightforward.\n"
"First note that we call (`every #`'`achieve`*something*) twice within the "
"program, so let's replace those two forms with ( `achieve-all`*something*).\n"
"We can then define `achieve-all` as follows:"
msgstr ""
"Изменение программы для распознавания проблемы \"предпосылки повреждение "
"брата цели\" является простым.\n"
"Во-первых, обратите внимание, что мы вызываем (`every #``achieve` "
"*something*) дважды в рамках программы, поэтому давайте заменим эти две "
"формы на ( `achieve-all` *something*).\n"
"Затем мы можем определить `achieve-all` следующим образом:"

#: in/chapter4.md:413
msgid ""
"```lisp\n"
"(defun achieve-all (goals)\n"
"  \"Try to achieve each goal, then make sure they still hold.\"\n"
"  (and (every #'achieve goals) (subsetp goals *state*)))\n"
"```\n"
"The Common Lisp function subsetp returns true if its first argument is a "
"subset of its second.\n"
"In `achieve-all`, it returns true if every one of the goals is still in the "
"current state after achieving all the goals.\n"
"This is just what we wanted to test."
msgstr ""
"```lisp\n"
"(defun achieve-all (goals)\n"
"  \"Try to achieve each goal, then make sure they still hold.\"\n"
"  (and (every #'achieve goals) (subsetp goals *state*)))\n"
"```\n"
"Функция Common Lisp subsetp  возвращает true, если ее первый аргумент "
"является подмножеством его вторго аргумента. В `achieve-all`, она возвращает "
"значение true, если каждая из целей все еще  находится в текущем состоянии "
"после достижения всех целей. \n"
"Это то, что мы хотели проверить."

#: in/chapter4.md:416
msgid ""
"The introduction of `achieve-all` prevents GPS from returning true when one "
"of the goals gets clobbered, but it doesn't force GPS to replan and try to "
"recover from a clobbered goal.\n"
"We won't consider that possibility now, but we will take it up again in the "
"section on the blocks world domain, which was Sussman's primary example."
msgstr ""
"Введение `achieve-all` предотвращает возврат из GPS истины, когда одина из "
"целей повреждена, но это не заставляет GPS перепланировать и попытаться "
"восстановиться из за поврежденной цели.\n"
"Мы не будем рассматривать эту возможность сейчас, но мы ее рассмотрим снова "
"в разделе о домене мира блоков, который был основным примером Суссмана.\n"

#: in/chapter4.md:418
msgid "## 4.8 The Leaping before You Look Problem"
msgstr "## 4.8 Прыжок перед тем как вы увидели проблему(прыгнуть в слепую)."

#: in/chapter4.md:422
msgid ""
"Another way to address the \"prerequisite clobbers sibling goal\" problem is "
"just to be more careful about the order of goals in a goal list.\n"
"If we want to get the kid to school and still have some money left, why not "
"just specify the goal as (`son-at-school have-money`) rather than (`have-"
"money son-at-school`)?\n"
"Let's see what happens when we try that:"
msgstr ""
"Еще один способ решить проблему \"предпослыки повреждения брата цели\" - это "
"просто более внимательно отнестись к порядку целей в списке целей.\n"
"Если мы хотим отправить ребенка в школу и еще иметь немного денег, почему бы "
"просто не сказать (`son-at-school have-money`), а не (`have-money son-at-"
"school`)?\n"
"Давайте посмотрим, что произойдет когда мы попробуем это сделать:"

#: in/chapter4.md:438
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(son-at-school have-money)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"NIL\n"
"```\n"
"GPS returns nil, reflecting the fact that the goal cannot be achieved, but "
"only after executing all actions up to and including driving to school.\n"
"I call this the \"leaping before you look\" problem, because if you asked "
"the program to solve for the two goals `(jump-off-cliff land-safely)` it "
"would happily jump first, only to discover that it had no operator to land "
"safely.\n"
"This is less than prudent behavior."
msgstr ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"    '(son-at-school have-money)\n"
"    *school-ops*)\n"
"(EXECUTING LOOK-UP-NUMBER)\n"
"(EXECUTING TELEPHONE-SHOP)\n"
"(EXECUTING TELL-SHOP-PROBLEM)\n"
"(EXECUTING GIVE-SHOP-MONEY)\n"
"(EXECUTING SHOP-INSTALLS-BATTERY)\n"
"(EXECUTING DRIVE-SON-TO-SCHOOL)\n"
"NIL\n"
"```\n"
"GPS возвращает nil, отражая тот факт, что цель не может быть достигнута, но "
"только после того, как выполнены все действия, вплоть до поездки в школу, "
"включительно.\n"
"Я называю это \"прыжком перед тем как проблема будет видна\", потому что "
"если бы вы попросили программу решить проблему для двух целей `(jump-off-"
"cliff land-safely)`, она бы вначале прыгнула и только потом обнаружила, что "
"в ней нет оператора, чтобы безопасно приземлиться.\n"
"Это далеко не благоразумное поведение."

#: in/chapter4.md:443
msgid ""
"The problem arises because planning and execution are interleaved.\n"
"Once the preconditions for an operator are achieved, the action is taken-and "
"`*state*` is irrevocably changed-even if this action may eventually lead to "
"a dead end.\n"
"An alternative would be to replace the single global `*state*` with distinct "
"local state variables, such that a new variable is created for each new "
"state.\n"
"This alternative is a good one for another, independent reason, as we shall "
"see in the next section."
msgstr ""
"Проблема возникает потому, что планирование и исполнение чередуются. Как "
"только предварительные условия для оператора достигнуты, предпринимается "
"дейтсвие-и состояние `*state*` бесповоротно изменяется, даже если это "
"действие, в конечном итоге, может завести в тупк.\n"
"Альтернативой было бы заменить одно глобальное состояние `*state*` "
"различными локальными переменными состояния, так что для каждого нового "
"состояния создавалась бы новая переменная.\n"
"как мы увидим в следующем разделе, эта альтернатива хороша и по другой, "
"независимой причине."

#: in/chapter4.md:445
msgid "## 4.9 The Recursive Subgoal Problem"
msgstr "## 4.9 Проблема рекурсивности подцели"

#: in/chapter4.md:450
msgid ""
"In our simulated nursery school world there is only one way to find out a "
"phone number: to look it up in the phone book.\n"
"Suppose we want to add an operator for finding out a phone number by asking "
"someone.\n"
"Of course, in order to ask someone something, you need to be in "
"communication with him or her.\n"
"The asking-for-a-phone-number operator could be implemented as follows:"
msgstr ""
"В нашем моделируемом мире с детским садом есть только один способ узнать "
"номер телефона: посмотреть его в телефонной книге.\n"
"Предположим, мы хотим добавить оператор, позволяющий узнать номер телефона, "
"спросив кого-либо.\n"
"Конечно, для того чтобы спросить кого-то о чем-то, вы должны общаться с ним "
"или ней.\n"
"Оператор для запроса телефонного номера(asking-for-a-phone-number) может "
"быть реализован следующим образом:"

#: in/chapter4.md:459
msgid ""
"```lisp\n"
"(push (make-op :action 'ask-phone-number\n"
"      :preconds '(in-communication-with-shop)\n"
"      :add-list '(know-phone-number))\n"
"    *school-ops*)\n"
"```\n"
"(The special form ( `push`*item list*) puts the item on the front of the "
"list; it is equivalent to (setf *list* (`cons`*item list*) ) in the simple "
"case.) Unfortunately, something unexpected happens when we attempt to solve "
"seemingly simple problems with this new set of operators.\n"
"Consider the following:"
msgstr ""
"```lisp\n"
"(push (make-op :action 'ask-phone-number\n"
"      :preconds '(in-communication-with-shop)\n"
"      :add-list '(know-phone-number))\n"
"    *school-ops*)\n"
"```\n"
"(Специальная форма ( `push`*item list*) помещает элемент в начало списка; "
"это выражение эквивалентно (setf *list* (`cons`*item list*) ) в простом "
"случае.) К сожалению, иногда случается нечто не ожиданное, когда мы пытаемся "
"решить, казалось бы простые, проблемы с этим новым набором(множеством) "
"операторов. \n"
"Обратите внимание на следующее:"

#: in/chapter4.md:471
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
">>TRAP 14877 (SYSTEM:PDL-OVERFLOW EH: :REGULAR)\n"
"The regular push-down list has overflown.\n"
"While in the function ACHIEVE <- EVERY <- REMOVE\n"
"```\n"
"The error message (which will vary from one implementation of Common Lisp to "
"another) means that too many recursively nested function calls were made.\n"
"This indicates either a very complex problem or, more commonly, a bug in the "
"program leading to infinite recursion.\n"
"One way to try to see the cause of the bug is to trace a relevant function, "
"such as `achieve`:"
msgstr ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
">>TRAP 14877 (SYSTEM:PDL-OVERFLOW EH: :REGULAR)\n"
"The regular push-down list has overflown.\n"
"While in the function ACHIEVE <- EVERY <- REMOVE\n"
"```\n"
"Сообщение об ошибке (которое будет варьироваться от одной реализации Common "
"Lisp к другой) означает, что было сделано слишком много рекурсивно вложенных "
"вызовов функций.\n"
"Это указывает либо на очень сложную проблему, либо, чаще всего, на ошибку в "
"программе, которая ведет к бесконечной рекурсси.\n"
"Один из способов попытаться увидеть причину ошибки - это трассировать "
"соответствующую функцию, такую как `achieve`:"

#: in/chapter4.md:473
msgid "`> (trace achieve)`=> `(ACHIEVE)`"
msgstr ""

#: in/chapter4.md:499
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(1 ENTER ACHIEVE: SON-AT-SCHOOL)\n"
"  (2 ENTER ACHIEVE: SON-AT-HOME)\n"
"  (2 EXIT ACHIEVE: (SON-AT-HOME CAR-NEEDS-BATTERY HAVE-MONEY))\n"
"  (2 ENTER ACHIEVE: CAR-WORKS)\n"
"    (3 ENTER ACHIEVE: CAR-NEEDS-BATTERY)\n"
"    (3 EXIT ACHIEVE: (CAR-NEEDS-BATTERY HAVE-MONEY))\n"
"    (3 ENTER ACHIEVE: SHOP-KNOWS-PROBLEM)\n"
"      (4 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"        (5 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"          (6 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"            (7 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"              (8 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"                (9 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"```\n"
"The output from trace gives us the necessary clues.\n"
"Newell and Simon talk of \"oscillating among ends, functions required, and "
"means that perform them.\" Here it seems we have an infinite oscillation "
"between being in communication with the shop (levels 4, 6, 8,...) and "
"knowing the shop's phone number (levels 5, 7, 9,...).\n"
"The reasoning is as follows: we want the shop to know about the problem with "
"the battery, and this requires being in communication with him or her.\n"
"One way to get in communication is to phone, but we don't have a phone book "
"to look up the number.\n"
"We could ask them their phone number, but this requires being in "
"communication with them.\n"
"As Aristotle put it, \"If we are to be always deliberating, we shall have to "
"go on to infinity.\" We will call this the \"recursive subgoal\" problem: "
"trying to solve a problem in terms of itself.\n"
"One way to avoid the problem is to have achieve keep track of all the goals "
"that are being worked on and give up if it sees a loop in the goal stack."
msgstr ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money)\n"
"    '(son-at-school)\n"
"    *school-ops*)\n"
"(1 ENTER ACHIEVE: SON-AT-SCHOOL)\n"
"  (2 ENTER ACHIEVE: SON-AT-HOME)\n"
"  (2 EXIT ACHIEVE: (SON-AT-HOME CAR-NEEDS-BATTERY HAVE-MONEY))\n"
"  (2 ENTER ACHIEVE: CAR-WORKS)\n"
"    (3 ENTER ACHIEVE: CAR-NEEDS-BATTERY)\n"
"    (3 EXIT ACHIEVE: (CAR-NEEDS-BATTERY HAVE-MONEY))\n"
"    (3 ENTER ACHIEVE: SHOP-KNOWS-PROBLEM)\n"
"      (4 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"        (5 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"          (6 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"            (7 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"              (8 ENTER ACHIEVE: IN-COMMUNICATION-WITH-SHOP)\n"
"                (9 ENTER ACHIEVE: KNOW-PHONE-NUMBER)\n"
"```\n"
"Выходные данные трассировки trace дают необходимые подсказки.\n"
"Ньюэл и Саймон говорят о \"колебании(переключении) между целями, требуемыми "
"функциями и средствами, которые необходимы для их выполнения.\" Здесь, "
"кажется, мы имеем бесконечное колебание между тем, чтобы быть в общеии с "
"магазином (levels 4, 6, 8,...) и попыткой узнать номер телефона магазина "
"(levels 5, 7, 9,...).\n"
"Рассуждение заключается в следующем: мы хотим, чтобы магазин узнал о "
"проблеме с батареей, и для этого необходимо с ним(или с ней) "
"проконтактировать.\n"
"Один из спопособов проконтактировать, это позвонить по телефону, но у нас "
"нет телефонной книги, чтобы посмотреть номер.\n"
"Мы могли бы спросить у них их номер телефона, но для этого нажно с ними "
"проконтактировать.\n"
"Как выразился Аристотель, \"если мы хотим постоянно размышлять, нам придется "
"дойти до бесконечности\". Мы назовем это проблемой \"рекусивной подцели\": "
"попытке решить проблему в териминах самой проблемы.\n"
"Один из способов избежать этой проблемы - заставить achieve отслеживать все "
"цели, над которыми она работает, и прекращать работу, если она найдет петлю "
"в стеке целей."

#: in/chapter4.md:501
msgid "## 4.10 The Lack of Intermediate Information Problem"
msgstr "## 4.10 проблема отсутствия промежуточной информации"

#: in/chapter4.md:506
msgid ""
"When GPS fails to find a solution, it just returns `nil`.\n"
"This is annoying in cases where the user expected a solution to be found, "
"because it gives no information about the cause of failure.\n"
"The user could always trace some function, as we traced achieve above, but "
"the output from trace is rarely exactly the information desired.\n"
"It would be nice to have a general debugging output tool where the "
"programmer could insert print statements into his code and have them "
"selectively printed, depending on the information desired."
msgstr ""
"Когда GPS не может найт решение, он просто возвращает `nil`.\n"
"Это раздражает в тех случаях, когда пользователь ожидал, что решение будет "
"найдено, потому что этот nil не дает никакой информации о причине сбоя.\n"
"Пользователь всегда может отследить(трассировать)какую-то функцию, как мы "
"трассировали выше, но вывод трассировки редко является именно той "
"информцией, которая требуется. Было бы неплохо иметь общий инструмент "
"выводящий отладочную информацию, используя который программист мог бы "
"вставлять операторы печати в свой код и выборочно печатать их в зависимости "
"от желаемой информации."

#: in/chapter4.md:513
msgid ""
"The function `dbg` provides this capability.\n"
"`dbg` prints output in the same way as `format`, but it will only print when "
"debugging output is desired.\n"
"Each call to `dbg` is accompanied by an identifier that is used to specify a "
"class of debugging messages.\n"
"The functions `debug` and `undebug` are used to add or remove message "
"classes to the list of classes that should be printed.\n"
"In this chapter, all the debugging output will use the identifier :`gps`.\n"
"Other programs will use other identifiers, and a complex program will use "
"many identifiers."
msgstr ""
"Функция `dbg` обеспечивает эту возможность.\n"
"`dbg` печатает выходные данные также как `format`, но она будет печатать "
"только тогда, когда троебуется отладочный вывод.\n"
"Каждый вызов `dbg` сопровождается идентификатором, который используется для "
"укзанания класса отладочных сообщений.\n"
"Функции `debug` и `undebug` используются для добавления или удаления классов "
"сообщений в список классов, которые должны быть напечатаны.\n"
"В этой главе, все выходные отладочные данные будут использовать "
"идентификатор: `gps`.\n"
"Другие программы будут использовать другие идентификаторы, а сложная "
"программа будет использовать много идентификаторов."

#: in/chapter4.md:517
msgid ""
"A call to `dbg` will result in output if the first argument to `dbg`, the "
"identifier, is one that was specified in a call to `debug`.\n"
"The other arguments to `dbg` are a format string followed by a list of "
"arguments to be printed according to the format string.\n"
"In other words, we will write functions that include calls to `dbg` like:"
msgstr ""
"Вызов `dbg` приведет к выводу, если первый аргумент `dbg`, является тем, "
"который был указан в вызове `debug`.\n"
"Остальные аргументы `dbg` - это строка формата, за которой следует список "
"аргументов, которые должны быть напечатаны в соответствии с этой строкой "
"формата.\n"
"Другими словами, мы будем писать функции, которые включают в себя вызовы "
"`dbg` такие как:"

#: in/chapter4.md:527
msgid ""
"```lisp\n"
"(dbg :gps \"The current goal is: ~a\" goal)\n"
"```\n"
"If we have turned on debugging with `(debug :gps)`, then calls to dbg with "
"the identifier :`gps` will print output.\n"
"The output is turned off with `(undebug :gps)`.\n"
"`debug` and `undebug` are designed to be similar to `trace` and `untrace`, "
"in that they turn diagnostic output on and off.\n"
"They also follow the convention that `debug` with no arguments returns the "
"current list of identifiers, and that `undebug` with no arguments turns all "
"debugging off.\n"
"However, they differ from `trace` and `untrace` in that they are functions, "
"not macros.\n"
"If you use only keywords and integers for identifiers, then you won't notice "
"the difference."
msgstr ""
"```lisp\n"
"(dbg :gps \"The current goal is: ~a\" goal)\n"
"```\n"
"Если мы включили отладку с помощью `(debug :gps)`, то вызовы dbg с "
"идентификатором  :`gps` будут выводить выходные данные.\n"
"Вывод выключается с помощью `(undebug :gps)`.\n"
"`debug` и `undebug` предназначены для того, чтобы быть похожими на `trace` и "
"`untrace`, в том смысле, что они включают и выключают диагностический "
"вывод.\n"
"Они также следуют соглашению, что `debug` без аргументов возвращает текущий "
"список идентификаторов, а `undebug` без аргументов отключает вывод всей "
"отладочной информации.\n"
"Однако они в отличии от `trace` и `untrace`, являются функциями, а не "
"макросами.\n"
"Если вы исползуете только ключевые слова и целые числа для идентификаторов, "
"то вы не заметите разницы."

#: in/chapter4.md:534
msgid ""
"Two new built-in features are introduced here.\n"
"First, `*debug-io*` is the stream normally used for debugging input/output.\n"
"In all previous calls to `format` we have used t as the stream argument, "
"which causes output to go to the `*standard-output*` stream.\n"
"Sending different types of output to different streams allows the user some "
"flexibility.\n"
"For example, debugging output could be directed to a separate window, or it "
"could be copied to a file.\n"
"Second, the function `fresh-line` advances to the next line of output, "
"unless the output stream is already at the start of the line."
msgstr ""
"Здесь представлены две новые встроенные функции.\n"
"Во первых, `*debug-io*` это поток, обычно используемый для отладки ввода/"
"вывода.\n"
"Во всех предыдущих вызовах `format` мы использовали t в качестве аргумента "
"потока, что приводило к переходу вывода в поток `*standard-output*`.\n"
"Отправка различных типов выходных данных в различные потоки позволяет "
"пользователю проявлять некоторую гибкость.\n"
"Например, отладочный вывод может быть направлен в отдельное окно или "
"скопирован в файл.\n"
"Во вторых, функция `fresh-line` переходит к следующей строке вывода, если "
"только выходной поток уже не находиться в начале строки."

#: in/chapter4.md:537
msgid ""
"```lisp\n"
"(defvar *dbg-ids* nil \"Identifiers used by dbg\")"
msgstr ""

#: in/chapter4.md:543
msgid ""
"(defun dbg (id format-string &rest args)\n"
"  \"Print debugging info if (DEBUG ID) has been specified.\"\n"
"  (when (member id *dbg-ids*)\n"
"    (fresh-line *debug-io*)\n"
"    (apply #'format *debug-io* format-string args)))"
msgstr ""

#: in/chapter4.md:547
msgid ""
"(defun debug (&rest ids)\n"
"  \"Start dbg output on the given ids.\"\n"
"  (setf *dbg-ids* (union ids *dbg-ids*)))"
msgstr ""

#: in/chapter4.md:555
msgid ""
"(defun undebug (&rest ids)\n"
" \"Stop dbg on the ids. With no ids, stop dbg altogether.\"\n"
"  (setf *dbg-ids* (if (null ids) nil\n"
"            (set-difference *dbg-ids* ids))))\n"
"```\n"
"Sometimes it is easier to view debugging output if it is indented according "
"to some pattern, such as the depth of nested calls to a function.\n"
"To generate indented output, the function `dbg-indent` is defined:"
msgstr ""
"(defun undebug (&rest ids)\n"
" \"Stop dbg on the ids. With no ids, stop dbg altogether.\"\n"
"  (setf *dbg-ids* (if (null ids) nil\n"
"            (set-difference *dbg-ids* ids))))\n"
"```\n"
"Иногда легче посмотреть отладочный вывод, если он имеет отступ в "
"соответствии с каким-то шаблоном, например глубиной вложенных вызовов "
"функции.\n"
"Для генерации выходных с отступом определяется функция `dbg-indent`:"

#: in/chapter4.md:565
msgid ""
"```lisp\n"
"(defun dbg-indent (id indent format-string &rest args)\n"
"  \"Print indented debugging info if (DEBUG ID) has been specified.\"\n"
"  (when (member id *dbg-ids*)\n"
"    (fresh-line *debug-io*)\n"
"    (dotimes (i indent) (princ \" \" *debug-io*))\n"
"    (apply #'format *debug-io* format-string args)))\n"
"```\n"
"## 4.11 GPS Version 2: A More General Problem Solver"
msgstr ""
"```lisp\n"
"(defun dbg-indent (id indent format-string &rest args)\n"
"  \"Print indented debugging info if (DEBUG ID) has been specified.\"\n"
"  (when (member id *dbg-ids*)\n"
"    (fresh-line *debug-io*)\n"
"    (dotimes (i indent) (princ \" \" *debug-io*))\n"
"    (apply #'format *debug-io* format-string args)))\n"
"```\n"
"## 4.11 GPS Версия 2: более общий решатель проблем"

#: in/chapter4.md:568
msgid ""
"At this point we are ready to put together a new version of GPS with "
"solutions for the \"running around the block,\" \"prerequisite clobbers "
"sibling goal,\" \"leaping before you look,\" and \"recursive subgoal\" "
"problems.\n"
"The glossary for the new version is in [figure 4.2](#f0015)."
msgstr ""
"На этом этапе мы готовы собрать воедино новую версию GPS с решениями для "
"проблем \"бега вокруг блока\", \"предварительных условий ломающего цель брата"
"\", \"прыжка, прежде чем вы увидите проблему\" и \"рекурсивной подцели\".\n"
"Глоссарий для новой версии находится в [figure 4.2](#f0015)."

#: in/chapter4.md:601
msgid ""
"| Symbol             | Use                                                   "
"|\n"
"| ------             | ---                                                   "
"|\n"
"|                    | **Top-Level Function**                                "
"|\n"
"| `GPS`              | Solve a goal from a state using a list of operators.  "
"|\n"
"|                    | **Special Variables**                                 "
"|\n"
"| `*ops*`            | A list of available operators.                        "
"|\n"
"|                    | **Data Types**                                        "
"|\n"
"| `op`               | An operation with preconds, add-list and del-list.    "
"|\n"
"|                    | **Major Functions**                                   "
"|\n"
"| `achieve-all`      | Achieve a list of goals.                              "
"|\n"
"| `achieve`          | Achieve an individual goal.                           "
"|\n"
"| `appropriate-p`    | Decide if an operator is appropriate for a goal.      "
"|\n"
"| `apply-op`         | Apply operator to current state.                      "
"|\n"
"|                    | **Auxiliary Functions**                               "
"|\n"
"| `executing-p`      | Is a condition an *executing* form?                   "
"|\n"
"| `starts-with`      | Is the argument a list that starts with a given atom? "
"|\n"
"| `convert-op`       | Convert an operator to use the *executing* "
"convention.|\n"
"| `op`               | Create an operator.                                   "
"|\n"
"| `use`              | Use a list of operators.                              "
"|\n"
"| `member-equal`     | Test if an element is equal to a member of a list.    "
"|\n"
"|                    | **Selected Common Lisp Functions**                    "
"|\n"
"| `member`           | Test if an elementis a member of a list. (p.78)       "
"|\n"
"| `set-difference`   | All elements in one set but not the other.            "
"|\n"
"| `subsetp`          | Is one set wholly contained in another?               "
"|\n"
"| `union`            | All elements in either of the two sets.               "
"|\n"
"| `every`            | Test if every element of a list passes a test. (p. "
"62)|\n"
"| `some`             | Test if any element of a list passes a test.          "
"|\n"
"| `remove-if`        | Remove all items satisfying a test.                   "
"|\n"
"|                    | **Previously Defined Functions**                      "
"|\n"
"| `find-all`         | A list of all matching elements. (p. 101)             "
"|\n"
"| `find-all-if`      | A list of all elements satisfying a predicate.        "
"|"
msgstr ""
"| Символ             | "
"Использование                                                     |\n"
"| ------             | "
"---                                                               |\n"
"|                    | **Функция верхнего "
"уровняunction**                                |\n"
"| `GPS`              | Достигает цели из состояния state используя список "
"операторов     |\n"
"|                    | **Специальные "
"переменные**                                        |\n"
"| `*ops*`            | Список доступных "
"операторов              .                        |\n"
"|                    | **Типы "
"данных**                                                   |\n"
"| `op`               | Операция с условиями/состояниями preconds, add-list и "
"del-list.   |\n"
"|                    | **Главные "
"функции**                                               |\n"
"| `achieve-all`      | достижение списка "
"целей.                                          |\n"
"| `achieve`          | достижение индивидуальной "
"цели                                    |\n"
"| `appropriate-p`    | Решает, подходит ли оператор для достижения "
"цели.                 |\n"
"| `apply-op`         | Применяет оператор к текущему "
"состоянию                           |\n"
"|                    | **вспомогательные "
"функции**                                       |\n"
"| `executing-p`      | Является ли условие *исполняемой*   "
"формой?                       |\n"
"| `starts-with`      | Является ли аргумент списком, который начинается с "
"данного атома? |\n"
"| `convert-op`       | Преобраз. оператора при использовании соглашения о "
"*исполнении*.  |\n"
"| `op`               | Создает "
"оператор.                                                 |\n"
"| `use`              | Используемый список "
"операторов.                                   |\n"
"| `member-equal`     | Проверяет, равен ли элемент члену "
"списка.                         |\n"
"|                    | **Выбранные Функции Common "
"Lisp**                                 |\n"
"| `member`           | Проверяет является ли элемент членом списка "
"(p.78)                |\n"
"| `set-difference`   | Все элементы в одном множестве, не входящие в "
"другое              |\n"
"| `subsetp`          | Содержится ли одино множество целиком в "
"другом?                   |\n"
"| `union`            | Все элементы в любом из двух наборов (p. "
"62)                      |\n"
"| `every`            | проверяет, проходит ли тест каждый элемент "
"списка.                |\n"
"| `some`             | Проверяет, проходит ли тест какой-либо элемент "
"списка.            |\n"
"| `remove-if`        | Удаляет все элементы, удовлетворяющие "
"тесту.                      |\n"
"|                    | **Ранее определенные "
"функции**                                    |\n"
"| `find-all`         | Список всех совпадающих элементов (p. "
"101)                        |\n"
"| `find-all-if`      | Список всех элементов, удовлетворяющих "
"предикату                  |"

#: in/chapter4.md:607
msgid ""
"The most important change is that, instead of printing a message when each "
"operator is applied, we will instead have `GPS` return the resulting state.\n"
"A list of \"messages\" in each state indicates what actions have been "
"taken.\n"
"Each message is actually a condition, a list of the form (executing "
"*operator*).\n"
"This solves the \"running around the block\" problem: we could call `GPS` "
"with an initial goal of `((executing run-around-block))`, and it would "
"execute the `run-around-block` operator, thereby satisfying the goal.\n"
"The following code defines a new function, op, which builds operators that "
"include the message in their add-list."
msgstr ""
"Самое важное изменение заключается в том, что вместо печати сообщения при "
"применении каждого оператора мы будем иметь `GPS`, возвращающий "
"результирующее состояние.\n"
"Список \"сообщений\" в каждом состоянии указывает, какие действия были "
"предприняты.\n"
"Каждое сообщение на самом деле является условием, списком формы (executing "
"*operator*).\n"
"Это решает проблему \"бега вокруг блока\": мы можем вызвать `GPS` с "
"начальной целью `((executing run-around-block))`, И он выполнит оператор "
"`run-around-block`, Тем самым удовлетворяя этой цели.\n"
"Следующий код определяет новую функцию op, которая строит операторы, "
"включающие сообщение(message) в свой список add-list."

#: in/chapter4.md:612
msgid ""
"```lisp\n"
"(defun executing-p (x)\n"
"  \"Is x of the form: (executing ...) ?\"\n"
"  (starts-with x 'executing))"
msgstr ""

#: in/chapter4.md:616
msgid ""
"(defun starts-with (list x)\n"
"  \"Is this a list whose first element is x?\"\n"
"  (and (consp list) (eql (first list) x)))"
msgstr ""

#: in/chapter4.md:622
msgid ""
"(defun convert-op (op)\n"
"  \"Make op conform to the (EXECUTING op) convention.\"\n"
"  (unless (some #'executing-p (op-add-list op))\n"
"    (push (list 'executing (op-action op)) (op-add-list op)))\n"
"  op)"
msgstr ""

#: in/chapter4.md:630
msgid ""
"(defun op (action &key preconds add-list del-list)\n"
"  \"Make a new operator that obeys the (EXECUTING op) convention.\"\n"
"  (convert-op\n"
"    (make-op :action action :preconds preconds\n"
"          :add-list add-list :del-list del-list)))\n"
"```\n"
"Operators built by op will be correct, but we can convert existing operators "
"using `convert-op` directly:"
msgstr ""
"(defun op (action &key preconds add-list del-list)\n"
"  \"Make a new operator that obeys the (EXECUTING op) convention.\"\n"
"  (convert-op\n"
"    (make-op :action action :preconds preconds\n"
"          :add-list add-list :del-list del-list)))\n"
"```\n"
"Операторы, построенные op, будут правильными, но мы можем конвертировать "
"существующие операторы, используя `convert-op` напрямую:"

#: in/chapter4.md:634
msgid ""
"```lisp\n"
"(mapc #'convert-op *school-ops*)\n"
"```"
msgstr ""

#: in/chapter4.md:636
msgid ""
"This is an example of exploratory programming: instead of starting all over "
"when we discover a limitation of the first version, we can use Lisp to alter "
"existing data structures for the new version of the program."
msgstr ""
"Это пример исследовательского программирования: вместо того, чтобы начинать "
"все сначала, когда мы обнаруживаем ограничение первой версии, мы можем "
"использовать Lisp для изменения существующих структур данных для новой "
"версии программы."

#: in/chapter4.md:643
msgid ""
"The definition of the variable `*ops*` and the structure op are exactly the "
"same as before, and the rest of the program consists of five functions we "
"have already seen: `GPS`, `achieve-all`, `achieve`, `appropriate-p`, and "
"`apply-op`.\n"
"At the top level, the function `GPS` calls `achieve-all`, which returns "
"either nil or a valid state.\n"
"From this we remove all the atoms, which leaves only the elements of the "
"final state that are lists-in other words, the actions of the form "
"(`executing`*operator*).\n"
"Thus, the value of `GPS` itself is the list of actions taken to arrive at "
"the final state.\n"
"`GPS` no longer returns `SOLVED` when it finds a solution, but it still "
"obeys the convention of returning nil for failure, and non-nil for success.\n"
"In general, it is a good idea to have a program return a meaningful value "
"rather than print that value, if there is the possibility that some other "
"program might ever want to use the value."
msgstr ""
"Определение переменной `*ops*` и структуры op точно такие же, как и раньше, "
"а остальная часть программы состоит из пяти функций, которые мы уже видели: "
"`GPS`, `achieve-all`, `achieve`, `appropriate-p` и `apply-op`.\n"
"На верхнем уровне функция `GPS` вызывает `achieve-all`, которая возвращает "
"либо nil, либо допустимое состояние.\n"
"Из него мы удаляем все атомы, в результате чего остаются только элементы "
"конечного состояния, которые являются списками - другими словами, действиями "
"формы (`executing`*operator*).\n"
"Таким образом, значение возвращаемое `GPS` само по себе является списком "
"действий, предпринимаемых для достижения конечного состояния.\n"
"`GPS` больше не возвращает `SOLVED`, когда он находит решение, но она по-"
"прежнему подчиняется условию возврата nil в случае неудачи и не-nil для "
"успеха.\n"
"В общем, это хорошая идея, чтобы программа возвращала значимое значение, а "
"не печатала это значение, если есть вероятность, что какая-то другая "
"программа когда-нибудь захочет использовать это значение."

#: in/chapter4.md:646
msgid ""
"```lisp\n"
"(defvar *ops* nil \"A list of available operators.\")"
msgstr ""

#: in/chapter4.md:649
msgctxt "in/chapter4.md:649"
msgid ""
"(defstruct op \"An operation\"\n"
"  (action nil) (preconds nil) (add-list nil) (del-list nil))"
msgstr ""

#: in/chapter4.md:654
msgid ""
"(defun GPS (state goals &optional (*ops* *ops*))\n"
"  \"General Problem Solver: from state, achieve goals using *ops*.\"\n"
"  (remove-if #'atom (achieve-all (cons '(start) state) goals nil)))\n"
"```"
msgstr ""

#: in/chapter4.md:660
msgid ""
"The first major change in version 2 is evident from the first line of the "
"program: there is no `*state*` variable.\n"
"Instead, the program keeps track of local state variables.\n"
"This is to solve the \"leaping before you look\" problem, as outlined "
"before.\n"
"The functions `achieve`, `achieve-all`, and `apply-op` all take an extra "
"argument which is the current state, and all return a new state as their "
"value.\n"
"They also must still obey the convention of returning nil when they fail."
msgstr ""
"Первое серьезное изменение в версии 2 очевидно из первой строки программы: "
"отсутствует переменная   `*state*`.\n"
"Вместо этого программа отслеживает локальные переменные состояния - state.\n"
"Это сделано для того, чтобы решить проблему «прыжка, прежде чем посмотреть», "
"как было сказано ранее.\n"
"Все функции `achieve`, `achieve-all` и `apply-op` принимают дополнительный "
"аргумент, который является текущим состоянием, и все возвращают новое "
"состояние в качестве своего значения.\n"
"Они также должны подчиняются соглашению о возврате nil в случае неудачи."

#: in/chapter4.md:669
msgid ""
"Thus we have a potential ambiguity: does nil represent failure, or does it "
"represent a valid state that happens to have no conditions?\n"
"We resolve the ambiguity by adopting the convention that all states must "
"have at least one condition.\n"
"This convention is enforced by the function GPS.\n"
"Instead of calling (`achieve-all state goals nil`), GPS calls `(achieve-all "
"(cons '(start) state) goals nil)`.\n"
"So even if the user passes GPS a null initial state, it will pass on a state "
"containing `(start)` to `achieve-all`.\n"
"From then on, we are guaranteed that no state will ever become nil, because "
"the only function that builds a new state is `apply-op`, and we can see by "
"looking at the last line of `apply-op` that it always appends something onto "
"the state it is returning.\n"
"(An add-list can never be nil, because if it were, the operator would not be "
"appropriate.\n"
"Besides, every operator includes the (executing ...) condition.)"
msgstr ""
"Таким образом, у нас получается потенциальная двусмысленность: обозначает ли "
"nil, что решение не найдено или допустимое состояние, которое не имеет "
"условий?\n"
"Мы разрешаем двусмысленность, принимая соглашение, согласно которому все "
"состояния должны иметь хотя бы одно условие.\n"
"Это соглашение обеспечивается функцией GPS.\n"
"Вместо вызова (`achieve-all state goals nil`), GPS вызывает `(achieve-all "
"(cons '(start) state) goals nil)`.\n"
"Таким образом, даже если пользователь передает GPS нулевое начальное "
"состояние,  та создаст состояние, содержащее `(start)`, передав его в "
"`achieve-all`.\n"
"С этого момента нам гарантируется, что ни одно состояние никогда не станет "
"nil, потому что единственная функция, которая создает новое состояние - это "
"`apply-op`, и мы можем видеть, посмотрев на последнюю строку `apply-op`, что "
"она всегда добавляет что-то в возвращаемое состояние.\n"
"(Список добавлений - add-list никогда не может быть nil, потому что в "
"противном случае оператор не был бы уместен.\n"
"Кроме того, каждый оператор включает условие (executing ...).)"

#: in/chapter4.md:673
msgid ""
"Note that the final value we return from GPS has all the atoms removed, so "
"we end up reporting only the actions performed, since they are represented "
"by conditions of the form (`executing *action*`).\n"
"Adding the `(start)` condition at the beginning also serves to differentiate "
"between a problem that cannot be solved and one that is solved without "
"executing any actions.\n"
"Failure returns nil, while a solution with no steps will at least include "
"the `(start)` condition, if nothing else."
msgstr ""
"Обратите внимание, что из конечного значения, которое мы возвращаем из GPS,  "
"удалены все атомы, поэтому в конечном итоге мы сообщаем только о выполненных "
"действиях, поскольку они представлены условиями формы (`executing "
"*action*`).\n"
"Добавление условия `(start)` в начале также служит для отличия проблемы, "
"которая не может быть решена, от проблемы, которая решается без выполнения "
"каких-либо действий.\n"
"Отказ возвращает nil, в то время как решение без выполнения шагов будет, по "
"крайней мере, включать условие `(start)`, если ничего больше требуется."

#: in/chapter4.md:683
msgid ""
"Functions that return nil as an indication of failure and return some useful "
"value otherwise are known as *semipredicates*.\n"
"They are error prone in just these cases where nil might be construed as a "
"useful value.\n"
"Be careful when defining and using semipredicates: (1) Decide if nil could "
"ever be a meaningful value.\n"
"(2) Insure that the *user* can't corrupt the program by supplying nil as a "
"value.\n"
"In this program, GPS is the only function the user should call, so once we "
"have accounted for it, we're covered.\n"
"(3) Insure that the *program* can't supply nil as a value.\n"
"We did this by seeing that there was only one place in the program where new "
"states were constructed, and that this new state was formed by appending a "
"one-element list onto another state.\n"
"By following this three-step procedure, we have an informal proof that the "
"semipredicates involving states will function properly.\n"
"This kind of informal proof procedure is a common element of good program "
"design."
msgstr ""
"Функции, которые возвращают nil как признак сбоя и возвращают какое-то "
"полезное значение, иначе известны как *полупредикаты*(*semipredicates*).\n"
"Они подвержены ошибкам только в тех случаях, когда nil может быть "
"истолковано как полезное значение.\n"
"Будьте осторожны при определении и использовании полупредикатов: (1) Решите, "
"может ли nil когда-либо быть значимым значением.\n"
"(2) Убедитесь, что *пользователь* не может повредить программу, указав в "
"качестве значения nil.\n"
"В этой программе GPS - единственная функция, которую пользователь должен "
"вызывать, поэтому, как только мы это учли, все готово.\n"
"(3) Убедитесь, что *программа* не может передать значение nil.\n"
"Мы сделали это, увидев, что в программе было только одно место, где были "
"созданы новые состояния, и что это новое состояние было сформировано путем "
"добавления одноэлементного списка к другому состоянию.\n"
"Следуя этой трехэтапной процедуре, мы получаем неформальное доказательство "
"того, что полупредикаты, работающие с состояниями, будут работать "
"правильно.\n"
"Такая процедура неформального доказательства является обычным элементом "
"хорошего дизайна программы."

#: in/chapter4.md:687
msgid ""
"The other big change in version 2 is the introduction of a goal stack to "
"solve the recursive subgoal problem.\n"
"The program keeps track of the goals it is working on and immediately fails "
"if a goal appears as a subgoal of itself.\n"
"This test is made in the second clause of `achieve`."
msgstr ""
"Другое большое изменение в версии 2 - это введение стека целей для решения "
"проблемы рекурсивных подцелей.\n"
"Программа отслеживает цели, над которыми она работает, и немедленно терпит "
"неудачу, если цель выступает в качестве подцели.\n"
"Эта проверка выполняется во втором предложении/пункте `achieve`."

#: in/chapter4.md:690
msgid ""
"The function `achieve-all` tries to achieve each one of the goals in turn, "
"setting the variable `current-state` to be the value returned from each "
"successive call to `achieve`.\n"
"If all goals are achieved in turn, and if all the goals still hold at the "
"end (as `subsetp` checks for), then the final state is returned; otherwise "
"the function fails, returning nil."
msgstr ""
"Функция `achieve-all` пытается достичь каждой из целей по очереди, "
"устанавливая переменную `current-state` как значение, возвращаемое при "
"каждом последующем вызове функции `achieve`.\n"
"Если все цели достигаются по очереди, и если все цели все еще сохраняются в "
"конце (что и проверяет `subsetp`), то возвращается конечное состояние; в "
"противном случае функция завершается ошибкой, возвращая nil."

#: in/chapter4.md:695
msgid ""
"Most of the work is done by `achieve`, which gets passed a state, a single "
"goal condition, and the stack of goals worked on so far.\n"
"If the condition is already in the state, then `achieve` succeeds and "
"returns the state.\n"
"On the other hand, if the goal condition is already in the goal stack, then "
"there is no sense continuing-we will be stuck in an endless loop-so "
"`achieve` returns nil.\n"
"Otherwise, `achieve` looks through the list of operators, trying to find one "
"appropriate to apply."
msgstr ""
"Большая часть работы выполняется с помощью `achieve`, которой передается "
"состояние, условие единственной цели и набор целей, над которыми до сих пор "
"работали.\n"
"Если условие уже находится в состоянии, то `achieve` завершается успешно и "
"возвращает состояние.\n"
"С другой стороны, если целевое условие уже находится в стеке целей, тогда "
"нет смысла продолжать - мы застрянем в бесконечном цикле, поэтому `achieve` "
"вернет nil.\n"
"В противном случае `achieve` просматривает список операторов, пытаясь найти "
"подходящий для применения."

#: in/chapter4.md:706
msgid ""
"```lisp\n"
"(defun achieve-all (state goals goal-stack)\n"
"  \"Achieve each goal, and make sure they still hold at the end.\"\n"
"  (let ((current-state state))\n"
"    (if (and (every #'(lambda (g)\n"
"            (setf current-state\n"
"              (achieve current-state g goal-stack)))\n"
"          goals)\n"
"        (subsetp goals current-state :test #'equal))\n"
"      current-state)))"
msgstr ""

#: in/chapter4.md:716
msgid ""
"(defun achieve (state goal goal-stack)\n"
"  \"A goal is achieved if it already holds,\n"
"  or if there is an appropriate op for it that is applicable.\"\n"
"  (dbg-indent :gps (length goal-stack) \"Goal: \"a\" goal)\n"
"  (cond ((member-equal goal state) state)\n"
"      ((member-equal goal goal-stack) nil)\n"
"      (t (some #'(lambda (op) (apply-op state goal op goal-stack))\n"
"          (find-all goal *ops* :test #'appropriate-p)))))\n"
"```"
msgstr ""

#: in/chapter4.md:725
msgid ""
"The goal `( (executing run-around-block) )` is a list of one condition, "
"where the condition happens to be a two-element list.\n"
"Allowing lists as conditions gives us more flexibility, but we also have to "
"be careful.\n"
"The problem is that not all lists that look alike actually are the same.\n"
"The predicate equal essentially tests to see if its two arguments look "
"alike, while the predicate `eql` tests to see if its two arguments actually "
"are identical.\n"
"Since functions like `member` use `eql` by default, we have to specify with "
"a `:test` keyword that we want `equal` instead.\n"
"Since this is done several times, we introduce the function `member-equal`.\n"
"In fact, we could have carried the abstraction one step further and defined "
"`member-situation`, a function to test if a condition is true in a "
"situation.\n"
"This would allow the user to change the matching function from `eql` to "
"`equal`, and to anything else that might be useful."
msgstr ""
"Цель `( (executing run-around-block) )` представляет собой список из одного "
"условия, где условие является списком из двух элементов.\n"
"Применение списков в качестве условий дает нам большую гибкость, но мы также "
"должны быть осторожны.\n"
"Проблема в том, что не все похожие списки на самом деле одинаковы.\n"
"Предикат equal по существу проверяет, похожи ли два его аргумента, а "
"предикат `eql` проверяет, идентичны ли два его аргумента.\n"
"Поскольку такие функции, как `member` по умолчанию используют `eql`, мы "
"должны указать с помощью ключевого слова `:test`, которое мы хотим вместо "
"него использовать.\n"
"Поскольку это делается несколько раз, мы вводим функцию `member-equal`.\n"
"Фактически, мы могли бы продвинуть абстракцию еще на один шаг и определить "
"`member-situation`, функцию для проверки того, является ли условие истинным "
"в некоторой ситуации.\n"
"Это позволит пользователю изменить функцию сопоставления с `eql` на `equal` "
"и на все остальное, что может быть полезно.\n"

#: in/chapter4.md:730
msgid ""
"```lisp\n"
"(defun member-equal (item list)\n"
"  (member item list :test #'equal))\n"
"```"
msgstr ""

#: in/chapter4.md:734
msgid ""
"The function `apply-op`, which used to change the state irrevocably and "
"print a message reflecting this, now returns the new state instead of "
"printing anything.\n"
"It first computes the state that would result from achieving all the "
"preconditions of the operator.\n"
"If it is possible to arrive at such a state, then `apply-op` returns a new "
"state derived from this state by adding what's in the add-list and removing "
"everything in the delete-list."
msgstr ""
"Функция `apply-op`, которая раньше безвозвратно изменяла состояние и "
"печатала сообщение, отражающее это, теперь возвращает новое состояние вместо "
"того, чтобы что-либо печатать.\n"
"Сначала она вычисляет состояние, которое будет результатом выполнения всех "
"предварительных условий оператора.\n"
"Если возможно достичь такого состояния, то `apply-op` возвращает новое "
"состояние, из полученного состояния, добавляя то, что находится в списке "
"добавления(add-list), и удаляя все что находится в списке удаления(delete-"
"list)."

#: in/chapter4.md:748
msgid ""
"```lisp\n"
"(defun apply-op (state goal op goal-stack)\n"
"  \"Return a new, transformed state if op is applicable.\"\n"
"  (dbg-indent :gps (length goal-stack) \"Consider: ~a\" (op-action op))\n"
"  (let ((state2 (achieve-all state (op-preconds op)\n"
"            (cons goal goal-stack))))\n"
"    (unless (null state2)\n"
"      ;; Return an updated state\n"
"      (dbg-indent :gps (length goal-stack) \"Action: ~a\" (op-action op))\n"
"      (append (remove-if #'(lambda (x)\n"
"            (member-equal x (op-del-list op)))\n"
"          state2)\n"
"        (op-add-list op)))))"
msgstr ""

#: in/chapter4.md:753
msgid ""
"(defun appropriate-p (goal op)\n"
"  \"An op is appropriate to a goal if it is in its add-list.\"\n"
"  (member-equal goal (op-add-list op)))\n"
"```"
msgstr ""

#: in/chapter4.md:758
msgid ""
"There is one last complication in the way we compute the new state.\n"
"In version 1 of GPS, states were (conceptually) unordered sets of "
"conditions, so we could use `union` and `set-difference` to operate on "
"them.\n"
"In version 2, states become ordered lists, because we need to preserve the "
"ordering of actions.\n"
"Thus, we have to use the functions `append` and `remove-if`, since these are "
"defined to preserve order, while `union` and `set-difference` are not."
msgstr ""
"Есть еще одна сложность в способе вычисления нового состояния.\n"
"В версии 1 GPS состояния были (концептуально) неупорядоченными "
"наборами(множествами) условий, поэтому мы могли использовать `union` и `set-"
"difference` для работы с ними.\n"
"В версии 2 состояния становятся упорядоченными списками, потому что нам "
"нужно сохранить порядок действий.\n"
"Таким образом, мы должны использовать функции `append` и `remove-if`, так "
"как они сохраненяют порядок обрабатываемого списка, а `union` и `set-"
"difference` - нет."

#: in/chapter4.md:761
msgid ""
"Finally, the last difference in version 2 is that it introduces a new "
"function: `use`.\n"
"This function is intended to be used as a sort of declaration that a given "
"list of operators is to be used for a series of problems."
msgstr ""
"Наконец, последнее отличие версии 2 состоит в том, что она вводит новую "
"функцию: `use`.\n"
"Эта функция предназначена для использования в качестве своего рода "
"объявления о том, что данный список операторов должен использоваться для "
"решения ряда проблем."

#: in/chapter4.md:769
msgid ""
"```lisp\n"
"(defun use (oplist)\n"
"  \"Use oplist as the default list of operators.\"\n"
"  ;; Return something useful, but not too verbose:\n"
"  ;; the number of operators.\n"
"   (length (setf *ops* oplist)))\n"
"```"
msgstr ""

#: in/chapter4.md:778
msgid ""
"Calling use sets the parameter `*ops*`, so that it need not be specified on "
"each call to GPS.\n"
"Accordingly, in the definition of GPS itself the third argument, `*ops*`, is "
"now optional; if it is not supplied, a default will be used.\n"
"The default value for `*ops*` is given as `*ops*`.\n"
"This may seem redundant or superfluous-how could a variable be its own "
"default?\n"
"The answer is that the two occurrences of `*ops*` look alike, but they "
"actually refer to two completely separate bindings of the special variable "
"`*ops*`.\n"
"Most of the time, variables in parameter lists are local variables, but "
"there is no rule against binding a special variable as a parameter.\n"
"Remember that the effect of binding a special variable is that all "
"references to the special variable that occur anywhere in the program-even "
"outside the lexical scope of the function-refer to the new binding of the "
"special variable.\n"
"So after a sequence of calls we eventually reach achieve, which references "
"`*ops*`, and it will see the newly bound value of `*ops*`."
msgstr ""
"Вызов use устанавливает параметр `*ops*`, поэтому его не нужно указывать при "
"каждом вызове GPS.\n"
"Соответственно, в определении самого GPS третий аргумент, `*ops*`, теперь "
"необязателен; если он не указан, будет использоваться значение по "
"умолчанию.\n"
"Значение по умолчанию для `*ops*` дается как `*ops*`.\n"
"Это может показаться излишним или черезмерным - как переменная может быть "
"сама собой по умолчанию?\n"
"Ответ заключается в том, что два появления `*ops*` похожи друг на друга, но "
"на самом деле они относятся к двум совершенно отдельным привязкам "
"специальной переменной `*ops*`.\n"
"В большинстве случаев переменные в списках параметров являются локальными "
"переменными, но нет правила, запрещающего привязку специальной переменной в "
"качестве параметра.\n"
"Помните, что эффект привязки специальной переменной заключается в том, что "
"все ссылки на специальную переменную, которые встречаются в любом месте "
"программы - даже за пределами лексической области действия функции, - "
"относятся к новой привязке специальной переменной.\n"
"Итак, после последовательности вызовов мы в конечном итоге достигаем "
"достижения, которое ссылается на `*ops*`, и оно увидит новое связанное "
"значение `*ops*`."

#: in/chapter4.md:781
msgid ""
"The definition of GPS is repeated here, along with an alternate version that "
"binds a local variable and explicitly sets and resets the special variable "
"`*ops*`.\n"
"Clearly, the idiom of binding a special variable is more concise, and while "
"it can be initially confusing, it is useful once understood."
msgstr ""
"Определение GPS повторяемоездесь вместе с альтернативной версией, которая "
"связывает локальную переменную и явно устанавливает и сбрасывает специальную "
"переменную `*ops*`.\n"
"Очевидно, что идиома привязки специальной переменной более лаконична, хотя "
"она и может выглядеть вначале запутанной, она полезна, когда ее понимают."

#: in/chapter4.md:786
msgid ""
"```lisp\n"
"(defun GPS (state goals &optional (*ops* *ops*))\n"
"  \"General Problem Solver: from state, achieve goals using *ops*.\"\n"
"  (remove-if #'atom (achieve-all (cons '(start) state) goals nil)))"
msgstr ""

#: in/chapter4.md:797
msgid ""
"(defun GPS (state goals &optional (ops *ops*))\n"
"  \"General Problem Solver: from state, achieve goals using *ops*.\"\n"
"  (let ((old-ops *ops*))\n"
"    (setf *ops* ops)\n"
"    (let ((result (remove-if #'atom (achieve-all\n"
"                  (cons'(start) state)\n"
"                  goals nil ))))\n"
"      (setf *ops* old-ops)\n"
"      result)))\n"
"```"
msgstr ""

#: in/chapter4.md:801
msgid ""
"Now let's see how version 2 performs.\n"
"We use the list of operators that includes the \"asking the shop their phone "
"number\" operator.\n"
"First we make sure it will still do the examples version 1 did:"
msgstr ""
"Теперь давайте посмотрим, как работает версия 2.\n"
"Мы используем список операторов, который включает в себя оператор \"спросить "
"у магазина их номер телефона\".\n"
"Сначала мы убедимся, что он все еще будет делать примеры, которые сделала "
"Версия 1:"

#: in/chapter4.md:803
msgid "`> (use *school-ops*)`=> `7`"
msgstr ""

#: in/chapter4.md:815
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"      '(son-at-school))\n"
"((START)\n"
"  (EXECUTING LOOK-UP-NUMBER)\n"
"  (EXECUTING TELEPHONE-SHOP)\n"
"  (EXECUTING TELL-SHOP-PROBLEM)\n"
"  (EXECUTING GIVE-SHOP-MONEY)\n"
"  (EXECUTING SHOP-INSTALLS-BATTERY)\n"
"  (EXECUTING DRIVE-SON-TO-SCHOOL))\n"
"```"
msgstr ""

#: in/chapter4.md:817
msgctxt "in/chapter4.md:817"
msgid "`> (debug :gps)`=> `(:GPS)`"
msgstr ""

#: in/chapter4.md:853
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"      '(son-at-school))\n"
"Goal: SON-AT-SCHOOL\n"
"Consider: DRIVE-SON-TO-SCHOOL\n"
"  Goal: SON-AT-HOME\n"
"  Goal: CAR-WORKS\n"
"  Consider: SHOP-INSTALLS-BATTERY\n"
"    Goal: CAR-NEEDS-BATTERY\n"
"    Goal: SHOP-KNOWS-PROBLEM\n"
"    Consider: TELL-SHOP-PROBLEM\n"
"      Goal: IN-COMMUNICATION-WITH-SHOP\n"
"      Consider: TELEPHONE-SHOP\n"
"        Goal: KNOW-PHONE-NUMBER\n"
"        Consider: ASK-PHONE-NUMBER\n"
"          Goal: IN-COMMUNICATION-WITH-SHOP\n"
"        Consider: LOOK-UP-NUMBER\n"
"          Goal: HAVE-PHONE-BOOK\n"
"        Action: LOOK-UP-NUMBER\n"
"      Action: TELEPHONE-SHOP\n"
"    Action: TELL-SHOP-PROBLEM\n"
"    Goal: SHOP-HAS-MONEY\n"
"    Consider: GIVE-SHOP-MONEY\n"
"      Goal: HAVE-MONEY\n"
"    Action: GIVE-SHOP-MONEY\n"
"  Action: SHOP-INSTALLS-BATTERY\n"
"Action: DRIVE-SON-TO-SCHOOL\n"
"((START)\n"
"  (EXECUTING LOOK-UP-NUMBER)\n"
"  (EXECUTING TELEPHONE-SHOP)\n"
"  (EXECUTING TELL-SHOP-PROBLEM)\n"
"  (EXECUTING GIVE-SHOP-MONEY)\n"
"  (EXECUTING SHOP-INSTALLS-BATTERY)\n"
"  (EXECUTING DRIVE-SON-TO-SCHOOL))\n"
"```"
msgstr ""

#: in/chapter4.md:855
msgctxt "in/chapter4.md:855"
msgid "`> (undebug)`=> `NIL`"
msgstr ""

#: in/chapter4.md:862
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-works)\n"
"      '(son-at-school))\n"
"((START)\n"
"  (EXECUTING DRIVE-SON-TO-SCHOOL))\n"
"```"
msgstr ""

#: in/chapter4.md:865
msgid ""
"Now we see that version 2 can also handle the three cases that version 1 got "
"wrong.\n"
"In each case, the program avoids an infinite loop, and also avoids leaping "
"before it looks."
msgstr ""
"Теперь мы видим, что версия 2 также может справиться с тремя случаями, в "
"которых Версия 1 ошиблась.\n"
"В каждом случае программа избегает бесконечного цикла, а также избегает "
"прыгать до того, как он посмотреть, нет ли какой опасности."

#: in/chapter4.md:877
msgid ""
"```lisp\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"      '(have-money son-at-school))\n"
"NIL\n"
"> (gps '(son-at-home car-needs-battery have-money have-phone-book)\n"
"      '(son-at-school have-money))\n"
"NIL\n"
"(gps '(son-at-home car-needs-battery have-money)\n"
"      '(son-at-school) )\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter4.md:879
msgid ""
"Finally, we see that this version of GPS also works on trivial problems "
"requiring no action:"
msgstr ""
"Наконец, мы видим, что эта версия GPS также работает над тривиальными "
"проблемами, не требующими никаких действий:"

#: in/chapter4.md:881
msgid "`> (gps '(son-at-home) '(son-at-home))`=> `((START))`"
msgstr ""

#: in/chapter4.md:883
msgid "## 4.12 The New Domain Problem: Monkey and Bananas"
msgstr "## 4.12 новая пробленая область(проблемный домен): обезьяна и бананы"

#: in/chapter4.md:889
msgid ""
"To show that GPS is at all general, we have to make it work in different "
"domains.\n"
"We will start with a \"classic\" AI problem.[3](#fn0020) Imagine the "
"following scenario: a hungry monkey is standing at the doorway to a room.\n"
"In the middle of the room is a bunch of bananas suspended from the ceiling "
"by a rope, well out of the monkey's reach.\n"
"There is a chair near the door, which is light enough for the monkey to push "
"and tall enough to reach almost to the bananas.\n"
"Just to make things complicated, assume the monkey is holding a toy ball and "
"can only hold one thing at a time."
msgstr ""
"Чтобы показать, что GPS действительно является общим, мы должны заставить "
"его работать в разных областях.\n"
"Начнем с \"классической\" задачи ИИ.[3](#fn0020) Представьте себе следующий "
"сценарий: голодная обезьяна стоит в дверях комнаты.\n"
"В центре комнаты на веревке с потолка свисает гроздь бананов, до которых "
"обезьяне не дотянуться.\n"
"У двери стоит стул, достаточно легкий, чтобы обезьяна могла толкать его, и "
"достаточно высокий, чтобы дотянуться почти до бананов.\n"
"Чтобы все усложнить, предположим, что обезьяна держит игрушечный мяч и может "
"держать только одну вещь одновременно."

#: in/chapter4.md:892
msgid ""
"In trying to represent this scenario, we have some flexibility in choosing "
"what to put in the current state and what to put in with the operators.\n"
"For now, assume we define the operators as follows:"
msgstr ""
"Пытаясь представить этот сценарий, мы имеем некоторую гибкость в выборе "
"того, что поместить в текущее состояние и что поместить с операторами.\n"
"Теперь предположим, что мы определяем операторы следующим образом:"

#: in/chapter4.md:927
msgid ""
"```lisp\n"
"(defparameter *banana-ops*\n"
"  (list\n"
"    (op\n"
"      'climb-on-chair\n"
"      :preconds '(chair-at-middle-room at-middle-room on-floor)\n"
"      :add-list '(at-bananas on-chair)\n"
"      :del-list '(at-middle-room on-floor))\n"
"    (op \n"
"      'push-chair-from-door-to-middle-room\n"
"      :preconds '(chair-at-door at-door)\n"
"      :add-list '(chair-at-middle-room at-middle-room)\n"
"      :del-list '(chair-at-door at-door))\n"
"    (op \n"
"      'walk-from-door-to-middle-room\n"
"      :preconds '(at-door on-floor)\n"
"      :add-list '(at-middle-room)\n"
"      :del-list '(at-door))\n"
"    (op \n"
"      'grasp-bananas\n"
"      :preconds '(at-bananas empty-handed)\n"
"      :add-list '(has-bananas)\n"
"      :del-list '(empty-handed))\n"
"    (op \n"
"      'drop-ball\n"
"      :preconds '(has-ball)\n"
"      :add-list '(empty-handed)\n"
"      :del-list '(has-ball))\n"
"    (op \n"
"      'eat-bananas\n"
"      :preconds '(has-bananas)\n"
"      :add-list '(empty-handed not-hungry)\n"
"      :del-list '(has-bananas hungry))))\n"
"```"
msgstr ""
"```lisp\n"
"(defparameter *banana-ops*\n"
"  (list\n"
"    (op\n"
"      'climb-on-chair       ;;забраться на стул\n"
"      :preconds '(chair-at-middle-room at-middle-room on-floor)\n"
"      :add-list '(at-bananas on-chair)\n"
"      :del-list '(at-middle-room on-floor))\n"
"    (op \n"
"      'push-chair-from-door-to-middle-room ;;толкать стул от двери к "
"середине комнаты\n"
"      :preconds '(chair-at-door at-door)\n"
"      :add-list '(chair-at-middle-room at-middle-room)\n"
"      :del-list '(chair-at-door at-door))\n"
"    (op \n"
"      'walk-from-door-to-middle-room ;;идти от двери к середине комнаты\n"
"      :preconds '(at-door on-floor)\n"
"      :add-list '(at-middle-room)\n"
"      :del-list '(at-door))\n"
"    (op \n"
"      'grasp-bananas   ;;схавтить банан\n"
"      :preconds '(at-bananas empty-handed)\n"
"      :add-list '(has-bananas)\n"
"      :del-list '(empty-handed))\n"
"    (op \n"
"      'drop-ball        ;; бросить мяч\n"
"      :preconds '(has-ball)\n"
"      :add-list '(empty-handed)\n"
"      :del-list '(has-ball))\n"
"    (op \n"
"      'eat-bananas      ;;съесть банан\n"
"      :preconds '(has-bananas)\n"
"      :add-list '(empty-handed not-hungry)\n"
"      :del-list '(has-bananas hungry))))\n"
"```"

#: in/chapter4.md:930
msgid ""
"Using these operators, we could pose the problem of becoming not-hungry, "
"given the initial state of being at the door, standing on the floor, holding "
"the ball, hungry, and with the chair at the door.\n"
"`GPS` can find a solution to this problem:"
msgstr ""
"Используя эти операторы, мы могли бы поставить задачу стать не-голодными(not-"
"hungry), учитывая начальное состояние нахождения у двери, стоя на полу, "
"держа мяч, голодные и со стулом у двери.\n"
"`GPS` может найти решение этой проблемы:"

#: in/chapter4.md:932
msgid "`> (use *banana-ops*)`=> `6`"
msgstr ""

#: in/chapter4.md:943
msgid ""
"```lisp\n"
"> (GPS '(at-door on-floor has-ball hungry chair-at-door)\n"
"      '(not-hungry))\n"
"((START)\n"
"  (EXECUTING PUSH-CHAIR-FROM-DOOR-TO-MIDDLE-ROOM)\n"
"  (EXECUTING CLIMB-ON-CHAIR)\n"
"  (EXECUTING DROP-BALL)\n"
"  (EXECUTING GRASP-BANANAS)\n"
"  (EXECUTING EAT-BANANAS))\n"
"```"
msgstr ""

#: in/chapter4.md:946
msgid ""
"Notice we did not need to make any changes at all to the `GPS` program.\n"
"We just used a different set of operators."
msgstr ""
"Обратите внимание, что нам не нужно было вносить какие-либо изменения в "
"программу `GPS`.\n"
"Мы просто использовали другой набор операторов."

#: in/chapter4.md:948
msgid "## 4.13 The Maze Searching Domain"
msgstr "## 4.13 Проблемная область(домен) Поиск в Лабиринте"

#: in/chapter4.md:951
msgid ""
"Now we will consider another \"classic\" problem, maze searching.\n"
"We will assume a particular maze, diagrammed here."
msgstr ""
"Теперь рассмотрим еще одну «классическую» проблему - поиск в лабиринте.\n"
"Предположим, что здесь изображен конкретный лабиринт.\n"

#: in/chapter4.md:953
msgid "![u04-01](images/chapter4/u04-01.jpg)"
msgstr ""

#: in/chapter4.md:956
msgid ""
"It is much easier to define some functions to help build the operators for "
"this domain than it would be to type in all the operators directly.\n"
"The following code defines a set of operators for mazes in general, and for "
"this maze in particular:"
msgstr ""
"Намного проще определить некоторые функции, помогающие создавать операторы "
"для этого домена, чем вводить все операторы напрямую.\n"
"Следующий код определяет набор операторов для лабиринтов в целом и для этого "
"лабиринта в частности:"

#: in/chapter4.md:975
msgid ""
"```lisp\n"
"(defun make-maze-ops (pair)\n"
"  \"Make maze ops in both directions\"\n"
"  (list (make-maze-op (first pair) (second pair))\n"
"      (make-maze-op (second pair) (first pair))))\n"
"(defun make-maze-op (here there)\n"
"  \"Make an operator to move between two places\"\n"
"  (op \n"
"    '(move from ,here to ,there)\n"
"    :preconds '((at ,here))\n"
"    :add-list '((at ,there))\n"
"    :del-list '((at ,here))))\n"
"(defparameter *maze-ops*\n"
"  (mappend #'make-maze-ops\n"
"    '((1 2) (2 3) (3 4) (4 9) (9 14) (9 8) (8 7) (7 12) (12 13)\n"
"      (12 11) (11 6) (11 16) (16 17) (17 22) (21 22) (22 23)\n"
"      (23 18) (23 24) (24 19) (19 20) (20 15) (15 10) (10 5) (20 25))))\n"
"```"
msgstr ""
"```lisp\n"
"(defun make-maze-ops (pair)\n"
"  \"Make maze ops in both directions\"\n"
"  (list (make-maze-op (first pair) (second pair))\n"
"      (make-maze-op (second pair) (first pair))))\n"
"(defun make-maze-op (here there)\n"
"  \"Make an operator to move between two places\"\n"
"  (op \n"
"    `(move from ,here to ,there)\n"
"    :preconds `((at ,here))\n"
"    :add-list `((at ,there))\n"
"    :del-list `((at ,here))))\n"
"(defparameter *maze-ops*\n"
"  (mappend #'make-maze-ops\n"
"    '((1 2) (2 3) (3 4) (4 9) (9 14) (9 8) (8 7) (7 12) (12 13)\n"
"      (12 11) (11 6) (11 16) (16 17) (17 22) (21 22) (22 23)\n"
"      (23 18) (23 24) (24 19) (19 20) (20 15) (15 10) (10 5) (20 25))))\n"
"```"

#: in/chapter4.md:978
msgid ""
"Note the backquote notation, ( ' ).\n"
"It is covered in [section 3.2](B9780080571157500030.xhtml#s0020), [page 67]"
"(B9780080571157500030.xhtml#p67)."
msgstr ""
"Обратите внимание на обозначение обратных кавычек ```( ` )```.\n"
"Она объясняется в [Разделе 3.2](B9780080571157500030.xhtml#s0020), [page 67]"
"(B9780080571157500030.xhtml#p67)."

#: in/chapter4.md:982
msgid ""
"We can now use this list of operators to solve several problems with this "
"maze.\n"
"And we could easily create another maze by giving another list of "
"connections.\n"
"Note that there is nothing that says the places in the maze are arranged in "
"a five-by-five layout-that is just one way of visualizing the connectivity"
msgstr ""
"Теперь мы можем использовать этот список операторов для решения нескольких "
"задач с этим лабиринтом.\n"
"И мы могли бы легко создать еще один лабиринт, предоставив еще один список "
"связей.\n"
"Обратите внимание, что нет ничего, что говорило бы о том, что места в "
"лабиринте расположены по схеме пять на пять - это всего лишь один из "
"способов визуализации связности."

#: in/chapter4.md:984
msgctxt "in/chapter4.md:984"
msgid "`> (use *maze-ops*)`=> `48`"
msgstr ""

#: in/chapter4.md:1006
msgid ""
"```lisp\n"
"> (gps '((at 1)) '((at 25)))\n"
"((START)\n"
"  (EXECUTING-(MOVE-FROM-1 TO 2))\n"
"  (EXECUTING-(MOVE-FROM-2 TO 3))\n"
"  (EXECUTING-(MOVE-FROM-3 TO 4))\n"
"  (EXECUTING-(MOVE-FROM-4 TO 9))\n"
"  (EXECUTING-(MOVE-FROM-9 TO 8))\n"
"  (EXECUTING-(MOVE-FROM-8 TO 7))\n"
"  (EXECUTING-(MOVE-FROM-7 TO 12))\n"
"  (EXECUTING-(MOVE-FROM-12 TO 11))\n"
"  (EXECUTING-(MOVE-FROM-11 TO 16))\n"
"  (EXECUTING-(MOVE-FROM-16 TO 17))\n"
"  (EXECUTING-(MOVE-FROM-17 TO 22))\n"
"  (EXECUTING-(MOVE-FROM-22 TO 23))\n"
"  (EXECUTING-(MOVE-FROM-23 TO 24))\n"
"  (EXECUTING-(MOVE-FROM-24 TO 19))\n"
"  (EXECUTING-(MOVE-FROM-19 TO 20))\n"
"  (EXECUTING-(MOVE-FROM-20 TO 25))\n"
"  (AT 25))\n"
"```"
msgstr ""

#: in/chapter4.md:1019
msgid ""
"There is one subtle bug that the maze domain points out.\n"
"We wanted GPS to return a list of the actions executed.\n"
"However, in order to account for the case where the goal can be achieved "
"with no action, I included `(START)` in the value returned by GPS.\n"
"These examples include the `START` and `EXECUTING` forms but also a list of "
"the form (AT *n*), for some *n*.\n"
"This is the bug.\n"
"If we go back and look at the function GPS, we find that it reports the "
"resuit by removing all atoms from the state returned by `achieve-all`.\n"
"This is a \"pun\"-we said remove atoms, when we really meant to remove all "
"conditions except the `(START)` and `(EXECUTING *action*)` forms.\n"
"Up to now, all these conditions were atoms, so this approach worked.\n"
"The maze domain introduced conditions of the form (`AT`*n*), so for the "
"first time there was a problem.\n"
"The moral is that when a programmer uses puns-saying what's convenient "
"instead of what's really happening-there's bound to be trouble.\n"
"What we really want to do is not to remove atoms but to find all elements "
"that denote actions.\n"
"The code below says what we mean:"
msgstr ""
"Есть одна тонкая ошибка, на которую указывает домен лабиринта.\n"
"Мы хотели, чтобы GPS возвращал список выполненных действий.\n"
"Однако, чтобы учесть случай, когда цель может быть достигнута без каких-либо "
"действий, я включил `(START)` в значение, возвращаемое GPS.\n"
"Эти примеры включают формы `START` и `EXECUTING`, а также список формы (AT "
"*n*) для некоторых *n*.\n"
"Это ошибка.\n"
"Если мы вернемся и посмотрим на функцию GPS, мы обнаружим, что она сообщает "
"о результатах, удаляя все атомы из состояния, возвращенного `achieve-all`.\n"
"Это «подмена понятий» - мы говорили об удалении атомов, когда на самом деле "
"намеревались удалить все условия, кроме форм `(START)` и `(EXECUTING "
"*action*)`.\n"
"До сих пор все эти условия были атомами, поэтому этот подход работал.\n"
"В области лабиринта введены условия вида (`AT` *n*), так что впервые "
"возникла проблема.\n"
"Мораль такова: когда программист использует подмены, говоря, что удобно, а "
"не то, что на самом деле происходит, неизбежно возникают проблемы.\n"
"На самом деле мы хотим не удалять атомы, а найти все элементы, обозначающие "
"действия.\n"
"Код ниже говорит о том, что мы имеем в виду:"

#: in/chapter4.md:1029
msgid ""
"```lisp\n"
"(defun GPS (state goals &optional (*ops* *ops*))\n"
"  \"General Problem Solver: from state, achieve goals using *ops*.\"\n"
"  (find-all-if #'action-p\n"
"        (achieve-all (cons '(start) state) goals nil)))\n"
"(defun action-p (x)\n"
"  \"Is x something that is (start) or (executing ...)?\"\n"
"  (or (equal x '(start)) (executing-p x)))\n"
"```"
msgstr ""

#: in/chapter4.md:1034
msgid ""
"The domain of maze solving also points out an advantage of version 2: that "
"it returns a representation of the actions taken rather than just printing "
"them out.\n"
"The reason this is an advantage is that we may want to use the results for "
"something, rather than just look at them.\n"
"Suppose we wanted a function that gives us a path through a maze as a list "
"of locations to visit in turn.\n"
"We could do this by calling GPS as a subfunction and then manipulating the "
"results:"
msgstr ""
"Домен решений лабиринтов также указывает на преимущество версии 2: она "
"возвращает представление о предпринятых действиях, а не просто распечатывает "
"их.\n"
"Причина, по которой это является преимуществом, заключается в том, что мы "
"можем захотеть использовать результаты для чего-то, а не просто смотреть на "
"них.\n"
"Предположим, нам нужна функция, которая дает нам путь через лабиринт в виде "
"списка мест, которые нужно посетить по очереди.\n"
"Мы могли бы сделать это, вызвав GPS в качестве подфункции, а затем "
"использовать результаты:"

#: in/chapter4.md:1047
msgid ""
"```lisp\n"
"(defun find-path (start end)\n"
"  \"Search a maze for a path from start to end.\"\n"
"  (let ((results (GPS '((at .start)) '((at .end)))))\n"
"    (unless (null results)\n"
"      (cons start (mapcar #'destination\n"
"              (remove '(start) results\n"
"                  :test #'equal))))))\n"
"(defun destination (action)\n"
"  \"Find the Y in (executing (move from X to Y))\"\n"
"  (fifth (second action)))\n"
"```"
msgstr ""
"```lisp\n"
"(defun find-path (start end)\n"
"  \"Search a maze for a path from start to end.\"\n"
"  (let ((results (GPS `((at ,start)) `((at ,end)))))\n"
"    (unless (null results)\n"
"      (cons start (mapcar #'destination\n"
"              (remove '(start) results\n"
"                  :test #'equal))))))\n"
"(defun destination (action)\n"
"  \"Find the Y in (executing (move from X to Y))\"\n"
"  (fifth (second action)))\n"
"```"

#: in/chapter4.md:1051
msgid ""
"The function `find-path` calls GPS to get the `results`.\n"
"If this is `nil`, there is no answer, but if it is not, then take the `rest` "
"of `results` (in other words, ignore the `(START)` part).\n"
"Pick out the destination, `*y*,` from each `(EXECUTING (MOVE FROM x TO y))` "
"form, and remember to include the starting point."
msgstr ""
"Функция `find-path` вызывает GPS для получения результатов - `results`.\n"
"Если это `nil`, ответа нет, а если есть, то возьмите «остаток» - `rest` от "
"`results` (другими словами, игнорируйте часть `(START)`).\n"
"Выберите пункт назначения, `*y*` из каждой формы `(EXECUTING (MOVE FROM x TO "
"y))` и не забудьте указать начальную точку."

#: in/chapter4.md:1053
msgctxt "in/chapter4.md:1053"
msgid "`> (use *maze-ops*)`=> `48`"
msgstr ""

#: in/chapter4.md:1055
msgid "`> (find-path 1 25)`=>"
msgstr ""

#: in/chapter4.md:1059
msgid ""
"```lisp\n"
"(1 2 3 4 9 8 7 12 11 16 17 22 23 24 19 20 25)\n"
"```"
msgstr ""

#: in/chapter4.md:1061
msgid "`> (find-path 1 1)`=> `(1)`"
msgstr ""

#: in/chapter4.md:1063
msgid "`> (equal (find-path 1 25) (reverse (find-path 25 1)))`=> `T`"
msgstr ""

#: in/chapter4.md:1065
msgid "## 4.14 The Blocks World Domain"
msgstr "## 4.14 Домен Мира Блоков(Blocks World)"

#: in/chapter4.md:1072
msgid ""
"Another domain that has attracted more than its share of attention in AI "
"circles is the blocks world domain.\n"
"Imagine a child's set of building blocks on a table top.\n"
"The problem is to move the blocks from their starting configuration into "
"some goal configuration.\n"
"We will assume that each block can have only one other block directly on top "
"of it, although they can be stacked to arbitrary height.\n"
"The only action that can be taken in this world is to move a single block "
"that has nothing on top of it either to the top of another block or onto the "
"table that represents the block world.\n"
"We will create an operator for each possible block move."
msgstr ""
"Еще одна область(домен), которая привлекает большое внимания в кругах ИИ, - "
"это мир блоков.\n"
"Представьте детский набор строительных блоков на столе.\n"
"Проблема состоит в том, чтобы переместить блоки из их начальной конфигурации "
"в некоторую целевую конфигурацию.\n"
"Мы предполагаем, что каждый блок может иметь только один другой блок "
"непосредственно поверх него, хотя они могут быть размещены на произвольной "
"высоте.\n"
"Единственное действие, которое можно предпринять в этом мире, - это "
"переместить отдельный блок, на котором ничего нет, либо наверх другого "
"блока, либо на стол, который представляет мир блоков.\n"
"Мы создадим операторы для каждого возможного перемещения блока."

#: in/chapter4.md:1097
msgid ""
"```lisp\n"
"(defun make-block-ops (blocks)\n"
"  (let ((ops nil))\n"
"    (dolist (a blocks)\n"
"      (dolist (b blocks)\n"
"        (unless (equal a b)\n"
"          (dolist (c blocks)\n"
"            (unless (or (equal c a) (equal c b))\n"
"              (push (move-op a b c) ops)))\n"
"          (push (move-op a 'table b) ops)\n"
"          (push (move-op a b 'table) ops))))\n"
"    ops))\n"
"(defun move-op (a b c)\n"
"  \"Make an operator to move A from B to C.\"\n"
"  (op \n"
"      '(move ,a from ,b to ,c)\n"
"      :preconds '((space on ,a) (space on ,c) (,a on ,b))\n"
"      :add-list (move-ons a b c)\n"
"      :del-list (move-ons a c b)))\n"
"(defun move-ons (a b c)\n"
"  (if (eq b 'table)\n"
"      '((,a on ,c))\n"
"      '((.a on ,c) (space on ,b))))\n"
"```"
msgstr ""

#: in/chapter4.md:1100
msgid ""
"Now we try these operators out on some problems.\n"
"The simplest possible problem is stacking one block on another:"
msgstr ""
"Теперь мы опробуем эти операторы на некоторых задачах.\n"
"Самая простая проблема - это положить однин блок на другой:\n"

#: in/chapter4.md:1102
msgid "![u04-02](images/chapter4/u04-02.jpg)"
msgstr ""

#: in/chapter4.md:1104
msgid "`> (use (make-block-ops '(a b)))`=> `4`"
msgstr ""

#: in/chapter4.md:1112
msgid ""
"```lisp\n"
"> (gps '((a on table) (b on table) (space on a) (space on b)\n"
"      (space on table))\n"
"    '((a on b) (b on table)))\n"
"((START)\n"
"  (EXECUTING (MOVE A FROM TABLE TO B)))\n"
"```"
msgstr ""

#: in/chapter4.md:1115
msgid ""
"Here is a slightly more complex problem: inverting a stack of two blocks.\n"
"This time we show the debugging output."
msgstr ""
"Вот немного более сложная проблема: инвертирование стопки из двух блоков.\n"
"На этот раз мы показываем результаты отладки.\n"

#: in/chapter4.md:1117
msgid "![u04-03](images/chapter4/u04-03.jpg)"
msgstr ""

#: in/chapter4.md:1119
msgctxt "in/chapter4.md:1119"
msgid "`> (debug :gps)`=> `(:GPS)`"
msgstr ""

#: in/chapter4.md:1138
msgid ""
"```lisp\n"
"> (gps '((a on b) (b on table) (space on a) (space on table))\n"
"      '((b on a)))\n"
"Goal: (B ON A)\n"
"Consider: (MOVE B FROM TABLE TO A)\n"
"  Goal: (SPACE ON B)\n"
"  Consider: (MOVE A FROM B TO TABLE)\n"
"    Goal: (SPACE ON A)\n"
"    Goal: (SPACE ON TABLE)\n"
"    Goal: (A ON B)\n"
"  Action: (MOVE A FROM B TO TABLE)\n"
"  Goal: (SPACE ON A)\n"
"  Goal: (B ON TABLE)\n"
"Action: (MOVE B FROM TABLE TO A)\n"
"((START)\n"
"  (EXECUTING (MOVE A FROM B TO TABLE))\n"
"  (EXECUTING (MOVE B FROM TABLE TO A)))\n"
"```"
msgstr ""

#: in/chapter4.md:1140
msgctxt "in/chapter4.md:1140"
msgid "`> (undebug)`=> `NIL`"
msgstr ""

#: in/chapter4.md:1144
msgid ""
"Sometimes it matters what order you try the conjuncts in.\n"
"For example, you can't have your cake and eat it too, but you can take a "
"picture of your cake and eat it too, as long as you take the picture "
"*before* eating it.\n"
"In the blocks world, we have:"
msgstr ""
"Иногда имеет значение, в каком порядке вы пробуете конъюнкты.\n"
"Например, вы не можете взять свой торт и съесть его, но вы можете "
"сфотографировать свой торт и тоже съесть его, если вы сделаете снимок "
"*перед* его поеданием.\n"
"В мире блоков у нас есть:"

#: in/chapter4.md:1146
msgid "![u04-04](images/chapter4/u04-04.jpg)"
msgstr ""

#: in/chapter4.md:1159
msgid ""
"```lisp\n"
"> (use (make-block-ops '(a b c))) 18\n"
"> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))\n"
"      '((b on a) (c on b)))\n"
"((START)\n"
"  (EXECUTING (MOVE A FROM B TO TABLE))\n"
"  (EXECUTING (MOVE B FROM C TO A))\n"
"  (EXECUTING (MOVE C FROM TABLE TO B)))\n"
"> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))\n"
"      '((c on b) (b on a)))\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter4.md:1165
msgid ""
"In the first case, the tower was built by putting B on A first, and then C "
"on B.\n"
"In the second case, the program gets C on B first, but clobbers that goal "
"while getting B on A.\n"
"The \"prerequisite clobbers sibling goal\" situation is recognized, but the "
"program doesn't do anything about it.\n"
"One thing we could do is try to vary the order of the conjunct goals.\n"
"That is, we could change `achieve-all` as follows:"
msgstr ""
"В первом случае башня была построена путем установки сначала B на A, а затем "
"C на B.\n"
"Во втором случае программа сначала получает башню с C на B, но портит эту "
"цель, получая башню с B на A.\n"
"Видим ситуацию \"предпосылки порчи родственной цели\", но программа ничего с "
"этим не делает.\n"
"Единственное, что мы могли бы сделать, - это попытаться изменить порядок "
"конъюнктивных целей.\n"
"То есть мы могли бы изменить `achieve-all` следующим образом:"

#: in/chapter4.md:1171
msgid ""
"```lisp\n"
"(defun achieve-all (state goals goal-stack)\n"
"  \"Achieve each goal, trying several orderings.\"\n"
"  (some #'(lambda (goals) (achieve-each state goals goal-stack))\n"
"      (orderings goals)))"
msgstr ""

#: in/chapter4.md:1181
msgid ""
"(defun achieve-each (state goals goal-stack)\n"
"  \"Achieve each goal, and make sure they still hold at the end.\"\n"
"  (let ((current-state state))\n"
"    (if (and (every #'(lambda (g)\n"
"            (setf current-state\n"
"              (achieve current-state g goal-stack)))\n"
"          goals)\n"
"        (subsetp goals current-state :test #'equal))\n"
"      current-state)))"
msgstr ""

#: in/chapter4.md:1187
msgid ""
"(defun orderings (l)\n"
"  (if (> (length l) l)\n"
"      (list l (reverse l))\n"
"      (list l)))\n"
"```"
msgstr ""
"(defun orderings (l)\n"
"  (if (> (length l) 1)\n"
"      (list l (reverse l))\n"
"      (list l)))\n"
"```"

#: in/chapter4.md:1194
msgid ""
"Now we can represent the goal either way, and we'll still get an answer.\n"
"Notice that we only consider two orderings: the order given and the reversed "
"order.\n"
"Obviously, for goal sets of one or two conjuncts this is all the orderings.\n"
"In general, if there is only one interaction per goal set, then one of these "
"two orders will work.\n"
"Thus, we are assuming that \"prerequisite clobbers sibling goal\" "
"interactions are rare, and that there will seldom be more than one "
"interaction per goal set.\n"
"Another possibility would be to consider all possible permutations of the "
"goals, but that could take a long time with large goal sets."
msgstr ""
"Теперь мы можем представить цель в любом виде, и мы все равно получим "
"ответ.\n"
"Заметьте, что мы рассматриваем только два порядка: данный порядок и обратный "
"порядок.\n"
"Очевидно, что для множества целей из одного или двух конъюнктов это все "
"упорядочения.\n"
"В общем, если есть только одно взаимодействие в множестве целей, то один из "
"этих двух порядков будет работать.\n"
"Таким образом, мы исходим из того, что взаимодействия \"предпосылки "
"разрушающие родственную цель\" редки, и что редко будет больше одного "
"взаимодействия на множестве целей.\n"
"Другой возможностью было бы рассмотреть все возможные перестановки целей, но "
"это может занять много времени при большом множестве целей."

#: in/chapter4.md:1197
msgid ""
"Another consideration is the efficiency of solutions.\n"
"Consider the simple task of getting block C on the table in the following "
"diagram:"
msgstr ""
"Еще одним соображением является эффективность решений.\n"
"Рассмотрим простую задачу получения блока С на столе на следующей диаграмме:"

#: in/chapter4.md:1199
msgid "![u04-05](images/chapter4/u04-05.jpg)"
msgstr ""

#: in/chapter4.md:1208
msgid ""
"```lisp\n"
"> (gps '((c on a) (a on table) (b on table)\n"
"      (space on c) (space on b) (space on table))\n"
"    '((c on table)))\n"
"((START)\n"
"  (EXECUTING (MOVE C FROM A TO B))\n"
"  (EXECUTING (MOVE C FROM B TO TABLE)))\n"
"```"
msgstr ""

#: in/chapter4.md:1214
msgid ""
"The solution is correct, but there is an easier solution that moves C "
"directly to the table.\n"
"The simpler solution was not found because of an accident: it happens that "
"`make-block-ops` defines the operators so that moving C from B to the table "
"comes before moving C from A to the table.\n"
"So the first operator is tried, and it succeeds provided C is on B.\n"
"Thus, the two-step solution is found before the one-step solution is ever "
"considered.\n"
"The following example takes four steps when it could be done in two:"
msgstr ""
"Решение правильное, но есть более простое решение, которое перемещает C "
"непосредственно на стол.\n"
"Более простое решение не было найдено из-за неудачного случая: случается, "
"что `make-block-ops` определяет операторы так, что перемещение C с B на стол "
"происходит раньше, чем перемещение C с A на стол.\n"
"Итак, первый оператор опробован, и он успешен при условии, что C находится "
"на B.\n"
"Таким образом, двухэтапное решение найдено до того, как будет рассмотрено "
"одноэтапное решение.\n"
"В следующем примере выполняется четыре шага, когда это можно было бы сделать "
"за два:"

#: in/chapter4.md:1216
msgid "![u04-06](images/chapter4/u04-06.jpg)"
msgstr ""

#: in/chapter4.md:1227
msgid ""
"```lisp\n"
"> (gps '((c on a) (a on table) (b on table)\n"
"      (space on c) (space on b) (space on table))\n"
"    '((c on table) (a on b)))\n"
"((START)\n"
"  (EXECUTING (MOVE C FROM A TO B))\n"
"  (EXECUTING (MOVE C FROM B TO TABLE))\n"
"  (EXECUTING (MOVE A FROM TABLE TO C))\n"
"  (EXECUTING (MOVE A FROM C TO B)))\n"
"```"
msgstr ""

#: in/chapter4.md:1234
msgid ""
"How could we find shorter solutions?\n"
"One way would be to do a full-fledged search: shorter solutions are tried "
"first, temporarily abandoned when something else looks more promising, and "
"then reconsidered later on.\n"
"This approach is taken up in [chapter 6](B9780080571157500066.xhtml), using "
"a general searching function.\n"
"A less drastic solution is to do a limited rearrangement of the order in "
"which operators are searched: the ones with fewer unfulfilled preconditions "
"are tried first.\n"
"In particular, this means that operators with all preconditions filled would "
"always be tried before other operators.\n"
"To implement this approach, we change `achieve`:"
msgstr ""
"Как мы можем найти более короткие решения?\n"
"Одним из способов было бы провести полноценный поиск: сначала пробуются "
"более короткие решения, временно забрасываются, когда что-то другое выглядит "
"более перспективным, а затем пересматриваются позже.\n"
"Этот подход рассматривается в [главе 6](B9780080571157500066.xhtml), "
"используя общую функцию поиска.\n"
"Менее радикальное решение состоит в том, чтобы сделать ограниченную "
"перестановку порядка, в котором ищутся операторы: сначала пробуются те, у "
"которых меньше невыполненных предварительных условий.\n"
"В частности, это означает, что операторы со всеми заполненными "
"предварительными условиями всегда будут опробованы раньше других "
"операторов.\n"
"Чтобы реализовать этот подход, мы изменим `achieve`:"

#: in/chapter4.md:1244
msgid ""
"```lisp\n"
"(defun achieve (state goal goal-stack)\n"
"  \"A goal is achieved if it already holds,\n"
"  or if there is an appropriate op for it that is applicable.\"\n"
"  (dbg-indent :gps (length goal-stack) \"Goal:~a\" goal)\n"
"  (cond ((member-equal goal state) state)\n"
"      ((member-equal goal goal-stack) nil)\n"
"      (t (some #'(lambda (op) (apply-op state goal op goal-stack))\n"
"          (appropriate-ops goal state))))) ;***"
msgstr ""

#: in/chapter4.md:1254
msgid ""
"(defun appropriate-ops (goal state)\n"
"  \"Return a list of appropriate operators,\n"
"  sorted by the number of unfulfilled preconditions.\"\n"
"  (sort (copy-list (find-all goal *ops* :test #'appropriate-p)) #'<\n"
"      :key #'(lambda (op)\n"
"          (count-if #'(lambda (precond)\n"
"              (not (member-equal precond state)))\n"
"            (op-preconds op)))))\n"
"```"
msgstr ""

#: in/chapter4.md:1256
msgid "Now we get the solutions we wanted:"
msgstr "Теперь мы получаем решения, которые хотели:"

#: in/chapter4.md:1258
msgid "![u04-07](images/chapter4/u04-07.jpg)"
msgstr ""

#: in/chapter4.md:1267
msgid ""
"```lisp\n"
"> (gps '((c on a) (a on table) (b on table)\n"
"      (space on c) (space on b) (space on table))\n"
"    '((c on table) (a on b)))\n"
"((START)\n"
"  (EXECUTING (MOVE C FROM A TO TABLE))\n"
"  (EXECUTING (MOVE A FROM TABLE TO B)))\n"
"```"
msgstr ""

#: in/chapter4.md:1269
msgid "![u04-08](images/chapter4/u04-08.jpg)"
msgstr ""

#: in/chapter4.md:1284
msgid ""
"```lisp\n"
"(gps '((a on b) (b on c) (c on table) (space on a) (space on table))\n"
"      '((b on a) (c on b)))\n"
"((START)\n"
"  (EXECUTING (MOVE A FROM B TO TABLE))\n"
"  (EXECUTING (MOVE B FROM C TO A))\n"
"  (EXECUTING (MOVE C FROM TABLE TO B)))\n"
"> (gps '((a on b) (b on c) (c on table) (space on a) (space on table))\n"
"      '((c on b) (b on a)))\n"
"((START)\n"
"  (EXECUTING (MOVE A FROM B TO TABLE))\n"
"  (EXECUTING (MOVE B FROM C TO A))\n"
"  (EXECUTING (MOVE C FROM TABLE TO B)))\n"
"```"
msgstr ""

#: in/chapter4.md:1286
msgid "### The Sussman Anomaly"
msgstr "### Аномалия Сассмана"

#: in/chapter4.md:1289
msgid ""
"Surprisingly, there are problems that can't be solved by *any* reordering of "
"goals.\n"
"Consider:"
msgstr ""
"Удивительно, но есть проблемы, которые не могут быть решены путем "
"*произвольного* переупорядочения целей.\n"
"Рассмотрим:"

#: in/chapter4.md:1291
msgid "![u04-09](images/chapter4/u04-09.jpg)"
msgstr ""

#: in/chapter4.md:1293
msgid "This doesn't look too hard, so let's see how our GPS handles it:"
msgstr ""
"Это выглядит не слишком сложно, так что давайте посмотрим, как наш GPS "
"справляется с этим:"

#: in/chapter4.md:1300
msgid ""
"```lisp\n"
"> (setf start '((c on a) (a on table) (b on table) (space on c)\n"
"        (space on b) (space on table)))\n"
"((C ON A) (A ON TABLE) (B ON TABLE) (SPACE ON C)\n"
"  (SPACE ON B) (SPACE ON TABLE))\n"
"```"
msgstr ""

#: in/chapter4.md:1302
msgid "`> (gps start '((a on b) (b on c)))`=> `NIL`"
msgstr ""

#: in/chapter4.md:1304
msgid "`> (gps start '((b on c) (a on b)))`=> `NIL`"
msgstr ""

#: in/chapter4.md:1308
msgid ""
"There is a \"prerequisite clobbers sibling goal\" problem regardless of "
"which way we order the conjuncts!\n"
"In other words, no combination of plans for the two individual goals can "
"solve the conjunction of the two goals.\n"
"This is a surprising fact, and the example has come to be known as \"the "
"Sussman anomaly.\"[4](#fn0025) We will return to this problem in [chapter 6]"
"(B9780080571157500066.xhtml)."
msgstr ""
"Существует проблема \"предпосылки повреждающей родственную цель\" независимо "
"от того, каким образом мы упорядочиваем конъюнкты!\n"
"Другими словами, никакая комбинация планов для двух индивидуальных целей не "
"может решить проблему соединения этих двух целей.\n"
"Это удивительный факт, и этот пример стал известен как \"аномалия Сассмана\"."
"[4] (#fn0025) мы вернемся к этой проблеме в [главе 6](B9780080571157500066."
"xhtml)."

#: in/chapter4.md:1310
msgid "## 4.15 Stage 5 Repeated: Analysis of Version 2"
msgstr "## 4.15 Этап 5 Повторяем: Анализ версии 2"

#: in/chapter4.md:1316
msgid ""
"We have shown that GPS is extensible to multiple domains.\n"
"The main point is that we didn't need to change the program itself to get "
"the new domains to work; we just changed the list of operators passed to "
"GPS.\n"
"Experience in different domains did suggest changes that could be made, and "
"we showed how to incorporate a few changes.\n"
"Although version 2 is a big improvement over version 1, it still leaves much "
"to be desired.\n"
"Now we will discover a few of the most troubling problems."
msgstr ""
"Мы показали, что GPS можно расширять на несколько доменовis extensible to "
"multiple domains.\n"
"Главное, что нам не нужно было менять саму программу, чтобы новые домены "
"заработали; мы просто изменили список операторов, переданных в GPS.\n"
"Опыт в различных доменах подсказал, какие изменения можно внести, и мы "
"показали, как внести некоторые изменения.\n"
"ХОтя версия 2 является большим улучшением по сравнению с версией 1, она по "
"прежнему оставляет желать лучшего.\n"
"Теперь мы можем обнаружить несколько наиболее тревожных проблем."

#: in/chapter4.md:1318
msgid "## 4.16 The Not Looking after You Don't Leap Problem"
msgstr "## 4.16 отсутствие присмотра за вами не является проблемой прыжка"

#: in/chapter4.md:1321
msgid ""
"We solved the \"leaping before you look\" problem by introducing variables "
"to hold a representation of possible future states, rather than just a "
"single variable representing the current state.\n"
"This prevents GPS from taking an ill-advised action, but we shall see that "
"even with all the repair strategies introduced in the last section, it "
"doesn't guarantee that a solution will be found whenever one is possible."
msgstr ""
"Мы решили проблему \"прыжка, прежде чем посмотреть, безопасен ли он\", введя "
"переменные для хранения представления возможных будущих состояний, а не "
"только одну переменную, представляющую текущее состояние.\n"
"Это не позволяет GPS предпринять опрометчивые действия, но мы увидим, что "
"даже со всеми стратегиями восстановления, представленными в последнем "
"разделе, это не гарантирует, что решение будет найдено всякий раз, когда оно "
"возможно."

#: in/chapter4.md:1323
msgid ""
"To see the problem, add another operator to the front of the `*school-ops*` "
"list and turn the debugging output back on:"
msgstr ""
"Чтобы увидеть проблему, добавьте еще один оператор в начало списка `*school-"
"ops*` и снова включите вывод отладочной информации:"

#: in/chapter4.md:1332
msgid ""
"```lisp\n"
"(use (push (op 'taxi-son-to-school\n"
"        :preconds '(son-at-home have-money)\n"
"        :add-list '(son-at-school)\n"
"        :del-list '(son-at-home have-money))\n"
"      *school-ops*))\n"
"(debug :gps)\n"
"```"
msgstr ""

#: in/chapter4.md:1334
msgid ""
"Now, consider the problem of getting the child to school without using any "
"money:"
msgstr ""
"Теперь рассмотрим проблему получения ситуации: ребенок в школе без "
"использования денег:"

#: in/chapter4.md:1352
msgid ""
"```lisp\n"
"> (gps '(son-at-home have-money car-works)\n"
"      '(son-at-school have-money))\n"
"Goal: SON-AT-SCHOOL\n"
"Consider: TAXI-SON-TO-SCHOOL\n"
"  Goal: SON-AT-HOME\n"
"  Goal: HAVE-MONEY\n"
"Action: TAXI-SON-TO-SCHOOL\n"
"Goal: HAVE-MONEY\n"
"Goal: HAVE-MONEY\n"
"Goal: SON-AT-SCHOOL\n"
"Consider: TAXI-SON-TO-SCHOOL\n"
"  Goal: SON-AT-HOME\n"
"  Goal: HAVE-MONEY\n"
"Action: TAXI-SON-TO-SCHOOL\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter4.md:1360
msgid ""
"The first five lines of output successfully solve the `son-at-school` goal "
"with the `TAXI-SON-TO-SCHOOL` action.\n"
"The next line shows an unsuccessful attempt to solve the `have-money` goal.\n"
"The next step is to try the other ordering.\n"
"This time, the `have-money` goal is tried first, and succeeds.\n"
"Then, the `son-at-school` goal is achieved again by the `TAXI-SON-TO-SCHOOL` "
"action.\n"
"But the check for consistency in `achieve-each` fails, and there are no "
"repairs available.\n"
"The goal fails, even though there is a valid solution: driving to school."
msgstr ""
"Первые пять строк выходных данных успепшно решают проблему: сын в школе - "
"`son-at-school` с помщью действия `TAXI-SON-TO-SCHOOL`.\n"
"Следующая строка показывает безуспешную попытку достичь цели: иметь деньги - "
"`have-money`.\n"
"Следующий шаг - попробовать в другом порядке.\n"
"На этот раз сначала делается попытка получить деньги, она оказывается "
"успешной.\n"
"Затем, цель `son-at-school` снова достигается благодаря действию `TAXI-SON-"
"TO-SCHOOL`.\n"
"Но проверка на согласованность в  `achieve-each`   не удается, и в этом "
"месте исправление не доступно.\n"
"Цель не достигется, хотя есть верное решине: отвезти ребенка в школу."

#: in/chapter4.md:1368
msgid ""
"The problem is that `achieve` uses `some` to look at the `appropriate-ops`.\n"
"Thus, if there is some appropriate operator, `achieve` succeeds.\n"
"If there is only one goal, this will yield a correct solution.\n"
"However, if there are multiple goals, as in this case, achieve will still "
"only find one way to fulfil the first goal.\n"
"If the first solution is a bad one, the only recourse is to try to repair "
"it.\n"
"In domains like the block world and maze world, repair often works, because "
"all steps are reversible.\n"
"But in the taxi example, no amount of plan repair can get the money back "
"once it is spent, so the whole plan fails."
msgstr ""
"Проблема в том, что   `achieve`   использует  `some`  для просмотра(поиска) "
"применимых операторов - `appropriate-ops`.\n"
"Таким образом, если есть какой-то подходящий оператор, `achieve` завершится "
"успешно.\n"
"Если есть только одна цель, это даст правильное решение.\n"
"Однако, если есть несколько подцелей, как в этом случае, achieve все равно "
"найдет только один способ достич первой цели.\n"
"Если первое решение плохое, единственный выход - попытаться его исправить.\n"
"В таких областях(доменах), как мир блоков и мир лабиринтов, исправление "
"часто работает, потому что все шаги обратимы.\n"
"Но в примере с такси никакое исправление плана не может вернуть деньги после "
"того, как они были потрачены, поэтому весь план терпит неудачу."

#: in/chapter4.md:1378
msgid ""
"There are two ways around this problem.\n"
"The first approach is to examine all possible solutions, not just the first "
"solution that achieves each subgoal.\n"
"The language Prolog, to be discussed in [chapter 11](B978008057115750011X."
"xhtml), does just that.\n"
"The second approach is to have achieve and `achieve-all` keep track of a "
"list of goals that must be *protected*.\n"
"In the taxi example, we would trivially achieve the `have-money` goal and "
"then try to achieve `son-at-school`, while protecting the goal `have-"
"money`.\n"
"An operator would only be appropriate if it didn't delete any protected "
"goals.\n"
"This approach still requires some kind of repair or search through multiple "
"solution paths.\n"
"If we tried only one ordering-achieving `son-at-school` and then trying to "
"protect it while achieving `have-money`-then we would not find the "
"solution.\n"
"David Warren's WARPLAN planner makes good use of the idea of protected goals."
msgstr ""
"Есть два пути обойти эту проблему.\n"
"Первый подход - изучить все возможные решения, а не только первое решение, "
"которое позволяет достичь каждой подцели.\n"
"Язык Prolog, который будет обсуждаться в [chapter 11](B978008057115750011X."
"xhtml), именно этим и занимается.\n"
"Второй подход состоит в том, чтобы achieve и `achieve-all` отслеживали "
"список целей, которые необходимо *защищать/protected*.\n"
"В примере с такси мы бы тривиально достигли цели `have-money`, а затем "
"попытались бы достичь цели `son-at-school`, защищая цель `have-money`.\n"
"Оператор будет уместен только в том случае, если он не удаляет никаких "
"защищенных целей.\n"
"Этот подход по прежнему требует какого то исправления или поиска по "
"нескольким путям решения.\n"
"Если бы мы попробовали только один порядок - достигающий `son-at-school`, а "
"затем попытались бы защитить его, достигая при этом `have-money`- то мы бы "
"не нашли решения.\n"
"Планировщик  WARPLAN Дэвида Уоррена хорошо использует идею защищенных целей."

#: in/chapter4.md:1380
msgid "## 4.17 The Lack of Descriptive Power Problem"
msgstr "## 4.17 проблема отсутствия описательной мощности"

#: in/chapter4.md:1384
msgid ""
"It would be a lot more economical, in the maze domain, to have one operator "
"that says we can move from here to there if we are at \"here,\" and if there "
"is a connection from \"here\" to \"there.\" Then the input to a particular "
"problem could list the valid connections, and we could solve any maze with "
"this single operator.\n"
"Similarly, we have defined an operator where the monkey pushes the chair "
"from the door to the middle of the room, but it would be better to have an "
"operator where the monkey can push the chair from wherever it is to any "
"other nearby location, or better yet, an operator to push any \"pushable\" "
"object from one location to a nearby one, as long as there is no intervening "
"obstacle.\n"
"The conclusion is that we would like to have variables in the operators, so "
"we could say something like:"
msgstr ""
"В домене лабиринтов было бы намного экономичнее иметь один оператор, который "
"говорил бы, что мы можем перемещаться отсюда/here туда/there, если мы "
"находимся \"здесь/here\" и если существует связь \"отсюда/here\" к \"туда/"
"there\". Затем входные данные для конкретной задачи могут содержать список "
"допустимых соединений и мы могли бы решить любой лабиринт с помощью этого "
"единственного оператора.\n"
"Точно так же мы определили оператор, в котором обезьяна толкает стул от "
"двери к середине комнаты, но было бы лучше иметь оператор, с помощью "
"которого обезьяна могла бы толкать стул из любого места в любое другое "
"близлежащее место, или еще лучше - оператор которые толкает любой \"толкаемый"
"\" объект из одного места в соседнее, если нет никаких препятствий.\n"
"Вывод таков: мы хотели бы иметь переменные в операторах, чтобы можно было "
"сказать что-то вроде:"

#: in/chapter4.md:1392
msgid ""
"```lisp\n"
"(op \n"
"  '(push X from A to B)\n"
"  :preconds '((monkey at A) (X at A) (pushable X) (path A B))\n"
"  :add-list '((monkey at B) (X at B))\n"
"  :del-list '((monkey at A) (X at A)))\n"
"```"
msgstr ""

#: in/chapter4.md:1396
msgid ""
"Often we want to characterize a state in terms of something more abstract "
"than a list of conditions.\n"
"For example, in solving a chess problem, the goal is to have the opponent in "
"checkmate, a situation that cannot be economically described in terms of "
"primitives like `(black king on A 4)`, so we need to be able to state some "
"kind of constraint on the goal state, rather than just listing its "
"components.\n"
"We might want to be able to achieve a disjunction or negation of conditions, "
"where the current formalism allows only a conjunction."
msgstr ""
"Часто мы хотим охарактеризовать состояния в терминах чего-то более "
"абстрактного, чем список условий.\n"
"Например, при решении шахматной задачи цель состоит в том, чтобы поставить "
"опоненту мат, ситуацию которую нельзя экономно описать в терминах таких "
"примитивов, как `(black king on A 4)`, поэтому мы должны иметь возможность "
"сформулировать какой-то вид ограничений на состояние цели, а не просто "
"перечисления её компонентов.\n"
"Мы могли бы захотеть достичь дизъюнкции(ИЛИ) или отритцания условий, тогда "
"как текущий формализм допускает только коньюнкцию(И)."

#: in/chapter4.md:1399
msgid ""
"It also is important, in many domains, to be able to state problems dealing "
"with time: we want to achieve *X* before time *T*0, and then achieve *Y* "
"before time *T*2, but not before *T*1.\n"
"Scheduling work on a factory floor or building a house are examples of "
"planning where time plays an important role."
msgstr ""
"Во многих областях(доменах) также важно уметь формулировать проблемы, "
"связанные со временем: мы хотим достичь *X* до наступления времени *T0*, и "
"затем достичь *Y* до наступления времени *T2*, но не раньше *T1*.\n"
"Планирование работы в производственном цехе или строительство дома - примеры "
"планирования, в котором время играет важную роль."

#: in/chapter4.md:1404
msgid ""
"Often there are costs associated with actions, and we want to find a "
"solution with minimal, or near-minimal costs.\n"
"The cost might be as simple as the number of operators required for a "
"solution-we saw in the blocks world domain that sometimes an operator that "
"could be applied immediately was ignored, and an operator that needed "
"several preconditions satisfied was chosen instead.\n"
"Or we may be satisfied with a partial solution, if a complete solution is "
"impossible or too expensive.\n"
"We may also want to take the cost (and time) of computation into account."
msgstr ""
"Часто действия связаны с расходами и мы хотим найти решение с минимальными "
"или почти минимальными затратами.\n"
"Стоимость может быть такой же простой, как количество операторов, "
"необходимых для решения - мы видели в домене мира блоков, что иногда "
"оператор, который можно было применить немедленно, игнорировался, и вместо "
"него выбирался оператор, которому требовалолсь выполнение нескольких "
"предварительных условий.\n"
"Или нас могло бы удовлетворить частичное решение, если полное решение "
"невозможно или слишком дорого. \n"
"Мы также можем принимать во внимание стоимость (или время) вычислений."

#: in/chapter4.md:1406
msgid "## 4.18 The Perfect Information Problem"
msgstr "## 4.18 Идеальная Информационная Проблема"

#: in/chapter4.md:1414
msgid ""
"All the operators we have seen so far have unambiguous results; they add or "
"delete certain things from the current state, and GPS always knows exactly "
"what they are going to do.\n"
"In the real world, things are rarely so cut and dried.\n"
"Going back to the problem of becoming rich, one relevant operator would be "
"playing the lottery.\n"
"This operator has the effect of consuming a few dollars, and once in a while "
"paying off a large sum.\n"
"But we have no way to represent a payoff \"once in a while.\" Similarly, we "
"have no way to represent unexpected difficulties of any kind.\n"
"In the nursery school problem, we could represent the problem with the car "
"battery by having GPS explicitly check to see if the car was working, or if "
"it needed a battery, every time the program considered the driving "
"operator.\n"
"In the real world, we are seldom this careful; we get in the car, and only "
"when it doesn't start do we consider the possibility of a dead battery."
msgstr ""
"Все опереторы, которые мы видели до сих пор, дают однозначные результаты; "
"они добавляют или удаляют определенные вещи из текущего состояния и  GPS "
"всегда точно знает, что с ними делать.\n"
"В реальном мире, вещи редко бывают такими простыми.\n"
"Возвращаясь к проблеме обогащения, можно сказать, что в лотерею играет один "
"соответствующий оператор.\n"
"Этот оператор использует несколько долларов и время от времени выплачивает "
"крупную сумму.\n"
"Но у нас нет способа представить выигрыш \"только от времени\". Точно так же "
"у нас нет возможности представлять неожиданные трудности любого рода.\n"
"В задаче про детский сад мы могли бы представить проблему с автомобильным "
"аккумулятором, если бы GPS явно проверял, работает автомобиль или ему нужен "
"аккумулятор, каждый раз, когда программа обдумывает оператор перемещения/"
"driving.\n"
"В реальном мире мы редко бываем так осторожны; мы садимся в машину и только "
"тогда когда она не заводится, мы рассматриваем возможность разрядки "
"аккумулятора."

#: in/chapter4.md:1416
msgid "## 4.19 The Interacting Goals Problem"
msgstr "## 4.19 Проблема Взаимодействующих Целей"

#: in/chapter4.md:1423
msgid ""
"People tend to have multiple goals, rather than working on one at a time.\n"
"Not only do I want to get the kid to nursery school, but I want to avoid "
"getting hit by another car, get to my job on time, get my work done, meet my "
"friends, have some fun, continue breathing, and so on.\n"
"I also have to discover goals on my own, rather than work on a set of "
"predefined goals passed to me by someone else.\n"
"Some goals I can keep in the background for years, and then work on them "
"when the opportunity presents itself.\n"
"There is never a notion of satisfying all possible goals.\n"
"Rather, there is a continual process of achieving some goals, partially "
"achieving others, and deferring or abandoning still others."
msgstr ""
"Люди как правило преследуют несколько целей, а не работают только над "
"одной.\n"
"Я не только хочу отвести ребенка в сад, но я хочу, чтобы меня не сбила "
"машина, чтобы успеть вовремя на работу, встретиться с друзьями, "
"повеселиться, продолжить дышать и т.д.\n"
"Я также должен самостоятельно определять цели, а не работать над набором "
"заранее определенных целей, переданных мне кем-то.\n"
"Некоторые цели я могу годами держать в тени, а затем работать над ними, "
"когда представиться возможность.\n"
"Никогда не бывает идеи достижения всех возможных целей.\n"
"Скорее, это непрерывный процесс достижения одних целей, частичного "
"достижения других и откладывания или отказа от третьих."

#: in/chapter4.md:1430
msgid ""
"In addition to having active goals, people also are aware of undesirable "
"situations that they are trying to avoid.\n"
"For example, suppose I have a goal of visiting a friend in the hospital.\n"
"This requires being at the hospital.\n"
"One applicable operator might be to walk to the hospital, while another "
"would be to severely injure myself and wait for the ambulance to take me "
"there.\n"
"The second operator achieves the goal just as well (perhaps faster), but it "
"has an undesirable side effect.\n"
"This could be addressed either with a notion of solution cost, as outlined "
"in the last section, or with a list of background goals that every solution "
"attempts to protect."
msgstr ""
"Помимо активных целей, люди также оседомлены о нежелательных ситуациях, "
"которых они пытаются избежать.\n"
"Например, предположим, что у меня есть цель навести друга в больнице.\n"
"Для этого мне нужно идти в больницу.\n"
"Один применимый оператор может: идти в больницу, в то время как другой "
"может: пораниться и ждать пока скорая помощь не отвезет меня туда.\n"
"Второй оператор достигает цели так же хорошо(а возможно и быстрее), но имеет "
"нежелательный побочный эффект.\n"
"Это можно решить либо с помощью понятия стоимости(цены) решения,  как "
"указано в последнем разделе, либо с помощью списка фоновых целей, которые "
"пытаются защитить каждое решение."

#: in/chapter4.md:1433
msgid ""
"Herb Simon coined the term \"satisficing\" to describe the strategy of "
"satisfying a reasonable number of goals to a reasonable degree, while "
"abandoning or postponing other goals.\n"
"GPS only knows success and failure, and thus has no way of maximizing "
"partial success."
msgstr ""
"Herb Simon ввел термин \"удовлетворительный\", чтобы описать стратигию "
"достижения разумного числа целей в разумной степени при отказе от других "
"целей или откладывании их на потом.\n"
"GPS знает только успехи или неудачи, и поэтому не может максимизировать "
"частичный успех."

#: in/chapter4.md:1435
msgid "## 4.20 The End of GPS"
msgstr "## 4.20 Конец GPS"

#: in/chapter4.md:1441
msgid ""
"These last four sections give a hint as to the scope of the limitations of "
"GPS.\n"
"In fact, it is not a very general problem solver at all.\n"
"It *is* general in the sense that the algorithm is not tied to a particular "
"domain; we can change domain by changing the operators.\n"
"But GPS fails to be general in that it can't solve many interesting "
"problems.\n"
"It is confined to small tricks and games."
msgstr ""
"Эти последние четыре раздела дают представление об ограничениях  GPS.\n"
"Фактически, это вообще не средство решения общих проблем.\n"
"Он *является* общим в том смысле, что алгоритм не привязан к определенной "
"области(домену); мы можем изменить домен, изменяя операторы.\n"
"Но GPS не может быть универсальным, поскольку не может решить многие "
"интересные проблемы.\n"
"Он сводиться к маленьким фокусам и играм."

#: in/chapter4.md:1453
msgid ""
"There is an important yet subtle reason why GPS was destined to fail, a "
"reason that was not widely appreciated in 1957 but now is at the core of "
"computer science.\n"
"It is now recognized that there are problems that computers can't solve-not "
"because a theoretically correct program can't be written, but because the "
"execution of the program will take too long.\n"
"A large number of problems can be shown to fall into the class of \"NP-hard"
"\" problems.\n"
"Computing a solution to these problems takes time that grows exponentially "
"as the size of the problem grows.\n"
"This is a property of the problems themselves, and holds no matter how "
"clever the programmer is.\n"
"Exponential growth means that problems that can be solved in seconds for, "
"say, a five-input case may take trillions of years when there are 100 "
"inputs.\n"
"Buying a faster computer won't help much.\n"
"After all, if a problem would take a trillion years to solve on your "
"computer, it won't help much to buy 1000 computers each 1000 times faster "
"than the one you have: you're still left with a million years wait.\n"
"For a theoretical computer scientist, discovering that a problem is NP-hard "
"is an end in itself.\n"
"But for an AI worker, it means that the wrong question is being asked.\n"
"Many problems are NP-hard when we insist on the optimal solution but are "
"much easier when we accept a solution that might not be the best."
msgstr ""
"Есть важная, но тонкая причина, по которой GPS была обречена на провал, "
"причина, которая не получила признания в 1957, но сейчас она лежит в основе "
"компьютерных наук.\n"
"Сейчас признано, что есть проблемы, которые компьютеры не могут решить - не "
"потому, что теоретически правильная программа не может быть написана, а "
"потому, что выполнение программы займет слишком много времени.\n"
"Можно показать, что большое количество проблем попадает в класс \"NP-сложных"
"\" проблем.\n"
"Вычисление решения этих проблем требует времени, которое экспотенциально "
"растет по мере увеличения размера проблемы.\n"
"Это свойство самих проблем, и оно выполняется каким бы умным не был "
"программист.\n"
"Экспотенциальный рост означает, что проблемы, которые могут быть решены за "
"секунды, например для случая с пятью входами, могут занять триллионы лет, "
"когда есть 100 входов.\n"
"Покупка более быстрого компьютера не сильно поможет.\n"
"В конце концов, если на решение проблемы на вашем компьютере потребуется "
"триллион лет, покупка 1000 компьютеров каждый в 1000 раз быстрее вашего, не "
"поможет: вам все равно придется ждать миллион лет.\n"
"Для теоретика в области информатики обнаружение NP-трудности проблемы "
"является самоцелью.\n"
"Но для работника AI, это означает, что задается не тот вопрос.\n"
"Многие проблемы являются  NP-трудными, когда мы настаиваем на оптимальном "
"решении, которое может быть не лучшим."

#: in/chapter4.md:1458
msgid ""
"The input to GPS is essentially a program, and the execution of GPS is the "
"execution of that program.\n"
"If GPS's input language is general enough to express any program, then there "
"will be problems that can't be solved, either because they take too long to "
"execute or because they have no solution.\n"
"Modern problem-solving programs recognize this fundamental limitation, and "
"either limit the class of problems they try to solve or consider ways of "
"finding approximate or partial solutions.\n"
"Some problem solvers also monitor their own execution time and know enough "
"to give up when a problem is too hard."
msgstr ""
"Входные данные для  GPS - это по сути программа, а выполнение GPS - это "
"выполнение этой программы.\n"
"Если язык ввода GPS является достаточно общим, чтобы выразить любую "
"программу, тогда возникнут проблемы, которые невозможно решить, либо потому, "
"что они выполняются слишком долго, либо потому, что у нех нет решения.\n"
"Современные программы решения проблем признают это фундаментальное "
"ограничение и либо ограничивают класс проблем, которые они пытаются решить, "
"либо рассматривают способы поиска приблизительных или частичных решений.\n"
"Некоторые специалисты по решению проблем также контролируют собственное "
"время выполнения и знают достаточно, чтобы отказаться, когда проблема "
"слишком сложна."

#: in/chapter4.md:1461
msgid ""
"The following quote from Drew McDermott's article \"Artificial Intelligence "
"Meets Natural Stupidity\" sums up the current feeling about GPS.\n"
"Keep it in mind the next time you have to name a program."
msgstr ""
"Следующая цитата из статьи Дрю МакДермотта \"Искуственный интеллект "
"встречается с естественной глупостю\" резюмирует нынешние представления о "
"GPS.\n"
"Помните об том в следующий раз, когда вам нужно будет назвать программу."

#: in/chapter4.md:1466
msgid ""
"> *Remember GPS?\n"
"By now, \"GPS\" is a colorless term denoting a particularly stupid program "
"to solve puzzles.\n"
"But it originally meant \"General Problem Solver \" which caused everybody a "
"lot of needless excitement and distraction.\n"
"It should have been called *lfgns *-\"Local Feature-Guided Network Searcher."
"\"*"
msgstr ""
"> *Помните GPS?\n"
"К настоящему времени \"GPS\" - это бесцветный термин, означающий особо "
"глупую программу для решения головоломок.\n"
"Но изначально оно означало \"Решатель Общих Проблем\", что вызывало у всех "
"ненужное волнение и смятение.\n"
"Она должна была называться  *lfgns* - \"Локальный поисковик в сети указанных "
"характеристик.\""

#: in/chapter4.md:1470
msgid ""
"Nonetheless, GPS has been a useful vehicle for exploring programming in "
"general, and AI programming in particular.\n"
"More importantly, it has been a useful vehicle for exploring \"the nature of "
"deliberation.\" Surely we'll admit that Aristotle was a smarter person than "
"you or me, yet with the aid of the computational model of mind as a guiding "
"metaphor, and the further aid of a working computer program to help explore "
"the metaphor, we have been led to a more thorough appreciation of means-ends "
"analysis-at least within the computational model.\n"
"We must resist the temptation to believe that all thinking follows this "
"model."
msgstr ""
"Тем не менее, GPS оказался полезным средством изучения программирования в "
"целом и программирования AI в частности.\n"
"Что еще более важно, это был полезный инструмент для исследования \"природы "
"размышлений\". Конечно, мы признаем, что Аристотель был более умным "
"человеком, чем вы или я, но с помощью вычислительной модели разума в "
"качестве ведущей метафоры и дальнейшей помощи рабочей компьютерной "
"программы, помогающей исследовать эту метафору, мы были ведомы к более "
"тщательному пониманию анализа средств и целей - по крайней мере, в рамках "
"вычислительной модели.\n"
"Мы должны сопротивляться искушению поверить в то, что все мышление следует "
"этой модели."

#: in/chapter4.md:1476
msgid ""
"The appeal of AI can be seen as a split between means and ends.\n"
"The end of a successful AI project can be a program that accomplishes some "
"useful task better, faster, or cheaper than it could be before.\n"
"By that measure, GPS is a mostly a failure, as it doesn't solve many "
"problems particularly well.\n"
"But the means toward that end involved an investigation and formalization of "
"the problem-solving process.\n"
"By that measure, our reconstruction of GPS is a success to the degree in "
"which it leads the reader to a better understanding of the issues."
msgstr ""
"Привлекательность AI можно рассматривать как разделение между средствами и "
"целями.\n"
"Завершением успешного проекта AI может быть программа, которая выполняет "
"некоторые полезные задачи лучше, быстрее или дешевле, чем это могло быть "
"ранее.\n"
"По этим меркам GPS в большинстве случаев является ошибкой, поскольку он не "
"решает многие проблемы особенно хорошо.\n"
"Но средства для достижения этой цели включали исследование и формализацию "
"процесса решения проблем.\n"
"Таким образом, наша реконструкция GPS является успешной в той мере, в какой "
"она помогает читателю лучше понять суть проблемы."

#: in/chapter4.md:1478
msgid "## 4.21 History and References"
msgstr "## 4.21 история и ссылки"

#: in/chapter4.md:1481
msgid ""
"The original GPS is documented in Newell and Simon's 1963 paper and in their "
"1972 book, *Human Problem Solving*, as well as in Ernst and Newell 1969.\n"
"The implementation in this chapter is based on the Strips program (Fikes and "
"Nilsson 1971)."
msgstr ""
"Оригинальный GPS задокументирован в статье Ньюэлла и Саймона 1963 года и в "
"их книге 1972 года \"решение человеческих проблем\", а также В книге Эрнста "
"и Ньюэлла 1969 года.\n"
"Реализация в этой главе основана на программе Stripes (Fikes and Nilsson "
"1971)."

#: in/chapter4.md:1488
msgid ""
"There are other important planning programs.\n"
"Earl Sacerdoti's Abstrips program was a modification of Strips that allowed "
"for hierarchical planning.\n"
"The idea was to sketch out a skeletal plan that solved the entire program at "
"an abstract level, and then fill in the details.\n"
"David Warren's Warplan planner is covered in Warren 1974a,b and in a section "
"of Coelho and Cotta 1988.\n"
"Austin Tate's Nonlin system (Tate 1977) achieved greater efficiency by "
"considering a plan as a partially ordered sequence of operations rather than "
"as a strictly ordered sequence of situations.\n"
"David Chapman's Tweak synthesizes and formalizes the state of the art in "
"planning as of 1987."
msgstr ""
"Есть и другие важные программы планирования.\n"
"Программа Эрла Сакердоти Abstrips представляла собой модификацию Strips, "
"которая позволяла осуществлять иерархическое планирование.\n"
"Идея состояла в том, чтобы набросать скелетный план, который решает всю "
"программу на абстрактном уровне, а затем заполнить детали.\n"
"Планировщик  Warplan Дэвида Уоррена освещен в Warren 1974a, b и в разделе "
"Coelho and Cotta 1988.\n"
"Система Nonlin  Остина Тейта (Tate 1977) достигла большей эффективности, "
"рассматривая план как частично упорядоченную последовательность операций, а "
"не как строго упорядоченную последовательность ситуаций.\n"
"Tweak Дэвида Чэпмена синтезирует и формализует современное состояние "
"планирования по состоянию на 1987 год."

#: in/chapter4.md:1490
msgid ""
"All of these papers-and quite a few other important planning papers-are "
"reprinted in Allen, Hendler, and Tate 1990."
msgstr ""
"Все эти документы-и довольно много других важных документов по планированию-"
"перепечатаны в Allen, Hendler, and Tate 1990."

#: in/chapter4.md:1492
msgid "## 4.22 Exercises"
msgstr "## 4.22 Упражнения"

#: in/chapter4.md:1495
msgid ""
"**Exercise  4.1 [m]** It is possible to implement dbg using a single call to "
"format.\n"
"Can you figure out the format directives to do this?"
msgstr ""
"**Exercise  4.1 [m]** Можно реализовать dbg с помощью одного вызова format.\n"
"Можете ли вы определить директивы format, чтобы сделать это?"

#: in/chapter4.md:1497
msgid ""
"**Exercise  4.2 [m]** Write a function that generates all permutations of "
"its input."
msgstr ""
"**Exercise  4.2 [m]** Напишите функцию, которая генерирует все перестановки "
"ее входных данных.."

#: in/chapter4.md:1506
msgid ""
"**Exercise  4.3 [h]** GPS does not recognize the situation where a goal is "
"accidentally solved as part of achieving another goal.\n"
"Consider the goal of eating dessert.\n"
"Assume that there are two operators available: eating ice cream (which "
"requires having the ice cream) and eating cake (which requires having the "
"cake).\n"
"Assume that we can buy a cake, and that the bakery has a deal where it gives "
"out free ice cream to each customer who purchases and eats a cake.\n"
"(1) Design a list of operators to represent this situation.\n"
"(2) Give gps the goal of eating dessert.\n"
"Show that, with the right list of operators, `gps` will decide to eat ice "
"cream, then decide to buy and eat the cake in order to get the free ice "
"cream, and then go ahead and eat the ice cream, even though the goal of "
"eating dessert has already been achieved by eating the cake.\n"
"(3) Fix gps so that it does not manifest this problem."
msgstr ""
"**Exercise  4.3 [h]** GPS не распознает ситуацию, когда цель случайно "
"достигается как часть достижения другой цели.\n"
"Рассмотрим цель - поедание десерта.\n"
"Предположим, что есть два доступных оператора: съесть мороженое (которая "
"требует наличия мороженого) и съесть торт (который требует наличия торта).\n"
"Предположим, что мы можем купить торт, и что пекарня проводит акцию, когда "
"она выдает бесплатное мороженое каждому клиенту, который покупает и ест "
"торт.\n"
"(1) Составьте список операторов для представления этой ситуации.\n"
"(2) Дайте gps цель съесть десерт.\n"
"Покажите, что, имея правильный список операторов, `gps` решит съесть "
"мороженое, затем решит купить и съесть торт, чтобы получить бесплатное "
"мороженое, а затем пойти вперед и съесть мороженое, даже если цель съесть "
"десерт уже достигнута, поеданием торта.\n"
"(3) исправьте gps так, чтобы он не проявлял этой проблемы."

#: in/chapter4.md:1508
msgid ""
"The following exercises address the problems in version 2 of the program."
msgstr ""
"Следующие упражнения направлены на решение проблем в версии 2 программы."

#: in/chapter4.md:1513
msgid ""
"**Exercise  4.4 [h]** *The Not Looking after You Don't Leap Problem*.\n"
"Write a program that keeps track of the remaining goals so that it does not "
"get stuck considering only one possible operation when others will "
"eventually lead to the goal.\n"
"Hint: have achieve take an extra argument indicating the goals that remain "
"to be achieved after the current goal is achieved.\n"
"`achieve` should succeed only if it can achieve the current goal and also "
"`achieve-all` the remaining goals."
msgstr ""
"**Exercise  4.4 [h]** *То, что вы не смотрите за собой, не является "
"проблемой прыжка*.\n"
"Напишите программу, которая отслеживает оставшиеся цели, чтобы она не "
"застряла, рассматривая только одну возможную операцию, когда другие в "
"конечном итоге приведут к цели.\n"
"Подсказка: пусть achieve примет дополнительный аргумент, указывающий на "
"цели, которые остаются достижимыми после достижения текущей цели.\n"
"`achieve` должно быть успешным только в том случае, если оно может достичь "
"текущей цели, а также `achieve-all` остальных целей."

#: in/chapter4.md:1517
msgid ""
"**Exercise  4.5 [d]** Write a planning program that, like Warren's Warplan, "
"keeps track of the list of goals that remain to be done as well as the list "
"of goals that have been achieved and should not be undone.\n"
"The program should never undo a goal that has been achieved, but it should "
"allow for the possibility of reordering steps that have already been taken.\n"
"In this way, the program will solve the Sussman anomaly and similar problems."
msgstr ""
"**Exercise  4.5 [d]** Напишите программу планирования, которая, как и "
"Warplan Уоррена, отслеживает список целей, которые еще предстоит достичь, а "
"также список целей, которые были достигнуты и не должны быть отменены.\n"
"Программа никогда не должна отменять цель, которая была достигнута, но она "
"должна допускать возможность переупорядочения шагов, которые уже были "
"предприняты.\n"
"Таким образом, программа решит аномалию Сассмана и подобные проблемы."

#: in/chapter4.md:1523
msgid ""
"**Exercise  4.6 [d]** *The Lack of Descriptive Power Problem*.\n"
"Read [chapters 5](B9780080571157500054.xhtml) and [6](B9780080571157500066."
"xhtml) tolearn about pattern matching.\n"
"Write a version of GPS that uses the pattern matching tools, and thus allows "
"variables in the operators.\n"
"Apply it to the maze and blocks world domains.\n"
"Your program will be more efficient if, like Chapman's Tweak program, you "
"allow for the possibility of variables that remain unbound as long as "
"possible."
msgstr ""
"**Exercise  4.6 [d]** *Отсутствие описательной проблемы власти*.\n"
"Прочитайте [главы 5](B9780080571157500054.xhtml) и [6](B9780080571157500066."
"xhtml), чтобы узнать о сопоставлении шаблонов.\n"
"Напишите версию GPS, которая использует инструменты сопоставления образцов "
"и, таким образом, допускает переменные в операторах.\n"
"Применяйте его к доменам лабиринт и миру блоков.\n"
"Ваша программа будет более эффективной, если, подобно программе Чепмена "
"Tweak, вы допускаете возможность переменных, которые остаются несвязанными "
"как можно дольше."

#: in/chapter4.md:1525
msgid ""
"**Exercise  4.7 [d]** Speculate on the design of a planner that can address "
"the *Perfect Information* and *Interacting Goals* problems."
msgstr ""
"**Exercise  4.7 [d]** Поразмышляйте над дизайном планировщика, который может "
"решить  проблемы *идеальной информации* и *взаимодействующих целей*."

#: in/chapter4.md:1527
msgid "## 4.23 Answers"
msgstr "## 4.23 Ответы"

#: in/chapter4.md:1530
msgid ""
"**Answer 4.1** In this version, the format string `\"~&~V@T~?\"` breaks down "
"as follows: `\"~&\"` means go to a fresh line; `\"~V@T\"` means insert "
"spaces `(@T)` but use the next argument `(V)` to get the number of spaces.\n"
"The `\"~?\"` is the indirection operator: use the next argument as a format "
"string, and the argument following that as the list of arguments for the "
"format string."
msgstr ""
"**Answer 4.1** В этой версии форматная строка `\"~&~V@T~?\"` разбивается "
"следующим образом: `\"~&\"` означает перейти к новой строке;`\"~V@T\"` "
"означает вставить `(@T)` пробелы, но используйте следующий аргумент `(V)`, "
"чтобы получить количество пробелов.\n"
"Это `\"~?\"` - это оператор косвенности: используйте следующий аргумент в "
"качестве строки формата, а следующий за ним аргумент - в качестве списка "
"аргументов для строки формата."

#: in/chapter4.md:1537
msgid ""
"```lisp\n"
"(defun dbg-indent (id indent format-string &rest args)\n"
"  \"Print indented debugging info if (DEBUG ID) has been specified.\"\n"
"  (when (member id *dbg-ids*)\n"
"    (format *debug-io* \"~&~V@T~?\" (* 2 indent) format-string args)))\n"
"```"
msgstr ""

#: in/chapter4.md:1540
msgid ""
"**Answer 4.2** Here is one solution.\n"
"The sophisticated Lisp programmer should also see the exercise on [page 680]"
"(B9780080571157500194.xhtml#p680)."
msgstr ""
"**Answer 4.2** Вот одно из решений.\n"
"Искушенный программист Lisp также должен видеть это упражнение на [page 680]"
"(B9780080571157500194.xhtml#p680)."

#: in/chapter4.md:1558
msgid ""
"```lisp\n"
"(defun permutations (bag)\n"
"  \"Return a list of all the permutations of the input.\"\n"
"  ;; If the input is nil, there is only one permutation:\n"
"  ;; nil itself\n"
"  (if (null bag)\n"
"      '(())\n"
"      ;; Otherwise, take an element, e, out of the bag\n"
"      ;; Generate all permutations of the remaining elements,\n"
"      ;; And add e to the front of each of these.\n"
"      ;; Do this for all possible e to generate all permutations,\n"
"      (mapcan #'(lambda (e)\n"
"          (mapcar #'(lambda (p) (cons e p))\n"
"            (permutations\n"
"              (remove e bag :count 1 :test #'eq))))\n"
"        bag)))\n"
"```"
msgstr ""

#: in/chapter4.md:1560
msgid "----------------------"
msgstr ""

#: in/chapter4.md:1562
msgid ""
"[1](#xfn0010)Strips is the Stanford Research Institute Problem Solver, "
"designed by [Richard Fikes and Nils Nilsson (1971)](B9780080571157500285."
"xhtml#bb0405)."
msgstr ""

#: in/chapter4.md:1565
msgid ""
"[2](#xfn0015) Gerald Sussman, in his book *A Computer Model of Skill "
"Acquisition,* uses the term \"prerequisite clobbers brother goal\" or PCBG.\n"
"I prefer to be gender neutral, even at the risk of being labeled a "
"historical revisionist."
msgstr ""

#: in/chapter4.md:1567
msgid ""
"[3](#xfn0020) Originally posed by [Saul Amarel (1968)](B9780080571157500285."
"xhtml#bb0045)."
msgstr ""

#: in/chapter4.md:1570
msgid ""
"[4](#xfn0025) A footnote in Waldinger 1977 says, \"This problem was proposed "
"by Allen Brown.\n"
"Perhaps many children thought of it earlier but did not recognize that it "
"was hard.\" The problem is named after Gerald Sussman because he popularized "
"it in Sussman 1973."
msgstr ""
