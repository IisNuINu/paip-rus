#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter22.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-03-15 08:17+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter22.md:3
msgid ""
"# Chapter 22\n"
"## Scheme: An Uncommon Lisp"
msgstr ""
"# Глава 22\n"
"## Scheme: Необычный Лисп"

#: in/chapter22.md:5
msgid "> The best laid schemes o' mice an' men"
msgstr "> Лучшие продуманные схемы мышей и людей"

#: in/chapter22.md:7
msgid "> -Robert Burns (1759-1796)"
msgstr ""

#: in/chapter22.md:11
msgid ""
"This chapter presents the Scheme dialect of Lisp and an interpreter for it.\n"
"While it is not likely that you would use this interpreter for any serious "
"programming, understanding how the interpreter works can give you a better "
"appreciation of how Lisp works, and thus make you a better programmer.\n"
"A Scheme interpreter is used instead of a Common Lisp one because Scheme is "
"simpler, and also because Scheme is an important language that is worth "
"knowing about."
msgstr ""
"В этой главе представлен диалект Лиспа - Scheme и его интерпретатор.\n"
"Хотя маловероятно, что вы будете использовать этот интерпретатор для "
"серьезного программирования, понимание того, как работает интерпретатор, "
"может дать вам лучшее представление о том, как работает Lisp, и, таким "
"образом, сделать вас лучшим программистом.\n"
"Интерпретатор Scheme используется вместо Common Lisp, потому что Scheme "
"проще, а также потому, что Scheme - важный язык, о котором стоит знать."

#: in/chapter22.md:17
msgid ""
"Scheme is the only dialect of Lisp besides Common Lisp that is currently "
"flourishing.\n"
"Where Common Lisp tries to standardize all the important features that are "
"in current use by Lisp programmers, Scheme tries to give a minimal set of "
"very powerful features that can be used to implement the others.\n"
"It is interesting that among all the programming languages in the world, "
"Scheme is one of the smallest, while Common Lisp is one of the largest.\n"
"The Scheme manual is only 45 pages (only 38 if you omit the example, "
"bibliography, and index), while *Common Lisp the Language*, 2d edition, is "
"1029 pages.\n"
"Here is a partial list of the ways Scheme is simpler than Common Lisp:"
msgstr ""
"Scheme - единственный диалект Lisp, помимо Common Lisp, который в настоящее "
"время процветает.\n"
"В то время как Common Lisp пытается стандартизировать все важные функции, "
"которые в настоящее время используются программистами Lisp, Scheme пытается "
"предоставить минимальный набор очень мощных функций, которые можно "
"использовать для реализации других.\n"
"Интересно, что среди всех языков программирования в мире Scheme - один из "
"самых маленьких, а Common Lisp - один из самых больших.\n"
"Руководство по Scheme занимает всего 45 страниц (только 38, если вы опустите "
"пример, библиографию и указатель), а *Common Lisp the Language*, 2-е "
"издание, составляет 1029 страниц.\n"
"Вот неполный список способов, которые делают Scheme проще, чем Common Lisp:"

#: in/chapter22.md:20
msgid ""
"1.  Scheme has fewer built-in functions and special forms.\n"
"!!!(p) {:.numlist}"
msgstr ""
"1.  Scheme имеет меньше встроенных функций и специальных форм.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:23
msgid ""
"2.  Scheme has no special variables, only lexical variables.\n"
"!!!(p) {:.numlist}"
msgstr ""
"2.  В Scheme нет специальных переменных, только лексические переменные.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:26
msgid ""
"3.  Scheme uses the same name space for functions and variables (and "
"everything else).\n"
"!!!(p) {:.numlist}"
msgstr ""
"3.  Scheme использует одно и то же пространство имен для функций и "
"переменных (и всего остального).\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:29
msgid ""
"4.  Scheme evaluates the function part of a function call in exactly the "
"same way as the arguments.\n"
"!!!(p) {:.numlist}"
msgstr ""
"4.  Scheme вычисляет(оценивает) функциональную часть вызова функции точно "
"так же, как аргументы.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:33
msgid ""
"5.  Scheme functions can not have optional and keyword parameters.\n"
"However, they can have the equivalent of a `&rest` parameter.\n"
"!!!(p) {:.numlist}"
msgstr ""
"5.  Функции Scheme не могут иметь дополнительных(опциональных) параметров и "
"параметров ключевых слов.\n"
"Однако они могут иметь эквивалент параметра `&rest`.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:36
msgid ""
"6.  Scheme has no `block, return, go, orthrow`; a single function `(call/"
"cc)` replaces all of these (and does much more).\n"
"!!!(p) {:.numlist}"
msgstr ""
"6.  В Scheme нет `block, return, go, orthrow`; есть одна функция `(call / "
"cc)`, которая заменяет их все (и делает гораздо больше).\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:40
msgid ""
"7.  Scheme has no packages.\n"
"Lexical variables can be used to implement package-like structures.\n"
"!!!(p) {:.numlist}"
msgstr ""
"7.  В Scheme нет пакетов.\n"
"Лексические переменные могут использоваться для реализации структур, "
"подобных пакетам.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:43
msgid ""
"8.  Scheme, as a standard, has no macros, although most implementations "
"provide macros as an extension.\n"
"!!!(p) {:.numlist}"
msgstr ""
"8.  Scheme, как стандарт, не имеет макросов, хотя большинство реализаций "
"предоставляют макросы в качестве расширения.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:46
msgid ""
"9.  Scheme has no special forms for looping; instead it asks the user to use "
"recursion and promises to implement the recursion efficiently.\n"
"!!!(p) {:.numlist}"
msgstr ""
"9.  Scheme не имеет специальных форм для зацикливания; вместо этого он "
"просит пользователя использовать рекурсию и обещает эффективно реализовать "
"рекурсию.\n"
"!!!(p) {:.numlist}"

#: in/chapter22.md:57
msgid ""
"The five main special forms in Scheme are `quote` and `if`, which are just "
"as in Common Lisp; `begin` and `set!`, which are just different spellings "
"for `progn` and `setq`; and `lambda`, which is as in Common Lisp, except "
"that it doesn't require a # 'before it.\n"
"In addition, Scheme allows variables, constants (numbers, strings, and "
"characters), and function calls.\n"
"The function call is different because the function itself is evaluated in "
"the same way as the arguments.\n"
"In Common Lisp, (`f x`) means to look up the function binding of `f` and "
"apply that to the value of `x`.\n"
"In Scheme, `(f x)` means to evaluate `f` (in this case by looking up the "
"value of the variable `f` ), evaluate `x` (by looking up the value of the "
"variable in exactly the same way) and then apply the function to the "
"argument.\n"
"Any expression can be in the function position, and it is evaluated just "
"like the arguments.\n"
"Another difference is that Scheme uses `#t` and `#f` for true and false, "
"instead of `t` and `nil`.\n"
"The empty list is denoted by `()`, and it is distinct from the false value, "
"#f.\n"
"There are also minor lexical differences in the conventions for complex "
"numbers and numbers in different bases, but these can be ignored for all the "
"programs in this book.\n"
"Also, in Scheme a single macro, `define`, serves to define both variables "
"and functions."
msgstr ""
"Пять основных специальных форм в Scheme - это `quote` и `if`, которые такие "
"же, как в Common Lisp; `begin` и `set! `, которые просто разные варианты "
"написания `progn` и `setq`; и `lambda`, что и в Common Lisp, за исключением "
"того, что перед ним не требуется #.\n"
"Кроме того, Scheme позволяет использовать переменные, константы (числа, "
"строки и символы) и вызовы функций.\n"
"Вызов функции отличается, потому что сама функция вычисляется(оценивается) "
"так же, как и аргументы.\n"
"В Common Lisp (`f x`) означает поиск привязки функции `f` и применение ее к "
"значению `x`.\n"
"На Scheme `(f x)` означает вычисление `f` (в данном случае путем поиска "
"значения переменной `f`), вычисление `x` (путем поиска значения переменной "
"точно таким же образом), а затем применение функцию к аргументу.\n"
"В позиции функции может быть любое выражение, и оно вычисляется так же, как "
"аргументы.\n"
"Другое отличие состоит в том, что Scheme использует `# t` и `#f` для "
"значений  true и false вместо `t` и `nil`.\n"
"Пустой список обозначается `()`, и он отличается от ложного значения #f.\n"
"Есть также незначительные лексические различия в соглашениях для комплексных "
"чисел и чисел в разных основаниях, но их можно игнорировать для всех "
"программ в этой книге.\n"
"Кроме того, в схеме один макрос, `define`, служит для определения как "
"переменных, так и функций."

#: in/chapter22.md:73
msgid ""
"| Scheme                          | Common Lisp                             "
"|\n"
"|---------------------------------|-----------------------------------------|\n"
"| *var*                           | *var*                                   "
"|\n"
"| *constant*                      | *constant*                              "
"|\n"
"| (`quote`*x*) or '*x*            | (`quote`*x*) or '*x*                    "
"|\n"
"| (`begin`*x*...)                 | (`progn`*x*...)                         "
"|\n"
"| (`set!`*var x*)                 | (`setq`*var x*)                         "
"|\n"
"| (`if`*pab*)                     | (`if`*pab*)                             "
"|\n"
"| (`lambda`*parms x*...)          | `#'` (`lambda`*parms x*...)             "
"|\n"
"| (*fn arg*...)                   | (*fn arg*...) or (`funcall`*fn arg*...) "
"|\n"
"| `#t`                            | `t`                                     "
"|\n"
"| `#f`                            | `nil`                                   "
"|\n"
"| `( )`                           | `nil`                                   "
"|\n"
"| (`define`*varexp*)              | (`defparameter`*var exp*)               "
"|\n"
"| (`define` (*fnparm*...) *body*) | (`defun`*fn* (*parm*...) *body*)        |"
msgstr ""

#: in/chapter22.md:76
msgid ""
"**Exercise  22**.**1** [**s**] What does the following expression evaluate "
"to in Scheme?\n"
"How many errors does it have as a Common Lisp expression?"
msgstr ""
"**Exercise  22**.**1** [**s**] Что вычислит следующее выражение на Scheme?\n"
"Сколько ошибок оно имеет в качестве выражения Common Lisp?"

#: in/chapter22.md:84
msgid ""
"```lisp\n"
"((if (= (+  2 2) 4)\n"
"      (lambda (x y) (+ (* x y) 12))\n"
"      cons)\n"
"  5\n"
"  6)\n"
"```"
msgstr ""

#: in/chapter22.md:94
msgid ""
"A great many functions, such as `car`, `cdr`, `cons`, `append`, +, `*`, and "
"`list` are the same (or nearly the same) in both dialects.\n"
"However, Scheme has some spelling conventions that are different from Common "
"Lisp.\n"
"Most Scheme mutators, like `set`!, end in '`!`' Common Lisp has no "
"consistent convention for this; some mutators start with `n` (`nreverse, "
"nsubst, nintersection`) while others have idiosyncratic names (`delete "
"versus remove`).\n"
"Scheme would use consistent names-`reverse`!\n"
"and `remove`!\n"
"-if these functions were defined at all (they are not defined in the "
"standard).\n"
"Most Scheme predicates end in '`?`', not '`p`'.\n"
"This makes predicates more obvious and eliminates the complicated "
"conventions for adding a hyphen before the `p`.[1](#fn0010) The only problem "
"with this convention is in spoken language: is `equal?` pronounced \"equal-"
"question-mark\" or \"equal-q\" or perhaps equal, with rising intonation?\n"
"This would make Scheme a tone language, like Chinese."
msgstr ""
"Множество функций, таких как `car`, `cdr`, `cons`, `append`, +, `*` и "
"`list`, одинаковы (или почти одинаковы) в обоих диалектах.\n"
"Однако в Scheme есть некоторые правила написания, которые отличаются от "
"Common Lisp.\n"
"Большинство мутаторов(деструктивных функций) Scheme, таких как `set!`, "
"оканчиваются на '`!`'. В Common Lisp нет общепринятого соглашения для этого; "
"некоторые мутаторы начинаются с `n` (`nreverse, nsubst, nintersection`), в "
"то время как другие имеют своеобразные имена (`delete versus remove`).\n"
"Scheme будет использовать согласованные имена - `reverse`! и `remove`! - "
"если эти функции были вообще определены(в стандарте они не определены).\n"
"Большинство предикатов Scheme оканчиваются на '`?`', а не на '`p`'.\n"
"Это делает предикаты более очевидными и устраняет сложные соглашения о "
"добавлении дефиса перед `p`. [1](#fn0010) Единственная проблема с этим "
"соглашением заключается в разговорной речи: `equal?` Произносится как "
"\"равно-знак-вопроса\" или  \"равный-q\" или, возможно равно, с возрастающей "
"интонацией?\n"
"Это сделало бы Scheme языком тонов, как китайский."

#: in/chapter22.md:97
msgid ""
"In Scheme, it is an error to apply `car` or `cdr` to the empty list.\n"
"Despite the fact that Scheme has `cons`, it calls the result a `pair` rather "
"than a cons cell, so the predicate is `pair?`, not `consp`."
msgstr ""
"В Scheme применение `car` или `cdr` к пустому списку является ошибкой.\n"
"Несмотря на то, что Scheme имеет `cons`, результат называется "
"`pair`(`парой`), а не cons-ячейкой, поэтому предикатом будет `pair?`, а не "
"`consp`."

#: in/chapter22.md:100
msgid ""
"Scheme recognizes not all lambda expressions will be \"functions\" according "
"to the mathematical definition of function, and so it uses the term "
"\"procedure\" instead.\n"
"Here is a partial list of correspondences between the two dialects:"
msgstr ""
"Scheme распознает, что не все лямбда-выражения будут \"функциями\" в "
"соответствии с математическим определением функции, и поэтому вместо этого "
"использует термин \"процедура\".\n"
"Вот неполный список соответствий между двумя диалектами:"

#: in/chapter22.md:123
msgid ""
"| Scheme Procedure | Common Lisp Function |\n"
"|------------------|----------------------|\n"
"| `char-ready?`    | `listen`             |\n"
"| `char?`          | `characterp`         |\n"
"| `eq?`            | `eq`                 |\n"
"| `equal?`         | `equal`              |\n"
"| `eqv?`           | `eql`                |\n"
"| `even?`          | `evenp`              |\n"
"| `for-each`       | `mapc`               |\n"
"| `integer?`       | `integerp`           |\n"
"| `list->string`   | `coerce`             |\n"
"| `list->vector`   | `coerce`             |\n"
"| `list-ref`       | `nth`                |\n"
"| `list-tail`      | `nthcdr`             |\n"
"| `map`            | `mapcar`             |\n"
"| `negative?`      | `minusp`             |\n"
"| `pair?`          | `consp`              |\n"
"| `procedure?`     | `functionp`          |\n"
"| `set!`           | `setq`               |\n"
"| `set-car!`       | `replaca`            |\n"
"| `vector-set!`    | `setf`               |\n"
"| `string-set!`    | `setf`               |"
msgstr ""

#: in/chapter22.md:125
msgid "## 22.1 A Scheme Interpreter"
msgstr "## 22.1 Интерпретатор Scheme"

#: in/chapter22.md:134
msgid ""
"As we have seen, an interpreter takes a program (or expression) as input and "
"returns the value computed by that program.\n"
"The Lisp function `eval` is thus an interpreter, and that is essentially the "
"function we are trying to write in this section.\n"
"We have to be careful, however, in that it is possible to confuse the "
"notions of interpreter and compiler.\n"
"A compiler takes a program as input and produces as output a translation of "
"that program into some other language-usually a language that can be "
"directly (or more easily) executed on some machine.\n"
"So it is also possible to write `eval` by compiling the argument and then "
"interpreting the resulting machine-level program.\n"
"Most modern Lisp systems support both possibilities, although some only "
"interpret code directly, and others compile all code before executing it.\n"
"To make the distinction clear, we will not write a function called `eval`.\n"
"Instead, we will write versions of two functions: `interp`, a Scheme "
"interpreter, and, in the next chapter, `comp`, a Scheme compiler."
msgstr ""
"Как мы видели, интерпретатор принимает программу(или выражение) в качестве "
"входных данных и возвращает значение, вычисленное этой программой.\n"
"Таким образом, Lisp функция `eval` является интерпретатором, и это, по сути, "
"функция которую мы пытаемся написать в этом разделе.\n"
"Однако мы должны быть осторожны, так как можно спутать понятия "
"интерпретатора и компилятора.\n"
"Компилятор принимает программу в качестве входных данных и производит в "
"качестве выходных данных перевод этой программы на какой-либо другой язык - "
"обычно это язык, который можно напрямую(или с большей легкостью) выполнить "
"на некоторой машине.\n"
"Таким образом, также можно написать `eval`, скомпилировав аргумент и затем "
"интерпретировать полученную программу на машинном уровне.\n"
"Большинство современных систем Lisp поддерживают обе возможности, хотя "
"некоторые некоторые только интерпретируют код на прямую, а другие "
"компилируют весь код перед его выполнением.\n"
"Чтобы прояснить различие, мы не будем писать функцию с именем `eval`.\n"
"Вместо этого, мы напишем версии двух функций: `interp`, интерпретатор "
"Scheme, и в следующей главе, `comp`, компилятор Scheme."

#: in/chapter22.md:141
msgid ""
"An interpreter that handles the Scheme primitives is easy to write.\n"
"In the interpreter `interp`, the main conditional has eight cases, "
"corresponding to the five special forms, symbols, other atoms, and procedure "
"applications (otherwise known as function calls).\n"
"For the moment we will stick with `t` and `nil` instead of `#t` and `#f`.\n"
"After developing a simple interpreter, we will add support for macros, then "
"develop a tail-recursive interpreter, and finally a continuation-passing "
"interpreter.\n"
"(These terms will be defined when the time comes.).\n"
"The glossary for `interp` is in [figure 22.1](#f0010)."
msgstr ""
"Интерпретор обрабатывающий примитивы Scheme, легко написать.\n"
"В интерпретаторе `interp`, главное условие имеет восемь случаев, "
"соответствующих пяти специальным формам, символам, другим атомам и "
"применению процедур (также известным как вызовы функций).\n"
"На данный момент мы будем придерживаться `t` и `nil` вместо `#t` и `#f`.\n"
"После разработки простого интерпретатора мы добавим поддержку макросов, "
"затем разработаем интерпретатор с хвостовой рекурсией и, наконец, "
"интерпретатор с передачей продолжения(continuation-passing).\n"
"(Эти термины будут определены, когда придет время.).\n"
"Глоссарий(словарь) для `interp` приведен на [рисунке 22.1](#f0010)."

#: in/chapter22.md:172
msgid ""
"| | **Top-Level Functions** |\n"
"|---|---|\n"
"| `scheme` | A Scheme read-interp-print loop |\n"
"| `interp` | Interpret (evaluate) an expression in an environment. |\n"
"| `def-scheme-macro` | Define a Scheme macro. |\n"
"| | **Special Variables** |\n"
"| `*scheme-procs*` | Some procedures to store in the global environment. |\n"
"| | **Auxiliary Functions** |\n"
"| `set-var!` | Set a variable to a value |\n"
"| `get-var` | Get the value of a variable in an environment. |\n"
"| `set-global-var!` | Set a global variable to a value. |\n"
"| `get-global-var` | Get the value of a variable from the global "
"environment. |\n"
"| `extend-env` | Add some variables and values to an environment. |\n"
"| `init-scheme-iterp` | Initialize some global variables. |\n"
"| `init-scheme-proc` | Define a primitive Scheme procedure. |\n"
"| `scheme-macro` | Retrieve the Scheme macro for a symbol. |\n"
"| `scheme-macro-expand` | Macro-expand a Scheme expression. |\n"
"| `maybe-add` | Add an element to the front of a non-singleton list. |\n"
"| `print-proc` | Print a procedure. |\n"
"| | **Data Type (tail-recursive version only)** |\n"
"| `proc` | A Scheme procedure. |\n"
"| | **Functions (continuation version only)** |\n"
"| `interp-begin` | Interpret a `begin` expression. |\n"
"| `interp-call` | Interpret a function application. |\n"
"| `map-interp` | Map `interp` over a list. |\n"
"| `call/cc` | call with current continuation. |\n"
"| | **Previously Defined Functions** |\n"
"| `lastl` | Select the last element of a list. |\n"
"| `length=1` | Is this a list of length 1? |\n"
"| Table 22.1: Glossary for the Scheme Interpreter |"
msgstr ""
"| | **Функции верхнего уровня** |\n"
"|---|---|\n"
"| `scheme` | Scheme цикл чтения-интерпретации-печати/REPL(read-interp-print) "
"|\n"
"| `interp` | Интерпретирует/вычисляет (оценивает) выражение в сред "
"окружения.|\n"
"| `def-scheme-macro` | Определяет макрос Scheme. |\n"
"| | **Специальные переменные** |\n"
"| `*scheme-procs*` | Некоторые процедуры сохраняемые в глобальной среде "
"окружения. |\n"
"| | **Вспомогательные функции** |\n"
"| `set-var!` | Установить значение для переменной |\n"
"| `get-var` | Получить значение для переменной в окружающей среде. |\n"
"| `set-global-var!` | Установить значение для глобальной переменной. |\n"
"| `get-global-var` | Получить значение переменной из глобальной окружающей "
"среды. |\n"
"| `extend-env` | Добавить в окружающую среду несколько переменных и "
"значений. |\n"
"| `init-scheme-iterp` | Инициализирует некоторые глобальные переменные. |\n"
"| `init-scheme-proc` | Определяет простую(примитивную) процедуру Scheme. |\n"
"| `scheme-macro` | Получает макрос Scheme для символа. |\n"
"| `scheme-macro-expand` | Макрорасширение выражения Scheme. |\n"
"| `maybe-add` | Добаить элемент в начало не одноэлементного списка. |\n"
"| `print-proc` | Распечатать процедуру. |\n"
"| | **Типы Данных (только для версии с хвостовой рекурсией)** |\n"
"| `proc` | Процедура Scheme. |\n"
"| | **Функции (только в версии с продолжениями)** |\n"
"| `interp-begin` | Интерпретирует выражение `begin`. |\n"
"| `interp-call` | Интерпретирует применение функции. |\n"
"| `map-interp` | Сопоставляет `interp` со списком. |\n"
"| `call/cc` | вызызов с текущим продолжением. |\n"
"| | **Ранее определенные функции** |\n"
"| `lastl` | Выбирает последний элемент из списка. |\n"
"| `length=1` | Проверяет что список имеет длину 1? |\n"
"| Таблица 22.1: Словарь для интерпретатора Scheme |"

#: in/chapter22.md:183
msgid ""
"The simple interpreter has eight cases to worry about: (1) If the expression "
"is a symbol, look up its value in the environment.\n"
"(2) If it is an atom that is not a symbol (such as a number), just return "
"it.\n"
"Otherwise, the expression must be a list.\n"
"(3) If it starts with `quote`, return the quoted expression.\n"
"(4) If it starts with `begin`, interpret each subexpression, and return the "
"last one.\n"
"(5) If it starts with `set!`, interpret the value and then set the variable "
"to that value.\n"
"(6) If it starts with `if`, then interpret the conditional, and depending on "
"if it is true or not, interpret the then-part or the else-part.\n"
"(7) If it starts with `lambda`, build a new procedure-a closure over the "
"current environment.\n"
"(8) Otherwise, it must be a procedure application.\n"
"Interpret the procedure and all the arguments, and apply the procedure value "
"to the argument values."
msgstr ""
"У простого интерпретатора есть восем случаев, о которых нужно беспокоиться: "
"(1) Если выражение является символом, найдите его значение в окружающей "
"среде.\n"
"(2) Если это атом, который не является символом(такой как число), просто "
"верните его.\n"
"В противном случае выражение должно быть списком.\n"
"(3) Если оно начинается с `quote`, вернуть выражение в кавычках.\n"
"(4) Если оно начинается с `begin`, интерпретировать каждое подвыражение, и "
"вернуть значение последнего.\n"
"(5) Если оно начинается с `set!`, интерпретируйте значение, а затем "
"установите для переменной это значение.\n"
"(6) Если оно начинается с `if`, интерпретируйте условное выражение, и в "
"зависимости от того истинно оно или нет интерпретируйте then-часть или else-"
"часть.\n"
"(7) Если оно начинается с `lambda`, создайте новую процедуру - замыкание для "
"текущей окружающей среды.\n"
"(8) В противном случае, это должно быть применение процедуры.\n"
"Интерпретируйте процедуру и все аргументы и примените значение процедуры к "
"значениям аргументов."

#: in/chapter22.md:207
msgctxt "in/chapter22.md:207"
msgid ""
"```lisp\n"
"(defun interp (x &optional env)\n"
"  \"Interpret (evaluate) the expression x in the environment env.\"\n"
"  (cond\n"
"    ((symbolp x) (get-var x env))\n"
"    ((atom x) x)\n"
"    ((case (first x)\n"
"       (QUOTE  (second x))\n"
"       (BEGIN  (last1 (mapcar #'(lambda (y) (interp y env))\n"
"                              (rest x))))\n"
"       (SET!   (set-var! (second x) (interp (third x) env) env))\n"
"       (IF     (if (interp (second x) env)\n"
"                   (interp (third x) env)\n"
"                   (interp (fourth x) env)))\n"
"       (LAMBDA (let ((parms (second x))\n"
"                     (code (maybe-add 'begin (rest2 x))))\n"
"                 #'(lambda (&rest args)\n"
"                     (interp code (extend-env parms args env)))))\n"
"       (t      ;; a procedure application\n"
"               (apply (interp (first x) env)\n"
"                      (mapcar #'(lambda (v) (interp v env))\n"
"                              (rest x))))))))\n"
"```"
msgstr ""

#: in/chapter22.md:211
msgid ""
"An environment is represented as an association list of variable/value "
"pairs, except for the global environment, which is represented by values on "
"the `global-val` property of symbols.\n"
"It would be simpler to represent the global environment in the same way as "
"local environments, but it is more efficient to use property lists than one "
"big global a-list.\n"
"Furthermore, the global environment is distinct in that every symbol is "
"implicitly defined in the global environment, while local environments only "
"contain variables that are explicitly mentioned (in a `lambda` expression)."
msgstr ""
"Окружающая среда(environment/окружение/среда/среда окружения) представлена в "
"виде ассоциативного списка парами переменная/значение(variable/value), за "
"исключением глобальной окружающей среды, которая представлена значениями в "
"свойстве `global-val` для символов.\n"
"Было бы проще представить глобальное окружение так же, как локальную среду, "
"но более эффективно использовать списки свойств, чем большой глобальный "
"ассоциативный список(a-list).\n"
"Более того, глобальная среда отличается тем, что каждый символ определяется "
"неявно в глобальном оружении, в то время как локальная окружающая среда "
"содержит только переменные, которые явно упомянуты (в `lambda` выражении)."

#: in/chapter22.md:213
msgid ""
"As an example, suppose we interpret the function call `(f 1 2 3)`, and that "
"the functions `f` has been defined by the Scheme expression:"
msgstr ""
"В качестве примера предположим, что мы интерпретируем вызов функции `(f 1 2 "
"3)`, и что функция `f` была определена следующим выражением Scheme:"

#: in/chapter22.md:216
msgid ""
"`(set!\n"
"f (lambda (a b c) (+ a (g b c))))`"
msgstr ""

#: in/chapter22.md:218
msgid ""
"Then we will interpret `( f 1 2 3 )` by interpreting the body of `f` with "
"the environment:"
msgstr ""
"Затем мы интерпретируем `( f 1 2 3 )` интерпретируя тело `f` с окружающей "
"средой:"

#: in/chapter22.md:222
msgid ""
"```lisp\n"
"((a 1) (b 2) (c 3))\n"
"```"
msgstr ""

#: in/chapter22.md:225
msgid ""
"Scheme procedures are implemented as Common Lisp functions, and in fact all "
"the Scheme data types are implemented by the corresponding Common Lisp "
"types.\n"
"Iinclude the function `init-scheme- interp` to initialize a few global "
"values and repeat the definitions of `last1` and `length=1`:"
msgstr ""
"Процедуры Scheme реализованы как функции Common Lisp, и фактически все типы "
"данных Scheme реализованы соответствующими типами Common Lisp.\n"
"Я включил функцию `init-scheme-interp` для инициализации нескольких "
"глобальных значений и повторяю определения `last1` и `length=1`:"

#: in/chapter22.md:233
msgid ""
"```lisp\n"
"(defun set-var! (var val env)\n"
"  \"Set a variable to a value, in the given or global environment.\"\n"
"  (if (assoc var env)\n"
"      (setf (second (assoc var env)) val)\n"
"      (set-global-var! var val))\n"
"  val)"
msgstr ""

#: in/chapter22.md:239
msgid ""
"(defun get-var (var env)\n"
"  \"Get the value of a variable, from the given or global environment.\"\n"
"    (if (assoc var env)\n"
"        (second (assoc var env))\n"
"        (get-global-var var)))"
msgstr ""

#: in/chapter22.md:242
msgid ""
"(defun set-global-var! (var val)\n"
"  (setf (get var 'global-val) val))"
msgstr ""

#: in/chapter22.md:249
msgid ""
"(defun get-global-var (var)\n"
"  (let* ((default \"unbound\")\n"
"         (val (get var 'global-val default)))\n"
"    (if (eq val default)\n"
"        (error \"Unbound scheme variable: ~a\" var)\n"
"        val)))"
msgstr ""

#: in/chapter22.md:253
msgid ""
"(defun extend-env (vars vals env)\n"
"  \"Add some variables and values to an environment.\"\n"
"  (nconc (mapcar #'list vars vals) env))"
msgstr ""

#: in/chapter22.md:258
msgid ""
"(defparameter *scheme-procs*\n"
"  '(+ - * / = < > <= >= cons car cdr not append list read member\n"
"    (null? null) (eq? eq) (equal? equal) (eqv? eql)\n"
"    (write prin1) (display princ) (newline terpri)))"
msgstr ""

#: in/chapter22.md:267
msgid ""
"(defun init-scheme-interp ()\n"
"  \"Initialize the scheme interpreter with some global variables.\"\n"
"  ;; Define Scheme procedures as CL functions:\n"
"  (mapc #'init-scheme-proc *scheme-procs*)\n"
"  ;; Define the boolean `constants'. Unfortunately, this won't\n"
"  ;; stop someone from saying: (set! t nil)\n"
"  (set-global-var! t t)\n"
"  (set-global-var! nil nil))"
msgstr ""

#: in/chapter22.md:274
msgid ""
"(defun init-scheme-proc (f)\n"
"  \"Define a Scheme procedure as a corresponding CL function.\"\n"
"  (if (listp f)\n"
"      (set-global-var! (first f) (symbol-function (second f)))\n"
"      (set-global-var! f (symbol-function f))))\n"
"```"
msgstr ""

#: in/chapter22.md:290
msgid ""
"```lisp\n"
"(defun maybe-add (op exps &optional if-nil)\n"
"  \"For example, (maybe-add 'and exps t) returns\n"
"  t if exps is nil, exps if there is only one,\n"
"  and (and exp1 exp2...) if there are several exps.\"\n"
"  (cond ((null exps) if-nil)\n"
"              ((length=1 exps) (first exps))\n"
"              (t (cons op exps))))\n"
"(defun length=1 (x)\n"
"  \"Is x a list of length 1?\"\n"
"  (and (consp x) (null (cdr x))))\n"
"(defun lastl (list)\n"
"  \"Return the last element (not last cons cell) of list\"\n"
"  (first (last list)))\n"
"```"
msgstr ""

#: in/chapter22.md:292
msgid "To test the interpreter, we add a simple read-eval-print loop:"
msgstr ""
"Чтобы протестировать интерпретатор, мы добавляем простой цикл чтения-"
"выполнения-печати(REPL- read-eval-print loop):"

#: in/chapter22.md:300
msgid ""
"```lisp\n"
"(defun scheme ()\n"
"  \"A Scheme read-eval-print loop (using interp)\"\n"
"  (init-scheme-interp)\n"
"  (loop (format t \"~&==> \")\n"
"        (print (interp (read) nil))))\n"
"```"
msgstr ""

#: in/chapter22.md:303
msgid ""
"And now we're ready to try out the interpreter.\n"
"Note the Common Lisp prompt is \">,\" while the Scheme prompt is \"==>.\""
msgstr ""
"А теперь мы готовы опробовать интерпретатор. \n"
"Обратите внимание, что приглашение Common Lisp это \">,\" а приглашение "
"Scheme это \"==>.\""

#: in/chapter22.md:313
msgid ""
"```lisp\n"
"> (scheme)\n"
"==> (+  2 2)\n"
"4\n"
"==> ((if (=  1 2) * +) 3 4)\n"
"7\n"
"==> ((if (=  1 1) * +) 3 4)\n"
"12\n"
"```"
msgstr ""

#: in/chapter22.md:316
msgid ""
"`==> (set!\n"
"fact (lambda (n)`"
msgstr ""

#: in/chapter22.md:324
msgid ""
"```lisp\n"
"                (if (= n 0) 1\n"
"                    (* n (fact (- n 1))))))\n"
"#<DTP-LEXICAL-CLOSURE 36722615  >\n"
"==> (fact 5)\n"
"120\n"
"```"
msgstr ""

#: in/chapter22.md:327
msgid ""
"`==> (set!\n"
"table (lambda (f start end)`"
msgstr ""

#: in/chapter22.md:357
msgid ""
"```lisp\n"
"                    (if (<= start end)\n"
"                        (begin\n"
"                          (write (list start (f start)))\n"
"                          (newline)\n"
"                          (table f (+ start 1) end)))))\n"
"#<DTP-LEXICAL-CLOSURE 41072172  >\n"
"==> (table fact 1 10)\n"
"(1 1)\n"
"(2 2)\n"
"(3 6)\n"
"(4 24)\n"
"(5 120)\n"
"(6 720)\n"
"(7 5040)\n"
"(8 40320)\n"
"(9 362880)\n"
"(10 3628800)\n"
"NIL\n"
"==> (table (lambda (x) (* x x x)) 5 10)\n"
"(5 125)\n"
"(6 216)\n"
"(7 343)\n"
"(8 512)\n"
"(9 729)\n"
"(10 1000)\n"
"NIL\n"
"==> [ABORT]\n"
"```"
msgstr ""

#: in/chapter22.md:359
msgid "## 22.2 Syntactic Extension with Macros"
msgstr "## 22.2 Синтаксическое расширение с помощью Макросов"

#: in/chapter22.md:364
msgid ""
"Scheme has a number of other special forms that were not listed above.\n"
"Actually, Scheme uses the term \"syntax\" where we have been using \"special "
"form.\" The remaining syntax can be defined as \"derived expressions\" in "
"terms of the five primitives.\n"
"The Scheme standard does not recognize a concept of macros, but it is clear "
"that a \"derived expression\" is like a macro, and we will implement them "
"using macros.\n"
"The following forms are used (nearly) identically in Scheme and Common Lisp:"
msgstr ""
"Scheme имеет ряд специальных форм, не перечисленных выше.\n"
"Фактически, Scheme использует термин \"синтаксис\" там, где мы используем "
"\"специальная форма.\" \n"
"Остальной синтаксис можно определить как \"производные выражения\" в "
"терминах пяти примитивов.\n"
"Стандарт Scheme не признает концепцию макросов, но ясно, что \"производное "
"выражение\" похоже на макрос, и мы будем реализовывать их с помощью "
"макросов.\n"
"Следующие формы используются (почти) одинаково в Scheme и Common Lisp:"

#: in/chapter22.md:368
msgid ""
"```lisp\n"
"let let* and or do cond case\n"
"```"
msgstr ""

#: in/chapter22.md:376
msgid ""
"One difference is that Scheme is less lenient as to what counts as a binding "
"in `let`, `let*` and `do`.\n"
"Every binding must be `(`*var init*`)`; just `(`*var*`)` or *var* is not "
"allowed.\n"
"In do, a binding can be either (*var init step*) or (*var init*).\n"
"Notice there is no `do*`.\n"
"The other difference is in `case` and `cond`.\n"
"Where Common Lisp uses the symbol `t` or `otherwise` to mark the final case, "
"Scheme uses `else`.\n"
"The final three syntactic extensions are unique to Scheme:"
msgstr ""
"Одно отличие состоит в том, что Scheme менее снисходительно относится к "
"тому, что считается связыванием в `let`, `let*` и `do`.\n"
"Каждая привязка должна быть `(`*var init*`)`; просто `(`*var*`)` или *var* "
"не допустимы.\n"
"В do, привязка может быть либо (*var init step*), либо (*var init*).\n"
"Обратите внимание, что `do*` отсутствует.\n"
"Другое отличие заключается в  `case` и `cond`.\n"
"Где Common Lisp использует символ `t` или `otherwise` для обозначения "
"последнего случая, Scheme использует `else`.\n"
"Последние три синтаксических расширения уникальны для Scheme:"

#: in/chapter22.md:382
msgid ""
"```lisp\n"
"(define *var val*)      *or*          (define (*proc*-*name arg*...) "
"*body*...)\n"
"(delay *expression*)\n"
"(letrec ((*var init*)...) *body*...)\n"
"```"
msgstr ""

#: in/chapter22.md:391
msgid ""
"`define` is a combination of `defun` and `defparameter`.\n"
"In its first form, it assigns a value to a variable.\n"
"Since there are no special variables in Scheme, this is no different than "
"using `set!`.\n"
"(There is a difference when the `define` is nested inside another "
"definition, but that is not yet considered.) In the second form, it defines "
"a function.\n"
"`delay` is used to delay evaluation, as described in [section 9.3]"
"(B9780080571157500091.xhtml#s0020), page 281.\n"
"`letrec` is similar to `let`.\n"
"The difference is that all the *init* forms are evaluated in an environment "
"that includes all the *vars*.\n"
"Thus, `letrec` can be used to define local recursive functions, just as "
"`labels` does in Common Lisp."
msgstr ""
"`define` это комбинация  `defun` и `defparameter`.\n"
"В своей первой форме он присваивает значение переменной.\n"
"Поскольку в Scheme нет специальных переменных, она ничем не отличается от "
"`set!`.\n"
"(Есть разница, когда определение вложено в другое определение, но это еще не "
"рассматривается.) \n"
"Во второй форме оно определяет функцию.\n"
"`delay` используется для задержки вычислений, как описано в [разделе 9.3]"
"(B9780080571157500091.xhtml#s0020), стр. 281.\n"
"`letrec` аналогичен `let`.\n"
"Разница в том, что все формы *init* вычисляются в окружающей среде, которая "
"включает все *vars*(переменные*).\n"
"Таким образом, `letrec` можно использовать для определения локальных "
"рекурсивных функций, как это делает `labels` в Common Lisp."

#: in/chapter22.md:394
msgid ""
"The first step in implementing these syntactic extensions is to change "
"`interp` to allow macros.\n"
"Only one clause has to be added, but we'll repeat the whole definition:"
msgstr ""
"Первым шагом в реализации этих синтаксических расширений является изменение "
"`interp`, позволяющее использовать макросы.\n"
"Нужно добавить одно предложение, но мы повторим все определение:"

#: in/chapter22.md:418
msgctxt "in/chapter22.md:418"
msgid ""
"```lisp\n"
"(defun interp (x &optional env)\n"
"  \"Interpret (evaluate) the expression x in the environment env.\"\n"
"  (cond\n"
"    ((symbolp x) (get-var x env))\n"
"    ((atom x) x)\n"
"    ((case (first x)\n"
"       (QUOTE  (second x))\n"
"       (BEGIN  (last1 (mapcar #'(lambda (y) (interp y env))\n"
"                              (rest x))))\n"
"       (SET!   (set-var! (second x) (interp (third x) env) env))\n"
"       (IF     (if (interp (second x) env)\n"
"                   (interp (third x) env)\n"
"                   (interp (fourth x) env)))\n"
"       (LAMBDA (let ((parms (second x))\n"
"                     (code (maybe-add 'begin (rest2 x))))\n"
"                 #'(lambda (&rest args)\n"
"                     (interp code (extend-env parms args env)))))\n"
"       (t      ;; a procedure application\n"
"               (apply (interp (first x) env)\n"
"                      (mapcar #'(lambda (v) (interp v env))\n"
"                              (rest x))))))))\n"
"```"
msgstr ""

#: in/chapter22.md:428
msgid ""
"Now we provide a mechanism for defining macros.\n"
"The macro definitions can be in any convenient language; the easiest choices "
"are Scheme itself or Common Lisp.\n"
"I have chosen the latter.\n"
"This makes it clear that macros are not part of Scheme itself but rather are "
"used to implement Scheme.\n"
"If we wanted to offer the macro facility to the Scheme programmer, we would "
"make the other choice.\n"
"(But then we would be sure to add the backquote notation, which is so useful "
"in writing macros.) `def-scheme-macro` (which happens to be a macro itself) "
"provides a way of adding new Scheme macros.\n"
"It does that by storing a Common Lisp function on the `scheme-macro` "
"property of a symbol.\n"
"This function, when given a list of arguments, returns the code that the "
"macro call should expand into.\n"
"The function `scheme-macro` tests if a symbol has a macro attached to it, "
"and `scheme-macro-expand` does the actual macro-expansion:"
msgstr ""
"Теперь мы предоставим механизм для определения макросов.\n"
"Определения макросов могут быть на любом языке; самый простой выбор - это "
"сама Scheme или Common Lisp.\n"
"Я выбрал второе.\n"
"Это дает понять, что макросы не являются частью самой Scheme, а используются "
"для реализации Scheme.\n"
"Если бы мы хотели пердложить программисту Scheme возможность/"
"функциональность создания мароса, мы бы сделали другой выбор.\n"
"(Но тогда мы обязательно добавим обозначение/запись обратных кавычек, "
"которая очень полезна при написании макросов.) `def-scheme-macro` (который "
"сам по себе является макросом) предоставляет способ добавления новых "
"макросов Scheme.\n"
"Он делает это, сохраняя функцию Common Lisp в свойстве символа `scheme-"
"macro`.\n"
"Эта функция, получив список аргументов, возвращает код, в который должен "
"быть расширен вызов макроса.\n"
"Функция `scheme-macro` проверяет, имеет ли символ прикрепленный к нему "
"макрос, а `scheme-macro-expand` выполняет фактическое расширение макроса:"

#: in/chapter22.md:443
msgid ""
"```lisp\n"
"(defun scheme-macro (symbol)\n"
"  (and (symbolp symbol) (get symbol 'scheme-macro)))\n"
"(defmacro def-scheme-macro (name parmiist &body body)\n"
"  \"Define a Scheme macro.\"\n"
"  '(setf (get ',name 'scheme-macro)\n"
"        #'(lambda .parmlist ..body)))\n"
"(defun scheme-macro-expand (x)\n"
"  \"Macro-expand this Scheme expression.\"\n"
"  (if (and (listp x) (scheme-macro (first x)))\n"
"              (scheme-macro-expand\n"
"                (apply (scheme-macro (first x)) (rest x)))\n"
"              x))\n"
"```"
msgstr ""

#: in/chapter22.md:445
msgid "Here are the definitions of nine important macros in Scheme:"
msgstr "Вот определение девяти важных в Scheme макросов:"

#: in/chapter22.md:488
msgid ""
"```lisp\n"
"(def-scheme-macro let (bindings &rest body)\n"
"  '((lambda .(mapcar #'first bindings) . ,body)\n"
"    .,(mapcar #'second bindings)))\n"
"(def-scheme-macro let* (bindings &rest body)\n"
"  (if (null bindings)\n"
"              '(begin .,body)\n"
"              '(let (,(first bindings))\n"
"          (let* ,(rest bindings) . ,body))))\n"
"(def-scheme-macro and (&rest args)\n"
"  (cond ((null args) 'T)\n"
"          ((length=1 args) (first args))\n"
"          (t '(if ,(first args)\n"
"                    (and . ,(rest args))))))\n"
"(def-scheme-macro or (&rest args)\n"
"  (cond ((null args) 'nil)\n"
"        ((length=1 args) (first args))\n"
"        (t (let ((var (gensym)))\n"
"                '(let ((,var ,(first args)))\n"
"                  (if ,var ,var (or . ,(rest args))))))))\n"
"(def-scheme-macro cond (&rest clauses)\n"
"  (cond ((null clauses) nil)\n"
"          ((length=1 (first clauses))\n"
"            '(or ,(first clauses) (cond .,(rest clauses))))\n"
"          ((starts-with (first clauses) 'else)\n"
"            '(begin .,(rest (first clauses))))\n"
"          (t '(if ,(first (first clauses))\n"
"                    (begin .,(rest (first clauses)))\n"
"                    (cond .,(rest clauses))))))\n"
"(def-scheme-macro case (key &rest clauses)\n"
"  (let ((key-val (gensym \"KEY\")))\n"
"    '(let ((,key-val ,key))\n"
"      (cond ,@(mapcar\n"
"                #'(lambda (clause)\n"
"                    (if (starts-with clause 'else)\n"
"                        clause\n"
"                        '((member ,key-val ',(first clause))\n"
"                                .,(rest clause))))\n"
"                clauses)))))\n"
"(def-scheme-macro define (name &rest body)\n"
"  (if (atom name)\n"
"```"
msgstr ""

#: in/chapter22.md:491
msgid ""
"`              '(begin (set!\n"
",name . ,body) ',name)`"
msgstr ""

#: in/chapter22.md:500
msgid ""
"```lisp\n"
"              '(define ,(first name)\n"
"          (lambda ,(rest name) . ,body))))\n"
"(def-scheme-macro delay (computation)\n"
"  '(lambda () ,computation))\n"
"(def-scheme-macro letrec (bindings &rest body)\n"
"  '(let ,(mapcar #'(lambda (v) (list (first v) nil)) bindings)\n"
"```"
msgstr ""

#: in/chapter22.md:503
msgid ""
"`        ,@(mapcar #'(lambda (v) '(set!\n"
". ,v)) bindings)`"
msgstr ""

#: in/chapter22.md:507
msgid ""
"```lisp\n"
"      .,body))\n"
"```"
msgstr ""

#: in/chapter22.md:509
msgid "We can test out the macro facility:"
msgstr "Мы можем протестировать возможность использовать макросов:"

#: in/chapter22.md:514
msgid ""
"```lisp\n"
"> (scheme-macro-expand '(and p q)) => (IF P (AND Q))\n"
"> (scheme-macro-expand '(and q)) Q\n"
"```"
msgstr ""

#: in/chapter22.md:516
msgid "`> (scheme-macro-expand '(let ((x 1) (y 2)) (+ x y)))`=>"
msgstr ""

#: in/chapter22.md:522
msgid ""
"```lisp\n"
"((LAMBDA (X Y) (+ X Y)) 1 2)\n"
"> (scheme-macro-expand\n"
"    '(letrec\n"
"```"
msgstr ""

#: in/chapter22.md:526
msgid ""
"`        ((even?\n"
"(lambda (x) (or (= x 0) (odd?\n"
"(- x 1)))))`"
msgstr ""

#: in/chapter22.md:530
msgid ""
"`          (odd?\n"
"(lambda (x) (even?\n"
"(- x 1)))))`"
msgstr ""

#: in/chapter22.md:533
msgid ""
"`        (even?\n"
"z)))`=>"
msgstr ""

#: in/chapter22.md:536
msgid ""
"`(LET ((EVEN?\n"
"NIL)`"
msgstr ""

#: in/chapter22.md:539
msgid ""
"`              (ODD?\n"
"NIL))`"
msgstr ""

#: in/chapter22.md:544
msgid ""
"`  (SET!\n"
"EVEN?\n"
"(LAMBDA (X) (OR (= X 0) (ODD?\n"
"(- X 1)))))`"
msgstr ""

#: in/chapter22.md:549
msgid ""
"`  (SET!\n"
"ODD?\n"
"(LAMBDA (X) (EVEN?\n"
"(- X 1))))`"
msgstr ""

#: in/chapter22.md:552
msgid ""
"`  (EVEN?\n"
"Z))`"
msgstr ""

#: in/chapter22.md:557
msgid ""
"```lisp\n"
"> (scheme)\n"
"==> (define (reverse 1)\n"
"```"
msgstr ""

#: in/chapter22.md:560
msgid ""
"`      (if (null?\n"
"1) nil`"
msgstr ""

#: in/chapter22.md:572
msgid ""
"```lisp\n"
"            (append (reverse (cdr 1)) (list (car 1)))))\n"
"REVERSE\n"
"==> (reverse '(a b c d))\n"
"(D C B A)\n"
"==> (let* ((x 5) (y (+ x x)))\n"
"      (if (or (= x 0) (and (<  0 y) (< y 20)))\n"
"            (list x y)\n"
"            (+ y x)))\n"
"(5 10)\n"
"```"
msgstr ""

#: in/chapter22.md:578
msgid ""
"The macro `define` is just like `set!`, except that it returns the symbol "
"rather than the value assigned to the symbol.\n"
"In addition, `define` provides an optional syntax for defining functions-it "
"serves the purposes of both `defun` and `defvar`.\n"
"The syntax (`define` (*fn*.\n"
"*args*).*body*) is an abbreviation for (`define`*fn* (`lambda`*args*.\n"
"*body*))."
msgstr ""
"Макрос `define` похож на `set!`, за исключением того, что он возвращает "
"символ, а не значение, присвоенное символу.\n"
"Кроме того, `define` предоставляет необязательный синтаксис для определения "
"функций - он служит целям как `defun`, так и `defvar`.\n"
"Синтаксис (`define` (*fn* . *args*) .*body*) является сокращением "
"(`define`*fn* (`lambda`*args* . *body*))."

#: in/chapter22.md:580
msgid ""
"In addition, Scheme provides a notation where `define` can be used inside a "
"function definition in a way that makes it work like `let` rather than `set!."
"`"
msgstr ""
"Кроме того, Scheme предоставляет нотацию, в которой  `define` можно "
"использовать внутри определения функции таким образом, чтобы оно работало "
"как `let`, а не как `set!.`"

#: in/chapter22.md:584
msgid ""
"The advantage of the macro-based approach to special forms is that we don't "
"have to change the interpreter to add new special forms.\n"
"The interpreter remains simple, even while the language grows.\n"
"This also holds for the compiler, as we see in the next section."
msgstr ""
"Преимущетсво подхода базирующегося на макросах к специальным формам состоит "
"в том, что нам не нужно изменять интерпретатор для добавления новых "
"специальных форм.\n"
"Интерпретатор остается простым, даже когда язык растет.\n"
"Это также относится к компилятору, как мы увидим в следующем разделе."

#: in/chapter22.md:586
msgid "## 22.3 A Properly Tail-Recursive Interpreter"
msgstr "## 22.3 Правильный Интерпретатор Хвостовой Рекурсии"

#: in/chapter22.md:590
msgid ""
"Unfortunately, the interpreter presented above can not lay claim to the name "
"Scheme, because a true Scheme must be properly tail-recursive.\n"
"Our interpreter is tail- recursive only when run in a Common Lisp that is "
"tail-recursive.\n"
"To see the problem, consider the following Scheme procedure:"
msgstr ""
"К сожалению, представленный выше интерпретатор не может претендовать на "
"гордое имя Scheme, потому что настоящая Scheme должна правильно обрабатывать "
"хвостовую рекурсию.\n"
"Наш интерпретатор обрабатывает хвостовую рекурсию только при запуске в  "
"Common Lisp, который сам является обрабатывающим хвостовую рекурсию.\n"
"Чтобы увидеть проблему, рассмотрим следующую процедуру Scheme:"

#: in/chapter22.md:595
msgid ""
"```lisp\n"
"(define (traverse lyst)\n"
"  (if lyst (traverse (cdr lyst))))\n"
"```"
msgstr ""

#: in/chapter22.md:601
msgid ""
"Trace the function `interp` and execute `(interp '(traverse '(a b c d)))`.\n"
"The nested calls to `interp` go 16 levels deep.\n"
"In general, the level of nesting is 4 plus 3 times the length of the list.\n"
"Each call to `interp` requires Common Lisp to allocate some storage on the "
"stack, so for very long lists, we will eventually run out of storage.\n"
"To earn the name Scheme, a language must guarantee that such a program does "
"not run out of storage."
msgstr ""
"Трассируйте функцию `interp` и выполните `(interp '(traverse '(a b c d)))`.\n"
"Вложенные вызовы функции `interp` проходят на 16 уровней в глубину.\n"
"Как правило, уровень вложенности в 4 плюс 3 раза больше длины списка.\n"
"Каждый вызов `interp` требует Common Lisp выделил часть памяти в стеке, "
"поэтому для очень длинных списков у нас в конечном итоге закончится память.\n"
"Чтобы получить звание Scheme, язык должен гарантировать, что у такой "
"программы не закончится память."

#: in/chapter22.md:610
msgid ""
"The problem, in this example, lies in two places.\n"
"Everytime we interpret an `if` form or a procedure call, we descend another "
"recursive level into `interp`.\n"
"But that extra level is not necessary.\n"
"Consider the `if` form.\n"
"It is certainly necessary to call `interp` recursively to decide if the test "
"is true or not.\n"
"For the sake of argument, let's say the test is true.\n"
"Then we call `interp` again on the *then* part.\n"
"This recursive call will return a value, which will then be immediately "
"returned as the value of the original call as well."
msgstr ""
"Проблема в этом примере заключается в двух местах.\n"
"Каждый раз, когда мы интерпретируем форму `if` или вызов процедуры, мы "
"спускаемся с другого рекурсивного уровня в `interp`.\n"
"Но этот дополнительный уровень не нужен.\n"
"Рассмотрим форму `if`.\n"
"Разумеется, необходимо рекурсивно вызвать `interp` , чтобы решить верен ли "
"тест или нет.\n"
"Ради аргумента, предположим, что тест верен.\n"
"Затем мы снова вызываем `interp` для части *then*.\n"
"Этот рекурсивный вызов вернет значение, которое затем будет немедленно "
"возвращено как значение исходного вызова."

#: in/chapter22.md:617
msgid ""
"The alternative is to replace the recursive call to `interp` with a renaming "
"of variables, followed by a `goto` statement.\n"
"That is, instead of calling `interp` and thereby binding a new instance of "
"the variable `x` to the *then* part, we just assign the *then* part to `x`, "
"and branch to the top of the `interp` routine.\n"
"This works because we know we have no more use for the old value of `x`.\n"
"A similar technique is used to eliminate the recursive call for the last "
"expression in a `begin` form.\n"
"(Many programmers have been taught the \"structured programming\" party line "
"that `goto` statements are harmful.\n"
"In this case, the `goto` is necessary to implement a low-level feature "
"efficiently.)"
msgstr ""
"Альтернативой является замена рекурсивного вызова `interp` на переименование "
"переменных с последующим выполнением оператора `goto`.\n"
"То есть, вместо вызова `interp` и, таким образом, привязки нового экземпляра "
"переменной `x` к части *then*, мы просто присваиваем часть *then* переменной "
"`x`, и переходим к началу подпрограммы `interp`.\n"
"Это работает, потому что мы знаем, что нам больше не нужно использовать "
"старое значение `x`.\n"
"Аналогичный прием используется для устранения рекурсивного вызова для "
"последнего выражения в форме `begin`.\n"
"(Многие программисты были обучены \"структурным программированием\", что "
"операторы `goto` вредны.\n"
"В этом случае `goto` необходим для эффективной реализации низкоуровневой "
"функции.)"

#: in/chapter22.md:621
msgid ""
"The final thing we need to do is explicitly manage Scheme procedures.\n"
"Instead of implementing Scheme procedures as Common Lisp closures, we will "
"define a structure, `proc`, to contain the code, environment, parameter "
"list, and optionally the name of the procedure.\n"
"Then when we are evaluating a procedure call, we can assign the body of the "
"procedure to `x` rather than recursively calling `interp`."
msgstr ""
"Последнее, что нам нужно сделать, это явно управлять процедурами Scheme.\n"
"Вместо реализации процедур Scheme как замыканий Common Lisp мы определим "
"структуру, `proc`, которая будет содержать код, окружающую среду, список "
"параметров и, возможно, имя процедуры.\n"
"Затем, когда мы вычисляем вызов процедуры, мы можем присвоить тело процедуры "
"`x`, а не рекурсивно вызывать `interp`."

#: in/chapter22.md:627
msgid ""
"```lisp\n"
"(defstruct (proc (:print-function print-proc))\n"
"  \"Represent a Scheme procedure\"\n"
"  code (env nil)(name nil) (parms nil))\n"
"```"
msgstr ""

#: in/chapter22.md:634
msgid ""
"The following is a properly tail-recursive interpreter.\n"
"The macro `prog` sets up a `tagbody` within which we can use `go` statements "
"to branch to labels, and it also sets up a `block` from which we can return "
"a value.\n"
"It can also bind variables like `let`, although in this usage, the variable "
"list is empty.\n"
"Any symbol within the body of a `prog` is considered a label.\n"
"In this case, the label : `INTERP` is the target of the branch statements "
"`(GO : INTERP)`.\n"
"I use uppercase to indicate that go-to statements are being used, but this "
"convention has not been widely adopted."
msgstr ""
"Ниже приведен интерпретатор с правильной хвостовой рекурсией.\n"
"Макрос `prog` устанавливает `tagbody`, внутри которого мы можем использовать "
"операторы `go` для перехода к меткам, а также он устанавливает `block`, из "
"которого мы можем возвращать значение.\n"
"Он также может связывать переменные, подобно `let`, хотя в этом случае "
"список переменных пуст.\n"
"Любой символ в теле `prog` считается меткой.\n"
"В этом случае метка :`INTERP` является целью операторов ветвления `(GO: "
"INTERP)`.\n"
"Я использую прописные буквы, чтобы указать, что используются операторы "
"перехода, но это соглашение не получило широкого распространения."

#: in/chapter22.md:656
msgid ""
"```lisp\n"
"(defun interp (x &optional env)\n"
"  \"Evaluate the expression x in the environment env.\n"
"  This version is properly tail-recursive.\"\n"
"  (prog ()\n"
"    :INTERP\n"
"    (return\n"
"      (cond\n"
"        ((symbolp x) (get-var x env))\n"
"        ((atom x) x)\n"
"        ((scheme-macro (first x))\n"
"          (setf x (scheme-macro-expand x)) (go :INTERP))\n"
"        ((case (first x)\n"
"            (QUOTE (second x))\n"
"            (BEGIN (pop x) ; pop off the BEGIN to get at the args\n"
"                      ;; Now interpret all but the last expression\n"
"                      (loop while (rest x) do (interp (pop x) env))\n"
"                      ;; Finally, rename the last expression as x\n"
"                      (setf x (first x))\n"
"                      (GO :INTERP))\n"
"```"
msgstr ""

#: in/chapter22.md:659
msgid ""
"`            (SET!    (set-var!\n"
"(second x) (interp (third x) env) env))`"
msgstr ""

#: in/chapter22.md:685
msgid ""
"```lisp\n"
"            (IF              (setf x (if (interp (second x) env)\n"
"                                (third x)\n"
"                                (fourth x)))\n"
"                      ;; That is, rename the right expression as x\n"
"                      (GO :INTERP))\n"
"            (LAMBDA (make-proc :env env :parms (second x)\n"
"                                :code (maybe-add 'begin (rest2 x))))\n"
"            (t      ;; a procedure application\n"
"                    (let ((proc (interp (first x) env))\n"
"                          (args (mapcar #'(lambda (v) (interp v env))\n"
"                                                      (rest x))))\n"
"                      (if (proc-p proc)\n"
"                            ;; Execute procedure with rename+goto\n"
"                            (progn\n"
"                              (setf x (proc-code proc))\n"
"                              (setf env (extend-env (proc-parms proc) args\n"
"                                                                          (proc-"
"env proc)))\n"
"                              (GO :INTERP))\n"
"                            ;; else apply primitive procedure\n"
"                            (apply proc args))))))))))\n"
"(defun print-proc (proc &optional (stream *standard-output*) depth)\n"
"  (declare (ignore depth))\n"
"  (format stream \"{~a}\" (or (proc-name proc) '??)))\n"
"```"
msgstr ""

#: in/chapter22.md:687
msgid ""
"By tracing the tail-recursive version of `interp`, you can see that calls to "
"`traverse` descend only three recursive levels of `interp`, regardless of "
"the length of the list traversed."
msgstr ""
"Трассируя хвосто-рекурсивную версию `interp`, вы можете видеть, что вызовы "
"`traverse` спускаются только на три рекурсивных уровня `interp`, независимо "
"от длины пройденного списка."

#: in/chapter22.md:692
msgid ""
"Note that we are not claiming that this interpreter allocates no storage "
"when it makes tail-recursive calls.\n"
"Indeed, it wastes quite a bit of storage in evaluating arguments and "
"building environments.\n"
"The claim is that since the storage is allocated on the heap rather than on "
"the stack, it can be reclaimed by the garbage collector.\n"
"So even if `traverse` is applied to an infinitely long list (i.e., a "
"circular list), the interpreter will never run out of space-it will always "
"be able to garbage-collect and continue."
msgstr ""
"Обратите внимание, что мы не утверждаем, что этот интерпретатор не выделяет "
"памяти при выполнении хвостовых рекурсивных вызовов.\n"
"Действительно, он тратит довольно много памяти на вычисление аргументов и "
"построение окружающей среды.\n"
"Утверждается, что поскольку хранилище выделяется в куче, а не в стеке, его "
"может вернуть сборщик мусора.\n"
"Таким образом, даже если `traverse` применяется к бесконечно длинному списку "
"(т. е. круговому списку), интерпретатор никогда не исчерпает пространство - "
"он всегда сможет собрать мусор и продолжить работу."

#: in/chapter22.md:695
msgid ""
"There are many improvements that could be made to this interpreter, but "
"effort is better spent in improving a compiler rather than an interpreter.\n"
"The next chapter does just that."
msgstr ""
"В этот интерпретатор можно внести много улучшений, но лучше потратить усилия "
"на улучшение компилятора, а не интерпретатора.\n"
"Следующая глава посвящена именно этому."

#: in/chapter22.md:697
msgid "## 22.4 Throw, Catch, and Call/cc"
msgstr "## 22.4 Throw, Catch и Call/cc"

#: in/chapter22.md:707
msgid ""
"Tail-recursion is crucial to Scheme.\n"
"The idea is that when the language is guaranteed to optimize tail-recursive "
"calls, then there is no need for special forms to do iteration.\n"
"All loops can be written using recursion, without any worry of overflowing "
"the runtime stack.\n"
"This helps keep the language simple and rules out the `goto` statement, the "
"scourge of the structured programming movement.\n"
"However, there are cases where some kind of nonlocal exit is the best "
"alternative.\n"
"Suppose that some unexpected event happens deep inside your program.\n"
"The best action is to print an error message and pop back up to the top "
"level of your program.\n"
"This could be done trivially with a goto-like statement.\n"
"Without it, every function along the calling path would have to be altered "
"to accept either a valid result or an indication of the exceptional "
"condition, which just gets passed up to the next level."
msgstr ""
"Хвостовая рекурсия имеет решающее значение для Scheme.\n"
"Идея состоит в том, что когда язык гарантированно оптимизирует хвостовые "
"рекурсивные вызовы, тогда нет необходимости в специальных формах для "
"выполнения итераций.\n"
"Все циклы можно писать с помощью рекурсии, не беспокоясь о переполнении "
"стека выполнения.\n"
"Она помогает сохранить простоту языка и исключает использование оператора "
"`goto`, признанного бедствием в движении за структурное программирование.\n"
"Однако бывают случаи, когда какой-то нелокальный выход - лучшая "
"альтернатива.\n"
"Предположим, что в вашей программе происходит какое-то неожиданное событие.\n"
"Лучшее действие - распечатать сообщение об ошибке и вернуться на верхний "
"уровень вашей программы.\n"
"Это можно сделать тривиально с помощью оператора goto.\n"
"Без него каждую функцию на пути вызова пришлось бы изменить, чтобы принимать "
"либо действительный результат, либо указание на исключительное условие, "
"которое просто передается на следующий уровень."

#: in/chapter22.md:712
msgid ""
"In Common Lisp, the functions `throw` and `catch` are provided for this kind "
"of nonlocal exit.\n"
"Scott Zimmerman, the perennial world Frisbee champion, is also a programmer "
"for a Southern California firm.\n"
"He once told me, \"I'm starting to learn Lisp, and it must be a good "
"language because it's got `throw` and `catch` in it.\" Unfortunately for "
"`Scott`, `throw` and `catch` don't refer to Frisbees but to transfer of "
"control.\n"
"They are both special forms, with the following syntax:"
msgstr ""
"В Common Lisp для такого нелокального выхода предусмотрены функции `throw` и "
"`catch`.\n"
"Скотт Циммерман, бессменный чемпион мира по фрисби, также работает "
"программистом в южнокалифорнийской фирме.\n"
"Однажды он сказал мне: \"Я начинаю изучать Лисп, и это должен быть хороший "
"язык, потому что в нем есть  `throw` и `catch`. К сожалению для Скотта, "
"слова `throw` и `catch` относятся не к фрисби, а к передаче управления.\n"
"Это обе специальные формы со следующим синтаксисом:"

#: in/chapter22.md:717
msgid ""
"```lisp\n"
"(catch tag body...)\n"
"(throw tag value)\n"
"```"
msgstr ""

#: in/chapter22.md:722
msgid ""
"The first argument to `catch` is a tag, or label.\n"
"The remaining arguments are evaluated one at a time, and the last one is "
"returned.\n"
"Thus, `catch` is much like `progn`.\n"
"The difference is that if any code in the dynamic extent of the body of the "
"`catch` evaluates the special form `throw`, then control is immediately "
"passed to the enclosing `catch` with the same tag."
msgstr ""
"Первый аргумент `catch` - это тег или метка.\n"
"Остальные аргументы вычисляются по одному, и возвращается значение "
"последнего из них.\n"
"Таким образом, `catch` очень похож на `progn`.\n"
"Разница в том, что если какой-либо код в динамическом экстенте(внутри) тела "
"`catch` вычисляет специальную форму `throw`, то управление немедленно "
"передается за охватывающий `catch` с тем же тегом."

#: in/chapter22.md:724
msgid "For example, the form"
msgstr "Например, форма"

#: in/chapter22.md:729
msgid ""
"```lisp\n"
"(catch 'tag\n"
"  (print 1) (throw 'tag 2) (print 3))\n"
"```"
msgstr ""

#: in/chapter22.md:732
msgid ""
"prints `1` and returns `2`, without going on to print `3`.\n"
"A more representative example is:"
msgstr ""
"печатает `1` и возвращает `2`, не выводя на печать `3`.\n"
"Более представительный пример:"

#: in/chapter22.md:747
msgid ""
"```lisp\n"
"(defun print-table (l)\n"
"  (catch 'not-a-number (mapcar #'print-sqrt-abs l)))\n"
"(defun print-sqrt-abs (x)\n"
"  (print (sqrt (abs (must-be-number x)))))\n"
"(defun must-be-number (x)\n"
"  (if (numberp x) x\n"
"      (throw 'not-a-number \"huh?\")))\n"
"> (print-table '(1 4 -9 x 10 20))\n"
"1\n"
"2\n"
"3\n"
"\"huh?\"\n"
"```"
msgstr ""

#: in/chapter22.md:752
msgid ""
"Here `print-table` calls `print-sqrt-abs`, which calls `must-be-number`.\n"
"The first three times all is fine and the values 1,2,3 get printed.\n"
"The next time `x` is not a number, so the value `\"huh?\"` gets thrown to "
"the tag `not-a-number` established by `catch` in `f`.\n"
"The throw bypasses the pending calls to `abs`, `sqrt`, and `print`, as well "
"as the rest of the call to `mapcar`."
msgstr ""
"Здесь `print-table` вызывает `print-sqrt-abs`, который вызывает `must-be-"
"number`.\n"
"Первые три раза все в порядке, и печатаются значения 1,2,3.\n"
"В следующий раз `x` не будет числом, поэтому значение `\"huh?\"` будет "
"выброшено(throw) в тег `not-a-number`, установленный `catch` в `f`.\n"
"Этот throw(Бросок) обходит ожидающие вызовы к `abs`, `sqrt` и `print`, а "
"также остаток вызова `mapcar`."

#: in/chapter22.md:761
msgid ""
"This kind of control is provided in Scheme with a very general and powerful "
"procedure, `call-with-current-continuation`, which is often abbreviated "
"`call/cc.\n"
"call/cc` is a normal procedure (not a special form like `throw` and `catch`) "
"that takes a single argument.\n"
"Let's call the argument `computation`.\n"
"`computation` must be a procedure of one argument.\n"
"When `call/cc` is invoked, it calls `computation`, and whatever "
"`computation` returns is the value of the call to `call/cc`.\n"
"The trick is that the procedure `computation` also takes an argument (which "
"we'll call `cc`) that is another procedure representing the current "
"continuation point.\n"
"If `cc` is applied to some value, that value is returned as the value of the "
"call to `call/cc`.\n"
"Here are some examples:"
msgstr ""
"Этот вид управления предоставляется в Scheme с помощью очень общей и мощной "
"процедуры, `call-with-current-continue`, которая часто сокращается до `call/"
"cc`.\n"
"`call/cc` - это обычная процедура (не особая форма, такая как `throw` и "
"`catch`), которая принимает единственный аргумент.\n"
"Давайте назовем аргумент `computation`(вычислением).\n"
"`computation` должна быть процедурой с одним аргументом.\n"
"Когда вызывается `call/cc`, он вызывает `computation`, и все, что возвращает "
"`computation`, является значением вызова `call/cc`.\n"
"Уловка заключается в том, что процедура `computation` также принимает "
"аргумент (который мы назовем `cc`), который является другой процедурой, "
"представляющей текущую точку продолжения.\n"
"Если `cc` применяется к какому-либо значению, это значение возвращается как "
"значение вызова `call/cc`.\n"
"Вот некоторые примеры:"

#: in/chapter22.md:767
msgid ""
"```lisp\n"
"> (scheme)\n"
"=> (+  1 (call/cc (lambda (cc) (+  20 300))))\n"
"321\n"
"```"
msgstr ""

#: in/chapter22.md:770
msgid ""
"This example ignores `cc` and just computes `(+  1 (+  20 300 ))`.\n"
"More precisely, it is equivalent to:"
msgstr ""
"В этом примере игнорируется `cc` и вычисляется просто `(+ 1 (+ 20 300))`.\n"
"Точнее, это эквивалент:"

#: in/chapter22.md:775
msgid ""
"```lisp\n"
"((lambda (val) (+  1  val))\n"
"  (+  20 300))\n"
"```"
msgstr ""

#: in/chapter22.md:777
msgid "The next example does make use of `cc`:"
msgstr "В следующем примере действительно используется `cc`:"

#: in/chapter22.md:782
msgid ""
"```lisp\n"
"=> (+  1 (call/cc (lambda (cc) (+  20 (cc 300)))))\n"
"301\n"
"```"
msgstr ""

#: in/chapter22.md:786
msgid ""
"This passes `300` to `cc`, thus bypassing the addition of `20`.\n"
"It effectively throws `300` out of the computation to the catch point "
"established by `call/cc`.\n"
"It is equivalent to:"
msgstr ""
"Он передает `300` в `cc`, минуя добавление `20`.\n"
"Он фактически выбрасывает `300` из вычислений в точку перехвата, "
"установленную `call/cc`.\n"
"Это эквивалентно:"

#: in/chapter22.md:791
msgid ""
"```lisp\n"
"((lambda (val) (+  1  val))\n"
"  300)\n"
"```"
msgstr ""

#: in/chapter22.md:793
msgid "or to:"
msgstr "или в:"

#: in/chapter22.md:800
msgid ""
"```lisp\n"
"((lambda (val) (+  1  val))\n"
"  (catch 'cc\n"
"    ((lambda (v) (+  20 v))\n"
"      (throw 'cc 300))))\n"
"```"
msgstr ""

#: in/chapter22.md:802
msgid "Here's how the `throw/catch` mechanism would look in Scheme:"
msgstr "Вот как будет выглядеть механизм `throw/catch` на Scheme:"

#: in/chapter22.md:808
msgid ""
"```lisp\n"
"(define (print-table l )\n"
"  (call/cc\n"
"    (lambda (escape)\n"
"```"
msgstr ""

#: in/chapter22.md:811
msgid ""
"`      (set!\n"
"not-a-number escape)`"
msgstr ""

#: in/chapter22.md:821
msgid ""
"```lisp\n"
"      (map print-sqrt-abs l))))\n"
"(define (print-sqrt-abs x)\n"
"  (write (sqrt (abs (must-be-number x)))))\n"
"(define (must-be-number x)\n"
"  (if (numberp x) x\n"
"      (not-a-number \"huh?\")))\n"
"(define (map fn l)\n"
"```"
msgstr ""

#: in/chapter22.md:824
msgid ""
"`  (if (null?\n"
"l)`"
msgstr ""

#: in/chapter22.md:830
msgid ""
"```lisp\n"
"      '()\n"
"      (cons (fn (first l))\n"
"              (map fn (rest 1)))))\n"
"```"
msgstr ""

#: in/chapter22.md:834
msgid ""
"The ability to return to a pending point in the computation is useful for "
"this kind of error and interrupt handling.\n"
"However, the truly amazing, wonderful thing about `call/cc` is the ability "
"to return to a continuation point more than once.\n"
"Consider a slight variation:"
msgstr ""
"Возможность вернуться к ожидающей точке вычисления полезна для обработки "
"ошибок и прерываний такого рода.\n"
"Однако поистине удивительная, замечательная особенность `call/cc` - это "
"возможность возвращаться к точке продолжения более одного раза.\n"
"Рассмотрим небольшое изменение:"

#: in/chapter22.md:838
msgid ""
"```lisp\n"
"=> (+  1 (call/cc (lambda (cc)\n"
"```"
msgstr ""

#: in/chapter22.md:841
msgid ""
"`                      (set!\n"
"old-cc  cc)`"
msgstr ""

#: in/chapter22.md:848
msgid ""
"```lisp\n"
"                      (+  20 (cc 300)))))\n"
"301\n"
"=> (old-cc 500)\n"
"501\n"
"```"
msgstr ""

#: in/chapter22.md:852
msgid ""
"Here, we first computed 301, just as before, but along the way saved `cc` in "
"the global variable `old-cc`.\n"
"Afterward, calling `(old-cc 500)` returns (for the second time) to the point "
"in the computation where 1 is added, this time returning `501`.\n"
"The equivalent Common Lisp code leads to an error:"
msgstr ""
"Здесь мы сначала вычислили 301, как и раньше, но попутно сохранили `cc` в "
"глобальной переменной `old-cc`.\n"
"После этого вызов `(old-cc 500)` возвращает (во второй раз) к точке в "
"вычислении, где добавляется 1, на этот раз возвращая `501`.\n"
"Эквивалентный код Common Lisp приводит к ошибке:"

#: in/chapter22.md:859
msgid ""
"```lisp\n"
"> (+  1 (catch 'tag (+  20 (throw 'tag 300))))\n"
"301\n"
"> (throw 'tag 500)\n"
"*Error*: *there was no pending CATCH for the tag TAG*\n"
"```"
msgstr ""

#: in/chapter22.md:861
msgid ""
"In other words, `call/cc`'s continuations have indefinite extent, while "
"throw/catch tags only have dynamic extent."
msgstr ""
"Другими словами, продолжения `call/cc` имеют неограниченную "
"протяженность(extent), в то время как теги throw/catch имеют только "
"динамическую протяженность(extent)."

#: in/chapter22.md:865
msgid ""
"We can use `cal1/cc` to implement automatic backtracking (among other "
"things).\n"
"Suppose we had a special form, `amb`, the \"ambiguous\" operator, which "
"returns one of its arguments, chosen at random.\n"
"We could write:"
msgstr ""
"Мы можем использовать `call/cc` для реализации автоматического поиска с "
"возвратом(backtracking) (среди прочего).\n"
"Предположим, у нас есть специальная форма, `amb`, \"неоднозначный\" "
"оператор, который возвращает один из своих аргументов, выбранных случайным "
"образом.\n"
"Мы могли бы написать:"

#: in/chapter22.md:869
msgid ""
"```lisp\n"
"(define (integer) (amb 1 (+  1 (integer))))\n"
"```"
msgstr ""

#: in/chapter22.md:873
msgid ""
"and a call to `integer` would return some random positive integer.\n"
"In addition, suppose we had a function, `fail`, which doesn't return at all "
"but instead causes execution to continue at a prior `amb` point, with the "
"other choice taken.\n"
"Then we could write succinct[2](#fn0015) backtracking code like the "
"following:"
msgstr ""
"а вызов `integer` вернет некоторое случайное положительное целое число.\n"
"Вдобавок предположим, что у нас есть функция `fail`, которая вообще не "
"возвращается, а вместо этого заставляет выполняться продолжение с предыдущей "
"точки `amb` с другим выбором.\n"
"Тогда мы могли бы написать краткий [2](#fn0015) код отслеживания с "
"возвратом, как показано ниже:"

#: in/chapter22.md:878
msgid ""
"```lisp\n"
"(define (prime)\n"
"  (let ((n (integer)))\n"
"```"
msgstr ""

#: in/chapter22.md:881
msgid ""
"`  (if (prime?\n"
"n) n (fail))))`"
msgstr ""

#: in/chapter22.md:885
msgid ""
"If `prime?` is a predicate that returns true only when its argument is a "
"prime number, then prime will always return some `prime` number, decided by "
"generating random integers.\n"
"While this looks like a major change to the language-adding backtracking and "
"nondeterminism-it turns out that `amb` and `fail` can be implemented quite "
"easily with `cal1/cc`.\n"
"First, we need to make `amb` be a macro:"
msgstr ""
"Если `prime?` - это предикат, который возвращает истину только тогда, когда "
"его аргумент - простое(prime) число, то prime всегда будет возвращать "
"некоторое `простое(prime)`число, определенное путем генерации случайных "
"целых чисел.\n"
"Хотя это выглядит как серьезное изменение языка - добавление обратного "
"отслеживания и недетерминизма - оказывается, что `amb` и `fail` могут быть "
"довольно легко реализованы с помощью `cal1/cc`.\n"
"Во-первых, нам нужно сделать `amb` макросом:"

#: in/chapter22.md:890
msgid ""
"```lisp\n"
"(def-scheme-macro amb (x y)\n"
"  '(random-choice (lambda () ,x) (lambda () ,y))))\n"
"```"
msgstr ""

#: in/chapter22.md:898
msgid ""
"The rest is pure Scheme.\n"
"We maintain a list of `backtrack-points`, which are implemented as functions "
"of no arguments.\n"
"To backtrack, we just call one of these functions.\n"
"That is what `fail` does.\n"
"The function `choose-first` takes two functions and pushes the second, along "
"with the proper continuation, on `backtrack-points`, and then calls the "
"first, returning that value.\n"
"The function `random-choice` is what `amb` expands into: it decides which "
"choice is first, and which is second.\n"
"(Note that the convention in Scheme is to write global variables like "
"`backtrack-points` without asterisks.)"
msgstr ""
"В остальном это чистая Scheme.\n"
"Мы ведем список `backtrack-points`(точек возврата), которые реализованы как "
"функции без аргументов.\n"
"Чтобы вернуться назад, мы просто вызываем одну из этих функций.\n"
"Вот что делает `fail`.\n"
"Функция `choose-first` принимает две функции и подталкивает вторую вместе с "
"надлежащим продолжением к `backtrack-points`, а затем вызывает первую, "
"возвращая это значение.\n"
"Функция `random-choice` - это то, во что расширяется `amb`: она решает, "
"какой выбор будет первым, а какой - вторым.\n"
"(Обратите внимание, что в Scheme принято записывать глобальные переменные, "
"такие как `backtrack-points`, без звездочек.)"

#: in/chapter22.md:904
msgid ""
"```lisp\n"
"(define backtrack-points nil)\n"
"(define (fail)\n"
"  (let ((last-choice (car backtrack-points)))\n"
"```"
msgstr ""

#: in/chapter22.md:907
msgid ""
"`    (set!\n"
"backtrack-points (cdr backtrack-points))`"
msgstr ""

#: in/chapter22.md:918
msgid ""
"```lisp\n"
"    (last-choice)))\n"
"(define (random-choice f g)\n"
"  (if (=  1 (random 2))\n"
"      (choose-first f g)\n"
"      (choose-first g f)))\n"
"(define (choose-first f g)\n"
"  (call/cc\n"
"    (lambda (k)\n"
"```"
msgstr ""

#: in/chapter22.md:921
msgid ""
"`      (set!\n"
"backtrack-points`"
msgstr ""

#: in/chapter22.md:926
msgid ""
"```lisp\n"
"            (cons (lambda () (k (g))) backtrack-points))\n"
"      (f))))\n"
"```"
msgstr ""

#: in/chapter22.md:931
msgid ""
"This implements chronological backtracking, as in Prolog.\n"
"However, we actually have the freedom to do other kinds of backtracking as "
"well.\n"
"Instead of having `fail` take the first element of `backtrack-points`, we "
"could choose a random element instead.\n"
"Or, we could do some more complex analysis to choose a good backtrack point."
msgstr ""
"Это реализует хронологическое обратное отслеживание(backtracking), как в "
"Prolog.\n"
"Однако на самом деле у нас есть свобода делать и другие виды обратного "
"отслеживания.\n"
"Вместо того, чтобы `fail` брал первый элемент из `backtrack-points`, мы "
"могли бы выбрать случайный элемент.\n"
"Или мы могли бы провести более сложный анализ, чтобы выбрать хорошую точку "
"возврата."

#: in/chapter22.md:937
msgid ""
"`call/cc` can be used to implement a variety of control structures.\n"
"As another example, many Lisp implementations provide a `reset` function "
"that aborts the current computation and returns control to the top-level "
"read-eval-print loop.\n"
"reset can be defined quite easily using `call/cc`.\n"
"The trick is to capture a continuation that is at the top level and save it "
"away for future use.\n"
"The following expression, evaluated at the top level, saves the appropriate "
"continuation in the value of reset:"
msgstr ""
"`call/cc` может использоваться для реализации различных структур "
"управления.\n"
"В качестве другого примера, многие реализации Lisp предоставляют функцию "
"`reset`, которая прерывает текущее вычисление и возвращает управление циклу "
"чтения-оценки-печати верхнего уровня.\n"
"reset можно довольно легко определить с помощью `call/cc`.\n"
"Хитрость заключается в том, чтобы захватить продолжение, которое находится "
"на верхнем уровне, и сохранить его для использования в будущем.\n"
"Следующее выражение, вычисленное на верхнем уровне, сохраняет "
"соответствующее продолжение в значении reset:"

#: in/chapter22.md:940
msgid ""
"`(call/cc (lambda (cc) (set!\n"
"reset (lambda ()`"
msgstr ""

#: in/chapter22.md:944
msgid ""
"```lisp\n"
"                                (cc \"Back to top level\")))))\n"
"```"
msgstr ""

#: in/chapter22.md:946
msgid "**Exercise 22.2 [m]** Can you implement `call/cc` in Common Lisp?"
msgstr ""
"**Exercise 22.2 [m]** Можете ли вы реализовать `call/cc` в Common Lisp?"

#: in/chapter22.md:948
msgid ""
"**Exercise 22.3 [s]** Can you implement `amb` and `fail` in Common Lisp?"
msgstr ""

#: in/chapter22.md:950
msgid "**Exercise 22.4 [m]**`fail` could be written"
msgstr ""

#: in/chapter22.md:952
msgid ""
"`(define (fail) ((pop backtrack-points)))` if we had the pop macro in Scheme."
msgstr ""

#: in/chapter22.md:954
msgid "Write `pop.`"
msgstr ""

#: in/chapter22.md:956
msgid "## 22.5 An Interpreter Supporting Call/cc"
msgstr "## 22.5 Интерпретатор с поддержкой Call/cc"

#: in/chapter22.md:962
msgid ""
"It is interesting that the more a host language has to offer, the easier it "
"is to write an interpreter.\n"
"Perhaps the hardest part of writing a Lisp interpreter (or compiler) is "
"garbage collection.\n"
"By writing our interpreter in Lisp, we bypassed the problem all together-the "
"host language automatically collects garbage.\n"
"Similarly, if we are using a Common Lisp that is properly tail-recursive, "
"then our interpreter will be too, without taking any special steps.\n"
"If not, the interpreter must be rewritten to take care of tail-recursion, as "
"we have seen above."
msgstr ""
"Интересно, что чем больше может предложить хост-язык, тем проще написать "
"интерпретатор.\n"
"Возможно, самая сложная часть написания интерпретатора (или компилятора) "
"Лиспа - это сборка мусора.\n"
"Написав наш интерпретатор на Лиспе, мы полностью обошли эту проблему - "
"основной язык автоматически собирает мусор.\n"
"Точно так же, если мы используем Common Lisp, который имеет хвостовую "
"рекурсию, то наш интерпретатор тоже будет использовать её, без каких-либо "
"специальных действий.\n"
"Если нет, то интерпретатор должен быть переписан, чтобы позаботиться о "
"хвостовой рекурсии, как мы видели выше."

#: in/chapter22.md:969
msgid ""
"It is the same with `call/cc`.\n"
"If our host language provides continuations with indefinite extent, then it "
"is trivial to implement `call/cc`.\n"
"If not, we have to rewrite the whole interpreter, so that it explicitly "
"handles continuations.\n"
"The best way to do this is to make `interp` a function of three arguments: "
"an expression, an environment, and a continuation.\n"
"That means the top level will have to change too.\n"
"Rather than having `interp` return a value that gets printed, we just pass "
"it the function `print` as a continuation:"
msgstr ""
"То же самое и с `call/cc`.\n"
"Если наш основной язык обеспечивает предоставляет продолжения с "
"неограниченным экстентом(временем существования), то реализовать `call/cc` "
"тривиально.\n"
"Если нет, мы должны переписать весь интерпретатор, чтобы он явно обрабатывал "
"продолжения.\n"
"Лучший способ сделать это - сделать `interp` функцией трех аргументов: "
"выражения, окружения и продолжения.\n"
"Значит, придется изменить и верхний уровень.\n"
"Вместо того, чтобы заставлять `interp` возвращать значение, которое "
"распечатывается, мы просто передаем ему функцию `print` как продолжение:"

#: in/chapter22.md:978
msgid ""
"```lisp\n"
"(defun scheme ()\n"
"    \"A Scheme read-eval-print loop (using interp).\n"
"    Handles call/cc by explicitly passing continuations.\"\n"
"    (init-scheme-interp)\n"
"    (loop (format t \"~&==> \")\n"
"              (interp (read) nil #'print)))\n"
"```"
msgstr ""

#: in/chapter22.md:983
msgid ""
"Now we are ready to tackle `interp`.\n"
"For clarity, we will base it on the non-tail-recursive version.\n"
"The cases for symbols, atoms, macros, and `quote` are almost the same as "
"before.\n"
"The difference is that the result of each computation gets passed to the "
"continuation, `cc`, rather than just being returned."
msgstr ""
"Теперь мы готовы заняться `interp`.\n"
"Для ясности мы возьмём за базу его на не хвостово-рекурсивную версию.\n"
"Случаи символов, атомов, макросов и `quote`(цитаты) почти такие же, как и "
"раньше.\n"
"Разница в том, что результат каждого вычисления передается продолжению `cc`, "
"а не просто возвращается."

#: in/chapter22.md:991
msgid ""
"The other cases are all more complex, because they all require explicit "
"representation of continuations.\n"
"That means that calls to `interp` cannot be nested.\n"
"Instead, we call `interp` with a continuation that includes another call to "
"`interp`.\n"
"For example, to interpret (`if p x y`), we first call `interp` on the second "
"element of the form, the predicate `p`.\n"
"The continuation for this call is a function that tests the value of `p` and "
"interprets either `x` or `y` accordingly, using the original continuation "
"for the recursive call to `interp`.\n"
"The other cases are similar.\n"
"One important change is that Scheme procedures are implemented as Lisp "
"functions where the first argument is the continuation:"
msgstr ""
"Остальные случаи более сложные, потому что все они требуют явного "
"представления продолжений.\n"
"Это означает, что вызовы `interp` не могут быть вложенными.\n"
"Вместо этого мы вызываем `interp` с продолжением, которое включает еще один "
"вызов `interp`.\n"
"Например, чтобы интерпретировать (`if p x y`), мы сначала вызываем `interp` "
"для второго элемента формы, предиката `p`.\n"
"Продолжением этого вызова является функция, которая проверяет значение `p` и "
"интерпретирует соответственно `x` или `y`, используя исходное продолжение "
"для рекурсивного вызова `interp`.\n"
"Остальные случаи аналогичны.\n"
"Одним из важных изменений является то, что процедуры Scheme реализованы как "
"функции Lisp, где первым аргументом является продолжение:"

#: in/chapter22.md:1007
msgid ""
"```lisp\n"
"(defun interp (x env cc)\n"
"  \"Evaluate the expression x in the environment env,\n"
"  and pass the result to the continuation cc.\"\n"
"  (cond\n"
"    ((symbolp x) (funcall cc (get-var x env)))\n"
"    ((atom x) (funcall cc x))\n"
"    ((scheme-macro (first x))\n"
"      (interp (scheme-macro-expand x) env cc))\n"
"    ((case (first x)\n"
"          (QUOTE (funcall cc (second x)))\n"
"          (BEGIN (interp-begin (rest x) env cc))\n"
"(SET!    (interp (third x) env\n"
"                    #'(lambda (val)\n"
"```"
msgstr ""

#: in/chapter22.md:1010
msgid ""
"`                          (funcall cc (set-var!\n"
"(second x)`"
msgstr ""

#: in/chapter22.md:1027
msgid ""
"```lisp\n"
"                                                                        val "
"env)))))\n"
"(IF      (interp (second x) env\n"
"                    #'(lambda (pred)\n"
"                          (interp (if pred (third x) (fourth x))\n"
"                                env cc))))\n"
"(LAMBDA (let ((parms (second x))\n"
"                  (code (maybe-add 'begin (rest2 x))))\n"
"              (funcall\n"
"                cc\n"
"                #'(lambda (cont &rest args)\n"
"                    (interp code\n"
"                              (extend-env parms args env)\n"
"                              cont)))))\n"
"(t      (interp-call x env cc))))))\n"
"```"
msgstr ""

#: in/chapter22.md:1029
msgid ""
"A few auxiliary functions are defined, in the same continuation-passing "
"style:"
msgstr ""
"Определены несколько вспомогательных функций в том же стиле передачи "
"продолжения:"

#: in/chapter22.md:1055
msgid ""
"```lisp\n"
"(defun interp-begin (body env cc)\n"
"  \"Interpret each element of BODY, passing the last to CC.\"\n"
"  (interp (first body) env\n"
"          #'(lambda (val)\n"
"              (if (null (rest body))\n"
"                      (funcall cc val)\n"
"                      (interp-begin (rest body) env cc)))))\n"
"(defun interp-call (call env cc)\n"
"  \"Interpret the call (f x...) and pass the result to CC.\"\n"
"  (map-interp call env\n"
"                  #'(lambda (fn-and-args)\n"
"                      (apply (first fn-and-args)\n"
"                                cc\n"
"                                (rest fn-and-args)))))\n"
"(defun map-interp (list env cc)\n"
"  \"Interpret each element of LIST, and pass the list to CC.\"\n"
"  (if (null list)\n"
"        (funcall cc nil)\n"
"        (interp (first list) env\n"
"                  #'(lambda (x)\n"
"                      (map-interp (rest list) env\n"
"                                #'(lambda (y)\n"
"                                (funcall cc (cons x y))))))))\n"
"```"
msgstr ""

#: in/chapter22.md:1057
msgid ""
"Because Scheme procedures expect a continuation as the first argument, we "
"need to redefine `init-scheme-proc` to install procedures that accept and "
"apply the continuation:"
msgstr ""
"Поскольку процедуры Scheme ожидают продолжения в качестве первого аргумента, "
"нам нужно переопределить `init-scheme-proc` для установки процедур, которые "
"принимают и применяют продолжение:"

#: in/chapter22.md:1065
msgid ""
"```lisp\n"
"(defun init-scheme-proc (f)\n"
"  \"Define a Scheme procedure as a corresponding CL function.\"\n"
"  (if (listp f)\n"
"      (set-global-var! (first f) (symbol-function (second f)))\n"
"      (set-global-var! f (symbol-function f))))\n"
"```"
msgstr ""

#: in/chapter22.md:1075
msgid ""
"We also need to define `call/cc`.\n"
"Think for a moment about what `call/cc` must do.\n"
"Like all Scheme procedures, it takes the current continuation as its first "
"argument.\n"
"The second argument is a procedure-a computation to be performed.\n"
"`call/cc` performs the computation by calling the procedure.\n"
"This is just a normal call, so it uses the current continuation.\n"
"The tricky part is what `call/cc` passes the computation as its argument.\n"
"It passes an escape procedure, which can be invoked to return to the same "
"point that the original call to `call/cc` would have returned to.\n"
"Once the working of `call/cc` is understood, the implementation is obvious:"
msgstr ""
"Нам также нужно определить `call/cc`.\n"
"Подумайте на мгновение о том, что должен делать `call/cc`.\n"
"Как и все процедуры Scheme, он принимает текущее продолжение в качестве "
"первого аргумента.\n"
"Второй аргумент - это процедура - вычисление, которое нужно выполнить.\n"
"`call/cc` выполняет вычисление, вызывая процедуру.\n"
"Это обычный вызов, поэтому он использует текущее продолжение.\n"
"Сложность состоит в том, что `call/cc` передает вычисление в качестве "
"аргумента.\n"
"Он передает процедуру выхода, которая может быть вызвана для возврата в ту "
"же точку, в которую был бы возвращен исходный вызов `call/cc`.\n"
"Как только работа `call/cc` будет понятна, реализация станет очевидной:"

#: in/chapter22.md:1084
msgid ""
"```lisp\n"
"(defun call/cc (cc computation)\n"
"  \"Make the continuation accessible to a Scheme procedure.\"\n"
"  (funcall computation cc\n"
"           ;; Package up CC into a Scheme function:\n"
"           #'(lambda (cont val)\n"
"               (declare (ignore cont))\n"
"               (funcall cc val))))"
msgstr ""

#: in/chapter22.md:1089
msgid ""
";; Now install call/cc in the global environment\n"
"(set-global-var! 'call/cc #'call/cc)\n"
"(set-global-var! 'call-with-current-continuation #'call/cc)\n"
"```"
msgstr ""

#: in/chapter22.md:1091
msgid "## 22.6 History and References"
msgstr "## 22.6 История и Ссылки"

#: in/chapter22.md:1098
msgid ""
"Lisp interpreters and AI have a long history together.\n"
"MIT AI Lab Memo No.\n"
"1 ([McCarthy 1958](B9780080571157500285.xhtml#bb0790)) was the first paper "
"on Lisp.\n"
"McCarthy's students were working on a Lisp compiler, had written certain "
"routines-`read`, `print`, etc.-`in` assembly language, and were trying to "
"develop a full Lisp interpreter in assembler.\n"
"Sometime around the end of 1958, McCarthy wrote a theoretical paper showing "
"that Lisp was powerful enough to write the universal function, `eval`.\n"
"A programmer on the project, Steve Russell, saw the paper, and, according to "
"McCarthy:"
msgstr ""

#: in/chapter22.md:1102
msgid ""
"> Steve Russell said, look, why don't I program this `eval` and-you remember "
"the interpreter-and I said to him, ho, ho, you're confusing theory with "
"practice, this `eval` is intended for reading not for computing.\n"
"But he went ahead and did it.\n"
"That is, he compiled the `eval` in my paper into 704 machine code fixing "
"bugs and then advertised this as a Lisp interpreter, which it certainly was."
"[3](#fn0020)"
msgstr ""

#: in/chapter22.md:1107
msgid ""
"So the first Lisp interpreter was the result of a programmer ignoring his "
"boss's advice.\n"
"The first compiler was for the Lisp 1.5 system ([McCarthy et al.\n"
"1962](B9780080571157500285.xhtml#bb0815)).\n"
"The compiler was written in Lisp; it was probably the first compiler written "
"in its own language."
msgstr ""

#: in/chapter22.md:1112
msgid ""
"Allen's *Anatomy of lisp* (1978) was one of the first overviews of Lisp "
"implementation techniques, and it remains one of the best.\n"
"However, it concentrates on the dynamic-scoping Lisp dialects that were in "
"use at the time.\n"
"The more modern view of a lexically scoped Lisp was documented in an "
"influential pair of papers by Guy Steele ([1976a](B9780080571157500285."
"xhtml#bb1130),[b](B9780080571157500285.xhtml#bb1135)).\n"
"His papers \"Lambda: the ultimate goto\" and \"Compiler optimization based "
"on viewing lambda as rename plus goto\" describe properly tail-recursive "
"interpreters and compilers."
msgstr ""

#: in/chapter22.md:1116
msgid ""
"The Scheme dialect was invented by Gerald Sussman and Guy Steele around 1975 "
"(see their MIT AI Memo 349).\n"
"The *Revised*4*Report on the Algorithmic Language Scheme* ([Clinger et al.\n"
"1991](B9780080571157500285.xhtml#bb0205)) is the definitive reference manual "
"for the current version of Scheme."
msgstr ""

#: in/chapter22.md:1121
msgid ""
"[Abelson and Sussman (1985)](B9780080571157500285.xhtml#bb0010) is probably "
"the best introduction to computer science ever written.\n"
"It may or may not be a coincidence that it uses Scheme as the programming "
"language.\n"
"It includes a Scheme interpreter.\n"
"Winston and Horn's *Lisp* (1989) also develops a Lisp interpreter."
msgstr ""

#: in/chapter22.md:1125
msgid ""
"The `amb` operator for nondeterministic choice was proposed by [John "
"McCarthy (1963)](B9780080571157500285.xhtml#bb0800) and used in SCHEMER "
"([Zabih et al.\n"
"1987](B9780080571157500285.xhtml#bb1440)), a nondeterministic Lisp.\n"
"[Ruf and Weise (1990)](B9780080571157500285.xhtml#bb1015) present another "
"implementation of backtracking in Scheme that incorporates all of logic "
"programming."
msgstr ""

#: in/chapter22.md:1127
msgid "## 22.7 Exercises"
msgstr "## 22.7 Упражнения"

#: in/chapter22.md:1130
msgid ""
"**Exercise  22.5 [m]** While Scheme does not provide full-blown support for "
"optional and keyword arguments, it does support rest parameters.\n"
"Modify the interpreter to support the Scheme syntax for rest parameters:"
msgstr ""
"**Exercise  22.5 [m]** Хотя Scheme не обеспечивает полноценной поддержки "
"необязательных аргументов и аргументов ключевых слов, он поддерживает "
"параметры rest.\n"
"Измените интерпретатор для поддержки синтаксиса Scheme для параметров rest:"

#: in/chapter22.md:1135
msgid ""
"| Scheme                     | Common Lisp                       |\n"
"|----------------------------|-----------------------------------|\n"
"| (`lambda x`*body*)         | (`lambda` (`&rest x`) *body*)     |\n"
"| (`lambda (x y . z)`*body*) | (`lambda` (`x y &rest z`) *body*) |"
msgstr ""

#: in/chapter22.md:1139
msgid ""
"**Exercise  22.6 [h]** The representation of environments is somewhat "
"wasteful.\n"
"Currently it takes 3*n* cons cells to represent an environment with *n* "
"variables.\n"
"Change the representation to take less space."
msgstr ""

#: in/chapter22.md:1144
msgid ""
"**Exercise  22.7 [m]** As we've implemented macros, they need to be expanded "
"each time they are encountered.\n"
"This is not so bad for the compiler-you expand the source code and compile "
"it, and then never refer to the source code again.\n"
"But for the interpreter, this treatment of macros is most unsatisfactory: "
"the work of macroexpansion must be done again and again.\n"
"How can you eliminate this duplicated effort?"
msgstr ""

#: in/chapter22.md:1149
msgid ""
"**Exercise  22.8 [m]** It turns out Scheme allows some additional syntax in "
"`let` and `cond`.\n"
"First, there is the \"named-let\" expression, which binds initial values for "
"variables but also defines a local function that can be called within the "
"body of the `let`.\n"
"Second, `cond` recognizes the symbol => when it is the second element of a "
"cond clause, and treats it as a directive to pass the value of the test "
"(when it is not false) to the third element of the clause, which must be a "
"function of one argument.\n"
"Here are two examples:"
msgstr ""

#: in/chapter22.md:1160
msgid ""
"```lisp\n"
"(define (fact n)\n"
"  ;; Iterative factorial; does not grow the stack\n"
"  (let loop ((result 1) (i n))\n"
"    (if (= i 0) result (loop (* result i) (- i 1)))))\n"
"(define (lookup key alist)\n"
"  ;; Find key's value in alist\n"
"  (cond ((assoc key alist) => cdr)\n"
"          (else #f)))\n"
"```"
msgstr ""

#: in/chapter22.md:1162
msgid "These are equivalent to:"
msgstr ""

#: in/chapter22.md:1177
msgid ""
"```lisp\n"
"(define (fact n)\n"
"  (letrec\n"
"    ((loop (lambda (result i)\n"
"                (if (= i 0)\n"
"                    result\n"
"                    (loop (* result i) (- i 1))))))\n"
"    (loop 1 n)))\n"
"(define (lookup key alist)\n"
"  (let ((g0030 (assoc key alist)))\n"
"    (if g0030\n"
"        (cdr g0030)\n"
"        #f)))\n"
"```"
msgstr ""

#: in/chapter22.md:1179
msgid "Write macro definitions for `let` and `cond` allowing these variations."
msgstr ""

#: in/chapter22.md:1182
msgid ""
"**Exercise  22.9 [h]** Some Scheme implementations permit `define` "
"statements inside the body of a `lambda` (and thus of a `define`, `let`, "
"`let*`, or `letrec` as well).\n"
"Here is an example:"
msgstr ""

#: in/chapter22.md:1187
msgid ""
"```lisp\n"
"(define (length l)\n"
"  (define (len l n)\n"
"```"
msgstr ""

#: in/chapter22.md:1190
msgid ""
"`    (if (null?\n"
"l) n (len (cdr l) (+ n 1))))`"
msgstr ""

#: in/chapter22.md:1194
msgid ""
"```lisp\n"
"  (len l 0))\n"
"```"
msgstr ""

#: in/chapter22.md:1197
msgid ""
"The internal definition of len is interpreted not as defining a global name "
"but rather as defining a local name as if with `letrec`.\n"
"The above definition is equivalent to:"
msgstr ""

#: in/chapter22.md:1202
msgid ""
"```lisp\n"
"(define (length l)\n"
"  (letrec ((len (lambda (l n)\n"
"```"
msgstr ""

#: in/chapter22.md:1205
msgid ""
"`                      (if (null?\n"
"l) n (len (cdr l) (+ n 1))))))`"
msgstr ""

#: in/chapter22.md:1209
msgid ""
"```lisp\n"
"    (len l 0)))\n"
"```"
msgstr ""

#: in/chapter22.md:1211
msgid ""
"Make changes to the interpreter to allow this kind of internal definition."
msgstr ""

#: in/chapter22.md:1214
msgid ""
"**Exercise  22.10** Scheme programmers are often disdainful of the "
"`function` or `#`' notation in Common Lisp.\n"
"Is it possible (without changing the compiler) to make Common Lisp accept "
"`(lambda ( ) ... )` instead of `#` ' `(lambda ( ) ... )` and `fn` instead of "
"`#`'`fn?`"
msgstr ""

#: in/chapter22.md:1218
msgid ""
"**Exercise  22.11 [m]** The top level of the continuation-passing version of "
"`scheme` includes the call: `(interp (read)``nil` #'`print)`.\n"
"Will this always result in some value being printed?\n"
"Or is it possible that the expression read might call some escape function "
"that ignores the value without printing anything?"
msgstr ""

#: in/chapter22.md:1220
msgid ""
"**Exercise  22.12 [h]** What would have to be added or changed to turn the "
"Scheme interpreter into a Common Lisp interpreter?"
msgstr ""

#: in/chapter22.md:1223
msgid ""
"**Exercise  22.13 [h]** How would you change the interpreter to allow for "
"multiple values?\n"
"Explain how this would be done both for the first version of the interpreter "
"and for the continuation-passing version."
msgstr ""

#: in/chapter22.md:1225
msgid "## 22.8 Answers"
msgstr "## 22.8 Ответы"

#: in/chapter22.md:1227
msgid ""
"**Answer 22.2** There is no way to implement a full `call/cc` to Common "
"Lisp, but the following works for cases where the continuation is only used "
"with dynamic extent:"
msgstr ""
"**Answer 22.2** Невозможно реализовать полный `call/cc` для Common Lisp, но "
"следующее работает для случаев, когда продолжение используется только с "
"динамическим экстентом:"

#: in/chapter22.md:1237
msgid ""
"```lisp\n"
"(defun call/cc (cc computation)\n"
"  \"Make the continuation accessible to a Scheme procedure.\"\n"
"  (funcall computation cc\n"
"           ;; Package up CC into a Scheme function:\n"
"           #'(lambda (cont val)\n"
"               (declare (ignore cont))\n"
"               (funcall cc val))))\n"
"```"
msgstr ""

#: in/chapter22.md:1240
msgid ""
"**Answer 22.3** No.\n"
"`fail` requires continuations with dynamic extent."
msgstr ""

#: in/chapter22.md:1243
msgid ""
"**Answer 22.5** We need only modify `extend` - `env` to know about an atomic "
"`vars` list.\n"
"While we're at it, we might as well add some error checking:"
msgstr ""

#: in/chapter22.md:1256
msgid ""
"```lisp\n"
"(defun extend-env (vars vals env)\n"
"  \"Add some variables and values to an environment.\"\n"
"  (cond ((null vars)\n"
"          (assert (null vals) ( ) \"Too many arguments supplied\")\n"
"          env)\n"
"          ((atom vars)\n"
"            (cons (list vars vals) env))\n"
"          (t (assert (rest vals) ( ) \"Too few arguments supplied\")\n"
"              (cons (list (first vars) (first vals))\n"
"                      (extend-env (rest vars) (rest vals) env)))))\n"
"```"
msgstr ""

#: in/chapter22.md:1262
msgid ""
"**Answer 22.6** Storing the environment as an association list, `((*var "
"val*)...)`, makes it easy to look up variables with `assoc`.\n"
"We could save one cons cell per variable just by changing to `((*var* . "
"*val*)...)`.\n"
"But even better is to switch to a different representation, one presented by "
"Steele and Sussman in *The Art of the Interpreter* (1978).\n"
"In this representation we switch from a single list of var/val pairs to a "
"list of frames, where each frame is a var-list/val-list pair.\n"
"It looks like this:"
msgstr ""

#: in/chapter22.md:1268
msgid ""
"```lisp\n"
"(((*var*...) . (*val*...))\n"
"  ((*var*...) . (*val*...))\n"
"...)\n"
"```"
msgstr ""

#: in/chapter22.md:1270
msgid "Now `extend-env` is trivial:"
msgstr ""

#: in/chapter22.md:1276
msgid ""
"```lisp\n"
"(defun extend-env (vars vals env)\n"
"  \"Add some variables and values to an environment.\"\n"
"  (nconc (mapcar #'list vars vals) env))\n"
"```"
msgstr ""

#: in/chapter22.md:1281
msgid ""
"The advantage of this approach is that in most cases we already have a list "
"of variables (the procedure's parameter list) and values (from the `mapcar` "
"of `interp` over the arguments).\n"
"So it is cheaper to just cons these two lists together, rather than "
"arranging them into pairs.\n"
"Of course, `get-var` and `set-var`!\n"
"become more complex."
msgstr ""

#: in/chapter22.md:1284
msgid ""
"**Answer 22.7** One answer is to destructively alter the source code as it "
"is macro-expanded, so that the next time the source code is interpreted, it "
"will already be expanded.\n"
"The following code takes care of that:"
msgstr ""

#: in/chapter22.md:1296
msgid ""
"```lisp\n"
"(defun scheme-macro-expand (x)\n"
"  (displace x (apply (scheme-macro (first x)) (rest x))))\n"
"(defun displace (old new)\n"
"  \"Destructively change old cons-cell to new value.\"\n"
"  (if (consp new)\n"
"        (progn (setf (car old) (car new))\n"
"                      (setf (cdr old) (cdr new))\n"
"                      old)\n"
"        (displace old '(begin ,new))))\n"
"```"
msgstr ""

#: in/chapter22.md:1299
msgid ""
"One drawback to this approach is that the user's source code is actually "
"changed, which may make debugging confusing.\n"
"An alternative is to expand into something that keeps both the original and "
"macro-expanded code around:"
msgstr ""

#: in/chapter22.md:1307
msgid ""
"```lisp\n"
"(defun displace (old new)\n"
"  \"Destructively change old to a DISPLACED structure.\"\n"
"  (setf (car old) 'DISPLACED)\n"
"  (setf (cdr old) (list new old))\n"
"  old)\n"
"```"
msgstr ""

#: in/chapter22.md:1310
msgid ""
"This means that `DISPLACED` is a new special form, and we need a clause for "
"it in the interpreter.\n"
"It would look something like this:"
msgstr ""

#: in/chapter22.md:1317
msgid ""
"```lisp\n"
"(case (first x)\n"
"  ...\n"
"  (DISPLACED (interp (second x) env))\n"
"  ...\n"
"```"
msgstr ""

#: in/chapter22.md:1319
msgid ""
"We'd also need to modify the printing routines to print just `old` whenever "
"they see `(displaced old new)`."
msgstr ""

#: in/chapter22.md:1321
msgid "**Answer 22.8**"
msgstr ""

#: in/chapter22.md:1332
msgid ""
"```lisp\n"
"(def-scheme-macro let (vars &rest body)\n"
"  (if (symbolp vars)\n"
"        ;; named let\n"
"        (let ((f vars) (vars (first body)) (body (rest body)))\n"
"          '(letrec ((,f (lambda ,(mapcar #'first vars) .,body)))\n"
"                (,f .,(mapcar #'second vars))))\n"
"        ;; \"regular\" let\n"
"        '((lambda ,(mapcar #'first vars) . ,body)\n"
"```"
msgstr ""

#: in/chapter22.md:1335
msgid ""
"`          .\n"
",(mapcar #'second vars)))))`"
msgstr ""

#: in/chapter22.md:1353
msgid ""
"```lisp\n"
"(def-scheme-macro cond (&rest clauses)\n"
"  (cond ((null clauses) nil)\n"
"        ((length=1 (first clauses))\n"
"         `(or ,(first clauses) (cond .,(rest clauses))))\n"
"        ((starts-with (first clauses) 'else)\n"
"         `(begin .,(rest (first clauses))))\n"
"        ((eq (second (first clauses)) '=>)\n"
"            (assert (= (length (first clauses)) 3))\n"
"            (let ((var (gensym)))\n"
"            '(let ((,var ,(first (first clauses))))\n"
"                (if ,var (,(third (first clauses)) ,var)\n"
"                          (cond .,(rest clauses))))))\n"
"        (t `(if ,(first (first clauses))\n"
"                (begin .,(rest (first clauses)))\n"
"                (cond .,(rest clauses))))))\n"
"```"
msgstr ""

#: in/chapter22.md:1355
msgid ""
"**Answer 22.10** It is easy to define `lambda` as a macro, eliminating the "
"need for `#'(lambda ...)`:"
msgstr ""

#: in/chapter22.md:1360
msgid ""
"```lisp\n"
"(defmacro lambda (args &rest body)\n"
"  '(function (lambda .args .@body)))\n"
"```"
msgstr ""

#: in/chapter22.md:1363
msgid ""
"If this were part of the Common Lisp standard, I would gladly use it.\n"
"But because it is not, I have avoided it, on the grounds that it can be "
"confusing."
msgstr ""

#: in/chapter22.md:1365
msgid ""
"It is also possible to write a new function-defining macro that would do the "
"following type of expansion:"
msgstr ""

#: in/chapter22.md:1370
msgid ""
"```lisp\n"
"(defn double (x) (* 2 x)) =>\n"
"(defparameter double (defun double (x) (* 2 x)))\n"
"```"
msgstr ""

#: in/chapter22.md:1374
msgid ""
"This makes `double` a special variable, so we can write `double` instead of "
"`#'double`.\n"
"But this approach is not recommended-it is dangerous to define special "
"variables that violate the asterisk convention, and the Common Lisp compiler "
"may not be able to optimize special variable references the way it can "
"`function` special forms.\n"
"Also, this approach would not interact properly with `flet` and `labels`."
msgstr ""

#: in/chapter22.md:1376
msgid "----------------------"
msgstr ""

#: in/chapter22.md:1380
msgid ""
"[1](#xfn0010) One writes `numberp` because there is no hyphen in `number` "
"but `random-state-p` because there is a hyphen in `random-state`.\n"
"However, `defstruct` concatenates `-p` in all its predicates, regardless of "
"the presence of a hyphen in the structure's name.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter22.md:1383
msgid ""
"[2](#xfn0015) although inefficient\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter22.md:1386
msgid ""
"[3](#xfn0020) McCarthy's words from a talk on the history of Lisp, 1974, "
"recorded by [Stoyan (1984)](B9780080571157500285.xhtml#bb1205).\n"
"!!!(p) {:.ftnote1}"
msgstr ""
