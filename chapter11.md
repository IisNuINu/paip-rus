# Глава 11
## Логическое Программирование

> Не стоит знать язык, который не влияет на ваше представление о программировании.

> -Alan Perlis

Lisp-это основной язык для работы с ИИ, но он ни в коем случае не единственный.
Другой сильный соперник-Пролог, название которого происходит от "программирование основанное на логике". [1](#fn0015) идея логического программирования заключается в том, что программист должен сформулировать отношения, описывающие проблему и ее решение.
Эти отношения действуют как ограничения на алгоритмы, которые могут решить проблему, но сама система, а не программист, отвечает за детали алгоритма.
Напряженность между "программированием" и "логикой" будет рассмотрена в [главе 14](B9780080571157500145.xhtml), но пока можно с уверенностью сказать, что пролог является приближением к идеальной цели логического программирования.
Пролог занял удобную нишу между традиционным языком программирования и языком логических спецификаций.
Он опирается на три важные идеи:

*   Prolog поощряет использование единой *унифицированной/универсальной/единой базы данных. Хорошие компиляторы обеспечивают эффективный доступ к этой базе данных, уменьшая потребность в векторах, хэш-таблицах, списках свойств и других структурах данных, с которыми программист Lisp должен иметь дело подробно.
Потому что он основан на идее баз данных, Пролог *реляционнен*, в то время как Лисп (и многие языки) *функциональны.* В прологе мы будем представлять то, как "население Сан-Франциско составляет 750000" как отношение.
В Лиспе мы были бы склонны написать функцию `population(население), которая принимает город в качестве входных данных и возвращает число.
Отношения более гибкие; их можно использовать не только для поиска населения Сан-Франциско, но и, скажем, для поиска городов с населением более 500 000 человек.

*   Пролог предоставляет *логические переменные* вместо "обычных" переменных.
Логическая переменная связана с *унификацией/универсальностью*, а не с присвоением.
Однажды связанная логическая переменная никогда не может измениться.
Таким образом, они больше похожи на переменные математики.
Существование логических переменных и унификация(единая база данных) позволяют логическому программисту формулировать уравнения, ограничивающие задачу (как в математике), без необходимости указывать порядок вычислений (как в операторах присваивания).

*   Prolog обеспечивает *автоматический поиск с возвратом.* В Лиспе каждый вызов функции возвращает одно значение (если только программист не принимает специальные меры, чтобы он возвращал несколько значений или список значений).
В Prolog каждый запрос приводит к поиску отношений в базе данных, которые удовлетворяют запросу.
Если их несколько, они считаются по одному.
Если запрос включает несколько отношений, например, "какой город с населением более 500 000 и является столицей штата?", Prolog просмотрит отношение "население", чтобы найти город с населением более 500 000 человек.
Затем для каждого найденного города он проверяет отношение "capital"(столица), чтобы узнать, является ли город столицей.
Если это так, Prolog печатает город; в противном случае он *возвращается назад,* пытается найти другой город в отношении "население".
Таким образом, Prolog освобождает программиста от забот как о том, как хранятся данные, так и о том, как их искать.
Для некоторых проблем наивный автоматический поиск будет слишком неэффективным, и программисту придется переформулировать проблему.
Но в идеале программа Prolog устанавливает ограничения для решения, не указывая в деталях, как решения достигаются.

Эта глава служит двум целям: она предупреждает читателя о возможности написания определенных программ на Prolog, а не на Lisp, и представляет реализации трех важных идей Prolog, чтобы их можно было использовать (независимо или вместе) в программах на Lisp.
Пролог представляет собой интересный, иной взгляд на процесс программирования.
По этой причине это стоит знать.
В следующих главах мы увидим несколько полезных приложений подхода Пролога.

## 11.1 Идея 1: Единая/Универсальная база данных

Первая важная идея Пролога должна быть знакома читателям этой книги: манипулирование хранимой базой данных утверждений.
В Прологе утверждения называются *предложениями*(clauses), и их можно разделить на два типа: *факты*(facts), которые устанавливают отношения, которые имеют место между некоторыми объектами, и *правила*(rules), которые используются для утверждения случайных фактов.
Вот изображения двух фактов о населении Сан-Франциско и столицы Калифорнии.
Отношениями являются "население" и "столица", а объектами, которые участвуют в этих отношениях, являются `SF, 750000`, `Sacramento` и `CA`:

```lisp
(population SF 750000)
(capital Sacramento CA)
```

Мы используем синтаксис Лиспа, потому что нам нужен интерпретатор Пролога, который можно встроить в Лисп.
Реальная нотация Пролога будет `population` (`sf, 750000`).
Вот несколько фактов, касающихся отношения `likes`(любит):

```lisp
(likes Kim Robin)
(likes Sandy Lee)
(likes Sandy Kim)
(likes Robin cats)
```

Эти факты можно истолковать как означающие, что Ким нравится Робин, Сэнди нравятся и Ли, и Ким, а Робин любит кошек.
Нам нужен какой-то способ сообщить Лиспу, что они должны интерпретироваться как факты Пролога, а не как вызов функции Лисп.
Мы будем использовать макрос <-, чтобы отмечать факты.
Думайте об этом как о стрелке назначения/присваивания, которая добавляет факт в базу данных:

```lisp
(<- (likes Kim Robin))
(<- (likes Sandy Lee))
(<- (likes Sandy Kim))
(<- (likes Robin cats))
```

Одно из основных различий между Prolog и Lisp зависит от разницы между отношениями и функциями.
В Лиспе мы бы определили функцию `любит`, чтобы (` любит 'Sandy`) возвращал список (`Lee Kim`).
Если бы мы хотели получить доступ к информации другим способом, мы бы определили другую функцию, скажем, `likers-of`, чтобы (` likers-of 'Lee`) возвращал (`Sandy`).
В Прологе у нас есть одно отношение `likes` вместо нескольких функций.
Это единственное отношение можно использовать, как если бы оно было множеством функций, создавая разные запросы.
Например, запрос (`likes Sandy ?who`) удовлетворяется с помощью `?who`, привязанному к `Lee или Kim`, а запрос (` like ?who `Lee`) удовлетворяется с `?Who` привязанному к `Sandy`.

Второй тип предложения в базе данных Пролога - это  *правило.* Правила устанавливают условные факты.
Например, мы можем представить правило, согласно которому Сэнди любит всех, кто любит кошек, следующим образом:

```lisp
(<- (likes Sandy ?x) (likes ?x cats))
```

Это можно прочесть двояко.
Рассматриваемое как логическое утверждение, оно читается: "Для любого x Сэнди любит x, если x любит кошек". Это *декларативная* интерпретация.
Рассматриваемое как часть программы на Прологе, оно читается так: "Если вы когда-нибудь захотите показать, что Сэнди нравится какой-то x, один из способов сделать это - показать, что x любит кошекА". Это *процедурная* интерпретация. 
Она называется интерпретацией *обратной цепочки*, потому что человек рассуждает в обратном направлении от цели (Сэнди любит x) к предпосылкам (x любит кошек).
Символ <- подходит для обеих интерпретаций: это стрелка, указывающая на логический смысл, и она указывает назад, чтобы указать обратную цепочку.

Декларативная форма может дать более одной процедурной интерпретации.
(Мы сделали это в [главе 1](B9780080571157500017.xhtml), где правила грамматики использовались для генерации как строк слов, так и деревьев синтаксического анализа.) Приведенное выше правило могло быть интерпретировано процедурно как "Если вы когда-нибудь обнаружите, что какой-то `x` любит кошек, значит, Сэнди любит `x` ". Это будет *прямая цепочка:* рассуждение от предпосылки к выводу.
Оказывается, Пролог выполняет исключительно обратную цепочку.
Многие экспертные системы используют исключительно прямую цепочку, а некоторые системы используют их сочетание.

Крайнее левое выражение в предложении называется *заголовком*, а остальные - *телом*. В этом представлении факт - это просто правило, не имеющее тела; то есть факт верен, несмотря ни на что.
В общем, формулировка предложения следующая:

(<- *head body*...)

В предложении утверждается, что голова верна только в том случае, если все цели в теле верны.
Например, в следующем пункте говорится, что Ким нравятся все, кому нравятся и Ли, и Ким:

```lisp
(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
```

Это можно читать так:

*For any* x, *deduce that*`Kim likes x`(*Для любого* x, *вывести, что* `Ким любит x`)

*if it can be proved that*`x likes Lee`*and* x `likes Kim.` (*если можно доказать, что* `x любит Ли` *и* x `любит Ким`.)

## 11.2 Идея 2: Унификация логических переменных

Унификация - это прямое расширение идеи сопоставления с образцом.
Функции сопоставления с образцом, которые мы видели до сих пор, всегда сопоставляли образец (выражение, содержащее переменные) с постоянным выражением (без переменных).
При унификации два образца(шаблона), каждый из которых может содержать переменные, сопоставляются друг с другом.
Вот пример разницы между сопоставлением с образцом и объединением:

`> (pat-match '(?x + ?y) '(2 + 1))`=> `((?Y . 1) (?X . 2))`

`> (unify '(?x + 1) '(2 + ?y))`=> `((?Y . 1) (?X . 2))`

В рамках унификации переменные (например, `?x` и `?y` выше) называются *логическими переменными*. Как и обычным переменным, логической переменной может быть присвоено значение или она может быть несвязанной.
Разница в том, что логическая переменная никогда не может быть изменена.
Как только ей присвоено значение, она сохраняет это значение.
Любая попытка унифицировать его с другим значением приводит к неудаче.
Можно объединить(унифицировать) переменную с одним и тем же значением более одного раза, точно так же, как можно было выполнить сопоставление с образцом (?x + ?x) с (`2 + 2`).

Разница между простым сопоставлением с образцом и унификацией заключается в том, что унификация позволяет сравнивать/сопоставлять две переменные друг с другом.
Две переменные останутся несвязанными, но становятся эквивалентными.
Если какая-либо переменная впоследствии связывается со значением, то обе переменные принимают это значение.
В следующем примере переменные `?x` и `?y` сравниваются путем привязки `?x` к `?y`:

`> (unify '(f ?x) '(f ?y))`=> `((?X . ?Y))`

Унификацию(Объединение) можно использовать для сложных рассуждений.
Например, если у нас есть два уравнения, *a* + *a* = 0 и *x* + *y* = *y* и если мы знаем, что эти два уравнения объединяются(унифицируются), то мы можем заключить, что *a*, *x* и *y* равны 0.
Версия `unify`, которую мы определим, показывает этот результат путем привязки `?y` к `0`,`?x` к `?y` и `?a` к `?x`.
Мы также определим функцию `unifier`, которая показывает структуру, полученную в результате объединения(унификации) двух структур.

`> (unify '(?a + ?a = 0) '(?x + ?y = ?y))`=>

```lisp
((?Y . 0) (?X . ?Y) (?A . ?X))
```

`> (unifier '(?a + ?a = 0) '(?x + ?y = ?y))`=> `(0 + 0 = 0)`

Чтобы не увлечься силой унификации(объединения), рекомендуется проанализировать, что именно дает унификация.
Она *действительно* предоставляет способ заявить, что переменные равны другим переменным или выражениям.
Она *не* обеспечивает способ автоматического решения уравнений или применения ограничений, отличных от равенства.
Следующий пример проясняет, что при унификации символ + рассматривается только как неинтерпретированный атом, а не как оператор сложения:

`> (unifier '(?a + ?a = 2) '(?x + ?y = ?y))`=> `(2 + 2 = 2)`

Перед разработкой кода для `unify`, мы повторяем здесь код, взятый из утилиты сопоставления с образцом ([глава 6](B9780080571157500066.xhtml)):

```lisp
(defconstant fail nil "Indicates pat-match failure")
(defconstant no-bindings '((t . t))
  "Indicates pat-match success, with no variables.")
(defun variable-p (x)
  "Is x a variable (a symbol beginning with '?')?"
  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))
(defun get-binding (var bindings)
  "Find a (variable . value) pair in a binding list."
  (assoc var bindings))
(defun binding-val (binding)
  "Get the value part of a single binding."
  (cdr binding))
(defun lookup (var bindings)
  "Get the value part (for var) from a binding list."
  (binding-val (get-binding var bindings)))
(defun extend-bindings (var val bindings)
  "Add a (var . value) pair to a binding list."
  (cons (cons var val)
              ;; Once we add a "real" binding,
              ;; we can get rid of the dummy no-bindings
              (if (and (eq bindings no-bindings))
                      nil
                      bindings)))
(defun match-variable (var input bindings)
  "Does VAR match input? Uses (or updates) and returns bindings."
  (let ((binding (get-binding var bindings)))
  (cond ((not binding) (extend-bindings var input bindings))
              ((equal input (binding-val binding)) bindings)
              (t fail))))
```

Далее следует функция `unify`; она идентична `pat-match` (как определено на стр. 180), за исключением добавления строки, отмеченной `***`.
Функция `unify-variable` также следует за функцией `match-variable`:

```lisp
(defun unify (x y &optional (bindings no-bindings))
  "See if x and y match with given bindings."
  (cond ((eq bindings fail) fail)
              ((variable-p x) (unify-variable x y bindings))
              ((variable-p y) (unify-variable y x bindings)) ;***
              ((eql x y) bindings)
              ((and (consp x) (consp y))
                (unify (rest x) (rest y)
                              (unify (first x) (first y) bindings)))
              (t fail)))
(defun unify-variable (var x bindings)
  "Unify var with x, using (and maybe extending) bindings."
  ;; Warning - buggy version
  (if (get-binding var bindings)
    (unify (lookup var bindings) x bindings)
    (extend-bindings var x bindings)))
```

К сожалению, это определение не совсем верное.
Оно обрабатывает простые примеры:

`> (unify '(?x + 1) '(2 + ?y))`=> `((?Y . 1) (?X . 2))`

`> (unify '?x '?y)`=> `((?X . ?Y))`

`> (unify '(?x ?x) '(?y ?y))`=> `((?Y . ?Y) (?X . ?Y))`

но есть несколько патологических случаев, с которыми оно не может бороться:

```lisp
> (unify '(?x ?x ?x) '(?y ?y ?y))
>>Trap #043622 (PDL-OVERFLOW REGULAR)
The regular push-down list has overflowed.
```

`While in the function GET-BINDING`<= `UNIFY-VARIABLE`<= `UNIFY`

Проблема здесь в том, что как только `?y` привязывается к самому себе, вызов `unify` внутри `unify-variable` приводит к бесконечному циклу.
Но сопоставление `?y` с самим собой всегда должно быть успешным, поэтому мы можем переместить проверку равенства в `unify` перед проверкой переменной.
Это предполагает, что равные переменные - это `eql`, допустимое предположение для переменных, реализованных как символы (но будьте осторожны, если вы когда-нибудь решите реализовать переменные каким-либо другим способом).

```lisp
(defun unify (x y &optional (bindings no-bindings))
  "See if x and y match with given bindings."
  (cond ((eq bindings fail) fail)
    ((eql x y) bindings) ;*** moved this line
    ((variable-p x) (unify-variable x y bindings))
    ((variable-p y) (unify-variable y x bindings))
    ((and (consp x) (consp y))
    (unify (rest x) (rest y)
            (unify (first x) (first y) bindings)))
      (t fail)))
```

Вот несколько тестов:

`> (unify '(?x ?x) '(?y ?y))`=> `((?X . ?Y))`

`> (unify '(?x ?x ?x) '(?y ?y ?y))`=> `((?X . ?Y))`

`> (unify '(?x ?y) '(?y ?x))`=> `((?Y . ?X) (?X . ?Y))`

```lisp
> (unify '(?x ?y a) '(?y ?x ?x))
>>Trap #043622 (PDL-OVERFLOW REGULAR)
The regular push-down list has overflowed.
```

`While in the function GET-BINDING`<= `UNIFY-VARIABLE`<= `UNIFY`

Мы отодвинули проблему, но не решили ее.
Разрешить и `(?y . ?y)`, и `(?x . ?y)` в одном списке привязки так же плохо, как разрешить `(?y . ?y)`.
Чтобы избежать этой проблемы, политика не должна иметь дело с привязанными переменными, а должна иметь дело с их значениями, как указано в списке привязки.
Функция `unify-variable` не может реализовать эту политику.
У неё есть проверка, которая получает привязку для var, когда это связанная переменная, но также должна быть проверка, которая получает значение `x`, когда` x` является связанной переменной:

```lisp
(defun unify-variable (var x bindings)
  "Unify var with x, using (and maybe extending) bindings."
  (cond ((get-binding var bindings)
      (unify (lookup var bindings) x bindings))
    ((and (variable-p x) (get-binding x bindings)) ;***
      (unify var (lookup x bindings) bindings)) ;***
    (t (extend-bindings var x bindings))))
```

Вот еще несколько тестовых примеров:

`> (unify '(?x ?y) '(?y ?x))`=> `((?X . ?Y))`

`> (unify '(?x ?y a) '(?y ?x ?x))`=> `((?Y . A) (?X . ?Y))`

Вроде проблема решена.
Теперь попробуем новую задачу:

`> (unify '?x '(f ?x))`=> `((?X F ?X))`

Здесь `((?X F ?X))` действительно означает `((?X . ((F ?X))))`, поэтому `?X` связан с (`F ?X`).
Это представляет собой круговое, бесконечное унифицирование/объединение.
Некоторые версии Пролога, особенно Пролог II ([Giannesini et al.
1986] (B9780080571157500285.xhtml # bb0460)), предоставляют интерпретацию таких структур, но определить семантику бесконечных структур сложно.

Самый простой способ справиться с такими бесконечными структурами - просто запретить их.
Этот запрет может быть реализован путем модификации унификатора(unifier) так, чтобы он терпел неудачу при каждой попытке унифицировать переменную со структурой, содержащей эту переменную.
Это известно в кругах унификации как *(проверка происхождения/occurs check).* На практике проблема возникает редко, и, поскольку она может добавить много вычислительной сложности, большинство систем Prolog проигнорировали проверку происхождения.
Это означает, что эти системы потенциально могут давать неверные ответы.
В последней версии `unify` предоставляется переменная, позволяющая пользователю включать или отключать проверку происхождения.

```lisp
(defparameter *occurs-check* t "Should we do the occurs check?")

(defun unify (x y &optional (bindings no-bindings))
  "See if x and y match with given bindings."
  (cond ((eq bindings fail) fail)
        ((eql x y) bindings)
        ((variable-p x) (unify-variable x y bindings))
        ((variable-p y) (unify-variable y x bindings))
        ((and (consp x) (consp y))
         (unify (rest x) (rest y)
                (unify (first x) (first y) bindings)))
        (t fail)))

(defun unify-variable (var x bindings)
  "Unify var with x, using (and maybe extending) bindings."
  (cond ((get-binding var bindings)
         (unify (lookup var bindings) x bindings))
        ((and (variable-p x) (get-binding x bindings))
         (unify var (lookup x bindings) bindings))
        ((and *occurs-check* (occurs-check var x bindings))
         fail)
        (t (extend-bindings var x bindings))))

(defun occurs-check (var x bindings)
  "Does var occur anywhere inside x?"
  (cond ((eq var x) t)
        ((and (variable-p x) (get-binding x bindings))
         (occurs-check var (lookup x bindings) bindings))
        ((consp x) (or (occurs-check var (first x) bindings)
                       (occurs-check var (rest x) bindings)))
        (t nil)))
```

Теперь мы рассмотрим, как будет использоваться `unify`.
В частности, нам нужна функция для замены(подстановки) списка привязки в выражение.
Первоначально мы выбрали списки ассоциаций в качестве реализации привязок из-за доступности функции `sublis`.
По иронии судьбы, `sublis` больше не будет работать, потому что переменные могут быть привязаны к другим переменным, которые, в свою очередь, привязаны к выражениям.
Функция `subst-bindings` действует как `sublis`, за исключением того, что заменяет рекурсивные привязки.

```lisp
(defun subst-bindings (bindings x)
  "Substitute the value of variables in bindings into x,
  taking recursively bound variables into account."
  (cond ((eq bindings fail) fail)
        ((eq bindings no-bindings) x)
        ((and (variable-p x) (get-binding x bindings))
         (subst-bindings bindings (lookup x bindings)))
        ((atom x) x)
        (t (reuse-cons (subst-bindings bindings (car x))
                       (subst-bindings bindings (cdr x))
                       x))))
```

Теперь давайте попробуем `unify` на нескольких примерах:

`> (unify '(?x ?y a) '(?y ?x ?x))`=> `((?Y . A) (?X . ?Y))`

`> (unify '?x '(f ?x))`=> `NIL`

`> (unify '(?x ?y) '((f ?y) (f ?x)))`=> `NIL`

`> (unify '(?x ?y ?z) '((?y ?z) (?x ?z) (?x ?y)))`=> `NIL`

`> (unify 'a 'a)`=> `((T . T))`

Наконец, функция `unifier` вызывает `unify` и подставляет полученный список привязки в один из аргументов.
Выбор `x` произвольный; такой же результат будет при подстановке списка привязки на `y`.

```lisp
(defun unifier (x y)
 "Return something that unifies with both x and y (or fail)."
 (subst-bindings (unify x y) x))
```

Вот несколько примеров `unifier`:

`> (unifier '(?x ?y a) '(?y ?x ?x))`=> `(A A A)`

```lisp
> (unifier '((?a * ?x ^ 2) + (?b * ?x) + ?c)
```

`                '(?z + (4 * 5) + 3))`=>

```lisp
((?A * 5 ^ 2) + (4 * 5) + 3)
```

Когда *`occurs-check`(проверка происхождени)* это false, мы получаем следующие ответы:

`> (unify '?x '(f ?x))`=> `((?X F ?X))`

`> (unify '(?x ?y) '((f ?y) (f ?x)))`=> `((?Y F ?X) (?X F ?Y))`

```lisp
> (unify '(?x ?y ?z) '((?y ?z) (?x ?z) (?x ?y))) => ((?Z ?X ?Y) (?Y ?X ?Z) (?X ?Y  ?Z))
```

### Программирование с помощью Prolog

В предложениях Пролога замечательно то, что их можно использовать для выражения отношений, которые мы обычно воспринимаем как "программы", а не как "данные". Например, мы можем определить отношение "member(участник/член)", которое имеет место между элементом и списком, содержащим этот элемент.
Точнее, элемент является членом списка, если он является либо первым элементом списка(first), либо членом остальной части списка(member rest).
Это определение можно почти дословно перевести на Пролог:

```lisp
(<- (member ?item (?item . ?rest)))
(<- (member ?item (?x . ?rest)) (member ?item ?rest))
```

Конечно, мы можем написать подобное определение на Лиспе.
Наиболее заметное различие заключается в том, что Prolog позволяет нам помещать шаблоны в заголовок предложения, поэтому нам не нужны распознаватели, такие как `consp` или аксессоры, такие как `first` и `rest`.
В остальном определение Лиспа аналогично: [2](# fn0020)

```lisp
(defun lisp-member (item list)
  (and (consp list)
  (or (eql item (first list))
    (lisp-member item (rest list)))))
```

Если бы мы написали код Пролога, не используя возможности работы с образцом, он был бы больше похож на версию Лиспа:

```lisp
(<- (member ?item ?list)
  (= ?list (?item . ?rest)))
(<- (member ?item ?list)
  (= ?list (?x . ?rest))
  (member ?item ?rest))
```

Если мы определим или в Прологе, мы напишем версию, которая явно является синтаксическим вариантом версии Лиспа.

```lisp
(<- (member ?item ?list)
  (= ?list (?first . ?rest))
  (or (= ?item ?first)
  (member ?item ?rest)))
```

Давайте посмотрим, как работает версия `member` на языке Prolog.
Представьте, что у нас есть интерпретатор Пролога, которому можно задать запрос с помощью макроса ?-, и что было введено определение `member`.
Тогда мы увидим:

```lisp
> (?- (member 2 (1 2 3)))
Yes;
> (?- (member 2 (1 2 3 2 1)))
Yes;
Yes;
```

Ответ на первый вопрос - "да", потому что 2 является членом остальной части списка.
Во втором запросе дважды ответ "да", потому что 2 появляется в списке дважды.
Это немного удивительно для программистов на Лиспе, но все еще кажется довольно близкое соответствие между `member` Пролога и Lisp. Однако есть вещи, которые `member` Пролога может делать, а Lisp не может:

```lisp
> (?- (member ?x (1 2 3)))
?X = 1;
?X = 2;
?X = 3;
```

Здесь `member` используется не как предикат, а как генератор элементов в списке.
В то время как функции Lisp всегда сопоставляются с заданным входом (или входами) с заданным выходом, отношения Пролога могут использоваться несколькими способами.
Для `member` мы видим, что первый аргумент, `?x`, может быть либо входом, либо выходом, в зависимости от указанной цели.
Эта возможность использовать одну спецификацию как функцию, работающую в нескольких разных направлениях, является очень гибкой функцией Prolog.
(К сожалению, хотя она очень хорошо работает для простых отношений, таких как `member`, на практике она не работает для больших программ.
Например, очень сложно разработать компилятор и автоматически заставить его работать как дизассемблер.)

Теперь перейдем к реализации интерпретатора Пролога, как показано на [рис. 11.1](#f0010).
Первый вариант реализации - это представление правил и фактов.
Мы построим единую базу данных предложений, не отделяя правила от фактов.
Простейшее представление предложений - это cons-ячейка, содержащая голову и тело.
Для фактов тело будет пустым.

| []()                                             |
|--------------------------------------------------|
| ![f11-01](images/chapter11/f11-01.jpg)           |
| Рисунок 11.1: Глоссарий интерпретатора Пролога |

(ed: this should be a markdown table)

```lisp
;; Clauses are represented as (head . body) cons cells
(defun clause-head (clause) (first clause))
(defun clause-body (clause) (rest clause))
```

Следующий вопрос - как проиндексировать предложения.
Вспомните процедурную интерпретацию предложения: когда мы хотим доказать голову, мы можем сделать это, доказав тело.
Это говорит о том, что предложения следует индексировать по их заголовкам.
Каждое предложение будет хранить в списке свойств предиката заголовк предложения.
Поскольку база данных теперь распределена по списку свойств различных символов, мы представляем всю базу данных как список символов, хранящихся как значение `*db-predicates*`.

```lisp
;; Clauses are stored on the predicate's plist
(defun get-clauses (pred) (get pred 'clauses))
(defun predicate (relation) (first relation))

(defvar *db-predicates* nil
  "A list of all predicates stored in the database.")
```

Теперь нам нужен способ добавления нового предложения.
Работа разделена на макрос <-, который обеспечивает пользовательский интерфейс, и функцию add-clause, которая выполняет эту работу.
Стоит определить макрос для добавления предложений, потому что фактически мы определяем новый язык: Prolog-In-Lisp.
В этом языке есть только две синтаксические конструкции: макрос <- для добавления предложений и макрос ?- для выполнения запросов.

```lisp
(defmacro <- (&rest clause)
  "Add a clause to the data base."
  `(add-clause ',clause))

(defun add-clause (clause)
  "Add a clause to the data base, indexed by head's predicate."
  ;; The predicate must be a non-variable symbol.
  (let ((pred (predicate (clause-head clause))))
    (assert (and (symbolp pred) (not (variable-p pred))))
    (pushnew pred *db-predicates*)
    (setf (get pred 'clauses)
          (nconc (get-clauses pred) (list clause)))
    pred))
```

Теперь все, что нам нужно, - это способ удалить предложения, и база данных будет полной.

```lisp
(defun clear-db ()
  "Remove all clauses (for all predicates) from the data base."
  (mapc #'clear-predicate *db-predicates*))

(defun clear-predicate (predicate)
  "Remove the clauses for a single predicate."
  (setf (get predicate 'clauses) nil))
```

База данных бесполезна без способа извлечения данных, а также их размещения.
Функция prove будет использоваться, чтобы доказать, что данная цель либо соответствует факту, который находится в базе данных напрямую, либо может быть получена из правил.
Чтобы доказать цель, сначала найдите все предложения-кандидаты для этой цели.
Для каждого кандидата проверьте, совпадает ли цель с заголовком предложения.
Если это так, постарайтесь доказать все цели в теле предложения.
Для фактов, в теле не будет целей, поэтому успех будет немедленным(непосредственным).
Для правил, цели в теле нужно подтверждать по одной, следя за тем, чтобы привязки из предыдущего шага сохранялись.
Реализация проста:

```lisp
(defun prove (goal bindings)
  "Return a list of possible solutions to goal."
  (mapcan #'(lambda (clause)
              (let ((new-clause (rename-variables clause)))
                (prove-all (clause-body new-clause)
                           (unify goal (clause-head new-clause) bindings))))
          (get-clauses (predicate goal))))

(defun prove-all (goals bindings)
  "Return a list of solutions to the conjunction of goals."
  (cond ((eq bindings fail) fail)
        ((null goals) (list bindings))
        (t (mapcan #'(lambda (goal1-solution)
                       (prove-all (rest goals) goal1-solution))
                   (prove (first goals) bindings)))))
```

Сложность состоит в том, что нам нужен способ отличить переменную `?x` в одном предложении от другой переменной `?x` в другом предложении.
В противном случае переменная, используемая в двух разных предложениях в ходе доказательства, должна была бы принимать одно и то же значение в каждом предложении, что было бы ошибкой.
Так же, как аргументы функции могут иметь разные значения при разных рекурсивных вызовах функции, переменные в предложении могут принимать разные значения в разных рекурсивных применениях.
Самый простой способ сохранить различия между переменными - просто переименовать все переменные в каждом предложении перед его использованием.
Функция `rename-variables` делает следующее: [3](#fn0025)

```lisp
(defun rename-variables (x)
  "Replace all variables in x with new ones."
  (sublis (mapcar #'(lambda (var) (cons var (gensym (string var))))
                  (variables-in x))
          x))
```

`rename-variables` использует функцию gensym, которая генерирует новый символ при каждом вызове.
Этот символ не интернирован ни в одном пакете, что означает, что нет опасности, что программист напечатает символ с тем же именем.
Здесь определены предикат `variables-in` и его вспомогательная функция:

```lisp
(defun variables-in (exp)
  "Return a list of all the variables in EXP."
  (unique-find-anywhere-if #'variable-p exp))

(defun unique-find-anywhere-if (predicate tree
                                &optional found-so-far)
  "Return a list of leaves of tree satisfying predicate,
  with duplicates removed."
  (if (atom tree)
      (if (funcall predicate tree)
          (adjoin tree found-so-far)
          found-so-far)
      (unique-find-anywhere-if
        predicate
        (first tree)
        (unique-find-anywhere-if predicate (rest tree)
                                 found-so-far))))
```

Наконец, нам нужен хороший интерфейс для функций доказательства.
Мы будем использовать `?-` в качестве макроса для ввода запроса.
С таким же успехом запрос может допускать сочетание целей, поэтому `?-` вызовет `prove-all`(доказывать все).
Вместе `<-` и `?-` определяют полный синтаксис нашего языка Prolog-In-Lisp.

```lisp
(defmacro ?- (&rest goals) '(prove-all ',goals no-bindings))
```

Теперь мы можем ввести все предложения, приведенные в предыдущем примере:

```lisp
(<- (likes Kim Robin))
(<- (likes Sandy Lee))
(<- (likes Sandy Kim))
(<- (likes Robin cats))
(<- (likes Sandy ?x) (likes ?x cats))
(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
(<- (likes ?x ?x))
```

Чтобы спросить, кого любит Сэнди, мы воспользуемся:

```lisp
> (?- (likes Sandy ?who))
(((?WHO . LEE))
  ((?WHO . KIM))
  ((?X2856 . ROBIN) (?WHO .?X2856))
  ((?X2860 . CATS) (?X2857 CATS) (?X2856 . SANDAY) (?WHO ?X2856)
  ((?X2865 . CATS) (?X2856 ?X2865)((?WHO . ?X2856))
  (?WHO . SANDY) (?X2867 . SANDAY)))
```

Возможно вы удивитесь, но существует шесть ответов.
Первые два ответа - Ли и Ким, потому что факты.
Следующие три проистекают из предложения, что Сэнди любит всех, кто любит кошек.
Во-первых, Робин - это ответ, потому что Робин любит кошек.
Чтобы увидеть, что Робин является ответом, мы должны распутать привязки:  `?who` привязан к `?x2856`, который, в свою очередь, привязан к Robin.

Теперь нас ждут некоторые сюрпризы: Сэнди внесена в список по следующим причинам: (1) Сэнди любит всех/тех, кто любит кошек, (2) кошки любят кошек, потому что все любят себя, (3) поэтому Сэнди любит кошек, и (4) поэтому Сэнди нравится Сэнди.
Кошки - это ответ из-за шага (2), и, наконец, Сэнди - это снова ответ из-за пункта о симпатии к себе.
Обратите внимание, что результатом запроса является список решений, где каждое решение соответствует разному способу подтверждения истинности запроса.
Сэнди появляется дважды, потому что есть два разных способа показать, что Сэнди нравится Сэнди.
Порядок появления решений определяется порядком поиска.
Prolog ищет решения сверху вниз, слева направо.
Поиск по предложениям выполняется сверху вниз, поэтому первые введенные предложения являются первыми опробованными.
В конкретном предложении поиск выполняется слева направо.
При использовании предложения (`likes Kim ?x`) Prolog сначала пытается найти `x`, которому нравится Ли, а затем посмотреть, нравится ли `x` Ким.

Результат от `prove-all` не очень красивый.
Мы можем исправить это, определив новую функцию `top-level-prove`, которая, как и раньше, вызывает `prove-all`, но затем передает список решений в `show-prolog-solutions`, которая распечатывает их в более читаемом виде.
Обратите внимание, что `show-prolog-solutions` не возвращает значений: `(values)`. Это означает, что цикл read-eval-print не будет печатать ничего, если `(values)` является результатом вызова верхнего уровня.

```lisp
(defmacro ?- (&rest goals) `(top-level-prove ',goals))

(defun top-level-prove (goals)
  "Prove the goals, and print variables readably."
  (show-prolog-solutions
    (variables-in goals)
    (prove-all goals no-bindings)))

(defun show-prolog-solutions (vars solutions)
  "Print the variables in each of the solutions."
  (if (null solutions)
      (format t "~&No.")
      (mapc #'(lambda (solution) (show-prolog-vars vars solution))
            solutions))
  (values))

(defun show-prolog-vars (vars bindings)
  "Print each variable with its binding."
  (if (null vars)
      (format t "~&Yes")
      (dolist (var vars)
        (format t "~&~a = ~a" var
                (subst-bindings bindings var))))
  (princ ";"))
```

Теперь попробуем несколько запросов:

```lisp
> (?- (likes Sandy ?who))
?WHO = LEE;
?WHO = KIM;
?WHO = ROBIN;
?WHO = SANDY;
?WHO = CATS;
?WHO = SANDY;
> (?- (likes ?who Sandy))
?WHO = SANDY;
?WHO = KIM;
?WHO = SANDY;
> (?- (likes Robin Lee))
No.
```

Первый вопрос снова спрашивает, кому нравится Сэнди, а второй спрашивает, кому нравится Сэнди.
Третий просит подтверждения факта.
Ответ - "no", потому что нет никаких предложений или фактов, говорящих о том, что Робин любит Ли.
Вот еще один пример - список пар людей, которые находятся в отношениях взаимных симпатий.
Последний ответ содержит неустановленную переменную, указывающую на то, что все любят себя.

```lisp
> (?- (likes ?x ?y) (likes ?y ?x))
?Y = KIM
?X = SANDY;
?Y = SANDY
?X = SANDY;
?Y = SANDY
?X = SANDY;
?Y = SANDY
?X = KIM;
?Y = SANDY
?X = SANDY;
?Y = ?X3251
?X = ?X3251;
```

В Прологе имеет смысл задавать открытые(open-ended) запросы, такие как "what lists is 2 a member of ?"(в какие списки входит ?) или даже "what items are elements of what lists?"(какие элементы входят в какие списки?)

```lisp
(?- (member 2 ?list))
(?- (member ?item ?list))
```

Эти запросы являются действительным Прологом и вернут решения, но их будет бесконечное количество.
Поскольку наш интерпретатор собирает все решения в один список перед тем, как показать какое-либо из них, мы никогда не увидим решения.
В следующем разделе показано, как написать новый интерпретатор, решающий эту проблему.

** Упражнение 11.1 [m] ** Отношения представляются списком, первым элементом которого является символ.
Однако для отношений без аргументов некоторые люди предпочитают писать `(<- p q r)`, а не `(<- (p) (q) (r))`.
Внесите изменения, чтобы любая форма была приемлемой.

** Упражнение 11.2 [m] ** Некоторым людям трудно читать обозначение <-.
Определите макросы rule и fact, чтобы мы могли написать:

```lisp
(fact (likes Robin cats))
(rule (likes Sandy ?x) if (likes ?x cats))
```

## 11.3 Идея 3: Автоматический возврат

Интерпретатор Пролога, реализованный в последнем разделе, решает проблемы, возвращая список всех возможных решений.
Мы будем называть этот подход *batch*(пакетным), потому что ответы извлекаются за один непрерывный пакет обработки.
Иногда это именно то, что вам нужно, но в других случаях достаточно одного решения.
В реальном Прологе решения представляются по одному по мере их нахождения.
После того, как каждое решение напечатано, пользователь может запросить дополнительные решения или остановиться.
Это "инкрементный" подход.
Постепенный подход будет быстрее, если желаемое решение будет одним из первых из многих альтернатив.
Пошаговый подход будет работать даже при бесконечном количестве решений.
А если этого недостаточно, можно реализовать инкрементный подход, при котором поиск будет выполняться сначала в глубину.
Это означает, что в любой момент для этого потребуется меньше места для хранения, чем при пакетном подходе, при котором все решения должны одновременно храниться в памяти.

Один из подходов - изменить интерпретатор последнего раздела для использования каналов(pipes), а не списков.
С каналами ненужные вычисления задерживаются, и даже бесконечные списки могут быть выражены за конечное количество времени и пространства.
Мы могли бы перейти на каналы, просто изменив `mapcan` в `prove` и `prove-all` на `mappend-pipe` (стр. 286).
В книгах [Winston and Horn (1988)] (B9780080571157500285.xhtml#bb1410) и [Abelson and Sussman (1985)] (B9780080571157500285.xhtml#bb0010) используется этот подход.
Мы возьмем другой подход.

Первый шаг - это варианты `prove`  и `prove-all`, которые возвращают единственное решение, а не список всех возможных решений.
Это должно напоминать `achieve` и `achieve-all` из "gps" ([глава 4](B9780080571157500042.xhtml)).
В отличие от `gps`, рекурсивные подцели и достигнутые родственные цели не проверяются.
Однако для систематического поиска по всем решениям требуется `prove`, поэтому ей передается дополнительный параметр: список других целей, которых нужно достичь после достижения первой цели.
Это эквивалентно передаче продолжения в `prove`.
В результате, если `prove` когда-либо будет успешно, это означает, что вся цель верхнего уровня достигнута.
Если это не удается, это просто означает, что программа возвращается и пытается выполнить другую последовательность вариантов.
Обратите внимание, что `prove` полагается на то, что `fail` равно `nil`, потому что она использует some.

```lisp
(defun prove-all (goals bindings)
  "Find a solution to the conjunction of goals."
  (cond ((eq bindings fail) fail)
              ((null goals) bindings)
              (t (prove (first goals) bindings (rest goals)))))
(defun prove (goal bindings other-goals)
  "Return a list of possible solutions to goal."
  (some #'(lambda (clause)
                      (let ((new-clause (rename-variables clause)))
                          (prove-all
                              (append (clause-body new-clause) other-goals)
                      (unify goal (clause-head new-clause) bindings))))
  (get-clauses (predicate goal))))
```

Если `prove` действительно успешно, это означает, что решение было найдено.
Если мы хотим больше решений, нам нужен какой-то способ сделать процесс неудачным, чтобы он вернулся(откатился назад) и попробовал снова.
Один из способов сделать это - расширить каждый запрос с целью распечатать переменные и спросить пользователя, следует ли продолжить вычисление.
Если пользователь говорит "yes/да", то цель *терпит неудачу* и начинается возврат.
Если пользователь говорит "no/нет", цель выполняется, а поскольку это конечная цель, вычисление завершается.
Для этого требуется совершенно новый тип цели: цель, которая не сопоставляется с базой данных, а скорее заставляет некоторую процедуру предпринимать действия.
В Прологе такие процедуры называются *примитивами*, потому что они встроены в язык, а новые не могут быть определены пользователем.
Пользователь, конечно, может определять непримитивные процедуры, которые вызывают примитивы.

В нашей реализации примитивы будут представлены как функции Лиспа.
Предикат может быть представлен либо как список предложений (как это было до сих пор), либо как единичный примитив.
Вот версия `verify`, которая при необходимости вызывает примитивы:

```lisp
(defun prove (goal bindings other-goals)
  "Return a list of possible solutions to goal."
  (let ((clauses (get-clauses (predicate goal))))
      (if (listp clauses)
              (some
                  #'(lambda (clause)
                          (let ((new-clause (rename-variables clause)))
                              (prove-all
                                (append (clause-body new-clause) other-goals)
                                (unify goal (clause-head new-clause) bindings))))
                  clauses)
              ;; The predicate's "clauses" can be an atom:
              ;; a primitive function to call
              (funcall clauses (rest goal) bindings
                                other-goals))))
```

Вот версия `top-level-prove`, которая добавляет примитивную цель `show-prolog-vars` в конец списка целей.
Обратите внимание, что эта версия не должна вызывать саму `show-prolog-solutions`, так как печать будет обрабатываться примитивом для `show-prolog-vars`

```lisp
(defun top-level-prove (goals)
  (prove-all '(,@goals (show-prolog-vars ,@(variables-in goals)))
                        no-bindings)
  (format t "~&No.")
  (values))
```

Здесь мы определяем примитивный `show-prolog-vars`.
Все примитивы должны быть функциями трех аргументов: списка аргументов отношения примитивов (здесь список переменных для отображения), списка привязки для этих аргументов и списка ожидающих целей.
Примитив должен либо вернуть `fail`, либо вызвать `prove-all` для продолжения.

```lisp
(defun show-prolog-vars (vars bindings other-goals)
  "Print each variable with its binding.
  Then ask the user if more solutions are desired."
  (if (null vars)
          (format t "~&Yes")
          (dolist (var vars)
              (format t "~&~a = ~a" var
                              (subst-bindings bindings var))))
  (if (continue-p)
          fail
          (prove-all other-goals bindings)))
```

Поскольку примитивы представлены в виде записей в свойстве предикатных символов `clauses`, мы должны зарегистрировать `show-prolog-vars` как примитив, подобный этому:

```lisp
(setf (get 'show-prolog-vars 'clauses) 'show-prolog-vars)
```

Наконец, предикат Лиспа `continue-p` спрашивает пользователя, хочет ли он увидеть больше решений:

```lisp
(defun continue-p ()
  "Ask user if we should continue looking for solutions."
  (case (read-char)
    (#\; t)
```

`    (#\.
nil)`

```lisp
    (#\newline (continue-p))
    (otherwise
      (format t " Type ; to see more or . to stop")
      (continue-p))))
```

Эта версия работает так же хорошо, как и предыдущая, с конечными задачами.
Единственное отличие состоит в том, что точки с запятой вводит пользователь, а не система.
Преимущество состоит в том, что теперь мы можем использовать систему и для решения бесконечных задач.
Сначала мы спросим, в какие списки входит 2:

```lisp
> (?- (member 2 ?list))
?LIST = (2 . ?REST3302);
?LIST = (?X3303 2 . ?REST3307);
?LIST = (?X3303 ?X3308 2 . ?REST3312);
?LIST = (?X3303 ?X3308 ?X3313 2 . ?REST3317).
No.
```

Ответы означают, что 2 является членом любого списка, который начинается с 2, или чей второй элемент равен 2, или чей третий элемент равен 2, и так далее.
Бесконечное вычисление было остановлено, когда пользователь ввел точку, а не точку с запятой.
Ответ "no"(нет) означает, что больше нет ответов для печати; он появится, если ответов нет вообще, если пользователь вводит точку или если все ответы были напечатаны.

Мы можем задавать и более абстрактные вопросы.
Ответ на следующий запрос говорит, что элемент является элементом списка, когда он является первым элементом, или вторым, или третьим, или четвертым, и так далее.

```lisp
> (?- (member ?item ?list))
?ITEM = ?ITEM3318
?LIST = (?ITEM3318 . ?REST3319);
?ITEM = ?ITEM3323
?LIST = (?X3320 ?ITEM3323 . ?REST3324);
?ITEM = ?ITEM3328
?LIST = (?X3320 ?X3325 ?ITEM3328 . ?REST3329);
?ITEM = ?ITEM3333
?LIST = (?X3320 ?X3325 ?X3330 ?ITEM3333 . ?REST3334).
No.
```

Теперь добавим определение отношение длины(length):

```lisp
(<- (length () 0))
(<- (length (?x . ?y) (1  + ?n)) (length ?y ?n))
```

Вот несколько запросов, показывающих, что длина(length) может использоваться для поиска второго аргумента, первого или обоих:

```lisp
> (?- (length (a b c d) ?n))
?N = (1  + (1  + (1  + (1  + 0))));
No.
> (?- (length ?list (1  + (1  + 0))))
?LIST = (?X3869 ?X3872);
No.
> (?- (length ?list ?n))
?LIST = NIL
?N = 0;
?LIST = (?X3918)
?N = (1  + 0);
?LIST = (?X3918 ?X3921)
?N = (1  + (1  + 0)).
No.
```

Следующие два запроса показывают два списка длины два с a в качестве члена.
Оба запроса дают правильный ответ - список из двух элементов, который начинается или заканчивается на a.
Однако поведение после создания этих двух решений совершенно разное.

```lisp
> (?- (length ?l (1  + (1  + 0))) (member a ?l))
?L = (A ?X4057);
?L = (?Y4061 A);
No.
> (?- (member a ?l) (length ?l (1  + (1  + 0))))
?L = (A ?X4081);
?L = (?Y4085 A);[Abort]
```

В первом запросе length генерирует только одно возможное решение - список с двумя несвязанными элементами.
`member` берет это решение и создает экземпляр первого или второго элемента a.

Во втором запросе member продолжает генерировать потенциальные решения.
Первые два частичных решения, где a - первый или второй член списка неизвестной длины, расширяются на `length`, чтобы получить решения, у которых список имеет длину два.
После этого member генерирует все более длинные списки, которые length отвергает.
В определении элемента неявно подразумевается, что последующие решения будут длиннее, но поскольку это явно не известно, все они все равно генерируются, а затем явно проверяются и отклоняются с помощью параметра length.

Этот пример показывает ограничения Prolog как чистого языка логического программирования.
Оказывается, пользователь должен заботиться не только о логике проблемы, но и о потоке управления.
Prolog достаточно умен, чтобы возвращаться и находить все решения, когда пространство поиска достаточно мало, но когда оно бесконечно (или даже очень велико), программист по-прежнему несет ответственность за управление потоком управления.
Можно разработать языки, которые делают гораздо больше с точки зрения автоматического потока управления. [4](#fn0030) Пролог - это удобный и эффективный промежуточный вариант между императивными языками и чистой логикой.

### Подходы к возврату(Backtracking)

Предположим, вас просят внести "небольшое" изменение в существующую программу.
Проблема в том, что некоторая функция `f`, которая считалась однозначной(возвращающей одно значение), как теперь стало известно, при определенных обстоятельствах возвращает два или более правильных ответа.
Другими словами, `f` недетерминирована.
(Возможно, `f` это `sqrt`, и теперь мы хотим иметь дело с отрицательными числами).
Какие у вас есть альтернативы как программиста?
Можно выделить пять возможностей:

*   Угадывание.
Выберем одну возможность и отбросим остальные.
Для этого нужны средства, позволяющие делать правильные предположения или отказываться от неправильных предположений.

*   Знание
Иногда вы можете предоставить дополнительную информацию, которой достаточно, чтобы решить, какой выбор будет правильным.
Это означает изменение вызывающих функций для предоставления дополнительной информации.

*   Вернуть список.
Это означает, что вызывающую функцию(-и) необходимо изменить, чтобы она ожидала в ответ список.

*   Вернуть *канал*(pipe), как определено в [разделе 9.3](B9780080571157500091.xhtml#s0020).
Опять же, вызывающие функции должны быть изменены для ожидания канала.

*   Угадать и сохранить.
Выберите одну возможность и верните ее, но запишите достаточно информации, чтобы позже можно было вычислить другие возможности.
Это требует сохранения текущего состояния вычислений, а также некоторой информации об оставшихся возможностях.

Последняя альтернатива наиболее желательна.
Она эффективна, потому что не требует вычисления ответов, которые никогда не используются.
Она ненавязчива, поскольку не требует изменения вызывающей функции (и вызывающей функции вызывающей функции) для ожидания списка или канала(pipe) для ответов.
К сожалению, у него есть одна серьезная трудность: должен быть способ упаковать текущее состояние вычисления и сохранить его, чтобы его можно было вернуть, когда первый вариант не сработает.
Для нашего интерпретатора Пролога текущее состояние кратко представлено в виде списка целей.
В других задачах не так-то просто подвести итоги всего состояния.

В [разделе 22.4](B9780080571157500224.xhtml#s0025) мы увидим, что диалект Scheme в Lisp предоставляет функцию `call-with-current-continuation`, которая делает именно то, что мы хотим: она упаковывает текущее состояние вычислений в функцию, которую можно сохранить и вызывать позже.
К сожалению, в Common Lisp нет соответствующей функции.

### Анонимные переменные

Прежде чем двигаться дальше, полезно ввести понятие *анонимной переменной*. Это переменная, которая отличается от всех других в предложении или запросе, но программист не хочет давать ей имя.
В реальном Прологе нижнее подчеркивание используется для анонимных переменных, но мы будем использовать одиночный знак вопроса.
В последующем определении `member` используются анонимные переменные для обозначения позиций внутри терминов, которые не нужны в предложении:

```lisp
(<- (member ?item (?item . ?)))
```

`(<- (member ?item (?
. ?rest)) (member ?item ?rest))`

Однако мы также хотим разрешить несколько анонимных переменных в предложении, но при этом иметь возможность сохранять каждую анонимную переменную отдельно от всех других переменных.
Один из способов сделать это - заменить каждую анонимную переменную уникальной переменной.
Функция `replace-?-vars` использует для этого `gensym`.
Она устанавливается в макросы верхнего уровня `<-` и `?-`, чтобы все предложения и запросы обрабатывались должным образом.

```lisp
(defmacro <- (&rest clause)
  "Add a clause to the data base."
  '(add-clause ',(replace-?-vars clause)))
(defmacro ?- (&rest goals)
  "Make a query and print answers."
  '(top-level-prove '.(replace-?-vars goals)))
(defun replace-?-vars (exp)
  "Replace any ? within exp with a var of the form ?123."
  (cond ((eq exp '?) (gensym "?"))
              ((atom exp) exp)
              (t (reuse-cons (replace-?-vars (first exp))
                                            (replace-?-vars (rest exp))
                                            exp))))
```

Именованная переменная, которая используется в предложении только один раз, также может считаться анонимной переменной.
Это решается другим способом в [раздел 12.3](B9780080571157500121.xhtml#s0020).

## 11.4 Загадка(Puzzle) зебры

Вот пример того, в чем Prolog очень хорош: логическая головоломка.
В головоломке есть пятнадцать фактов или ограничений:

1.  There are five houses in a line, each with an owner, a pet, a cigarette, a drink, and a color.(В линию пять домов, в каждом есть хозяин, домашнее животное, сигарета, напиток и цвет.)
!!!(p) {:.numlist}

2.  The Englishman lives in the red house.(Англичанин живет в красном доме.)
!!!(p) {:.numlist}

3.  The Spaniard owns the dog.(Собака принадлежит испанцу.)
!!!(p) {:.numlist}

4.  Coffee is drunk in the green house.(В зеленом доме пьют кофе.)
!!!(p) {:.numlist}

5.  The Ukrainian drinks tea.(Украинец пьет чай.)
!!!(p) {:.numlist}

6.  The green house is immediately to the right of the ivory house.(Оранжерея находится справа от дома из слоновой кости.)
!!!(p) {:.numlist}

7.  The Winston smoker owns snails.(Курильщик Winston владеет улитками.)
!!!(p) {:.numlist}

8.  Kools are smoked in the yellow house.(В желтом доме курят кулы.)
!!!(p) {:.numlist}

9.  Milk is drunk in the middle house.(В среднем доме пьют молоко.)
!!!(p) {:.numlist}

10.  The Norwegian lives in the first house on the left.(Норвежец живет в первом доме слева.)
!!!(p) {:.numlista}

11.  The man who smokes Chesterfields lives next to the man with the fox.(Мужчина, который курит Честерфилд, живет рядом с человеком с лисой.)
!!!(p) {:.numlista}

12.  Kools are smoked in the house next to the house with the horse.(В доме рядом с домом с лошадью коптят/курят кулы.)
!!!(p) {:.numlista}

13.  The Lucky Strike smoker drinks orange juice.(Курильщик Lucky Strike пьет апельсиновый сок.)
!!!(p) {:.numlista}

14.  The Japanese smokes Parliaments.(Японцы курят парламенты.)
!!!(p) {:.numlista}

15.  The Norwegian lives next to the blue house.(Норвежец живет рядом с синим домом.)
!!!(p) {:.numlista}

Необходимо ответить на следующие вопросы: who drinks water and who owns the zebra?(кто пьет воду и кому принадлежит зебра?)
Чтобы решить эту загадку, мы сначала определяем отношения `nextto` (для "рядом с" - "next to") и `iright` (для "непосредственно справа от" - "immediately to the right of").
Они тесно связаны с отношением `member`, которое здесь повторяется.

(<- `(member ?item (?item . ?rest)))`

(<- `(member ?item (?x . ? rest)) (member ?item ?rest))`

(<- `(nextto ?x ?y ?list) (iright ?x ?y ?list))`

(<- `(nextto ?x ?y ?list) (iright ?y ?x ?list))`

(<- `(iright ?left ?right (?left ?right . ?rest)))`

(<- `(iright ?left ?right (?x . ?rest))`

```lisp
      (iright ?left ?right ?rest))
```

(<- `(= ?x ?x))`

Мы также определили отношение тождества =.
В нем есть одно предложение, в котором говорится, что любой x равен самому себе.
Можно подумать, что это реализует eq или equal.
Фактически, поскольку Пролог использует унификацию, чтобы увидеть, объединяются/унифицируются ли каждый из двух аргументов цели с помощью `?x`, это означает, что = является унификацией/объединением.

Теперь мы готовы определить головоломку "зебра" с помощью одного (длинного) предложения.
Переменная "?h" представляет список из пяти домов, и каждый дом представлен термином в форме (house *nationality pet cigarette drink color*)-(дом *национальность питомец сигарета напиток цвепт*).
Переменная `?w` - пьющий воду, а `?z` - владелец зебры.
Каждое из 15 ограничений в головоломке перечислено в `теле` `зебры`, хотя ограничения 9 и 10 были объединены в первое(одно).
Рассмотрим ограничение 2: "The Englishman lives in the `red` house."(Англичанин живет в `красном` доме). Оно интерпретируется как "есть дом, национальность которого - англичанин, цвет - красный, и который входит в список домов": другими словами, `(member (house englishman ? ? ? red) ?h).` Остальные ограничения также просты.

```lisp
(<- (zebra ?h ?w ?z)
  ;; Each house is of the form:
  ;; (house nationality pet cigarette drink house-color)
  (= ?h ((house norwegian ? ? ? ?)                                    ;1,10
                ?
                (house ? ? ? milk ?) ? ?))                                  ; 9
  (member (house englishman ? ? ? red) ?h)                    ; 2
  (member (house spaniard dog ? ? ?) ?h)                        ; 3
  (member (house ? ? ? coffee green) ?h)                        ; 4
  (member (house ukrainian ? ? tea ?) ?h)                      ; 5
  (iright (house ? ? ? ? ivory)                                          ; 6
                  (house 1111 green) ?h)
  (member (house ? snails winston ? ?) ?h)                    ; 7
  (member (house ? ? kools ? yellow) ?h)                        ; 8
  (nextto (house ? ? chesterfield ? ?)                            ;11
                  (house ? fox ? ? ?) ?h)
  (nextto (house ? ? kools ? ?)                                          ;12
                  (house ? horse ? ? ?) ?h)
  (member (house ? ? luckystrike orange-juice ?) ?h);13
  (member (house japanese ? parliaments ? ?) ?h)        ;14
  (nextto (house norwegian ? ? ? ?)                                  ;15
                  (house ? ? ? ? blue) ?h)
  ;; Now for the questions:
  (member (house ?w ? ? water ?) ?h)                                ;Q1
  (member (house ?z zebra ? ? ?) ?h))                              ;Q2
```

Вот вопрос и решение загадки:

```lisp
> (?- (zebra ?houses ?water-drinker ?zebra-owner))
?HOUSES = ((HOUSE NORWEGIAN FOX KOOLS WATER YELLOW)
                      (HOUSE UKRAINIAN HORSE CHESTERFIELD TEA BLUE)
                      (HOUSE ENGLISHMAN SNAILS WINSTON MILK RED)
                      (HOUSE SPANIARD DOG LUCKYSTRIKE ORANGE-JUICE IVORY)
                      (HOUSE JAPANESE ZEBRA PARLIAMENTS COFFEE GREEN))
?WATER-DRINKER = NORWEGIAN
?ZEBRA-OWNER = JAPANESE.
No.
```

Это заняло 278 секунд, а профилирование (см. Стр. 288) показывает, что функция proof вызывалась 12825 раз.
Вызов prove(доказательства) был назван *логическим выводом, поэтому* наша система выполняет 12825/278 = 46 логических выводов в секунду, или LIPS.
Хорошие системы Prolog работают со скоростью от 10 000 до 100 000 LIPS или более, так что эта едва ли не прихрамывает.

Небольшие изменения в проблеме могут сильно повлиять на время поиска.
Например, отношение nextto выполняется, когда первый дом находится непосредственно справа от второго или когда второй находится непосредственно справа от первого.
Порядок перечисления этих пунктов произвольный, и можно подумать, что не имеет значения, в каком порядке они перечислены.
Фактически, если мы изменим порядок этих двух предложений, время выполнения сократится примерно вдвое.

## 11.5 Синергия поиска с возвратом и унификации/объединения

Обратная цепочка с обратным отслеживанием в Prolog - мощный метод для генерации возможных решений проблемы.
Это упрощает реализацию стратегии *создать и тестировать(проверить)*, при которой возможные решения рассматриваются по одному, а когда решение-кандидат отклоняется, предлагается следующее.
Но создание и тестирование возможно только тогда, когда пространство возможных решений невелико.

В головоломке с зеброй для каждого из пяти домов есть пять атрибутов.
Таким образом, существует 5!5 или более 24 миллиардов возможных решений, слишком много, чтобы тестировать по одному.
Именно концепция унификации (с соответствующим понятием логической переменной) делает возможным создание и тестирование этой головоломки.
Вместо того, чтобы перечислять полные варианты решений, унификация позволяет нам указать *частичные*  кандидаты.
Мы начинаем с того, что узнаём, что есть пять домов, где норвежец живет слева, а пьющий молоко посередине.
Вместо того, чтобы генерировать всех полных кандидатов, удовлетворяющих этим двум ограничениям, мы оставляем оставшуюся информацию неопределенной, объединяя оставшиеся дома и атрибуты с анонимными логическими переменными.
Следующее ограничение (номер 2) помещает англичанина в красный дом.
Из-за того, как написано `member`, сначала пытается поместить англичанина в крайний левый дом.
Это отклоняется, потому что англичанин и норвежец не могут объединиться(унифицироваться/unify), поэтому рассматривается следующая возможность, и англичанин помещается во второй дом.
Но никакие другие особенности второго дома не указаны - нам не нужно было делать отдельные предположения о том, что дом англичанина зеленый, желтый и так далее.
Поиск продолжается, заполняя ровно столько, сколько необходимо, и делая резервные копии всякий раз, когда объединение(унификация) не удается.

В этой проблеме унификация служит той же цели, что и макрос задержки(delay) (стр. 281).
Это позволяет нам отложить определение значения некоторого атрибута как можно дольше, но немедленно отклонить решение, которое пытается присвоить два разных значения одному и тому же атрибуту.
Таким образом, мы сэкономим время, если в конечном итоге возвращаемся до того, как вычисление будет выполнено, но мы все равно сможем заполнить значение позже.

Можно расширить унификацию, чтобы она выполняла больше работы, а при возврате выполнялось меньше работы.
Рассмотрим следующее вычисление:

```lisp
(?- (length ?l 4)
        (member d ?l) (member a ?l) (member c ?l) (member b ?l)
        (= ?l (a b c d)))
```

Первые две строки генерируют перестановки списка (`d a c b`), а третья строка проверяет перестановку, равную (`a b c d`).
Большая часть работы выполняется путем возврата(backtracking).
Альтернативой является расширение унификации для работы со списками, а также константами и переменными.
Предикаты, такие как `length` и `member`, будут примитивами, которые должны знать о представлении списков.
Затем в первых двух строках приведенной выше программы для `set ?l` будет указано что-то вроде `#s (list :length 4 :members (d a c d))`.
Третья строка будет вызовом расширенной процедуры унификации, которая будет дополнительно определять `?l` чем-то вроде:

```lisp
#s(list :length 4 imembers (d a c d) :order (abc d))
```

Усложняя процедуру унификации, мы полностью устраняем необходимость в обратном отслеживании.

**Упражнение 11.3 [s]** Будет ли алгоритм унификации, который откладывает тесты "member", хорошей или плохой идеей для головоломки зебра?

## 11.6 Разрушающая унификация/объединение

Как мы видели в [раздел 11.2](#s0015), отслеживать список привязки переменных немного сложно.
Кроме того, это может привести к неэффективности, если список привязок становится большим, потому что список должен просматриваться линейно, и потому что для хранения списка привязок необходимо выделить пространство.
Альтернативная реализация - заменить `unify` на деструктивную операцию.
В этом подходе нет списков привязок.
Вместо этого каждая переменная представлена как структура, которая включает поле для ее привязки.
Когда переменная объединяется(унифицируется) с другим выражением, поле привязки переменной изменяется, чтобы указывать на выражение.
Такие переменные будут называться `vars`, чтобы отличать их от реализации переменных в виде символов, начинающихся с вопросительного знака, `vars` определяются следующим кодом:

```lisp
(defconstant unbound "Unbound")
(defstruct var name (binding unbound))
(defun bound-p (var) (not (eq (var-binding var) unbound)))
```

Макрос deref достигает привязки переменной, возвращая ее аргумент, если это несвязанная(unbound) переменная или выражение без переменной.
Он включает цикл, потому что переменная может быть привязана к другой переменной, которая, в свою очередь, привязана к конечному значению.

Обычно считается плохой практикой реализовать deref как макрос, поскольку он может быть реализован как встроенная функция, при условии, что вызывающий желает написать `(setf x (deref x))` вместо `(deref x)`.
Однако deref будет появляться в коде, сгенерированном некоторыми версиями компилятора Prolog, который будет представлен в следующем разделе.
Поэтому, чтобы сгенерированный код выглядел более аккуратно, я позволил себе роскошь макроса `deref`.

```lisp
(defmacro deref (exp)
  "Follow pointers for bound variables."
  '(progn (loop while (and (var-p ,exp) (bound-p ,exp))
                        do (setf ,exp (var-binding ,exp)))
                  ,exp))
```

Функция `unify!` ниже является деструктивной версией `unify`.
Это предикат, который возвращает истину в случае успеха и ложь в случае неудачи и имеет побочный эффект изменения привязок переменных.

`(defun unify!
(x y)`

```lisp
  "Destructively unify two expressions"
  (cond ((eql (deref x) (deref y)) t)
```

`              ((var-p x) (set-binding!
x y))`

`              ((var-p y) (set-binding!
y x))`

```lisp
              ((and (consp x) (consp y))
```

`              (and (unify!
(first x) (first y))`

`                        (unify!
(rest x) (rest y))))`

```lisp
              (t nil)))
```

`(defun set-binding!
(var value)`

`  "Set var's binding to value.
Always succeeds (returns t)."`

```lisp
  (setf (var-binding var) value)
  t)
```

Чтобы упростить чтение `vars`, мы можем установить: `print-function`:

```lisp
(defstruct (var (:print-function print-var))
      name (binding unbound))
  (defun print-var (var stream depth)
      (if (or (and (numberp *print-level*)
                        (>= depth *print-level*))
              (var-p (deref var)))
        (format stream "?~a" (var-name var))
        (write var :stream stream)))
```

Это первый пример тщательно продуманной: `print-function`.
Следует отметить три вещи.
Во-первых, она явно записывает в поток, переданный в качестве аргумента.
Она не записывает в поток по умолчанию.
Во-вторых, она проверяет переменную `depth` на `*print-level*` и печатает только имя переменной при превышении глубины.
В-третьих, она использует `write` для печати привязок.
Это связано с тем, что write обращает внимание на текущие значения `*print-escape*, *print-pretty*` и `soon`.
Другие функции печати, такие как `prinl` или `print`, не обращают внимания на эти переменные.

Теперь, для целей обратного отслеживания(backtracking), мы хотим, чтобы `set-binding!` отслеживал сделанные привязки, чтобы их можно было отменить позже:

```lisp
(defvar *trall* (make-array 200 :fill-pointer 0 :adjustable t))
```

`(defun set-binding!
(var value)`

```lisp
  "Set var's binding to value, after saving the variable
```

`  in the trail.
Always returns t."`

```lisp
  (unless (eq var value)
      (vector-push-extend var *trail*)
      (setf (var-binding var) value))
  t)
```

`(defun undo-bindings!
(old-trail)`

```lisp
  "Undo all bindings back to a given point in the trail."
  (loop until (= (fill-pointer *trail*) old-trail)
      do (setf (var-binding (vector-pop *trail*)) unbound)))
```

Теперь нам нужен способ создания новых переменных, каждая из которых отличается.
Это можно сделать, задав новое имя для каждой переменной, но более быстрое решение - просто увеличить счетчик.
Функция конструктора ? определена для создания новой переменной с именем, которое является новым целым числом.
Это не обязательно; мы могли бы просто использовать автоматически предоставленный конструктор `make-var`.
Однако я думал, что операция предоставления новой анонимной переменной достаточно отличается от предоставления именованной переменной, что заслуживает своей собственной функции.
Кроме того, `make-var` может быть менее эффективной, потому что она должна обрабатывать аргументы ключевого слова.
Функция ? не имеет аргументов; она просто присваивает значения по умолчанию, указанные в слотах структуры `var`.

```lisp
(defvar *var-counter* 0)
(defstruct (var (:constructor ? ())
                      (:print-function print-var))
  (name (incf *var-counter*))
  (binding unbound))
```

Следующим разумным шагом было бы использовать деструктивную унификацию для создания более эффективного интерпретатора.
Однако это оставлено как упражнение, и вместо этого мы отложим интерпретатор и в следующей главе разработаем компилятор.

## 11.7 Пролог на Прологе

Как было сказано в начале этой главы, Prolog имеет многие из тех же функций, которые делают Lisp привлекательным для разработки программ.
Так же, как легко написать интерпретатор Лиспа на Лиспе, так же легко написать интерпретатор Пролога на Прологе.
Следующий метаинтерпретатор Пролога имеет три основных отношения.
Предложение отношения используется для хранения предложений, которые составляют правила и факты, которые должны быть интерпретированы.
Отношение `prove`(доказательство) используется для доказательства цели.
Он вызывает `prove`-`all`, которая пытается доказать список целей, `prove`-`all` успешна двумя способами: (1) если список пуст, или (2) если есть какое-то предложение, head совпадает с первой целью, и, если мы сможем доказать телом этого предложения, следующие за ним оставшиеся цели:

```lisp
(<- (prove ?goal) (prove-all (?goal)))
(<- (prove-all nil))
(<- (prove-all (?goal . !!!(char) Ã®goals))
        (clause (<- ?goal . ?body))
        (concat ?body ?goals ?new-goals)
        (prove-all ?new-goals))
```

Теперь мы добавляем в базу данных два предложения, чтобы определить отношение членства(member):

```lisp
(<- (clause (<- (mem ?x (?x . ?y)))))
```

`(<- (clause (<- (mem ?x (?
. ?z)) (mem ?x ?z))))`

Наконец, мы можем доказать цель с помощью нашего интерпретатора:

```lisp
(?- (prove (mem ?x (1 2 3))))
?X = 1;
?X = 2;
?X = 3;
No.
```

## 11.8 Пролог по сравнению с Лиспом

Многие из функциональных возможностей, которые делают Prolog успешным языком для ИИ (и для разработки программ в целом), такие же, как и возможности Lisp.
Давайте пересмотрим список возможностей, которые отличают Lisp от обычных языков (см. Стр.25), и посмотрим, что может предложить Prolog:

*   *Встроенная поддержка списков (и других типов данных).* Новые типы данных можно легко создавать с помощью списков или структур (предпочтительны структуры).
Поддержка чтения, печати и доступа к компонентам предоставляется автоматически.
Также поддерживаются числа, символьные знаки и символы.
Однако, поскольку логические переменные не могут быть изменены, некоторые структуры данных и операции не предусмотрены.
Например, в Прологе нет возможности обновить элемент вектора.

*   *Автоматическое управление хранилищем.* Программист может размещать новые объекты, не беспокоясь об их восстановлении.
Восстановление обычно происходит быстрее в Прологе, чем в Лиспе, потому что большая часть данных может быть размещена в стеке, а не в куче.

*   *Динамический ввод.* Объявления(Декларации) не требуются.
В самом деле, стандартного способа объявления типов не существует, хотя некоторые реализации позволяют это.
Некоторые системы Prolog предоставляют только фиксированные числа(fixnums), что устраняет необходимость в большом классе объявлений.

*   *Функции первого класса.* В Прологе нет эквивалента лямбда, но встроенный предикат `call` позволяет вызвать термин - часть данных - как цель.
Хотя точки выбора с возвратом не являются объектами первого класса, их можно использовать способом, очень похожим на продолжения в Лиспе.

*   *Единый синтаксис.* Как и Лисп, Пролог имеет единый синтаксис как для программ, так и для данных.
Это упрощает написание интерпретаторов и компиляторов на Прологе.
В то время как нотация списка префиксных операторов в Лиспе более единообразна, Пролог допускает инфиксные и постфиксные операторы, что может быть более естественным для некоторых приложений.

*   *Интерактивная среда.* Выражения могут быть немедленно вычислены.
Высококачественные системы Prolog предлагают как компилятор, так и интерпретатор, а также множество инструментов отладки.

*   *Расширяемость.* Синтаксис Пролога расширяемый.
Поскольку программы и данные используют один и тот же формат, можно написать эквивалент макроса в Prolog и определить встроенные языки.
Однако может быть труднее гарантировать, что полученный код будет эффективно скомпилирован.
Детали компиляции Пролога зависят от реализации.

Чтобы взглянуть на вещи в перспективе, примите во внимание, что Лисп является одновременно одним из языков самого высокого уровня и универсальным языком ассемблера.
Это язык высокого уровня, потому что он может легко захватывать данные, функциональные и управляющие абстракции.
Это хороший язык ассемблера, потому что можно писать на Lisp в стиле, который напрямую отражает операции, доступные на современных компьютерах.

Пролог, как правило, не так эффективен, как язык ассемблера, но может быть более кратким в качестве языка спецификации, по крайней мере, для некоторых проблем.
Пользователь пишет спецификации: списки аксиом, которые описывают отношения, которые могут иметь место в проблемной области.
Если эти спецификации имеют правильную форму, автоматический поиск с возвратом в Prolog может найти решение, даже если программист не предоставляет явного алгоритма.
Для других проблем пространство поиска будет слишком большим или бесконечным, или простой поиск в глубину Prolog с возвратами будет слишком негибким.
В этом случае Prolog следует использовать как язык программирования, а не как язык спецификации.
Программист должен знать стратегию поиска Пролога, используя ее для реализации подходящего алгоритма для решения данной проблемы.

Пролог, как и Лисп, несправедливо пострадал от некоторых распространенных мифов.
Считалось, что это неэффективный язык, потому что ранние реализации были интерпретируемыми, и потому что он использовался для написания интерпретаторов.
Но современный скомпилированный Пролог может быть довольно эффективным (см. [Warren et al.
1977] (B9780080571157500285.xhtml#bb1335) и Ван Рой 1990).
Есть соблазн рассматривать Prolog как решение само по себе, а не как язык программирования.
Те, кто придерживается этой точки зрения, возражают, что стратегия поиска в глубину Пролога и основа исчисления предикатов слишком негибкие.
С этим возражением не согласны программисты Пролога, которые используют возможности, предоставляемые языком, для построения более мощных стратегий поиска и представлений, точно так же, как это можно было бы сделать в Лиспе или любом другом языке.

## 11.9 История и Ссылки

Cordell [Green (1968)](B9780080571157500285.xhtml#bb0490) was the first to articulate the view that mathematical results on theorem proving could be used to make deductions and thereby answer queries.
However, the major technique in use at the time, resolution theorem proving (see [Robinson 1965](B9780080571157500285.xhtml#bb0995)), did not adequately constrain search, and thus was not practical.
The idea of goal-directed computing was developed in Carl Hewitt's work (1971) on the planner language for robot problem solving.
He suggested that the user provide explicit hints on how to control deduction.

At about the same time and independently, Alain Colmerauer was developing a system to perform natural language analysis.
His approach was to weaken the logical language so that computationally complex statements (such as logical dis-junctions) could not be made.
Colmerauer and his group implemented the first Prolog interpreter using Algol-W in the summer of 1972 (see [Roussel 1975](B9780080571157500285.xhtml#bb1005)).
It was Roussel's wife, Jacqueline, who came up with the name Prolog as an abbreviation for "programmation en logique." The first large Prolog program was their natural language system, also completed that year ([Colmerauer et al.
1973](B9780080571157500285.xhtml#bb0255)).
For those who read English better than French, [Colmerauer (1985)](B9780080571157500285.xhtml#bb0245) presents an overview of Prolog.
Robert Kowalski is generally considered the coinventer of Prolog.
His 1974 article outlines his approach, and his 1988 article is a historical review on the early logic programming work.

There are now dozens of text books on Prolog.
In my mind, six of these stand out.
Clocksin and Mellish's *Programming in Prolog* (1987) was the first and remains one of the best.
Sterling and Shapiro's *The Art of Prolog* (1986) has more substantial examples but is not as complete as a reference.
An excellent overview from a slightly more mathematical perspective is Pereira and Shieber's *Prolog and Natural-Language Analysis* (1987).
The book is worthwhile for its coverage of Prolog alone, and it also provides a good introduction to the use of logic programming for language under-standing (see part V for more on this subject).
O'Keefe's *The Craft of Prolog* (1990) shows a number of advanced techniques.
O'Keefe is certainly one of the most influential voices in the Prolog community.
He has definite views on what makes for good and bad coding style and is not shy about sharing his opinions.
The reader is warned that this book evolved from a set of notes on the Clocksin and Mellish book, and the lack of organization shows in places.
However, it contains advanced material that can be found nowhere else.
Another collection of notes that has been organized into a book is Coelho and Cotta's *Prolog by Example.* Published in 1988, this is an update of their 1980 book, *How to Solve it in Prolog.* The earlier book was an underground classic in the field, serving to educate a generation of Prolog programmers.
Both versions include a wealth of examples, unfortunately with little documentation and many typos.
Finally, Ivan Bratko's *Prolog Programming for Artificial Intelligence* (1990) covers some introductory AI material from the Prolog perspective.

Maier and Warren's *Computing with Logic* (1988) is the best reference for those interested in implementing Prolog.
It starts with a simple interpreter for a variable-free version of Prolog, and then moves up to the full language, adding improvements to the interpreter along the way.
(Note that the second author, David S.
Warren of Stonybrook, is different from David H.
D.
Warren, formerly at Edinburgh and now at Bristol.
Both are experts on Prolog.)

Lloyd's *Foundations of Logic Programming* (1987) provides a theoretical explanation of the formal semantics of Prolog and related languages.
[Lassez et al.
(1988)](B9780080571157500285.xhtml#bb0705) and [Knight (1989)](B9780080571157500285.xhtml#bb0625) provide overviews of unification.

There have been many attempts to extend Prolog to be closer to the ideal of Logic Programming.
The language MU-Prolog and NU-Prolog ([Naish 1986](B9780080571157500285.xhtml#bb0890)) and Prolog III ([Colmerauer 1990](B9780080571157500285.xhtml#bb0250)) are particularly interesting.
The latter includes a systematic treatment of the &ne; relation and an interpretation of infinite trees.

## 11.10 Упражнения

**Exercise  11.4 [m]** It is somewhat confusing to see "no" printed after one or more valid answers have appeared.
Modify the program to print "no" only when there are no answers at all, and "no more" in other cases.

**Exercise  11.5 [h]** At least six books (Abelson and Sussman 1985, [Charniak and McDermott 1985](B9780080571157500285.xhtml#bb0175), Charniak et al.
1986, [Hennessey 1989](B9780080571157500285.xhtml#bb0530), [Wilensky 1986](B9780080571157500285.xhtml#bb1390), and [Winston and Horn 1988](B9780080571157500285.xhtml#bb1410)) present unification algorithms with a common error.
They all have problems unifying (`?x ?y a`) with (`?y ?x ?x`).
Some of these texts assume that `unify`will be called in a context where no variables are shared between the two arguments.
However, they are still suspect to the bug, as the following example points out:

```lisp
> (unify '(f (?x ?y a) (?y ?x ?x)) '(f ?z ?z))
((?Y . A) (?X . ?Y) (?Z ?X ?Y A))
```

Despite this subtle bug, I highly recommend each of the books to the reader.
It is interesting to compare different implementations of the same algorithm.
It turns out there are more similarities than differences.
This indicates two things: (1) there is a generally agreed-upon style for writing these functions, and (2) good programmers sometimes take advantage of opportunities to look at other's code.

The question is : Can you give an informal proof of the correctness of the algorithm presented in this chapter?
Start by making a clear statement of the specification.
Apply that to the other algorithms, and show where they go wrong.
Then see if you can prove that the `unify` function in this chapter is correct.
Failing a complete proof, can you at least prove that the algorithm will always terminate?
See [Norvig 1991](B9780080571157500285.xhtml#bb0915) for more on this problem.

**Exercise  11.6 [h]** Since logic variables are so basic to Prolog, we would like them to be efficient.
In most implementations, structures are not the best choice for small objects.
Note that variables only have two slots: the name and the binding.
The binding is crucial, but the name is only needed for printing and is arbitrary for most variables.
This suggests an alternative implementation.
Each variable will be a cons cell of the variable's binding and an arbitrary marker to indicate the type.
This marker would be checked by `variable-p`.
Variable names can be stored in a hash table that is cleared before each query.
Implement this representation for variables and compare it to the structure representation.

**Exercise  11.7 [m]** Consider the following alternative implementation for anonymous variables: Leave the macros <- and ?- alone, so that anonymous variables are allowed in assertions and queries.
Instead, change `unify` so that it lets anything match against an anonymous variable:

```lisp
(defun unify (x y &optional (bindings no-bindings))
  "See if x and y match with given bindings."
  (cond ((eq bindings fail) fail)
              ((eql x y) bindings)
              ((or (eq x '?) (eq y '?)) bindings)      ;***
              ((variable-p x) (unify-variable x y bindings))
              ((variable-p y) (unify-variable y x bindings))
              ((and (consp x) (consp y))
                (unify (rest x) (rest y)
                          (unify (first x) (first y) bindings)))
              (t fail)))
```

Is this alternative correct?
If so, give an informal proof.
If not, give a counterexample.

**Exercise  11.8 [h]** Write a version of the Prolog interpreter that uses destructive unification instead of binding lists.

**Exercise  11.9 [m]** Write Prolog rules to express the terms father, mother, son, daughter, and grand- versions of each of them.
Also define parent, child, wife, husband, brother, sister, uncle, and aunt.
You will need to decide which relations are primitive (stored in the Prolog data base) and which are derived by rules.

For example, here's a definition of grandfather that says that G is the grandfather of C if G is the father of some P, who is the parent of C:

```lisp
(<- (grandfather ?g ?c)
        (father ?g ?p)
        (parent ?p ?c))
```

**Exercise 11.10 [m]** The following problem is presented in [Wirth 1976](B9780080571157500285.xhtml#bb1415):

*I married a widow (let's call her W) who has a grown-up daughter (call her D).
My father (F), who visited us often, fell in love with my step-daughter and married her.
Hence my father became my son-in-law and my step-daughter became my mother.
Some months later, my wife gave birth to a son (S1), who became the brother-in-law of my father, as well as my uncle.
The wife of my father, that is, my step-daughter, also had a son (S2).*

Represent this situation using the predicates defined in the previous exercise, verify its conclusions, and prove that the narrator of this tale is his own grandfather.

**Exercise 11.11 [d]** Recall the example:

`> (?- (length (a b` c `d) ?n))`

```lisp
?N = (1  + (1  + (1  + (1  + 0))));
```

It is possible to produce 4 instead of `(1+ (1+ (1+ (1+ 0))))` by extending the notion of unification.
[A&iuml;t-Kaci et al.
1987](B9780080571157500285.xhtml#bb0025) might give you some ideas how to do this.

**Exercise  11.12 [h]** The function `rename-variables` was necessary to avoid confusion between the variables in the first argument to `unify` and those in the second argument.
An alternative is to change the `unify` so that it takes two binding lists, one for each argument, and keeps them separate.
Implement this alternative.

## 11.11 Ответы

**Answer 11.9** We will choose as primitives the unary predicates `male` and `female` and the binary predicates `child` and `married`.
The former takes the child first; the latter takes the husband first.
Given these primitives, we can make the following definitions:

```lisp
(<- (father ?f ?e)    (male ?f) (parent ?f ?c))
(<- (mother ?m ?c)    (female ?m) (parent ?m c))
(<- (son ?s ?p)      (male ?s) (parent ?p ?s))
(<- (daughter ?s ?p)    (male ?s) (parent ?p ?s))
(<- (grandfather ?g ?c) (father ?g ?p) (parent ?p ?c))
(<- (grandmother ?g ?c) (mother ?g ?p) (parent ?p ?c))
(<- (grandson ?gs ?gp) (son ?gs ?p) (parent ?gp ?p))
(<- (granddaughter ?gd ?gp) (daughter ?gd ?p) (parent ?gp ?p))
(<- (parent ?p ?c)    (child ?c ?p))
(<- (wife ?w ?h)      (married ?h ?w))
(<- (husband ?h ?w)    (married ?h ?w))
(<- (sibling ?x ?y)    (parent ?p ?x) (parent ?p ?y))
(<- (brother ?b ?x)      (male ?b) (sibling ?b ?x))
(<- (sister ?s ?x)        (female ?s) (sibling ?s ?x))
(<- (uncle ?u ?n)        (brother ?u ?p) (parent ?p ?n))
(<- (aunt ?a ?n)        (sister ?a ?p) (parent ?p ?n  ))
```

Note that there is no way in Prolog to express a *true* definition.
We would like to say that "P is the parent of C if and only if C is the child of P," but Prolog makes us express the biconditional in one direction only.

**Answer 11.10** Because we haven't considered step-relations in the prior definitions, we have to extend the notion of parent to include step-parents.
The definitions have to be written very carefully to avoid infinite loops.
The strategy is to structure the defined terms into a strict hierarchy: the four primitives are at the bottom, then parent is defined in terms of the primitives, then the other terms are defined in terms of parent and the primitives.

We also provide a definition for son-in-law:

```lisp
(<- (parent ?p ?c) (married ?p ?w) (child ?c ?w))
(<- (parent ?p ?c) (married ?h ?p) (child ?c ?w))
(<- (son-in-law ?s ?p) (parent ?p ?w) (married ?s ?w))
```

Now we add the information from the story.
Note that we only use the four primitives male, female, married, and child:

```lisp
(<- (male I)) (<- (male F)) (<- (male S1)) (<- (male S2))
(<- (female W)) (<- (female D))
(<- (married I W))
(<- (married F D))
(<- (child D W))
(<- (child I F))
(<- (child S1 I))
(<- (child S2 F))
```

Now we are ready to make the queries:

```lisp
> (?- (son-in-law F I)) Yes.
> (?- (mother D I)) Yes.
> (?- (uncle S1 I)) Yes.
> (?- (grandfather I I)) Yes.
```

----------------------

[1](#xfn0015) Actually, *programmation en logique*, since it was invented by a French group (see page 382).
!!!(p) {:.ftnote1}

[2](#xfn0020) Actually, this is more like the Lisp `find` than the Lisp `member`.
In this chapter we have adopted the traditional Prolog definition of `member`.
!!!(p) {:.ftnote1}

[3](#xfn0025) See exercise 11.12 for an alternative approach.
!!!(p) {:.ftnote1}

[4](#xfn0030) See the MU-Prolog and NU-Prolog languages ([Naish 1986](B9780080571157500285.xhtml#bb0890)).
!!!(p) {:.ftnote1}