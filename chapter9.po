#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter9.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2021-01-26 18:15+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter9.md:3
msgid ""
"# Chapter 9\n"
"## Efficiency Issues"
msgstr ""
"# Глава 9\n"
"## Вопросы эффективности"

#: in/chapter9.md:5
msgid ""
"> A Lisp programmer knows the value of everything, but the cost of nothing."
msgstr "> Программист на Лиспе знает значение всего, но не знает цены ничему."

#: in/chapter9.md:8
msgid ""
"> -Alan J.\n"
"Perlis"
msgstr ""

#: in/chapter9.md:10
msgid ""
"> Lisp is not inherently less efficient than other high-level languages."
msgstr ""
"> Lisp по своей сути не менее эффективен, чем другие языки высокого уровня"

#: in/chapter9.md:13
msgid ""
"> -Richard J.\n"
"Fateman"
msgstr ""

#: in/chapter9.md:19
msgid ""
"One of the reasons Lisp has enjoyed a long history is because it is an ideal "
"language for what is now called *rapid-prototyping*-developing a program "
"quickly, with little regards for details.\n"
"That is what we have done so far in this book: concentrated on getting a "
"working algorithm.\n"
"Unfortunately, when a prototype is to be turned into a production-quality "
"program, details can no longer be ignored.\n"
"Most \"real\" AI programs deal with large amounts of data, and with large "
"search spaces.\n"
"Thus, efficiency considerations become very important."
msgstr ""
"Одна из причин, по которой Lisp имеет долгую историю, заключается в том, что "
"это идеальный язык для того, что сейчас называется *быстрое "
"прототипирование* - быстрая разработка программы, не обращающая внимание на "
"детали.\n"
"Именно этим мы и занимались до сих пор в этой книге: концентрировались на "
"получении работающего алгоритма.\n"
"К сожалению, когда прототип должен быть превращен в программу "
"производственного качества, детали уже нельзя игнорировать.\n"
"Большинство \"настоящих\" программ ИИ работают с большими объемами данных и "
"с большими пространствами поиска.\n"
"Таким образом, соображения эффективности становятся очень важными."

#: in/chapter9.md:25
msgid ""
"However, this does not mean that writing an efficient program is "
"fundamentally different from writing a working program.\n"
"Ideally, developing an efficient program should be a three-step process.\n"
"First, develop a working program, using proper abstractions so that the "
"program will be easy to change if necessary.\n"
"Second, *instrument* the program to determine where it is spending most of "
"the time.\n"
"Third, replace the slow parts with faster versions, while maintaining the "
"program's correctness."
msgstr ""
"Однако это не означает, что написание эффективной программы в корне "
"отличается от написания рабочей программы.\n"
"В идеале разработка эффективной программы должна состоять из трех этапов.\n"
"Во-первых, разработайте рабочую программу, используя надлежащие абстракции, "
"чтобы при необходимости ее можно было легко изменить.\n"
"Во-вторых, *проанализируйте* программу, чтобы определить, где она проводит "
"большую часть времени.\n"
"В-третьих, замените медленные части более быстрыми версиями, сохранив при "
"этом корректность программы."

#: in/chapter9.md:30
msgid ""
"The term *efficiency* will be used primarily to talk about the *speed* or "
"run time of a program.\n"
"To a lesser extent, *efficiency* is also used to refer to the *space* or "
"amount of storage consumed by a program.\n"
"We will also talk about the cost of a program.\n"
"This is partly a use of the metaphor \"time is money,\" and partly rooted in "
"actual monetary costs-if a critical program runs unacceptably slowly, you "
"may need to buy a more expensive computer."
msgstr ""
"Термин *эффективность* будет использоваться в основном для обозначения "
"*скорости* или времени выполнения программы.\n"
"В меньшей степени *эффективность* также используется для обозначения "
"*пространства* или объема памяти, потребляемого программой.\n"
"Также поговорим о стоимости программы.\n"
"Отчасти это связано с использованием метафоры \"время - деньги\", а отчасти "
"связано с реальными денежными затратами: если критически важная программа "
"работает неприемлемо медленно, возможно, вам придется купить более дорогой "
"компьютер."

#: in/chapter9.md:39
msgid ""
"Lisp has been saddled with a reputation as an \"inefficient language.\" "
"Strictly speaking, it makes no sense to call a *language* efficient or "
"inefficient.\n"
"Rather, it is only a particular *implementation* of the language executing a "
"particular program that can be measured for efficiency.\n"
"So saying Lisp is inefficient is partly a historical claim: some past "
"implementations *have* been inefficient.\n"
"It is also partly a prediction: there are some reasons why future "
"implementations are expected to suffer from inefficiencies.\n"
"These reasons mainly stem from Lisp's flexibility.\n"
"Lisp allows many decisions to be delayed until run time, and that can make "
"the run time take longer.\n"
"In the past decade, the \"efficiency gap\" between Lisp and \"conventional "
"languages\" like FORTRAN or C has narrowed.\n"
"Here are the reasons-some deserved, some not-behind Lisp's reputation for "
"inefficiency:"
msgstr ""
"Lisp получил репутацию \"неэффективного языка\". Строго говоря, нет смысла "
"называть *язык* эффективным или неэффективным.\n"
"Скорее, только конкретная *реализация* языка, выполняющего конкретную "
"программу, может быть измерена на эффективность.\n"
"Утверждение о неэффективности Lisp отчасти является историческим "
"утверждением: некоторые прошлые реализации *были* неэффективными.\n"
"Это также отчасти прогноз: есть несколько причин, по которым будущие "
"реализации, как ожидается, будут иметь неэффективность.\n"
"Эти причины в основном проистекают из гибкости Lisp.\n"
"Lisp позволяет отложить принятие многих решений до времени выполнения, и это "
"может увеличить время выполнения.\n"
"За последнее десятилетие \"разрыв в эффективности\" между Lisp и "
"\"традиционными языками\", такими как FORTRAN или C, сократился.\n"
"Вот причины - некоторые заслуженные, а некоторые нет - создающие Лиспу "
"репутацию неэффективного языка:"

#: in/chapter9.md:43
msgid ""
"*   Early implementations were interpreted rather than compiled, which made "
"them inherently inefficient.\n"
"Common Lisp implementations have compilers, so this is no longer a problem.\n"
"While Lisp is (primarily) no longer an interpreted language, it is still an "
"*interactive* language, so it retains its flexibility."
msgstr ""
"*   Ранние реализации скорее интерпретировались, чем компилировались, что "
"делало их по сути неэффективными.\n"
"Реализации Common Lisp имеют компиляторы, так что это больше не проблема.\n"
"Хотя Lisp (в первую очередь) больше не является интерпретируемым языком, он "
"по-прежнему является *интерактивным* языком, поэтому он сохраняет свою "
"гибкость."

#: in/chapter9.md:46
msgid ""
"*   Lisp has often been used to write interpreters for embedded languages, "
"thereby compounding the problem.\n"
"Consider this quote from [Cooper and Wogrin's (1988)](B9780080571157500285."
"xhtml#bb0260) book on the rule-based programming language OPS5:"
msgstr ""
"*   Лисп часто использовался для написания интерпретаторов для встроенных "
"языков, что усугубляло проблему.\n"
"Рассмотрим эту цитату из книги [Cooper and Wogrin's (1988)]"
"(B9780080571157500285.xhtml#bb0260) о языке программирования на основе "
"правил OPS5:"

#: in/chapter9.md:48
msgid ""
"> The efficiency of implementations that compile rules into executable code "
"compares favorably to that of programs written in most sequential languages "
"such as FORTRAN or Pascal Implementations that compile rules into data "
"structures to be interpreted, as do many Lisp-based ones, could be "
"noticeably slower."
msgstr ""
"> Эффективность реализаций, компилирующих правила в исполняемый код, выгодно "
"отличается от эффективности программ, написанных на большинстве "
"последовательных языков, таких как FORTRAN или Pascal. Реализации, которые "
"компилируют правила в структуры данных для интерпретации, как и многие из "
"основанных на Lisp, могут быть заметно медленнее."

#: in/chapter9.md:53
msgid ""
"Here Lisp is guilty by association.\n"
"The fallacious chain of reasoning is: Lisp has been used to write "
"interpreters; interpreters are slow; therefore Lisp is slow.\n"
"While it is true that Lisp makes it very easy to write interpreters, it also "
"makes it easy to write compilers.\n"
"This book is the first that concentrates on using Lisp as both the "
"implementation and target language for compilers."
msgstr ""
"Здесь Лисп виноват по ассоциации.\n"
"Ошибочная цепочка рассуждений такова: Лисп использовался для написания "
"интерпретаторов; интерпретаторы медлительны; поэтому Лисп медленный.\n"
"Хотя это правда, что Lisp очень упрощает написание интерпретаторов, он также "
"упрощает написание компиляторов.\n"
"Эта книга - первая книга, в которой основное внимание уделяется "
"использованию Lisp в качестве языка реализации и целевого языка для "
"компиляторов."

#: in/chapter9.md:60
msgid ""
"*   Lisp encourages a style with lots of function calls, particularly "
"recursive calls.\n"
"In some older systems, function calls were expensive.\n"
"But it is now understood that a function call can be compiled into a simple "
"branch instruction, and that many recursive calls can be made no more "
"expensive than an equivalent iterative loop (see [chapter 22]"
"(B9780080571157500224.xhtml)).\n"
"It is also possible to instruct a Common Lisp compiler to compile certain "
"functions inline, so there is no calling overhead at all.\n"
"On the other hand, many Lisp systems require two fetches instead of one to "
"find the code for a function, and thus will be slower.\n"
"This extra level of indirection is the price paid for the freedom of being "
"able to redefine functions without reloading the whole program."
msgstr ""
"*   Lisp поощряет стиль с множеством вызовов функций, особенно рекурсивных "
"вызовов.\n"
"В некоторых старых системах вызовы функций были дорогими.\n"
"Но теперь понятно, что вызов функции может быть скомпилирован в простую "
"инструкцию ветвления, и что многие рекурсивные вызовы могут выполняться не "
"дороже, чем эквивалентный итерационный цикл (см. [Глава 22] "
"(B9780080571157500224.xhtml)).\n"
"Также можно дать указание компилятору Common Lisp скомпилировать "
"определенные функции во встроенном режиме(inline), чтобы не было "
"дополнительных затрат на вызовы.\n"
"С другой стороны, многие системы Lisp требуют двух выборок вместо одной, "
"чтобы найти код функции, и, следовательно, будут медленнее.\n"
"Этот дополнительный уровень косвенности - это плата за свободу "
"переопределения функций без перезагрузки всей программы."

#: in/chapter9.md:73
msgid ""
"*   Run-time type-checking is slow.\n"
"Lisp provides a repertoire of generic functions.\n"
"For example, we can write `(+ x y)` without bothering to declare if `x` and "
"`y` are integers, floating point, bignums, complex numbers, rationals, or "
"some combination of the above.\n"
"This is very convenient, but it means that type checks must be made at run "
"time, so the generic  +  will be slower than, say, a 16-bit integer addition "
"with no check for overflow.\n"
"If efficiency is important, Common Lisp allows the programmer to include "
"declarations that can eliminate run-time checks.\n"
"In fact, once the proper declarations are added, Lisp can be as fast or "
"faster than conventional languages.\n"
"[Fateman (1973)](B9780080571157500285.xhtml#bb0375) compared the FORTRAN "
"cube root routine on the PDP-10 to a MacLisp transliteration.\n"
"The MacLisp version produced almost identical numerical code, but was 18% "
"faster overall, due to a superior function-calling sequence.[1](#fn0010)The "
"epigraph at the beginning of this chapter is from this article.\n"
"[Berlin and Weise (1990)](B9780080571157500285.xhtml#bb0085) show that with "
"a special compilation technique called *partial evaluation*, speeds 7 to 90 "
"times faster than conventionally compiled code can be achieved.\n"
"Of course, partial evaluation could be used in any language, but it is very "
"easy to do in Lisp.\n"
"The fact remains that Lisp objects must somehow represent their type, and "
"even with declarations, not all of this overhead can be eliminated.\n"
"Most Lisp implementations optimize access to lists and fixnums but pay the "
"price for the other, less commonly used data types."
msgstr ""
"*   Проверка типов во время выполнения выполняется медленно.\n"
"Lisp предоставляет набор обобщенных функций.\n"
"Например, мы можем написать `(+ x y)`, не беспокоясь о том, являются ли `x` "
"и `y` целыми числами, числами с плавающей запятой, большими числами, "
"комплексными числами, рациональными числами или какой-либо комбинацией "
"вышеперечисленного.\n"
"Это очень удобно, но это означает, что проверки типов должны выполняться во "
"время выполнения, поэтому обобщенный + будет медленнее, чем, скажем, "
"сложение 16-битных целых чисел без проверки переполнения.\n"
"Если важна эффективность, Common Lisp позволяет программисту включать "
"объявления, которые могут исключить проверки во время выполнения.\n"
"Фактически, после добавления правильных объявлений Lisp может работать так "
"же быстро или быстрее, как и обычные языки.\n"
"[Fateman (1973)](B9780080571157500285.xhtml#bb0375) сравнил процедуру "
"кубичесого корня FORTRAN на PDP-10 с транслитерацией MacLisp.\n"
"Версия MacLisp выдавала практически идентичный числовой код, но в целом была "
"на 18% быстрее из-за превосходной последовательности вызова функций. [1]"
"(#fn0010) Эпиграф в начале этой главы взят из этой статьи.\n"
"[Berlin and Weise (1990)](B9780080571157500285.xhtml#bb0085) в которой "
"показывают, что с помощью специальной техники компиляции, называемой "
"*частичным вычислением*, можно достичь скорости от 7 до 90 раз быстрее, чем "
"код, скомпилированный традиционным способом.\n"
"Конечно, частичное вычисление можно использовать на любом языке, но в Лиспе "
"это очень легко сделать.\n"
"Факт остается фактом: объекты Lisp должны каким-то образом представлять свой "
"тип, и даже с объявлениями не все эти накладные расходы можно устранить.\n"
"Большинство реализаций Lisp оптимизируют доступ к спискам и фиксированным "
"числам, но расплачиваются за другие, менее часто используемые типы данных."

#: in/chapter9.md:81
msgid ""
"*   Lisp automatically manages storage, and so it must periodically stop and "
"collect the unused storage, or *garbage*.\n"
"In early systems, this was done by periodically sweeping through all of "
"memory, resulting in an appreciable pause.\n"
"Modern systems tend to use incremental garbage-collection techniques, so "
"pauses are shorter and usually unnoticed by the user (although the pauses "
"may still be too long for real-time applications such as controlling a "
"laboratory instrument).\n"
"The problem with automatic garbage collection these days is not that it is "
"slow-in fact, the automatic systems do about as well as handcrafted storage "
"allocation.\n"
"The problem is that they make it convenient for the programmer to generate a "
"lot of garbage in the first place.\n"
"Programmers in conventional languages, who have to clean up their own "
"garbage, tend to be more careful and use static rather than dynamic storage "
"more often.\n"
"If garbage becomes a problem, the Lisp programmer can just adopt these "
"static techniques."
msgstr ""
"*   Lisp автоматически управляет хранилищем, поэтому он должен переодически "
"останавливаться и собирать неиспользуемое хранилище, или *мусор/garbage*.\n"
"В ранних системах это делалось путем периодической очистки всей памяти, что "
"приводило к заметной паузе.\n"
"Современные системы, как правило, используют методы "
"инкрементной(постепенной) сборки мусора, поэтому паузы короче и обычно "
"незаметны(хотя паузы могут быть слишком длинными для приложений реального "
"времени, таких как управление лабораторным прибором).\n"
"Проблема с автоматической сборкой мусора в наши дни не в том, что она "
"медленная - на самом деле, автоматические системы делают примерно так же, "
"как и ручное выделение.\n"
"Проблема в том, что они в первую очередь позволяют программисту создавать "
"МНОГО мусора.\n"
"Программисты использующие традиционные языки, которым приходится убирать "
"свой собственный мусор, как правило, более осторожны и чаще используют "
"статическое, а не динамическое хранилище.\n"
"Если мусор становится проблемой, программист на Лиспе может просто "
"использовать эти статические техники."

#: in/chapter9.md:88
msgid ""
"*   Lisp systems are big and leave little room for other programs.\n"
"Most Lisp systems are designed to be complete environments, within which the "
"programmer does all program development and execution.\n"
"For this kind of operation, it makes sense to have a large language like "
"Common Lisp with a huge set of tools.\n"
"However, it is becoming more common to use Lisp as just one component in a "
"computing environment that may include UNIX, X Windows, emacs, and other "
"interacting programs.\n"
"In this kind of heterogeneous environment, it would be useful to be able to "
"define and run small Lisp processes that do not include megabytes of unused "
"tools.\n"
"Some recent compilers support this option, but it is not widely available "
"yet."
msgstr ""
"*   Lisp системы велики и оставляют мало места для других программ.\n"
"Большинство Lisp систем спроектированы как законченные среды, в которых "
"программист выполняет всю разработку и выполнение программ.\n"
"Для такого рода операций имеет смысл иметь большой язык, такой как Common "
"Lisp, с огромным набором инструментов.\n"
"Однако становится все более распространенным использование Лиспа как одного "
"компонента в вычислительной среде, которая может включать UNIX, X Windows, "
"emacs, и другие взаимодействующие программы.\n"
"В такой гетерогенной среде было бы полезно иметь возможность определять и "
"запускать небольшие Lisp процессы, которые не включают мегабайты "
"неиспользуемых инструментов.\n"
"Некоторые последние компиляторы поддерживают эту опцию, но пока она не "
"распространена."

#: in/chapter9.md:97
msgid ""
"*   Lisp is a complicated high-level language, and it can be difficult for "
"the programmer to anticipate the costs of various operations.\n"
"In general, the problem is not that an efficient encoding is impossible but "
"that it is difficult to arrive at that efficient encoding.\n"
"In a language like C, the experienced programmer has a pretty good idea how "
"each statement will compile into assembly language instructions.\n"
"But in Lisp, very similar statements can compile into widely different "
"assembly-level instructions, depending on subtle interactions between the "
"declarations given and the capabilities of the compiler.\n"
"[Page 318](B9780080571157500108.xhtml#p318) gives an example where adding a "
"declaration speeds up a trivial function by 40 times.\n"
"Nonexperts do not understand when such declarations are necessary and are "
"frustrated by the seeming inconsistencies.\n"
"With experience, the expert Lisp programmer eventually develops a good "
"\"efficiency model,\" and the need for such declarations becomes obvious.\n"
"Recent compilers such as CMU's Python provide feedback that eases this "
"learning process."
msgstr ""
"*   Lisp - сложный язык высокого уровня, и программисту может быть сложно "
"предвидеть затраты на различные операции.\n"
"В общем, проблема не в том, что эффективное кодирование невозможно, а втом, "
"что трудно достичь этого эффективного кодирования.\n"
"На таком языке как Си, опытный программист имеет довольно хорошее "
"представление о том, как каждый оператор будет компилироваться в инструкции "
"на языке ассемблера. \n"
"Но в Лиспе очень похожие операторы могут компилироваться в очень разные "
"инструкции ассемблерного уровня, в зависимости от тонкого взаимодействия "
"между данными объявлениями(declarations) и возможностями компилятора.\n"
"[На Стр. 318](B9780080571157500108.xhtml#p318) приведен пример, в котором "
"добавление объявления ускоряет выполнение тривиальной функци в  40 раз.\n"
"Не эксперты не понимают, когда такие деклараци необходимы, и расстраиваются "
"из-за их кажущихся несоответствий.\n"
"Опытный программист на Лиспе со временем вырабатывает хорошую \"модель "
"эфффективности\" и необходимость таких деклараций становится очевидной.\n"
"Последние компиляторы, такие как CMU's Python, обеспечивают обратную связь, "
"которая облегчает процесс обучения этому."

#: in/chapter9.md:104
msgid ""
"In summary, Lisp makes it possible to write programs in a wide variety of "
"styles, some efficient, some less so.\n"
"The programmer who writes Lisp programs in the same style as C programs will "
"probably find Lisp to be of comparable speed, perhaps slightly slower.\n"
"The programmer who uses some of the more dynamic features of Lisp typically "
"finds that it is much easier to develop a working program.\n"
"Then, if the resulting program is not efficient enough, there will be more "
"time to go back and improve critical sections.\n"
"Deciding which parts of the program use the most resources is called "
"*instrumentation*.\n"
"It is foolhardy to try to improve the efficiency of a program without first "
"checking if the improvement will make a real difference."
msgstr ""
"Таким образом, Lisp позволяет писать программы в самых разнообразных стилях, "
"некоторые эффективные, некоторые не очень.\n"
"Программист, который пишет Лисп-программы в том же стиле, что и программы на "
"Си, вероятно обнаружит, что Лисп имеет сопоставимую скорость, возможно "
"немного чуть медленне.\n"
"Программист, который использует некоторые из наиболее динамичных функций "
"Лисп, обычно находит, что гораздо проще разработать работающую программу.\n"
"Затем, если результирующая программа недостаточно эффективна у вас будет "
"больше времени, чтобы вернуться назад и улучшить критические разделы.\n"
"Решение о том, какие части программы используют больше всего ресурсов, "
"принимается вызвав *инструментарий*.\n"
"Безрассудно пытаться повысить эффективность программы, предварительно не "
"проверив, действительно ли улучшение будет иметь значение."

#: in/chapter9.md:109
msgid ""
"One route to efficiency is to use the Lisp prototype as a specification and "
"reimplement that specification in a lower-level language, such as C or C++.\n"
"Some commercial AI vendors are taking this route.\n"
"An alternative is to use Lisp as the language for both the prototype and the "
"final implementation.\n"
"By adding declarations and making minor changes to the original program, it "
"is possible to end up with a Lisp program that is similar in efficiency to a "
"C program."
msgstr ""
"Одним из путей повышения эффективности является использование прототипов на "
"Лиспе в качестве спецификации и повторная реализация этой спецификации на "
"языке более низкого уровня, таком как Си или Си++.\n"
"Некоторые коммерческие поставщики ИИ идут по этому пути.\n"
"Альтернативой является использование Лиспа в качестве языка как для "
"прототипа, так и для окончательной реализации.\n"
"Добавляя объявления и внося незначительные изменения в исходную программу, "
"можно получить Лисп программу, аналогичную по эффективности программе на "
"языке Си."

#: in/chapter9.md:111
msgid ""
"There are four very general and language-independent techniques for speeding "
"up an algorithm:"
msgstr ""
"Существует четыре общих и независимых от языка метода ускорения работы "
"алгоритма:"

#: in/chapter9.md:113
msgid "*   *Caching* the results of computations for later reuse."
msgstr "*   *Кеширование* результатов вычислений для повторного использования."

#: in/chapter9.md:115
msgid "*   *Compiling* so that less work is done at run time."
msgstr "*   *Компиляция*, чтобы во время выполнения выполнялось меньше работы."

#: in/chapter9.md:117
msgid ""
"*   *Delaying* the computation of partial results that may never be needed."
msgstr ""
"*   *Отсрочка/delaying* вычисления части результатов, которые могут никогда "
"не понадобиться."

#: in/chapter9.md:119
msgid "*   *Indexing* a data structure for quicker retrieval."
msgstr "*   *Индексирование* структуры данных для более быстрого поиска."

#: in/chapter9.md:124
msgid ""
"This chapter covers each of the four techniques in order.\n"
"It then addresses the important problem of *instrumentation*.\n"
"The chapter concludes with a case study of the simplify program.\n"
"The techniques outlined here result in a 130-fold speed-up in this program."
msgstr ""
"В этой главе по порядку рассматривается каждый из четырех методов\n"
"Затем мы вернемся к важной проблеме  *инструментария*.\n"
"Глава завершается обучающим случаем программы упрощения.\n"
"Описанные здесь методы позволяют ускорить выполнение этой программы в 130-"
"раз."

#: in/chapter9.md:126
msgid ""
"[Chapter 10](B9780080571157500108.xhtml) concentrates on lower-level \"tricks"
"\" for improving efficiency further."
msgstr ""
"[Глава 10](B9780080571157500108.xhtml) концентрируется на \"уловках/tricks\" "
"для дальнейшего повышения эффективности."

#: in/chapter9.md:128
msgid "## 9.1 Caching Results of Previous Computations: Memoization"
msgstr ""
"## 9.1 Кеширование результатов предыдущих вычислений: "
"Memoization(запоминание)"

#: in/chapter9.md:131
msgid ""
"We start with a simple mathematical function to demonstrate the advantages "
"of caching techniques.\n"
"Later we will demonstrate more complex examples."
msgstr ""
"Начнем с простой математической функции, чтобы продемонстрировать "
"преимущества методов кэширования.\n"
"Позже мы продемонстрируем более сложные примеры."

#: in/chapter9.md:134
msgid ""
"The Fibonacci sequence is defined as the numbers 1,1,2,3,5,8,... where each "
"number is the sum of the two previous numbers.\n"
"The most straightforward function to compute the nth number in this sequence "
"is as follows:"
msgstr ""
"Последовательность Фибоначи определяется как числа 1,1,2,3,5,8,... где "
"каждое число - это сумма двух предыдущих чисел.\n"
"Самая простая функция для вычисления n-го числа в этой последовательности "
"выглядит следующим образом:"

#: in/chapter9.md:138
msgid ""
"```lisp\n"
"(defun fib (n)\n"
"```"
msgstr ""

#: in/chapter9.md:140
msgid "    `\"Compute the nth number in the Fibonacci sequence.\"`"
msgstr ""

#: in/chapter9.md:142
msgid "  `(if (<= n 1) 1`"
msgstr ""

#: in/chapter9.md:144
msgid "      `(+ (fib (- n 1)) (fib (- n 2)))))`"
msgstr ""

#: in/chapter9.md:152
msgid ""
"The problem with this function is that it computes the same thing over and "
"over again.\n"
"To compute (`fib 5`) means computing (`fib 4`) and (`fib 3`), but (`fib 4`) "
"also requires (`fib 3`), they both require (`fib 2`), and so on.\n"
"There are ways to rewrite the function to do less computation, but wouldn't "
"it be nice to write the function as is, and have it automatically avoid "
"redundant computation?\n"
"Amazingly, there is a way to do just that.\n"
"The idea is to use the function `fib` to build a new function that remembers "
"previously computed results and uses them, rather than recompute them.\n"
"This process is called *memoization*.\n"
"The function `memo` below is a higher-order function that takes a function "
"as input and returns a new function that will compute the same results, but "
"not do the same computation twice."
msgstr ""
"Проблема этой функции в том, что она вычисляет одно и то же снова и снова.\n"
"Вычисление (`fib 5`) означает вычисление (`fib 4`) и (`fib 3`), но (`fib 4`) "
"также требует (`fib 3`), и они оба требуют (`fib 2`), и т.д.\n"
"Есть способы переписать функцию, чтобы она делала меньше вычислений, но было "
"бы не плохо написать функцию как есть, но чтобы она автоматически избегала "
"избыточных вычислений?\n"
"Удивительно, но есть способ сделать именно это.\n"
"Идея состоит в том, чтобы использовать функцию `fib` для создания новой "
"функции, которая запоминает ранее вычисленные результаты и использует их, а "
"не пересчитывает заново.\n"
"Этот процесс называется *memoization*(придание функции памяти).\n"
"Функция `memo` это функция высшего порядка, которая принимает функцию в "
"качестве входных данных и возвращает новую функцию, которая будет вычислять "
"те же результаты, но не выполнять одно и тоже вычисление дважды."

#: in/chapter9.md:165
msgctxt "in/chapter9.md:165"
msgid ""
"```lisp\n"
"(defun memo (fn &key (key #'first) (test #'eql) name)\n"
"  \"Return a memo-function of fn.\"\n"
"  (let ((table (make-hash-table :test test)))\n"
"    (setf (get name 'memo) table)\n"
"    #'(lambda (&rest args)\n"
"        (let ((k (funcall key args)))\n"
"          (multiple-value-bind (val found-p)\n"
"              (gethash k table)\n"
"            (if found-p val\n"
"                (setf (gethash k table) (apply fn args))))))))\n"
"```"
msgstr ""

#: in/chapter9.md:168
msgid ""
"The expression (`memo #'fib`) will produce a function that remembers its "
"results between calls, so that, for example, if we apply it to 3 twice, the "
"first call will do the computation of (`fib 3`), but the second will just "
"look up the result in a hash table.\n"
"With `fib` traced, it would look like this:"
msgstr ""
"Выражение (`memo #'fib`) создает функцию, которая запоминает свои результаты "
"между вызовами, так что, например, если мы дважды применим её к  3, первый "
"вызов выполнит вычисление (`fib 3`), но второй будет просто будет искать "
"результат в хеш-таблице.\n"
"После трассировки `fib`, это будет выглядеть так:"

#: in/chapter9.md:174
msgid ""
"```lisp\n"
"> (setf memo-fib (memo #'fib)) => #  <  CLOSURE -  67300731  >\n"
"> (funcall memo-fib 3) =>\n"
"(1 ENTER FIB: 3)\n"
"```"
msgstr ""

#: in/chapter9.md:176
msgid "    `(2 ENTER FIB: 2)`"
msgstr ""

#: in/chapter9.md:178
msgid "          `(3 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:180
msgctxt "in/chapter9.md:180"
msgid "          `(3 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:182
msgid "          `(3 ENTER FIB: 0)`"
msgstr ""

#: in/chapter9.md:184
msgctxt "in/chapter9.md:184"
msgid "          `(3 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:186
msgid "    `(2 EXIT FIB: 2)`"
msgstr ""

#: in/chapter9.md:188
msgid "    `(2 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:190
msgid "    `(2 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:196
msgid ""
"```lisp\n"
"(1 EXIT FIB: 3)\n"
"3\n"
"> (funcall memo-fib 3) =  >  3\n"
"```"
msgstr ""

#: in/chapter9.md:201
msgid ""
"The second time we call `memo-fib` with 3 as the argument, the answer is "
"just retrieved rather than recomputed.\n"
"But the problem is that during the computation of (`fib 3`), we still "
"compute (`fib 2`) multiple times.\n"
"It would be better if even the internal, recursive calls were memoized, but "
"they are calls to fib, which is unchanged, not to `memo-fib`.\n"
"We can solve this problem easily enough with the function `memoize`:"
msgstr ""
"Во второй раз, когда мы вызываем `memo-fib` с аргументом 3, ответ просто "
"извлекается, а не вычислялется заново.\n"
"Но проблема в том, что во время вычисления (`fib 3`), мы по прежнему "
"вычисляем (`fib 2`) несколько раз.\n"
"Было бы лучше, если бы даже внутренние рекурсивные вызовы были "
"запомнены(memoized), но это были вызовы неизменённого fib,а не `memo-fib`.\n"
"Эту проблему легко решить с помощью функции `memoize`:"

#: in/chapter9.md:207
msgid ""
"```lisp\n"
"(defun memoize (fn-name &key (key #'first) (test #'eql))\n"
"  \"Replace fn-name's global definition with a memoized version.\"\n"
"  (clear-memoize fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:213
msgid ""
"When passed a symbol that names a function, `memoize` changes the global "
"definition of the function to a memo-function.\n"
"Thus, any recursive calls will go first to the memo-function, rather than to "
"the original function.\n"
"This is just what we want.\n"
"In the following, we contrast the memoized and unmemoized versions of "
"`fib`.\n"
"First, a call to (`fib 5`) with `fib` traced:"
msgstr ""
"При передаче символа, который именует функцию, `memoize` изменяет глобальное "
"определение функции на memo-функцию.\n"
"Таким образом, любые рекурсивные вызовы сначала будут обращаться к  memo-"
"функции, а не к исходной функции.\n"
"Это как раз то, что мы хотим.\n"
"Далее мы сопоставим запоминающие(memoized) и не запоминающие(unmemoized) "
"версии `fib`.\n"
"Первый вызов (`fib 5`) с трассировкой `fib`:"

#: in/chapter9.md:218
msgid ""
"```lisp\n"
"> (fib 5) =>\n"
"(1 ENTER FIB: 5)\n"
"```"
msgstr ""

#: in/chapter9.md:220
msgid "      `(2 ENTER FIB: 4)`"
msgstr ""

#: in/chapter9.md:222
msgid "            `(3 ENTER FIB: 3)`"
msgstr ""

#: in/chapter9.md:224
msgid "                  `(4 ENTER FIB: 2)`"
msgstr ""

#: in/chapter9.md:226
msgid "                          `(5 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:228
msgctxt "in/chapter9.md:228"
msgid "                          `(5 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:230
msgid "                          `(5 ENTER FIB: 0)`"
msgstr ""

#: in/chapter9.md:232
msgctxt "in/chapter9.md:232"
msgid "                          `(5 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:234
msgid "                  `(4 EXIT FIB: 2)`"
msgstr ""

#: in/chapter9.md:236
msgctxt "in/chapter9.md:236"
msgid "                  `(4 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:238
msgctxt "in/chapter9.md:238"
msgid "                  `(4 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:240
msgid "            `(3 EXIT FIB: 3)`"
msgstr ""

#: in/chapter9.md:242
msgctxt "in/chapter9.md:242"
msgid "            `(3 ENTER FIB: 2)`"
msgstr ""

#: in/chapter9.md:244
msgctxt "in/chapter9.md:244"
msgid "                  `(4 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:246
msgctxt "in/chapter9.md:246"
msgid "                  `(4 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:248
msgctxt "in/chapter9.md:248"
msgid "                  `(4 ENTER FIB: 0)`"
msgstr ""

#: in/chapter9.md:250
msgctxt "in/chapter9.md:250"
msgid "                  `(4 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:252
msgctxt "in/chapter9.md:252"
msgid "            `(3 EXIT FIB: 2)`"
msgstr ""

#: in/chapter9.md:254
msgid "      `(2 EXIT FIB: 5)`"
msgstr ""

#: in/chapter9.md:256
msgid "      `(2 ENTER FIB: 3)`"
msgstr ""

#: in/chapter9.md:258
msgctxt "in/chapter9.md:258"
msgid "            `(3 ENTER FIB: 2)`"
msgstr ""

#: in/chapter9.md:260
msgctxt "in/chapter9.md:260"
msgid "                  `(4 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:262
msgctxt "in/chapter9.md:262"
msgid "                  `(4 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:264
msgctxt "in/chapter9.md:264"
msgid "                  `(4 ENTER FIB: 0)`"
msgstr ""

#: in/chapter9.md:266
msgctxt "in/chapter9.md:266"
msgid "                  `(4 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:268
msgctxt "in/chapter9.md:268"
msgid "            `(3 EXIT FIB: 2)`"
msgstr ""

#: in/chapter9.md:270
msgid "            `(3 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:272
msgid "            `(3 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:274
msgid "      `(2 EXIT FIB: 3)`"
msgstr ""

#: in/chapter9.md:279
msgid ""
"```lisp\n"
"(1 EXIT FIB: 8)\n"
"8\n"
"```"
msgstr ""

#: in/chapter9.md:284
msgid ""
"We see that (`fib 5`) and (`fib 4`) are each computed once, but (`fib 3`) is "
"computed twice, (`fib 2`) three times,and (`fib 1`) five times.\n"
"Below we call (`memoize 'fib`) and repeat the calculation.\n"
"This time, each computation is done only once.\n"
"Furthermore, when the computation of (`fib 5`) is repeated, the answer is "
"returned immediately with no intermediate computation, and a further call to "
"(`fib 6`) can make use of the value of (`fib 5`)."
msgstr ""
"Мы видим, что (`fib 5`) и (`fib 4`) вычисляются один раз, но (`fib 3`) "
"вычисляется дважды, (`fib 2`) трижды, а (`fib 1`) пять раз.\n"
"Ниже мы вызываем (`memoize 'fib`) и повторяем вычисление.\n"
"На этот раз, каждое вычисление выполняется только один раз.\n"
"Кроме того, когда вычисление (`fib 5`) повторяется, ответ возвращается "
"немедленно без промежуточных вычислений, и при следующем вызове (`fib 6`) "
"может быть использовано значение (`fib 5`)."

#: in/chapter9.md:290
msgid ""
"```lisp\n"
"> (memoize 'fib) => #  <  CLOSURE 76626607  >\n"
"> (fib 5) =>\n"
"(1 ENTER FIB: 5)\n"
"```"
msgstr ""

#: in/chapter9.md:292
msgid "    `(2 ENTER FIB: 4)`"
msgstr ""

#: in/chapter9.md:294
msgid "          `(3 ENTER FIB: 3)`"
msgstr ""

#: in/chapter9.md:296
msgid "                `(4 ENTER FIB: 2)`"
msgstr ""

#: in/chapter9.md:298
msgid "                      `(5 ENTER FIB: 1)`"
msgstr ""

#: in/chapter9.md:300
msgctxt "in/chapter9.md:300"
msgid "                      `(5 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:302
msgid "                      `(5 ENTER FIB: 0)`"
msgstr ""

#: in/chapter9.md:304
msgctxt "in/chapter9.md:304"
msgid "                      `(5 EXIT FIB: 1)`"
msgstr ""

#: in/chapter9.md:306
msgid "                `(4 EXIT FIB: 2)`"
msgstr ""

#: in/chapter9.md:308
msgid "          `(3 EXIT FIB: 3)`"
msgstr ""

#: in/chapter9.md:310
msgid "    `(2 EXIT FIB: 5)`"
msgstr ""

#: in/chapter9.md:320
msgid ""
"```lisp\n"
"(1 EXIT FIB: 8)\n"
"8\n"
"> (fib 5)   =>  8\n"
"> (fib 6) =>\n"
"(1 ENTER FIB: 6)\n"
"(1 EXIT FIB: 13)\n"
"13\n"
"```"
msgstr ""

#: in/chapter9.md:324
msgid ""
"Understanding why this works requires a clear understanding of the "
"distinction between functions and function names.\n"
"The original (`defun fib ...`) form does two things: builds a function and "
"stores it as the `symbol - function` value of `fib`.\n"
"Within that function there are two references to `fib`; these are compiled "
"(or interpreted) as instructions to fetch the `symbol - function` of `fib` "
"and apply it to the argument."
msgstr ""
"Понимание того, почему это работает, требует четкого понимания различий "
"между функциями и именами функций.\n"
"Исходная форма (`defun fib ...`) выполняет две задачи: создает функцию и и "
"сохраняет ее как значение (`symbol-function`) символа-функции `fib`.\n"
"Внутри этой функции есть две ссылки на `fib`; они компилируются (или "
"интерпретируются) как инструкции для получения  `symbol-function` для `fib` "
"и применения её к аргументу."

#: in/chapter9.md:331
msgid ""
"What `memoize` does is fetch the original function and transform it with "
"`memo` to a function that, when called, will first look in the table to see "
"if the answer is already known.\n"
"If not, the original function is called, and a new value is placed in the "
"table.\n"
"The trick is that `memoize` takes this new function and makes it the `symbol "
"- function` value of the function name.\n"
"This means that all the references in the original function will now go to "
"the new function, and the table will be properly checked on each recursive "
"call.\n"
"One further complication to `memo:` the function `gethash` returns both the "
"value found in the table and an indicator of whether the key was present or "
"not.\n"
"We use `multiple-value-bind` to capture both values, so that we can "
"distinguish the case when `nil` is the value of the function stored in the "
"table from the case where there is no stored value."
msgstr ""
"`memoize` извлекает исходную функцию и преобразует её с помощью `memo` в "
"функцию, которая при вызове, сначала просматривает таблицу, чтобы узнать, "
"известен ли уже ответ.\n"
"Если нет, вызывается исходная функция, и в таблицу помещается новое "
"значение.\n"
"Хитрость в том, что `memoize` берет эту новую функцию и делает её значением "
"символа-фукнции(`symbol-function`) имени функции.\n"
"Это означает, что все ссылки в исходной функции теперь перейдут на новую "
"функцию, и таблица будет правильно проверяться при каждом рекурсивном "
"вызове.\n"
"Еще одна сложность для `memo:` функция `gethash` возвращает два значения, "
"найденное в таблице и индикатор того, присутствует ключ или нет.\n"
"Мы используем `multiple-value-bind` для захвата обоих значений, чтобы мы "
"могли отличить случай, когда `nil` является значением функции сохраненным в "
"таблице, от случая, когда сохраненного значения нет."

#: in/chapter9.md:334
msgid ""
"If you make a change to a memoized function, you need to recompile the "
"original definition, and then redo the call to memoize.\n"
"In developing your program, rather than saying `(memoize 'f)`, it might be "
"easier to wrap appropriate definitions in a `memoize` form as follows:"
msgstr ""
"Если вы вносите изменения в функцию преобразованную memoize, вам необходимо "
"перекомпилировать исходное определение, а затем повторить вызов memoize.\n"
"При разработке вашей программы, вместо того, чтобы сказать `(memoize 'f)`, "
"было бы проще заключить соответствующее определение в форму `memoize` "
"следующим образом:"

#: in/chapter9.md:338
msgid ""
"```lisp\n"
"(memoize\n"
"```"
msgstr ""

#: in/chapter9.md:340
msgid "    `(defun f (x) ...)`"
msgstr ""

#: in/chapter9.md:342
msgid "    `)`"
msgstr ""

#: in/chapter9.md:344
msgid "Or define a macro that combines `defun` and `memoize`:"
msgstr "Или определить макрос, который объединяет `defun` и `memoize`:"

#: in/chapter9.md:349
msgid ""
"```lisp\n"
"(defmacro defun-memo (fn args &body body)\n"
"  \"Define a memoized function.\"\n"
"  `(memoize (defun ,fn ,args . ,body)))"
msgstr ""

#: in/chapter9.md:352
msgid ""
"(defun-memo f (x) ...)\n"
"```"
msgstr ""

#: in/chapter9.md:354
msgid ""
"Both of these approaches rely on the fact that `defun` returns the name of "
"the function defined."
msgstr ""
"Оба этих подхода основаны на том факте, что  `defun` возвращает имя "
"определенной функции."

#: in/chapter9.md:375
msgid ""
"| []() |             |            |          |                |\n"
"|------|-------------|------------|----------|----------------|\n"
"| *n*  | `(fib *n*)` | unmemoized | memoized | memoized up to |\n"
"| 25   | 121393      | 1.1        | .010     | 0              |\n"
"| 26   | 196418      | 1.8        | .001     | 25             |\n"
"| 27   | 317811      | 2.9        | .001     | 26             |\n"
"| 28   | 514229      | 4.7        | .001     | 27             |\n"
"| 29   | 832040      | 8.2        | .001     | 28             |\n"
"| 30   | 1346269     | 12.4       | .001     | 29             |\n"
"| 31   | 2178309     | 20.1       | .001     | 30             |\n"
"| 32   | 3524578     | 32.4       | .001     | 31             |\n"
"| 33   | 5702887     | 52.5       | .001     | 32             |\n"
"| 34   | 9227465     | 81.5       | .001     | 33             |\n"
"| 50   | 2.0e10      | -          | .014     | 34             |\n"
"| 100  | 5.7e20      | -          | .031     | 50             |\n"
"| 200  | 4.5e41      | -          | .096     | 100            |\n"
"| 500  | 2.2e104     | -          | .270     | 200            |\n"
"| 1000 | 7.0e208     | -          | .596     | 500            |\n"
"| 1000 | 7.0e208     | -          | .001     | 1000           |\n"
"| 1000 | 7.0e208     | -          | .876     | 0              |"
msgstr ""

#: in/chapter9.md:380
msgid ""
"Now we show a table giving the values of `(fib *n*)` for certain *n*, and "
"the time in seconds to compute the value, before and after `(memoize "
"'fib)`.\n"
"For larger values of *n*, approximations are shown in the table, although "
"`fib` actually returns an exact integer.\n"
"With the unmemoized version, I stopped at *n*  =  34, because the times were "
"getting too long.\n"
"For the memoized version, even *n*  =  1000 took under a second."
msgstr ""
"Теперь мы показываем таблицу, в которой указаны значения `(fib *n*)` для "
"определенного *n*, и время в секундах для вычисления значения, до и после "
"выполнения `(memoize 'fib)`.\n"
"Для дальнейших значений *n*, показаны приближенные значения в таблице, хотя "
"на самом деле `fib` возвращает точное целое число.\n"
"Для незапоминающей(unmemoized) версии, я остановился на *n*  =  34, потому "
"что время выполнения становилось слишком длинным.\n"
"Для замоминающей(memoized) версии, даже  *n*  =  1000 заняло меньше секунды."

#: in/chapter9.md:383
msgid ""
"Note there are three entries for (`fib 1000`).\n"
"The first entry represents the incremental computation when the table "
"contains the memoized values up to 500, the second entry shows the time for "
"a table lookup when (`fib 1000`) is already computed, and the third entry is "
"the time for a complete computation starting with an empty table."
msgstr ""
"Обратите внимание, что есть три записи для (`fib 1000`).\n"
"Первая запись представляет собой инкрементное вычисление, когда таблица "
"содержит запомненные(memoized) значения до 500, вторая запись показывает "
"время поиска в таблице, когда (`fib 1000`) уже вычислено, а третья - время "
"для полного вычисления, начиная с пустой таблицы."

#: in/chapter9.md:394
msgid ""
"It should be noted that there are two general approaches to discussing the "
"efficiency of an algorithm.\n"
"One is to time the algorithm on representative inputs, as we did in this "
"table.\n"
"The other is to analyze the *asymptotic complexity* of the algorithm.\n"
"For the `fib` problem, an asymptotic analysis considers how long it takes to "
"compute `(fib *n*)` as *n* approaches infinity.\n"
"The notation *O*(*f*(*n*)) is used to describe the complexity.\n"
"For example, the memoized version `fib` is an *O*(*n*) algorithm because the "
"computation time is bounded by some constant times *n*, for any value of "
"*n*.\n"
"The unmemoized version, it turns out, is *O*(1.\n"
"7*n*), meaning computing `fib` of n  +  1 can take up to 1.7 times as long "
"as `fib` of *n*.\n"
"In simpler terms, the memoized version has *linear* complexity, while the "
"unmemoized version has *exponential* complexity.\n"
"[Exercise 9.4](B9780080571157500091.xhtml#p4655) ([Page 308]"
"(B9780080571157500091.xhtml#p308)) describes where the 1.7 comes from, and "
"gives a tighter bound on the complexity."
msgstr ""
"Следует отметить, что есть два общих подхода к обсуждению эффективности "
"алгоритма.\n"
"Один из них - сопоставить алгоритм с репрезентативными входными данными, как "
"мы сделали в этой таблице.\n"
"Другой - анализировать *асимптотическую сложность* алгоритма.\n"
"Для задачи `fib` асимптотический анализ рассматривает, сколько времени "
"требуется для вычисления `(fib *n*)` когда *n* приближается к "
"бесконечности.\n"
"Обозначение *O*(*f*(*n*)) используется для описания сложности.\n"
"Например, запоминающая версия `fib` является алгоритмом *O*(*n*), потому что "
"время вычислений ограничено некоторым постоянным временем *n*, для любого "
"значения *n*.\n"
"Незапоминающая версия, оно оказывается, is *O*(1.7*n*), что означает, что "
"вычисление `fib` для n  +  1 может занимать в 1.7 раза больше времени, чем "
"вычисление `fib` для *n*.\n"
"Проще говоря, запоминающая версия имеет *линейную* сложность, в то время как "
"не запоминающая версия имеет *экспотенциальную* сложность.\n"
"[В упражнении 9.4](B9780080571157500091.xhtml#p4655) ([Page 308]"
"(B9780080571157500091.xhtml#p308)) объясняется откуда взялось 1.7, и дается "
"более жесткая оценка сложности."

#: in/chapter9.md:401
msgid ""
"The version of `memo` presented above is inflexible in several ways.\n"
"First, it only works for functions of one argument.\n"
"Second, it only returns a stored value for arguments that are `eql`, because "
"that is how hash tables work by default.\n"
"For some applications we want to retrieve the stored value for arguments "
"that are `equal`.\n"
"Third, there is no way to delete entries from the hash table.\n"
"In many applications there are times when it would be good to clear the hash "
"table, either because it has grown too large or because we have finished a "
"set of related problems and are moving on to a new problem."
msgstr ""
"Представленная выше версия `memo` негибка по нескольким причинам.\n"
"Во-первых, она работает только с функцией с одним аргументом.\n"
"Во-вторых, она возвращает сохраненное значение только для аргументов, "
"которые являются `eql`, потому что именно так работают хеш-таблицы по "
"умолчанию. \n"
"Для некоторых приложений мы хотим получить сохраненное значение для "
"аргументов, которые являются `equal`.\n"
"В-третьих, нет возможности удалять записи в хеш-таблице.\n"
"Во многих приложениях бывают случаи, когда было бы хорошо очистить хеш-"
"таблицу либо потому, что она стала слишком большой, либо потому, что мы "
"закончили некий набор связаных проблем и переходим к новой проблеме."

#: in/chapter9.md:410
msgid ""
"The versions of `memo` and `memoize` below handle these three problems.\n"
"They are compatible with the previous version but add three new keywords for "
"the extensions.\n"
"The `name` keyword stores the hash table on the property list of that name, "
"so it can be accessed by `clear-memoize`.\n"
"The `test` keyword tells what kind of hash table to create: `eq, eql, or "
"equal`.\n"
"Finally, the `key` keyword tells which arguments of the function to index "
"under.\n"
"The default is the first argument (to be compatible with the previous "
"version), but any combination of the arguments can be used.\n"
"If you want to use all the arguments, specify `identity` as the key.\n"
"Note that if the key is a list of arguments, then you will have to use "
"`equal` hash tables."
msgstr ""
"Приведенные ниже версии `memo` и `memoize` решают эти три проблемы.\n"
"Они совместимы с предыдущей версией, но добавляют три новых ключевых слова "
"для расширений.\n"
"Ключевое слово `name` сохраняет хеш-таблицу в списке свойств этого имени, "
"поэтому к ней можно получить доступ с помощью `clear-memoize`.\n"
"Ключевое слово `test` сообщает какую хэш-таблицу создавать: `eq, eql или "
"equal`.\n"
"Наконец, ключевое слово `key` сообщает, какие аргументы функции нужно "
"индексировать.\n"
"По умолчанию, используется первый аргумент (для совместимости с предыдущей "
"версией), но можно использовать любую комбинацию аргументов.\n"
"Если вы хотите использовать все аргументы, укажите в качестве ключа "
"`identity`.\n"
"Обратите внимание: если key(ключ) представляет собой список аргументов, вам "
"придется использовать хэш-таблицы сравнивающие через `equal`."

#: in/chapter9.md:423
msgctxt "in/chapter9.md:423"
msgid ""
"```lisp\n"
"(defun memo (fn &key (key #'first) (test #'eql) name)\n"
"  \"Return a memo-function of fn.\"\n"
"  (let ((table (make-hash-table :test test)))\n"
"    (setf (get name 'memo) table)\n"
"    #'(lambda (&rest args)\n"
"        (let ((k (funcall key args)))\n"
"          (multiple-value-bind (val found-p)\n"
"              (gethash k table)\n"
"            (if found-p val\n"
"                (setf (gethash k table) (apply fn args))))))))\n"
"```"
msgstr ""

#: in/chapter9.md:432
msgid ""
"```lisp\n"
"(defun memoize (fn-name &key (key #'first) (test #'eql))\n"
"  \"Replace fn-name's global definition with a memoized version.\"\n"
"  (clear-memoize fn-name)\n"
"  (setf (symbol-function fn-name)\n"
"        (memo (symbol-function fn-name)\n"
"              :name fn-name :key key :test test)))\n"
"```"
msgstr ""

#: in/chapter9.md:439
msgid ""
"```lisp\n"
"(defun clear-memoize (fn-name)\n"
"  \"Clear the hash table from a memo function.\"\n"
"  (let ((table (get fn-name 'memo)))\n"
"    (when table (clrhash table))))\n"
"```"
msgstr ""

#: in/chapter9.md:441
msgid "## 9.2 Compiling One Language into Another"
msgstr "## 9.2 Компиляция одного языка в другой"

#: in/chapter9.md:445
msgid ""
"In [chapter 2](B9780080571157500029.xhtml) we defined a new language-the "
"language of grammar rules-which was processed by an interpreter designed "
"especially for that language.\n"
"An *interpreter* is a program that looks at some data structure representing "
"a \"program\" or sequence of rules of some sort and interprets or evaluates "
"those rules.\n"
"This is in contrast to a *compiler*, which translates some set of rules in "
"one language into a program in another language."
msgstr ""
"В [Главе 2](B9780080571157500029.xhtml) мы определили новый язык - язык "
"граматических правил,- который обрабатывался интерпретатором, разработанным "
"специально для этого языка.\n"
"*Интепретатор/interpreter* это программа, котора смотрит на некоторую "
"структуру данных, представляющую \"программу\" или последовательность правил "
"определенного типа, и интерпретирует или вычисляет(оценивает) эти правила.\n"
"В этом отличие от *компилятора/compiler*,  который переводит некоторый набор "
"правил на одном языке в программу на другом языке."

#: in/chapter9.md:448
msgid ""
"The function `generate` was an interpreter for the \"language\" defined by "
"the set of grammar rules.\n"
"Interpreting these rules is straightforward, but the process is some-what "
"inefficient, in that generate must continually search through the "
"`*grammar*` to find the appropriate rule, then count the length of the right-"
"hand side, and so on."
msgstr ""
"Функция `generate` была интерпретатором для языка \"language\" определенного "
"набором граматических правил.\n"
"Интерпретация этих правил проста, но процесс несколько неэффективен, так "
"как  generate должен постоянно искать в граматике `*grammar*` подходящее "
"правило, затем подсчитывать длину правой части и так далее."

#: in/chapter9.md:453
msgid ""
"A compiler for this rule-language would take each rule and translate it into "
"a function.\n"
"These functions could then call each other with no need to search through "
"the `*grammar*`.\n"
"We implement this approach with the function `compile-rule`.\n"
"It makes use of the auxiliary functions `one-of` and `rule-lhs` and `rule-"
"rhs` from [Page 40](B9780080571157500029.xhtml#p40), repeated here:"
msgstr ""
"Компилятор для этого языка правил принимает каждое правило и переводит его в "
"функцию.\n"
"Эти функции могут затем вызывать друг друга без необходимости поиска в "
"граматике `*grammar*`.\n"
"Мы реализуем этот подход с помощью функции `compile-rule`.\n"
"Она использует вспомогательные функции `one-of` и `rule-lhs` и `rule-rhs` со "
"[Страницы 40](B9780080571157500029.xhtml#p40), повторенные здесь:"

#: in/chapter9.md:457
msgid ""
"```lisp\n"
"(defun rule-lhs (rule)\n"
"```"
msgstr ""

#: in/chapter9.md:459
msgid "  `\"The left-hand side of a rule.\"`"
msgstr ""

#: in/chapter9.md:461
msgid "  `(first rule))`"
msgstr ""

#: in/chapter9.md:465
msgid ""
"```lisp\n"
"(defun rule-rhs (rule)\n"
"```"
msgstr ""

#: in/chapter9.md:467
msgid "  `\"The right-hand side of a rule.\"`"
msgstr ""

#: in/chapter9.md:469
msgid "  `(rest (rest rule)))`"
msgstr ""

#: in/chapter9.md:473
msgid ""
"```lisp\n"
"(defun one-of (set)\n"
"```"
msgstr ""

#: in/chapter9.md:475
msgid "  `\"Pick one element of set, and make a list of it.\"`"
msgstr ""

#: in/chapter9.md:477
msgid "  `(list (random-elt set)))`"
msgstr ""

#: in/chapter9.md:483
msgid ""
"```lisp\n"
"(defun random-elt (seq)\n"
"  \"Pick a random element out of a sequence.\"\n"
"  (elt seq (random (length seq))))\n"
"```"
msgstr ""

#: in/chapter9.md:490
msgid ""
"The function `compile-rule` turns a rule into a function definition by "
"building up Lisp code that implements all the actions that generate would "
"take in interpreting the rule.\n"
"There are three cases.\n"
"If every element of the right-hand side is an atom, then the rule is a "
"lexical rule, which compiles into a call to `one-of` to pick a word at "
"random.\n"
"If there is only one element of the right-hand side, then `build-code` is "
"called to generate code for it.\n"
"Usually, this will be a call to append to build up a list.\n"
"Finally, if there are several elements in the right-hand side, they are each "
"turned into code by `build-code`; are given a number by `build-cases`; and "
"then a `case` statement is constructed to choose one of the cases."
msgstr ""
"Функция `compile-rule` превращает правило в определение функции, создавая "
"код на Лиспе, который реализует все действия, которые будут выполняться при "
"интерпретации правила.\n"
"Есть три случая.\n"
"Если каждый элемент правой части является атомом, то правило является "
"лексическим правилом, которое компилируется в вызов `one-of` для случайного "
"выбора слова.\n"
"Если есть только один элемент с правой стороны, то вызывается `build-code` "
"для генерации кода для него.\n"
"Обычно это будет вызов (append)добавления для создания списка.\n"
"Наконец, если в правой части есть несколько элементов, каждый из них "
"превращается в код с помощью `build-code`; присваиваются числовые "
"значения(номера) с помощью `build-case`; а затем строится оператор `case` "
"для выбора одного из случаев."

#: in/chapter9.md:494
msgid ""
"```lisp\n"
"(defun compile-rule (rule)\n"
"```"
msgstr ""

#: in/chapter9.md:496
msgid "  `\"Translate a grammar rule into a LISP function definition.\"`"
msgstr ""

#: in/chapter9.md:498
msgid "  `(let ((rhs (rule-rhs rule)))`"
msgstr ""

#: in/chapter9.md:500
msgid "      `'(defun ,(rule-lhs rule) ()`"
msgstr ""

#: in/chapter9.md:504
msgid ""
"```lisp\n"
"        ,(cond ((every #'atom rhs) '(one-of ',rhs))\n"
"```"
msgstr ""

#: in/chapter9.md:506
msgid "              `((length  =l rhs) (build-code (first rhs)))`"
msgstr ""

#: in/chapter9.md:508
msgid "              `(t '(case (random .(length rhs))`"
msgstr ""

#: in/chapter9.md:510
msgid "                  `,@(build-cases 0 rhs)))))))`"
msgstr ""

#: in/chapter9.md:514
msgid ""
"```lisp\n"
"(defun build-cases (number choices)\n"
"```"
msgstr ""

#: in/chapter9.md:516
msgid "  `\"Return a list of case-clauses\"`"
msgstr ""

#: in/chapter9.md:518
msgid "  `(when choices`"
msgstr ""

#: in/chapter9.md:520
msgid "      `(cons (list number (build-code (first choices)))`"
msgstr ""

#: in/chapter9.md:522
msgid "              `(build-cases (+ number 1) (rest choices)))))`"
msgstr ""

#: in/chapter9.md:526
msgid ""
"```lisp\n"
"(defun build-code (choice)\n"
"```"
msgstr ""

#: in/chapter9.md:528
msgid "  `\"Append together multiple constituents\"`"
msgstr ""

#: in/chapter9.md:530
msgid "  `(cond ((null choice) nil)`"
msgstr ""

#: in/chapter9.md:532
msgid "              `((atom choice) (list choice))`"
msgstr ""

#: in/chapter9.md:534
msgid "              `((length=1 choice) choice)`"
msgstr ""

#: in/chapter9.md:536
msgid "              `(t '(append ,@(mapcar #'build-code choice)))))`"
msgstr ""

#: in/chapter9.md:542
msgid ""
"```lisp\n"
"(defun length=1 (x)\n"
"  \"Is x a list of length 1?\"\n"
"  (and (consp x) (null (cdr x))))\n"
"```"
msgstr ""

#: in/chapter9.md:546
msgid ""
"The Lisp code built by `compile-rule` must be compiled or interpreted to "
"make it available to the Lisp system.\n"
"We can do that with one of the following forms.\n"
"Normally we would want to call `compile`, but during debugging it may be "
"easier not to."
msgstr ""
"Код Лиспа, созданный с помощью `compile-rule`(компиляции правил), должен "
"быть скомпилирован или интерпретирован, чтобы сделать его доступным для "
"системы Лисп.\n"
"Мы можем сделать это с помощью одной из следующих форм.\n"
"Обычно мы хотели бы вызвать `compile`, но во время отладки может быть проще "
"этого не делать."

#: in/chapter9.md:551
msgid ""
"```lisp\n"
"(dolist (rule *grammar*) (eval (compile-rule rule)))\n"
"(dolist (rule *grammar*) (compile (eval (compile-rule rule))))\n"
"```"
msgstr ""

#: in/chapter9.md:555
msgid ""
"One frequent way to use compilation is to define a macro that expands into "
"the code generated by the compiler.\n"
"That way, we just type in calls to the macro and don't have to worry about "
"making sure all the latest rules have been compiled.\n"
"We might implement this as follows:"
msgstr ""
"Одним из частых способов использования компиляции является определение "
"макроса, который расширяется в код, созданный компилятором.\n"
"Таким образом, мы просто вводим вызовы макроса и не должны беспокоиться о "
"том, чтобы убедиться, что все последние правила скомпилированы.\n"
"Мы можем реализовать это следующим образом:"

#: in/chapter9.md:559
msgid ""
"```lisp\n"
"(defmacro defrule (&rest rule)\n"
"```"
msgstr ""

#: in/chapter9.md:561
msgid "    `\"Define a grammar rule\"`"
msgstr ""

#: in/chapter9.md:563
msgid "    `(compile-rule rule))`"
msgstr ""

#: in/chapter9.md:572
msgid ""
"```lisp\n"
"(defrule Sentence -> (NP VP))\n"
"(defrule NP -> (Art Noun))\n"
"(defrule VP -> (Verb NP))\n"
"(defrule Art -> the a)\n"
"(defrule Noun -> man bail woman table)\n"
"(defrule Verb -> hit took saw liked)\n"
"```"
msgstr ""

#: in/chapter9.md:577
msgid ""
"Actually, the choice of using one big list of rules (like `*grammar*`) "
"versus using individual macros to define rules is independent of the choice "
"of compiler versus interpreter.\n"
"We could just as easily define defrule simply to push the rule onto "
"`*grammar*`.\n"
"Macros like `defrule` are useful when you want to define rules in different "
"places, perhaps in several separate files.\n"
"The `defparameter` method is appropriate when all the rules can be defined "
"in one place."
msgstr ""
"Фактически, выбор использования одного большого списка правил (например, "
"`*grammar*`) по сравнению с использованием отдельных макросов для "
"определения правил не зависит от выбора: компилятор или интерпретатор.\n"
"Мы могли бы так же легко определить defrule, просто поместив правило в "
"граматику - `*grammar*`.\n"
"Такие макросы, как defrule, полезны, когда вы хотите определить правила в "
"разных местах, возможно, в нескольких отдельных файлах.\n"
"Метод `defparameter` подходит, когда все правила могут быть определены в "
"одном месте."

#: in/chapter9.md:579
msgid ""
"We can see the Lisp code generated by `compile-rule` in two ways: by passing "
"it a rule directly:"
msgstr ""
"Мы можем увидеть код Лисп, сгенерированный `compile-rule` двумя способами: "
"передав ему правило напрямую:"

#: in/chapter9.md:584
msgid ""
"```lisp\n"
"> (compile-rule '(Sentence -> (NP VP)))\n"
"(DEFUN SENTENCE ()\n"
"```"
msgstr ""

#: in/chapter9.md:586
msgid "      `(APPEND (NP) (VP)))`"
msgstr ""

#: in/chapter9.md:591
msgid ""
"```lisp\n"
"> (compile-rule '(Noun -> man bail woman table))\n"
"(DEFUN NOUN ()\n"
"```"
msgstr ""

#: in/chapter9.md:593
msgid "      `(ONE-OF '(MAN BALL WOMAN TABLE)))`"
msgstr ""

#: in/chapter9.md:596
msgid ""
"or by macroexpanding a `defrule` expression.\n"
"The compiler was designed to produce the same code we were writing in our "
"first approach to the generation problem (see [Page 35](B9780080571157500029."
"xhtml#p35))."
msgstr ""
"или макрорасширением выражения defrule.\n"
"Компилятор был разработан для создания того же кода, который мы писали при "
"первом подходе к проблеме генерации (см. [Страница 35](B9780080571157500029."
"xhtml#p35))."

#: in/chapter9.md:601
msgid ""
"```lisp\n"
"> (macroexpand '(defrule Adj* -> () Adj (Adj Adj*)))\n"
"(DEFUN ADJ* ()\n"
"```"
msgstr ""

#: in/chapter9.md:603
msgid "  `(CASE (RANDOM 3)`"
msgstr ""

#: in/chapter9.md:605
msgid "      `(0 NIL)`"
msgstr ""

#: in/chapter9.md:607
msgid "      `(1 (ADJ))`"
msgstr ""

#: in/chapter9.md:609
msgid "      `(2 (APPEND (ADJ) (ADJ*)))))`"
msgstr ""

#: in/chapter9.md:615
msgid ""
"Interpreters are usually easier to write than compilers, although in this "
"case, even the compiler was not too difficult.\n"
"Interpreters are also inherently more flexible than compilers, because they "
"put off making decisions until the last possible moment.\n"
"For example, our compiler considers the right-hand side of a rule to be a "
"list of words only if every element is an atom.\n"
"In all other cases, the elements are treated as nonterminals.\n"
"This could cause problems if we extended the definition of `Noun` to include "
"the compound noun \"chow chow\":"
msgstr ""
"Интерпретаторы обычно легче писать, чем компиляторы, хотя в этом случае даже "
"компилятор не будет слишком сложным.\n"
"Интерпретаторы также по своей сути более гибкие, чем компиляторы, потому что "
"они откладывают принятие решений до последнего возможного момента.\n"
"Например, наш компилятор считает правую часть правила списком слов, даже "
"если каждый элемент является атомом.\n"
"Во всех остальных случаях элементы рассматриваются как нетерминальные.\n"
"Это могло вызвать проблемы, если бы мы расширили определение "
"`Noun`(Существительного), включив в него составное существительное(noun) "
"\"chow chow\":"

#: in/chapter9.md:619
msgid ""
"```lisp\n"
"(defrule Noun -> man ball woman table (chow chow))\n"
"```"
msgstr ""

#: in/chapter9.md:621
msgid "The rule would expand into the following code:"
msgstr "Правило расширилось бы до следующего кода:"

#: in/chapter9.md:626
msgid ""
"```lisp\n"
"(DEFUN NOUN ()\n"
"  (CASE (RANDOM 5)\n"
"```"
msgstr ""

#: in/chapter9.md:628
msgid "      `(0 (MAN))`"
msgstr ""

#: in/chapter9.md:630
msgid "      `(1 (BALL))`"
msgstr ""

#: in/chapter9.md:632
msgid "      `(2 (WOMAN))`"
msgstr ""

#: in/chapter9.md:634
msgid "      `(3 (TABLE))`"
msgstr ""

#: in/chapter9.md:636
msgid "      `(4 (APPEND (CHOW) (CHOW)))))`"
msgstr ""

#: in/chapter9.md:645
msgid ""
"The problem is that `man` and `ball` and all the others are suddenly treated "
"as functions, not as literal words.\n"
"So we would get a run-time error notifying us of undefined functions.\n"
"The equivalent rule would cause no trouble for the interpreter, which waits "
"until it actually needs to generate a symbol to decide if it is a word or a "
"nonterminal.\n"
"Thus, the semantics of rules are different for the interpreter and the "
"compiler, and we as program implementors have to be very careful about how "
"we specify the actual meaning of a rule.\n"
"In fact, this was probably a bug in the interpreter version, since it "
"effectively prohibits words like \"noun\" and \"sentence\" from occurring as "
"words if they are also the names of categories.\n"
"One possible resolution of the conflict is to say that an element of a right-"
"hand side represents a word if it is an atom, and a list of categories if it "
"is a list.\n"
"If we did indeed settle on that convention, then we could modify both the "
"interpreter and the compiler to comply with the convention.\n"
"Another possibility would be to represent words as strings, and categories "
"as symbols."
msgstr ""
"Проблема в том, что `man`, `ball` и все остальные неожиданно стали "
"рассматриваться как функции, а не как буквальные слова.\n"
"Таким образом, мы получим ошибку времени выполнения, сообщающую нам о "
"неопределенных функциях.\n"
"Эквивалентное правило не вызовет проблем для интерпретатора, который ждет, "
"пока ему действительно не понадобиться сгенерировать символ, чтобы решить, "
"является ли он словом или нетерминальным символом.\n"
"Таким образом, семантика правил различна для интерпретатора и компилятора, и "
"мы, разработчики программ, должны быть очень осторожны с тем, как мы "
"указываем фактическое значение правила.\n"
"Фактически, это, вероятно, было ошибкой в ​​версии интерпретатора, поскольку "
"он эффективно запрещает таким словам, как \"noun\" и \"sentence\" "
"встречаться в виде слов, если они также являются названиями категорий.\n"
"Одно из возможных решений конфликта - сказать, что элемент правой части "
"представляет слово, если это атом, и список категорий, если это список.\n"
"Если бы мы действительно остановились на этом соглашении, то мы могли бы "
"модифицировать и интерпретатор, и компилятор, чтобы соответствовать этому "
"соглашению.\n"
"Другая возможность - представить слова в виде строк, а категории в виде "
"символов."

#: in/chapter9.md:648
msgid ""
"The flip side of losing run-time flexibility is gaining compile-time "
"diagnostics.\n"
"For example, it turns out that on the Common Lisp system I am currently "
"using, I get some useful error messages when I try to compile the buggy "
"version of `Noun:`"
msgstr ""
"Обратной стороной потери гибкости во время выполнения является получение "
"диагностики во время компиляции.\n"
"Например, оказывается, что в системе Common Lisp, которую я использую "
"сейчас, я получаю несколько полезных сообщений об ошибках, когда пытаюсь "
"скомпилировать ошибочную версию `Noun`:"

#: in/chapter9.md:653
msgid ""
"```lisp\n"
"> (defrule Noun -> man bail woman table (chow chow))\n"
"The following functions were referenced but don't seem defined:\n"
"```"
msgstr ""

#: in/chapter9.md:655
msgid "  `CHOW referenced by NOUN`"
msgstr ""

#: in/chapter9.md:657
msgid "  `TABLE referenced by NOUN`"
msgstr ""

#: in/chapter9.md:659
msgid "  `WOMAN referenced by NOUN`"
msgstr ""

#: in/chapter9.md:661
msgid "  `BALL referenced by NOUN`"
msgstr ""

#: in/chapter9.md:663
msgid "  `MAN referenced by NOUN`"
msgstr ""

#: in/chapter9.md:667
msgid ""
"```lisp\n"
"NOUN\n"
"```"
msgstr ""

#: in/chapter9.md:676
msgid ""
"Another problem with the compilation scheme outlined here is the possibility "
"of *name clashes*.\n"
"Under the interpretation scheme, the only names used were the function "
"generate and the variable `*grammar*`.\n"
"With compilation, every left-hand side of a rule becomes the name of a "
"function.\n"
"The grammar writer has to make sure he or she is not using the name of an "
"existing Lisp function, and hence redefining it.\n"
"Even worse, if more than one grammar is being developed at the same time, "
"they cannot have any functions in common.\n"
"If they do, the user will have to recompile with every switch from one "
"grammar to another.\n"
"This may make it difficult to compare grammars.\n"
"The best away around this problem is to use the Common Lisp idea of "
"*packages*, but for small exercises name clashes can be avoided easily "
"enough, so we will not explore packages until [section 24.1]"
"(B9780080571157500248.xhtml#s0010)."
msgstr ""
"Еще одна проблема с описанной здесь схемой компиляции - это возможность "
"*конфликтов имен*.\n"
"В схеме интерпретации использовались только имена функции generate и "
"переменной `*grammar*`.\n"
"При компиляции каждая левая часть правила становится именем функции.\n"
"Автор грамматики должен убедиться, что он или она не использует имя "
"существующей функции Лиспа, и, следовательно, не переопределяет ее.\n"
"Хуже того, если одновременно разрабатывается более одной грамматики, у них "
"не должно быть общих функций.\n"
"Если это произойдет, пользователю придется выполнять перекомпиляцию при "
"каждом переключении с одной грамматики на другую.\n"
"Это может затруднить сравнение грамматик.\n"
"Лучшее решение этой проблемы - использовать идею *пакетов* в Common Lisp, но "
"для небольших упражнений конфликта имен можно  избежать достаточно легко, "
"поэтому мы не будем исследовать пакеты до [раздела 24.1]"
"(B9780080571157500248.xhtml#s0010)."

#: in/chapter9.md:681
msgid ""
"The major advantage of a compiler is speed of execution, when that makes a "
"difference.\n"
"For identical grammars running in one particular implementation of Common "
"Lisp on one machine, our interpreter generates about 75 sentences per "
"second, while the compiled approach turns out about 200.\n"
"Thus, it is more than twice as fast, but the difference is negligible unless "
"we need to generate many thousands of sentences.\n"
"In [section 9.6](#s0035) we will see another compiler with an even greater "
"speed-up."
msgstr ""
"Главное преимущество компилятора - это скорость выполнения, когда это имеет "
"значение.\n"
"Для идентичных грамматик, выполняемых в одной конкретной реализации Common "
"Lisp на одной машине, наш интерпретатор генерирует около 75 предложений в "
"секунду, в то время как компилируемый подход дает около 200.\n"
"Таким образом, это более чем в два раза быстрее, но разница незначительна, "
"если нам не нужно генерировать многие тысячи предложений.\n"
"В [разделе 9.6] (# s0035) мы увидим другой компилятор с еще большим "
"ускорением."

#: in/chapter9.md:684
msgid ""
"The need to optimize the code produced by your macros and compilers "
"ultimately depends on the quality of the underlying Lisp compiler.\n"
"For example, consider the following code:"
msgstr ""
"Необходимость оптимизации кода, создаваемого вашими макросами и "
"компиляторами, в конечном итоге зависит от качества базового Лисп "
"компилятора.\n"
"Например, рассмотрим следующий код:"

#: in/chapter9.md:690
msgid ""
"```lisp\n"
"(defun f1 (n l)\n"
"      (let ((l1 (first l))\n"
"                  (l2 (second l)))\n"
"```"
msgstr ""

#: in/chapter9.md:692
msgid "                `(expt (* 1 (+ n 0))`"
msgstr ""

#: in/chapter9.md:694
msgid "              `(- 4 (length (list l1 l2))))))`"
msgstr ""

#: in/chapter9.md:700
msgid ""
"```lisp\n"
"F1\n"
"> (defun f2 (n l) (* n n)) =>F2\n"
"> (disassemble 'fl)\n"
"```"
msgstr ""

#: in/chapter9.md:707
msgid ""
"| []()       |             |\n"
"|------------|-------------|\n"
"| `6 PUSH`   | `ARGIO ; N` |\n"
"| `7 MOVEM`  | `PDL-PUSH`  |\n"
"| `8 *`      | `PDL-POP`   |\n"
"| `9 RETURN` | `PDL-POP`   |"
msgstr ""

#: in/chapter9.md:712
msgid ""
"```lisp\n"
"Fl\n"
"> (disassemble 'f2)\n"
"```"
msgstr ""

#: in/chapter9.md:719
msgid ""
"| []()       |            |\n"
"|------------|------------|\n"
"| `6 PUSH`   | `ARGO ; N` |\n"
"| `7 MOVEM`  | `PDL-PUSH` |\n"
"| `8 *`      | `PDL-POP`  |\n"
"| `9 RETURN` | `PDL-POP`  |"
msgstr ""

#: in/chapter9.md:723
msgid ""
"```lisp\n"
"F2\n"
"```"
msgstr ""

#: in/chapter9.md:729
msgid ""
"This particular Lisp compiler generates the exact same code for `f1` and "
"`f2`.\n"
"Both functions square the argument `n`, and the four machine instructions "
"say, \"Take the 0th argument, make a copy of it, multiply those two numbers, "
"and return the result.\" It's clear the compiler has some knowledge of the "
"basic Lisp functions.\n"
"In the case of `f1`, it was smart enough to get rid of the local variables "
"`l1` and `l2` (and their initialization), as well as the calls to `first, "
"second, length,` and `list` and most of the arithmetic.\n"
"The compiler could do this because it has knowledge about the functions "
"`length` and `list` and the arithmetic functions.\n"
"Some of this knowledge might be in the form of simplification rules."
msgstr ""
"Этот Лисп компилятор генерирует точно такой же код для `f1` и `f2`.\n"
"Обе функции возводят аргумент `n` в квадрат, и четыре машинные инструкции "
"говорят: \"Возьмите 0-й аргумент, сделайте его копию, умножьте эти два числа "
"и верните результат\". Понятно, что компилятор имеет некоторые знания об "
"основных функциях Лиспа.\n"
"В случае с `f1` он был достаточно умен, чтобы избавиться от локальных "
"переменных `l1` и `l2` (и их инициализации), а также от вызовов `first, "
"second, length` и `list` и большей части арифметики.\n"
"Компилятор может сделать это, потому что он знает о функциях `length` и "
"`list` и арифметических функциях.\n"
"Некоторые из этих знаний могут быть в форме правил упрощения."

#: in/chapter9.md:732
msgid ""
"As a user of this compiler, there's no need for me to write clever macros or "
"compilers that generate streamlined code as seen in `f2`; I can blindly "
"generate code with possible inefficiencies like those in `f1`, and assume "
"that the Lisp compiler will cover up for my laziness.\n"
"With another compiler that didn't know about such optimizations, I would "
"have to be more careful about the code I generate."
msgstr ""
"Как пользователю этого компилятора, мне нет необходимости писать умные "
"макросы или компиляторы, которые генерируют упрощенный код, как показано в "
"`f2`; Я могу слепо сгенерировать код с возможной неэффективностью, как в "
"`f1`, и предполагать, что Лисп компилятор скроет мою лень.\n"
"С другим компилятором, который не знает о таких оптимизациях, мне пришлось "
"бы быть более осторожным с генерируемым мной кодом."

#: in/chapter9.md:734
msgid "## 9.3 Delaying Computation"
msgstr "## 9.3 Отложенные Вычисления"

#: in/chapter9.md:737
msgid ""
"Back on [Page 45](B9780080571157500029.xhtml#p45), we saw a program to "
"generate all strings derivable from a grammar.\n"
"One drawback of this program was that some grammars produce an infinite "
"number of strings, so the program would not terminate on those grammars."
msgstr ""
"Вернувшись на [Страницу 45](B9780080571157500029.xhtml#p45), мы увидим "
"программу для генерации всех строк, полученных из грамматики.\n"
"Одним из недостатков этой программы было то, что некоторые грамматики "
"производили бесконечное количество строк, поэтому программа не завершалась "
"при использовании этих грамматик."

#: in/chapter9.md:750
msgid ""
"It turns out that we often want to deal with infinite sets.\n"
"Of course, we can't enumerate all the elements of an infinite set, but we "
"should be able to represent the set and pick elements out one at a time.\n"
"In other words, we want to be able to specify how a set (or other object) is "
"constructed, but delay the actual construction, perhaps doing it "
"incrementally over time.\n"
"This sounds like a job for closures: we can specify the set constructor as a "
"function, and then call the function some time later.\n"
"We will implement this approach with the syntax used in Scheme-the macro "
"`delay` builds a closure to be computed later, and the function `force` "
"calls that function and caches away the value.\n"
"We use structures of type `delay` to implement this.\n"
"A delay structure has two fields: the value and the function.\n"
"Initially, the value field is undefined, and the function field holds the "
"closure that will compute the value.\n"
"The first time the delay is forced, the function is called, and its result "
"is stored in the value field.\n"
"The function field is then set to nil to indicate that there is no need to "
"call the function again.\n"
"The function `force` checks if the function needs to be called, and returns "
"the value.\n"
"If `force` is passed an argument that is not a delay, it just returns the "
"argument."
msgstr ""
"Оказывается, мы часто хотим иметь дело с бесконечными множествами.\n"
"Конечно, мы не можем перечислить все элементы бесконечного множества, но мы "
"должны иметь возможность представлять множество и выбирать элементы по "
"одному.\n"
"Другими словами, мы хотим иметь возможность указывать, как создается "
"множество(набор) (или другой объект), но задерживать фактическое построение, "
"возможно, делая это постепенно с течением времени.\n"
"Это звучит как работа для замыканий: мы можем указать конструктор множества "
"как функцию, а затем вызвать функцию через некоторое время.\n"
"Мы реализуем этот подход с синтаксисом, используемым в Scheme - макрос "
"`delay` создает замыкание, которое будет вычислено позже, а функция `force` "
"вызывает эту функцию и кэширует значение.\n"
"Для этого мы используем структуры типа `delay`.\n"
"В структуре задержки(delay) есть два поля: value(значение) и "
"function(функция).\n"
"Первоначально поле value не определено, а поле function(функции) содержит "
"замыкание, которое будет вычислять значение.\n"
"Вначале delay применяется в force, где вызывается function, и ее результат "
"сохраняется в поле значения.\n"
"Затем поле function устанавливается в nil, чтобы указать, что нет "
"необходимости вызывать функцию снова.\n"
"Функция `force` проверяет, нужно ли вызывать функцию, и возвращает "
"значение.\n"
"Если `force` передается аргумент, который не является delay, она просто "
"возвращает аргумент."

#: in/chapter9.md:753
msgid ""
"```lisp\n"
"(defstruct delay value (computed? nil))"
msgstr ""

#: in/chapter9.md:758
msgid ""
"(defmacro delay (&rest body)\n"
"  \"A computation that can be executed later by FORCE.\"\n"
"  `(make-delay :value #'(lambda () . ,body)))\n"
"```"
msgstr ""

#: in/chapter9.md:762
msgid ""
"```lisp\n"
"(defun force (x)\n"
"```"
msgstr ""

#: in/chapter9.md:764
msgid "  `\"Find the value of x, by computing if it is a delay.\"`"
msgstr ""

#: in/chapter9.md:766
msgid "  `(if (not (delay-p x))`"
msgstr ""

#: in/chapter9.md:768
msgid "            `x`"
msgstr ""

#: in/chapter9.md:770
msgid "            `(progn`"
msgstr ""

#: in/chapter9.md:772
msgid "            `(when (delay-function x)`"
msgstr ""

#: in/chapter9.md:774
msgid "                  `(setf (delay-value x)`"
msgstr ""

#: in/chapter9.md:776
msgid "                          `(funcall (delay-function x)))`"
msgstr ""

#: in/chapter9.md:778
msgid "                  `(setf (delay-function x) nil))`"
msgstr ""

#: in/chapter9.md:781
msgid ""
"            `(delay-value x))))`\n"
"```"
msgstr ""

#: in/chapter9.md:785
msgid ""
"Here's an example of the use of `delay`.\n"
"The list `x` is constructed using a combination of normal evaluation and "
"delayed evaluation.\n"
"Thus, the `1` is printed when `x` is created, `but` the `2` is not:"
msgstr ""
"Вот пример использования `delay`.\n"
"Список `x` строится с использованием комбинации нормального вычисления и "
"отложенного вычисления.\n"
"Таким образом, `1` печатается при создании `x`, а `2` - нет:"

#: in/chapter9.md:791
msgid ""
"```lisp\n"
"(setf x (list (print 1) (delay (print 2)))) =>\n"
"1\n"
"(1 #S(DELAY .-FUNCTION (LAMBDA () (PRINT 2))))\n"
"```"
msgstr ""

#: in/chapter9.md:794
msgid ""
"The second element is evaluated (and printed) when it is forced.\n"
"But then forcing it again just retrieves the cached value, rather than "
"calling the function again:"
msgstr ""
"Второй элемент вычисляется (и печатается), когда он вызывается force.\n"
"Но затем повторение force  просто извлекает кешированное значение, а не "
"вызывает функцию снова:"

#: in/chapter9.md:802
msgid ""
"```lisp\n"
"> (force (second x)) =>\n"
"2\n"
"2\n"
"> x => (1 #S(DELAY : VALUE 2))\n"
"> (force (second x)) => 2\n"
"```"
msgstr ""

#: in/chapter9.md:809
msgid ""
"Now let's see how delays can be used to build infinite sets.\n"
"An infinite set will be considered a special case of what we will call a "
"*pipe*: a list with a `first` component that has been computed, and a `rest` "
"component that is either a normal list or a delayed value.\n"
"Pipes have also been called delayed lists, generated lists, and (most "
"commonly) streams.\n"
"We will use the term *pipe* because *stream* already has a meaning in Common "
"Lisp.\n"
"The book *Artificial Intelligence Programming* ([Charniak et al.\n"
"1987](B9780080571157500285.xhtml#bb0180)) also calls these structures pipes, "
"reserving streams for delayed structures that do not cache computed results."
msgstr ""
"Теперь посмотрим, как можно использовать delay(задержки) для построения "
"бесконечных множеств.\n"
"Бесконечное множество будет считаться частным случаем того, что мы будем "
"называть *pipe*: список с вычисленным компонентом `first` и компонентом "
"`rest`, который является либо обычным списком, либо отложенным(delayed) "
"значением.\n"
"Каналы(pipes) также называются отложенными списками, генерированными "
"списками и (чаще всего) потоками.\n"
"Мы будем использовать термин *pipe*, потому что *stream* уже имеет значение "
"в Common Lisp.\n"
"В книге *Программирование искусственного интеллекта* ([Чарняк и др.\n"
"1987](B9780080571157500285.xhtml#bb0180)) также называет эти структуры "
"pipes, резервируя streams(потоки) для отложенных структур, которые не "
"кэшируют вычисленные результаты."

#: in/chapter9.md:813
msgid ""
"To distinguish pipes from lists, we will use the accessors `head` and `tail` "
"instead of `first` and `rest`.\n"
"We will also use `empty-pipe` instead of `nil, make-pipe` instead of `cons`, "
"and `pipe-elt` instead of `elt`.\n"
"Note that `make-pipe` is a macro that delays evaluation of the tail."
msgstr ""
"Чтобы отличать pipes(каналы) от списков, мы будем использовать функции "
"доступа(аксессоры) `head` и `tail` вместо `first` и `rest`.\n"
"Мы также будем использовать `empty-pipe` вместо `nil`, `make-pipe` вместо "
"`cons` и `pipe-elt` вместо `elt`.\n"
"Обратите внимание, что `make-pipe` - это макрос, который задерживает "
"вычисление хвоста(tail)."

#: in/chapter9.md:817
msgctxt "in/chapter9.md:817"
msgid ""
"```lisp\n"
"(defmacro make-pipe (head tail)\n"
"```"
msgstr ""

#: in/chapter9.md:819
msgctxt "in/chapter9.md:819"
msgid "  `\"Create a pipe by evaluating head and delaying tail.\"`"
msgstr ""

#: in/chapter9.md:821
msgid "  `'(cons ,head (delay ,tail)))`"
msgstr ""

#: in/chapter9.md:828
msgid ""
"```lisp\n"
"(defconstant empty-pipe nil)\n"
"(defun head (pipe) (first pipe))\n"
"(defun tail (pipe)(force (rest pipe)))\n"
"(defun pipe-elt (pipe i)\n"
"```"
msgstr ""

#: in/chapter9.md:830
msgid "  `\"The i-th element of a pipe, 0-based\"`"
msgstr ""

#: in/chapter9.md:832
msgid "  `(if (= i 0)`"
msgstr ""

#: in/chapter9.md:834
msgid "      `(head pipe)`"
msgstr ""

#: in/chapter9.md:836
msgid "      `(pipe-elt (tail pipe) (- i 1))))`"
msgstr ""

#: in/chapter9.md:838
msgid ""
"Here's a function that can be used to make a large or infinite sequence of "
"integers with delayed evaluation:"
msgstr ""
"Вот функция, которую можно использовать для создания большой или бесконечной "
"последовательности целых чисел с отложенным вычислением:"

#: in/chapter9.md:842
msgid ""
"```lisp\n"
"(defun integers (&optional (start 0) end)\n"
"```"
msgstr ""

#: in/chapter9.md:844
msgid "  `\"A pipe of integers from START to END.`"
msgstr ""

#: in/chapter9.md:846
msgid "  `If END is nil, this is an infinite pipe.\"`"
msgstr ""

#: in/chapter9.md:848
msgid "  `(if (or (null end) (<= start end))`"
msgstr ""

#: in/chapter9.md:850
msgid "      `(make-pipe start (integers (+ start 1) end))`"
msgstr ""

#: in/chapter9.md:852
msgid "      `nil))`"
msgstr ""

#: in/chapter9.md:857
msgid ""
"And here is an example of its use.\n"
"The pipe `c` represents the numbers from 0 to infinity.\n"
"When it is created, only the zeroth element, 0, is evaluated.\n"
"The computation of the other elements is delayed."
msgstr ""
"А вот и пример её использования.\n"
"pipe `c` представляет числа от 0 до бесконечности.\n"
"При его создании вычисляется только нулевой элемент, 0.\n"
"Вычисление других элементов задерживается(delayed)."

#: in/chapter9.md:862
msgid ""
"```lisp\n"
"> (setf c (integers 0)) => (0 . #S(DELAY :FUNCTION #  <  CLOSURE -  "
"77435477  >))\n"
">  (pipe-elt c 0) =>    0\n"
"```"
msgstr ""

#: in/chapter9.md:866
msgid ""
"Calling `pipe-elt` to look at the third element causes the first through "
"third elements to be evaluated.\n"
"The numbers 0 to 3 are cached in the correct positions, and further elements "
"remain unevaluated.\n"
"Another call to `pipe-elt` with a larger index would force them by "
"evaluating the delayed function."
msgstr ""
"Вызов `pipe-elt` для просмотра третьего элемента приводит к вычислению "
"элементов с первого по третий.\n"
"Числа от 0 до 3 кэшируются в правильных позициях, а другие элементы остаются "
"невычисленными.\n"
"Другой вызов `pipe-elt` с большим индексом заставит их вычислить отложенную "
"функцию."

#: in/chapter9.md:872
msgid ""
"```lisp\n"
"> (pipe-elt c 3) => 3\n"
"c =>\n"
"(0 . #S(DELAY\n"
"```"
msgstr ""

#: in/chapter9.md:874
msgid "                `: VALUE`"
msgstr ""

#: in/chapter9.md:876
msgid "                `(1 . #S(DELAY`"
msgstr ""

#: in/chapter9.md:878
msgid "                                    `: VALUE`"
msgstr ""

#: in/chapter9.md:880
msgid "                                    `(2 . #S(DELAY`"
msgstr ""

#: in/chapter9.md:882
msgid "                                                    `: VALUE`"
msgstr ""

#: in/chapter9.md:884
msgid "                                                    `(3 . #S(DELAY`"
msgstr ""

#: in/chapter9.md:886
msgid ""
"                                                                      `:"
"FUNCTION`"
msgstr ""

#: in/chapter9.md:888
msgid ""
"                                                                      `#  <  "
"CLOSURE -  77432724  >))))))))`"
msgstr ""

#: in/chapter9.md:893
msgid ""
"While this seems to work fine, there is a heavy price to pay.\n"
"Every delayed value must be stored in a two-element structure, where one of "
"the elements is a closure.\n"
"Thus, there is some storage wasted.\n"
"There is also some time wasted, as `tail` or `pipe-elt` must traverse the "
"structures."
msgstr ""
"Хотя это, кажется, работает нормально, но придется заплатить высокую цену.\n"
"Каждое отложенное значение должно храниться в двухэлементной структуре, где "
"одним из элементов является замыкание.\n"
"Таким образом, часть памяти теряется.\n"
"Так же некоторое время теряется, так как `tail` или `pipe-elt` должны "
"проходить по структуре."

#: in/chapter9.md:901
msgid ""
"An alternate representation for pipes is as (*value.\n"
"closure*) pairs, where the closure values are stored into the actual cons "
"cells as they are computed.\n"
"Previously we needed structures of type delay to distinguish a delayed from "
"a nondelayed object, but in a pipe we know the rest can be only one of three "
"things: nil, a list, or a delayed value.\n"
"Thus, we can use the closures directly instead of using `delay` structures, "
"if we have some way of distinguishing closures from lists.\n"
"Compiled closures are atoms, so they can always be distinguished from "
"lists.\n"
"But sometimes closures are implemented as lists beginning with `lambda` or "
"some other implementation-dependent symbol.[2](#fn0015) The built-in "
"function `functionp` is defined to be true of such lists, as well as of all "
"symbols and all objects returned by `compile`.\n"
"But using `functionp` means that we cannot have a pipe that includes the "
"symbol `lambda` as an element, because it will be confused for a closure:"
msgstr ""
"Альтернативное представление для pipe - это пары (*value . closure*), где "
"значения замыкания сохраняются в фактических cons-ячейках по мере их "
"вычисления.\n"
"Раньше нам требовались структуры типа delay, чтобы отличать "
"отложенный(задержанный) от неотложенного объекта, но в pipe, как мы знаем, "
"rest может быть только одним из трех: nil, список или отложенное значение.\n"
"Таким образом, мы можем использовать замыкания напрямую вместо использования "
"структур `delay`, если у нас есть способ отличить замыкания от списков.\n"
"Скомпилированные замыкания - это атомы, поэтому их всегда можно отличить от "
"списков.\n"
"Но иногда замыкания реализуются в виде списков, начинающихся с `lambda` или "
"какого-либо другого символа, зависящего от реализации. [2](#fn0015) "
"Встроенная функция `functionp` определена как истинная для таких списков, а "
"также для всех символов и всех объектов, возвращаемых `compile`.\n"
"Но использование `functionp` означает, что у нас не может быть pipe, который "
"включает в себя символ `lambda` как элемент, потому что его можно спутать с "
"замыканием:"

#: in/chapter9.md:905
msgid ""
"```lisp\n"
"> (functionp (last '(theta iota kappa lambda))) => T\n"
"```"
msgstr ""

#: in/chapter9.md:908
msgid ""
"If we consistently use compiled functions, then we could eliminate the "
"problem by testing with the built-in predicate `compiled-function-p`.\n"
"The following definitions do not make this assumption:"
msgstr ""
"Если мы будем последовательно использовать скомпилированные функции, то мы "
"сможем устранить проблему с тестированием используя встроенный предикат "
"`compiled-function-p`.\n"
"Следующие определения не делают этого предположения:"

#: in/chapter9.md:912
msgctxt "in/chapter9.md:912"
msgid ""
"```lisp\n"
"(defmacro make-pipe (head tail)\n"
"```"
msgstr ""

#: in/chapter9.md:914
msgctxt "in/chapter9.md:914"
msgid "  `\"Create a pipe by evaluating head and delaying tail.\"`"
msgstr ""

#: in/chapter9.md:916
msgid "  `'(cons ,head #'(lambda () ,tail)))`"
msgstr ""

#: in/chapter9.md:920
msgid ""
"```lisp\n"
"(defun tail (pipe)\n"
"```"
msgstr ""

#: in/chapter9.md:922
msgid "  `\"Return tail of pipe or list, and destructively update`"
msgstr ""

#: in/chapter9.md:924
msgid "  `the tail if it is a function.\"`"
msgstr ""

#: in/chapter9.md:926
msgid "  `(if (functionp (rest pipe))`"
msgstr ""

#: in/chapter9.md:928
msgid "      `(setf (rest pipe) (funcall (rest pipe)))`"
msgstr ""

#: in/chapter9.md:930
msgid "      `(rest pipe)))`"
msgstr ""

#: in/chapter9.md:934
msgid ""
"Everything else remains the same.\n"
"If we recompile `integers` (because it uses the `macro make-pipe`), we see "
"the following behavior.\n"
"First, creation of the infinite pipe `c` is similar:"
msgstr ""
"Все остальное остается прежним.\n"
"Если мы перекомпилируем `integers` (потому что она использует макрос `make-"
"pipe`), мы увидим следующее поведение.\n"
"Во-первых, создание бесконечного pipe `c` аналогично:"

#: in/chapter9.md:939
msgid ""
"```lisp\n"
"> (setf c (integers 0)) => (0 . #  <  CLOSURE 77350123  >)\n"
"> (pipe-elt c 0) => 0\n"
"```"
msgstr ""

#: in/chapter9.md:941
msgid ""
"Accessing an element of the pipe forces evaluation of all the intervening "
"elements, and as before leaves subsequent elements unevaluated:"
msgstr ""
"Доступ к принудительному вычислению элемента pipe для всех промежуточных "
"элементов, и, как и прежде, оставляет без вычисления последующие элементы:"

#: in/chapter9.md:946
msgid ""
"```lisp\n"
"> (pipe-elt c 5) => 5\n"
"> c => (0 1 2 3 4 5 . #  <  CLOSURE 77351636  >)\n"
"```"
msgstr ""

#: in/chapter9.md:949
msgid ""
"Pipes can also be used for finite lists.\n"
"Here we see a pipe of length 11:"
msgstr ""
"Pipes также могут использоваться для конечных списков.\n"
"Здесь мы видим pipe длиной 11:"

#: in/chapter9.md:956
msgid ""
"```lisp\n"
"> (setf i (integers 0 10)) => (0 . #  <  CLOSURE 77375357  >)\n"
"> (pipe-elt i 10) => 10\n"
"> (pipe-elt i 11) => NIL\n"
"> i => (0 1 2 3 4 5 6 7 8 9 10)\n"
"```"
msgstr ""

#: in/chapter9.md:962
msgid ""
"Clearly, this version wastes less space and is much neater about cleaning up "
"after itself.\n"
"In fact, a completely evaluated pipe turns itself into a list!\n"
"This efficiency was gained at the sacrifice of a general principle of "
"program design.\n"
"Usually we strive to build more complicated abstractions, like pipes, out of "
"simpler ones, like delays.\n"
"But in this case, part of the functionality that delays were providing was "
"duplicated by the cons cells that make up pipes, so the more efficient "
"implementation of pipes does not use delays at all."
msgstr ""
"Понятно, что эта версия тратит меньше места и гораздо аккуратнее убирает "
"после себя.\n"
"Фактически, полностью вычисленный pipe превращается в список!\n"
"Эта эффективность была достигнута за счет общего принципа разработки "
"программ.\n"
"Обычно мы стремимся построить более сложные абстракции, например "
"каналы(pipes), из более простых, например задержек/отложенных "
"вычислений(delays).\n"
"Но в этом случае часть функциональных возможностей, которые обеспечивали "
"отложенные вычисления, была дублирована cons-ячейками, составляющими "
"каналы(pipes), поэтому более эффективная реализация каналов вообще не "
"использует задержки."

#: in/chapter9.md:964
msgid "Here are some more utility functions on pipes:"
msgstr "Вот еще несколько служебных функций для каналов(pipes):"

#: in/chapter9.md:968
msgid ""
"```lisp\n"
"(defun enumerate (pipe &key count key (result pipe))\n"
"```"
msgstr ""

#: in/chapter9.md:970
msgid "  `\"Go through all (or count) elements of pipe,`"
msgstr ""

#: in/chapter9.md:973
msgid ""
"  `possibly applying the KEY function.\n"
"(Try PRINT.)\"`"
msgstr ""

#: in/chapter9.md:975
msgid "  `;; Returns RESULT, which defaults to the pipe itself.`"
msgstr ""

#: in/chapter9.md:977
msgid "  `(if (or (eq pipe empty-pipe) (eql count 0))`"
msgstr ""

#: in/chapter9.md:979
msgid "              `result`"
msgstr ""

#: in/chapter9.md:981
msgid "              `(progn`"
msgstr ""

#: in/chapter9.md:983
msgid "              `(unless (null key) (funcall key (head pipe)))`"
msgstr ""

#: in/chapter9.md:985
msgid "              `(enumerate (tail pipe) :count (if count (- count 1))`"
msgstr ""

#: in/chapter9.md:987
msgid ""
"                                                `: key key : result "
"result))))`"
msgstr ""

#: in/chapter9.md:991
msgid ""
"```lisp\n"
"(defun filter (pred pipe)\n"
"```"
msgstr ""

#: in/chapter9.md:993
msgid "  `\"Keep only items in pipe satisfying pred.\"`"
msgstr ""

#: in/chapter9.md:995
msgid "  `(if (funcall pred (head pipe))`"
msgstr ""

#: in/chapter9.md:997
msgid "      `(make-pipe (head pipe)`"
msgstr ""

#: in/chapter9.md:999
msgid "                                          `(filter pred (tail pipe)))`"
msgstr ""

#: in/chapter9.md:1001
msgid "      `(filter pred (tail pipe))))`"
msgstr ""

#: in/chapter9.md:1003
msgid ""
"And here's an application of pipes: generating prime numbers using the sieve "
"of Eratosthenes algorithm:"
msgstr ""
"А вот и применение pipes: генерация простых чисел с использованием алгоритма "
"решета Эратосфена:"

#: in/chapter9.md:1007
msgid ""
"```lisp\n"
"(defun sieve (pipe)\n"
"```"
msgstr ""

#: in/chapter9.md:1009
msgid "  `(make-pipe (head pipe)`"
msgstr ""

#: in/chapter9.md:1011
msgid "              `(filter #'(lambda (x) (/= (mod x (head pipe)) 0))`"
msgstr ""

#: in/chapter9.md:1013
msgid "                                `(sieve (tail pipe)))))`"
msgstr ""

#: in/chapter9.md:1020
msgid ""
"```lisp\n"
"(defvar *primes* (sieve (integers 2)))\n"
"> *primes* => (2 . #  <  CLOSURE 3075345  >)\n"
"> (enumerate *primes* :count 10) =>\n"
"(2 3 5 7 11 13 17 19 23 29 31 . #  <  CLOSURE 5224472  >)\n"
"```"
msgstr ""

#: in/chapter9.md:1023
msgid ""
"Finally, let's return to the problem of generating all strings in a "
"grammar.\n"
"First we're going to need some more utility functions:"
msgstr ""
"Наконец, вернемся к проблеме генерации всех строк в грамматике.\n"
"Для начала нам понадобятся еще несколько служебных функций:"

#: in/chapter9.md:1027
msgid ""
"```lisp\n"
"(defun map-pipe (fn pipe)\n"
"```"
msgstr ""

#: in/chapter9.md:1029
msgid "  `\"Map fn over pipe, delaying all but the first fn call.\"`"
msgstr ""

#: in/chapter9.md:1031
msgctxt "in/chapter9.md:1031"
msgid "  `(if (eq pipe empty-pipe)`"
msgstr ""

#: in/chapter9.md:1033
msgid "            `empty-pipe`"
msgstr ""

#: in/chapter9.md:1035
msgid "            `(make-pipe (funcall fn (head pipe))`"
msgstr ""

#: in/chapter9.md:1037
msgid "                            `(map-pipe fn (tail pipe)))))`"
msgstr ""

#: in/chapter9.md:1041
msgid ""
"```lisp\n"
"(defun append-pipes (x y)\n"
"```"
msgstr ""

#: in/chapter9.md:1043
msgid "  `\"Return a pipe that appends the elements of x and y.\"`"
msgstr ""

#: in/chapter9.md:1045
msgid "  `(if (eq x empty-pipe)`"
msgstr ""

#: in/chapter9.md:1047
msgid "              `y`"
msgstr ""

#: in/chapter9.md:1049
msgid "              `(make-pipe (head x)`"
msgstr ""

#: in/chapter9.md:1051
msgid "                                    `(append-pipes (tail x) y))))`"
msgstr ""

#: in/chapter9.md:1055
msgid ""
"```lisp\n"
"(defun mappend-pipe (fn pipe)\n"
"```"
msgstr ""

#: in/chapter9.md:1057
msgid "  `\"Lazily map fn over pipe, appending results.\"`"
msgstr ""

#: in/chapter9.md:1059
msgctxt "in/chapter9.md:1059"
msgid "  `(if (eq pipe empty-pipe)`"
msgstr ""

#: in/chapter9.md:1061
msgid "                    `empty-pipe`"
msgstr ""

#: in/chapter9.md:1063
msgid "                    `(let ((x (funcall fn (head pipe))))`"
msgstr ""

#: in/chapter9.md:1065
msgid "                        `(make-pipe (head x)`"
msgstr ""

#: in/chapter9.md:1067
msgid "                                        `(append-pipes (tail x)`"
msgstr ""

#: in/chapter9.md:1069
msgid ""
"                                                                `(mappend-"
"pipe`"
msgstr ""

#: in/chapter9.md:1071
msgid ""
"                                                                                        `fn "
"(tail pipe)))))))`"
msgstr ""

#: in/chapter9.md:1073
msgid ""
"Now we can rewrite `generate-all` and `combine-all` to use pipes instead of "
"lists."
msgstr ""
"Теперь мы можем переписать `generate-all` и `combine-all`, чтобы "
"использовать каналы(pipes) вместо списков."

#: in/chapter9.md:1075
msgid ""
"Everything else is the same as on [Page 45](B9780080571157500029.xhtml#p45)."
msgstr ""
"Все остальное такое же, как на [Странице 45](B9780080571157500029.xhtml#p45)."

#: in/chapter9.md:1079
msgid ""
"```lisp\n"
"(defun generate-all (phrase)\n"
"```"
msgstr ""

#: in/chapter9.md:1081
msgid "  `\"Generate a random sentence or phrase\"`"
msgstr ""

#: in/chapter9.md:1083
msgid "  `(if (listp phrase)`"
msgstr ""

#: in/chapter9.md:1085
msgid "      `(if (null phrase)`"
msgstr ""

#: in/chapter9.md:1087
msgid "              `(list nil)`"
msgstr ""

#: in/chapter9.md:1089
msgid "              `(combine-all-pipes`"
msgstr ""

#: in/chapter9.md:1091
msgid "                    `(generate-all (first phrase))`"
msgstr ""

#: in/chapter9.md:1093
msgid "                    `(generate-all (rest phrase))))`"
msgstr ""

#: in/chapter9.md:1095
msgid "      `(let ((choices (rule-rhs (assoc phrase *grammar*))))`"
msgstr ""

#: in/chapter9.md:1097
msgid "        `(if choices`"
msgstr ""

#: in/chapter9.md:1099
msgid "                    `(mappend-pipe #'generate-all choices)`"
msgstr ""

#: in/chapter9.md:1101
msgid "                    `(list (list phrase))))))`"
msgstr ""

#: in/chapter9.md:1105
msgid ""
"```lisp\n"
"(defun combine-all-pipes (xpipe ypipe)\n"
"```"
msgstr ""

#: in/chapter9.md:1107
msgid "  `\"Return a pipe of pipes formed by appending a y to an x\"`"
msgstr ""

#: in/chapter9.md:1109
msgid "  `;; In other words, form the cartesian product.`"
msgstr ""

#: in/chapter9.md:1111
msgid "  `(mappend-pipe`"
msgstr ""

#: in/chapter9.md:1113
msgid "      `#'(lambda (y)`"
msgstr ""

#: in/chapter9.md:1115
msgid "                  `(map-pipe #'(lambda (x) (append-pipes x y))`"
msgstr ""

#: in/chapter9.md:1117
msgid "                                                    `xpipe))`"
msgstr ""

#: in/chapter9.md:1119
msgid "      `ypipe))`"
msgstr ""

#: in/chapter9.md:1121
msgid ""
"With these definitions, here's the pipe of all sentences from `*grammar2*` "
"(from [Page 43](B9780080571157500029.xhtml#p43)):"
msgstr ""
"С этими определениями, вот pipe всех предложений из `*grammar2*` (из "
"[Страница 43](B9780080571157500029.xhtml#p43)):"

#: in/chapter9.md:1142
msgid ""
"```lisp\n"
"> (setf ss (generate-all 'sentence)) =>\n"
"((THE . #  <  CLOSURE 27265720  >) . #  <  CLOSURE 27266035>)\n"
"> (enumerate ss :count 5) =>\n"
"((THE . #  <  CLOSURE 27265720  >)\n"
"(A . #  <  CLOSURE 27273143  >)\n"
"(THE . #  <  CLOSURE 27402545  >)\n"
"(A . #  <  CLOSURE 27404344  >)\n"
"(THE . #  <  CLOSURE 27404527  >)\n"
"(A . #  <  CLOSURE 27405473  >) . #  <  CLOSURE 27405600  >)\n"
"> (enumerate ss .-count 5 :key #'enumerate) =>\n"
"((THE MAN HIT THE MAN)\n"
"(A MAN HIT THE MAN)\n"
"(THE BIG MAN HIT THE MAN)\n"
"(A BIG MAN HIT THE MAN)\n"
"(THE LITTLE MAN HIT THE MAN)\n"
"(THE . #  <  CLOSURE 27423236  >) . #  <  CLOSURE 27423343  >)\n"
"> (enumerate (pipe-elt ss 200)) =>\n"
"(THE ADIABATIC GREEN BLUE MAN HIT THE MAN)\n"
"```"
msgstr ""

#: in/chapter9.md:1148
msgid ""
"While we were able to represent the infinite set of sentences and enumerate "
"instances of it, we still haven't solved all the problems.\n"
"For one, this enumeration will never get to a sentence that does not have "
"\"hit the man\" as the verb phrase.\n"
"We will see longer and longer lists of adjectives, but no other change.\n"
"Another problem is that left-recursive rules will still cause infinite "
"loops.\n"
"For example, if the expansion for `Adj*` had been `(Adj* -> (Adj* Adj) ())` "
"instead of `(Adj* -> () (Adj Adj*))`, then the enumeration would never "
"terminate, because pipes need to generate a first element."
msgstr ""
"Хотя мы смогли представить бесконечный набор предложений и перечислить их "
"экземпляры, мы все еще не решили все проблемы.\n"
"Во-первых, это перечисление никогда не дойдет до предложения, в котором нет "
"глагольной фразы \"hit the man\"(ударить человека).\n"
"Мы будем видеть все более длинные списки прилагательных, но никаких других "
"изменений.\n"
"Другая проблема заключается в том, что леворекурсивные правила по-прежнему "
"будут вызывать бесконечные циклы.\n"
"Например, если расширение для `Adj*` было `(Adj* -> (Adj* Adj) ())` вместо "
"`(Adj* -> () (Adj Adj*))`, то перечисление никогда не будет завершаться, "
"потому что pipes должны генерировать первый элемент."

#: in/chapter9.md:1153
msgid ""
"We have used delays and pipes for two main purposes: to put off until later "
"computations that may not be needed at all, and to have an explicit "
"representation of large or infinite sets.\n"
"It should be mentioned that the language Prolog has a different solution to "
"the first problem (but not the second).\n"
"As we shall see in [chapter 11](B978008057115750011X.xhtml), Prolog "
"generates solutions one at a time, automatically keeping track of possible "
"backtrack points.\n"
"Where pipes allow us to represent an infinite number of alternatives in the "
"data, Prolog allows us to represent those alternatives in the program itself."
msgstr ""
"Мы использовали задержки(delays) и каналы(pipes) для двух основных целей: "
"чтобы отложить на потом вычисления, которые могут вообще не понадобиться, и "
"для получения явного представления больших или бесконечных множеств.\n"
"Следует отметить, что язык Prolog имеет иное решение первой проблемы (но не "
"второй).\n"
"Как мы увидим в [главе 11](B978008057115750011X.xhtml), Prolog генерирует "
"решения по одному, автоматически отслеживая возможные точки возврата.\n"
"Там, где pipes позволяют нам представлять бесконечное количество альтернатив "
"в данных, Prolog позволяет нам представлять эти альтернативы в самой "
"программе."

#: in/chapter9.md:1158
msgid ""
"**Exercise  9.1 [h]** When given a function `f` and a pipe `p`, `mappend-"
"pipe` returns a new pipe that will eventually enumerate all of `(f (first "
"p))`, then all of `(f (second p))`, and so on.\n"
"This is deemed \"unfair\" if `(f (first p))` has an infinite number of "
"elements.\n"
"Define a function that will fairly interleave elements, so that all of them "
"are eventually enumerated.\n"
"Show that the function works by changing `generate-all` to work with it."
msgstr ""
"**Exercise  9.1 [h]** Когда дана функция `f` и канал `p`, `mappend-pipe` "
"возвращает новый канал, который в конечном итоге перечислит все `(f (first "
"p))`, затем все `(f (second p))` и так далее.\n"
"Это считается \"неправильным\", если `(f (first p))` имеет бесконечное "
"количество элементов.\n"
"Определите функцию, которая будет правильно чередовать элементы, чтобы все "
"они в конечном итоге были перечислены.\n"
"Покажите, что функция работает, изменив `generate-all` для работы с ней."

#: in/chapter9.md:1160
msgid "## 9.4 Indexing Data"
msgstr "## 9.4 Индексирование данных"

#: in/chapter9.md:1167
msgid ""
"Lisp makes it very easy to use lists as the universal data structure.\n"
"A list can represent a set or an ordered sequence, and a list with sublists "
"can represent a tree or graph.\n"
"For rapid prototyping, it is often easiest to represent data in lists, but "
"for efficiency this is not always the best idea.\n"
"To find an element in a list of length *n* will take *n*/2 steps on "
"average.\n"
"This is true for a simple list, an association list, or a property list.\n"
"If *n* can be large, it is worth looking at other data structures, such as "
"hash tables, vectors, property lists, and trees."
msgstr ""
"Lisp упрощает использование списков в качестве универсальной структуры "
"данных.\n"
"Список может представлять множество или упорядоченную последовательность, а "
"список с подсписками может представлять дерево или граф.\n"
"Для быстрого прототипирования зачастую проще всего представить данные в виде "
"списков, но для эффективности это не всегда лучшая идея.\n"
"Чтобы найти элемент в списке длиной *n*, потребуется в среднем *n*/2 шагов.\n"
"Это верно для простого списка, списка ассоциаций(alist) или списка "
"свойств(plist).\n"
"Если *n* может быть большим, стоит рассмотреть другие структуры данных, "
"такие как хеш-таблицы, векторы, списки свойств и деревья."

#: in/chapter9.md:1173
msgid ""
"Picking the right data structure and algorithm is as important in Lisp as it "
"is in any other programming language.\n"
"Even though Lisp offers a wide variety of data structures, it is often "
"worthwhile to spend some effort on building just the right data structure "
"for frequently used data.\n"
"For example, Lisp's hash tables are very general and thus can be "
"inefficient.\n"
"You may want to build your own hash tables if, for example, you never need "
"to delete elements, thus making open hashing an attractive possibility.\n"
"We will see an example of efficient indexing in [section 9.6](#s0035) ([Page "
"297](B9780080571157500091.xhtml#p297))."
msgstr ""
"Выбор правильной структуры данных и алгоритма так же важен в Лиспе, как и в "
"любом другом языке программирования.\n"
"Несмотря на то, что Lisp предлагает широкий спектр структур данных, часто "
"стоит потратить некоторые усилия на построение правильной структуры данных "
"для часто используемых данных.\n"
"Например, хеш-таблицы Lisp слишком обобщены и поэтому могут быть "
"неэффективными.\n"
"Вы можете создавать свои собственные хеш-таблицы, если, например, вам "
"никогда не нужно удалять элементы, что делает открытое хеширование "
"привлекательной возможностью.\n"
"Мы увидим пример эффективного индексирования в [раздел 9.6](#s0035)"
"([Страница 297] (B9780080571157500091.xhtml#p297))."

#: in/chapter9.md:1175
msgid "## 9.5 Instrumentation: Deciding What to Optimize"
msgstr "## 9.5 Инструментарий: Позволяющий решить, что оптимизировать"

#: in/chapter9.md:1179
msgid ""
"Because Lisp is such a good rapid-prototyping language, we can expect to get "
"a working implementation quickly.\n"
"Before we go about trying to improve the efficiency of the implementation, "
"it is a good idea to see what parts are used most often.\n"
"Improving little-used features is a waste of time."
msgstr ""
"Поскольку Lisp - очень хороший язык для быстрого создания прототипов, мы "
"можем рассчитывать быстро получить работающую реализацию.\n"
"Прежде чем мы приступим к попыткам повысить эффективность реализации, "
"неплохо посмотреть, какие части используются чаще всего.\n"
"Улучшение малоиспользуемых функций - пустая трата времени."

#: in/chapter9.md:1182
msgid ""
"The minimal support we need is to count the number of calls to selected "
"functions, and then print out the totals.\n"
"This is called *profiling* the functions.[3](#fn0020) For each function to "
"be profiled, we change the definition so that it increments a counter and "
"then calls the original function."
msgstr ""
"Минимальная поддержка, которая нам нужна, - это подсчет количества вызовов "
"выбранных функций, а затем распечатка итогов.\n"
"Это называется *профилированием* функций. [3](# fn0020) Для каждой функции, "
"подлежащей профилированию, мы меняем определение так, чтобы оно увеличивало "
"счетчик, а затем вызывала исходную функцию."

#: in/chapter9.md:1188
msgid ""
"Most Lisp systems have some built-in profiling mechanism.\n"
"If your system has one, by all means use it.\n"
"The code in this section is provided for those who lack such a feature, and "
"as an example of how functions can be manipulated.\n"
"The following is a simple profiling facility.\n"
"For each profiled function, it keeps a count of the number of times it is "
"called under the `profile-count` property of the function's name."
msgstr ""
"Большинство систем на Лиспе имеют встроенный механизм профилирования.\n"
"Если в вашей системе он есть, обязательно используйте его.\n"
"Код в этом разделе предназначен для тех, у кого нет такой возможности, и "
"является примером того, как можно управлять функциями.\n"
"Ниже приводится простое средство профилирования.\n"
"Для каждой профилируемой функции он ведет подсчет количества ее вызовов в "
"свойстве `profile-count` имени функции."

#: in/chapter9.md:1192
msgctxt "in/chapter9.md:1192"
msgid ""
"```lisp\n"
"(defun profile1 (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1194
msgctxt "in/chapter9.md:1194"
msgid "  `\"Make the function count how often it is called\"`"
msgstr ""

#: in/chapter9.md:1196
msgctxt "in/chapter9.md:1196"
msgid "  `;; First save away the old, unprofiled function`"
msgstr ""

#: in/chapter9.md:1198
msgctxt "in/chapter9.md:1198"
msgid "  `;; Then make the name be a new function that increments`"
msgstr ""

#: in/chapter9.md:1200
msgctxt "in/chapter9.md:1200"
msgid "  `;; a counter and then calls the original function`"
msgstr ""

#: in/chapter9.md:1202
msgid "    `(let ((fn (symbol-function fn-name)))`"
msgstr ""

#: in/chapter9.md:1204
msgid "          `(setf (get fn-name 'unprofiled-fn) fn)`"
msgstr ""

#: in/chapter9.md:1206
msgid "      `(setf (get fn-name 'profile-count) 0)`"
msgstr ""

#: in/chapter9.md:1208
msgctxt "in/chapter9.md:1208"
msgid "      `(setf (symbol-function fn-name)`"
msgstr ""

#: in/chapter9.md:1210
msgid "                `(profiled-fn fn-name fn))`"
msgstr ""

#: in/chapter9.md:1212
msgid "      `fn-name))`"
msgstr ""

#: in/chapter9.md:1216
msgctxt "in/chapter9.md:1216"
msgid ""
"```lisp\n"
"(defun unprofile1 (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1218
msgctxt "in/chapter9.md:1218"
msgid "  `\"Make the function stop counting how often it is called.\"`"
msgstr ""

#: in/chapter9.md:1220
msgid "  `(setf (symbol-function fn-name) (get fn-name 'unprofiled-fn))`"
msgstr ""

#: in/chapter9.md:1222
msgctxt "in/chapter9.md:1222"
msgid "  `fn-name)`"
msgstr ""

#: in/chapter9.md:1226
msgid ""
"```lisp\n"
"(defun profiled-fn (fn-name fn)\n"
"```"
msgstr ""

#: in/chapter9.md:1228
msgid "  `\"Return a function that increments the count.\"`"
msgstr ""

#: in/chapter9.md:1230
msgctxt "in/chapter9.md:1230"
msgid "  `#'(lambda (&rest args)`"
msgstr ""

#: in/chapter9.md:1232
msgid "      `(incf (get fn-name 'profile-count))`"
msgstr ""

#: in/chapter9.md:1234
msgid "      `(apply fn args)))`"
msgstr ""

#: in/chapter9.md:1238
msgid ""
"```lisp\n"
"(defun profile-count (fn-name) (get fn-name 'profile-count))\n"
"```"
msgstr ""

#: in/chapter9.md:1240
msgid "  `(defun profile-report (fn-names &optional (key #'profile-count))`"
msgstr ""

#: in/chapter9.md:1242
msgid "  `\"Report profiling statistics on given functions.\"`"
msgstr ""

#: in/chapter9.md:1244
msgid "              `(loop for name in (sort fn-names #'> :key key) do`"
msgstr ""

#: in/chapter9.md:1248
msgid ""
"```lisp\n"
"                    (format t \"~&  ~  7D  ~  A\" (profile-count name) "
"name)))\n"
"```"
msgstr ""

#: in/chapter9.md:1253
msgid ""
"That's all we need for the bare-bones functionality.\n"
"However, there are a few ways we could improve this.\n"
"First, it would be nice to have macros that, like `trace` and `untrace`, "
"allow the user to profile multiple functions at once and keep track of what "
"has been profiled.\n"
"Second, it can be helpful to see the length of time spent in each function, "
"as well as the number of calls."
msgstr ""
"Это все, что нам нужно для базовой функциональности.\n"
"Однако есть несколько способов улучшить это.\n"
"Во-первых, было бы неплохо иметь макросы, такие как `trace` и `untrace`, "
"которые позволяют пользователю одновременно профилировать несколько функций "
"и отслеживать то, что было профилировано.\n"
"Во-вторых, может быть полезно видеть время, затраченное на каждую функцию, а "
"также количество вызовов."

#: in/chapter9.md:1256
msgid ""
"Also, it is important to avoid profiling a function twice, since that would "
"double the number of calls reported without alerting the user of any "
"trouble.\n"
"Suppose we entered the following sequence of commands:"
msgstr ""
"Кроме того, важно избегать двойного профилирования функции, поскольку это "
"удвоит количество зарегистрированных вызовов, не предупреждая пользователя о "
"каких-либо проблемах.\n"
"Допустим, мы ввели следующую последовательность команд:"

#: in/chapter9.md:1262
msgid ""
"```lisp\n"
"(defun f (x) (g x))\n"
"(profile1 'f)\n"
"(profile1 'f)\n"
"```"
msgstr ""

#: in/chapter9.md:1264
msgid "Then the definition of `f` would be roughly:"
msgstr "Тогда определение `f` будет примерно таким:"

#: in/chapter9.md:1268
msgid ""
"```lisp\n"
"(lambda (&rest args)\n"
"```"
msgstr ""

#: in/chapter9.md:1270
msgid "      `(incf (get 'f 'profile-count))`"
msgstr ""

#: in/chapter9.md:1272
msgid "      `(apply #'(lambda (&rest args)`"
msgstr ""

#: in/chapter9.md:1274
msgid "            `(incf (get 'f 'profile-count))`"
msgstr ""

#: in/chapter9.md:1276
msgid "            `(apply #'(lambda (x) (g x))`"
msgstr ""

#: in/chapter9.md:1278
msgid "                        `args))`"
msgstr ""

#: in/chapter9.md:1280
msgid "                `args))`"
msgstr ""

#: in/chapter9.md:1282
msgid ""
"The result is that any call to `f` will eventually call the original `f`, "
"but only after incrementing the count twice."
msgstr ""
"В результате любой вызов `f` в конечном итоге вызовет исходный `f`, но "
"только после двукратного увеличения счетчика."

#: in/chapter9.md:1289
msgid ""
"Another consideration is what happens when a profiled function is redefined "
"by the user.\n"
"The only way we could ensure that a redefined function would continue "
"profiling would be to change the definition of the macro defun to look for "
"functions that should be profiled.\n"
"Changing system functions like defun is a risky prospect, and in *Common "
"Lisp the Language*, 2d edition, it is explicitly disallowed.\n"
"Instead, we'll do the next best thing: ensure that the next call to "
"`profile` will reprofile any functions that have been redefined.\n"
"We do this by keeping track of both the original unprofiled function and the "
"profiled function.\n"
"We also keep a list of all functions that are currently profiled."
msgstr ""
"Еще одно соображение: что происходит, когда профилируемая функция "
"переопределяется пользователем.\n"
"Единственный способ гарантировать, что переопределенная функция продолжит "
"профилирование, - это изменить определение макроса defun для поиска функций, "
"которые следует профилировать.\n"
"Изменение системных функций, таких как defun, - рискованная перспектива, и в "
"*Common Lisp the Language*, 2-е издание, это явно запрещено.\n"
"Вместо этого мы сделаем следующее: убедимся, что следующий вызов `profile` "
"повторно профилирует любые функции, которые были переопределены.\n"
"Мы делаем это, отслеживая как исходную непрофилированную функцию, так и "
"профилированную функцию.\n"
"Мы также храним список всех профилируемых функций."

#: in/chapter9.md:1296
msgid ""
"In addition, we will count the amount of time spent in each function.\n"
"However, the user is cautioned not to trust the timing figures too much.\n"
"First, they include the overhead cost of the profiling facility.\n"
"This can be significant, particularly because the facility conses, and thus "
"can force garbage collections that would not otherwise have been done.\n"
"Second, the resolution of the system clock may not be fine enough to make "
"accurate timings.\n"
"For functions that take about 1/10 of a second or more, the figures will be "
"reliable, but for quick functions they may not be."
msgstr ""
"Кроме того, мы посчитаем время, потраченное на каждую функцию.\n"
"Однако пользователя предупреждают, что нельзя слишком доверять цифрам "
"времени.\n"
"Во-первых, они включают накладные расходы на средство профилирования.\n"
"Это может быть значительным, особенно потому, что средство "
"conses(конструирует списки) и, таким образом, может вызвать сборку мусора, "
"которая в противном случае не была бы выполнена.\n"
"Во-вторых, разрешения системных часов может быть недостаточно для точного "
"отсчета времени.\n"
"Для функций, которые занимают около 1/10 секунды или более, цифры будут "
"надежными, но для быстрых функций это не так."

#: in/chapter9.md:1298
msgid "Here is the basic code for `profile` and `unprofile:`"
msgstr "Вот основной код для `profile` и `unprofile:`"

#: in/chapter9.md:1302
msgid ""
"```lisp\n"
"(defvar *profiled-functions* nil\n"
"```"
msgstr ""

#: in/chapter9.md:1304
msgid "  `\"Function names that are currently profiled\")`"
msgstr ""

#: in/chapter9.md:1308
msgid ""
"```lisp\n"
"(defmacro profile (&rest fn-names)\n"
"```"
msgstr ""

#: in/chapter9.md:1311
msgid ""
"  `\"Profile fn-names.\n"
"With no args, list profiled functions.\"`"
msgstr ""

#: in/chapter9.md:1313
msgid "  `'(mapcar #'profile1`"
msgstr ""

#: in/chapter9.md:1315
msgid "              `(setf *profiled-functions*`"
msgstr ""

#: in/chapter9.md:1317
msgid "            `(union *profiled-functions* fn-names))))`"
msgstr ""

#: in/chapter9.md:1321
msgid ""
"```lisp\n"
"(defmacro unprofile (&rest fn-names)\n"
"```"
msgstr ""

#: in/chapter9.md:1324
msgid ""
"  `\"Stop profiling fn-names.\n"
"With no args, stop all profiling.\"`"
msgstr ""

#: in/chapter9.md:1326
msgid "  `'(progn`"
msgstr ""

#: in/chapter9.md:1328
msgid "      `(mapcar #'unprofile1`"
msgstr ""

#: in/chapter9.md:1330
msgid "                  `,(if fn-names fn-names '*profiled-functions*))`"
msgstr ""

#: in/chapter9.md:1332
msgid "      `(setf *profiled-functions*`"
msgstr ""

#: in/chapter9.md:1334
msgid "                  `,(if (null fn-names)`"
msgstr ""

#: in/chapter9.md:1336
msgid "            `nil`"
msgstr ""

#: in/chapter9.md:1338
msgid "                  `'(set-difference *profiled-functions*`"
msgstr ""

#: in/chapter9.md:1340
msgid "                        `',fn-names)))))`"
msgstr ""

#: in/chapter9.md:1346
msgid ""
"The idiom ' ',`fn-names` deserves comment, since it is common but can be "
"confusing at first.\n"
"It may be easier to understand when written in the equivalent form "
"'`(quote , fn-names)`.\n"
"As always, the backquote builds a structure with both constant and evaluated "
"components.\n"
"In this case, the `quote` is constant and the variable `fn-names` is "
"evaluated.\n"
"In MacLisp, the function `kwote` was defined to serve this purpose:"
msgstr ""
"Идиома ' ',`fn-names` заслуживает комментария, так как она обычна, но "
"поначалу может сбивать с толку.\n"
"Её может быть легче понять, если написать в эквивалентной форме '`(quote ,fn-"
"names)`.\n"
"Как всегда, обратная кавычка создает структуру как с постоянными, так и с "
"вычисляемыми компонентами.\n"
"В этом случае `quote` постоянна, а переменная `fn-names` вычисляется.\n"
"В MacLisp для этой цели была определена функция `kwote`:"

#: in/chapter9.md:1350
msgid ""
"```lisp\n"
"(defun kwote (x) (list 'quote x))\n"
"```"
msgstr ""

#: in/chapter9.md:1354
msgid ""
"Now we need to change `profile1` and `unprofile1` to do the additional "
"bookkeeping: For `profile1`, there are two cases.\n"
"If the user does a `profile1` on the same function name twice in a row, then "
"on the second time we will notice that the current function is the same as "
"the functioned stored under the `profiled-fn` property, so nothing more "
"needs to be done.\n"
"Otherwise, we create the profiled function, store it as the current "
"definition of the name under the `profiled-fn` property, save the unprofiled "
"function, and initialize the counts."
msgstr ""
"Теперь нам нужно изменить `profile1` и `unprofile1`, чтобы выполнить "
"дополнительный учет: Для `profile1` есть два случая.\n"
"Если пользователь дважды подряд выполняет `profile1` для одного и того же "
"имени функции, то во второй раз мы заметим, что текущая функция совпадает с "
"функцией, хранящейся в свойстве `profiled-fn`, поэтому больше ничего не "
"нужно должно быть сделано.\n"
"В противном случае мы создаем профилированную функцию, сохраняем ее как "
"текущее определение имени в свойстве `profiled-fn`, сохраняем "
"непрофилированную функцию и инициализируем счетчики."

#: in/chapter9.md:1358
msgctxt "in/chapter9.md:1358"
msgid ""
"```lisp\n"
"(defun profile1 (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1360
msgctxt "in/chapter9.md:1360"
msgid "  `\"Make the function count how often it is called\"`"
msgstr ""

#: in/chapter9.md:1362
msgctxt "in/chapter9.md:1362"
msgid "  `;; First save away the old, unprofiled function`"
msgstr ""

#: in/chapter9.md:1364
msgctxt "in/chapter9.md:1364"
msgid "  `;; Then make the name be a new function that increments`"
msgstr ""

#: in/chapter9.md:1366
msgctxt "in/chapter9.md:1366"
msgid "  `;; a counter and then calls the original function`"
msgstr ""

#: in/chapter9.md:1368
msgid "  `(let ((fn (symbol-function fn-name)))`"
msgstr ""

#: in/chapter9.md:1370
msgid "      `(unless (eq fn (get fn-name 'profiled-fn))`"
msgstr ""

#: in/chapter9.md:1372
msgid "              `(let ((new-fn (profiled-fn fn-name fn)))`"
msgstr ""

#: in/chapter9.md:1374
msgid "                  `(setf (symbol-function fn-name) new-fn`"
msgstr ""

#: in/chapter9.md:1376
msgid "                              `(get fn-name 'profiled-fn) new-fn`"
msgstr ""

#: in/chapter9.md:1378
msgid "                              `(get fn-name 'unprofiled-fn) fn`"
msgstr ""

#: in/chapter9.md:1380
msgid "                              `(get fn-name 'profile-time) 0`"
msgstr ""

#: in/chapter9.md:1382
msgid "                              `(get fn-name 'profile-count) 0))))`"
msgstr ""

#: in/chapter9.md:1384
msgid "        `fn-name)`"
msgstr ""

#: in/chapter9.md:1388
msgctxt "in/chapter9.md:1388"
msgid ""
"```lisp\n"
"(defun unprofile1 (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1390
msgctxt "in/chapter9.md:1390"
msgid "  `\"Make the function stop counting how often it is called.\"`"
msgstr ""

#: in/chapter9.md:1392
msgid "  `(setf (get fn-name 'profile-time) 0)`"
msgstr ""

#: in/chapter9.md:1394
msgid "  `(setf (get fn-name 'profile-count) 0)`"
msgstr ""

#: in/chapter9.md:1396
msgid "  `(when (eq (symbol-function fn-name) (get fn-name 'profiled-fn))`"
msgstr ""

#: in/chapter9.md:1398
msgid "      `;; normal case: restore unprofiled version`"
msgstr ""

#: in/chapter9.md:1400
msgctxt "in/chapter9.md:1400"
msgid "      `(setf (symbol-function fn-name)`"
msgstr ""

#: in/chapter9.md:1402
msgid "                `(get fn-name 'unprofiled-fn)))`"
msgstr ""

#: in/chapter9.md:1404
msgctxt "in/chapter9.md:1404"
msgid "  `fn-name)`"
msgstr ""

#: in/chapter9.md:1410
msgid ""
"Now we look into the question of timing.\n"
"There is a built-in Common Lisp function, `get-internal-real-time`, that "
"returns the elapsed time since the Lisp session started.\n"
"Because this can quickly become a bignum, some implementations provide "
"another timing function that wraps around rather than increasing forever, "
"but which may have a higher resolution than `get-internal-real-time`.\n"
"For example, on TI Explorer Lisp Machines, `get-internal-real-time` measures "
"1/60-second intervals, while `time:microsecond-time` measures 1/1,000,000-"
"second intervals, but the value returned wraps around to zero every hour or "
"so.\n"
"The function `time:microsecond-time-difference` is used to compare two of "
"these numbers with compensation for wraparound, as long as no more than one "
"wraparound has occurred."
msgstr ""
"Теперь рассмотрим вопрос о времени.\n"
"Существует встроенная функция Common Lisp, `get-internal-real-time`, которая "
"возвращает время, прошедшее с начала сеанса Lisp.\n"
"Поскольку оно может быстро стать большим числом, некоторые реализации "
"предоставляют другую функцию подсчета времени, которая идет по кругу, а не "
"увеличивается постоянно, но которая может иметь более высокое разрешение, "
"чем `get-internal-real-time`.\n"
"Например, на машинах TI Explorer Lisp, `get-internal-real-time` измеряет "
"интервалы в 1/60 секунды, а `time:microsecond-time` измеряет интервалы в "
"1/1000000 секунд, но возвращаемое значение возвращается к нулю. каждый час "
"или около того.\n"
"Функция `time:microsecond-time-difference` используется для сравнения двух "
"из этих чисел с компенсацией зацикливания, если произошло не более одного "
"зацикливания."

#: in/chapter9.md:1417
msgid ""
"In the code below, I use the conditional read macro characters `#+`and `#-` "
"to define the right behavior on both Explorer and non-Explorer machines.\n"
"We have seeen that `#` is a special character to the reader that takes "
"different action depending on the following character.\n"
"For example, `#'fn` is read as `(function fn)`.\n"
"The character sequence `#+`is defined so that `#+`*feature expression* reads "
"as *expression* if the *feature* is defined in the current implementation, "
"and as nothing at all if it is not.\n"
"The sequence `#-` acts in just the opposite way.\n"
"For example, on a TI Explorer, we would get the following:"
msgstr ""
"В приведенном ниже коде я использую условные символы макроса чтения `#+` и "
"`#-`, чтобы определить правильное поведение как на машинах Explorer, так и "
"на других машинах.\n"
"Мы видели, что `#` - это специальный символьный знак для reader, который "
"выполняет разные действия в зависимости от последующего символьного знака.\n"
"Например, `#'fn` читается как `(function fn)`.\n"
"Последовательность знаков `#+` определена так, что `#+`*feature expression* "
"читается как *expression*, если *feature*(функциональность) определена в "
"текущей реализации, и как ничто, если это не так.\n"
"Последовательность `#-` действует прямо противоположно.\n"
"Например, в TI Explorer мы получим следующее:"

#: in/chapter9.md:1421
msgid ""
"```lisp\n"
">'(hi #+TI t #+Symbolics s #-Explorer e #-Mac m) => (HI T M)\n"
"```"
msgstr ""

#: in/chapter9.md:1423
msgid ""
"The conditional read macro characters are used in the following definitions:"
msgstr "Условные знаки макроса чтения используются в следующих определениях:"

#: in/chapter9.md:1427
msgid ""
"```lisp\n"
"(defun get-fast-time ()\n"
"```"
msgstr ""

#: in/chapter9.md:1430
msgid ""
"  `\"Return the elapsed time.\n"
"This may wrap around;`"
msgstr ""

#: in/chapter9.md:1432
msgid "  `use FAST-TIME-DIFFERENCE to compare.\"`"
msgstr ""

#: in/chapter9.md:1434
msgid "  `#+Explorer (time:microsecond-time) ; do this on an Explorer`"
msgstr ""

#: in/chapter9.md:1436
msgid "  `#-Explorer (get-internal-real-time)) ; do this on a non-Explorer`"
msgstr ""

#: in/chapter9.md:1440
msgid ""
"```lisp\n"
"(defun fast-time-difference (end start)\n"
"```"
msgstr ""

#: in/chapter9.md:1442
msgid "  `\"Subtract two time points.\"`"
msgstr ""

#: in/chapter9.md:1444
msgid "  `#+Explorer (time:microsecond-time-difference end start)`"
msgstr ""

#: in/chapter9.md:1446
msgid "  `#-Explorer (- end start))`"
msgstr ""

#: in/chapter9.md:1450
msgid ""
"```lisp\n"
"(defun fast-time->seconds (time)\n"
"```"
msgstr ""

#: in/chapter9.md:1452
msgid "  `\"Convert a fast-time interval into seconds.\"`"
msgstr ""

#: in/chapter9.md:1454
msgid "  `#+Explorer (/ time 1000000.0)`"
msgstr ""

#: in/chapter9.md:1456
msgid "  `#-Explorer (/ time internal-time-units-per-second))`"
msgstr ""

#: in/chapter9.md:1462
msgid ""
"The next step is to update `profiled-fn` to keep track of the timing data.\n"
"The simplest way to do this would be to set a variable, say `start`, to the "
"time when a function is entered, run the function, and then increment the "
"function's time by the difference between the current time and `start`.\n"
"The problem with this approach is that every function in the call stack gets "
"credit for the time of each called function.\n"
"Suppose the function f calls itself recursively five times, with each call "
"and return taking place a second apart, so that the whole computation takes "
"nine seconds.\n"
"Then f will be charged nine seconds for the outer call, seven seconds for "
"the next call, and so on, for a total of 25 seconds, even though in reality "
"it only took nine seconds for all of them together."
msgstr ""
"Следующим шагом является обновление `profiled-fn` для отслеживания данных о "
"времени.\n"
"Самый простой способ сделать это - установить для переменной, скажем, "
"`start`, время, когда происходит вход в функцию, запустить функцию и затем "
"увеличить время выполнения функции на разницу между текущим временем и "
"`start`.\n"
"Проблема с этим подходом состоит в том, что каждая функция в стеке вызовов "
"получает значение для времени каждой вызываемой функции.\n"
"Предположим, что функция `f` рекурсивно вызывает себя пять раз, причем "
"каждый вызов и возврат происходят с интервалом в секунду, так что все "
"вычисления занимают девять секунд.\n"
"Тогда с `f` будет начислено девять секунд за внешний вызов, семь секунд за "
"следующий и так далее, всего 25 секунд, хотя на самом деле на все они вместе "
"потребовалось всего девять секунд."

#: in/chapter9.md:1467
msgid ""
"A better algorithm would be to charge each function only for the time since "
"the last call or return.\n"
"Then `f` would only be charged the nine seconds.\n"
"The variable `*profile-call-stack*` is used to hold a stack of function name/"
"entry time pairs.\n"
"This stack is manipulated by `profile-enter` and `profile-exit` to get the "
"right timings."
msgstr ""
"Лучшим алгоритмом было бы заряжать каждую функцию только на время, прошедшее "
"с момента последнего вызова или возврата.\n"
"Тогда `f` будет заряжаться только девять секунд.\n"
"Переменная `*profile-call-stack*` используется для хранения стека пар: имя "
"функции/время входа.\n"
"Этот стек управляется `profile-enter` и `profile-exit`, чтобы получить "
"правильные тайминги."

#: in/chapter9.md:1475
msgid ""
"The functions that are used on each call to a profiled function are declared "
"`inline`.\n"
"In most cases, a call to a function compiles into machine instructions that "
"set up the argument list and branch to the location of the function's "
"definition.\n"
"With an `inline` function, the body of the function is compiled in line at "
"the place of the function call.\n"
"Thus, there is no overhead for setting up the argument list and branching to "
"the definition.\n"
"An `inline` declaration can appear anywhere any other declaration can "
"appear.\n"
"In this case, the function `proclaim` is used to register a global "
"declaration.\n"
"Inline declarations are discussed in more depth on [Page 317]"
"(B9780080571157500108.xhtml#p317)."
msgstr ""
"Функции, которые используются при каждом вызове профилируемой функции, "
"объявляются `inline`.\n"
"В большинстве случаев \n"
"вызов функции компилируется в машинные инструкции, которые устанавливают "
"список аргументов и переходят к местоположению определения функции.\n"
"При использовании встроенной функции тело функции компилируется в строке в "
"месте вызова функции.\n"
"Таким образом, нет дополнительных затрат на настройку списка аргументов и "
"переход к определению.\n"
"Объявление `inline` может появляться везде, где может появиться любое другое "
"объявление.\n"
"В этом случае функция `proclaim` используется для регистрации глобального "
"объявления.\n"
"Inline объявления более подробно обсуждаются на [Страница 317]"
"(B9780080571157500108.xhtml#p317)."

#: in/chapter9.md:1480
msgid ""
"```lisp\n"
"(proclaim '(inline profile-enter profile-exit inc-profile-time))\n"
"(defun profiled-fn (fn-name fn)\n"
"```"
msgstr ""

#: in/chapter9.md:1482
msgid "  `\"Return a function that increments the count, and times.\"`"
msgstr ""

#: in/chapter9.md:1484
msgctxt "in/chapter9.md:1484"
msgid "  `#'(lambda (&rest args)`"
msgstr ""

#: in/chapter9.md:1486
msgid "          `(profile-enter fn-name)`"
msgstr ""

#: in/chapter9.md:1488
msgid "          `(multiple-value-progl`"
msgstr ""

#: in/chapter9.md:1490
msgid "                `(apply fn args)`"
msgstr ""

#: in/chapter9.md:1492
msgid "                `(profile-exit fn-name))))`"
msgstr ""

#: in/chapter9.md:1497
msgid ""
"```lisp\n"
"(defvar *profile-call-stack* nil)\n"
"(defun profile-enter (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1499
msgid "  `(incf (get fn-name 'profile-count))`"
msgstr ""

#: in/chapter9.md:1501
msgctxt "in/chapter9.md:1501"
msgid "  `(unless (null *profile-call-stack*)`"
msgstr ""

#: in/chapter9.md:1503
msgid "      `;; Time charged against the calling function:`"
msgstr ""

#: in/chapter9.md:1505
msgid "      `(inc-profile-time (first *profile-call-stack*)`"
msgstr ""

#: in/chapter9.md:1507
msgid "                              `(car (first *profile-call-stack*))))`"
msgstr ""

#: in/chapter9.md:1509
msgid "  `;; Put a new entry on the stack`"
msgstr ""

#: in/chapter9.md:1511
msgid "  `(push (cons fn-name (get-fast-time))`"
msgstr ""

#: in/chapter9.md:1513
msgid "              `*profile-call-stack*))`"
msgstr ""

#: in/chapter9.md:1517
msgid ""
"```lisp\n"
"(defun profile-exit (fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1519
msgid "  `;; Time charged against the current function:`"
msgstr ""

#: in/chapter9.md:1521
msgid "  `(inc-profile-time (pop *profile-call-stack*)`"
msgstr ""

#: in/chapter9.md:1523
msgid "                                          `fn-name)`"
msgstr ""

#: in/chapter9.md:1525
msgid "  `;; Change the top entry to reflect current time`"
msgstr ""

#: in/chapter9.md:1527
msgctxt "in/chapter9.md:1527"
msgid "  `(unless (null *profile-call-stack*)`"
msgstr ""

#: in/chapter9.md:1529
msgid "      `(setf (cdr (first *profile-call-stack*))`"
msgstr ""

#: in/chapter9.md:1531
msgid "              `(get-fast-time))))`"
msgstr ""

#: in/chapter9.md:1535
msgid ""
"```lisp\n"
"(defun inc-profile-time (entry fn-name)\n"
"```"
msgstr ""

#: in/chapter9.md:1537
msgid "  `(incf (get fn-name 'profile-time)`"
msgstr ""

#: in/chapter9.md:1539
msgid ""
"                        `(fast-time-difference (get-fast-time) (cdr "
"entry))))`"
msgstr ""

#: in/chapter9.md:1544
msgid ""
"Finally, we need to update `profile-report` to print the timing data as well "
"as the counts.\n"
"Note that the default `fn-names` is a copy of the global list.\n"
"That is because we pass `fn-names` to `sort`, which is a destructive "
"function.\n"
"We don't want the global list to be modified as a result of this sort."
msgstr ""
"Наконец, нам нужно обновить `profile-report`, чтобы печатать временные "
"данные, а также счетчики.\n"
"Обратите внимание, что по умолчанию `fn-names` является копией глобального "
"списка.\n"
"Это потому, что мы передаем `fn-names` в `sort`, которая является "
"разрушающей функцией.\n"
"Мы не хотим, чтобы глобальный список изменялся в результате этой сортировки."

#: in/chapter9.md:1564
msgid ""
"```lisp\n"
"(defun profile-report (&optional\n"
"                                            (fn-names (copy-list *profiled-"
"functions*))\n"
"                                            (key #'profile-count))\n"
"    \"Report profiling statistics on given functions.\"\n"
"    (let ((total-time (reduce #'  +  (mapcar #'profile-time fn-names))))\n"
"        (unless (null key)\n"
"            (setf fn-names (sort fn-names #'> :key key)))\n"
"        (format t \"~&Total elapsed time: ~d seconds.\"\n"
"                        (fast-time-> seconds total-time))\n"
"        (format t Count Secs Time% Name\")\n"
"        (loop for name in fn-names do\n"
"                  (format t \"~&~7D ~6,2F ~3d% ~A\"\n"
"                                (profile-count name)\n"
"                                (fast-time-> seconds (profile-time name))\n"
"                                (round (/ (profile-time name) total-"
"time) .01)\n"
"                                name))))\n"
"(defun profile-time (fn-name) (get fn-name 'profile-time))\n"
"```"
msgstr ""

#: in/chapter9.md:1567
msgid ""
"These functions can be used by calling `profile`, then doing some "
"representative computation, then calling `profile-report`, and finally "
"`unprofile`.\n"
"It can be convenient to provide a single macro for doing all of these at "
"once:"
msgstr ""
"Эти функции можно использовать, вызвав `profile`, затем выполнив некоторые "
"типичные вычисления, затем вызвав `profile-report` и, наконец, `unprofile`.\n"
"Может быть удобно предоставить один макрос для выполнения всех этих действий "
"одновременно:"

#: in/chapter9.md:1579
msgid ""
"```lisp\n"
"(defmacro with-profiling (fn-names &rest body)\n"
"  '(progn\n"
"        (unprofile . ,fn-names)\n"
"        (profile . ,fn-names)\n"
"        (setf *profile-call-stack* nil)\n"
"        (unwind-protect\n"
"                (progn . ,body)\n"
"            (profile-report ',fn-names)\n"
"            (unprofile . ,fn-names))))\n"
"```"
msgstr ""

#: in/chapter9.md:1584
msgid ""
"Note the use of `unwind-protect` to produce the report and call `unprofile` "
"even if the computation is aborted.\n"
"`unwind-protect` is a special form that takes any number of arguments.\n"
"It evaluates the first argument, and if all goes well it then evaluates the "
"other arguments and returns the first one, just like `progl`.\n"
"But if an error occurs during the evaluation of the first argument and "
"computation is aborted, then the subsequent arguments (called cleanup forms) "
"are evaluated anyway."
msgstr ""
"Обратите внимание на использование функции `unwind-protect` для создания "
"отчета и вызова `unprofile`, даже если вычисление было прервано.\n"
"`unwind-protect` - это особая форма, которая принимает любое количество "
"аргументов.\n"
"Она  вычисляет первый аргумент и, если все идет хорошо, вычисляет остальные "
"аргументы и возвращает результат первого, как и `progl`.\n"
"Но если во время вычисления первого аргумента возникает ошибка и вычисление "
"прерывается, то последующие аргументы (называемые формами очистки) все равно "
"вычисляются."

#: in/chapter9.md:1586
msgid "## 9.6 A Case Study in Efficiency: The SIMPLIFY Program"
msgstr "## 9.6 Пример исследования эффективности: программа SIMPLIFY"

#: in/chapter9.md:1590
msgid ""
"Suppose we wanted to speed up the `simplify` program of [chapter 8]"
"(B978008057115750008X.xhtml).\n"
"This section shows how a combination of general techniques-memoizing, "
"indexing, and compiling-can be used to speed up the program by a factor of "
"130.\n"
"[Chapter 15](B9780080571157500157.xhtml) will show another approach: replace "
"the algorithm with an entirely different one."
msgstr ""
"Предположим, мы хотим ускорить выполнение программы `simplify` из [главы 8]"
"(B978008057115750008X.xhtml).\n"
"В этом разделе показано, как сочетание общих методов - "
"запоминания(memoizing), индексации и компиляции - может использоваться для "
"ускорения программы в 130 раз.\n"
"[Глава 15](B9780080571157500157.xhtml) покажет другой подход: заменить "
"алгоритм совершенно другим."

#: in/chapter9.md:1593
msgid ""
"The first step to a faster program is defining a *benchmark*, a test suite "
"representing a typical work load.\n"
"The following is a short list of test problems (and their answers) that are "
"typical of the `simplify` task."
msgstr ""
"Первым шагом к более быстрой программе является определение *эталонного "
"теста*(benchmark), набора тестов, представляющего типичную рабочую "
"нагрузку.\n"
"Ниже приводится краткий список тестовых задач (и их ответов), которые "
"типичны для задачи `simplify`."

#: in/chapter9.md:1603
msgid ""
"```lisp\n"
"(defvar *test-data* (mapcar #'infix-> prefix\n"
"  '((d (a * x ^ 2  +  b * x  +  c) / d x)\n"
"      (d ((a * x ^ 2  +  b * x  +  c) / x) / d x)\n"
"      (d((a*x ^ 3  +  b * x ^ 2  +  c * x  +  d)/x ^ 5)/dx)\n"
"      ((sin (x  +  x)) * (sin (2 * x))  +  (cos (d (x ^ 2) / d x)) ^ 1)\n"
"      (d (3 * x  +  (cos x) / x) / d x))))\n"
"(defvar *answers* (mapcar #'simplify *test-data*))\n"
"```"
msgstr ""

#: in/chapter9.md:1605
msgid ""
"The function `test-it` runs through the test data, making sure that each "
"answer is correct and optionally printing profiling data."
msgstr ""
"Функция `test-it` просматривает тестовые данные, проверяя правильность "
"каждого ответа и при необходимости распечатывая данные профилирования."

#: in/chapter9.md:1609
msgid ""
"```lisp\n"
"(defun test-it (&optional (with-profiling t))\n"
"```"
msgstr ""

#: in/chapter9.md:1612
msgid ""
"`    \"Time a test run.\n"
"and make sure the answers are correct.\"`"
msgstr ""

#: in/chapter9.md:1627
msgid ""
"```lisp\n"
"    (let ((answers\n"
"                  (if with-profiling\n"
"                          (with-profiling (simplify simplify-exp pat-match\n"
"                                                            match-variable "
"variable-p)\n"
"                              (mapcar #'simplify *test-data*))\n"
"                          (time (mapcar #'simplify *test-data*)))))\n"
"        (mapc #'assert-equal answers *answers*)\n"
"        t))\n"
"(defun assert-equal (x y)\n"
"    \"If x is not equal to y, complain.\"\n"
"    (assert (equal x y) (x y)\n"
"                    \"Expected ~a to be equal to ~a\" x y))\n"
"```"
msgstr ""

#: in/chapter9.md:1629
msgid "Here are the results of (`test-it`) with and without profiling:"
msgstr "Вот результаты (`test-it`) с профилированием и без него:"

#: in/chapter9.md:1636
msgid ""
"```lisp\n"
"> (test-it nil)\n"
"Evaluation of (MAPCAR #'SIMPLIFY *TEST-DATA*) took 6.612  seconds.\n"
"> (test-it t)\n"
"Total elapsed time: 22.819614  seconds\n"
"```"
msgstr ""

#: in/chapter9.md:1645
msgid ""
"| []()    |         |         |                  |\n"
"|---------|---------|---------|------------------|\n"
"| `Count` | `Secs`  | `Time%` | `Name`           |\n"
"| `51690` | `11.57` | `51%`   | `PAT-MATCH`      |\n"
"| `37908` | `8.75`  | `38%`   | `VARIABLE-P`     |\n"
"| `1393`  | `0.32`  | `1%`    | `MATCH-VARIABLE` |\n"
"| `906`   | `0.20`  | `1%`    | `SIMPLIFY`       |\n"
"| `274`   | `1.98`  | `9%`    | `SIMPLIFY-EXP`   |"
msgstr ""

#: in/chapter9.md:1649
msgid ""
"Running the test takes 6.6  seconds normally, although the time triples when "
"the profiling overhead is added in.\n"
"It should be clear that to speed things up, we have to either speed up or "
"cut down on the number of calls to `pat-match` or `variable-p`, since "
"together they account for 89% of the calls (and 89% of the time as well).\n"
"We will look at three methods for achieving both those goals."
msgstr ""
"Обычно выполнение теста занимает 6,6 секунды, хотя время увеличивается втрое "
"при добавлении дополнительных затрат на профилирование.\n"
"Должно быть ясно, что для ускорения работы мы должны либо ускорить, либо "
"сократить количество обращений к `pat-match` или `variable-p`, поскольку "
"вместе они составляют 89% вызовов (и 89% времени тоже).\n"
"Мы рассмотрим три метода достижения обеих этих целей."

#: in/chapter9.md:1651
msgid "#### Memoization"
msgstr "#### Memoization(Запоминание вычисленных результатов)"

#: in/chapter9.md:1657
msgid ""
"Consider the rule that transforms (`x  +  x`) into (`2 * x`).\n"
"Once this is done, we have to simplify the result, which involves "
"resimplifying the components.\n"
"If `x` were some complex expression, this could be time-consuming, and it "
"will certainly be wasteful, because `x` is already simplified and cannot "
"change.\n"
"We have seen this type of problem before, and the solution is memoization: "
"make `simplify` remember the work it has done, rather than repeating the "
"work.\n"
"We can just say:"
msgstr ""
"Рассмотрим правило, которое преобразует (`x + x`) в (`2 * x`).\n"
"Как только это будет сделано, мы должны упростить результат, что "
"предполагает повторное упрощение компонентов.\n"
"Если бы `x` был некоторым сложным выражением, это могло бы занять много "
"времени и, безусловно, будет расточительным, потому что `x` уже упрощен и не "
"может измениться.\n"
"Мы уже сталкивались с подобными проблемами раньше, и решением является "
"мемоизация: заставьте `simplify` запоминать проделанную работу, а не "
"повторять ее.\n"
"Можно просто сказать:"

#: in/chapter9.md:1661
msgid ""
"```lisp\n"
"(memoize 'simplify :test #'equal)\n"
"```"
msgstr ""

#: in/chapter9.md:1666
msgid ""
"Two questions are unclear: what kind of hash table to use, and whether we "
"should clear the hash table between problems.\n"
"The simplifier was timed for all four combinations of `eq` or `equal` hash "
"tables and resetting or nonresetting between problems.\n"
"The fastest result was `equal` hashing and nonresetting.\n"
"Note that with `eq` hashing, the resetting version was faster, presumably "
"because it couldn't take advantage of the common subexpressions between "
"examples (since they aren't `eq`)."
msgstr ""
"Неясны два вопроса: какую хеш-таблицу использовать и нужно ли очищать хеш-"
"таблицу между проблемами.\n"
"Упрощение рассчитывалось для всех четырех комбинаций хэш-таблиц `eq` или "
"`equal` и сброса или отсутствия сброса между задачами.\n"
"Самым быстрым результатом было `equal` хеширование без сброса(очистки).\n"
"Обратите внимание, что с хешированием `eq` версия с сбросом была быстрее, "
"предположительно потому, что она не могла использовать преимущества общих "
"подвыражений между примерами (поскольку они не являются `eq`)."

#: in/chapter9.md:1674
msgid ""
"| hashing | resetting | time |\n"
"|---------|-----------|------|\n"
"| none    | -         | 6.6  |\n"
"| equal   | yes       | 3.8  |\n"
"| equal   | no        | 3.0  |\n"
"| eq      | yes       | 7.0  |\n"
"| eq      | no        | 10.2 |"
msgstr ""

#: in/chapter9.md:1682
msgid ""
"This approach makes the function `simplify` remember the work it has done, "
"in a hash table.\n"
"If the overhead of hash table maintenance becomes too large, there is an "
"alternative: make the data remember what simplify has done.\n"
"This approach was taken in MACSYMA: it represented operators as lists rather "
"than as atoms.\n"
"Thus, instead of `(* 2 x)`, MACSYMA would use `((*) 2 x)`.\n"
"The simplification function would destructively insert a marker into the "
"operator list.\n"
"Thus, the result of simplifying 2*x* would be `((* simp) 2 x)`.\n"
"Then, when the simplifier was called recursively on this expression, it "
"would notice the `simp` marker and return the expression as is."
msgstr ""
"Такой подход заставляет функцию `simplify` запоминать выполненную работу в "
"хэш-таблице.\n"
"Если накладные расходы на обслуживание хеш-таблицы становятся слишком "
"большими, есть альтернатива: заставить данные помнить, что было сделано "
"упрощением.\n"
"Этот подход был использован в MACSYMA: она представляет операторы в виде "
"списков, а не атомов.\n"
"Таким образом, вместо `(* 2 x)` MACSYMA будет использовать `((*) 2 x)`.\n"
"Функция упрощения будет разрушающим образом вставлять маркер в список "
"операторов.\n"
"Таким образом, результатом упрощения 2 *x* будет `((* simp) 2 x)`.\n"
"Затем, когда упрощатель будет вызваться рекурсивно для этого выражения, он "
"заметит маркер `simp` и вернет выражение как есть."

#: in/chapter9.md:1686
msgid ""
"The idea of associating memoization information with the data instead of "
"with the function will be more efficient unless there are many functions "
"that all want to place their marks on the same data.\n"
"The data-oriented approach has two drawbacks: it doesn't identify structures "
"that are `equal` but not `eq`, and, because it requires explicitly altering "
"the data, it requires every other operation that manipulates the data to "
"know about the marker s.\n"
"The beauty of the hash table approach is that it is transparent; no code "
"needs to know that memoization is taking place."
msgstr ""
"Идея связать мемоизационную информацию с данными, а не с функцией будет "
"более эффективной, если не будет много функций, которые все захотят "
"поставить свои отметки на одни и те же данные.\n"
"Подход, ориентированный на данные, имеет два недостатка: он не "
"идентифицирует структуры, которые `equal`, но не `eq`, и, поскольку он "
"требует явного изменения данных, он требует, чтобы каждая другая операция, "
"которая манипулирует данными, знала о маркере.\n"
"Прелесть подхода с использованием хеш-таблицы в том, что он прозрачен; "
"никакой код не должен знать, что происходит мемоизация."

#: in/chapter9.md:1688
msgid "#### Indexing"
msgstr "#### Индексация"

#: in/chapter9.md:1694
msgid ""
"We currently go through the entire list of rules one at a time, checking "
"each rule.\n"
"This is inefficient because most of the rules could be trivially ruled out-"
"if only they were indexed properly.\n"
"The simplest indexing scheme would be to have a separate list of rules "
"indexed under each operator.\n"
"Instead of having `simplify-exp` check each member of `*simplification-"
"rules*`, it could look only at the smaller list of rules for the appropriate "
"operator.\n"
"Here's how:"
msgstr ""
"В настоящее время мы просматриваем весь список правил по одному, проверяя "
"каждое правило.\n"
"Это неэффективно, потому что большинство правил можно тривиально исключить, "
"если только они были правильно проиндексированы.\n"
"Самая простая схема индексации - это иметь отдельный список правил, "
"индексируемых под каждым оператором.\n"
"Вместо того, чтобы проверять `simplify-exp` каждый член `*simplification-"
"rules*` с помощью `simpleify-exp`, он может просматривать только меньший "
"список правил для соответствующего оператора.\n"
"Вот как:"

#: in/chapter9.md:1698
msgid ""
"```lisp\n"
"(defun simplify-exp (exp)\n"
"```"
msgstr ""

#: in/chapter9.md:1701
msgid ""
"`    \"Simplify using a rule.\n"
"or by doing arithmetic.`"
msgstr ""

#: in/chapter9.md:1725
msgid ""
"```lisp\n"
"    or by using the simp function supplied for this operator.\n"
"    This version indexes simplification rules under the operator.\"\n"
"    (cond ((simplify-by-fn exp))\n"
"                ((rule-based-translator exp (rules-for (exp-op exp)) ;***\n"
"                      :rule-if #'exp-lhs :rule-then #'exp-rhs\n"
"                      :action #'(lambda (bindings response)\n"
"                                            (simplify (sublis bindings "
"response)))))\n"
"                ((evaluable exp) (eval exp))\n"
"                (t exp)))\n"
"(defvar *rules-for* (make-hash-table :test #'eq))\n"
"(defun main-op (rule) (exp-op (exp-lhs rule)))\n"
"(defun index-rules (rules)\n"
"    \"Index all the rules under the main op.\"\n"
"    (clrhash *rules-for*)\n"
"    (dolist (rule rules)\n"
"        ;; nconc instead of push to preserve the order of rules\n"
"        (setf (gethash (main-op rule) *rules-for*)\n"
"                    (nconc (gethash (main-op rule) *rules-for*)\n"
"                                  (list rule)))))\n"
"(defun rules-for (op) (gethash op *rules-for*))\n"
"(index-rules *simplification-rules*)\n"
"```"
msgstr ""

#: in/chapter9.md:1729
msgid ""
"Timing the memoized, indexed version gets us to .98  seconds, down from 6.6  "
"seconds for the original code and 3 seconds for the memoized code.\n"
"If this hadn't helped, we could have considered more sophisticated indexing "
"schemes.\n"
"Instead, we move on to consider other means of gaining efficiency."
msgstr ""
"Время для мемоизированной(memoized) и индексированной(indexed) версии дает "
"нам 0,98 секунды, по сравнению с 6,6 секунды для исходного кода и 3 секунд "
"для мемоизированного(memoized) кода.\n"
"Если бы это не помогло, мы могли бы рассмотреть более сложные схемы "
"индексации.\n"
"Вместо этого мы переходим к рассмотрению других средств повышения "
"эффективности."

#: in/chapter9.md:1734
msgid ""
"**Exercise  9.2 [m]** The list of rules for each operator is stored in a "
"hash table with the operator as key.\n"
"An alternative would be to store the rules on the property list of each "
"operator, assuming operators must be symbols.\n"
"Implement this alternative, and time it against the hash table approach.\n"
"Remember that you need some way of clearing the old rules-trivial with a "
"hash table, but not automatic with property lists."
msgstr ""
"**Exercise  9.2 [m]** Список правил для каждого оператора хранится в хеш-"
"таблице с оператором в качестве ключа.\n"
"Альтернативой могло бы быть хранение правил в списке свойств каждого "
"оператора, предполагая, что операторы должны быть символами.\n"
"Реализуйте эту альтернативу и сопоставьте ее с подходом с хэш-таблицей.\n"
"Помните, что вам нужен какой-то способ очистки старых правил - тривиальный с "
"помощью хеш-таблицы, но не автоматический со списками свойств."

#: in/chapter9.md:1736
msgid "#### Compilation"
msgstr "#### Компиляция"

#: in/chapter9.md:1740
msgid ""
"You can look at `simplify-exp` as an interpreter for the simplification rule "
"language.\n"
"One proven technique for improving efficiency is to replace the interpreter "
"with a compiler.\n"
"For example, the rule `(x  +  x  =  2 * x)` could be compiled into something "
"like:"
msgstr ""
"Вы можете посмотреть на `simpleify-exp` как на интерпретатор языка правил "
"упрощения.\n"
"Один из проверенных методов повышения эффективности - замена интерпретатора "
"компилятором.\n"
"Например, правило `(x + x = 2 * x)` может быть скомпилировано во что-то "
"вроде:"

#: in/chapter9.md:1746
msgid ""
"```lisp\n"
"(lambda (exp)\n"
"    (if (and (eq (exp-op exp) '+) (equal (exp-lhs exp) (exp-rhs exp)))\n"
"            (make-exp :op '* :lhs 2 :rhs (exp-rhs exp))))\n"
"```"
msgstr ""

#: in/chapter9.md:1750
msgid ""
"This eliminates the need for consing up and passing around variable "
"bindings, and should be faster than the general matching procedure.\n"
"When used in conjunction with indexing, the individual rules can be simpler, "
"because we already know we have the right operator.\n"
"For example, with the above rule indexed under \"+\", it could now be "
"compiled as:"
msgstr ""
"Это устраняет необходимость в использовании конструирования списков(консинга/"
"consing) и передаче привязок переменных и должно быть быстрее, чем обычная "
"процедура сопоставления.\n"
"При использовании вместе с индексированием отдельные правила могут быть "
"проще, потому что мы уже знаем, что у нас есть правильный оператор.\n"
"Например, с указанным выше правилом, обозначенным знаком \"+\", теперь его "
"можно скомпилировать как:"

#: in/chapter9.md:1756
msgid ""
"```lisp\n"
"(lambda (exp)\n"
"    (if (equal (exp-lhs exp) (exp-rhs exp))\n"
"            (make-exp :op '* :lhs 2 :rhs (exp-lhs exp))))\n"
"```"
msgstr ""

#: in/chapter9.md:1758
msgid ""
"It is important to note that when these functions return nil, it means that "
"they have failed to simplify the expression, and we have to consider another "
"means of simplification."
msgstr ""
"Важно отметить, что когда эти функции возвращают nil, это означает, что они "
"не смогли упростить выражение, и мы должны рассмотреть другие способы "
"упрощения."

#: in/chapter9.md:1770
msgid ""
"Another possibility is to compile a set of rules all at the same time, so "
"that the indexing is in effect part of the compiled code.\n"
"As an example, I show here a small set of rules and a possible compilation "
"of the rule set.\n"
"The generated function assumes that `x` is not an atom.\n"
"This is appropriate because we are replacing `simplify-exp`, not "
"`simplify`.\n"
"Also, we will return nil to indicate that `x` is already simplified.\n"
"I have chosen a slightly different format for the code; the main difference "
"is the let to introduce variable names for subexpressions.\n"
"This is useful especially for deeply nested patterns.\n"
"The other difference is that I explicitly build up the answer with a call to "
"`list`, rather than `make-exp`.\n"
"This is normally considered bad style, but since this is code generated by a "
"compiler, I wanted it to be as efficient as possible.\n"
"If the representation of the exp data type changed, we could simply change "
"the compiler; a much easier task than hunting down all the references spread "
"throughout a human- written program.\n"
"The comments following were not generated by the compiler."
msgstr ""
"Другая возможность состоит в том, чтобы скомпилировать набор правил "
"одновременно, чтобы индексирование фактически было частью скомпилированного "
"кода.\n"
"В качестве примера я показываю здесь небольшой набор правил и возможную "
"компиляцию набора правил.\n"
"Созданная функция предполагает, что `x` не является атомом.\n"
"Это уместно, потому что мы заменяем `simpleify-exp`, а не `simplify`.\n"
"Кроме того, мы вернем nil, чтобы указать, что `x` уже упрощен.\n"
"Я выбрал немного другой формат кода; основное отличие - это возможность "
"вводить имена переменных для подвыражений.\n"
"Это особенно полезно для глубоко вложенных шаблонов(образцов).\n"
"Другое отличие состоит в том, что я явно создаю ответ с помощью вызова "
"`list`, а не `make-exp`.\n"
"Обычно это считается плохим стилем, но, поскольку это код, созданный "
"компилятором, я хотел, чтобы он был максимально эффективным.\n"
"Если бы представление типа данных exp изменилось, мы могли бы просто "
"изменить компилятор; задача гораздо проще, чем поиск всех ссылок, "
"разбросанных по программе, написанной человеком.\n"
"Следующие комментарии не были созданы компилятором."

#: in/chapter9.md:1791
msgid ""
"```lisp\n"
"(x * 1  =  x)\n"
"(1 * x  =  x)\n"
"(x * 0  =  0)\n"
"(0 * x  =  0)\n"
"(x * x  =  x ^ 2)\n"
"(lambda (x)\n"
"    (let ((xl (exp-lhs x))\n"
"                (xr (exp-rhs x)))\n"
"        (or (if (eql xr '1)        ; (x*1  =  X)\n"
"                        xl)\n"
"                (if (eql xl '1)        ; (1*x  =  X)\n"
"                        xr)\n"
"                (if (eql xr '0)        ; (x*0  =  0)\n"
"                        '0)\n"
"                (if (eql xl '0)        ; (0*x  =  0)\n"
"                        '0)\n"
"                (if (equal xr xl)    ; (x*x  =  x  ^  2)\n"
"                        (list '^ xl '2)))))\n"
"```"
msgstr ""

#: in/chapter9.md:1793
msgid ""
"I chose this format for the code because I imagined (and later *show*) that "
"it would be fairly easy to write the compiler for it."
msgstr ""
"Я выбрал этот формат для кода, потому что я представлял (и позже *show*), "
"что для него будет довольно легко написать компилятор."

#: in/chapter9.md:1795
msgid "#### The Single-Rule Compiler"
msgstr "#### Компилятор с одним правилом"

#: in/chapter9.md:1798
msgid ""
"Here I show the complete single-rule compiler, to be followed by the indexed-"
"rule-set compiler.\n"
"The single-rule compiler works like this:"
msgstr ""
"Здесь я показываю полный компилятор c одним правилом, за которым следует "
"компилятор индексированного набора правил.\n"
"Компилятор с одним правилом работает так:"

#: in/chapter9.md:1803
msgid ""
"```lisp\n"
"> (compile-rule '(= (+ x x) (* 2 x)))\n"
"(LAMBDA (X)\n"
"```"
msgstr ""

#: in/chapter9.md:1806
msgid ""
"`    (IF (OP?\n"
"X '+)`"
msgstr ""

#: in/chapter9.md:1813
msgid ""
"```lisp\n"
"        (LET ((XL (EXP-LHS X))\n"
"                    (XR (EXP-RHS X)))\n"
"          (IF (EQUAL XR XL)\n"
"                  (SIMPLIFY-EXP (LIST '* '2 XL))))))\n"
"```"
msgstr ""

#: in/chapter9.md:1821
msgid ""
"Given a rule, it generates code that first tests the pattern and then builds "
"the right- hand side of the rule if the pattern matches.\n"
"As the code is generated, correspondences are built between variables in the "
"pattern, like `x`, and variables in the generated code, like `xl`.\n"
"These are kept in the association list `*bindings*`.\n"
"The matching can be broken down into four cases: variables that haven't been "
"seen before, variables that have been seen before, atoms, and lists.\n"
"For example, the first time we run across `x` in the rule above, no test is "
"generated, since anything can match `x`.\n"
"But the entry `(x.xl)` is added to the `*bindings*` list to mark the "
"equivalence.\n"
"When the second `x` is encountered, the test `(equal xr xl)` is generated."
msgstr ""
"Получая правило, он генерирует код, который сначала проверяет образец, а "
"затем строит правую часть правила, если образец совпадает.\n"
"По мере того, как код генерируется, соответствия устанавливаются между "
"переменными в образце, такими как `x`, и переменными в сгенерированном коде, "
"например, `xl`.\n"
"Они хранятся в списке ассоциаций `*bindings*`.\n"
"Сопоставление можно разбить на четыре случая: переменные, которые НЕ были "
"замечены ранее, переменные, которые наблюдались раньше, атомы и списки.\n"
"Например, в первый раз, когда мы сталкиваемся с `x` в приведенном выше "
"правиле, тест не генерируется, поскольку все что угодно может "
"соответствовать `x`.\n"
"Но запись `(x . xl)` добавляется в список `*bindings*`, чтобы отметить "
"эквивалентность.\n"
"Когда встречается второй `x`, генерируется проверка/тест `(equal xr xl)`."

#: in/chapter9.md:1828
msgid ""
"Organizing the compiler is a little tricky, because we have to do three "
"things at once: return the generated code, keep track of the `*bindings*`, "
"and keep track of what to do \"next\"-that is, when a test succeeds, we need "
"to generate more code, either to test further, or to build the result.\n"
"This code needs to know about the bindings, so it can't be done *before* the "
"first part of the test, but it also needs to know where it should be placed "
"in the overall code, so it would be messy to do it *after* the first part of "
"the test.\n"
"The answer is to pass in a function that will tell us what code to generate "
"later.\n"
"This way, it gets done at the right time, and ends up in the right place as "
"well.\n"
"Such a function is often called a *continuation*, because it tells us where "
"to continue computing.\n"
"In our compiler, the variable `consequent` is a continuation function."
msgstr ""
"Организовать компилятор немного сложнее, потому что мы должны делать сразу "
"три вещи: возвращать сгенерированный код, отслеживать `*привязки*` и "
"отслеживать, что делать \"дальше\", то есть когда тест успешен, нам нужно "
"сгенерировать больше кода либо для дальнейшего тестирования, либо для "
"построения результата.\n"
"Этот код должен знать о привязках, поэтому он не может быть выполнен *до* "
"первой части теста, но он также должен знать, где он должен быть размещен в "
"общем коде, поэтому это было бы грязно сделать это *после* первой части "
"теста.\n"
"Ответ - передать функцию, которая сообщит нам, какой код сгенерировать "
"позже.\n"
"Таким образом, это делается в нужное время и тоже оказывается в нужном "
"месте.\n"
"Такую функцию часто называют *продолжением*(*continuation*), потому что она "
"сообщает нам, где продолжить вычисления.\n"
"В нашем компиляторе переменная `consquent` является функцией продолжения."

#: in/chapter9.md:1831
msgid ""
"The compiler is called `compile-rule`.\n"
"It takes a rule as an argument and returns a lambda expression that "
"implements the rule."
msgstr ""
"Компилятор называется `compile-rule`.\n"
"Он принимает правило в качестве аргумента и возвращает лямбда-выражение, "
"реализующее правило."

#: in/chapter9.md:1843
msgid ""
"```lisp\n"
"(defvar *bindings* nil\n"
"    \"A list of bindings used by the rule compiler.\")\n"
"(defun compile-rule (rule)\n"
"    \"Compile a single rule.\"\n"
"    (let ((*bindings* nil))\n"
"        '(lambda (x)\n"
"            ,(compile-exp 'x (exp-lhs rule) ; x is the lambda parameter\n"
"                                        (delay (build-exp (exp-rhs rule)\n"
"                                                                                              *bindings*))))))\n"
"```"
msgstr ""

#: in/chapter9.md:1851
msgid ""
"All the work is done by `compile-exp`, which takes three arguments: a "
"variable that will represent the input in the generated code, a pattern that "
"the input should be matched against, and a continuation for generating the "
"code if the test passes.\n"
"There are five cases: (1) If the pattern is a variable in the list of "
"bindings, then we generate an equality test.\n"
"(2) If the pattern is a variable that we have not seen before, then we add "
"it to the binding list, generate no test (because anything matches a "
"variable) and then generate the consequent code.\n"
"(3) If the pattern is an atom, then the match succeeds only if the input is "
"`eql` to that atom.\n"
"(4) If the pattern is a conditional like `(?is n numberp)`, then we generate "
"the test `(numberp n)`.\n"
"Other such patterns could be included here but have not been, since they "
"have not been used.\n"
"Finally, (5) if the pattern is a list, we check that it has the right "
"operator and arguments."
msgstr ""
"Вся работа выполняется с помощью `compile-exp`, который принимает три "
"аргумента: переменную, которая будет представлять входные данные в "
"сгенерированном коде, образец, которому входные данные должны быть "
"сопоставлены, и продолжение для генерации кода, если тест пройден.\n"
"Есть пять случаев: (1) Если образец переменной в списке привязок, мы "
"генерируем тест на равенство.\n"
"(2) Если образец представляет собой переменную, которую мы раньше не видели, "
"то мы добавляем ее в список привязок, не генерируем никакого теста (потому "
"что что-либо соответствует переменной), а затем генерируем соответствующий "
"код.\n"
"(3) Если образец представляет собой атом, то совпадение будет успешным, "
"только если ввод эквивалентен `eql` атому.\n"
"(4) Если образец является условным, например  `(?is n numberp)`, мы "
"генерируем тест `(numberp n)`.\n"
"Другие подобные образцы могут быть включены сюда, но не были включены, "
"поскольку они не использовались.\n"
"Наконец, (5) если образец является списком, мы проверяем, что он имеет "
"правильный оператор и аргументы."

#: in/chapter9.md:1856
msgid ""
"```lisp\n"
"(defun compile-exp (var pattern consequent)\n"
"    \"Compile code that tests the expression, and does consequent\n"
"```"
msgstr ""

#: in/chapter9.md:1859
msgid ""
"`    if it matches.\n"
"Assumes bindings in *bindings*.\"`"
msgstr ""
"`    если он совпадает.\n"
"Предполагает привязки в *bindings*`"

#: in/chapter9.md:1865
msgid ""
"```lisp\n"
"    (cond ((get-binding pattern *bindings*)\n"
"                  ;; Test a previously bound variable\n"
"                  '(if (equal .var .(lookup pattern *bindings*))\n"
"```"
msgstr ""

#: in/chapter9.md:1867
msgid "  `                          ,(force consequent)))`"
msgstr ""

#: in/chapter9.md:1882
msgid ""
"```lisp\n"
"                ((variable-p pattern)\n"
"                  ;; Add a new bindings; do type checking if needed.\n"
"                  (push (cons pattern var) *bindings*)\n"
"                  (force consequent))\n"
"                ((atom pattern)\n"
"                  ;; Match a literal atom\n"
"                  '(if (eql ,var '.pattern)\n"
"                            ,(force consequent)))\n"
"                ((starts-with pattern '?is)\n"
"                  (push (cons (second pattern) var) *bindings*)\n"
"                  '(if (,(third pattern) ,var)\n"
"                            ,(force consequent)))\n"
"```"
msgstr ""

#: in/chapter9.md:1885
msgid ""
"`                  ;; So.\n"
"far, only the ?is pattern is covered, because`"
msgstr ""
"`                  ;; Так.\n"
"потому что, пока что покрывается только образец ?is`"

#: in/chapter9.md:1892
msgid ""
"```lisp\n"
"                  ;; it is the only one used in simplification rules.\n"
"                  ;; Other patterns could be compiled by adding code here.\n"
"                  ;; Or we could switch to a data-driven approach.\n"
"                  (t ;; Check the operator and arguments\n"
"```"
msgstr ""

#: in/chapter9.md:1895
msgid ""
"`                    '(if (op?\n"
",var ',(exp-op pattern))`"
msgstr ""

#: in/chapter9.md:1899
msgid ""
"```lisp\n"
"                            ,(compile-args var pattern consequent)))))\n"
"```"
msgstr ""

#: in/chapter9.md:1903
msgid ""
"The function `compile-args` is used to check the arguments to a pattern.\n"
"It generates a `let` form binding one or two new variables (for a unary or "
"binary expression), and then calls `compile-exp` to generate code that "
"actually makes the tests.\n"
"It just passes along the continuation, `consequent`, to `compile-exp`."
msgstr ""
"Функция `compile-args` используется для проверки аргументов образца.\n"
"Она генерирует форму `let`, связывающую одну или две новые переменные (для "
"унарного или бинарного выражения), а затем вызывает `compile-exp` для "
"генерации кода, который фактически выполняет тесты.\n"
"Она просто передает продолжение, `consquent`, в `compile-exp`."

#: in/chapter9.md:1923
msgid ""
"```lisp\n"
"(defun compile-args (var pattern consequent)\n"
"    \"Compile code that checks the arg or args, and does consequent\n"
"    if the arg(s) match.\"\n"
"    ;; First make up variable names for the arg(s).\n"
"    (let ((L (symbol var 'L))\n"
"                (R (symbol var 'R)))\n"
"        (if (exp-rhs pattern)\n"
"                ;; two arg case\n"
"                '(let ((,L (exp-lhs ,var))\n"
"                              (,R (exp-rhs ,var)))\n"
"                      ,(compile-exp L (exp-lhs pattern)\n"
"                                                  (delay\n"
"                                                      (compile-exp R (exp-"
"rhs pattern)\n"
"                                                                                consequent))))\n"
"                ;; one arg case\n"
"                '(let ((,L (exp-lhs ,var)))\n"
"                      ,(compile-exp L (exp-lhs pattern) consequent)))))\n"
"```"
msgstr ""

#: in/chapter9.md:1927
msgid ""
"The remaining functions are simpler.\n"
"`build-exp` generates code to build the right- hand side of a `rule, op?` "
"tests if its first argument is an expression with a given operator, and "
"`symbol` constructs a new symbol.\n"
"Also given is `new-symbol`, although it is not used in this program."
msgstr ""
"Остальные функции попроще.\n"
"`build-exp` генерирует код для построения правой части `rule, op?`, "
"проверяющий, является ли его первый аргумент выражением с заданным "
"оператором, а `symbol` создает новый символ.\n"
"Также указан `new-symbol`, хотя он не используется в этой программе."

#: in/chapter9.md:1941
msgid ""
"```lisp\n"
"(defun build-exp (exp bindings)\n"
"    \"Compile code that will build the exp, given the bindings.\"\n"
"    (cond ((assoc exp bindings) (rest (assoc exp bindings)))\n"
"                ((variable-p exp)\n"
"                  (error \"Variable  ~  a occurred on right-hand side,~\n"
"                                but not left.\" exp))\n"
"                ((atom exp) \",exp)\n"
"                (t (let ((new-exp (mapcar #'(lambda (x)\n"
"                                                                          (build-"
"exp x bindings))\n"
"                                                                      exp)))\n"
"                          '(simplify-exp (list .,new-exp))))))\n"
"```"
msgstr ""

#: in/chapter9.md:1944
msgid ""
"`(defun op?\n"
"(exp op)`"
msgstr ""

#: in/chapter9.md:1955
msgid ""
"```lisp\n"
"    \"Does the exp have the given op as its operator?\"\n"
"    (and (exp-p exp) (eq (exp-op exp) op)))\n"
"(defun symbol (&rest args)\n"
"    \"Concatenate symbols or strings to form an interned symbol\"\n"
"    (intern (format nil \"~{~a~}\" args)))\n"
"(defun new-symbol (&rest args)\n"
"    \"Concatenate symbols or strings to form an uninterned symbol\"\n"
"    (make-symbol (format nil \"~{~a~}\" args)))\n"
"```"
msgstr ""

#: in/chapter9.md:1957
msgid "Here are some examples of the compiler:"
msgstr "Вот несколько примеров работы компилятора:"

#: in/chapter9.md:1962
msgid ""
"```lisp\n"
"> (compile-rule '(= (log (^ e x)) x))\n"
"(LAMBDA (X)\n"
"```"
msgstr ""

#: in/chapter9.md:1965
msgid ""
"`    (IF (OP?\n"
"X 'LOG)`"
msgstr ""

#: in/chapter9.md:1969
msgid ""
"```lisp\n"
"        (LET ((XL (EXP-LHS X)))\n"
"```"
msgstr ""

#: in/chapter9.md:1972
msgid ""
"`            (IF (OP?\n"
"XL '^`"
msgstr ""

#: in/chapter9.md:1981
msgid ""
"```lisp\n"
"                    (LET ((XLL (EXP-LHS XL))\n"
"                                (XLR (EXP-RHS XL)))\n"
"                      (IF (EQL XLL 'E)\n"
"                                XLR))))))\n"
"> (compile-rule (simp-rule '(n * (m * x)  =  (n * m) * x)))\n"
"(LAMBDA (X)\n"
"```"
msgstr ""

#: in/chapter9.md:1984
msgid ""
"`    (IF (OP?\n"
"X '*)`"
msgstr ""

#: in/chapter9.md:1990
msgid ""
"```lisp\n"
"        (LET ((XL (EXP-LHS X))\n"
"                    (XR (EXP-RHS X)))\n"
"            (IF (NUMBERP XL)\n"
"```"
msgstr ""

#: in/chapter9.md:1993
msgid ""
"`                    (IF (OP?\n"
"XR '*)`"
msgstr ""

#: in/chapter9.md:2003
msgid ""
"```lisp\n"
"                        (LET ((XRL (EXP-LHS XR))\n"
"                                    (XRR (EXP-RHS XR)))\n"
"                            (IF (NUMBERP XRL)\n"
"                                (SIMPLIFY-EXP\n"
"                                    (LIST '*\n"
"                                                (SIMPLIFY-EXP (LIST '* XL "
"XRL))\n"
"                                                XRR)))))))))\n"
"```"
msgstr ""

#: in/chapter9.md:2005
msgid "#### The Rule-Set Compiler"
msgstr "#### Компилятор с набором правил"

#: in/chapter9.md:2010
msgid ""
"The next step is to combine the code generated by this single-rule compiler "
"to generate more compact code for sets of rules.\n"
"We'll divide up the complete set of rules into subsets based on the main "
"operator (as we did with the `rules-for` function), and generate one big "
"function for each operator.\n"
"We need to preserve the order of the rules, so only certain optimizations "
"are possible, but if we make the assumption that no function has side "
"effects (a safe assumption in this application), we can still do pretty "
"well.\n"
"We'll use the `simp-fn` facility to install the one big function for each "
"operator."
msgstr ""
"Следующим шагом является объединение кода, сгенерированного этим "
"компилятором одного правила, для создания более компактного кода для наборов "
"правил.\n"
"Мы разделим полный набор правил на подмножества на основе главного оператора "
"(как мы это делали с функцией `rules-for`) и сгенерируем по одной большой "
"функции для каждого оператора.\n"
"Нам нужно сохранить порядок правил, поэтому возможны только определенные "
"оптимизации, но если мы сделаем предположение, что ни одна функция не имеет "
"побочных эффектов (безопасное предположение в этом приложении), мы все равно "
"можем работать довольно хорошо.\n"
"Мы будем использовать средство `simp-fn`, чтобы установить одну большую "
"функцию для каждого оператора."

#: in/chapter9.md:2014
msgid ""
"The function `compile-rule-set` takes an operator, finds all the rules for "
"that operator, and compiles each rule individually.\n"
"(It uses`compile-indexed-rule` rather than `compile-rule`, because it "
"assumes we have already done the indexing for the main operator.) After each "
"rule has been compiled, they are combined with `combine-rules`, which merges "
"similar parts of rules and concatenates the different parts.\n"
"The result is wrapped in a `lambda` expression and compiled as the final "
"simplification function for the operator."
msgstr ""
"Функция `compile-rule-set` принимает оператор, находит все правила для этого "
"оператора и компилирует каждое правило индивидуально.\n"
"(Она использует `compile-indexed-rule`, а не `compile-rule`, поскольку "
"предполагает, что мы уже выполнили индексацию для основного оператора.) "
"После того, как каждое правило было скомпилировано, они объединяются с "
"помощью `comb-rules`, который объединяет похожие части правил и объединяет "
"разные части.\n"
"Результат оборачивается `лямбда`-выражением и компилируется как последняя "
"функция упрощения для оператора."

#: in/chapter9.md:2033
msgid ""
"```lisp\n"
"(defun compile-rule-set (op)\n"
"    \"Compile all rules indexed under a given main op,\n"
"    and make them into the simp-fn for that op.\"\n"
"    (set-simp-fn op\n"
"        (compile nil\n"
"            '(lambda (x)\n"
"                ,(reduce #'combine-rules\n"
"                                  (mapcar #'compile-indexed-rule\n"
"                                                (rules-for op)))))))\n"
"(defun compile-indexed-rule (rule) .\n"
"    \"Compile one rule into lambda-less code,\n"
"    assuming indexing of main op.\"\n"
"    (let ((*bindings* nil))\n"
"        (compile-args\n"
"            'x (exp-lhs rule)\n"
"            (delay (build-exp (exp-rhs rule) *bindings*)))))\n"
"```"
msgstr ""

#: in/chapter9.md:2035
msgid "Here are two examples of what `compile-indexed-rule` generates:"
msgstr "Вот два примера того, что генерирует правило `compile-indexed-rule`:"

#: in/chapter9.md:2044
msgid ""
"```lisp\n"
"> (compile-indexed-rule '(= (log 1) 0))\n"
"  (LET ((XL (EXP-LHS X)))\n"
"    (IF (EQL XL '1)\n"
"            '0))\n"
"> (compile-indexed-rule '(= (log (^ e x)) x))\n"
"  (LET ((XL (EXP-LHS X)))\n"
"```"
msgstr ""

#: in/chapter9.md:2047
msgid ""
"`    (IF (OP?\n"
"XL '^)`"
msgstr ""

#: in/chapter9.md:2054
msgid ""
"```lisp\n"
"            (LET ((XLL (EXP-LHS XL))\n"
"                        (XLR (EXP-RHS XL)))\n"
"                (IF (EQL XLL 'E)\n"
"                          XLR))))\n"
"```"
msgstr ""

#: in/chapter9.md:2057
msgid ""
"The next step is to combine several of these rules into one.\n"
"The function `combine-rules` takes two rules and merges them together as "
"much as possible."
msgstr ""
"Следующий шаг - объединить несколько этих правил в одно.\n"
"Функция `comb-rules` берет два правила и объединяет их в максимально "
"возможной степени."

#: in/chapter9.md:2086
msgid ""
"```lisp\n"
"(defun combine-rules (a b)\n"
"    \"Combine the code for two rules into one, maintaining order.\"\n"
"    ;; In the default case, we generate the code (or a b),\n"
"    ;; but we try to be cleverer and share common code,\n"
"    ;; on the assumption that there are no side-effects.\n"
"    (cond ((and (listp a) (listp b)\n"
"                            (= (length a) (length b) 3)\n"
"                            (equal (first a) (first b))\n"
"                            (equal (second a) (second b)))\n"
"                ;; a  =  (f x y), b  =  (f x z) =>  (f x (combine-rules y "
"z))\n"
"                ;; This can apply when f=IF or f=LET\n"
"                (list (first a) (second a)\n"
"                            (combine-rules (third a) (third b))))\n"
"              ((matching-ifs a b)\n"
"                (if ,(second a)\n"
"                        ,(combine-rules (third a) (third b))\n"
"                        ,(combine-rules (fourth a) (fourth b))))\n"
"              ((starts-with a 'or)\n"
"                ;;    a  =  (or ... (if p y)), b  =  (if p z) =>\n"
"                ;;              (or ... (if p (combine-rules y z)))\n"
"                ;; else\n"
"                ;;    a  =  (or ...) b =  >  (or ... b)\n"
"                (if (matching-ifs (lastl a) b)\n"
"                        (append (butlast a)\n"
"                                        (list (combine-rules (lastl a) b)))\n"
"                        (append a (list b))))\n"
"```"
msgstr ""

#: in/chapter9.md:2089
msgid ""
"`                (t ; ; a.\n"
"b =  >  (or a b)`"
msgstr ""

#: in/chapter9.md:2100
msgid ""
"```lisp\n"
"                    '(or ,a ,b))))\n"
"(defun matching-ifs (a b)\n"
"    \"Are a and b if statements with the same predicate?\"\n"
"    (and (starts-with a 'if) (starts-with b 'if)\n"
"              (equal (second a) (second b))))\n"
"(defun lastl (list)\n"
"    \"Return the last element (not last cons cell) of list\"\n"
"    (first (last list)))\n"
"```"
msgstr ""

#: in/chapter9.md:2102
msgid "Here is what `combine-rules` does with the two rules generated above:"
msgstr "Вот что делает `comb-rules` с двумя сгенерированными выше правилами:"

#: in/chapter9.md:2108
msgid ""
"```lisp\n"
"> (combine-rules\n"
"        '(let ((xl (exp-lhs x))) (if (eql xl '1) '0))\n"
"        '(let ((xl (exp-lhs x)))\n"
"```"
msgstr ""

#: in/chapter9.md:2111
msgid ""
"`              (if (op?\n"
"xl '^)`"
msgstr ""

#: in/chapter9.md:2119
msgid ""
"```lisp\n"
"                      (let ((xl1 (exp-lhs xl))\n"
"                                (xlr (exp-rhs xl)))\n"
"                          (if (eql xll 'e) xlr)))))\n"
"(LET ((XL (EXP-LHS X)))\n"
"    (OR (IF (EQL XL '1) '0)\n"
"```"
msgstr ""

#: in/chapter9.md:2122
msgid ""
"`            (IF (OP?\n"
"XL '^)`"
msgstr ""

#: in/chapter9.md:2128
msgid ""
"```lisp\n"
"                    (LET ((XLL (EXP-LHS XL))\n"
"                                (XLR (EXP-RHS XL)))\n"
"                        (IF (EQL XLL 'E) XLR)))))\n"
"```"
msgstr ""

#: in/chapter9.md:2131
msgid ""
"Now we run the compiler by calling `compile-all-rules-indexed` and show the "
"combined compiled simplification function for log.\n"
"The comments were entered by hand to show what simplification rules are "
"compiled where."
msgstr ""
"Теперь мы запускаем компилятор, вызывая `compile-all-rules-indexed` и "
"показываем комбинированную скомпилированную функцию упрощения для журнала.\n"
"Комментарии были введены вручную, чтобы показать, какие правила упрощения "
"где скомпилированы."

#: in/chapter9.md:2151
msgid ""
"```lisp\n"
"(defun compile-all-rules-indexed (rules)\n"
"    \"Compile a separate fn for each operator, and store it\n"
"    as the simp-fn of the operator.\"\n"
"    (index-rules rules)\n"
"    (let ((all-ops (delete-duplicates (mapcar #'main-op rules))))\n"
"        (mapc #'compile-rule-set ail-ops)))\n"
"> (compile-all-rules-indexed *simplification-rules*)\n"
"(SIN COS LOG  ^  * / -  +  D)\n"
"> (simp-fn 'log)\n"
"(LAMBDA (X)\n"
"    (LET ((XL (EXP-LHS X)))\n"
"        (OR (IF (EQL XL '1)\n"
"                        '0)                                        ;*log 1  "
"=  0*\n"
"                (IF (EQL XL '0)\n"
"                        'UNDEFINED)                        ;*log 0  =  "
"undefined*\n"
"                (IF (EQL XL 'E)\n"
"                        '1)                                        ;*log e  "
"=  1*\n"
"```"
msgstr ""

#: in/chapter9.md:2154
msgid ""
"`                (IF (OP?\n"
"XL '^)`"
msgstr ""

#: in/chapter9.md:2161
msgid ""
"```lisp\n"
"                        (LET ((XLL (EXP-LHS XL))\n"
"                                    (XLR (EXP-RHS XL)))\n"
"                          (IF (EQL XLL 'E)\n"
"                                    XLR))))))              ;*log ex  =  x*\n"
"```"
msgstr ""

#: in/chapter9.md:2163
msgid ""
"If we want to bypass the rule-based simplifier altogether, we can change "
"`simplify-exp` once again to eliminate the check for rules:"
msgstr ""
"Если мы хотим полностью обойти упрощение, основанное на правилах, мы можем "
"еще раз изменить `simpleify-exp`, чтобы исключить проверку правил:"

#: in/chapter9.md:2168
msgid ""
"```lisp\n"
"(defun simplify-exp (exp)\n"
"    \"Simplify by doing arithmetic, or by using the simp function\n"
"```"
msgstr ""

#: in/chapter9.md:2171
msgid ""
"`    supplied for this operator.\n"
"Do not use rules of any kind.\"`"
msgstr ""

#: in/chapter9.md:2177
msgid ""
"```lisp\n"
"    (cond ((simplify-by-fn exp))\n"
"                ((evaluable exp) (eval exp))\n"
"                (t exp)))\n"
"```"
msgstr ""

#: in/chapter9.md:2181
msgid ""
"At last, we are in a position to run the benchmark test on the new compiled "
"code; the function `test-it` runs in about .15  seconds with memoization "
"and .05 without.\n"
"Why would memoization, which helped before, now hurt us?\n"
"Probably because there is a lot of overhead in accessing the hash table, and "
"that overhead is only worth it when there is a lot of other computation to "
"do."
msgstr ""
"Наконец, мы можем провести тест производительности на новом скомпилированном "
"коде; функция `test-it` выполняется примерно за 0,15 секунды с "
"запоминанием(memoization) и 0,05 без.\n"
"Почему мемоизация, которая помогала раньше, теперь вредит нам?\n"
"Вероятно, потому, что при доступе к хеш-таблице возникают большие накладные "
"расходы, и эти накладные расходы окупаются только тогда, когда есть много "
"других вычислений."

#: in/chapter9.md:2186
msgid ""
"We've seen a great improvement since the original code, as the following "
"table summarizes.\n"
"Overall, the various efficiency improvements have resulted in a 130- fold "
"speed-up-we can do now in a minute what used to take two hours.\n"
"Of course, one must keep in mind that the statistics are only good for this "
"one particular set of test data on this one machine.\n"
"It is an open question what performance you will get on other problems and "
"on other machines."
msgstr ""
"По сравнению с исходным кодом мы увидели значительное улучшение, как "
"показано в следующей таблице.\n"
"В целом, различные улучшения эффективности привели к увеличению скорости в "
"130 раз - теперь мы можем сделать за минуту то, что раньше занимало два "
"часа.\n"
"Конечно, нужно иметь в виду, что статистика хороша только для этого "
"конкретного набора тестовых данных на этой единственной машине.\n"
"Это открытый вопрос, какую производительность вы получите на других задачах "
"и на других машинах."

#: in/chapter9.md:2188
msgid ""
"The following table summarizes the execution time and number of function "
"calls on the test data:"
msgstr ""
"В следующей таблице приведены время выполнения и количество вызовов функций "
"для тестовых данных:"

#: in/chapter9.md:2200
msgid ""
"| []()            |          |       |              |             |      |\n"
"|-----------------|----------|-------|--------------|-------------|------|\n"
"|                 | original | memo  | memo + index | memo + comp | comp |\n"
"| run time (secs) | 6.6      | 3.0   | .98          | .15         | .05  |\n"
"| speed-up        | -        | 2     | 7            | 44          | 130  |\n"
"| calls           |\n"
"| pat-match       | 51690    | 20003 | 5159         | 0           | 0    |\n"
"| variable-p      | 37908    | 14694 | 4798         | 0           | 0    |\n"
"| match-variable  | 1393     | 551   | 551          | 0           | 0    |\n"
"| simplify        | 906      | 408   | 408          | 545         | 906  |\n"
"| simplify-exp    | 274      | 118   | 118          | 118         | 274  |"
msgstr ""

#: in/chapter9.md:2202
msgid "## 9.7 History and References"
msgstr "## 9.7 История и ссылки"

#: in/chapter9.md:2206
msgid ""
"The idea of memoization was introduced by Donald Michie 1968.\n"
"He proposed using a list of values rather than a hash table, so the savings "
"was not as great.\n"
"In mathematics, the field of dynamic programming is really just the study of "
"how to compute values in the proper order so that partial results will "
"already be cached away when needed."
msgstr ""

#: in/chapter9.md:2210
msgid ""
"A large part of academic computer science covers compilation; [Aho and "
"Ullman 1972](B9780080571157500285.xhtml#bb0015) is just one example.\n"
"The technique of compiling embedded languages (such as the language of "
"pattern-matching rules) is one that has achieved much more attention in the "
"Lisp community than in the rest of computer science.\n"
"See [Emanuelson and Haraldsson 1980](B9780080571157500285.xhtml#bb0365), for "
"an example."
msgstr ""

#: in/chapter9.md:2212
msgid ""
"Choosing the right data structure, indexing it properly, and defining "
"algorithms to operate on it is another important branch of computer science; "
"[Sedgewick 1988](B9780080571157500285.xhtml#bb1065) is one example, but "
"there are many worthy texts."
msgstr ""

#: in/chapter9.md:2219
msgid ""
"Delaying computation by packaging it up in a `lambda` expression is an idea "
"that goes back to Algol's use of *thunks*-a mechanism to implement call-by-"
"name parameters, essentially by passing functions of no arguments.\n"
"The name *thunk* comes from the fact that these functions can be compiled: "
"the system does not have to think about them at run time, because the "
"compiler has already thunk about them.\n"
"Peter [Ingerman 1961](B9780080571157500285.xhtml#bb0570) describes thunks in "
"detail.\n"
"[Abelson and Sussman 1985](B9780080571157500285.xhtml#bb0010) cover delays "
"nicely.\n"
"The idea of eliminating unneeded computation is so attractive that entire "
"languages have built around the concept of *lazy evaluation*-don't evaluate "
"an expression until its value is needed.\n"
"See [Hughes 1985](B9780080571157500285.xhtml#bb0565) or [Field and Harrison "
"1988](B9780080571157500285.xhtml#bb0400)."
msgstr ""

#: in/chapter9.md:2221
msgid "## 9.8 Exercises"
msgstr "## 9.8 Упражнения"

#: in/chapter9.md:2229
msgid ""
"**Exercise  9.3 [d]** In this chapter we presented a compiler for "
"`simplify`.\n"
"It is not too much harder to extend this compiler to handle the full power "
"of `pat-match`.\n"
"Instead of looking at expressions only, allow trees with variables in any "
"position.\n"
"Extend and generalize the definitions of `compile-rule` and `compile-rule-"
"set` so that they can be used as a general tool for any application program "
"that uses `pat-match` and/or `rule-based-translator`.\n"
"Make sure that the compiler is data-driven, so that the programmer who adds "
"a new kind of pattern to `pat-match` can also instruct the compiler how to "
"deal with it.\n"
"One hard part will be accounting for segment variables.\n"
"It is worth spending a considerable amount of effort at compile time to make "
"this efficient at run time."
msgstr ""
"**Упражнение 9.3 [d]** В этой главе мы представили компилятор для "
"`simplify`.\n"
"Не намного сложнее расширить этот компилятор, чтобы он мог использовать все "
"возможности `pat-match`.\n"
"Вместо того, чтобы смотреть только на выражения, разрешите деревья с "
"переменными в любой позиции.\n"
"Расширить и обобщить определения compile-rule и compile-rule-set, чтобы их "
"можно было использовать в качестве общего инструмента для любой прикладной "
"программы, которая использует pat-match и/или rule-based-translator. .\n"
"Убедитесь, что компилятор управляется данными, чтобы программист, "
"добавляющий новый тип шаблона в `pat-match`, также мог указать компилятору, "
"как с ним работать.\n"
"Одна сложная часть будет учитывать сегментные переменные.\n"
"Стоит потратить немало усилий во время компиляции, чтобы сделать это "
"эффективным во время выполнения."

#: in/chapter9.md:2233
msgid ""
"**Exercise  9.4 [m]** Define the time to compute (fib n) without memoization "
"as *Tn*.\n"
"Write a formula to express *Tn*.\n"
"Given that *T*25  &asymp;  1.1  seconds, predict *T*100."
msgstr ""
"**Упражнение 9.4 [m]** Определите время вычисления (fib n) без мемоизации "
"как *Tn*.\n"
"Напишите формулу для выражения *Tn*.\n"
"Учитывая, что *T*25 & asymp; 1,1 секунды, предсказать *T*100."

#: in/chapter9.md:2239
msgid ""
"**Exercise  9.5 [m]** Consider a version of the game of Nim played as "
"follows: there is a pile of *n* tokens.\n"
"Two players alternate removing tokens from the pile; on each turn a player "
"must take either one, two, or three tokens.\n"
"Whoever takes the last token wins.\n"
"Write a program that, given *n*, returns the number of tokens to take to "
"insure a win, if possible.\n"
"Analyze the execution times for your program, with and without memoization."
msgstr ""
"**Упражнение 9.5 [m]** Рассмотрим версию игры Ним, в которую играют "
"следующим образом: есть стопка из *n* жетонов.\n"
"Два игрока по очереди убирают жетоны из стопки; на каждом ходу игрок должен "
"взять один, два или три жетона.\n"
"Выигрывает тот, кто берет последний жетон.\n"
"Напишите программу, которая при заданном *n* возвращает количество жетонов, "
"которые нужно взять для обеспечения выигрыша, если это возможно.\n"
"Анализируйте время выполнения вашей программы с мемоизацией и без нее."

#: in/chapter9.md:2245
msgid ""
"**Exercise  9.6 [m]** A more complicated Nim-like game is known as Grundy's "
"game.\n"
"The game starts with a single pile of *n* tokens.\n"
"Each player must choose one pile and split it into two uneven piles.\n"
"The first player to be unable to move loses.\n"
"Write a program to play Grundy's game, and see how memoization helps."
msgstr ""
"**Упражнение 9.6 [m]** Более сложная игра в стиле Нима известна как игра "
"Гранди.\n"
"Игра начинается с одной стопки из * n * жетонов.\n"
"Каждый игрок должен выбрать одну стопку и разделить ее на две неравные "
"стопки.\n"
"Первый игрок, который не может двигаться, проигрывает.\n"
"Напишите программу, чтобы играть в игру Гранди, и посмотрите, как помогает "
"запоминание."

#: in/chapter9.md:2250
msgid ""
"**Exercise  9.7 [h]** This exercise describes a more challenging one-person "
"game.\n"
"In this game the player rolls a six-sided die eight times.\n"
"The player forms four two-digit decimal numbers such that the total of the "
"four numbers is as high as possible, but not higher than 170.\n"
"A total of 171 or more gets scored as zero."
msgstr ""
"**Упражнение 9.7 [h]** Это упражнение описывает более сложную игру одного "
"человека.\n"
"В этой игре игрок восемь раз бросает шестигранный кубик.\n"
"Игрок формирует четыре двузначных десятичных числа так, чтобы сумма четырех "
"чисел была как можно больше, но не превышала 170.\n"
"Всего 171 или более баллов оцениваются как ноль."

#: in/chapter9.md:2252
msgid ""
"The game would be deterministic and completely boring if not for the "
"requirement that after each roll the player must immediately place the digit "
"in either the ones or tens column of one of the four numbers."
msgstr ""
"Игра была бы детерминированной и совершенно скучной, если бы не требование, "
"согласно которому после каждого броска игрок должен немедленно помещать "
"цифру в столбец единиц или десятков одного из четырех чисел."

#: in/chapter9.md:2257
msgid ""
"Here is a sample game.\n"
"The player first rolls a 3 and places it in the ones column of the first "
"number, then rolls a 4 and places it in the tens column, and so on.\n"
"On the last roll the player rolls a 6 and ends up with a total of 180.\n"
"Since this is over the limit of 170, the player's final score is 0."
msgstr ""
"Вот образец игры.\n"
"Игрок сначала выбрасывает 3 и помещает его в столбец единиц первого числа, "
"затем бросает 4 и помещает его в столбец десятков и так далее.\n"
"В последнем броске игрок выбрасывает 6 и в итоге получает 180.\n"
"Поскольку это значение превышает предел 170, окончательный счет игрока равен "
"0."

#: in/chapter9.md:2266
msgid ""
"| []()     |    |    |    |    |    |    |     |    |\n"
"|----------|----|----|----|----|----|----|-----|----|\n"
"| roll     | 3  | 4  | 6  | 6  | 3  | 5  | 3   | 6  |\n"
"| lst num. | -3 | 43 | 43 | 43 | 43 | 43 | 43  | 43 |\n"
"| 2nd num. | -  | -  | -6 | -6 | 36 | 36 | 36  | 36 |\n"
"| 3rd num. | -  | -  | -  | -6 | -6 | -6 | 36  | 36 |\n"
"| 4th num. | -  | -  | -  | -  | -  | -5 | -5  | 65 |\n"
"| total    | 03 | 43 | 49 | 55 | 85 | 90 | 120 | 0  |"
msgstr ""

#: in/chapter9.md:2269
msgid ""
"Write a function that allows you to play a game or a series of games.\n"
"The function should take as argument a function representing a strategy for "
"playing the game."
msgstr ""
"Напишите функцию, которая позволит вам играть в игру или серию игр.\n"
"Функция должна принимать в качестве аргумента функцию, представляющую "
"стратегию игры."

#: in/chapter9.md:2272
msgid ""
"**Exercise  9.8 [h]** Define a good strategy for the dice game described "
"above.\n"
"(Hint: my strategy scores an average of 143.7.)"
msgstr ""
"**Упражнение 9.8 [h]** Определите хорошую стратегию игры в кости, описанной "
"выше.\n"
"(Подсказка: моя стратегия получила в среднем 143,7 балла.)"

#: in/chapter9.md:2276
msgid ""
"**Exercise  9.9 [m]** One problem with playing games involving random "
"numbers is the possibility that a player can cheat by figuring out what "
"`random` is going to do next.\n"
"Read the definition of the function `random` and describe how a player could "
"cheat.\n"
"Then describe a countermeasure."
msgstr ""
"**Упражнение 9.9 [m]** Одной из проблем, возникающих при игре в игры со "
"случайными числами, является вероятность того, что игрок может обмануть, "
"выяснив, что `random` будет делать дальше.\n"
"Прочтите определение функции random и опишите, как игрок может обмануть.\n"
"Затем опишите контрмеру."

#: in/chapter9.md:2280
msgid ""
"**Exercise  9.10 [m]** On [Page 292](B9780080571157500091.xhtml#p292) we saw "
"the use of the read-time conditionals, #+and #-, where #+is the read-time "
"equivalent of when, and #- is the read-time equivalent of unless.\n"
"Unfortunately, there is no read-time equivalent of case.\n"
"Implement one."
msgstr ""
"**Упражнение 9.10 [м]** На [стр. 292] (B9780080571157500091.xhtml#p292) мы "
"видели использование условных выражений времени чтения, #+ и #-, где #+ - "
"время чтения, эквивалентное when, и #- это время чтения, эквивалентное "
"unless.\n"
"К сожалению, не существует времени чтения эквивалентное case.\n"
"Реализуйте один."

#: in/chapter9.md:2283
msgid ""
"**Exercise  9.11 [h]** Write a compiler for ELIZA that compiles all the "
"rules at once into a single function.\n"
"How much more efficient is the compiled version?"
msgstr ""
"**Упражнение 9.11 [h]** Напишите компилятор для ELIZA, который объединяет "
"все правила сразу в одну функцию.\n"
"Насколько эффективнее скомпилированная версия?"

#: in/chapter9.md:2287
msgid ""
"**Exercise  9.12 [d]** Write some rules to simplify Lisp code.\n"
"Some of the algebraic simplification rules will still be valid, but new ones "
"will be needed to simplify nonalgebraic functions and special forms.\n"
"(Since `nil` is a valid expression in this domain, you will have to deal "
"with the semipredicate problem.) Here are some example rules (using prefix "
"notation):"
msgstr ""
"**Упражнение 9.12 [d]** Напишите несколько правил для упрощения кода Lisp.\n"
"Некоторые из правил алгебраического упрощения будут по-прежнему действовать, "
"но потребуются новые правила для упрощения неалгебраических функций и "
"специальных форм.\n"
"(Поскольку `nil` является допустимым выражением в этом домене, вам придется "
"иметь дело с проблемой полупредиката.) Вот несколько примеров правил (с "
"использованием префиксной записи):"

#: in/chapter9.md:2298
msgid ""
"```lisp\n"
"(= (+ x 0) x)\n"
"(= 'nil nil) (\n"
"(= (car (cons x y)) x)\n"
"(= (cdr (cons x y)) y)\n"
"(= (if t x y) x)\n"
"(= (if nil x y) y)\n"
"(= (length nil) 0)\n"
"(= (expt y (?if x numberp)) (expt (expt y (/ x 2)) 2))\n"
"```"
msgstr ""

#: in/chapter9.md:2302
msgid ""
"**Exercise  9.13 [m]** Consider the following two versions of the sieve of "
"Eratosthenes algorithm.\n"
"The second explicitly binds a local variable.\n"
"Is this worth it?"
msgstr ""
"**Упражнение 9.13 [m]** Рассмотрим следующие две версии алгоритма решета "
"Эратосфена.\n"
"Второй явно связывает локальную переменную.\n"
"Это того стоит?"

#: in/chapter9.md:2314
msgid ""
"```lisp\n"
"(defun sieve (pipe)\n"
"    (make-pipe (head pipe)\n"
"                          (filter #'(lambda (x)(/= (mod x (headpipe)) 0))\n"
"                                        (sieve (tail pipe)))))\n"
"(defun sieve (pipe)\n"
"    (let ((first-num (head pipe)))\n"
"        (make-pipe first-num\n"
"                              (filter #'(lambda (x) (/= (mod x first-num) "
"0))\n"
"                                            (sieve (tail pipe))))))\n"
"```"
msgstr ""

#: in/chapter9.md:2316
msgid "## 9.9 Answers"
msgstr "## 9.9 Ответы"

#: in/chapter9.md:2320
msgid ""
"**Answer 9.4** Let *Fn* denote (`fib n`).\n"
"Then the time to compute *Fn*, *Tn*, is a small constant for *n*  &le;  1, "
"and is roughly equal to *Tn-1* plus *Tn-2* for larger *n*.\n"
"Thus, *Tn* is roughly proportional to *Fn*:"
msgstr ""
"**Ответ 9.4** Пусть *Fn* обозначает (`fib n`).\n"
"Тогда время для вычисления *Fn*, *Tn* будет небольшой константой для *n* "
"&le; 1 и примерно равен *Tn-1* плюс *Tn-2* для большего *n*.\n"
"Таким образом, *Tn* примерно пропорционально *Fn*:"

#: in/chapter9.md:2322
msgid "Tn=FnTiFi"
msgstr ""

#: in/chapter9.md:2324
msgid "![si1_e](images/chapter9/si1_e.gif)"
msgstr ""

#: in/chapter9.md:2327
msgid ""
"We could use some small value of *Ti* to calculate *T*100 if we knew "
"*F*100.\n"
"Fortunately, we can use the equation:"
msgstr ""
"Мы могли бы использовать небольшое значение *Ti* для вычисления *T*100, если "
"бы знали *F*100.\n"
"К счастью, мы можем использовать уравнение:"

#: in/chapter9.md:2329
msgid "Fn&alpha;&Phi;n"
msgstr ""

#: in/chapter9.md:2331
msgid "![si2_e](images/chapter9/si2_e.gif)"
msgstr ""

#: in/chapter9.md:2340
msgid ""
"Where &phi;  =  (1  +  &radic;(5))/2  &asymp;  1.618.\n"
"This equation was derived by de Moivre in 1718 (see Knuth, Donald E.\n"
"*Fundamental Algorithms*, pp.\n"
"78-83), but the number *&phi;* has a long interesting history.\n"
"Euclid called it the \"extreme and mean ratio,\" because the ratio of *A* to "
"*B* is the ratio of *A*  +  *B* to *A* if *A*/*B* is *&phi;*.\n"
"In the Renaissance it was called the \"divine proportion,\" and in the last "
"century it has been known as the \"golden ratio,\" because a rectangle with "
"sides in this ratio can be divided into two smaller rectangles that both "
"have the same ratio between sides.\n"
"It is said to be a pleasing proportion when employed in paintings and "
"architecture.\n"
"Putting history aside, given *T*25  &asymp;  1.1  *sec* we can now calculate:"
msgstr ""
"Где &phi; = (1 + &radic;(5))/2 &asymp; 1.618.\n"
"Это уравнение было выведено де Муавром в 1718 году (см. Knuth, Donald E.\n"
"*Фундаментальные алгоритмы*, стр.\n"
"78-83), но число *&phi;* имеет долгую интересную историю.\n"
"Евклид назвал это \"крайним и средним соотношением\", потому что отношение "
"*A* к *B* - это отношение *A* + *B* к *A*, если *A*/*B* равно *&phi;* .\n"
"В эпоху Возрождения это называлось \"божественной пропорцией\", а в прошлом "
"веке оно было известно как \"золотое сечение\", потому что прямоугольник со "
"сторонами в этом соотношении можно разделить на два меньших прямоугольника, "
"которые имеют одинаковое соотношение между стороны.\n"
"Говорят, что это приятная пропорция, когда используется в живописи и "
"архитектуре.\n"
"Отложив историю в сторону, учитывая *T*25 &asymp; 1.1 *сек* теперь мы можем "
"вычислить:"

#: in/chapter9.md:2342
msgid "T100&asymp;&Phi;1001.1sec&Phi;25&asymp;5x1015sec"
msgstr ""

#: in/chapter9.md:2344
msgid "![si3_e](images/chapter9/si3_e.gif)"
msgstr ""

#: in/chapter9.md:2348
msgid ""
"which is roughly 150 million years.\n"
"We can also see that the timing data in the table fits the equation fairly "
"well.\n"
"However, we would expect some additional time for larger numbers because it "
"takes longer to add and garbage collect bignums than fixnums."
msgstr ""
"что примерно 150 миллионов лет.\n"
"Мы также можем видеть, что временные данные в таблице довольно хорошо "
"соответствуют уравнению.\n"
"Однако можно ожидать дополнительного времени для больших чисел, потому что "
"для добавления и сбора мусора требуется больше времени, чем для "
"фиксированных чисел."

#: in/chapter9.md:2357
msgid ""
"**Answer 9.5** First we'll define the notion of a forced win.\n"
"This occurs either when there are three or fewer tokens left or when you can "
"make a move that gives your opponent a possible loss.\n"
"A possible loss is any position that is not a forced win.\n"
"If you play perfectly, then a possible loss for your opponent will in fact "
"be a win for you, since there are no ties.\n"
"See the functions `win` and `loss` below.\n"
"Now your strategy should be to win the game outright if there are three or "
"fewer tokens, or otherwise to choose the largest number resulting in a "
"possible loss for your opponent.\n"
"If there is no such move available to you, take only one, on the grounds "
"that your opponent is more likely to make a mistake with a larger pile to "
"contend with.\n"
"This strategy is embodied in the function `nim` below."
msgstr ""
"**Ответ 9.5** Сначала определим понятие принудительной победы.\n"
"Это происходит, когда остается три или меньше жетонов, или когда вы можете "
"сделать ход, который принесет вашему противнику возможную потерю.\n"
"Возможная потеря - это любая позиция, не являющаяся принудительным "
"выигрышем.\n"
"Если вы играете идеально, то возможное поражение оппонента фактически будет "
"для вас победой, так как ничей нет.\n"
"См. Функции `win` и `loss` ниже.\n"
"Теперь ваша стратегия должна заключаться в том, чтобы выиграть игру сразу, "
"если есть три или меньше жетонов, или иным образом выбрать наибольшее число, "
"которое приведет к возможному проигрышу для вашего оппонента.\n"
"Если вам недоступен такой ход, возьмите только один, на том основании, что "
"ваш противник с большей вероятностью допустит ошибку с большей стопкой, с "
"которой нужно бороться.\n"
"Эта стратегия воплощена в функции `nim` ниже."

#: in/chapter9.md:2375
msgid ""
"```lisp\n"
"(defun win (n)\n"
"    \"Is a pile of n tokens a win for the player to move?\"\n"
"    (or (<= n 3)\n"
"            (loss (- n 1))\n"
"            (loss (- n 2))\n"
"            (loss (- n 3))))\n"
"(defun loss (n) (not (win n)))\n"
"(defun nim (n)\n"
"    \"Play Nim: a player must take 1-3; taking the last one wins.\n"
"    (con ((<= n 3) n); an immediate win\n"
"            ((loss (- n 3)) 3); an eventual win\n"
"            ((loss (- n 2)) 2); an eventual win\n"
"            ((loss (- n 1)) 1); an eventual win\n"
"            (t 1))); a loss; the 1 is arbitrary\n"
"(memoize 'loss)\n"
"```"
msgstr ""

#: in/chapter9.md:2380
msgid ""
"From this we are able to produce a table of execution times (in seconds), "
"with and without memoization.\n"
"Only `loss` need be memoized.\n"
"(Why?) Do you have a good explanation of the times for the unmemoized "
"version?\n"
"What happens if you change the order of the loss clauses in `win` and/or "
"`nim?`"
msgstr ""
"Из этого мы можем составить таблицу времени выполнения (в секундах) с "
"мемоизацией и без нее.\n"
"Запоминать нужно только `loss`.\n"
"(Почему?) У вас есть хорошее объяснение времени для немомизированной "
"версии?\n"
"Что произойдет, если вы измените порядок предложений loss(потерь/проигрышей) "
"в win и/или nim?"

#: in/chapter9.md:2385
msgid ""
"**Answer 9.6** We start by defining a function, `moves`, which generates all "
"possible moves from a given position.\n"
"This is done by considering each pile of *n* tokens within a set of piles "
"*s*.\n"
"Any pile bigger than two tokens can be split.\n"
"We take care to elimina te duplicate positions by sorting each set of piles, "
"and then removing the duplicates."
msgstr ""

#: in/chapter9.md:2403
msgid ""
"```lisp\n"
"(defun moves (s)\n"
"    \"Return a list of all possible moves in Grundy's game\"\n"
"    ;; S is a list of integers giving the sizes of the piles\n"
"    (remove-duplicates\n"
"        (loop for n in s append (make-moves n s))\n"
"        :test #'equal))\n"
"(defun make-moves (n s)\n"
"    (when (>  =  n 2)\n"
"        (let ((s/n (remove n s :count 1)))\n"
"            (loop for i from 1 to (- (ceiling n 2) 1)\n"
"                        collect (sort* (list* i (-  ni) s/n)\n"
"                                                      #'>>))))\n"
"(defun sort* (seq pred &key key)\n"
"  \"Sort without altering the sequence\"\n"
"  (sort (copy-seq seq) pred :key key))\n"
"```"
msgstr ""

#: in/chapter9.md:2406
msgid ""
"This time a loss is defined as a position from which you have no moves, or "
"one from which your opponent can force a win no matter what you do.\n"
"A winning position is one that is not a loss, and the strategy is to pick a "
"move that is a loss for your opponent, or if you can't, just to play "
"anything (here we arbitrarily pick the first move generated)."
msgstr ""

#: in/chapter9.md:2418
msgid ""
"```lisp\n"
"(defun loss (s)\n"
"    (let ((choices (moves s)))\n"
"        (or (null choices)\n"
"                (every #'win choices))))\n"
"(defun win (s) (not (loss s)))\n"
"(defun grundy (s)\n"
"    (let ((choices (moves s)))\n"
"        (or (find-if #'loss choices)\n"
"                (first choices))))\n"
"```"
msgstr ""

#: in/chapter9.md:2421
msgid ""
"**Answer 9.7** The answer assumes that a strategy function takes four "
"arguments: the current die roll, the score so far, the number of remaining "
"positions in the tens column, and the number of remaining positions in the "
"ones column.\n"
"The strategy function should return 1 or 10."
msgstr ""

#: in/chapter9.md:2425
msgid ""
"```lisp\n"
"(defun play-games (&optional (n-games 10) (player 'make-move))\n"
"```"
msgstr ""

#: in/chapter9.md:2428
msgid ""
"`    \"A driver for a simple dice game.\n"
"In this game the player`"
msgstr ""

#: in/chapter9.md:2431
msgid ""
"`    rolls a six-sided die eight times.\n"
"The player forms four`"
msgstr ""

#: in/chapter9.md:2436
msgid ""
"```lisp\n"
"    two-digit decimal numbers such that the total of the four\n"
"    numbers is as high as possible, but not higher than 170.\n"
"```"
msgstr ""

#: in/chapter9.md:2439
msgid ""
"`    A total of 171 or more gets scored as zero.\n"
"After each die`"
msgstr ""

#: in/chapter9.md:2457
msgid ""
"```lisp\n"
"    is rolled, the player must decide where to put it.\n"
"    This function returns the player's average score.\"\n"
"    (/ (loop repeat n-games summing (play-game player 0 4 4))\n"
"          (float n-games)))\n"
"(defun play-game (player &optional (total 0) (tens 4) (ones 4))\n"
"    (cond ((or (> total 170) (< tens 0) (< ones 0)) 0)\n"
"                ((and (= tens 0) (= ones 0)) total)\n"
"                (t (let ((die (roll-die)))\n"
"                        (case (funcall player die total tens ones)\n"
"                          (1 (play-game player (+ total die)\n"
"                                                      tens (- ones 1)))\n"
"                          (10 (play-game player (+ total (* 10 die))\n"
"                                                      (- tens 1) ones))\n"
"                          (t 0))))))\n"
"(defun roll-die () (+  1 (random 6)))\n"
"```"
msgstr ""

#: in/chapter9.md:2460
msgid ""
"So, the expression `(play-games 5 #'make-move)` would play five games with a "
"strategy called `make-move`.\n"
"This returns only the average score of the games; if you want to see each "
"move as it is played, use this function:"
msgstr ""

#: in/chapter9.md:2471
msgid ""
"```lisp\n"
"(defun show (player)\n"
"    \"Return a player that prints out each move it makes.\"\n"
"    #'(lambda (die total tens ones)\n"
"            (when (= total 0) (fresh-line))\n"
"            (let ((move (funcall player die total tens ones)))\n"
"                (incf total (* die move))\n"
"                (format t \"~2d-> ~  3d |  ~  @[*~]\" (* move die) total (> "
"total 170))\n"
"                  move)))\n"
"```"
msgstr ""

#: in/chapter9.md:2473
msgid "and call `(play-games 5 (show #'make-moves))`."
msgstr ""

#: in/chapter9.md:2476
msgid ""
"**Answer 9.9** The expression `(random 6 (make-random-state))` returns the "
"next number that `roll-die` will return.\n"
"To guard against this, we can make `roll-die` use a random state that is not "
"accessible through a global variable:"
msgstr ""

#: in/chapter9.md:2481
msgid ""
"```lisp\n"
"(let ((state (make-random-state t)))\n"
"    (defun roll-die () (+  1 (random 6 state))))\n"
"```"
msgstr ""

#: in/chapter9.md:2484
msgid ""
"**Answer 9.10** Because this has to do with read-time evaluation, it must be "
"implemented as a macro or read macro.\n"
"Here's one way to do it:"
msgstr ""

#: in/chapter9.md:2492
msgid ""
"```lisp\n"
"  (defmacro read-time-case (first-case &rest other-cases)\n"
"    \"Do the first case, where normally cases are\n"
"    specified with #+ or possibly #- marks.\"\n"
"    (declare (ignore other-cases))\n"
"    first-case)\n"
"```"
msgstr ""

#: in/chapter9.md:2494
msgid "A fanciful example, resurrecting a number of obsolete Lisps, follows:"
msgstr ""

#: in/chapter9.md:2499
msgid ""
"```lisp\n"
"(defun get-fast-time ()\n"
"    (read-time-case\n"
"```"
msgstr ""

#: in/chapter9.md:2511
msgid ""
"| []()             |                              |\n"
"|------------------|------------------------------|\n"
"| `#+Explorer`     | `(time :microsecond-time)`   |\n"
"| `#+Franz`        | `(sys:time)`                 |\n"
"| `#+(or PSL UCI)` | `(time)`                     |\n"
"| `#+YKT`          | `(currenttime)`              |\n"
"| `#+MTS`          | `(status 39)`                |\n"
"| `#+Interlisp`    | `(clock 1)`                  |\n"
"| `#+Lispl.5`      | `(tempus-fugit)`             |\n"
"| `;; otherwise`   |                              |\n"
"|                  | `(get-internal-real-time)))` |"
msgstr ""

#: in/chapter9.md:2516
msgid ""
"**Answer 9.13** Yes.\n"
"Computing (`head pipe`) may be a trivial computation, but it will be done "
"many times.\n"
"Binding the local variable makes sure that it is only done once.\n"
"In general, things that you expect to be done multiple times should be moved "
"out of delayed functions, while things that may not be done at all should be "
"moved inside a delay."
msgstr ""

#: in/chapter9.md:2518
msgid "----------------------"
msgstr ""

#: in/chapter9.md:2521
msgid ""
"[1](#xfn0010) One could say that the FORTRAN compiler was \"broken.\" This "
"underscores the problem of defining the efficiency of a language-do we judge "
"by the most popular compiler, by the best compiler available, or by the best "
"compiler imaginable?\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter9.md:2525
msgid ""
"[2](#xfn0015) In KCL, the symbol `lambda-closure` is used, and in Allegro, "
"it is `excl:.\n"
"lexical-closure`\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter9.md:2528
msgid ""
"[3](#xfn0020) The terms *metering* and *monitoring* are sometimes used "
"instead of profiling.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
