# Глава 20
## Унифицированные(Объединенные) Грамматики

Пролог был изобретен, потому что Ален Колмерауэр хотел формализм для описания грамматики французского языка.
Его интуиция заключалась в том, что комбинация предложений Хорна и унификации привела к созданию языка, который был достаточно мощным, чтобы выразить виды ограничений, которые проявляются в естественных языках, но не столь мощным, как, например, полное исчисление предикатов.
Этот недостаток мощности важен, потому что он обеспечивает эффективную реализацию Prolog и, следовательно, программ анализа языка, построенных на нем.

Конечно, Prolog эволюционировал и теперь используется во многих приложениях, помимо естественного языка, но основная интуиция Колмерауэра остается хорошей.
В этой главе показано, как рассматривать грамматику как набор предложений логического программирования.
Предложения(clauses) определяют, что является законным утверждением(заключением), а что нет, без какой-либо явной ссылки на процесс синтаксического анализа или генерации.
Удивительно то, что предложения могут быть определены таким образом, чтобы получить очень эффективный синтаксический анализатор.
Более того, одна и та же грамматика может использоваться как для синтаксического анализа, так и для генерации (по крайней мере, в некоторых случаях).

## 20.1 Синтаксический анализ(parsing) как умозаключение(дедукция).

Вот как мы могли бы выразить грамматическое правило "Утверждение(sentence) может состоять из фразы существительного(noun phrase), за которой следует глагольная фраза(verb phrase)" на Прологе:

```lisp
(<- (S ?s)
```

      `(NP ?np)`

      `(VP ?vp)`

      `(concat ?np ?vp ?s))`

Переменные представляют собой строки слов.
Как обычно, они будут реализованы в виде списков символов.
Правило гласит, что данная строка слов `?s` является утверждением(sentence), если есть строка, которая представляет собой фразу существительного и другая явлюящаяся глагольной фразой, и если они могут быть объединены в форму `?s`.
С логической точки зрения это нормально, и он будет работать как программа для генерации случайных утверждений.
Однако это очень неэффективная программа для разбора утверждений.
Она рассмотрит все возможные фразы существительных и глагольные фразы, независимо от введенных слов.
Только когда она достигнет цели concat (определенной на [стр. 411](B9780080571157500121.xhtml#p411)), она проверит, можно ли объединить две составляющие вместе, чтобы составить входную строку.
Таким образом, лучший порядок вычисления для синтаксического анализа:

```lisp
(<- (S ?s)
```

      `(concat ?np ?vp ?s)`

      `(NP ?np)`

      `(VP ?vp))`

В первой версии были угадываемые строки `NP` и `VP`, которые проверялись с помощью `concat`.
В большинстве грамматик будет очень большое или бесконечное количество `NP` и `VP`.
В этой второй версии есть угадываемые строки `concat`, которые должны проверяться `NP` и `VP`.
Если в утверждении *n* слов, то `concat` может сделать только *n* + 1 предположений, что является значительным улучшением.
Однако было бы еще лучше, если бы мы могли фактически заставить `concat` и `NP` работать вместе, чтобы сделать более ограниченное предположение, которое затем будет проверено `VP`.

Мы уже сталкивались с подобными проблемами.
В Лиспе ответ - возвращает несколько значений.
`NP` - это функция, которая принимает строку в качестве входных данных и возвращает два значения: индикатор успеха или неудачи и оставшуюся строку слов, которые еще не были проанализированы.
Когда первое значение указывает на успех, тогда будет вызываться `VP` с оставшейся строкой в качестве ввода.
В Прологе возвращаемые значения - это просто дополнительные аргументы.
Таким образом, у каждого предиката будет два параметра: входная строка и остаточная строка.
Следуя обычному соглашению Пролога, выходной параметр идет после входного.
В этом подходе не требуются вызовы concat, не делаются дикие предположения, а функция обратного отслеживания Prolog заботится о необходимых предположениях:

```lisp
(<- (S ?s0 ?s2)
```

              `(NP ?s0 ?sl)`

              `(VP ?sl ?s2))`

Это правило можно прочитать как "Строка от `*s*0` до `*s*2` является предложением, если существует `*s*1`, такое, что строка от `s0` до `*s*1`- это существительное, а строка от `*s*1` до `*s*2` - глагольная фраза."

Примером запроса будет `(?- (S (The boy ate the apple) ())).` С подходящими определениями `NP` и `VP` это будет успешным, со следующими привязками, удерживаемыми внутри `S`:

```lisp
?s0 = (The boy ate the apple)
?sl =                 (ate the apple)
?s2 =                                           ()
```

Другой способ чтения цели `(NP ?s0 ?sl)`, например, выглядит следующим образом: "`IS` the list `?s0` minus the list `?sl` a noun phrase?" В этом случае `?s0` минус `?sl` - это список `(The boy)`.
Комбинация двух аргументов, списка ввода и списка вывода, часто называется *списком различий*, чтобы подчеркнуть эту интерпретацию.
В более общем смысле комбинация входного параметра и выходного параметра называется *accumulator*(накопитель). Аккумуляторы, особенно списки различий, являются важным методом на протяжении всего логического программирования, а также используются в функциональном программировании, как мы видели на [стр. 63](B9780080571157500030.xhtml#p63).

В нашем правиле для `S` конкатенация списков различий была неявной.
При желании мы могли бы определить версию concat для списков различий и вызвать ее явно:

```lisp
(<- (S ?s-in ?s-rem)
```

              `(NP ?np-in ?np-rem)`

              `(VP ?vp-in ?vp-rem)`

              `(concat ?np-in ?np-rem ?vp-in ?vp-rem ?s-in ?s-rem))`

```lisp
(<- (concat ?a ?b ?b ?c ?a ?c))
```

Поскольку эта версия concat имеет другую арность, чем старая версия, они могут безопасно сосуществовать.
В нем указано уравнение списка различий *(a - b) + (b - c) = (a - c)*.

В предыдущей главе мы заявили, что контекстно-свободная грамматика с фразовой структурой неудобна для выражения таких вещей, как согласие между подлежащим и сказуемым в утверждении.
С помощью формализма грамматики, основанного на предложениях Хорна, которую мы здесь развиваем, мы можем добавить аргумент к предикатам NP и VP, чтобы представить согласие.
На английском правило соглашения не имеет большого значения.
Для всех глаголов, кроме *be,*, разница проявляется только в третьем лице единственного числа настоящего времени:

|               | Singular |        | Plural |       |
|---------------|----------|--------|--------|-------|
| first person  | I        | sleep  | we     | sleep |
| second person | you      | sleep  | you    | sleep |
| third person  | he/she   | sleeps | they   | sleep |

Таким образом, аргумент согласия будет принимать одно из двух значений `3sg` или `"3sg` для обозначения единственного числа от третьего лица или не от третьего лица единственного числа.
Мы могли бы написать:

```lisp
(<- (S ?s0 ?s2)
```

              `(NP ?agr ?s0 ?sl)`

              `(VP ?agr ?sl ?s2))`

```lisp
(<- (NP 3sg (he . ?s) ?s))
```

`(<- (NP`"`3sg (they . ?s) ?s))`

```lisp
(<- (VP 3sg (sleeps . ?s) ?s))
```

`(<- (VP`"`3sg (sleep . ?s) ?s))`

Эта грамматика разбирает только правильные предложения:

```lisp
> (?- (S (He sleeps) ()))
Yes.
> (?- (S (He sleep) ()))
No.
```

Давайте расширим грамматику, чтобы разрешить как общие существительные(common nouns), так и местоимения(pronouns):

```lisp
(<- (NP ?agr ?s0 ?s2)
```

              `(Det ?agr ?s0 ?sl)`

              `(N ?agr ?sl ?s2))`

```lisp
(<- (Det ?any (the . ?s) ?s))
(<- (N 3sg (boy . ?s) ?s))
(<- (N 3sg (girl . ?s) ?s))
```

Те же правила грамматики можно использовать как для создания предложений, так и для синтаксического анализа.
Вот все возможные предложения в этой тривиальной грамматике:

```lisp
> (?- (S ?words ()))
?WORDS = (HE SLEEPS);
?WORDS = (THEY SLEEP);
?WORDS = (THE BOY SLEEPS);
?WORDS = (THE GIRL SLEEPS);
No.
```

Пока все, что у нас есть, - это распознаватель: предикат, который может отделять sentences(утверждения) от неутверждений.
Но мы можем добавить к каждому предикату еще один аргумент, чтобы создать семантику.
В результате получается не просто распознаватель, а настоящий парсер:

```lisp
(<- (S (?pred ?subj) ?s0 ?s2)
```

              `(NP ?agr ?subj ?s0 ?sl)`

                `(VP ?agr ?pred ?sl ?s2))`

```lisp
(<- (NP 3sg (the male) (he . ?s) ?s))
```

`(<- (NP`"`3sg (some objects) (they . ?s) ?s))`

```lisp
(<- (NP ?agr (?det ?n) ?s0 ?s2)
```

                `(Det ?agr ?det ?s0 ?sl)`

                `(N ?agr ?n ?sl ?s2))`

```lisp
(<- (VP 3sg sleep (sleeps . ?s) ?s))
```

`(<- (VP`"`3sg sleep (sleep . ?s) ?s))`

```lisp
(<- (Det ?any the (the . ?s) ?s))
(<- (N 3sg (young male human) (boy . ?s) ?s))
(<- (N 3sg (young female human) (girl . ?s) ?s))
```

Семантические переводы(преобразования) отдельных слов немного капризны.
На самом деле, здесь не слишком важно, переводится ли `boy`(мальчик) как `(young male human)`(молодой человек-мужчина) или просто `boy`(мальчик).
Есть два важных свойства семантического представления.
Во-первых, оно должно быть однозначным.
Представление *оранжевого* плода должно отличаться от *оранжевого* цвета (хотя представление плода вполне может ссылаться(устанавливать отношение) на цвет или наоборот).
Во-вторых, оно должно выражать общие положения или позволять выразить их в другом месте.
Таким образом, либо *sleep* и *sleeps* должны иметь одинаковое или похожее представление, либо должно существовать правило вывода, связывающее их.
Точно так же, если представление *boy*(мальчика) не говорит об этом явно, но должно быть какое-то другое правило, согласно которому мальчик - это мужчина и человек.

Как только семантика отдельных слов определена, семантика категорий более высокого уровня (утверждений и фраз существительных) упрощается.
В этой грамматике семантика утверждения - это применение сказуемого (глагольной фразы) к подлежащему (фразе существительного).
Семантика составной фразы существительного - это применение определителя(determiner) к существительному.

Эта грамматика возвращает семантическую интерпретацию, но не строит синтаксическое дерево.
Синтаксическая структура подразумевается в последовательности целей: `S` вызывает `NP` и `VP`, а `NP` может вызывать `Det` и `N`.
Если мы хотим сделать это явным, мы можем предоставить еще один аргумент для каждого нетерминала:

```lisp
(<- (S (?pred ?subj) (s ?np ?vp) ?s0 ?s2)
```

              `(NP ?agr ?subj ?np ?s0 ?sl)`

                `(VP ?agr ?pred ?vp ?sl ?s2))`

```lisp
(<- (NP 3sg (the male) (np he) (he . ?s) ?s))
```

`(<- (NP`"`3sg (some objects) (np they) (they . ?s) ?s))`

```lisp
(<- (NP ?agr (?det ?n) (np ?det-syn ?n-syn)?s0 ?s2)
```

                `(Det ?agr ?det ?det-syn ?s0 ?sl)`

                `(N ?agr ?n ?n-syn ?sl ?s2))`

```lisp
(<- (VP 3sg sleep (vp sleeps)(sleeps . ?s) ?s))
```

`(<- (VP`"`3sg sleep (vp sleep) (sleep . ?s) ?s))`

```lisp
(<- (Det ?any the (det the) (the . ?s) ?s))
(<- (N 3sg (young male human) (n boy) (boy . ?s) ?s))
(<- (N 3sg (young female human) (n girl) (girl . ?s) ?s))
```

Эту грамматику все еще можно использовать для синтаксического анализа или генерации предложений или даже для перечисления всех триплетов синтаксиса / семантики / утверждений:

```lisp
;; Parsing:
> (?- (S ?sem ?syn (He sleeps) ()))
?SEM = (SLEEP (THE MALE))
?SYN = (S (NP HE) (VP SLEEPS)).
;; Generating:
> (?- (S (sleep (the male)) ? ?words ()))
?WORDS = (HE SLEEPS)
;; Enumerating:
> (?- (S ?sem ?syn ?words ()))
?SEM = (SLEEP (THE MALE))
?SYN = (S (NP HE) (VP SLEEPS))
?WORDS = (HE SLEEPS);
?SEM = (SLEEP (SOME OBJECTS))
?SYN = (S (NP THEY) (VP SLEEP))
?WORDS = (THEY SLEEP);
?SEM = (SLEEP (THE (YOUNG MALE HUMAN)))
?SYN = (S (NP (DET THE) (N BOY)) (VP SLEEPS))
?WORDS = (THE BOY SLEEPS);
?SEM = (SLEEP (THE (YOUNG FEMALE HUMAN)))
?SYN = (S (NP (DET THE) (N GIRL)) (VP SLEEPS))
?WORDS = (THE GIRL SLEEPS);
No.
```

## 20.2 Грамматика с определенными предложениями

Теперь у нас есть мощный и эффективный инструмент для разбора утверждений.
Однако он становится очень запутанным инструментом - для каждой цели слишком много аргументов, и трудно сказать, какие аргументы представляют синтаксис, какие представляют семантику, какие представляют строки ввода/вывода и какие представляют другие функции, например согласование(agreement).
Итак, мы сделаем обычный шаг, когда наш голый язык программирования становиться беспорядочным: определяем новый язык.

Edinburgh Prolog распознает утверждения(assertions), называемые правилами *грамматики с определенными предложениями* (DCG).
Термин *определенное предложение* - это просто еще одно название предложений Пролога, поэтому DCG также называют "логическими грамматиками". Их также можно было назвать "грамматиками предложений Хорна" или "грамматиками Пролога".

Правила DCG - это предложения, основным функтором которых является стрелка, обычно записываемая -->.
Они компилируются в обычные предложения Пролога с дополнительными аргументами.
В обычных правилах DCG автоматически добавляются только строковые аргументы.
Но позже мы увидим, как это можно расширить для автоматического добавления других аргументов.

Мы реализуем правила DCG с помощью макроса `rule` и инфиксной стрелки.
Таким образом, нам нужно выражение:

```lisp
(rule (S) --> (NP) (VP))
```

развернуть в предложение:

```lisp
(<- (S ?s0 ?s2)
```

              `(NP ?s0 ?sl)`

              `(VP ?sl ?s2))`

Пока мы находимся в этом, мы также можем дать `rule` возможность работать с разными типами правил, каждое из которых представлено стрелкой разного типа.
Вот макрос `rule`:

```lisp
(defmacro rule (head &optional (arrow ':-) &body body)
  "Expand one of several types of logic rules into pure Prolog."
  ;; This is data-driven, dispatching on the arrow
  (funcall (get arrow 'rule-function) head body))
```

В качестве примера функции правила стрелка: - будет использоваться для представления обычных предложений Пролога.
То есть форма (`rule`*head : - body*) будет эквивалентна (<- *head body).*

```lisp
(setf (get ':- 'rule-function)
      #'(lambda (head body) `(<- ,head .,body)))
```

Прежде чем писать функцию правила для правил DCG, необходимо рассмотреть еще две особенности формализма DCG.
Во-первых, некоторые цели в теле правила могут быть обычными целями Пролога и, следовательно, не требуют дополнительной пары аргументов.
В Edinburgh Prolog(Эдинбургском Прологе) такие цели заключены в фигурные скобки.
Можно было бы написать:

```lisp
s(Sem) --> np(Subj), vp(Pred),
```

                                    `{combi ne(Subj,Pred,Sem)}.`

где идея состоит в том, что `combine` не является грамматической составляющей, а скорее предикатом Пролога, который может производить некоторые вычисления с `Subj` и `Pred`, чтобы прийти к правильной семантике `Sem`.
Мы будем отмечать такой тестовый предикат не скобками, а списком, возглавляемым ключевым словом `:test`, например:

```lisp
(rule (S ?sem) --> (NP ?subj) (VP ?pred)
```

      `(:test (combine ?subj ?pred ?sem)))`

Во-вторых, нам нужен способ введения отдельных слов в правой части, в отличие от категорий слов.
В Прологе скобки используются для представления слова или списка слов с правой стороны:

```lisp
verb --> [sleeps].
```

Мы будем использовать список с ключевым словом `:word:`

```lisp
(rule (NP (the male) 3sg) --> (:word he))
(rule (VP sleeps 3sg) --> (:word sleeps))
```

Следующие предикаты проверяют эти два особых случая.
Обратите внимание, что  cut(обрезка) также допускается как обычная цель.

```lisp
(defun dcg-normal-goal-p (x) (or (starts-with x :test) (eq x '!)))

(defun dcg-word-list-p (x) (starts-with x ':word))
```

Наконец-то мы можем представить функцию правила для правил DCG.
Функция `make-dcg` вставляет переменные для отслеживания строк, которые анализируются.

```lisp
(setf (get '--> 'rule-function) 'make-dcg)

(defun make-dcg (head body)
  (let ((n (count-if (complement #'dcg-normal-goal-p) body)))
    `(<- (,@head ?s0 ,(symbol '?s n))
         .,(make-dcg-body body 0))))

(defun make-dcg-body (body n)
  "Make the body of a Definite Clause Grammar (DCG) clause.
  Add ?string-in and -out variables to each constituent.
  Goals like (:test goal) are ordinary Prolog goals,
  and goals like (:word hello) are literal words to be parsed."
  (if (null body)
      nil
      (let ((goal (first body)))
        (cond
          ((eq goal '!) (cons '! (make-dcg-body (rest body) n)))
          ((dcg-normal-goal-p goal)
           (append (rest goal)
                   (make-dcg-body (rest body) n)))
          ((dcg-word-list-p goal)
           (cons
             `(= ,(symbol '?s n)
                 (,@(rest goal) .,(symbol '?s (+ n 1))))
             (make-dcg-body (rest body) (+ n 1))))
          (t (cons
               (append goal
                       (list (symbol '?s n)
                             (symbol '?s (+ n 1))))
               (make-dcg-body (rest body) (+ n 1))))))))
```

**Упражнение 20.1 [m]** `make-dcg` нарушает одно из основных правил макросов.
Что он делает не так?
Как бы вы это исправить?

## 20.3 Простая грамматика в формате DCG

Вот тривиальная грамматика из [страница 688](chapter20.xhtml#p688) в формате DCG.

```lisp
(rule (S (?pred ?subj)) -->
```

      `(NP ?agr ?subj)`

      `(VP ?agr ?pred))`

```lisp
(rule (NP ?agr (?det ?n)) -->
```

      `(Det ?agr ?det)`

      `(N ?agr ?n))`

```lisp
(rule (NP 3sg (the male))                   --> (:word he))
```

`(rule (NP`"`3sg (some objects))           --> (:word they))`

```lisp
(rule (VP 3sg sleep)                             --> (:word sleeps))
```

`(rule (VP`"`3sg sleep)                             --> (:word sleep))`

```lisp
(rule (Det ?any the)                             --> (:word the))
(rule (N 3sg (young male human))     --> (:word boy))
(rule (N 3sg (young female human)) --> (:word girl))
```

Эта грамматика довольно ограничена, генерирует всего четыре предложения.
Первый способ её расширения - разрешить глаголы с объектами: в дополнение к "The boy sleeps"(Мальчик спит) мы разрешим "The boy meets the girl"(Мальчик встречает девушку). Чтобы избежать создания некрасивых предложений, таких как "* The boy meets"(Мальчик встречает)[1](#fn0015), мы разделим категорию глаголов на две *подкатегории*: переходные глаголы, которые принимают объект, и непереходные глаголы, которые его не имеют.

Переходные глаголы усложняют смысловую трактовку утверждений.
Мы хотели бы, чтобы интерпретация "Terry kisses Jean"(Терри целует Джин) была `(kiss Terry Jean)`.
Интерпретация фразы существительного "Terry"(Терри) - это просто `Terry`, но тогда какой должна быть интерпретация глагольной фразы "kisses Jean"(целует Джин)?
Чтобы соответствовать нашей модели применения предиката, она должна быть чем-то эквивалентной `(lambda (x) (kiss x Jean))`.
Применительно к субъекту мы хотим получить упрощение:

`((lambda (x) (kiss x Jean)) Terry)`=> `(kiss Terry Jean)`

Такое упрощение не выполняется Prolog(ом) автоматически, но мы можем написать для этого предикат.
Мы назовем его `funcall`, потому что он похож на функцию Lisp с таким именем, хотя он обрабатывает только замену аргумента, а не полное вычисление тела.
(Технически это операция лямбда-исчисления, известная как *бета-редукция.)* Предикат `funcall` обычно используется с двумя входными аргументами, функцией и ее аргументом и одним выходным аргументом, в результате чего происходит упрощение(сокращение):

```lisp
(<- (funcall (lambda (?x) ?body) ?x ?body))
```

С этим мы могли бы написать наше правило для утверждений как:

```lisp
(rule (S ?sem) -->
```

      `(NP ?agr ?subj)`

      `(VP ?agr ?pred)`

      `(:test (funcall ?pred ?subj ?sem)))`

Фактически, альтернативой является компиляция вызова функции `funcall`.
Вместо того чтобы семантическое представление `VP` было одним лямбда-выражением, мы можем представить его как два аргумента: входной аргумент, `?subj`, который действует как параметр для выходного аргумента,`?pred`, который принимает место тела лямбда-выражения.
Явно манипулируя параметром и телом, мы можем исключить вызов `funcall`.
Хитрость заключается в том, чтобы сделать параметр и субъект одним и тем же:

```lisp
(rule (S ?pred) -->
```

      `(NP ?agr ?subj)`

      `(VP ?agr ?subj ?pred))`

Один из способов прочтения этого правила: "Чтобы разобрать предложение, разобрать фразу существительного, за которой следует глагольная фраза.
Если у них есть разные признаки согласования, то они не работают, но в противном случае вставьте интерпретацию фразы существительного `?subj` в правильное место в интерпретации глагольной фразы `?pred` и верните `?pred` в качестве финального толкования утверждения".

Следующим шагом будет написание правил для глагольных фраз и глаголов.
Переходные глаголы перечислены под предикатом `Verb/tr`, а непереходные глаголы перечислены как `Verb/intr`.
Семантика времен (прошедшего(past) и настоящего(present)) игнорируется.

```lisp
(rule (VP ?agr ?subj ?pred) -->
```

      `(Verb/tr ?agr ?subj ?pred ?obj)`

      `(NP ?any-agr ?obj))`

```lisp
(rule (VP ?agr ?subj ?pred) -->
```

      `(Verb/intr ?agr ?subj ?pred))`

`(rule (Verb/tr`"`3sg ?x (kiss ?x ?y) ?y) --> (:word kiss))`

```lisp
(rule (Verb/tr 3sg ?x (kiss ?x ?y) ?y) --> (:word kisses))
(rule (Verb/tr ?any ?x (kiss ?x ?y) ?y) --> (:word kissed))
```

`(rule (Verb/intr`"`3sg ?x (sleep ?x)) --> (:word sleep))`

```lisp
(rule (Verb/intr 3sg ?x (sleep ?x)) --> (:word sleeps))
(rule (Verb/intr ?any ?x (sleep ?x)) --> (:word slept))
```

Вот правила для фраз существительных(noun phrases) и существительных(nouns):

```lisp
(rule (NP ?agr ?sem) -->
```

      `(Name ?agr ?sem))`

```lisp
(rule (NP ?agr (?det-sem ?noun-sem)) -->
```

      `(Det ?agr ?det-sem)`

      `(Noun ?agr ?noun-sem))`

```lisp
(rule (Name 3sg Terry) --> (:word Terry))
(rule (Name 3sg Jean) --> (:word Jean))
(rule (Noun 3sg (young male human)) --> (:word boy))
(rule (Noun 3sg (young female human)) --> (:word girl))
```

`(rule (Noun`"`3sg (group (young male human))) --> (:word boys))`

`(rule (Noun`"`3sg (group (young female human))) --> (:word girls))`

```lisp
(rule (Det ?any the) --> (:word the))
(rule (Det 3sg a) --> (:word a))
```

Эта грамматика и лексика генерируют больше утверждений, хотя они все еще довольно ограничены.
Вот некоторые примеры:

```lisp
> (?- (S ?sem (The boys kiss a girl) ()))
?SEM = (KISS (THE (GROUP (YOUNG MALE HUMAN)))
```

                                              `(A (YOUNG FEMALE HUMAN))).`

```lisp
> (?- (S ?sem (The girls kissed the girls) ()))
?SEM = (KISS (THE (GROUP (YOUNG FEMALE HUMAN)))
```

                                              `(THE (GROUP (YOUNG FEMALE HUMAN)))).`

```lisp
> (?- (S ?sem (Terry kissed the girl) ()))
?SEM = (KISS TERRY (THE (YOUNG FEMALE HUMAN))).
> (?- (S ?sem (The girls kisses the boys) ()))
No.
> (?- (S ?sem (Terry kissed a girls) ()))
No.
> (?- (S ?sem (Terry sleeps Jean) ()))
No.
```

Первые три примера анализируются правильно, а последние три правильно отклоняются.
Пытливый читатель может задаться вопросом, что же происходит в интерпретации утверждения вроде "The girls kissed the girls"(Девушки поцеловали девушек). Представляют ли субъект и объект одну и ту же группу девушек или разные группы?
Все целуются со всеми, или поцелуев становится меньше?
Пока мы не определим наше представление более тщательно, определенно сказать невозможно.
В самом деле, кажется, что существует потенциальная проблема в представлении, поскольку предикат `kiss`(целовать) иногда имеет в качестве аргументов индивидов, а иногда и группы.
Более тщательные представления "The girls kissed the girls" включают следующих кандидатов, использующих исчисление предикатов:

> &forall;`x`&forall;`y x` &isin; `girls` &and; `y` &isin; `girls => kiss(x,y)`

> &forall;`x` &forall;`y x` &isin; `girls` &and; `y`&epsilon;`girls` &and; `x`&ne;`y => kiss(x,y)`

> &forall;`x`&exist;`y,z x`&isin; `girls` &and; `y`&isin; `girls` &and; `z`&isin; `girls => kiss(x,y)` &and; `kiss(z,x)`

> &forall;`x`&exist;`y x`&isin; `girls` &and; `y`&isin; `girls => kiss(x,y)`&or; `kiss(y,x)`

Первая из них гласит, что каждая девушка целует каждую другую девушку.
Второй говорит то же самое, за исключением того, что девушке не нужно целоваться.
Третий говорит, что каждую девушку целует и целует хотя бы одна другая девушка, но не обязательно все они, а четвертый говорит, что каждый участвует хотя бы в одном поцелуе.
Ни одна из этих интерпретаций ничего не говорит о том, кто такие "the girls"(девушки).

Ясно, что представления исчисления предикатов менее неоднозначны, чем представления, производимые текущей системой.
С другой стороны, было бы неправильно выбирать одно из представлений произвольно, поскольку в разных контекстах "The girls kissed the girls"(девушки поцеловали девушек) могут означать разные вещи.
Сохранение двусмысленности в сжатой форме полезно, если есть какой-то способ в конечном итоге восстановить правильное значение.

## 20.4 Грамматика DCG с квантификаторами

Проблема в представлении, которое мы использовали, становится более острой, когда мы рассматриваем другие детерминанты, такие как "every"(каждый). Рассмотрим утверждение "Every picture paints a story"(Каждая картина изображает историю). Предыдущий DCG, если дать правильный словарь, даст интерпретацию:

```lisp
(paints (every picture) (a story))
```

Это можно считать двусмысленным между следующими двумя значениями в форме исчисления предикатов:

`&forall; x picture(x)`=> `&exist; y story(y) &and; paint(x,y)`

`&exist; y story (y) &and; &forall; x picture(x)`=> `paint(x,y)`

Первый говорит, что для каждой картины есть история, которую она изображает.
Второй говорит о том, что каждая картина изображает особую историю.
Второе - необычное толкование этого предложения, но для "Every U.S.
citizen has a president"(У каждого U.S. гражданина есть президент", 
вторая интерпретация, пожалуй, предпочтительнее.
В следующем разделе мы увидим, как создавать представления, которые можно преобразовать в любую интерпретацию.
На данный момент это полезное упражнение, чтобы увидеть, как мы можем создать только первое представление выше, интерпретацию, которая обычно является правильной.
Во-первых, нам нужно преобразовать его в Лисп:

```lisp
(all ?x (-> (picture ?x) (exists ?y (and (story ?y) (paint ?x ?y)))))
```

Первый вопрос - как туда попадают формы `all` и `exists`.
Они должны исходить от определителей "every"(каждый) и "a"(а). Кроме того, кажется, что за словом `all` следует стрелка импликации, `->`, а за словом `exists` следует конъюнкция `and`.
Таким образом, у определителей будут преобразования, которые выглядят так: 

```lisp
(rule (Det ?any ?x ?p ?q (the ?x (and ?p ?q)))     --> (:word the))
(rule (Det 3sg ?x ?p ?q (exists ?x (and ?p ?q))) --> (:word a))
(rule (Det 3sg ?x ?p ?q (all ?x (-> ?p ?q)))         --> (:word every))
```

После того, как мы приняли эти преобразования определителей, следует все остальное.
В формулах, представляющих определители, есть две позиции, `?p` и `?q`.
Первая будет заполнена предикатом, представляющим существительное, а последняя - предикатом, который применяется к фразе существительного в целом.
Обратите внимание, что происходит любопытная вещь.
Раньше при переводе в логическую форму руководствовались глаголом утверждения.
С лингвистической точки зрения глагол выражает основное сказуемое, поэтому логический перевод глагола должен быть основной частью преобразования предложения.
В лингвистических терминах мы говорим, что глагол является *главой* предложения.

С новыми преобразованиями для определителей мы фактически переворачиваем весь процесс с ног на голову.
Теперь определитель субъекта(подлежащего) имеет вес всего утверждения.
Интерпретация определителя является функцией двух аргументов; сначала она применяется к существительному, давая функцию одного аргумента, которая, в свою очередь, применяется к интерпретации глагольной фразы.
Это первенство определителя противоречит интуиции, но прямо ведет к правильной интерпретации.

Переменные `?p` и `?q` можно рассматривать как слоты(позиции), которые необходимо заполнить в окончательной интерпретации, но переменная `?x` выполняет совершенно иную роль.
В конце синтаксического разбора `?x` ничем не будет заполнен; он по-прежнему будет переменной.
Но на него будут ссылаться выражения, заполняющие `?p` и `?q`.
Мы говорим, что `?x` - это *метапеременная*, потому что это переменная в представлении, а не в реализации Пролога.
Просто так случилось, что переменные Пролога можно использовать для реализации этих метапеременных.

Вот интерпретация каждого слова в нашем целевом предложении и для каждой промежуточной составляющей:

```lisp
Every                   = (all ?x (-> ?pl ?ql))
picture               = (picture ?x)
paints                 = (paint ?x ?y)
a                           = (exists ?y (and ?p2 ?q2))
story                   = (story ?y)
Every picture   = (all ?x (-> (picture ?x) ?ql))
a story               = (exists ?y (and (story ?y) ?q2))
paints a story = (exists ?y (and (story ?y) (paint ?x ?y)))
```

Семантика существительного должна заполнить позицию в определителе `?p`, возможно, используя метапеременную `?x`.
Три аргумента к предикату Noun(существительное) - это agreement(согласование), метапеременная `?x` и оператор контроля(assertion), который выполняет утверждение о фразе существительного `?x`:

```lisp
(rule (Noun 3sg ?x (picture ?x)) --> (:word picture))
(rule (Noun 3sg ?x (story ?x)) --> (:word story))
(rule (Noun 3sg ?x (and (young ?x) (male ?x) (human ?x))) -->
```

      `(:word boy))`

Предикат NP изменен на четыре аргумента.
Сначала согласование, затем метапеременная `?x`.
Третий - это сказуемое(предикат), которое будет предоставляться извне с помощью глагольной фразы.
Последний аргумент возвращает интерпретацию NP в целом.
Как мы заявляли, это исходит от определителя:

```lisp
(rule (NP ?agr ?x ?pred ?pred) -->
```

      `(Name ?agr ?name))`

```lisp
;(rule (NP ?agr ?x ?pred ?np) -->
; (Det ?agr ?x ?noun ?pred ?np)
; (Noun ?agr ?x ?noun))
```

Правило для NP с определителем закомментировано, потому что на этом этапе удобно ввести расширенное правило, чтобы заменить его.
Новое правило учитывает некоторые предложения отношений, такие как "the boy that paints a picture"(мальчик, который рисует картину):

```lisp
(rule (NP ?agr ?x ?pred ?np) -->
```

      `(Det ?agr ?x ?noun&rel ?pred ?np)`

      `(Noun ?agr ?x ?noun)`

      `(rel-clause ?agr ?x ?noun ?noun&rel))`

```lisp
(rule (rel-clause ?agr ?x ?np ?np) --> )
(rule (rel-clause ?agr ?x ?np (and ?np ?rel)) -->
```

      `(:word that)`

      `(VP ?agr ?x ?rel))`

Новое правило не учитывает предложения отношений, в которых отсутствует объект, например "the picture that the boy paints"(рисунок, который рисует мальчик). Тем не менее, добавление предложений отношений означает, что теперь мы можем создать бесконечный язык, поскольку мы всегда можем ввести предложение отношений, которое введет новую фразу существительного, которая, в свою очередь, может вводить еще одно предложение отношения.

Правила для придаточных предложений(предложений отношений) несложны, но их трудно понять.
Из четырех аргументов `rel-clause` первые два содержат согласованные признаки заглавного существительного и метапеременной, представляющей заглавное существительное(head noun).
Последние два аргумента используются вместе как аккумулятор для предсказаний о метапеременной: третий аргумент содержит сделанные на данный момент предсказания, а четвертый будет содержать предсказания, включая предложение отношения.
Итак, первое правило для `rel-clause` гласит, что если нет предложения с отношением, то то, что поступает в аккумулятор, совпадает с тем, что выходит.
Второе правило гласит, что выходящее - это соединение того, что входит, и того, что указано в самом предложении отношения.

Глаголы применяются как к одной, так и к двум метапеременным, как и раньше.
Таким образом, мы можем использовать определения `Verb/tr` и `Verb/intr` без изменений.
Для разнообразия я добавил еще несколько глаголов:

`(rule (Verb/tr`"`3sg ?x ?y (paint ?x ?y)) --> (:word paint))`

```lisp
(rule (Verb/tr 3sg ?x ?y (paint ?x ?y)) --> (:word paints))
(rule (Verb/tr ?any ?x ?y (paint ?x ?y)) --> (:word painted))
```

`(rule (Verb/intr`"`3sg ?x (sleep ?x)) --> (:word sleep))`

```lisp
(rule (Verb/intr 3sg ?x (sleep ?x)) --> (:word sleeps))
(rule (Verb/intr ?any ?x (sleep ?x)) --> (:word slept))
(rule (Verb/intr 3sg ?x (sells ?x)) --> (:word sells))
(rule (Verb/intr 3sg ?x (stinks ?x)) --> (:word stinks))
```

Глагольные фразы и утверждения почти те же, что и раньше.
Единственное отличие состоит в вызове `NP`, у которого теперь есть дополнительные аргументы:

```lisp
(rule (VP ?agr ?x ?vp) -->
```

      `(Verb/tr ?agr ?x ?obj ?verb)`

      `(NP ?any-agr ?obj ?verb ?vp))`

```lisp
(rule (VP ?agr ?x ?vp) -->
```

      `(Verb/intr ?agr ?x ?vp))`

```lisp
(rule (S ?np) -->
```

      `(NP ?agr ?x ?vp ?np)`

      `(VP ?agr ?x ?vp))`

С помощью этой грамматики мы получаем следующее соответствие между утверждениями и логическими формами:

```lisp
Every picture paints a story.
(ALL ?3 (-> (PICTURE ?3)
```

                                          `(EXISTS ?14 (AND (STORY ?14) (PAINT ?3 ?14)))))`

```lisp
Every boy that paints a picture sleeps.
(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
```

                                                            `(EXISTS ?19 (AND (PICTURE ?19)`

                                                                                                                        `(PAINT ?3 ?19))))`

                                    `(SLEEP ?3)))`

```lisp
Every boy that sleeps paints a picture.
(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
```

                                                                `(SLEEP ?3))`

                                        `(EXISTS ?22 (AND (PICTURE ?22) (PAINT ?3 ?22)))))`

```lisp
Every boy that paints a picture that sells
paints a picture that stinks.
(ALL ?3 (-> (AND (AND (YOUNG ?3) (MALE ?3) (HUMAN ?3))
```

                                                            `(EXISTS ?19 (AND (AND (PICTURE ?19) (SELLS ?19))`

                                                                                                        `(PAINT ?3 ?19))))`

                                        `(EXISTS ?39 (AND (AND (PICTURE ?39) (STINKS ?39))`

                                                                                                    `(PAINT ?3 ?39)))))`

## 20.5 Сохранение неоднозначности области квантификатора

Рассмотрим простое предложение "Every man loves a woman"(Каждый мужчина любит женщину). Это предложение является двусмысленным между следующими двумя интерпретациями:

```lisp
&forall;m&exist;w man(m) &and; woman(w) &and; loves(m,w)
&exist;w&forall;m man(m) &and; woman(w) &and; loves(m,w)
```

Первая интерпретация состоит в том, что каждый мужчина любит какую-то женщину, возможно, свою жену.
Вторая интерпретация заключается в том, что есть некая женщина, которую любит каждый мужчина - возможно, Натасья Кински.
Значение предложения неоднозначно, но структура - нет; есть только один синтаксический анализ.

В последнем разделе мы представили синтаксический анализатор, который построит одну из двух интерпретаций.
В этом разделе мы покажем, как построить единую интерпретацию, которая сохраняет неоднозначность, но может быть устранена постсинтаксическим процессом.
Основная идея состоит в том, чтобы построить промежуточную логическую форму, которая оставляет область действия кванторов неопределенной.
Затем эту промежуточную форму можно изменить, чтобы получить окончательную интерпретацию.

Напомним, вот интерпретация, которую мы получили бы для фразы "Every man loves a woman"(Каждый мужчина любит женщину), учитывая грамматику в предыдущем разделе:

```lisp
(all ?m (-> (man ?m) (exists ?w) (and (woman ?w) (loves ?m ?w))))
```

Мы изменим грамматику, чтобы получить промежуточную форму:

```lisp
(and (all ?m (man ?m))
```

                  `(exists ?w (wowan ?w))`

                  `(loves ?m ?w))`

Разница в том, что логические компоненты производятся небольшими порциями с квантификаторами без области действия.
Типичное правило грамматики будет строить интерпретацию, соединяя составляющие с помощью `and`, а не вставляя части в слоты в других частях.
Вот полная грамматика и достаточно большой лексикон в новом формате:

```lisp
(rule (S (and ?np ?vp)) -->
```

      `(NP ?agr ?x ?np)`

      `(VP ?agr ?x ?vp))`

```lisp
(rule (VP ?agr ?x (and ?verb ?obj)) -->
```

      `(Verb/tr ?agr ?x ?o ?verb)`

      `(NP ?any-agr ?o ?obj))`

```lisp
(rule (VP ?agr ?x ?verb) -->
```

      `(Verb/intr ?agr ?x ?verb))`

```lisp
(rule (NP ?agr ?name t) -->
```

      `(Name ?agr ?name))`

```lisp
(rule (NP ?agr ?x ?det) -->
```

      `(Det ?agr ?x (and ?noun ?rel) ?det)`

      `(Noun ?agr ?x ?noun)`

      `(rel-clause ?agr ?x ?rel))`

```lisp
(rule (rel-clause ?agr ?x t) --> )
(rule (rel-clause ?agr ?x ?rel) -->
```

      `(:word that)`

      `(VP ?agr ?x ?rel))`

```lisp
(rule (Name 3sg Terry)                                       --> (:word Terry))
(rule (Name 3sg Jean)                                         --> (:word Jean))
(rule (Det 3sg ?x ?restr (all ?x ?restr)) --> (:word every))
(rule (Noun 3sg ?x (man ?x))                           --> (:word man))
(rule (Verb/tr 3sg ?x ?y (love ?x ?y))       --> (:word loves))
(rule (Verb/intr 3sg ?x (lives ?x))             --> (:word lives))
(rule (Det 3sg ?x ?res (exists ?x ?res))   --> (:word a))
(rule (Noun 3sg ?x (woman ?x))                       --> (:word woman))
```

Это дает нам следующий синтаксический анализ фразы "Every man loves a woman"(Каждый мужчина любит женщину):

```lisp
(and (all ?4 (and (man ?4) t))
```

                `(and (love ?4 ?12) (exists ?12 (and (woman ?12) t))))`

Если бы мы упростили это, исключив ts и joining ands, мы получили бы желаемое представление:

```lisp
(and (all ?m (man ?m))
```

                `(exists ?w (wowan ?w))`

                `(loves ?m ?w))`

Оттуда мы могли бы использовать то, что мы знаем о синтаксисе, в дополнение к тому, что мы знаем о мужчинах, женщинах и любви, чтобы определить наиболее вероятную окончательную интерпретацию.
Об этом мы поговорим в следующей главе.

## 20.6 Зависимости на большом расстоянии

До сих пор каждый синтаксический феномен, который мы рассматривали, был выражен в правиле, которое накладывает ограничения только на одном уровне.
Например, нам пришлось наложить ограничение, согласно которому субъект согласован со своим глаголом, но это ограничение включало две непосредственные составляющие предложения, фразу существительного и глагольную фразу.
Нам не нужно было выражать ограничение между, скажем, подлежащим(субьектом) и модификатором объекта глагола.
Однако существуют лингвистические явления, требующие именно таких ограничений.

Наше правило для предложений выражающих отношения было очень простым: предлжение отношения(придаточное) состоит из слова "that", за которым следует утверждение без подлежащего(субъекта), как в "every man that loves a woman"(каждый мужчина, который любит женщину).
Не все предложения отношений следуют этому шаблону.
Также возможно сформировать предложение отношений, опуская объект встроенного утверждения: "every man that a woman loves &blank;"(каждый мужчина, которого любит женщина &blank;).
В этом утверждении символ &blank; указывает на разрыв/зазор/пробел, который понимается как заполнение заголовком полной фразы существительного,  the man(мужчина).
Это было названо *зависимостью  заполнитель-разрыв*.
Это также известно как *зависимость на большом расстоянии*, потому что разрыв может возникать произвольно далеко от заполнителя.
Например, все следующие действительные фразы существительного:

The person that Lee likes &blank;

The person that Kim thinks Lee likes &blank;

The person that Jan says Kim thinks Lee likes &blank;

В каждом случае разрыв заполняется заглавным существительным - the person(человеком).
Но между заглавным существительным и разрывом может стоять любое количество предложений выражающих отношения.

Такая же зависимость между заполнителем и разрывом имеет место в вопросах, которые начинаются со слов "who"(кто), "what"(что), "where"(где) и других вопросительных местоимений.
Например, мы можем задать вопрос о теме(субъекте) утверждения, как в "Who likes Lee?"(Кому нравится Ли?), или о объекте, как в "Who does Kim like &blank;?"(Кому нравится Ким &blank;?).

Вот грамматика, которая охватывает предложения отношений с разрывами в субъектах или объектах.
Правила для `S, VP,` и `NP` дополняются парой аргументов, представляющих аккумулятор для разрывов.
Как и в списке различий, первый аргумент минус второй представляет наличие или отсутствие разрыва.
Например, в первых двух правилах для фраз существительного два аргумента одинаковы: `?g0` и `?g0`.
Это означает, что в правиле в целом нет разрывов, поскольку здесь не может быть разницы между двумя аргументами.
В третьем правиле для NP первый аргумент имеет форму `(gap ...)`, а второй - `nogap`. Это означает, что правая часть правила, пустая составляющая, может быть проанализирована. как разрыв.
(Обратите внимание, что если бы мы использовали истинностные списки различий, двумя аргументами были бы `((gap ...) ?g0)` и `?g0`
Но поскольку мы имеем дело только с одним разрывом на правило, нам не нужны истинностные списки различий.)

Правило для `S` гласит, что фраза существительного с разрывом `?g0` минус `?gl`, за которой следует глагольная фраза с разрывом `?gl` минус `?g2`, составляет утверждение с разрывом `?g0` минус `?g2`.
Правило для предложений с отношением находит предложение с разрывом где угодно; либо в субъекте, либо в глагольной фразе.
Вот полная грамматика:

```lisp
(rule (S ?g0 ?g2 (and ?np ?vp)) -->
```

      `(NP ?g0 ?gl ?agr ?x ?np)`

      `(VP ?gl ?g2 ?agr ?x ?vp))`

```lisp
(rule (VP ?g0 ?gl ?agr ?x (and ?obj ?verb)) -->
```

      `(Verb/tr ?agr ?x ?o ?verb)`

      `(NP ?g0 ?gl ?any-agr ?o ?obj))`

```lisp
(rule (VP ?g0 ?g0 ?agr ?x ?verb) -->
```

      `(Verb/intr ?agr ?x ?verb))`

```lisp
(rule (NP ?g0 ?g0 ?agr ?name t) -->
```

      `(Name ?agr ?name))`

```lisp
(rule (NP ?g0 ?g0 ?agr ?x ?det) -->
```

      `(Det ?agr ?x (and ?noun ?rel) ?det)`

      `(Noun ?agr ?x ?noun)`

      `(rel-clause ?agr ?x ?rel))`

```lisp
(rule (NP (gap NP ?agr ?x) nogap ?agr ?x t) --> )
(rule (rel-clause ?agr ?x t) --> )
(rule (rel-clause ?agr ?x ?rel) -->
```

      `(:word that)`

      `(S (gap NP ?agr ?x) nogap ?rel))`

Вот несколько пар утверждение/синтаксический анализ, охватываемых этой грамматикой:

`Every man that` &blank; `loves a woman likes a person.`

```lisp
(AND (ALL ?28 (AND (MAN ?28)
```

            `(AND T (AND (LOVE ?28 ?30)`

                  `(EXISTS ?30 (AND (WOMAN ?30)`

                              `T))))))`

      `(AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?28 ?39)))`

`Every man that a woman loves` &blank; `likes a person.`

```lisp
(AND (ALL ?37 (AND (MAN ?37)
```

            `(AND (EXISTS ?20 (AND (WOMAN ?20) T))`

                `(AND T (LOVE ?20 ?37)))))`

      `(AND (EXISTS ?39 (AND (PERSON ?39) T)) (LIKE ?37 ?39)))`

`Every man that loves a bird that` &blank; `flies likes a person.`

```lisp
(AND (ALL ?28 (AND (MAN ?28)
```

            `(AND T (AND (EXISTS ?54`

                  `(AND (BIRD ?54)`

                          `(AND T (FLY ?54))))`

                `(LOVE ?28 ?54)))))`

      `(AND (EXISTS ?60 (AND (PERSON ?60) T)) (LIKE ?28 ?60)))`

На самом деле есть ограничения на ситуации, в которых могут возникнуть разрывы.
В частности, редко бывает разрыв в субъекте утверждения, за исключением случая предложения с отношением.
В следующей главе мы увидим, как наложить дополнительные ограничения на разрывы.

## 20.7 Дополнение правил DCG

В предыдущем разделе мы увидели, как создать семантическое представление утверждения, объединив семантику компонентов.
Одна из проблем с этим подходом состоит в том, что семантическая интерпретация часто имеет форму `(and (and t *a) b)*`, тогда как мы предпочитаем `(and *a b)*`.
Есть два способа исправить эту проблему: либо мы добавляем шаг, который берет окончательную семантическую интерпретацию и упрощает ее, либо мы усложняем каждое отдельное правило, заставляя его генерировать упрощенную форму.
Второй вариант был бы немного более эффективным, но был бы очень уродливым и подверженным ошибкам.
Мы должны делать все возможное, чтобы правила были проще, а не усложнялись; в этом весь смысл формализма DCG.
Это предполагает третий подход: изменить интерпретатор правила так, чтобы он автоматически генерировал семантическую интерпретацию как соединение составляющих, если в правиле явно не указано иное.
В этом разделе показано, как дополнить правила DCG для автоматической обработки таких распространенных случаев.

Снова рассмотрим правило из [раздела 20.4](#s0025):

```lisp
(rule (S (and ?np ?vp)) -->
```

      `(NP ?agr ?x ?np)`

      `(VP ?agr ?x ?vp))`

Если бы мы изменили это правило, чтобы получить упрощенную семантическую интерпретацию, это выглядело бы следующим образом, где предикат `and*` упрощает список союзов до единого союза:

```lisp
(rule (S ?sem) -->
```

      `(np ?agr ?x ?np)`

      `(vp ?agr ?x ?vp)`

      `(:test (and*(?np ?vp) ?sem)))`

Многие правила будут иметь такую форму, поэтому мы принимаем простое соглашение: если последним аргументом составляющей в левой части правила является ключевое слово `:sem`, то мы построим семантику, заменив `:sem` с конъюнкцией, образованной путем объединения всех последних аргументов составляющих правую часть правила.
Стрелка `A==>` будет использоваться для правил, следующих этому соглашению, поэтому следующее правило эквивалентно приведенному выше:

```lisp
(rule (S :sem) ==>
```

      `(NP ?agr ?x ?np)`

      `(VP ?agr ?x ?vp))`

Иногда полезно ввести дополнительную семантику, которая не исходит от одного из компонентов.
Это можно указать с помощью элемента в правой части списка, начинающегося с `:sem`.
Например, следующее правило добавляет к семантике тот факт, что `?x` является темой предложения:

```lisp
(rule (S :sem) ==>
```

      `(NP ?agr ?x ?np)`

      `(VP ?agr ?x ?vp)`

      `(:sem (topic ?x)))`

Перед реализацией функции правила для стрелки `==>` стоит подумать, есть ли другие способы упростить работу автора правил.
Одна из возможностей - предоставить обозначения для описания примеров.
Примеры помогают понять, для чего создано правило.
Для правила `S` мы могли бы добавить такие примеры:

```lisp
(rule (S :sem) ==>
```

      `(:ex "John likes Mary" "He sleeps")`

      `(NP ?agr ?x ?np)`

      `(VP ?agr ?x ?vp))`

Эти примеры не только служат в качестве документации для правила, но также могут быть сохранены в `S` и впоследствии запускаться, когда мы хотим проверить, действительно ли `S` реализовано правильно.

Другая область, в которой составитель правил может использовать помощь, - это обработка леворекурсивных правил.
Рассмотрим правило, согласно которому утверждение может состоять из двух утверждений, соединенных союзом:

```lisp
(rule (S (?conj ?sl ?s2)) ==>
```

      `(:ex "John likes Mary and Mary likes John")`

      `(S ?sl)`

      `(Conj ?conj)`

      `(S ?s2))`

Хотя это правило является верным как декларативное утверждение, оно вызовет трудности при запуске стандартным процессом интерпретации DCG сверху вниз, сначала в глубину.
Цель верхнего уровня для синтаксического анализа `S` немедленно приведет к подзадаче синтаксического анализа `S`, и результатом будет бесконечный цикл.

К счастью, мы знаем, как избежать такого бесконечного цикла: разделить предикат, вызывающий нарушение, `S` на два предиката: один, поддерживающий рекурсию, и другой, находящийся на более низком уровне.
Мы будем называть предикат нижнего уровня `S-`.
Таким образом, следующее правило гласит, что утверждение может состоять из двух утверждений, где первое не соединяется, а второе, возможно, соединено:

```lisp
(rule (S (?conj ?sl ?s2)) ==>
```

      `(S_ ?sl)`

      `(Conj ?conj)`

      `(S ?s2))`

Нам также нужно правило, которое гласит, что возможно составное утверждение может состоять из несоединенного утрверждения:

```lisp
(rule (S ?sem) ==> (S- ?sem))
```

Чтобы это сработало, нам нужно заменить любое упоминание `S` в левой части правила на `S-`.
Ссылки на `S` в правой части правил остаются без изменений. 

```lisp
(rule (S- ?sem) ==>...)
```

Чтобы сделать все это автоматическим, мы предоставим макрос, `conj-rule`, который объявляет категорию как такую, которую можно объединить.
Такое объявление автоматически сгенерирует рекурсивные и нерекурсивные правила для категории и обеспечит замену будущих ссылок на категорию в левой части правила на соответствующий предикат нижнего уровня.

Одна из проблем этого подхода заключается в том, что он требует синтаксического анализа с ветвлением вправо для нескольких соединенных фраз.
То есть мы получим такие синтаксические выражения, как "spaghetti and (meatballs and salad)"(спагетти и (тефтели и салат)) not  "(spaghetti and meatballs) and salad". Ясно, что это неправильное толкование этого утверждения.
Тем не менее, можно утверждать, что лучше всего произвести один канонический синтаксический анализ, а затем позволить функциям семантической интерпретации позаботиться о переупорядочении синтаксического анализа в правильном порядке.
Мы не будем пытаться разрешить этот спор, но предоставим механизм автоматического соединения в качестве инструмента, который может быть удобным, но не требует затрат для пользователя, который предпочитает другое решение.

Теперь мы готовы реализовать расширенный формализм правил DCG, который обрабатывает `:sem, :ex,` и автоматические объединения(конъюнкции).
Функция `make-augmented-dcg`, сохраненная под стрелкой `==>`, будет использоваться для реализации формализма:

```lisp
(setf (get '==> 'rule-function) 'make-augmented-dcg)

(defun make-augmented-dcg (head body)
  "Build an augmented DCG rule that handles :sem, :ex,
  and automatic conjunctiontive constituents."
  (if (eq (last1 head) :sem)
      ;; Handle :sem
      (let* ((?sem (gensym "?SEM")))
        (make-augmented-dcg
          `(,@(butlast head) ,?sem)
          `(,@(remove :sem body :key #'first-or-nil)
            (:test ,(collect-sems body ?sem)))))
      ;; Separate out examples from body
      (multiple-value-bind (exs new-body)
          (partition-if #'(lambda (x) (starts-with x :ex)) body)
        ;; Handle conjunctions
        (let ((rule `(rule ,(handle-conj head) --> ,@new-body)))
          (if (null exs)
              rule
              `(progn (:ex ,head .,(mappend #'rest exs))
                      ,rule))))))
```

Сначала мы показываем код, который собирает вместе семантику каждой составляющей и объединяет их, когда указано `:sem`.
Функция `collect-sems` выбирает семантику и обрабатывает тривиальные случаи, когда в правой части есть ноль или одна составляющая.
Если их несколько, она вставляет вызов предиката `and*`.

```lisp
(defun collect-sems (body ?sem)
  "Get the semantics out of each constituent in body,
  and combine them together into ?sem."
  (let ((sems (loop for goal in body
                    unless (or (dcg-normal-goal-p goal)
                               (dcg-word-list-p goal)
                               (starts-with goal :ex)
                               (atom goal))
                    collect (last1 goal))))
    (case (length sems)
      (0 `(= ,?sem t))
      (1 `(= ,?sem ,(first sems)))
      (t `(and* ,sems ,?sem)))))
```

Мы могли бы реализовать `and*` с предложениями Prolog, но немного эффективнее делать это непосредственно в Lisp.
Вызов `conjuncts` собирает все конъюнкты, а затем мы добавляем and, если необходимо:

```lisp
(defun and*/2 (in out cont)
  "IN is a list of conjuncts that are conjoined into OUT."
  ;; E.g.: (and* (t (and a b) t (and c d) t) ?x) ==>
  ;;        ?x = (and a b c d)
  (if (unify! out (maybe-add 'and (conjuncts (cons 'and in)) t))
      (funcall cont)))

(defun conjuncts (exp)
  "Get all the conjuncts from an expression."
  (deref exp)
  (cond ((eq exp t) nil)
        ((atom exp) (list exp))
        ((eq (deref (first exp)) 'nil) nil)
        ((eq (first exp) 'and)
         (mappend #'conjuncts (rest exp)))
        (t (list exp))))
```

Следующий шаг - работа с примерами фраз.
Код в `make-augmented-dcg` превращает примеры в выражения вида:

```lisp
(:ex (S ?sem) "John likes Mary" "He sleeps")
```

Чтобы это работало, :ex должен быть макросом:

```lisp
(defmacro :ex ((category . args) &body examples)
  "Add some example phrases, indexed under the category."
  `(add-examples ',category ',args ',examples))
```

`:ex вызывает add-examples, чтобы выполнить всю работу.
Каждый пример хранится в хэш-таблице, индексируемой по категории.
Каждый пример преобразуется в список из двух элементов: сама строка фразы примера и вызов соответствующего предиката со всеми предоставленными аргументами.
Функция `add-examples` выполняет это преобразование и индексацию, а `run-examples` извлекает примеры, хранящиеся в категории, печатает каждую фразу и вызывает каждую цель.
Вспомогательные функции `get-examples` и `clear-examples` предназначены для управления таблицей примеров, а `remove-punction, punctuation-p` и `string->list` используются для отображения строки в список. слов.

```lisp
(defvar *examples* (make-hash-table :test #'eq))
(defun get-exampl es (category) (gethash category *examples*))
(defun clear-examples () (clrhash *examples*))

(defun add-examples (category args examples)
  "Add these example strings to this category,
  and when it comes time to run them, use the args."
  (dolist (example examples)
    (when (stringp example)
      (let ((ex `(,example
                  (,category ,@args
                   ,(string->list
                      (remove-punctuation example)) ()))))
        (unless (member ex (get-examples category)
                        :test #'equal)
          (setf (gethash category *examples*)
                (nconc (get-examples category) (list ex))))))))

(defun run-examples (&optional category)
  "Run all the example phrases stored under a category.
  With no category, run ALL the examples."
  (prolog-compile-symbols)
  (if (null category)
      (maphash #'(lambda (cat val)
                   (declare (ignore val))
                   (format t "~2&Examples of ~a:~&" cat)
                   (run-examples cat))
               *examples*)
      (dolist (example (get-examples category))
        (format t "~2&EXAMPLE: ~{~a~&~9T~a~}" example)
        (top-level-prove (cdr example)))))

(defun remove-punctuation (string)
  "Replace punctuation with spaces in string."
  (substitute-if #\space #'punctuation-p string))

(defun string->list (string)
  "Convert a string to a list of words."
  (read-from-string (concatenate 'string "(" string ")")))

(defun punctuation-p (char) (find char "*_.,;:`!?#-()\\\""))
```

Последняя часть нашего расширенного формализма DCG - это автоматическая обработка конъюнктивных составляющих.
Мы уже организовали перевод символов категорий в левой части правил в соответствующую конъюнктивную категорию, как определено функцией `handle-conj`.
Мы также хотим сгенерировать автоматически (или как можно проще) правила следующего вида:

```lisp
(rule (S (?conj ?sl ?s2)) ==>
```

      `(S_ ?sl)`

      `(Conj ?conj)`

      `(S ?s2))`

```lisp
(rule (S ?sem) ==> (S_ ?sem))
```

Но прежде чем создавать эти правила, давайте убедимся, что они именно то, что мы хотим.
Рассмотрите возможность синтаксического анализа несоединенного утверждения с этими двумя правилами.
Первое правило будет анализировать все утверждение как `S_`, а затем не сможет увидеть `Conj` и, следовательно, потерпит неудачу.
Второе правило будет дублировать весь процесс синтаксического анализа, таким образом удваивая количество затрачиваемого времени.
Если мы изменим порядок двух правил, мы сможем быстро анализировать несоединенные утверждения, но при этом нам придется возвращаться к соединенным утверждениям.

Ниже показан лучший подход.
Единственное правило для `S` анализирует утверждение с помощью `S_`, а затем вызывает `Conj_S`, который может быть прочитан как "либо соединение, за которым следует утверждение, либо ничего". Если за первым утверждением ничего не следует, тогда мы просто используем семантику первого утверждения; если есть конъюнкция, мы должны сформировать комбинированную семантику.
Я добавил ..., чтобы показать, где подходят аргументы предикату, кроме семантического аргумента.

```lisp
(rule (S ... ?s-combined) ==>
```

      `(S_ ... ?seml)`

      `(Conj_S ?seml ?s-combined))`

```lisp
(rule (Conj_S ?seml (?conj ?seml ?sem2)) ==>
```

      `(Conj ?conj)`

      `(S ... ?sem2))`

```lisp
(rule (Conj_S ?seml ?seml) ==>)
```

Теперь все, что нам нужно, это способ указать пользователю, что эти три правила желательны.
Поскольку точный метод построения комбинированной семантики и, возможно, даже вызов `Conj` может варьироваться в зависимости от специфики определяемой грамматики, правила не могут быть сгенерированы полностью автоматически.
Мы остановимся на макросе `conj-rule`, который очень похож на второе из трех приведенных выше правил, но расширяется во все три, плюс код, связывающий `S_` с `S`.
Итак, пользователь наберет:

```lisp
(conj-rule (Conj_S ?seml (?conj ?seml ?sem2)) ==>
```

      `(Conj ?conj)`

      `(S ?a ?b ?c ?sem2))`

Вот определение макроса:

```lisp
(defmacro conj-rule ((conj-cat sem1 combined-sem) ==>
                     conj (cat . args))
  "Define this category as an automatic conjunction."
  (assert (eq ==> '==>))
  `(progn
     (setf (get ',cat 'conj-cat) ',(symbol cat '_))
     (rule (,cat ,@(butlast args) ?combined-sem) ==>
       (,(symbol cat '_) ,@(butlast args) ,sem1)
       (,conj-cat ,sem1 ?combined-sem))
     (rule (,conj-cat ,sem1 ,combined-sem) ==>
       ,conj
       (,cat ,@args))
     (rule (,conj-cat ?sem1 ?sem1) ==>)))
```

и здесь мы определяем `handle-conj` для подстановки `S-` для `S` в левой части правил:

```lisp
(defun handle-conj (head)
  "Replace (Cat ...) with (Cat_ ...) if Cat is declared
  as a conjunctive category."
  (if (and (listp head) (conj-category (predicate head)))
      (cons (conj-category (predicate head)) (args head))
      head))

(defun conj-category (predicate)
  "If this is a conjunctive predicate, return the Cat_ symbol."
  (get predicate 'conj-category))
```

## 20.8 История и ссылки

As we have mentioned, Alain Colmerauer invented Prolog to use in his grammar of French (1973).
His *metamorphosis grammar* formalism was more expressive but much less efficient than the standard DCG formalism.

The grammar in [section 20.4](#s0025) is essentially the same as the one presented in Fernando Pereira and David H.
D.
Warren's 1980 paper, which introduced the Definite Clause Grammar formalism as it is known today.
The two developed a much more substantial grammar and used it in a very influential question-answering system called Chat-80 ([Warren and Pereira, 1982](B9780080571157500285.xhtml#bb1340)).
Pereira later teamed with Stuart Shieber on an excellent book covering logic grammars in more depth: *Prolog and Natural-Language Analysis* (1987).
The book has many strong points, but unfortunately it does not present a grammar anywhere near as complete as the Chat-80 grammar.

The idea of a compositional semantics based on mathematical logic owes much to the work of the late linguist Richard Montague.
The introduction by [Dowty, Wall, and Peters (1981)](B9780080571157500285.xhtml#bb0335) and the collection by [Rich Thomason (1974)](B9780080571157500285.xhtml#bb1235) cover Montague's approach.

The grammar in [section 20.5](#s0030) is based loosely on Michael McCord's modular logic grammar, as presented in [Walker et al.
1990](B9780080571157500285.xhtml#bb1295).

It should be noted that logic grammars are by no means the only approach to natural language processing.
[Woods (1970)](B9780080571157500285.xhtml#bb1425) presents an approach based on the *augmented transition network*, or ATN.
A transition network is like a context-free grammar.
The *augmentation* is a way of manipulating features and semantic values.
This is just like the extra arguments in DCGs, except that the basic operations are setting and testing variables rather than unification.
So the choice between ATNs and DCGs is largely a matter of what programming approach you are most comfortable with: procedural for ATNs and declarative for DCGs.
My feeling is that unification is a more suitable primitive than assignment, so I chose to present DCGs, even though this required bringing in Prolog's backtracking and unification mechanisms.

In either approach, the same linguistic problems must be addressed-agreement, long-distance dependencies, topicalization, quantifier-scope ambiguity, and so on.
Comparing [Woods's (1970)](B9780080571157500285.xhtml#bb1425) ATN grammar to [Pereira and Warren's (1980)](B9780080571157500285.xhtml#bb0950) DCG grammar, the careful reader will see that the solutions have much in common.
The analysis is more important than the notation, as it should be.

## 20.9 Упражнения

**Exercise  20.2 [m]** Modify the grammar (from [section 20.4](#s0025), [20.5](#s0030), [or 20.6](#s0035)) to allow for adjectives before a noun.

**Exercise  20.3 [m]** Modify the grammar to allow for prepositional phrase modifiers on verb and noun phrases.

**Exercise  20.4 [m]** Modify the grammar to allow for ditransitive verbs-verbs that take two objects, as in "give the dog a bone."

**Exercise  20.5** Suppose we wanted to adopt the Prolog convention of writing DCG tests and words in brackets and braces, respectively.
Write a function that will alter the readtable to work this way.

**Exercise  20.6 [m]** Define a rule function for a new type of DCG rule that automatically builds up a syntactic parse of the input.
For example, the two rules:

```lisp
(rule (s) => (np) (vp))
(rule (np) => (:word he))
```

should be equivalent to:

```lisp
(rule (s (s ?1 ?2)) --> (np ?1) (vp ?2))
(rule (np (np he)) --> (:word he))
```

**Exercise  20.7 [m]** There are advantages and disadvantages to the approach that Prolog takes in dividing predicates into clauses.
The advantage is that it is easy to add a new clause.
The disadvantage is that it is hard to alter an existing clause.
If you edit a clause and then evaluate it, the new clause will be added to the end of the clause list, when what you really wanted was for the new clause to take the place of the old one.
To achieve that effect, you have to call `clear-predicate`, and then reload all the clauses, not just the one that has been changed.

Write a macro `named-rule` that is just like `rule`, except that it attaches names to clauses.
When a named rule is reloaded, it replaces the old clause rather than adding a new one.

**Exercise 20.8 [h]** Extend the DCG rule function to allow or goals in the right-hand side.
To make this more useful, also allow `and` goals.
For example:

```lisp
(rule (A) --> (B) (or (C) (and (D) (E))) (F))
```

should compile into the equivalent of :

```lisp
(<- (A ?S0 ?S4)
```

      `(B ?S0 ?S1)`

      `(OR (AND (C ?S1 ?S2) (= ?S2 ?S3))`

    `(AND (D ?S1 ?S2) (E ?S2 ?S3)))`

      `(F ?S3 ?S4))`

## 20.10 Ответы

**Answer 20.1** It uses local variables `(?s0, ?sl ...)` that are not guaranteed to be unique.
This is a problem if the grammar writer wants to use these symbols anywhere in his or her rules.
The fix is to `gensym` symbols that are guaranteed to be unique.

### Answer 20.5

`(defun setup-braces Uoptional (on?
t) (readtable *readtable*))`

      `"Make [a b] read as (:word a b) and {a b} as (:test a b c) if ON?
is true; otherwise revert {[]} to normal."`

      `if ON?
is true; otherwise revert {[]} to normal."`

      `(if (not on?)`

      `(map nil #'(lambda (c)`

              `(set-macro-character c (get-macro-character #\a)`

                        `t readtable))`

        `"{[]}")`

      `(progn`

        `(set-macro-character`

          `#\] (get-macro-character #\)) nil readtable)`

        `(set-macro-character`

          `#\} (get-macro-character #\)) nil readtable)`

        `(set-macro-character`

          `#\[ #'(lambda (s ignore)`

                  `(cons :word (read-delimited-list #\] s t)))`

          `nil readtable)`

        `(set-macro-character`

          `#\{ #'(lambda (s ignore)`

                  `(cons :test (read-delimited-list #\} s t)))`

          `nil readtable))))`

----------------------

[1](#xfn0015) The asterisk at the start of a sentence is the standard linguistic notation for an utterance that is ungrammatical or otherwise ill-formed.
!!!(p) {:.ftnote1}