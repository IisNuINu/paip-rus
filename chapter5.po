#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter5.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:09+0300\n"
"PO-Revision-Date: 2020-10-21 14:28+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter5.md:3
msgid ""
"# Chapter 5\n"
"## ELIZA: Dialog with a Machine"
msgstr ""
"# Глава 5\n"
"## Элиза: Диалог с машиной"

#: in/chapter5.md:5
msgid "> *It is said that to explain is to explain away.*"
msgstr "> *Говорят, что объяснять - значит оправдываться.*"

#: in/chapter5.md:7
msgid "> -Joseph Weizenbaum"
msgstr ""

#: in/chapter5.md:9
msgid "> MIT computer scientist"
msgstr "> MIT computer scientist"

#: in/chapter5.md:14
msgid ""
"This chapter and the rest of part I will examine three more well-known AI "
"programs of the 1960s.\n"
"ELIZA held a conversation with the user in which it simulated a "
"psychotherapist.\n"
"STUDENT solved word problems of the kind found in high school algebra books, "
"and MACSYMA solved a variety of symbolic mathematical problems, including "
"differential and integral calculus.\n"
"We will develop versions of the first two programs that duplicate most of "
"the essential features, but for the third we will implement only a tiny "
"fraction of the original program's capabilities."
msgstr ""
"В этой главе и в остатках части I рассмотриваются еще три хорошо известные "
"программы искусственного интеллекта 1960-х годов.\n"
"ELIZA провела беседу с пользователем, в которой она имитировала "
"психотерапевта.\n"
"STUDENT решал словесные задачи, подобные тем, что встречаются в школьных "
"учебниках алгебры, а MACSYMA решала множество символических математических "
"задач, включая дифференциальное и интегральное исчисление.\n"
"Мы разработаем версии первых двух программ, которые дублируют большинство "
"основных функций, но для третьей мы будем реализовывать только крошечную "
"часть возможностей исходной программы."

#: in/chapter5.md:17
msgid ""
"All three programs make heavy use of a technique called pattern matching.\n"
"Part I serves to show the versatility-and also the limitations-of this "
"technique."
msgstr ""
"Все три программы интенсивно используют технику, называемую сопоставлением "
"образцов.\n"
"Часть I служит для того, чтобы показать универсальность, а также ограничения "
"- этой техники."

#: in/chapter5.md:20
msgid ""
"Of the three programs, the first two process input in plain English, and the "
"last two solve non-trivial problems in mathematics, so there is some basis "
"for describing them as being \"intelligent.\"\n"
"On the other hand, we shall see that this intelligence is largely an "
"illusion, and that ELIZA in particular was actually designed to demonstrate "
"this illusion, not to be a \"serious\" AI program."
msgstr ""
"Из трех программ первые две обрабатывают входные данные на простом "
"английском языке, и последние две решают нетривиальные задачи в математике, "
"поэтому есть некоторые основания для описания их как \"интеллектуальных\"."
"\"\n"
"С другой стороны, мы увидим, что этот интеллект в значительной степени "
"является иллюзией, и что Элиза, в частности, была на самом деле "
"предназначена для демонстрации этой иллюзии, а не для того, чтобы быть "
"\"серьезной\" программой ИИ."

#: in/chapter5.md:25
msgid ""
"ELIZA was one of the first programs to feature English output as well as "
"input.\n"
"The program was named after the heroine of *Pygmalion,* who was taught to "
"speak proper English by a dedicated teacher.\n"
"ELIZA'S principal developer, MIT professor Joseph Weizenbaum, published a "
"paper on ELIZA in the January 1966 issue of the *Communications of the "
"Association for Computing Machinery.*\n"
"The introduction to that paper is reproduced in its entirety here:"
msgstr ""
"ELIZA была одной из первых программ, в которой был возможен ввод и вывод на "
"английском языке.\n"
"Программа была названа в честь героини *Пигмалиона*, которую научил говорить "
"по-английски преданный своему делу учитель.\n"
"Главный разработчик ELIZA, профессор Массачусетского технологического "
"института Джозеф Вайценбаум, опубликовал статью об ELIZA в январском выпуске "
"журнала *Communications of the Association for Computing Machinery* за 1966 "
"год.\n"
"Введение к этой статье полностью воспроизводится здесь:"

#: in/chapter5.md:31
msgid ""
"> *It is said that to explain is to explain away.\n"
"This maxim is nowhere so well fulfilled as in the area of computer "
"programming, especially in what is called heuristic programming and "
"artificial intelligence.\n"
"For in those realms machines are made to behave in wondrous ways, often "
"sufficient to dazzle even the most experienced observer.\n"
"But once a particular program is unmasked, once its inner workings are "
"explained in language sufficiently plain to induce understanding, its magic "
"crumbles away; it stands revealed as a mere collection of procedures, each "
"quite comprehensible.\n"
"The observer says to himself, \"I could have written that.\" With that "
"thought he moves the program in question from the shelf marked \"intelligent,"
"\" to that reserved for curios, fit to be discussed only with people less "
"enlightened than he.*"
msgstr ""
"> *Говорят, что объяснять - значит растолковывать начиная из далека.\n"
"Эта максима нигде не выполняется так хорошо, как в области компьютерного "
"программирования, особенно в том, что называется эвристическим "
"программированием и искусственным интеллектом.\n"
"Ибо в этих сферах машины заставляют вести себя чудесными способами, часто "
"достаточными, чтобы ослепить даже самого опытного наблюдателя.\n"
"Но как только конкретная программа разоблачается, когда ее внутренняя работа "
"объясняется на языке, достаточно ясном, чтобы вызвать понимание, ее магия "
"рассыпается; он предстает как простой набор процедур, каждая из которых "
"вполне понятна.\n"
"Наблюдатель говорит себе: «Я мог бы написать это». С этой мыслью он "
"перемещает рассматриваемую программу с полки, помеченной как "
"«интеллектуальная», на полку, предназначенную для антикварных вещей, "
"подходящую для обсуждения только с людьми менее просвещенными, чем он*."

#: in/chapter5.md:33
msgid ""
"> *The object of this paper is to cause just such a re-evaluation of the "
"program about to be \"explained.\" Few programs ever needed it more.*"
msgstr ""
"> *Цель этой статьи - вызвать именно такую переоценку программы, которая вот-"
"вот будет \"объяснена\". Немногие программы когда-либо нуждались в этом "
"больше. *"

#: in/chapter5.md:35
msgid ""
"Let me point out in passing that the main object of this book is to cause "
"the reader to say to him or herself, \"I could have written that.\" It is "
"hoped that in some cases this will be because the reader has gained "
"something, and not solely because the programs in question have lost their "
"ability to dazzle."
msgstr ""
"Позвольте мне мимоходом заметить, что главная цель этой книги-заставить "
"читателя сказать себе: \"я мог бы написать это\". Есть надежда, что в "
"некоторых случаях это произойдет потому, что читатель что-то приобрел, а не "
"только потому, что программы, о которых идет речь, потеряли свою способность "
"ослеплять."

#: in/chapter5.md:43
msgid ""
"Let's start our investigation of ELIZA by looking at a sample dialog from "
"the Weizenbaum article.\n"
"ELIZA was designed to be instructed by a variety of scripts, or patterns of "
"interaction.\n"
"In fact it had several scripts, including ones in German and Welsh.\n"
"But the only script that was used to any extent was in English, and it made "
"ELIZA emulate a Rogerian psychoanalyst.\n"
"Rogerians are \"nondirective\"-they try to let the patient reveal himself.\n"
"This is an easy script for ELIZA to follow, because it involves being "
"passive and reacting, rather than volunteering new information.\n"
"In the listing that follows, the user's input is in mixed case, and ELIZA'S "
"response is in capitals:"
msgstr ""
"Давайте начнем наше исследование ELIZA с примера диалога из статьи "
"Вейценбаума.\n"
"ELIZA была создана для того, чтобы обучаться с помощью различных сценариев "
"или моделей взаимодействия.\n"
"На самом деле там было несколько сценариев, в том числе на немецком и "
"валлийском языках.\n"
"Но единственный сценарий, который в какой-то степени использовался, был на "
"английском, и это заставило ELIZA подражать психоаналитику Роджера(какое то "
"направление в психиатрии).\n"
"Роджерианцы \"недирективны\" -они пытаются позволить пациенту раскрыть "
"себя.\n"
"Элизе легко следовать этому сценарию, потому что она предполагает "
"пассивность и реакцию, а не добровольное предоставление новой информации.\n"
"В следующем списке ввод данных Пользователя осуществляется в смешанном "
"регистре, а ответ Элизы-заглавными буквами:"

#: in/chapter5.md:60
msgid ""
"```text\n"
"Men are all alike.\n"
"IN WHAT WAY\n"
"They're always bugging us about something or another.\n"
"CAN YOU BE MORE SPECIFIC\n"
"Well, my boyfriend made me come here.\n"
"YOUR BOYFRIEND MADE YOU COME HERE\n"
"He says I'm depressed much of the time.\n"
"I AM SORRY TO HEAR YOU ARE DEPRESSED\n"
"It's true. I am unhappy.\n"
"DO YOU THINK COMING HERE WILL HELP YOU NOT TO BE UNHAPPY\n"
"I need some help, that much seems certain.\n"
"WHAT WOULD IT MEAN TO YOU IF YOU GOT SOME HELP\n"
"Perhaps I could learn to get along with my mother.\n"
"TELL ME MORE ABOUT YOUR FAMILY\n"
"```"
msgstr ""

#: in/chapter5.md:70
msgid ""
"This seems quite impressive; the program is responding reasonably to a "
"variety of inputs and appears to be exhibiting true \"understanding.\"\n"
"But, as Weizenbaum explains, this appearance is an illusion, and the program "
"has finessed the difficult task of understanding by carefully recognizing, "
"transforming, and echoing pieces of the input.\n"
"The procedure is to look for specific patterns, based on a key word or words "
"in the input.\n"
"For example, whenever the program sees the words \"alike\" or \"same,\" it "
"prints a message asking about similarity, in this case, \"`IN WHAT WAY.`\" "
"Other patterns are more complicated.\n"
"In the next to last exchange, ELIZA first throws away everything after the "
"comma, and then uses a pattern that looks for input of the form \"I need X\" "
"and transforms it to the output \"What would it mean to you if you got X,\" "
"where X is the phrase \"some help\" in this case.\n"
"The great advantage of this approach is that the response will make sense "
"for a variety of inputs: \"I need a vacation\" will elicit \"What would it "
"mean to you if you got a vacation.\" This will work automatically, without "
"having to tell the program the difference between \"some help\" and \"a "
"vacation.\" The disadvantage is that the program will sometimes make silly "
"responses: \"I need this like a hole in the head\" will be answered with "
"\"What would it mean to you if you got this like a hole in the head.\" In "
"fact, the program only makes any sense at all if it is receiving input from "
"someone who makes sense-and someone who interprets its answers charitably.\n"
"When given \"I need gibble plix zzq,\" ELIZA would reply \"What would it "
"mean to you if you got gibble plix zzq,\" without any inkling that something "
"is wrong.\n"
"Another example of the original ELIZA program has it communicating with "
"another program, PARRY, which was written by Dr. Kenneth Colby to mimic "
"paranoid behavior.\n"
"Part of the conversation follows, with ELIZA again in capitals and PARRY in "
"mixed case:"
msgstr ""
"Это кажется весьма впечатляющим; программа разумно реагирует на различные "
"входные данные и, похоже, демонстрирует истинное «понимание».\n"
"Но, как объясняет Вайценбаум, эта видимость является иллюзией, и программа "
"решила сложную задачу понимания, тщательно распознавая, преобразовывая и "
"повторяя части входных данных.\n"
"Процедура заключается в поиске определенных шаблонов(образцов) на основе "
"ключевого слова или слов во входных данных.\n"
"Например, всякий раз, когда программа видит слова \"alike\"(похожий) или "
"\"same\"(такой же), она печатает сообщение с вопросом о сходстве, в данном "
"случае \"`IN WHAT WAY.`\"(каким образом). Другие шаблоны более сложны.\n"
"В предпоследнем обмене ELIZA сначала выбрасывает все, что стоит после "
"запятой, а затем использует шаблон, который ищет ввод в форме \"I need X"
"\"(Мне нужен X) и преобразует его в вывод \"What would it mean to you if you "
"got X\"(Что бы это значило для вас, если бы вы получили X), где X - фраза "
"\"some help\"(некоторая помощь), в данном случае.\n"
"Большое преимущество этого подхода заключается в том, что ответ будет иметь "
"смысл для различных входов: \"I need a vacation\"(мне нужен отпуск) будет "
"вызывать \"What would it mean to you if you got a vacation.\"(что бы это "
"значило для вас, если бы вы получили отпуск). Это будет работать "
"автоматически, без необходимости сообщать программе разницу между \"some help"
"\"(некоторой помощью) и \"a vacation.\"(отпуском). Недостатком является то, "
"что программа иногда будет делать глупые ответы: \"I need this like a hole "
"in the head\"(мне это нужно, как дырка в голове), - вызовет ответ: \"What "
"would it mean to you if you got this like a hole in the head\"(что бы это "
"значило для вас, если бы вы получили это, как дырку в голове). На самом "
"деле, программа имеет смысл только в том случае, если она получает "
"информацию от кого-то, кто имеет смысл - и кто-то, кто благосклонно "
"интерпретирует ее ответы.\n"
"Когда ей говорили: \"I need gibble plix zzq\"(мне нужен гиббл пликс ЗЗК), "
"Элиза отвечала: \"What would it mean to you if you got gibble plix zzq\"(что "
"бы это значило для тебя, если бы ты получил гиббл пликс ЗЗК), не подозревая, "
"что что-то не так.\n"
"Другой пример оригинальной программы ELIZA состоит в том, что она "
"взаимодействует с другой программой, PARRY, которая была написана доктором "
"Кеннетом Колби для имитации параноидального поведения.\n"
"Далее следует часть разговора, с Элизой снова заглавными буквами и PARRY в "
"смешанном регистре:"

#: in/chapter5.md:85
msgid ""
"```text\n"
"I don't understand your motives.\n"
"WHY DON'T YOU UNDERSTAND MY MOTIVES?\n"
"Shouldn't I be?\n"
"WHY DO YOU SAY THAT JUST NOW?\n"
"That's just the way it is.\n"
"SUPPOSE THAT'S JUST THE WAY IT WERE NOT.\n"
"So?\n"
"I AM NOT SURE I UNDERSTAND YOU FULLY.\n"
"You harp on the same questions too much.\n"
"WHAT DOES THAT SIMILARITY SUGGEST TO YOU?\n"
"I don't get you.\n"
"DO YOU WISH THAT YOU DID GET I?\n"
"```"
msgstr ""

#: in/chapter5.md:88
msgid ""
"This suggests that neither ELIZA nor PARRY had a deep understanding of the "
"dialog.\n"
"When there is a human to take on most of the burden of carrying forth the "
"conversation, these programs can be convincing, but when the human is taken "
"out of the conversation, the weaknesses of the programs are revealed."
msgstr ""
"Это говорит о том, что ни ELIZA, ни PARRY не имели глубокого понимания "
"диалога.\n"
"Когда человек берет на себя большую часть бремени ведения разговора, эти "
"программы могут быть убедительными, но когда человека выводят из разговора, "
"обнаруживаются слабые места программ."

#: in/chapter5.md:91
msgid ""
"## 5.1 Describing and Specifying ELIZA\n"
"Now that we have an idea of what ELIZA is like, we can begin the description "
"and specification of the program, and eventually move to the implementation "
"and debugging."
msgstr ""
"## 5.1 Описание и Спецификация Элизы(ELIZA)\n"
"Теперь, когда у нас есть представление о том, на что похожа ELIZA, мы можем "
"начать описание и спецификацию программы и, в конечном итоге, перейти к "
"реализации и отладке."

#: in/chapter5.md:94
msgid ""
"The ELIZA algorithm can be described simply as: (1) read an input, (2) find "
"a pattern that matches the input, (3) transform the input into a response, "
"and (4) print the response.\n"
"These four steps are repeated for each input."
msgstr ""
"Алгоритм ELIZA можно описать просто как: (1) прочитать ввод, (2) найти "
"образец, который соответствует вводу, (3) преобразовать ввод в ответ и (4) "
"распечатать ответ.\n"
"Эти четыре шага повторяются для каждого ввода."

#: in/chapter5.md:96
msgid ""
"The specification and implementation of steps (1) and (4) are trivial: for "
"(1), use the built-in `read` function to read a list of words, and for (4) "
"use `print` to print the list of words in the response."
msgstr ""
"Спецификация и реализация шагов (1) и (4) тривиальны: для (1) используйте "
"встроенную функцию `read`, чтобы прочитать список слов, и для (4) "
"используйте `print`, чтобы распечатать список слов в ответе."

#: in/chapter5.md:100
msgid ""
"Of course, there are some drawbacks to this specification.\n"
"The user will have to type a real list-using parentheses-and the user can't "
"use characters that are special to `read`, like quotation marks, commas, and "
"periods.\n"
"So our input won't be as unconstrained as in the sample dialog, but that's a "
"small price to pay for the convenience of having half of the problem neatly "
"solved."
msgstr ""
"Конечно, у этой спецификации есть некоторые недостатки.\n"
"Пользователь должен будет ввести реальный список, используя круглые скобки, "
"и пользователь не может использовать символы, специальные для `read`, такие "
"как кавычки, запятые и точки.\n"
"Так что наш ввод не будет таким неограниченным, как в примере диалога, но "
"это небольшая плата за удобство аккуратного решения половины проблемы."

#: in/chapter5.md:106
msgid ""
"## 5.2 Pattern Matching\n"
"The hard part comes with steps (2) and (3)-this notion of pattern matching "
"and transformation.\n"
"There are four things to be concerned with: a general pattern and response, "
"and a specific input and transformation of that input.\n"
"Since we have agreed to represent the input as a list, it makes sense for "
"the other components to be lists too.\n"
"For example, we might have:"
msgstr ""
"## 5.2 Сопоставление с образцом\n"
"Самая сложная часть состоит в шагах (2) и (3) - это идея сопоставления с "
"образцом и преобразования.\n"
"Есть четыре вещи, о которых нужно позаботиться: общие образец и ответ, а "
"также конкретные ввод и преобразование этого ввода.\n"
"Поскольку мы согласились представить входные данные в виде списка, имеет "
"смысл, чтобы и другие компоненты тоже были списками.\n"
"Например, у нас может быть:"

#: in/chapter5.md:110
msgid ""
"```text\n"
"Pattern: (i need a X)\n"
"Response: (what would it mean to you if you got a X ?)"
msgstr ""
"```text\n"
"Образец: (i need a X)\n"
"Ответ: (what would it mean to you if you got a X ?)"

#: in/chapter5.md:114
msgid ""
"Input: (i need a vacation)\n"
"Transformation: (what would it mean to you if you got a vacation ?)\n"
"```"
msgstr ""
"Ввод: (i need a vacation)\n"
"Преобразование: (what would it mean to you if you got a vacation ?)\n"
"```"

#: in/chapter5.md:118
msgid ""
"The pattern matcher must match the literals `i` with `i`, `need` with "
"`need`, and `a` with `a`, as well as match the variable `X` with "
"`vacation`.\n"
"This presupposes that there is some way of deciding that `X` is a variable "
"and that `need` is not.\n"
"We must then arrange to substitute `vacation` for `X` within the response, "
"in order to get the final transformation."
msgstr ""
"Средство сопоставления с образцом должно сопоставить литералы `i` с `i`, "
"`need` с `need` и `a` с `a`, а также сопоставить переменную `X` с "
"`vacation`.\n"
"Это предполагает, что есть способ узнать, что `X` является переменной, а "
"`need` - нет.\n"
"Затем мы должны заменить в ответе для `X` на `vacation`, чтобы получить "
"окончательное преобразование."

#: in/chapter5.md:121
msgid ""
"Ignoring for a moment the problem of transforming the pattern into the "
"response, we can see that this notion of pattern matching is just a "
"generalization of the Lisp function `equal`.\n"
"Below we show the function `simple-equal`, which is like the built-in "
"function `equal`,<sup>[1](#chapter5-fn1)</sup> and the function `pat-match`, "
"which is extended to handle pattern-matching variables:"
msgstr ""
"Игнорируя на мгновение проблему преобразования шаблона в ответ, мы можем "
"увидеть, что это понятие сопоставления с образцом является просто обобщением "
"функции Лиспа `equal`.\n"
"Ниже мы показываем функцию `simple-equal`, которая похожа на встроенную "
"функцию `equal`, <sup>[1] (#chapter5-fn1)</sup> и функцию `pat-match`, "
"которая является её расширением для обработки переменных сопоставления с "
"образцом:"

#: in/chapter5.md:129
msgid ""
"```lisp\n"
"(defun simple-equal (x y)\n"
"   \"Are x and y equal?  (Don't check inside strings.)\"\n"
"   (if (or (atom x) (atom y))\n"
"       (eql x y)\n"
"       (and (simple-equal (first x) (first y))\n"
"\t    (simple-equal (rest x) (rest y)))))"
msgstr ""

#: in/chapter5.md:139
msgid ""
"(defun pat-match (pattern input)\n"
"  \"Does pattern match input? Any variable can match anything.\"\n"
"  (if (variable-p pattern)\n"
"      t\n"
"      (if (or (atom pattern) (atom input))\n"
"\t  (eql pattern input)\n"
"          (and (pat-match (first pattern) (first input))\n"
"\t       (pat-match (rest pattern) (rest input))))))\n"
"```"
msgstr ""

#: in/chapter5.md:141
msgid ""
"&#9635; **Exercise 5.1 [s]** Would it be a good idea to replace the complex "
"and form in `pat-match` with the simpler `(every #'pat-match pattern input)?`"
msgstr ""
"&#9635; **Exercise 5.1 [s]** Было бы неплохо заменить complex и form в `pat-"
"match` на более простую `(every #'pat-match pattern input)?`"

#: in/chapter5.md:149
msgid ""
"Before we can go on, we need to decide on an implementation for pattern-"
"matching variables.\n"
"We could, for instance, say that only a certain set of symbols, such as {X, "
"Y, Z}, are variables.\n"
"Alternately, we could define a structure of type `variable`, but then we'd "
"have to type something verbose like `(make-variable :name' X )` every time "
"we wanted one.\n"
"Another choice would be to use symbols, but to distinguish variables from "
"constants by the name of the symbol.\n"
"For example, in Prolog, variables start with capital letters and constants "
"with lowercase.\n"
"But Common Lisp is case-insensitive, so that won't work.\n"
"Instead, there is a tradition in Lisp-based AI programs to have variables be "
"symbols that start with the question mark character."
msgstr ""
"Прежде чем мы продолжим, нам нужно определиться с реализацией для переменных "
"сопоставления с образцом.\n"
"Мы могли бы, например, сказать, что только определенный набор символов, "
"таких как {X, Y, Z}, является переменными.\n"
"В качестве альтернативы мы могли бы определить структуру типа `variable`, но "
"тогда нам пришлось бы вводить что-то подробное, например `(make-variable :"
"name 'X )`, каждый раз, когда нам это нужно.\n"
"Другой вариант - использовать символы, но отличать переменные от констант по "
"имени символа.\n"
"Например, в Прологе переменные начинаются с заглавных букв, а константы - со "
"строчных.\n"
"Но Common Lisp нечувствителен к регистру, так что это не сработает.\n"
"Вместо этого в программах ИИ на основе Лиспа существует традиция, когда "
"переменные представляют собой символы, начинающиеся с знака вопроса."

#: in/chapter5.md:156
msgid ""
"So far we have dealt with symbols as atoms-objects with no internal "
"structure.\n"
"But things are always more complicated than they first appear and, as in "
"Lisp as in physics, it turns out that even atoms have components.\n"
"In particular, symbols have names, which are strings and are accessible "
"through the `symbol-name` function.\n"
"Strings in turn have elements that are characters, accessible through the "
"function `char`.\n"
"The character '?' is denoted by the self-evaluating escape sequence `#\\?`.\n"
"So the predicate `variable-p` can be defined as follows, and we now have a "
"complete pattern matcher:"
msgstr ""
"До сих пор мы рассматривали символы как атомы - т.е. объекты без внутренней "
"структуры.\n"
"Но все всегда сложнее, чем кажется на первый взгляд, оказывается в Лиспе, "
"как и в физике, даже атомы имеют компоненты.\n"
"В частности, символы имеют имена, которые являются строками и доступны через "
"функцию `symbol-name`.\n"
"Строки, в свою очередь, имеют элементы, которые являются символьными "
"знаками, доступными через функцию `char`.\n"
"Символьный знак '?' обозначается самовычисляемой escape-последовательностью  "
"`#\\?`.\n"
"Итак, предикат `variable-p` может быть определен следующим образом, и теперь "
"у нас есть полный сопоставитель с образцом:"

#: in/chapter5.md:161
msgid ""
"```lisp\n"
"(defun variable-p (x)\n"
"  \"Is X a variable (a symbol beginning with '?')?\"\n"
"  (and (symbolp x) (equal (char (symbol-name x) 0) #\\?)))"
msgstr ""

#: in/chapter5.md:164
msgid ""
"> (pat-match '(I need a ?X) '(I need a vacation))\n"
"T"
msgstr ""

#: in/chapter5.md:168
msgid ""
"> (pat-match '(I need a ?X) ' (I really need a vacation))\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter5.md:182
msgid ""
"In each case we get the right answer, but we don't get any indication of "
"what `?X` is, so we couldn't substitute it into the response.\n"
"We need to modify `pat-match` to return some kind of table of variables and "
"corresponding values.\n"
"In making this choice, the experienced Common Lisp programmer can save some "
"time by being opportunistic: recognizing when there is an existing function "
"that will do a large part of the task at hand.\n"
"What we want is to substitute values for variables throughout the response.\n"
"The alert programmer could refer to the index of this book or the Common "
"Lisp reference manual and find the functions `substitute`, `subst`, and "
"`sublis`.\n"
"All of these substitute some new expression for an old one within an "
"expression.\n"
"It turns out that `sublis` is most appropriate because it is the only one "
"that allows us to make several substitutions all at once.\n"
"`sublis` takes two arguments, the first a list of old-new pairs, and the "
"second an expression in which to make the substitutions.\n"
"For each one of the pairs, the `car` is replaced by the `cdr`.\n"
"In other words, we would form each pair with something like `(cons old "
"new)`.\n"
"(Such a list of pairs is known as an *association list*, or *a-list,* "
"because it associates keys with values.\n"
"See section 3.6.)\n"
"In terms of the example above, we would use:"
msgstr ""
"В каждом случае мы получаем правильный ответ, но не получаем никаких "
"указаний на то, что такое `?X`, поэтому мы не можем подставить его в ответ.\n"
"Нам нужно изменить `pat-match`, чтобы она возвращала какую-то таблицу "
"переменных и соответствующих им значений.\n"
"Сделав этот выбор, опытный программист на Common Lisp может сэкономить "
"время, проявив гибкость: он сразу распознает, когда существует функция, "
"которая сможет выполнить большую часть поставленной задачи.\n"
"Мы хотим подставлять значения для переменных во всем ответе.\n"
"Предупрежденный программист может обратиться к указателю этой книги или "
"справочному руководству Common Lisp и найти функции `substitute`, `subst` и "
"`sublis`.\n"
"Все они заменяют старое выражение новым выражением внутри выражения.\n"
"Оказывается, что `sublis` является наиболее подходящим, потому что она "
"единственная, которая позволяет нам делать несколько замен одновременно.\n"
"`sublis` принимает два аргумента, первый - это список пар старый-новый, а "
"второй - выражение, в котором должны быть сделаны замены.\n"
"Для каждой из пар `car` заменяется на `cdr`.\n"
"Другими словами, мы должны сформировать каждую пару так: `(cons old new)`.\n"
"(Такой список пар известен как *список ассоциаций/ассоциативный список* или "
"*a-list*, потому что он связывает ключи со значениями.\n"
"См. Раздел 3.6.)\n"
"В терминах приведенного выше примера мы бы использовали:"

#: in/chapter5.md:188
msgid ""
"```lisp\n"
"> (sublis '((?X . vacation))\n"
"          '(what would it mean to you if you got a ?X ?))\n"
"(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)\n"
"```"
msgstr ""

#: in/chapter5.md:191
msgid ""
"Now we need to arrange for `pat-match` to return an a-list, rather than just "
"T for success.\n"
"Here's a first attempt:"
msgstr ""
"Теперь нам нужно сделать так, чтобы `pat-match` возвращал a-list, а не "
"просто T в случае успеха.\n"
"Вот первая попытка:"

#: in/chapter5.md:202
msgid ""
"```lisp\n"
"(defun pat-match (pattern input)\n"
"   \"Does pattern match input? WARNING: buggy version.\"\n"
"   (if (variable-p pattern)\n"
"       (list (cons pattern input))\n"
"       (if (or (atom pattern) (atom input))\n"
"\t   (eql pattern input)\n"
"\t   (append (pat-match (first pattern) (first input))\n"
"\t\t   (pat-match (rest pattern) (rest input))))))\n"
"```"
msgstr ""

#: in/chapter5.md:212
msgid ""
"This implementation looks reasonable: it returns an a-list of one element if "
"the pattern is a variable, and it appends alists if the pattern and input "
"are both lists.\n"
"However, there are several problems.\n"
"First, the test `(eql pattern input)` may return `T`, which is not a list, "
"so `append` will complain.\n"
"Second, the same test might return nil, which should indicate failure, but "
"it will just be treated as a list, and will be appended to the rest of the "
"answer.\n"
"Third, we haven't distinguished between the case where the match fails-and "
"returns nil-versus the case where everything matches, but there are no "
"variables, so it returns the null a-list.\n"
"(This is the semipredicate problem discussed on page 127.)\n"
"Fourth, we want the bindings of variables to agree-if `?X` is used twice in "
"the pattern, we don't want it to match two different values in the input.\n"
"Finally, it is inefficient for `pat-match` to check both the `first` and "
"`rest` of lists, even when the corresponding `first` parts fail to match.\n"
"(Isn't it amazing that there could be five bugs in a seven-line function?)"
msgstr ""
"Эта реализация выглядит разумной: она возвращает a-list из одного элемента, "
"если образец является переменной, и соединяет(append) ассоциативные списки, "
"если образец и вход являются списками.\n"
"Однако есть несколько проблем.\n"
"Во-первых, тест `(eql pattern input)` может вернуть `T`, который не является "
"списком, поэтому `append` будет жаловаться.\n"
"Во-вторых, тот же тест может вернуть nil, что должно указывать на сбой, но "
"он будет рассматриваться просто как список и будет добавлен к остальной "
"части ответа.\n"
"В-третьих, мы не различаем случай, когда совпадение не удается и "
"возвращается nil, и случай, когда все совпадает, но нет переменных, поэтому "
"он возвращается nil - нулевой a-list.\n"
"(Это проблема полупредиката, обсуждаемая на стр. 127.)\n"
"В-четвертых, мы хотим, чтобы привязки переменных согласовывались - если `?X` "
"используется дважды в образце, мы не хотим, чтобы он совпадал с двумя "
"разными значениями во входных данных.\n"
"Наконец, для `pat-match` неэффективно проверять и `first` и `rest` списков, "
"даже если соответствующие части `first` не совпадают.\n"
"(Разве не удивительно, что в семистрочной функции может быть пять ошибок?)"

#: in/chapter5.md:219
msgid ""
"We can resolve these problems by agreeing on two major conventions.\n"
"First, it is very convenient to make `pat-match` a true predicate, so we "
"will agree that it returns `nil` only to indicate failure.\n"
"That means that we will need a non-nil value to represent the empty binding "
"list.\n"
"Second, if we are going to be consistent about the values of variables, then "
"the `first` will have to know what the `rest` is doing.\n"
"We can accomplish this by passing the binding list as a third argument to "
"`pat-match`.\n"
"We make it an optional argument, because we want to be able to say simply "
"`(pat-match *a b*)`."
msgstr ""
"Мы можем решить эти проблемы, договорившись о двух основных соглашениях.\n"
"Во-первых, очень удобно сделать `pat-match` истинным предикатом, поэтому мы "
"согласимся, что он возвращает `nil` только для обозначения неудачи.\n"
"Это означает, что для представления пустого списка привязок нам понадобится "
"значение, отличное от nil.\n"
"Во-вторых, если мы собираемся быть последовательными в отношении значений "
"переменных, то первое(`first`) должно будет знать, что делают "
"остальные(`rest`).\n"
"Мы можем добиться этого, передав список привязок в качестве третьего "
"аргумента функции `pat-match`.\n"
"Мы сделаем его необязательным аргументом, потому что хотим иметь возможность "
"просто сказать `(pat-match a b)`."

#: in/chapter5.md:225
msgid ""
"To abstract away from these implementation decisions, we define the "
"constants `fail` and `no-bindings` to represent the two problematic return "
"values.\n"
"The special form `defconstant` is used to indicate that these values will "
"not change.\n"
"(It is customary to give special variables names beginning and ending with "
"asterisks, but this convention usually is not followed for constants.\n"
"The reasoning is that asterisks shout out, \"Careful!\n"
"I may be changed by something outside of this lexical scope.\" Constants, of "
"course, will not be changed.)"
msgstr ""
"Чтобы абстрагироваться от этих решений реализации, мы определяем константы "
"`fail` и `no-bindings` для представления двух проблемных возвращаемых "
"значений.\n"
"Специальная форма defconstant используется для обозначения того, что эти "
"значения не изменятся.\n"
"(Принято давать специальные имена переменных, начинающиеся и заканчивающиеся "
"звездочками, но это соглашение обычно не соблюдается для констант.\n"
"Причина в том, что звездочки кричат: \"Осторожно!\n"
"Я могу быть изменен чем-то за пределами этой лексической области.\" "
"Константы, конечно, не будут изменены.)"

#: in/chapter5.md:228
msgid ""
"```lisp\n"
"(defconstant fail nil \"Indicates pat-match failure\")"
msgstr ""

#: in/chapter5.md:232
msgid ""
"(defconstant no-bindings '((t . t))\n"
"  \"Indicates pat-match success, with no variables.\")\n"
"```"
msgstr ""

#: in/chapter5.md:234
msgid ""
"Next, we abstract away from `assoc` by introducing the following four "
"functions:"
msgstr "Затем мы абстрагируемся от `assoc`, введя следующие четыре функции:"

#: in/chapter5.md:239
msgid ""
"```lisp\n"
"(defun get-binding (var bindings)\n"
"  \"Find a (variable . value) pair in a binding list.\"\n"
"  (assoc var bindings))"
msgstr ""

#: in/chapter5.md:243
msgid ""
"(defun binding-val (binding)\n"
"  \"Get the value part of a single binding.\"\n"
"  (cdr binding))"
msgstr ""

#: in/chapter5.md:247
msgid ""
"(defun lookup (var bindings)\n"
"  \"Get the value part (for var) from a binding list.\"\n"
"  (binding-val (get-binding var bindings)))"
msgstr ""

#: in/chapter5.md:252
msgid ""
"(defun extend-bindings (var val bindings)\n"
"  \"Add a (var . value) pair to a binding list.\"\n"
"  (cons (cons var val) bindings))\n"
"```"
msgstr ""

#: in/chapter5.md:261
msgid ""
"Now that variables and bindings are defined, `pat-match` is easy.\n"
"It consists of five cases.\n"
"First, if the binding list is `fail`, then the match fails (because some "
"previous match must have failed).\n"
"If the pattern is a single variable, then the match returns whatever `match-"
"variable` returns; either the existing binding list, an extended one, or "
"`fail`.\n"
"Next, if both pattern and input are lists, we first call `pat-match` "
"recursively on the first element of each list.\n"
"This returns a binding list (or `fail`), which we use to match the rest of "
"the lists.\n"
"This is the only case that invokes a nontrivial function, so it is a good "
"idea to informally prove that the function will terminate: each of the two "
"recursive calls reduces the size of both pattern and input, and `pat-match` "
"checks the case of atomic patterns and inputs, so the function as a whole "
"must eventually return an answer (unless both pattern and input are of "
"infinite size).\n"
"If none of these four cases succeeds, then the match fails."
msgstr ""
"Теперь, когда определены переменные и привязки, реализация `pat-match` очень "
"проста.\n"
"Она состоит из пяти случаев.\n"
"Во-первых, если список привязки - `fail`, то сопоставление не удачно (потому "
"что какое-то предыдущее сопоставление должно было быть неудачным).\n"
"Если образец представляет собой единственную переменную, то совпадение "
"возвращает все, что возвращает `match-variable`; либо существующий список "
"привязки, либо расширенный, либо `fail`.\n"
"Затем, если и образец, и входные данные являются списками, мы сначала "
"рекурсивно вызываем `pat-match` для первого элемента каждого списка.\n"
"Она возвращает список привязки (или `fail`), который мы используем для "
"сопоставления с оставшимися списками.\n"
"Это единственный случай, когда вызывается нетривиальная функция, поэтому "
"неплохо неформально доказать, что функция завершится: каждый из двух "
"рекурсивных вызовов уменьшает размер как образца, так и ввода, а `pat-match` "
"проверяет случай атомарных образцов и входных данных, поэтому функция в "
"целом должна в конечном итоге вернуть ответ (если и образец, и входные "
"данные не имеют бесконечного размера).\n"
"Если ни один из этих четырех случаев неуспешен, то совпадение считается "
"неудачным."

#: in/chapter5.md:274
msgid ""
"```lisp\n"
"(defun pat-match (pattern input &optional (bindings no-bindings))\n"
"   \"Match pattern against input in the context of the bindings\"\n"
"   (cond ((eq bindings fail) fail)\n"
"\t ((variable-p pattern)\n"
"\t  (match-variable pattern input bindings))\n"
"\t ((eql pattern input) bindings)\n"
"\t ((and (consp pattern) (consp input))\n"
"\t  (pat-match (rest pattern) (rest input)\n"
"\t\t     (pat-match (first pattern) (first input)\n"
"\t\t\t\tbindings)))\n"
"\t (t fail)))"
msgstr ""

#: in/chapter5.md:282
msgid ""
"(defun match-variable (var input bindings)\n"
"  \"Does VAR match input? Uses (or updates) and returns bindings.\"\n"
"  (let ((binding (get-binding var bindings)))\n"
"    (cond ((not binding) (extend-bindings var input bindings))\n"
"\t  ((equal input (binding-val binding)) bindings)\n"
"\t  (t fail))))\n"
"```"
msgstr ""

#: in/chapter5.md:284
msgid "We can now test `pat-match` and see how it works:"
msgstr ""
"Теперь мы можем протестировать `pat-match` и посмотреть, как это работает:"

#: in/chapter5.md:289
msgid ""
"```lisp\n"
"> (pat-match '(i need a ?X) '(i need a vacation))\n"
"((?X . VACATION) (T . T))\n"
"```"
msgstr ""

#: in/chapter5.md:293
msgid ""
"The answer is a list of variable bindings in dotted pair notation; each "
"element of the list is a (`*variable . value*`) pair.\n"
"The `(T . T)` is a remnant from `no-bindings`.\n"
"It does no real harm, but we can eliminate it by making `extend-bindings` a "
"little more complicated:"
msgstr ""
"Ответ представляет собой список привязок переменных в виде точечных пар; "
"каждый элемент списка представляет собой пару (`variable . value`).\n"
"`(T. T)` является признаком `no-bindings`.\n"
"Он не наносит реального вреда, но мы можем устранить это, немного усложнив "
"`extend-bindings`:"

#: in/chapter5.md:303
msgid ""
"```lisp\n"
"(defun extend-bindings (var val bindings)\n"
"   \"Add a (var . value) pair to a binding list. \"\n"
"   (cons (cons var val)\n"
"\t ;; Once we add a \"real\" binding,\n"
"\t ;; we can get rid of the dummy no-bindings\n"
"\t (if (eq bindings no-bindings)\n"
"\t     nil\n"
"\t     bindings)))"
msgstr ""

#: in/chapter5.md:307
msgid ""
"> (sublis (pat-match ' (i need a ?X) ' (i need a vacation))\n"
"          '(what would it mean to you if you got a ?X ?))\n"
"(WHAT WOULD IT MEAN TO YOU IF YOU GOT A VACATION ?)"
msgstr ""

#: in/chapter5.md:310
msgid ""
"> (pat-match ' (i need a ?X) ' (i really need a vacation))\n"
"NIL"
msgstr ""

#: in/chapter5.md:313
msgid ""
"> (pat-match ' (this is easy) ' (this is easy))\n"
"((T . T))"
msgstr ""

#: in/chapter5.md:316
msgid ""
"> (pat-match ' (?X is ?X) ' ((2 + 2) is 4))\n"
"NIL"
msgstr ""

#: in/chapter5.md:319
msgid ""
"> (pat-match ' (?X is ?X) ' ((2 + 2) is (2 + 2)))\n"
"((?X 2 + 2))"
msgstr ""

#: in/chapter5.md:323
msgid ""
"> (pat-match ' (?P need . ?X) ' (i need a long vacation))\n"
"((?X A LONG VACATION) (?P . I ))\n"
"```"
msgstr ""
"> (pat-match ' (?P need . ?X) ' (i need a long vacation))\n"
"((?X A LONG VACATION) (?P . I ))\n"
"```\n"
"\n"
"Важное замечание: точка в конце шаблона, говорит о том, что последняя "
"переменная может соответствовать всей оставшейся части ввода.\n"
"\n"

#: in/chapter5.md:327
msgid ""
"Notice the distinction between `NIL` and `((T . T))`.\n"
"The latter means that the match succeeded, but there were no bindings to "
"return.\n"
"Also, remember that `(?X 2 + 2)` means the same as `(?X . (2 + 2))`."
msgstr ""
"Обратите внимание на различие между `NIL` и `((T . T))`.\n"
"Последнее означает, что совпадение прошло успешно, но привязок для возврата "
"нет.\n"
"Также запомните, что `(?X 2 + 2)` означает то же самое, что `(?X . (2 + 2))`."

#: in/chapter5.md:331
msgid ""
"A more powerful implementation of `pat-match` is given in chapter 6.\n"
"Yet another implementation is given in section 10.4.\n"
"It is more efficient but more cumbersome to use."
msgstr ""
"Более мощная реализация `pat-match` дается в главе 6.\n"
"Еще одна реализация приведена в разделе 10.4.\n"
"Она более эффективна, но более громоздка в использовании."

#: in/chapter5.md:342
msgid ""
"## 5.3 Segment Pattern Matching\n"
"In the pattern `(?P need . ?X)`, the variable `?X` matches the rest of the "
"input list, regardless of its length.\n"
"This is in contrast to `?P`, which can only match a single element, namely, "
"the first element of the input.\n"
"For many applications of pattern matching, this is fine; we only want to "
"match corresponding elements.\n"
"However, ELIZA is somewhat different in that we need to account for "
"variables in any position that match a sequence of items in the input.\n"
"We will call such variables *segment variables.* We will need a notation to "
"differentiate segment variables from normal variables.\n"
"The possibilities fall into two classes: either we use atoms to represent "
"segment variables and distinguish them by some spelling convention (as we "
"did to distinguish variables from constants) or we use a nonatomic "
"construct.\n"
"We will choose the latter, using a list of the form (`?*`*variable*) to "
"denote segment variables.\n"
"The symbol `?*` is chosen because it combines the notion of variable with "
"the Kleenestar notation.\n"
"So, the behavior we want from `pat-match` is now:"
msgstr ""
"## 5.3 Сопоставление с сегментным образцом\n"
"В образце `(?P need . ?X)` переменная `?X` соответствует остальной части "
"входного списка(остатку), независимо от его длины.\n"
"И в этом её отличие от `?P`, которая может соответствовать только одному "
"элементу, а именно первому элементу ввода.\n"
"Для многих приложений сопоставление с образцом это обычное дело; мы хотим "
"сопоставить только соответствующие элементы.\n"
"Однако ELIZA несколько отличается тем, что она учитывает переменные в любой "
"позиции, которые могут соответствовать последовательности элементов во "
"входных данных.\n"
"Мы будем называть такие переменные *сегментными переменными*.  Нам "
"понадобится обозначение, чтобы отличать сегментные переменные от обычных "
"переменных.\n"
"Возможны два класса обозначений: либо мы используем атомы для представления "
"сегментных переменных и различаем их по определенному правилу написания (как "
"мы это делали, чтобы отличать переменные от констант), либо мы используем "
"неатомарную конструкцию.\n"
"Мы выберем последний вариант, используем список вида (`?*` *Variable*) для "
"обозначения сегментных переменных.\n"
"Символ `?*` выбран потому, что он объединяет понятие переменной с "
"обозначением Kleenestar.\n"
"Итак, поведение, которое мы хотим от `pat-match`, таково:"

#: in/chapter5.md:348
msgid ""
"```lisp\n"
"> (pat-match '((?* ?p) need (?* ?x))\n"
"             '(Mr Hulot and I need a vacation))\n"
"((?P MR HULOT AND I) (?X A VACATION))\n"
"```"
msgstr ""

#: in/chapter5.md:352
msgid ""
"In other words, when both pattern and input are lists and the first element "
"of the pattern is a segment variable, then the variable will match some "
"initial part of the input, and the rest of the pattern will attempt to match "
"the rest.\n"
"We can update `pat-match` to account for this by adding a single cond-"
"clause.\n"
"Defining the predicate to test for segment variables is also easy:"
msgstr ""
"Другими словами, когда и образец, и ввод являются списками, а первый элемент "
"образца является сегментной переменной, тогда переменная будет сопоставлена "
"некоторой начальной части ввода, а остальная часть образца будет "
"сопоставлена остатку ввода.\n"
"Мы можем обновить `pat-match`, чтобы учесть это, добавив единственное "
"условие cond.\n"
"Также легко определить предикат для проверки сегментных переменных:"

#: in/chapter5.md:367
msgid ""
"```lisp\n"
" (defun pat-match (pattern input &optional (bindings no-bindings))\n"
"   \"Match pattern against input in the context of the bindings\"\n"
"   (cond ((eq bindings fail) fail)\n"
"\t ((variable-p pattern)\n"
"\t  (match-variable pattern input bindings))\n"
"\t ((eql pattern input) bindings)\n"
"\t ((segment-pattern-p pattern)                ; ***\n"
"\t  (segment-match pattern input bindings))    ; ***\n"
"\t ((and (consp pattern) (consp input))\n"
"\t  (pat-match (rest pattern) (rest input)\n"
"\t\t     (pat-match (first pattern) (first input)\n"
"\t\t\t\tbindings)))\n"
"\t (t fail)))"
msgstr ""

#: in/chapter5.md:373
msgid ""
"(defun segment-pattern-p (pattern)\n"
"  \"Is this a segment matching pattern: ((?* var) . pat)\"\n"
"  (and (consp pattern)\n"
"       (starts-with (first pattern) '?*)))\n"
"```"
msgstr ""

#: in/chapter5.md:383
msgid ""
"In writing `segment-match`, the important question is how much of the input "
"the segment variable should match.\n"
"One answer is to look at the next element of the pattern (the one after the "
"segment variable) and see at what position it occurs in the input.\n"
"If it doesn't occur, the total pattern can never match, and we should "
"`fail`.\n"
"If it does occur, call its position `pos`.\n"
"We will want to match the variable against the initial part of the input, up "
"to `pos`.\n"
"But first we have to see if the rest of the pattern matches the rest of the "
"input.\n"
"This is done by a recursive call to `pat-match`.\n"
"Let the result of this recursive call be named `b2`.\n"
"If `b2` succeeds, then we go ahead and match the segment variable against "
"the initial subsequence."
msgstr ""
"При написании `segment-match` важный вопрос состоит в том, какой части ввода "
"должна соответствовать сегментная переменная.\n"
"Один из ответов - посмотреть на следующий элемент образца (тот, который "
"стоит после переменной сегмента) и посмотреть, в какой позиции он "
"встречается во входных данных.\n"
"Если этого не происходит, весь образец никогда не может совпасть, и мы "
"должны - потерпеть неудачу (`fail`).\n"
"Если это происходит, назовем его позицию(позицию совпадения) `pos`.\n"
"Тогда мы сопоставляем переменную с начальной частью ввода, вплоть до позиции "
"`pos`.\n"
"Но сначала мы должны посмотреть, соответствует ли оставшаяся часть образца "
"оставшейся части ввода.\n"
"Это делается рекурсивным вызовом `pat-match`.\n"
"Пусть результат этого рекурсивного вызова будет называться `b2`.\n"
"Если `b2` успешно, то мы идем дальше и сопоставляем сегментную переменную с "
"начальной подпоследовательностью."

#: in/chapter5.md:390
msgid ""
"The tricky part is when `b2` fails.\n"
"We don't want to give up completely, because it may be that if the segment "
"variable matched a longer subsequence of the input, then the rest of the "
"pattern would match the rest of the input.\n"
"So what we want is to try `segment-match` again, but forcing it to consider "
"a longer match for the variable.\n"
"This is done by introducing an optional parameter, `start`, which is "
"initially 0 and is increased with each failure.\n"
"Notice that this policy rules out the possibility of any kind of variable "
"following a segment variable.\n"
"(Later we will remove this constraint.)"
msgstr ""
"Возникает сложность - когда `b2` неудача.\n"
"Мы не хотим полностью сдаваться, потому что может случиться так, что если "
"сегментная переменная соответствует более длинной подпоследовательности "
"ввода, тогда остальная часть образца будет соответствовать оставшейся части "
"ввода.\n"
"Итак, мы хотим снова попробовать `segment-match`, но заставить его учитывать "
"более длительное совпадение для переменной.\n"
"Это делается путем введения необязательного параметра `start`, который "
"изначально равен 0 и увеличивается с каждой ошибкой.\n"
"Обратите внимание, что это правило исключает возможность любой вид "
"переменных после сегментной переменной.\n"
"(Позже мы снимем это ограничение.)"

#: in/chapter5.md:411
msgid ""
"```lisp\n"
"(defun segment-match (pattern input bindings &optional (start 0))\n"
"   \"Match the segment pattern ((?* var) . pat) against input.\"\n"
"   (let ((var (second (first pattern)))\n"
"\t (pat (rest pattern)))\n"
"     (if (null pat)\n"
"\t (match-variable var input bindings)\n"
"\t ;; We assume that pat starts with a constant\n"
"\t ;; In other words, a pattern can't have 2 consecutive vars\n"
"\t (let ((pos (position (first pat) input\n"
"\t\t\t      :start start :test #'equal)))\n"
"\t   (if (null pos)\n"
"\t       fail\n"
"\t       (let ((b2 (pat-match pat (subseq input pos) bindings)))\n"
"\t\t ;; If this match failed, try another longer one\n"
"\t\t ;; If it worked, check that the variables match\n"
"\t\t (if (eq b2 fail)\n"
"\t\t     (segment-match pattern input bindings (+ pos 1))\n"
"\t\t     (match-variable var (subseq input 0 pos) b2))))))))\n"
"```"
msgstr ""

#: in/chapter5.md:413
msgid "Some examples of segment matching follow:"
msgstr "Ниже приведены некоторые примеры сопоставления сегментов:"

#: in/chapter5.md:418
msgid ""
"```lisp\n"
"> (pat-match '((?* ?p) need (?* ?x))\n"
"       '(Mr Hulot and I need a vacation))\n"
"((?P MR HULOT AND I) (?X A VACATION))"
msgstr ""

#: in/chapter5.md:422
msgid ""
"> (pat-match '((?* ?x) is a (?* ?y)) '(what he is is a fool))\n"
"((?X WHAT HE IS) (?Y FOOL))\n"
"```"
msgstr ""

#: in/chapter5.md:428
msgid ""
"The first of these examples shows a fairly simple case: `?p` matches "
"everything up to need, and `?x` matches the rest.\n"
"The next example involves the more complicated backup case.\n"
"First `?x` matches everything up to the first `is` (this is position 2, "
"since counting starts at 0 in Common Lisp).\n"
"But then the pattern a fails to match the input `is`, so `segment-match` "
"tries again with starting position 3.\n"
"This time everything works; `is` matches `is`, `a` matches a, and `(?* ?y)` "
"matches `fool`."
msgstr ""
"Первый из этих примеров показывает довольно простой случай: `?p` "
"соответствует всему, до need, а `?x` соответствует остальному.\n"
"В следующем примере рассматривается более сложный случай.\n"
"Первый `?x` соответствует всему, вплоть до первого `is` (это позиция 2, "
"поскольку счет начинается с 0 в Common Lisp).\n"
"Но тогда образец a не соответствует `is` из входных данных, `segment-match` "
"пытается начать снова с начальной позиции 3.\n"
"На этот раз все работает; `is` соответствует `is`, `a` соответствует `a` и "
"`(?* ?y)` соответствует `fool`."

#: in/chapter5.md:431
msgid ""
"Unfortunately, this version of `segment-match` does not match as much as it "
"should.\n"
"Consider the following example:"
msgstr ""
"К сожалению, эта версия `segment-match` не находит многие соответствия, как "
"это должно быть.\n"
"Рассмотрим следующий пример:"

#: in/chapter5.md:435
msgid ""
"```lisp\n"
"> (pat-match '((?* ?x) a b (?* ?x)) '(1 2 a b a b 1 2 a b)) â NIL\n"
"```"
msgstr ""

#: in/chapter5.md:438
msgid ""
"This fails because `?x` is matched against the subsequence `(1 2)`, and then "
"the remaining pattern successfully matches the remaining input, but the "
"final call to `match-variable` fails, because `?x` has two different "
"values.\n"
"The fix is to call `match-variable` before testing whether the `b2` fails, "
"so that we will be sure to try `segment-match` again with a longer match no "
"matter what the cause of the failure."
msgstr ""
"Функция терпит неудачу, потому что `?x` сопоставляется с "
"подпоследовательностью `(1 2)`, и тогда оставшийся образец успешно "
"соответствует оставшемуся входу, но окончательный вызов `match-variable` "
"завершается неудачей, потому что `?x` имеет два различных значения.\n"
"Исправление состоит в том, чтобы вызвать `match-variable` перед проверкой, "
"не является ли `b2` неудачей, так что мы обязательно попробуем `segment-"
"match` снова с более длинным соответствием независимо от причины сбоя."

#: in/chapter5.md:461
msgid ""
"```lisp\n"
"(defun segment-match (pattern input bindings &optional (start 0))\n"
"   \"Match the segment pattern ((?* var) . pat) against input.\"\n"
"   (let ((var (second (first pattern)))\n"
"\t (pat (rest pattern)))\n"
"     (if (null pat)\n"
"\t (match-variable var input bindings)\n"
"\t ;; We assume that pat starts with a constant\n"
"\t ;; In other words, a pattern can't have 2 consecutive vars\n"
"\t (let ((pos (position (first pat) input\n"
"\t\t\t      :start start :test #'equal)))\n"
"\t   (if (null pos)\n"
"\t       fail\n"
"\t       (let ((b2 (pat-match\n"
"\t\t\t  pat (subseq input pos)\n"
"\t\t\t  (match-variable var (subseq input 0 pos)\n"
"\t\t\t\t\t  bindings))))\n"
"\t\t ;; If this match failed, try another longer one\n"
"\t\t (if (eq b2 fail)\n"
"\t\t     (segment-match pattern input bindings (+ pos 1))\n"
"\t\t     b2)))))))\n"
"```"
msgstr ""

#: in/chapter5.md:463
msgid "Now we see that the match goes through:"
msgstr "Теперь мы видим, что поиск соответствия идет до конца:"

#: in/chapter5.md:468
msgid ""
"```lisp\n"
"> (pat-match '((?* ?x) a b (?* ?x)) '(1 2 a b a b 1 2 a b))\n"
"((?X 1 2 A B))\n"
"```"
msgstr ""

#: in/chapter5.md:471
msgid ""
"Note that this version of `segment-match` tries the shortest possible match "
"first.\n"
"It would also be possible to try the longest match first."
msgstr ""
"Обратите внимание, что эта версия `segment-match` сначала пытается найти "
"самое короткое совпадение.\n"
"Также можно было бы сначала попробовать самое длинное соответствие."

#: in/chapter5.md:477
msgid ""
"## 5.4 The ELIZA Program: A Rule-Based Translator\n"
"Now that we have a working pattern matcher, we need some patterns to match.\n"
"What's more, we want the patterns to be associated with responses.\n"
"We can do this by inventing a data structure called a `rule`, which consists "
"of a pattern and one or more associated responses.\n"
"These are rules in the sense that they assert, \"If you see A, then respond "
"with B or C, chosen at random.\" We will choose the simplest possible "
"implementation for rules: as lists, where the first element is the pattern "
"and the rest is a list of responses:"
msgstr ""
"## 5.4 Программа Элиза: Преобразователь на основе правил\n"
"Теперь, когда у нас есть работающий сопоставитель с образцом, нам нужно "
"сопоставить несколько образцов.\n"
"Более того, мы хотим, чтобы образцы были связаны с ответами.\n"
"Мы можем сделать это, придумав структуру данных, называемую `rule`(правило), "
"которая состоит из образца и одного или нескольких связанных ответов.\n"
"Это правила в том смысле, что они утверждают: \"Если вы видите A, то "
"ответьте B или C, выбранными наугад\". Мы выберем простейшую возможную "
"реализацию правил: в виде списков, где первый элемент - это образец, а "
"остаток - список ответов:\n"

#: in/chapter5.md:480
msgid ""
"```lisp\n"
"(defun rule-pattern (rule) (first rule))"
msgstr ""

#: in/chapter5.md:483
msgid ""
"(defun rule-responses (rule) (rest rule))\n"
"```"
msgstr ""

#: in/chapter5.md:485
msgid "Here's an example of a rule:"
msgstr "Вот пример правила:"

#: in/chapter5.md:492
msgid ""
"```lisp\n"
"(((?* ?x) I want (?* ?y))\n"
" (What would it mean if you got ?y)\n"
" (Why do you want ?y)\n"
" (Suppose you got ?y soon))\n"
"```"
msgstr ""

#: in/chapter5.md:494
msgid ""
"When applied to the input `(I want to test this program)`, this rule (when "
"interpreted by the ELIZA program) would pick a response at random, "
"substitute in the value of `?y`, and respond with, say, `(why do you want to "
"test this program)`."
msgstr ""
"При применении к входным данным: `(I want to test this program)`, т.е. `(я "
"хочу протестировать эту программу)` это правило (при интерпретации "
"программой ELIZA) выбирает ответ случайным образом, подставляет в `?y` "
"значение и отвечает, скажем: `(why do you want to test this program)`, т.е "
"`(почему вы хотите протестировать эту программу)`."

#: in/chapter5.md:499
msgid ""
"Now that we know what an individual rule will do, we need to decide how to "
"handle a set of rules.\n"
"If ELIZA is to be of any interest, it will have to have a variety of "
"responses.\n"
"So several rules may all be applicable to the same input.\n"
"One possibility would be to choose a rule at random from among the rules "
"having patterns that match the input."
msgstr ""
"Теперь, когда мы знаем, что будет делать отдельное правило, нам нужно "
"решить, как обрабатывать набор правил.\n"
"Если мы хотим, чтобы ELIZA представляла интерес, у нее должно быть множество "
"ответов.\n"
"Таким образом, к одному и тому же входу могут применяться несколько правил.\n"
"Одна из возможностей - выбрать случайным образом правило из набора правил, "
"имеющих образцы, соответствующие входным данным."

#: in/chapter5.md:503
msgid ""
"Another possibility is just to accept the first rule that matches.\n"
"This implies that the rules form an ordered list, rather than an unordered "
"set.\n"
"The clever ELIZA rule writer can take advantage of this ordering and arrange "
"for the most specific rules to come first, while more vague rules are near "
"the end of the list."
msgstr ""
"Другой вариант - просто принять первое подходящее правило.\n"
"Это означает, что правила формируют упорядоченный список, а не "
"неупорядоченное множество.\n"
"Умный составитель правил для ELIZA может воспользоваться этим "
"упорядочиванием и сделать так, чтобы наиболее конкретные правила были на "
"первом месте, в то время как более расплывчатые правила находились ближе к "
"концу списка.\n"

#: in/chapter5.md:507
msgid ""
"The original ELIZA had a system where each rule had a priority number "
"associated with it.\n"
"The matching rule with the highest priority was chosen.\n"
"Note that putting the rules in order achieves the same effect as having a "
"priority number on each rule: the first rule implicitly has the highest "
"priority, the second rule is next highest, and so on."
msgstr ""
"В исходной ELIZA была система, в которой каждому правилу был присвоен номер "
"приоритета.\n"
"Выбралось правило сопоставления с наивысшим приоритетом.\n"
"Обратите внимание, что упорядочение правил дает тот же эффект, что и номер "
"приоритета для каждого правила: первое правило неявно имеет наивысший "
"приоритет, второе правило - следующее наивысшее и т. Д.\n"

#: in/chapter5.md:510
msgid ""
"Here is a short list of rules, selected from Weizenbaum's original article, "
"but with the form of the rules updated to the form we are using.\n"
"The answer to exercise 5.18 contains a longer list of rules."
msgstr ""
"Вот краткий список правил, выбранных из исходной статьи Вайценбаума, но с "
"обновленной формой правил до той формы, которую мы используем.\n"
"Ответ к упражнению 5.18 содержит более длинный список правил."

#: in/chapter5.md:532
msgid ""
"```lisp\n"
"(defparameter *eliza-rules*\n"
"  '((((?* ?x) hello (?* ?y))\n"
"     (How do you do.  Please state your problem.))\n"
"    (((?* ?x) I want (?* ?y))\n"
"     (What would i t mean if you got ?y)\n"
"     (Why do you want ?y) (Suppose you got ?y soon))\n"
"    (((?* ?x) if (?* ?y))\n"
"     (Do you really think i t s l i k e l y that ?y) (Do you wish that ?y)\n"
"     (What do you think about ?y) (Really-- if ?y))\n"
"    (((?* ?x) no (?* ?y))\n"
"     (Why not?) (You are being a bit negative)\n"
"     (Are you saying \"NO\" just to be negative?))\n"
"    (((?* ?x) I was (?* ?y))\n"
"     (Were you really ?) (Perhaps I already knew you were ?y)\n"
"     (Why do you t e l l me you were ?y now?))\n"
"    (((?* ?x) I feel (?* ?y))\n"
"     (Do you often feel ?y ?))\n"
"    (((?* ?x) I felt (?* ?y))\n"
"     (What other feelings do you have?))))\n"
"```"
msgstr ""

#: in/chapter5.md:537
msgid ""
"Finally we are ready to define ELIZA proper.\n"
"As we said earlier, the main program should be a loop that reads input, "
"transforms it, and prints the result.\n"
"Transformation is done primarily by finding some rule such that its pattern "
"matches the input, and then substituting the variables into the rule's "
"response.\n"
"The program is summarized in figure 5.1."
msgstr ""
"Наконец, мы готовы дать собственно определение ELIZA.\n"
"Как мы говорили ранее, основная программа должна быть циклом, который "
"считывает ввод, преобразует его и печатает результат.\n"
"Преобразование выполняется в первую очередь путем нахождения некоторого "
"правила, образец которого соответствует входу, а затем подстановки "
"переменных в ответ правила.\n"
"Программа представлена на рисунке 5.1."

#: in/chapter5.md:539
msgid "Figure 5.1: Glossary for the ELIZA Program"
msgstr "Рисунок 5.1: Глоссарий программы ELIZA"

#: in/chapter5.md:559
msgid ""
"| Symbol             | Use                                                   "
"|\n"
"| ------             | ---                                                   "
"|\n"
"|                    | **Top-Level Function**                                "
"|\n"
"| `eliza`            | Respond to user input using pattern matching rules.   "
"|\n"
"|                    | **Special Variables**                                 "
"|\n"
"| `*eliza-rules*`    | A list of transformation rules.                       "
"|\n"
"|                    | **Data Types**                                        "
"|\n"
"| `rule`             | An association of a pattern with a list of responses. "
"|\n"
"|                    | **Functions**                                         "
"|\n"
"| `eliza`            | Respond to user input using pattern matching rules.   "
"|\n"
"| `use-eliza-rules`  | Find some rule with which to transform the input.     "
"|\n"
"| `switch-viewpoint` | Change I to you and vice versa, and so on.            "
"|\n"
"| `flatten`          | Append together elements of a list.                   "
"|\n"
"|                    | **Selected Common Lisp Functions**                    "
"|\n"
"| `sublis`           | Substitute elements into a tree.                      "
"|\n"
"|                    | **Previously Defined Functions**                      "
"|\n"
"| `random-elt`       | Pick a random element from a list. (p. 36)            "
"|\n"
"| `pat-match`        | Match a pattern against an input, (p. 160)            "
"|\n"
"| `mappend`          | Append together the results of a mapcar.              "
"|"
msgstr ""
"| Символ             | "
"Использование                                                                "
"|\n"
"| ------             | "
"---                                                                          "
"|\n"
"|                    | **Функция верхнего "
"уровня**                                                  |\n"
"| `eliza`            | Отвечает на ввод пользователя, используя правила "
"сопоставления с образцом.   |\n"
"|                    | **Специальные "
"переменные**                                                   |\n"
"| `*eliza-rules*`    | Список правил "
"преобразования.                                                |\n"
"|                    | **Типы "
"данных**                                                              |\n"
"| `rule`             | Связь образцов со списком "
"ответов..                                          |\n"
"|                    | "
"**Функции**                                                                  "
"|\n"
"| `eliza`            | Отвечает на ввод пользователя, используя правила "
"сопоставления с образцом.   |\n"
"| `use-eliza-rules`  | Ищет какое-либо правило, с помощью которого можно "
"преобразовать ввод.        |\n"
"| `switch-viewpoint` | Меняет я(I) на ты(you) и наоборот, и т."
"д.                                    |\n"
"| `flatten`          | складывает элементы в "
"список.                                                |\n"
"|                    | **Выбранные функции Common "
"Lisp**                                            |\n"
"| `sublis`           | производит замену элементов в "
"дереве.                                        |\n"
"|                    | **Ранее определенные "
"функции**                                               |\n"
"| `random-elt`       | Выберает случайный элемент из списка. (p. "
"36)                                |\n"
"| `pat-match`        | Сопоставляет образец с вводом, (p. "
"160)                                      |\n"
"| `mappend`          | Складывает вместе результаты "
"mapcar.                                         |"

#: in/chapter5.md:565
msgid ""
"There are a few minor complications.\n"
"We print a prompt to tell the user to input something.\n"
"We use the function `flatten` to insure that the output won't have embedded "
"lists after variable substitution.\n"
"An important trick is to alter the input by swapping \"you\" for \"me\" and "
"so on, since these terms are relative to the speaker.\n"
"Here is the complete program:"
msgstr ""
"Есть несколько мелких осложнений.\n"
"Мы печатаем приглашение, чтобы сообщить пользователю что ждем ввода.\n"
"Мы используем функцию `flatten`, чтобы гарантировать, что на выходе не будет "
"вложенных списков после подстановки переменных.\n"
"Важный трюк - изменить ввод, заменив \"ты\"(you) на \"я\"(i) и так далее, "
"поскольку эти термины относятся к говорящему.\n"
"Вот полная программа:\n"

#: in/chapter5.md:572
msgid ""
"```lisp\n"
"(defun eliza ()\n"
"  \"Respond to user input using pattern matching rules.\"\n"
"  (loop\n"
"   (print 'eliza>)\n"
"   (write (flatten (use-eliza-rules (read))) :pretty t)))"
msgstr ""

#: in/chapter5.md:581
msgid ""
" (defun use-eliza-rules (input)\n"
"   \"Find some rule with which to transform the input.\"\n"
"   (some #'(lambda (rule)\n"
"\t     (let ((result (pat-match (rule-pattern rule) input)))\n"
"\t       (if (not (eq result fail))\n"
"\t\t   (sublis (switch-viewpoint result)\n"
"\t\t\t   (random-elt (rule-responses rule))))))\n"
"\t *eliza-rules*))"
msgstr ""

#: in/chapter5.md:587
msgid ""
"(defun switch-viewpoint (words)\n"
"  \"Change I to you and vice versa, and so on.\"\n"
"  (sublis '((I . you) (you . I) (me . you) (am . are))\n"
"          words))\n"
"```"
msgstr ""

#: in/chapter5.md:591
msgid ""
"Note the use of `write` with the `:pretty` keyword true.\n"
"This will give better formatted output in some cases.\n"
"The program makes use of the previously defined `random-elt`, and `flatten`, "
"which is defined here using `mappend` and `mklist`, a function that is "
"defined in the InterLisp dialect but not in Common Lisp."
msgstr ""
"Обратите внимание на использование `write` с ключевым словом `:pretty` "
"true.\n"
"В некоторых случаях это даст лучший формат вывода.\n"
"Программа использует ранее определенные `random-elt` и `flatten`, которые "
"определены здесь с помощью `mappend` и `mklist`, функций, которые определены "
"в диалекте InterLisp, но не в Common Lisp."

#: in/chapter5.md:596
msgid ""
"```lisp\n"
"(defun flatten (the-list)\n"
"  \"Append together elements (or lists) in the list.\"\n"
"  (mappend #'mklist the-list))"
msgstr ""

#: in/chapter5.md:602
msgid ""
"(defun mklist (x)\n"
"  \"Return x if it is a list, otherwise (x).\"\n"
"  (if (listp x)\n"
"      x\n"
"    (list x)))"
msgstr ""

#: in/chapter5.md:606
msgid ""
"(defun mappend (fn the-list)\n"
"  \"Apply fn to each element of list and append the result.\"\n"
"  (apply #'append (mapcar fn the-list)))"
msgstr ""

#: in/chapter5.md:611
msgid ""
"(defun random-elt (choices)\n"
"  \"Choose an element from a list at random.\"\n"
"  (elt choices (random (length choices))))\n"
"```"
msgstr ""

#: in/chapter5.md:620
msgid ""
"The actual ELIZA program had a few complications that don't show up in this "
"version.\n"
"First, there was an alias method for associating several words with the same "
"pattern; both \"mother\" and \"father\" could be associated with the \"family"
"\" pattern.\n"
"There was also a synonym mechanism that would treat \"don't\" and \"do not\" "
"or \"everybody\" and \"everyone\" the same.\n"
"In the case of input with several comma-separated phrases, each phrase was "
"processed separately, and the response with the highest priority was "
"selected.\n"
"In addition, the original ELIZA had a \"memory\" mechanism.\n"
"When no pattern matched the input, it said something like \"Tell me more "
"about X,\" where X is some input given earlier.\n"
"Finally, our version has fewer rules.\n"
"Despite the shortcomings of our version, it can occasionally hold up its end "
"of a conversation, as shown below:"
msgstr ""
"В реальной программе ELIZA было несколько усложнений, которых нет в этой "
"версии.\n"
"Во-первых, был метод псевдонима для связывания нескольких слов с одним и тем "
"же образцо; и \"mother\"(мать), и \"father\"(отец) могут быть связаны с "
"образцом \"family\"(семья).\n"
"Был также механизм синонимов, который относился к \"don't\"(не надо) и \"do "
"not\" или \"everybody\"(всем) и \"everyone\".\n"
"В случае ввода нескольких фраз, разделенных запятыми, каждая фраза "
"обрабатывалась отдельно и выбирался ответ с наивысшим приоритетом.\n"
"Кроме того, исходная ELIZA имела механизм \"памяти\".\n"
"Когда ни один образец не совпадал с вводом, он говорил что-то вроде \"Tell "
"me more about X\"(Расскажите мне больше о X), где X - некоторый ввод, "
"сделанный ранее.\n"
"Наконец, в нашей версии меньше правил.\n"
"Несмотря на недостатки нашей версии, она может иногда задерживать конец "
"разговора, как показано ниже:"

#: in/chapter5.md:641
msgid ""
"```text\n"
"> (eliza)\n"
"ELIZA> (hello there)\n"
"(HOW DO YOU DO. PLEASE STATE YOUR PROBLEM.)\n"
"ELIZA> (i want to test this program)\n"
"(WHAT WOULD IT MEAN IF YOU GOT TO TEST THIS PROGRAM)\n"
"ELIZA> (i could see if it works)\n"
"(DO YOU REALLY THINK ITS LIKELY THAT IT WORKS)\n"
"ELIZA> (no not really)\n"
"(ARE YOU SAYING \"NO\" JUST TO BE NEGATIVE?)\n"
"ELIZA> (no)\n"
"(ARE YOU SAYING \"NO\" JUST TO BE NEGATIVE?)\n"
"ELIZA> (forget it-- i was wondering how general the program i s)\n"
"(WHY DO YOU TELL ME YOU WERE WONDERING HOW GENERAL THE PROGRAM I S NOW?)\n"
"ELIZA> (i felt like it)\n"
"(WHAT OTHER FEELINGS DO YOU HAVE?)\n"
"ELIZA> (i feel this is enough)\n"
"(DO YOU OFTEN FEEL THIS IS ENOUGH ?)\n"
"ELIZA> [Abort]\n"
"```"
msgstr ""

#: in/chapter5.md:649
msgid ""
"In the end, it is the technique that is important-not the program.\n"
"ELIZA has been \"explained away\" and should rightfully be moved to the "
"curio shelf.\n"
"Pattern matching in general remains important technique, and we will see it "
"again in subsequent chapters.\n"
"The notion of a rule-based translator is also important.\n"
"The problem of understanding English (and other languages) remains an "
"important part of AI.\n"
"Clearly, the problem of understanding English is not solved by ELIZA.\n"
"In part V, we will address the problem again, using more sophisticated "
"techniques."
msgstr ""
"В конце концов, это важна техника, а не программа.\n"
"ELIZA была \"объяснена\", и ее по праву следует переместить на полку с "
"любопытными вещами.\n"
"Сопоставление с образцом в целом остается важной техникой, и мы еще не раз "
"увидим ее в следующих главах.\n"
"Понятие преобразователя, основанного на правилах, также важно.\n"
"Проблема понимания английского (и других языков) остается важной частью ИИ.\n"
"Понятно, что проблема понимания английского не решается ELIZA.\n"
"В части V мы снова обратимся к этой проблеме, используя более сложные методы."

#: in/chapter5.md:659
msgid ""
"## 5.5 History and References\n"
"As mentioned above, the original article describing ELIZA is Weizenbaum "
"1966.\n"
"Another dialog system using similar pattern-matching techniques is Kenneth "
"Colby's (1975) PARRY.\n"
"This program simulated the conversation of a paranoid person well enough to "
"fool several professional psychologists.\n"
"Although the pattern matching techniques were simple, the model of belief "
"maintained by the system was much more sophisticated than ELIZA.\n"
"Colby has suggested that dialog programs like ELIZA, augmented with some "
"sort of belief model like PARRY, could be useful tools in treating mentally "
"disturbed people.\n"
"According to Colby, it would be inexpensive and effective to have patients "
"converse with a specially designed program, one that could handle simple "
"cases and alert doctors to patients that needed more help.\n"
"Weizenbaum's book *Computer Power and Human Reason* (1976) discusses ELIZA "
"and PARRY and takes a very critical view toward Colby's suggestion.\n"
"Other interesting early work on dialog systems that model belief is reported "
"by Allan Collins (1978) and Jamie Carbonell (1981)."
msgstr ""
"## 5.5 История и ссылки\n"
"Как упоминалось выше, исходная статья, описывающая ELIZA, описана в "
"Weizenbaum 1966.\n"
"Другой диалоговой системой, использующей аналогичные методы сопоставления с "
"образцом, является система PARRY Кеннета Колби (1975).\n"
"Эта программа достаточно хорошо смоделировала разговор параноика, чтобы "
"обмануть нескольких профессиональных психологов.\n"
"Хотя методы сопоставления с образцом были простыми, модель убеждений, "
"поддерживаемая системой, была намного сложнее, чем ELIZA.\n"
"Колби предположил, что диалоговые программы, такие как ELIZA, дополненные "
"какой-то моделью убеждений, такой как PARRY, могут быть полезными "
"инструментами при лечении психически больных людей.\n"
"По словам Колби, было бы недорого и эффективно заставить пациентов общаться "
"с помощью специально разработанной программы, которая могла бы обрабатывать "
"простые случаи и предупреждать врачей о пациентах, которым требуется "
"дополнительная помощь.\n"
"В книге Вайценбаума «Компьютерная мощь и человеческий разум» (1976) "
"обсуждаются ELIZA и PARRY и очень критически рассматривается предложение "
"Колби.\n"
"О других интересных ранних работах по диалоговым системам, моделирующим "
"убеждения, сообщили Аллан Коллинз (1978) и Джейми Карбонелл (1981)."

#: in/chapter5.md:665
msgid ""
"## 5.6 Exercises\n"
"&#9635; **Exercise 5.2 [m]** Experiment with this version of ELIZA.\n"
"Show some exchanges where it performs well, and some where it fails.\n"
"Try to characterize the difference.\n"
"Which failures could be fixed by changing the rule set, which by changing "
"the `pat-match` function (and the pattern language it defines), and which "
"require a change to the `eliza` program itself?"
msgstr ""
"## 5.6 Упражнения\n"
"&#9635; **Exercise 5.2 [m]** Поэкспериментируйте с этой версией ELIZA.\n"
"Покажите некоторые обмены сообщениями, где она работает хорошо, а где нет.\n"
"Попытайтесь охарактеризовать разницу.\n"
"Какие сбои можно исправить, изменив набор правил, какие - изменив функцию "
"`pat-match` (и язык образцов, который она определяет), а какие требуют "
"изменения самой программы `eliza`?"

#: in/chapter5.md:669
msgid ""
"&#9635; **Exercise 5.3 [h]** Define a new set of rules that make ELIZA give "
"stereotypical responses to some situation other than the doctor-patient "
"relationship.\n"
"Or, write a set of rules in a language other than English.\n"
"Test and debug your new rule set."
msgstr ""
"&#9635; **Exercise 5.3 [h]** Определите новый набор правил, которые заставят "
"ELIZA давать стереотипные ответы на некоторые ситуации, отличные от "
"отношений между врачом и пациентом.\n"
"Или напишите свод правил на другом языке, кроме английского.\n"
"Протестируйте и отладьте свой новый набор правил."

#: in/chapter5.md:673
msgid ""
"&#9635; **Exercise 5.4 [s]** We mentioned that our version of ELIZA cannot "
"handle commas or double quote marks in the input.\n"
"However, it seems to handle the apostrophe in both input and patterns.\n"
"Explain."
msgstr ""
"&#9635; **Exercise 5.4 [s]** Мы упоминали, что наша версия ELIZA не может "
"обрабатывать запятые или двойные кавычки во входных данных.\n"
"Однако, похоже, она обрабатывает апостроф как во вводе, так и в шаблонах.\n"
"Объясните."

#: in/chapter5.md:678
msgid ""
"&#9635; **Exercise 5.5 [h]** Alter the input mechanism to handle commas and "
"other punctuation characters.\n"
"Also arrange so that the user doesn't have to type parentheses around the "
"whole input expression.\n"
"(Hint: this can only be done using some Lisp functions we have not seen "
"yet.\n"
"Look at `read-line` and `read-from-string`.)"
msgstr ""
"&#9635; **Exercise 5.5 [h]** Измените механизм ввода для обработки запятых и "
"других знаков препинания.\n"
"Также сделайте так, чтобы пользователю не приходилось вводить круглые скобки "
"вокруг всего входного выражения.\n"
"(Подсказка: это можно сделать только с помощью некоторых функций Lisp, "
"которые мы еще не видели.\n"
"Посмотрите на `read-line` и `read-from-string`.)"

#: in/chapter5.md:681
msgid ""
"&#9635; **Exercise 5.6 [m]** Modify ELIZA to have an explicit exit.\n"
"Also arrange so that the output is not printed in parentheses either."
msgstr ""
"&#9635; **Exercise 5.6 [m]** Измените ELIZA, чтобы иметь явный выход.\n"
"Также организуйте так, чтобы вывод не печатался в круглых скобках."

#: in/chapter5.md:684
msgid ""
"&#9635; **Exercise 5.7 [m]** Add the \"memory mechanism\" discussed "
"previously to ELIZA.\n"
"Also add some way of defining synonyms like \"everyone\" and \"everybody.\""
msgstr ""
"&#9635; **Exercise 5.7 [m]** Добавьте \"механизм памяти\", о котором "
"говорилось ранее, в ELIZA.\n"
"Также добавьте способ определения синонимов, таких как \"everyone\" и "
"\"everybody\"."

#: in/chapter5.md:689
msgid ""
"&#9635; **Exercise 5.8 [h]** It turns out that none of the rules in the "
"given script uses a variable more than once-there is no rule of the form `(?"
"x... ?x)`.\n"
"Write a pattern matcher that only adds bindings, never checks variables "
"against previous bindings.\n"
"Use the `time` special form to compare your function against the current "
"version."
msgstr ""
"&#9635; **Exercise 5.8 [h]** Оказывается, ни одно из правил в данном скрипте "
"не использует переменную более одного раза - нет правила вида `(?X ... ?"
"X)`.\n"
"Напишите средство сопоставления образцов, которое только добавляет привязки, "
"но никогда не проверяет переменные на соответствие предыдущим привязкам.\n"
"Используйте специальную форму `time`, чтобы сравнить вашу функцию с текущей "
"версией."

#: in/chapter5.md:693
msgid ""
"&#9635; **Exercise 5.9 [h]** Winston and Horn's book *Lisp* presents a good "
"pattern-matching program.\n"
"Compare their implementation with this one.\n"
"One difference is that they handle the case where the first element of the "
"pattern is a segment variable with the following code (translated into our "
"notation):"
msgstr ""
"&#9635; **Exercise 5.9 [h]** Книга Уинстона и Хорна *Lisp* предоставляет "
"хорошую программу сопоставления с образцом.\n"
"Сравните их реализацию с этой.\n"
"Одно отличие состоит в том, что они обрабатывают случай, когда первый "
"элемент шаблона является сегментной переменной со следующим кодом "
"(переведенным в нашу нотацию):"

#: in/chapter5.md:698
msgid ""
"```lisp\n"
"(or (pat-match (rest pattern) (rest input) bindings)\n"
"  (pat-match pattern (rest input) bindings))\n"
"```"
msgstr ""

#: in/chapter5.md:704
msgid ""
"This says that a segment variable matches either by matching the first "
"element of the input, or by matching more than the first element.\n"
"It is much simpler than our approach using `position`, partly because they "
"don't update the binding list.\n"
"Can you change their code to handle bindings, and incorporate it into our "
"version of `pat-match`?\n"
"Is it still simpler?\n"
"Is it more or less efficient?"
msgstr ""
"Это говорит о том, что сегментная переменная соответствует либо путем "
"сопоставления первого элемента ввода, либо путем сопоставления более чем "
"первого элемента.\n"
"Это намного проще, чем наш подход с использованием `position`, отчасти "
"потому, что они не обновляют список привязок.\n"
"Можете ли вы изменить их код для обработки привязок и включить его в нашу "
"версию `pat-match`?\n"
"Все еще проще?\n"
"Это более или менее эффективно?"

#: in/chapter5.md:706
msgid ""
"&#9635; **Exercise 5.10** What is wrong with the following definition of "
"`simple-equal`?"
msgstr ""
"&#9635; **Exercise 5.10** Что не так в следующем определении  `simple-equal`?"

#: in/chapter5.md:716
msgid ""
"```lisp\n"
"(defun simple-equal (x y)\n"
"  \"Test if two lists or atoms are equal.\"\n"
"  ;; Warning - incorrect\n"
"  (or (eql x y)\n"
"      (and (listp x) (listp y)\n"
"     (simple-equal (first x) (first y))\n"
"     (simple-equal (rest x) (rest y)))))\n"
"```"
msgstr ""

#: in/chapter5.md:718
msgid ""
"&#9635; **Exercise 5.11 [m]** Weigh the advantages of changing `no-bindings` "
"to `nil`, and `fail` to something else."
msgstr ""
"&#9635; **Exercise 5.11 [m]** Оцените преимущества замены `no-bindings` на "
"`nil` и `fail` на что-то еще."

#: in/chapter5.md:720
msgid ""
"&#9635; **Exercise 5.12 [m]** Weigh the advantages of making `pat-match` "
"return multiple values: the first would be true for a match and false for "
"failure, and the second would be the binding list."
msgstr ""
"&#9635; **Exercise 5.12 [m]** Взвесьте преимущества того, что `pat-match` "
"возвращает множественное значение: первое будет истинным для совпадения и "
"ложным при неудаче, а второе будет списком привязок."

#: in/chapter5.md:722
msgid ""
"&#9635; **Exercise 5.13 [m]** Suppose that there is a call to `segment-"
"match` where the variable already has a binding."
msgstr ""
"&#9635; **Exercise 5.13 [m]** Предположим, что есть вызов `segment-match`, "
"где переменная уже имеет привязку."

#: in/chapter5.md:726
msgid ""
"The current definition will keep making recursive calls to `segment-match`, "
"one for each possible matching position.\n"
"But this is silly-if the variable is already bound, there is only one "
"sequence that it can possibly match against.\n"
"Change the definition so that it looks only for this one sequence."
msgstr ""
"Текущее определение будет продолжать делать рекурсивные вызовы `segment-"
"match`, по одному для каждой возможной совпадающей позиции.\n"
"Но это глупо - если переменная уже связана, есть только одна "
"последовательность, с которой её можно сопоставить.\n"
"Измените определение так, чтобы оно отображало только эту последовательность."

#: in/chapter5.md:728
msgid ""
"&#9635; **Exercise 5.14 [m]** Define a version of `mappend` that, like "
"`mapcar`, accepts any number of argument lists."
msgstr ""
"&#9635; **Exercise 5.14 [m]** Определите версию `mappend`, которая, как и "
"`mapcar`, принимает любое количество аргументов списков."

#: in/chapter5.md:730
msgid ""
"&#9635; **Exercise 5.15 [m]** Give an informal proof that `segment-match` "
"always terminates."
msgstr ""
"&#9635; **Exercise 5.15 [m]** Приведите неформальное доказательство того, "
"что `segment-match` всегда заканчивается."

#: in/chapter5.md:733
msgid ""
"&#9635; **Exercise 5.16 [s]** Trick question: There is an object in Lisp "
"which, when passed to `variable-p`, results in an error.\n"
"What is that object?"
msgstr ""
"&#9635; **Exercise 5.16 [s]** Вопрос с подвохом: в Лиспе есть объект, "
"который при передаче в `variable-p` приводит к ошибке.\n"
"Что это за объект?"

#: in/chapter5.md:738
msgid ""
"&#9635; **Exercise 5.17 [m]** The current version of ELIZA takes an input, "
"transforms it according to the first applicable rule, and outputs the "
"result.\n"
"One can also imagine a system where the input might be transformed several "
"times before the final output is printed.\n"
"Would such a system be more powerful?\n"
"If so, in what way?"
msgstr ""
"&#9635; **Exercise 5.17 [m]** Текущая версия ELIZA принимает входные данные, "
"преобразует их в соответствии с первым применимым правилом и выводит "
"результат.\n"
"Можно также представить себе систему, в которой ввод может быть преобразован "
"несколько раз, прежде чем будет напечатан окончательный вывод.\n"
"Будет ли такая система более мощной?\n"
"Если да, то каким образом?\n"

#: in/chapter5.md:740
msgid ""
"&#9635; **Exercise 5.18 [h]** Read Weizenbaum's original article on ELIZA "
"and transpose his list of rules into the notation used in this chapter."
msgstr ""
"&#9635; **Exercise 5.18 [h]** Прочтите оригинальную статью Вайценбаума об "
"ELIZA и перенесите его список правил в обозначения, используемые в этой "
"главе."

#: in/chapter5.md:745
msgid ""
"## 5.7 Answers\n"
"### Answer 5.1\n"
"No.\n"
"If either the pattern or the input were shorter, but matched every existing "
"element, the every expression would incorrectly return true."
msgstr ""
"## 5.7 Answers\n"
"### Answer 5.1\n"
"Нет.\n"
"Если либо образец, либо входные данные были короче, но соответствовали "
"каждому существующему элементу,  выражение every неправильно вернуло бы true."

#: in/chapter5.md:749
msgid ""
"```lisp\n"
"(every #'pat-match '(a b c) '(a)) â T\n"
"```"
msgstr ""

#: in/chapter5.md:751
msgid ""
"Furthermore, if either the pattern or the input were a dotted list, then the "
"result of the every would be undefined-some implementations might signal an "
"error, and others might just ignore the expression after the dot."
msgstr ""
"Более того, если образец или входные данные были списком с точкой, то "
"результат every был бы undefined - некоторые реализации могут "
"сигнализировать об ошибке, а другие могут просто игнорировать выражение "
"после точки."

#: in/chapter5.md:755
msgid ""
"```lisp\n"
"(every #'pat-match '(a b . c) '(a b . d)) â T, NIL, or error.\n"
"```"
msgstr ""

#: in/chapter5.md:761
msgid ""
"### Answer 5.4\n"
"The expression `don't` may look like a single word, but to the Lisp reader "
"it is composed of the two elements `don` and `'t`, or `(quote t )`.\n"
"If these elements are used consistently, they will match correctly, but they "
"won't print quite right-there will be a space before the quote mark.\n"
"In fact the `:pretty t` argument to `write` is specified primarily to make "
"`(quote t)` print as `'t`\n"
"(See page 559 of Steele's *Common Lisp the Language*, 2d edition)."
msgstr ""
"### Answer 5.4\n"
"Выражение `don't` может выглядеть как отдельное слово, но для читателя(read) "
"Lisp оно состоит из двух элементов `don` и `'t` или `(quote t )`.\n"
"Если эти элементы используются последовательно, они будут сопоставляться "
"правильно, но они не будут печататься правильно - перед кавычкой будет "
"пробел.\n"
"Фактически, аргумент `: pretty t` для `write` определен в первую очередь для "
"того, чтобы заставить `(quote t)` печатать как `'t`\n"
"(См. Стр. 559 книги Стила *Common Lisp the Language*, 2-е издание)."

#: in/chapter5.md:766
msgid ""
"### Answer 5.5\n"
"One way to do this is to read a whole line of text with `read-line` rather "
"than `read`.\n"
"Then, substitute spaces for any punctuation character in that string.\n"
"Finally, wrap the string in parentheses, and read it back in as a list:"
msgstr ""
"### Answer 5.5\n"
"OОдин из способов сделать это - прочитать всю строку текста с помощью `read-"
"line`, а не `read`.\n"
"Затем замените любой символ пунктуации в этой строке пробелами.\n"
"Наконец, заключите строку в круглые скобки и прочтите ее как список:"

#: in/chapter5.md:774
msgid ""
"```lisp\n"
"(defun read-line-no-punct ()\n"
"  \"Read an input line, ignoring punctuation.\"\n"
"  (read-from-string\n"
"   (concatenate 'string \"(\" (substitute-if #\\space #'punctuation-p\n"
"             (read-line))\n"
"    \")\")))"
msgstr ""

#: in/chapter5.md:777
msgid ""
"(defun punctuation-p (char) (find char \".,;:'!?#-()\\\\\\\"\"))\n"
"```"
msgstr ""

#: in/chapter5.md:779
msgid ""
"This could also be done by altering the readtable, as in section 23.5, page "
"821."
msgstr ""
"Это также можно сделать, изменив таблицу для чтения, как в разделе 23.5, с. "
"821."

#: in/chapter5.md:781
msgid "### Answer 5.6"
msgstr ""

#: in/chapter5.md:791
msgid ""
"```lisp\n"
" (defun eliza ()\n"
"   \"Respond to user input using pattern matching rules.\"\n"
"   (loop\n"
"      (print 'eliza>)\n"
"      (let* ((input (read-line-no-punct))\n"
"\t      (response (flatten (use-eliza-rules input))))\n"
"\t   (print-with-spaces response)\n"
"\t   (if (equal response '(good bye)) (RETURN)))))"
msgstr ""

#: in/chapter5.md:795
msgid ""
"(defun print-with-spaces (list)\n"
"  (mapc #'(lambda (x) (prin1 x) (princ \" \")) list))\n"
"```"
msgstr ""

#: in/chapter5.md:797
msgid "***`or`***"
msgstr "***`or`***"

#: in/chapter5.md:802
msgid ""
"```lisp\n"
"(defun print-with-spaces (list)\n"
"  (format t \"~{~a ~}\" list))\n"
"```"
msgstr ""

#: in/chapter5.md:805
msgid ""
"### Answer 5.10\n"
"Hint: consider `(simple-equal '() '(nil . nil))`."
msgstr ""
"### Answer 5.10\n"
"Подсказка: подумайте `(simple-equal '() '(nil . nil))`."

#: in/chapter5.md:807
msgid "### Answer 5.14"
msgstr ""

#: in/chapter5.md:813
msgid ""
"```lisp\n"
"(defun mappend (fn &rest list)\n"
"  \"Apply fn to each element of lists and append the results.\"\n"
"  (apply #'append (apply #'mapcar fn lists)))\n"
"```"
msgstr ""

#: in/chapter5.md:819
msgid ""
"### Answer 5.16\n"
"It must be a symbol, because for nonsymbols, `variable-p` just returns nil.\n"
"Getting the `symbol-name` of a symbol is just accessing a slot, so that "
"can't cause an error.\n"
"The only thing left is `elt`; if the symbol name is the empty string, then "
"accessing element zero of the empty string is an error.\n"
"Indeed, there is a symbol whose name is the empty string: the symbol."
msgstr ""
"### Answer 5.16\n"
"Это должен быть символ, потому что для несимволов `variable-p` просто "
"возвращает nil.\n"
"Получение `symbol-name` для символа - это просто доступ к слоту, поэтому она "
"не может вызвать ошибку.\n"
"Остается только `elt`; если имя символа - пустая строка, то доступ к "
"нулевому элементу пустой строки является ошибкой.\n"
"В самом деле, есть символ, имя которого - пустая строка: символ."

#: in/chapter5.md:824
msgid ""
"### Answer 5.17\n"
"Among other things, a recursive transformation system could be used to "
"handle abbreviations.\n"
"That is, a form like \"don't\" could be transformed into \"do not\" and then "
"processed again.\n"
"That way, the other rules need only work on inputs matching \"do not.\""
msgstr ""
"### Answer 5.17\n"
"Среди прочего, для обработки сокращений может использоваться система "
"рекурсивного преобразования.\n"
"То есть такую форму, как \"don't\"(не делать), можно преобразовать в \"do not"
"\", а затем снова обработать.\n"
"Таким образом, другие правила должны работать только с входными данными, "
"совпадающими с \"do not\"."

#: in/chapter5.md:827
msgid ""
"### Answer 5.18\n"
"The following includes most of Weizenbaum's rules:"
msgstr ""
"### Answer 5.18\n"
"Ниже приводится большая часть правил Вайценбаума:"

#: in/chapter5.md:950
msgid ""
"```lisp\n"
"(defparameter *eliza-rules*\n"
"  '((((?* ?x) hello (?* ?y))\n"
"     (How do you do. Please state your problem.))\n"
"    (((?* ?x) computer (?* ?y))\n"
"     (Do computers worry you?) (What do you think about machines?)\n"
"     (Why do you mention computers?)\n"
"     (What do you think machines have to do with your problem?))\n"
"    (((?* ?x) name (?* ?y))\n"
"     (I am not interested in names))\n"
"    (((?* ?x) sorry (?* ?y))\n"
"     (Please don't apologize) (Apologies are not necessary)\n"
"     (What feelings do you have when you apologize))\n"
"    (((?* ?x) I remember (?* ?y))\n"
"     (Do you often think of ?y)\n"
"     (Does thinking of ?y bring anything else to mind?)\n"
"     (What else do you remember) (Why do you recall ?y right now?)\n"
"     (What in the present situation reminds you of ?y)\n"
"     (What i s the connection between me and ?y))\n"
"    (((?* ?x) do you remember (?* ?y))\n"
"     (Did you think I would forget ?y ?)\n"
"     (Why do you think I should recall ?y now)\n"
"     (What about ?y) (You mentioned ?y))\n"
"    (((?* ?x) if (?* ?y))\n"
"     (Do you really think its likely that ?y) (Do you wish that ?y)\n"
"     (What do you think about ?y) (Really-- if ?y))\n"
"    (((?* ?x) I dreamt (?* ?y))\n"
"     (Really-- ?y) (Have you ever fantasized ?y while you were awake?)\n"
"     (Have you dreamt ?y before?))\n"
"    (((?* ?x) dream about (?* ?y))\n"
"     (How do you feel about ?y in reality?))\n"
"    (((?* ?x) dream (?* ?y))\n"
"     (What does this dream suggest to you?) (Do you dream often?)\n"
"     (What persons appear in your dreams?)\n"
"     (Don't you believe that dream has to do with your problem?))\n"
"    (((?* ?x) my mother (?* ?y))\n"
"     (Who else in your family ?y) (Tell me more about your family))\n"
"    (((?* ?x) my father (?* ?y))\n"
"     (Your father) (Does he influence you strongly?)\n"
"     (What else comes to mind when you think of your father?))\n"
"    (((?* ?x) I want (?* ?y))\n"
"     (What would it mean if you got ?y)\n"
"     (Why do you want ?y) (Suppose you got ?y soon))\n"
"    (((?* ?x) I am glad (?* ?y))\n"
"     (How have I helped you to be ?y) (What makes you happy just now)\n"
"     (Can you explain why you are suddenly ?y))\n"
"    (((?* ?x) I am sad (?* ?y))\n"
"     (I am sorry to hear you are depressed)\n"
"     (I 'm sure i t ' s not pleasant to be sad))\n"
"    (((?* ?x) are like (?* ?y))\n"
"     (What resemblance do you see between ?x and ?y))\n"
"    (((?* ?x) i s like (?* ?y))\n"
"     (In what way is it that ?x is like ?y)\n"
"     (What resemblance do you see?)\n"
"     (Could there really be some connection?) (How?))\n"
"    (((?* ?x) alike (?* ?y))\n"
"     (In what way?) (What s i m i l a r i t i e s are there?))\n"
"    (((?* ?x) same (?* ?y))\n"
"     (What other connections do you see?))\n"
"    (((?* ?x) I was (?* ?y))\n"
"     (Were you really ?) (Perhaps I already knew you were ?y)\n"
"     (Why do you tell me you were ?y now?))\n"
"    (((?* ?x) was I (?* ?y))\n"
"     (What if you were ?y ?) (Do you think you were ?y)\n"
"     (What would it mean if you were ?y))\n"
"    (((?* ?x) I am (?* ?y))\n"
"     (In what way are you ?y) (Do you want to be ?y ?))\n"
"    (((?* ?x) am I (?* ?y))\n"
"     (Do you believe you are ?y) (Would you want to be ?y)\n"
"     (You wish I would tell you you are ?y)\n"
"     (What would it mean if you were ?y))\n"
"    (((?* ?x) am (?* ?y))\n"
"     (Why do you say \"AM?\") (I don't understand that))\n"
"    (((?* ?x) are you (?* ?y))\n"
"     (Why are you interested in whether I am ?y or not?)\n"
"     (Would you prefer if I weren't ?y)\n"
"     (Perhaps I am ?y in your fantasies))\n"
"    (((?* ?x) you are (?* ?y))\n"
"     (What makes you think I am ?y ?))\n"
"    (((?* ?x) because (?* ?y))\n"
"     (Is that the real reason?) (What other reasons might there be?)\n"
"     (Does that reason seem to explain anything else?))\n"
"    (((?* ?x) were you (?* ?y))\n"
"     (Perhaps I was ?y) (What do you think?) (What if I had been ?y))\n"
"    (((?* ?x) I can't (?* ?y))\n"
"     (Maybe you could ?y now) (What if you could ?y ?))\n"
"    (((?* ?x) I feel (?* ?y))\n"
"     (Do you often feel ?y ?))\n"
"    (((?* ?x) I felt (?* ?y))\n"
"     (What other feelings do you have?))\n"
"    (((?* ?x) I (?* ?y) you (?* ?z))\n"
"     (Perhaps in your fantasy we ?y each other))\n"
"    (((?* ?x) why don't you (?* ?y))\n"
"     (Should you ?y yourself?)\n"
"     (Do you believe I don't ?y) (Perhaps I will ?y in good time))\n"
"    (((?* ?x) yes (?* ?y))\n"
"     (You seem quite positive) (You are sure) (I understand))\n"
"    (((?* ?x) no (?* ?y))\n"
"     (Why not?) (You are being a bit negative)\n"
"     (Are you saying \"NO\" just to be negative?))\n"
"    (((?* ?x) someone (?* ?y))\n"
"     (Can you be more specific?))\n"
"    (((?* ?x) everyone (?* ?y))\n"
"     (surely not everyone) (Can you think of anyone in particular?)\n"
"     (Who for example?) (You are thinking of a special person))\n"
"    (((?* ?x) always (?* ?y))\n"
"     (Can you think of a specific example) (When?)\n"
"     (What incident are you thinking of?) (Really-- always))\n"
"    (((?* ?x) what (?* ?y))\n"
"     (Why do you ask?) (Does that question interest you?)\n"
"     (What is it you really want to know?) (What do you think?)\n"
"     (What comes to your mind when you ask that?))\n"
"    (((?* ?x) perhaps (?* ?y))\n"
"     (You do not seem quite certain))\n"
"    (((?* ?x) are (?* ?y))\n"
"     (Did you think they might not be ?y)\n"
"     (Possibly they are ?y))\n"
"    (((?* ?x))\n"
"     (Very interesting) (I am not sure I understand you fully)\n"
"     (What does that suggest to you?) (Please continue) (Go on)\n"
"     (Do you feel strongly about discussing such things?))))\n"
"```"
msgstr ""

#: in/chapter5.md:952
msgid "----------------------"
msgstr ""

#: in/chapter5.md:953
msgid ""
"<a name=\"chapter5-fn1\">1</a>: The difference is that `simple-equal` does "
"not handle strings."
msgstr ""
"<a name=\"chapter5-fn1\">1</a>: Разница в том, что `simple-equal` не "
"обрабатывает строки."
