# Глава 7
## STUDENT: Решение Алгебраических Задач

> *[Это] превосходный пример* демонстрирующий силу использования значений(meaning) для решения лингвистических проблем.

> -[Marvin Minsky (1968)](B9780080571157500285.xhtml#bb0845)

> MIT computer scientist

STUDENT еще одна ранняя программа понимания языка, написанная Дэниелом Боброу в качестве исследовательского проекта на степень доктора философии 1964 г.
Она была разработана для чтения и решения задач со словами, которые можно найти в школьных учебниках по алгебре.
Пример:

> If the number of customers Tom gets is twice the square of 20% of the number of advertisements he runs, and the number of advertisements is 45, then what is the number of customers Tom gets?
(Если количество клиентов, которых получает Том, вдвое больше квадрата 20% от количества рекламных объявлений, которые он запускает, а количество рекламных объявлений равно 45, то какое количество клиентов получает Том?)

STUDENT правильно ответит, что клиентов 162.
Для этого STUDENT должен быть гораздо более искушеннее, чем ELIZA; он должен обрабатывать и "понимать" большую часть вводимой информации, а не просто концентрироваться на нескольких ключевых словах.
И он должен вычислять ответ, а не просто заполнять пробелы.
Однако мы увидим, что программа STUDENT использует немногим больше, чем методы сопоставления с образцом ELIZA для преобразования входных данных в набор алгебраических уравнений.
Поэтому он должен знать достаточно алгебры, чтобы решать уравнения, но она не очень сложная.

Разрабатываемая нами версия STUDENT является почти полной реализацией оригинала.
Однако помните, что хотя оригинал был последним по состоянию на 1964 год, ИИ добился определенного прогресса за четверть века, как это будет показано в последующих главах.

## 7.1 Преобразование Английского в Уравнения

Описание STUDENT такое:

1.  Разбейте ввод на фразы, которые будут представлять собой уравнения.
!!!(p) {:.numlist}

2.  Разбейте каждую фразу на пару фраз по обе стороны от знака =
!!!(p) {:.numlist}

3.  Далее разбейте эти фразы на суммы и произведения и так далее, пока, наконец, мы не дойдем до конца с числами и переменными.
(Под "переменной" здесь я имею в виду "математическую переменную", которая отличается от идеи "переменной используемой при сопоставлении с образцом", используемой в `pat-match` в [главе 6](B9780080571157500066.xhtml)).
!!!(p) {:.numlist}

4.  Преобразуйте каждую английскую фразу в математическое выражение.
Мы используем идею преобразователя на основе правил, разработанного для ELIZA.
!!!(p) {:.numlist}

5.  Решите полученные математические уравнения, найдя значение для каждой неизвестной переменной.
!!!(p) {:.numlist}

6.  Выведите значения всех переменных.
!!!(p) {:.numlist}

Например, у нас может быть образец формы (`If ?x then ?y`) с соответствующим ответом, в котором говорится, что `?x` и `?y` будут уравнениями или списками уравнений.
Применив сопоставление входных данных указанных выше с образцом, `?y` будет иметь значение (`what is the number of customers Tomgets`/ сколько клиентов Tomgets).
Другой образец формы (`?x is ?y`) мог бы иметь ответ, соответствующий равенству, где  `?x` и `?y` - две стороны одного равенства.
Затем мы могли бы создать математическую переменную для (`what`) и другую для (`the number of customers Tom gets`/количество клиентов, которых получает Том).
Мы бы распознали эту более позднюю фразу как переменную, потому что нет никаких образцов, которые позволили бы разбить её дальше.
Напротив, фраза (`twice the square of 20 per cent of the number of advertisements he runs`/вдвое больше квадрата 20 процентов от количества рекламных объявлений, которые он запускает) может соответствовать образцу формы (`twice ?x`) и преобразовываться в `(* 2 (the square of 20 per cent of the number of advertisements he runs))` и путем дальнейшего применения образцов формы (`the square of ?x`) и (`?x per cent of ?y`) мы могли бы прийти к окончательному ответу `(* 2 (expt (* (/ 20 100) n) 2))`, где `n` - переменная, генерируемая (`the number of advertisements he runs`/количество рекламных объявлений, которые он запускает).

Таким образом, нам нужно представить переменные, выражения, уравнения и наборы уравнений.
Проще всего использовать то, что мы знаем: представить их так же, как это делает сам Лисп.
Переменные будут символами, выражения и уравнения будут вложенными списками с префиксными операторами, а наборы уравнений будут списками уравнений.
Имея это в виду, мы можем определить список правил `образец-ответ`, соответствующих типам утверждений, встречающихся в описаниях задач алгебры.
Структура определений для правил повторется здесь, и добавляется структура  выражений `exp`.
`lhs` и `rhs` обозначают левую и правую стороны, соответственно.
Обратите внимание, что конструктор `mkexp` определяется как конструктор, который строит выражения без использования аргументов ключеввых слов.
Как правило, запись (`:constructor` *fn args*) создает функцию-конструктор с заданным именем и списком аргументов. [1] (# fn0015)

```lisp
(defstruct (rule (:type list)) pattern response)

(defstruct (exp (:type list)
                (:constructor mkexp (lhs op rhs)))
  op lhs rhs)

(defun exp-p (x) (consp x))
(defun exp-args (x) (rest x))
```

Мы проигнорировали запятые и точки в ELIZA, но они имеют решающее значение для STUDENT, поэтому мы должны сделать поправку на них.
Проблема в том, что `","` в Лиспе обычно можно использовать только в конструкции обратных кавычек, а `"."` обычно можно использовать только как десятичную точку или в точечной паре.
Специального значения этих символьных знаков для читателя(reader) Лиспа можно избежать, поставив перед символьным знаком обратную косую черту (\,) или окружив знак вертикальными полосами (| , |).

```lisp
(pat-match-abbrev '?x* '(?* ?x))
(pat-match-abbrev '?y* '(?* ?y))

(defparameter *student-rules* (mapcar #'expand-pat-match-abbrev
  '(((?x* |.|)                  ?x)
    ((?x* |.| ?y*)          (?x ?y))
    ((if ?x* |,| then ?y*)  (?x ?y))
    ((if ?x* then ?y*)      (?x ?y))
    ((if ?x* |,| ?y*)       (?x ?y))
    ((?x* |,| and ?y*)      (?x ?y))
    ((find ?x* and ?y*)     ((= to-find-1 ?x) (= to-find-2 ?y)))
    ((find ?x*)             (= to-find ?x))
    ((?x* equals ?y*)       (= ?x ?y))
    ((?x* same as ?y*)      (= ?x ?y))
    ((?x* = ?y*)            (= ?x ?y))
    ((?x* is equal to ?y*)  (= ?x ?y))
    ((?x* is ?y*)           (= ?x ?y))
    ((?x* - ?y*)            (- ?x ?y))
    ((?x* minus ?y*)        (- ?x ?y))
    ((difference between ?x* and ?y*)  (- ?y ?x))
    ((difference ?x* and ?y*)          (- ?y ?x))
    ((?x* + ?y*)            (+ ?x ?y))
    ((?x* plus ?y*)         (+ ?x ?y))
    ((sum ?x* and ?y*)      (+ ?x ?y))
    ((product ?x* and ?y*)  (* ?x ?y))
    ((?x* * ?y*)            (* ?x ?y))
    ((?x* times ?y*)        (* ?x ?y))
    ((?x* / ?y*)            (/ ?x ?y))
    ((?x* per ?y*)          (/ ?x ?y))
    ((?x* divided by ?y*)   (/ ?x ?y))
    ((half ?x*)             (/ ?x 2))
    ((one half ?x*)         (/ ?x 2))
    ((twice ?x*)            (* 2 ?x))
    ((square ?x*)           (* ?x ?x))
    ((?x* % less than ?y*)  (* ?y (/ (- 100 ?x) 100)))
    ((?x* % more than ?y*)  (* ?y (/ (+ 100 ?x) 100)))
    ((?x* % ?y*)            (* (/ ?x 100) ?y)))))
```

Основной раздел STUDENTа будет искать по списку правил для ответа, как это делала ELIZA.
Первое отклонение состоит в том, что перед тем, как мы подставим значения переменных `pat-match` в ответ, мы должны сначала рекурсивно преобразовать значение каждой переменной, используя тот же список правил образец-ответ.
Другое отличие состоит в том, что после того, как мы закончим, мы не просто печатаем ответ; вместо этого мы должны решить систему уравнений и распечатать ответы.
Краткое описание программы приведено на [рис. 7.1](#f0010).

| []()                                         |
|----------------------------------------------|
| ![f07-01](images/chapter7/f07-01.jpg)        |
| Figure 7.1: Словарь для программы STUDENT    |

(ed: this should be a markdown table)

Прежде чем внимательно взглянуть на программу, давайте попробуем рассмотреть пример задачи: "If z is 3, what is twice z?/Если z равно 3, сколько будет дважды z?" Применение правил к входу оставляет следующую трассу:

```lisp
Input: (If z is 3, what is twice z)
Rule: ((if ?x |,| ?y)            (?x ?y))
Binding: ((?x . (z is 3)) (?y . (what is twice z)))
  Input: (z is 3)
  Rule: ((?x is ?y)                  (= ?x ?y))
  Result: (= z 3)
  Input: (what is twice z ?)
  Rule: ((?x is ?y)                  (= ?x ?y))
  Binding:((?x . what) (?y . (twice z)))
    Input: (twice z)
    Rule: ((twice ?x)                (* 2 ?x))
    Result: (* 2 z)
  Result: (= what (* 2 z))
Result: ((= z 3) (= what (* 2 z)))
```

Есть две незначительных сложности.
Во-первых, мы договорились реализовать наборы уравнений в виде списков уравнений.
В этом примере все сработало, и ответом был список из двух уравнений.
Но если используются вложенные образцы, ответ может быть чем-то вроде `((= a 5) ((= b (+ a 1)) (= c (+ a b))))`, который не является списком уравнений.
Функция `create-list-of-sizes` преобразует такой ответ в правильный список уравнений.
Другая сложность - выбор имен переменных.
Имея список таких слов, как (`the number of customers Tom gets`/количество клиентов, которых получает Том), мы хотим выбрать символ для их представления.
Ниже мы увидим, что выбран символ `customers`/клиенты, но есть и другие возможности.

Вот основная функция для STUDENT.
Сначала она удаляет слова, у которых нет содержимого, затем преобразует ввод в одно большое выражение с помощью `translate-to-expression` и разбивает его на отдельные уравнения с помощью `create-list-of-equations`.
Наконец, функция `solve-equations` выполняет математические вычисления и выводит решение.

```lisp
(defun student (words)
  "Solve certain Algebra Word Problems."
  (solve-equations
    (create-list-of-equations
      (translate-to-expression (remove-if #'noise-word-p words)))))

```

Функция `translate-to-expression` - это преобразователь на основе правил.
Он либо находит какое-то правило в `*student-rules*` для преобразования ввода, либо предполагает, что весь ввод представляет собой единственную переменную.
Функция `translate-pair` принимает пару привязки переменная/значение и преобразует значение рекурсивным вызовом `translate-to-expression`.

```lisp
(defun translate-to-expression (words)
  "Translate an English phrase into an equation or expression."
  (or (rule-based-translator
        words *student-rules*
        :rule-if #'rule-pattern :rule-then #'rule-response
        :action #'(lambda (bindings response)
                    (sublis (mapcar #'translate-pair bindings)
                              response)))
      (make-variable words)))

(defun translate-pair (pair)
  "Translate the value part of the pair into an equation or expression."
  (cons (binding-var pair)
        (translate-to-expression (binding-val pair))))
```

Функция `create-list-of-equations` принимает одно выражение, содержащее встроенные уравнения(равенства), и разделяет их на список уравнений:

```lisp
(defun create-list-of-equations (exp)
  "Separate out equations embedded in nested parens."
  (cond ((null exp) nil)
        ((atom (first exp)) (list exp))
        (t (append (create-list-of-equations (first exp))
                   (create-list-of-equations (rest exp))))))
```

Наконец, функция `make-variable` создает переменную для представления списка слов.
Мы делаем это, сначала удаляя все "зашумляющие слова" из ввода, а затем беря первый оставшийся символ.
Так, например, "the distance John traveled/расстояние, пройденное Джоном" и "the distance traveled by John", будут представлены одной и той же переменной `distance`, что безусловно, является правильным решением.
Однако "the distance Mary traveled" также будет представлено той же переменной, что, безусловно, является ошибкой.
Для ((`the number of customers Tom gets`/количество клиентов, которых получает Том) переменной будет `customers`, так как `the`, `of` и `number` - все это зашумляющие слова.
Она будет соответствовать (`the customers mentioned above`/клиенты, упомянутые выше) и (`the number of customers`/количество клиентов`), но не (`Tom's customers`/клиенты Тома).
На данный момент мы примем решение, первое не шумовое слово, но обратите внимание, что в упражнении 7.3 требуется исправление.

```lisp
(defun make-variable (words)
  "Create a variable name based on the given list of words"
    ;; The list of words will already have noise words removed
  (first words))

(defun noise-word-p (word)
  "Is this a low-content word which can be safely ignored?"
  (member word '(a an the this number of $)))
```

## 7.2 Решение Алгебраических Уравнений

Следующим шагом будет написание раздела решения уравнений для STUDENT.
Это больше упражнение по элементарной алгебре, чем по ИИ, но это хороший пример задачи манипулирования символами и, следовательно, интересная проблема программирования.

Программа STUDENT упоминала функцию `solve-equations` передав ей один аргумент, список уравнений, которые необходимо решить.
`solve-equations` печатает список уравнений, пытаясь решить их с помощью `solve` и печатает результат.

```lisp
(defun solve-equations (equations)
  "Print the equations and their solution"
  (print-equations "The equations to be solved are:" equations)
  (print-equations "The solution is:" (solve equations nil)))
```

Настоящая работа выполняется методом solve, который имеет следующую спецификацию: (1) Ищет уравнение, в котором ровно одно вхождение неизвестного.
(2) Преобразует это уравнение так, чтобы неизвестное было изолировано в левой части.
Это можно сделать, если мы ограничим возможные операторы +, -, * и /.
(3) Выполняет арифметические действия в правой части, получая числовое значение для неизвестного.
(4) Подставляет числовое значение вместо неизвестного во все другие уравнения и запоминает полученные значения.
Затем пробует решить получившуюся систему уравнений.
(5) Если шаг (1) завершился неудачно - если нет уравнения с точно одним неизвестным - тогда просто возвращает известные значения и не пытайтется решить что-либо еще.


В функцию `solve` передается система уравнений вместе со списком известных пар переменная/значение.
Изначально переменные неизвестны, поэтому этот список будет пустым.
`solve` просматривает список уравнений в поисках уравнения с точно одним неизвестным.
Если она может найти такое уравнение, она вызывает `isolate`, чтобы решить уравнение в терминах этого неизвестного.
Затем `resolve` подставляет значение переменной по всему списку уравнений и рекурсивно вызывает себя в результирующем списке.
Каждый раз, когда `resolve` вызывает себя, она удаляет одно уравнение из списка уравнений, которые нужно решить, и добавляет одно в список известных пар переменная/значение.
Поскольку список уравнений всегда становится короче, `solve` в конечном итоге должно завершиться.

```lisp
(defun solve (equations known)
  "Solve a system of equations by constraint propagation."
  ;; Try to solve for one equation, and substitute its value into
  ;; the others. If that doesn't work, return what is known.
  (or (some #'(lambda (equation)
                (let ((x (one-unknown equation)))
                  (when x
                    (let ((answer (solve-arithmetic
           (isolate equation x))))
                      (solve (subst (exp-rhs answer) (exp-lhs answer)
                                    (remove equation equations))
                             (cons answer known))))))
            equations)
      known))
```

`isolate` передается уравнение, которое гарантированно содержит одно неизвестное.
Она возвращает эквивалентное уравнение с неизвестным, изолированным в левой части.
Следует рассмотреть пять случаев: когда неизвестное остается только слева, все готово.
Второй случай - когда неизвестное находится где-нибудь с правой стороны.
Поскольку '=' коммутативно, мы можем свести проблему к решению эквивалентного уравнения переставленными левой и правой частями.

Далее мы должны иметь дело со случаем, когда неизвестное находится в сложном выражении в левой части.
Поскольку мы допускаем четыре оператора, а неизвестное может быть справа или слева, существует восемь возможностей.
Если X обозначает выражение, содержащее неизвестное, а A и B обозначают выражения без неизвестных, то возможны их следующие решения:

| []()                   |                        |
|------------------------|------------------------|
| (1) `X*A=B` => `X=B/A` | (5) `A*X=B` => `X=B/A` |
| (2) `X+A=B` => `X=B-A` | (6) `A+X=B` => `X=B-A` |
| (3) `X/A=B` => `X=B*A` | (7) `A/X=B` => `X=A/B` |
| (4) `X-A=B` => `X=B+A` | (8) `A-X=B` => `X=A-B` |

Возможности (1) - (4) обрабатываются случаем III, (5) и (6) случаем IV, и (7) и (8) случаем V.
В каждом случае преобразование не дает нам окончательного ответа, поскольку X не обязательно должно быть неизвестным; это могло быть сложное выражение, связанное с неизвестным.
Итак, мы должны снова вызвать isolate c полученным уравнением.
Читатель должен попытаться проверить, что преобразования (1) - (8) действительны, и что случаи с III по V реализуют их правильно.

```lisp
(defun isolate (e x)
  "Isolate the lone x in e on the left hand side of e."
  ;; This assumes there is exactly one x in e,
  ;; and that e is an equation.
  (cond ((eq (exp-lhs e) x)
         ;; Case I: X = A -> X = n
         e)
        ((in-exp x (exp-rhs e))
         ;; Case II: A = f(X) -> f(X) = A
         (isolate (mkexp (exp-rhs e) '= (exp-lhs e)) x))
        ((in-exp x (exp-lhs (exp-lhs e)))
         ;; Case III: f(X)*A = B -> f(X) = B/A
         (isolate (mkexp (exp-lhs (exp-lhs e)) '=
                         (mkexp (exp-rhs e)
                                (inverse-op (exp-op (exp-lhs e)))
                                (exp-rhs (exp-lhs e)))) x))
        ((commutative-p (exp-op (exp-lhs e)))
         ;; Case IV: A*f(X) = B -> f(X) = B/A
         (isolate (mkexp (exp-rhs (exp-lhs e)) '=
                         (mkexp (exp-rhs e)
                                (inverse-op (exp-op (exp-lhs e)))
                                (exp-lhs (exp-lhs e)))) x))
        (t ;; Case V: A/f(X) = B -> f(X) = A/B
         (isolate (mkexp (exp-rhs (exp-lhs e)) '=
                         (mkexp (exp-lhs (exp-lhs e))
                                (exp-op (exp-lhs e))
                                (exp-rhs e))) x))))
```

Напомним, чтобы доказать правильность функции, мы должны доказать, что она то что она в конечном итоге завершается и дает правильный ответ.
Для рекурсивной функции с несколькими альтернативными случаями мы должны показать, что каждая альтернатива действительна, а также что, каждая альтернатива каким-то образом приближается к концу (что любые рекурсивные вызовы включают 'более простые' аргументы).
Для `isolate`, элементарная алгебра показывает, что каждый шаг верен, или по крайней мере, почти верен.
Деление обоих частей уравнения на 0 не дает эквивалентного уравнения и мы никогда не проверяли этого.
Также возможно, что подобные ошибки могут возникнуть во время вызова `eval`.
Однако, мы предположим, что уравнение имеет единственное допустимое решение, тогда `isolate` выполняет только законные преобразования.

Труднее всего доказать, что `isolate` завершается.
Случай I явно завершается, и все остальные вносят свой вклад в изоляцию неизвестного расположенного с левой стороны.
Для любого уравнения, последовательность(sequence) будет первым из возможных вариантов использования случая II, за которым последует ряд рекурсивных вызовов использующих случаи от III до V.
Количество вызовов ограничено числом подвыражений в уравнении, поскольку каждый последующий вызов эффективно удаляет выражение слева и помещает его справа.
Следовательно, предполагая, что вход имеет конечный размер, мы должны в конечном итоге достичь рекуривного вызова для `isolate`, который будет использовать случай I и завершаться.

Когда `isolate` возвращается, правая часть должна состоять только из чисел и операторов.
Мы могли бы легко написать функцию для вычисления такого выражения.
Однако нам не нужно прилагать таких усилий, поскольку функция уже существует.
Структура данных exp была тщательно выбрана, чтобы быть той же структурой (списками с префиксными функциям), какую использует и сам Lisp для своих собственных выражений.
Таким образом, Lisp обнаружит, что правая часть является приемлемым выражением, которое может быть вычислено, если ввести его на верхнем уровне.
Lisp вычисляет выражения, вызывая функцию `eval`, поэтому мы можем вызывать `eval` напрямую и получить возвращаемое из неё число.
Функция `solve-arithmetic` возвращает уравнение вида (=  *var number*).

Вспомогательные функции для `solve` показаны ниже.
Большинство из них просты, но я отмечу некоторые из них.
Функция `prefix->infix` принимает выражение в префиксной нотации и преобразует его в инфиксное выражение, полностью заключенное в скобки.
В отличии от `isolate`, она предполагает, что выражения будут реализованы в виде списков.
`prefix->infix` используется в `print-equations` для создания более читабельного вывода.

```lisp
(defun print-equations (header equations)
  "Print a list of equations."
  (format t "~%~a~{~%  ~{ ~a~}~}~%" header
          (mapcar #'prefix->infix equations)))

(defconstant operators-and-inverses
  '((+ -) (- +) (* /) (/ *) (= =)))

(defun inverse-op (op)
  (second (assoc op operators-and-inverses)))

(defun unknown-p (exp)
  (symbolp exp))

(defun in-exp (x exp)
  "True if x appears anywhere in exp"
  (or (eq x exp)
      (and (listp exp)
           (or (in-exp x (exp-lhs exp)) (in-exp x (exp-rhs exp))))))

(defun no-unknown (exp)
  "Returns true if there are no unknowns in exp."
  (cond ((unknown-p exp) nil)
        ((atom exp) t)
        ((no-unknown (exp-lhs exp)) (no-unknown (exp-rhs exp)))
        (t nil)))

(defun one-unknown (exp)
  "Returns the single unknown in exp, if there is exactly one."
  (cond ((unknown-p exp) exp)
        ((atom exp) nil)
        ((no-unknown (exp-lhs exp)) (one-unknown (exp-rhs exp)))
        ((no-unknown (exp-rhs exp)) (one-unknown (exp-lhs exp)))
        (t nil)))

(defun commutative-p (op)
  "Is operator commutative?"
  (member op '(+ * =)))

(defun solve-arithmetic (equation)
  "Do the arithmetic for the right hand side."
  ;; This assumes that the right hand side is in the right form.
  (mkexp (exp-lhs equation) '= (eval (exp-rhs equation))))

(defun binary-exp-p (x)
  (and (exp-p x) (= (length (exp-args x)) 2)))

(defun prefix->infix (exp)
  "Translate prefix to infix expressions."
  (if (atom exp) exp
      (mapcar #'prefix->infix
              (if (binary-exp-p exp)
                  (list (exp-lhs exp) (exp-op exp) (exp-rhs exp))
                  exp))))
```

Вот пример `solve-equations` в действии, с системой двух уравнений.
Читатель должен пройти тарссировку, обнаруживая какой случай использовался при каждом вызове `isolate`, и проверяя правильность/точность каждого шага.

```lisp
> (trace isolate solve)
(isolate solve)
> (solve-equations '((= (+  3 4) (* (- 5 (+  2 x)) 7))
                            (= (+ (* 3 x) y) 12)))
The equations to be solved are:
      (3 + 4) = ((5 - (2 + X)) * 7)
      ((3 * X) + Y) = 12
(1 ENTER SOLVE: ((= (+  3 4) (* (- 5 (+  2 X)) 7))
                            (= (+ (* 3 X) Y) 12)) NIL)
    (1 ENTER ISOLATE: (= (+  3 4) (* (- 5 (+  2 X)) 7)) X)
        (2 ENTER ISOLATE: (= (* (- 5 (+  2 X)) 7) (+  3 4)) X)
            (3 ENTER ISOLATE: (= (- 5 (+  2 X)) (/ (+  3 4) 7)) X)
                (4 ENTER ISOLATE: (= (+  2 X) (- 5 (/ (+  3 4) 7))) X)
                    (5 ENTER ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)) X)
                    (5 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))
                (4 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))
            (3 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))
        (2 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))
    (1 EXIT ISOLATE: (= X (- (- 5 (/ (+  3 4) 7)) 2)))
    (2 ENTER SOLVE: ((= (+ (* 3 2) Y) 12)) ((= X 2)))
        (1 ENTER ISOLATE: (= (+ (* 3 2) Y) 12) Y)
          (2 ENTER ISOLATE: (= Y (- 12 (* 3 2))) Y)
          (2 EXIT ISOLATE: (= Y (- 12 (* 3 2))))
        (1 EXIT ISOLATE: (= Y (- 12 (* 3 2))))
        (3 ENTER SOLVE: NIL ((= Y 6) (= X 2)))
        (3 EXIT SOLVE: ((= Y 6) (= X 2)))
    (2 EXIT SOLVE: ((= Y 6) (= X 2)))
(1 EXIT SOLVE: ((= Y 6) (= X 2)))
The solution is:
      Y = 6
      X = 2
NIL
```

Теперь давайте займемся строкой форматирования `"~%~a~{~% ~{ ~  a  ~}~}~*%"*` в `print-equations.` Она может показаться бессмысленной тарабарщиной, но на самом деле в ней есть определенный смысл.
`format` обрабатывает строку, печатая каждый символьный знак, за исключением `"~"` указывающим на некоторые специальный действия форматирования, зависящие от следующего за ним знака.
Комбинация `"~%"` печатает знак новой строки, а `"~a"` печатает следующий аргумент `format`, который еще не использовался.
Таким образом четыре знака строки форматирования: `"~%~a"`, выводят знак новой строки, за которым следует аргумент `header`.
Комбинация `"~{"` обрабатывает соответствующий аргумент как список, и обрабатывает каждый элемент списка в соответствии со спецификацией между `"~{"` и следующими `"~}"`.
В данном случае, `equations` представлляет собой список уравнений, и каждое уравнение печатается с новой строки (`"~%"`) за которой следует два пробела, после чего следует обработка самого уравнения как списка, где каждый элемент печатается в формате `"~a"` с пробелом перед ним.
Значение `t` указанное в качестве первого аргумента для `format` означает вывод на стандартный поток вывода; так же может быть указан другой выходной поток.

Одно из неприятных мелких упущений в Lisp заключается в том, что нет стандартного соглашения о том, где печатать знаки новой строки!
В Си, например, самая первая строка кода в справочном руководстве выглядит так

```lisp
printf("hello, world\n");
```

Она ясно дает понять, что знак новой строки печатается *после* каждой линии.
Это соглашение настолько укоренилось в мире UNIX, что некоторые UNIX программы будут уходить в бесконечный цикл, если последняя строка в файле не заканчивается знаком новой строки.
В Лиспе, однако, функция `print` ставит знак новой строки *перед* печатаемым объектом и пробел после него.
Некоторые программы на Лиспе переносят политику перехода на новую строку перед `format`, а другие используют политику перехода на новую строку после.
Это становится проблемой только тогда, когда вы хотите объединить две программы, написанные под разными политиками.
Как возникли две конкурирующие политики?
В UNIX была только одна разумная политика, потому что весь ввод в интерпретатор UNIX (оболочку/shell) завершался знаками новой строки, поэтому небыло необходимости в предшествующем знаке новой строки.
Однако в некоторых интерпетаторах Lisp ввод может быть завершен соответствующей правой круглой скобкой.
В этом случае, требуется предшествующий знак новой строки, чтобы вывод не отображался в той же строке, что и ввод.

**Упражнение  7.1 [m]** Реализуйте `print-equations` используя только примитивные функции печати, такие как `terpri` и `princ`, а также явные циклы.

## 7.3 Примеры

Теперь перейдем к примерам, взятым из диссертации Bobrow's.
В первом примере, перед словом "then/что" необходимо вставить "what/затем", чтобы получить правильный ответ:

```lisp
> (student '(If the number of customers Tom gets is twice the square of
            20 % of the number of advertisements he runs |,|
            and the number of advertisements is 45 |,|
            then what is the number of customers Tom gets ?))
Решаемые уравнения:
      CUSTOMERS = (2 * (((20 / 100) * ADVERTISEMENTS) *
                      ((20 / 100) * ADVERTISEMENTS)))
      ADVERTISEMENTS = 45
      WHAT = CUSTOMERS
Решение:
      WHAT = 162
      CUSTOMERS = 162
      ADVERTISEMENTS = 45
NIL
```

Обратите внимание, что наша программа печатает значения всех переменных, которые она может найти, в то время как программа Bobrow's выводила только те значения, которые явно были запрошены в тексте.
Это пример того, что "больше значит меньше", т.е. напечатать все ответы может и впечатляюще, но на самом деле это легче сделать, чем решить, какие именно ответы следует распечатать.
Следующий пример решен не правильно:

```lisp
> (student '(The daily cost of living for a group is the overhead cost plus
            the running cost for each person times the number of people in
            the group |.| This cost for one group equals $ 100 |,|
            and the number of people in the group is 40 |.|
            If the overhead cost is 10 times the running cost |,|
            find the overhead and running cost for each person |.|))
The equations to be solved are:
      DAILY = (OVERHEAD + (RUNNING * PEOPLE))
      COST = 100
      PEOPLE = 40
      OVERHEAD = (10 * RUNNING)
      TO-FIND-1 = OVERHEAD
      TO-FIND-2 = RUNNING
The solution is:
      PEOPLE = 40
      COST = 100
NIL
```

Этот пример указывает на два важных ограничения нашей версии student по сравнению с программой Bobrow's.
Первая проблема заключается в именовании переменных.
Фразы "the daily cost of living for a group(суточный прожиточный минимум для группы)" и "this cost(эта стоимость)" означают одно и тоже количество, но наша программа дает им имена `daily(день)` и `cost(стоимость)` соответственно.
Программа Bobrow's обрабатывала названия, сначала рассматривая фразы как одинаковые, только если они идеально совпадали.
Если результирущую систему уравнений нельзя было решить, она пыталась снова, на этот раз считая фразы с одинаковыми словами идентичными.
(См. следующие упражнения.)

Другая проблема заключается в нашей функции `solve`.
Предполагая, что мы правильно присвоили переменные, `solve` может свести набор уравнений к двум:

```lisp
100 = (OVERHEAD + (RUNNING * 40))
OVERHEAD = (10 * RUNNING)
```

Это набор двух линейных уравнений с двумя неизвестными и имеет единственное решение при `RUNNING = 2, OVERHEAD = 20`.
Но наша версия `solve` не смогла найти это решение, поскольку ищет уравнения с одним неизвестным.
Вот еще один пример, с которым  `student` хорошо справляется:

```lisp
> (student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
            Kelly's IQ minus 80 is Robin's height |.|
            If Robin is 4 feet tall |,| how old is Fran ?))
The equations to be solved are:
      (FRAN / ROBIN) = (KELLY / 2)
      (KELLY - 80) = ROBIN
      ROBIN = 4
      HOW = FRAN
The solution is:
      HOW = 168
      FRAN = 168
      KELLY = 84
      ROBIN = 4
NIL
```

Но небольшое изменение приводит к проблеме:

```lisp
> (student '(Fran's age divided by Robin's height is one half Kelly's IQ |.|
            Kelly's IQ minus 80 is Robin's height |.|
            If Robin is 0 feet tall |,| how old is Fran ?))
The equations to be solved are:
      (FRAN / ROBIN) = (KELLY / 2)
      (KELLY - 80) = ROBIN
      ROBIN = 0
      HOW = FRAN
The solution is:
      HOW = 0
      FRAN = 0
      KELLY = 80
      ROBIN = 0
NIL
```

У этой проблемы нет правильного решения, потому что она предполагает деление на 0 (Robin's height).
Но `student` готов преобразовать первое уравенение в:

```lisp
FRAN = ROBIN * (KELLY / 2)
```

и затем подставить полученный `0` для `FRAN`.
Хуже того, деление на ноль, может появиться внутри `eval`:

```lisp
> (student '(Fran's age times Robin's height is one half Kelly's IQ |.|
            Kelly's IQ minus 80 is Robin's height |.|
            If Robin is 0 feet tall |,| how old is Fran ?))
The equations to be solved are:
      (FRAN * ROBIN) = (KELLY / 2)
      (KELLY - 80) = ROBIN
      ROBIN = 0
      HOW = FRAN
>>Error: There was an attempt to divide a number by zero
```

Однако можно утверждать, что неприятные примеры с делением на ноль не встречаются в текстах по алгебре.

Таким образом, STUDENT ведет себя достаточно хорошо, делая гораздо больше, чем просто игрушечная программа ELIZA.
STUDENT так же довольно эффективен; на моей машине для каждого из предыдущих примеров требуется меньше одной секунды.
Однако, его все еще можно расширить, чтобы иметь более мощные возможности для решения уравнений.
Другое дело - его лингвистический охват.
Хотя можно добавлять новые шаблоны, она на самом деле являются лишь уловками и не отражают основную структуру английских предложений.
Вот почему подход принятый в STUDENT был оставлен как тема для исследования.

## 7.4 История и ссылки

Bobrow's Ph.D.
thesis contains a complete description of STUDENT.
It is reprinted in [Minsky 1968](B9780080571157500285.xhtml#bb0845).
Since then, there have been several systems that address the same task, with increased sophistication in both their mathematical and linguistic ability.
[Wong (1981)](B9780080571157500285.xhtml#bb1420) describes a system that uses its understanding of the problem to get a better linguistic analysis.
[Sterling et al.
(1982)](B9780080571157500285.xhtml#bb1195) present a much more powerful equation solver, but it does not accept natural language input.
Certainly Bobrow's language analysis techniques were not very sophisticated by today's measures.
But that was largely the point: if you know that the language is describing an algebraic problem of a certain type, then you don't need to know very much linguistics to get the right answer most of the time.

## 7.5 Упражнения

**Exercise  7.2 [h]** Ранее мы говорили, что наша программа не может решать пары линейных уравнений, например:

```lisp
100 = (OVERHEAD + (RUNNING * 40))
OVERHEAD = (10 * RUNNING)
```

Первоначальная программа STUDENT могла решить эти уравнения.
Напишите Write a routine to do so.
You may assume there will be only two equations in two unknowns if you wish, or if you are more ambitious, you could solve a system of *n* linear equations with *n* unknowns.

**Exercise  7.3 [h]** Реализуйте версию алгоритма именования переменных Боброу.
Вместо того, чтобы брать первое слово каждого уравнения, создайте уникальный символ и свяжите с ним весь список слов.
На первом проходе каждый неравный список слов будет считаться отдельной переменной.
Если решение не достигнуто, списки слов, которые имеют общие слова, считайте одной и той же переменной, и попытка решения предпринимается снова.
Например, входные данные, содержащие фразы "the rectangle's width"(ширина прямоугольника) и "the width of the rectangle"(ширина прямоугольника), могут присвоить этим двум фразам переменные `v1` и` v2`.
Если попытка решить проблему не дает решения, программа должна понять, что `v1` и `v2` имеют общие слова "rectangle"(прямоугольник) и "width"(ширина), и добавить уравнение (`= v1 v2`) и повторить попытку.
Поскольку переменные являются произвольными символами, процедура печати, вероятно, должна печатать фразы, связанные с каждой переменной, а не с саму переменную.

**Exercise  7.4 [h]** Первоначальный STUDENT также имел набор «общеизвестных» уравнений, которые он мог использовать при необходимости.
В основном это были факты о коэффициентах преобразования, например (`1 inch = 2.54  cm`), т.е. 1 дюйм = 2,54 см».
Также были включены уравнения типа (`distance equal s rate times time`), т.е. расстояние равно  скорости умноженной на время, которые можно было использовать для решения таких задач, как: If the distance from Anabru to Champaign is 10 miles and the time it takes Sandy to travel this distance is 2 hours, what is Sandy's rate of speed?"(Если расстояние от Анабру до Шампейна составляет 10 миль, а время, необходимое Сэнди, чтобы преодолеть это расстояние, составляет 2 часа, то какое скорость Сэнди?) Внесите изменения, чтобы включить эту возможность.
Вероятно, это помогает только в сочетании с решением предыдущего упражнения.

**Exercise  7.5 [h]** Измените `student` так, чтобы он печатал значения только тех переменных, которые запрашиваются в задаче.
То есть, если дана задача "X равно 3.
Y равно 4.
Сколько X + Y?" Он не должен печатать значения для X и Y.

**Exercise  7.6 [m]** Попробуйте STUDENT по следующим примерам.
Убедитесь, что вы правильно обрабатываете специальные символы:

(a)  The price of a radio is 69.70 dollars.
If this price is 15% less than the marked The number of soldiers the Russians have is one half of the number of guns
!!!(p) {:.numlist1}

(b)  The number of soldiers the Russians have is one half of the number of guns they have.
The number of guns they have is 7000.
What is the number of soldiers they have?
!!!(p) {:.numlist1}

(c)  If the number of customers Tom gets is twice the square of 20 % of the number of advertisements he runs, and the number of advertisements is 45, and the profit Tom receives is 10 times the number of customers he gets, then what is the profit?
!!!(p) {:.numlist1}

(d)  The average score is 73.
The maximum score is 97.
What is the square of the difference between the average and the maximum?
!!!(p) {:.numlist1}

(e)  Tom is twice Mary's age, and Jane's age is half the difference between Mary and Tom.
If Mary is 18 years old, how old is Jane?
!!!(p) {:.numlist1}

(f)  What is 4  +  5* 14/7?
!!!(p) {:.numlist1}

(g)  *x  x  b  =  c  +  d.
b  x  c  =  x.
x  =  b  +  b.
b  =  5.*
!!!(p) {:.numlist1}

**Exercise  7.7 [h]** Инфиксно-префиксные правила `Student` правильно учитывают приоритет операторов, но они не обрабатывают ассоциативность стандартным образом.
Например, (`12 - 6 - 3`) переводится как (` - 12 (- 6 3)`) или `9`, когда обычное соглашение интерпретирует это как (`- (- 12 6) 3`) или «3».
Исправьте ученика, чтобы он справился с этим соглашением.

**Exercise  7.8 [d]** Найдите математически ориентированную область, достаточно ограниченную, чтобы STUDENT мог решать в ней задачи.
Примером может служить химия растворов (расчет концентраций pH).
Напишите необходимые `*student-rules*` и протестируйте полученную программу.

**Exercise  7.9 [m]** Проанализируйте сложность `one-unknown` и внедрите более эффективную версию.

**Exercise  7.10 [h]** Статья Боброу о STUDENT (1968) включает приложение, в котором абстрактно описываются все проблемы, которые может решить его система.
Создайте аналогичную характеристику для этой версии программы.

## 7.6 Ответы

**Answer 7.1**

```lisp
(defun print-equations (header equations)
    (terpri)
    (princ header)
    (dolist (equation equations)
        (terpri)
        (princ " ")
        (dolist (x (prefix->infix equation))
            (princ " ")
            (princ x))))
```

**Answer 7.9**`one-unknown` очень неэффективен, потому что он ищет каждый подкомпонент выражения дважды.
Например, рассмотрим уравнение:

`(= (+ (+`  x  `2) (+  3 4)) (+ (+  5 6) (+  7 8)))`

Чтобы решить, есть ли у него одно неизвестное, `one-unknown` вызовет `no-unknown` в левой части, и, поскольку он не работает, вызовет его снова в правой части.
Хотя нужно рассмотреть только восемь атомов, в конечном итоге он вызывает «`no-unknown 17` раз и `one-unknown 4` раза.
В общем, для дерева глубины *n* выполняется примерно *2n* вызовов `no-unknown`.
Это явно расточительно; нет необходимости смотреть на каждый компонент более одного раза.

В следующей версии используется вспомогательная функция, `find-one-unknown`, у которой есть аккумулирующий параметр ʻunknown`. Этот параметр может принимать три возможных значения: nil, что указывает на то, что ничего неизвестного не найдено; или единственное неизвестное, что было найдено до сих пор; или число 2, указывающее, что были обнаружены два неизвестных, и поэтому окончательный результат должен быть равен нулю.
Функция `find-one-unknown` имеет четыре случая: (1) Если мы уже нашли два неизвестных, то верните 2, чтобы указать это.
(2) Если входное выражение является неатомарным выражением, то сначала посмотрите на его левую часть на предмет неизвестных и передайте результат, найденный на этой стороне, в качестве аккумулятора для поиска правой части.
(3) Если выражение неизвестно, и если это второе найденное выражение, вернуть `2`; в противном случае верните само неизвестное.
(4) Если выражение представляет собой атом, который не является неизвестным, просто верните накопленный результат.

```lisp
(defun one-unknown (exp)
    "Returns the single unknown in exp, if there is exactly one."
    (let ((answer (find-one-unknown exp nil)))
        ;; If there were two unknowns, return nil;
        ;; otherwise return the unknown (if there was one)
        (if (eql answer 2)
              nil
              answer)))
(defun find-one-unknown (exp unknown)
    "Assuming UNKNOWN is the unknown(s) found so far, decide
    if there is exactly one unknown in the entire expression."
    (cond ((eql unknown 2) 2)
                ((exp-p exp)
                    (find-one-unknown
                        (exp-rhs exp)
                        (find-one-unknown (exp-lhs exp) unknown)))
                ((unknown-p exp)
                    (if unknown
                            2
                            exp))
                (t unknown)))
```

----------------------

[1](#xfn0015)[Page 316](B9780080571157500108.xhtml#p316) of *Common Lisp the Language* says, "Because a constructor of this type operates By Order of Arguments, it is sometimes known as a BOA constructor."
!!!(p) {:.ftnote1}