# Глава 1
## Введение в Лисп

> Вы думаете, что знаете, когда вы учитесь, более уверены, когда вы можете писать, еще более уверены, когда вы можете учить, но по настоящему вы уверены, когда можете программировать.

> -Alan Perlis  
> Yale University computer scientist

Эта глава предназначена для людей с небольшим или полным отсутствием опыта работы на Лиспе.
Читатели, уверенные в своих способностях к программированию на Лиспе, могут быстро просмотреть эту главу или пропустить ее полностью.
Эта глава пробегает по верхам, поэтому те, у кого мало опыта программирования, или любой читатель, который находит эту главу трудной, должны искать дополнительный ознакомительный текст.
Мои рекомендации приведены в предисловии.

Компьютеры позволяют производить вычисления.
Программа обработки текстов имеет дело со словами, а калькулятор - с числами, но принципы те же.
В обоих случаях вы вводите входные данные (слова или числа) и указываете операции (например, удаление слова или сложение двух чисел) для получения результата (завершенного документа или вычисления).

Мы будем называть все, что может быть представлено в памяти компьютера как *вычислительный объект* или просто *объект*.
Таким образом, слова, абзацы и числа могут быть объектами.
И поскольку операции (удаление и добавление) должны быть представлены где-то в памяти компьютера, они также являются объектами.

Обычно различие между компьютерным "пользователем" и компьютерным "программистом" состоит в том, что пользователь предоставляет новые входные данные или данные (слова или числа), в то время как программист определяет новые операции(*operations*) или программы, а также новые типы(*types*) данных.
Каждый новый объект, будь то данные(datum) или операция, должен быть определен в терминах ранее определенных объектов.
Плохая новость заключается в том, что это может быть довольно утомительно, чтобы получить эти определения правильно.
Хорошая новость заключается в том, что каждый новый объект, в свою очередь, может быть использован в определении будущих объектов.
Таким образом, даже сложные программы могут быть построены из более мелких и простых объектов.
Эта книга охватывает ряд типичных проблем искусственного интеллекта, показывая, как каждая проблема может быть разбита на управляемые части, а также как каждая часть может быть описана на языке программирования Common Lisp.
В идеале, читатели узнают достаточно, изучая эти примеры, чтобы атаковать новые проблемы ИИ со стилем, изяществом и успехом.

Рассмотрим простой пример вычисления: найти сумму двух чисел, скажем 2 и 2.
Если бы у нас был под рукой калькулятор, мы набрали бы "2 + 2 =" и увидели бы отображаемый ответ.
На калькуляторе, использующем обратную польскую нотацию, мы должны были бы ввести "2 2 +", чтобы увидеть тот же ответ.
В Lisp, как и в калькуляторе, пользователь выполняет интерактивный диалог с компьютером, вводя выражение и смотря, как компьютер печатает значение этого выражения.
Этот интерактивный режим отличается от многих других языков программирования, которые предлагают только пакетный режим, в котором вся программа компилируется и запускается до того, как можно увидеть какой-либо вывод.

Мы запускаем карманный калькулятор, щелкая выключателем включения/выключения.
Программа Lisp также должна быть запущена, но детали варьируются от одного компьютера к другому, поэтому я не могу объяснить, как будет работать ваш Lisp.
Предполагая, что нам удалось запустить Lisp, мы, вероятно, увидим какую-то подсказку.
На моем компьютере Lisp печатает "'>'", чтобы указать, что он готов принять следующее вычисление.
Итак, перед нами экран, который выглядит следующим образом:

```lisp
>
```

Теперь мы можем ввести наши вычисления и увидеть результат.
Оказывается, что соглашение Lisp для арифметических выражений немного отличается: вычисление состоит из заключенного в скобки списка с первым именем операции, за которым следует любое количество операндов или аргументов.
Это называется *префиксная нотация.*

```lisp
> (+  2 2)
4
>
```

Мы видим, что Lisp напечатал ответ, 4, а затем еще одно приглашение, >, чтобы указать, что он готов к следующему вычислению.
На протяжении всей этой книги все выражения Lisp будут отображаться шрифтом `typewriter`.
Текст в той же строке, что и приглашение ">", вводится пользователем, а следующий за ним текст выводится компьютером.
Обычно ввод, введенный программистом, будет состоять из букв "нижнего регистра"(`lowercase`), а вывод, напечатанный компьютером, - из букв "верхнего регистра"(`UPPERCASE`).
Конечно, для таких символьных знаков как + и 4, нет никакой разницы.

Чтобы сэкономить место на странице, выходные данные иногда отображаются в той же строке, что и входные данные, разделенные стрелкой ( = > ), которая может быть прочитана как "вычисляется", а также может рассматриваться как значение клавиши return или enter, которую пользователь нажимает для завершения ввода:

```lisp
> (+  2 2) => 4
```

Одним из преимуществ скобочной префиксной нотации является то, что скобки четко обозначают начало и конец выражения.
Если мы хотим, мы можем передать + больше двух аргументов, и он все равно сложит их все:

```lisp
> (+ 1 2 3 4 5 6 7 8 9 10) => 55
```

На этот раз мы попытаемся вычислить (9000 + 900 + 90  + 9) - (5000 + 500 + 50 + 5):

```lisp
> (- (+ 9000 900 90 9) (+ 5000 500 50 5)) => 4444
```

Этот пример показывает, что выражения могут быть вложенными.
Аргументы функции "-" это заключенные в скобки списки, а аргументы каждой функции "+" - атомы.
Лисп-нотация может показаться необычной по сравнению со стандартной математической нотацией, но у этой нотации есть свои преимущества; поскольку Лисп-выражения могут состоять из функции, за которой следует любое количество аргументов, нам не нужно постоянно повторять `"+."` Более важным, чем нотация, является правило вычисления.
В Lisp списки вычисляются путем предварительного вычисления всех аргументов, а затем применения функции к аргументам, тем самым вычисляя результат.
Это правило намного проще, чем правило для вычисления обычных математических выражений, где есть много условностей, которые нужно запомнить, например, делать умножения и деления перед сложением и вычитанием.
Ниже мы увидим, что фактическое правило вычисления в Lisp немного сложнее, но не намного.

Иногда программисты, знакомые с другими языками, имеют предубеждения, которые затрудняют им изучение Лиспа.
Для них здесь стоит подчеркнуть три момента.
Во-первых, многие другие языки проводят различие между утверждениями и выражениями.
Выражение, такое как `2 + 2`, имеет значение, но утверждение, такое как `x  = 2 + 2`, не имеет значения.
Утверждения имеют эффекты, но они не возвращают значения.
В Lisp такого различия нет: каждое выражение возвращает значение.
Это правда, что некоторые выражения имеют эффекты, но даже эти выражения также возвращают значения.

Во-вторых, лексические правила для Lisp намного проще, чем правила для других языков.
В частности, меньше знаков препинания: только круглые скобки, кавычки (одинарные, двойные и обратные), пробелы и запятая служат для отделения символов друг от друга.
Таким образом, в то время как утверждение `y=a*x+3` анализируется как семь отдельных лексем в других языках, в Lisp оно будет рассматриваться как один символ.
<a id="tfn01-1"></a>
Чтобы получить список токенов, мы должны были бы вставить пробелы: `(y = a * x + 3)`.[1](#fn01-1)

В-третьих, хотя многие языки используют точки с запятой для разграничения операторов, Lisp не нуждается в точках с запятой, поскольку выражения разделяются скобками.
Lisp выбирает использовать точки с запятой для другой цели-для обозначения начала комментария, который длится до конца строки

```lisp
> (+ 2 2) ; this is a comment
4
```

## 1.1 Символьные вычисления

Все, что мы делали до сих пор, - это манипулировали числами так же, как простой карманный калькулятор.
Lisp является более полезным, чем калькулятор по двум основным причинам.
Во-первых, он позволяет нам манипулировать объектами, отличными от чисел, а во-вторых, он позволяет нам определять новые объекты, которые могут быть полезны в последующих вычислениях.
Мы рассмотрим эти два важных свойства по очереди.

Помимо чисел, Lisp может представлять знаки(символьные знаки, буквы), строки знаков и произвольные символы, где мы вольны интерпретировать эти символы как относящиеся к вещам вне мира математики.
Lisp также может создавать неатомные объекты, объединяя несколько объектов в список.
Эта возможность является фундаментальной и хорошо поддерживается в языке; на самом деле, имя Lisp является сокращением для обработки списков.

Вот пример вычисления со списками:

```lisp
> (append '(Pat Kim) '(Robin Sandy)) => (PAT KIM ROBIN SANDY)
```

Это выражение соединяет два списка имен.
Правило для вычисления этого выражения такое же, как правило для числовых вычислений: примените функцию (в данном случае append) к значению аргументов.

Необычной частью является кавычка `(')`, которая служит для блокирования вычисления следующего выражения, возвращая его буквально.
Если бы у нас было только выражение  `(Pat Kim),` оно было бы вычислено путем рассмотрения `Pat` как функции и применения его к значению выражения `Kim`.
Это не то, что  мы хотели сделать.
Кавычка указывает Lisp рассматривать список как часть данных, а не как вызов функции:

```lisp
> '(Pat Kim) (PAT KIM)
```

На других компьютерных языках (и на английском) кавычки обычно идут парами: одна для обозначения начала и одна для обозначения конца.
В Лиспе одинарная кавычка используется для обозначения начала выражения.
Поскольку мы всегда знаем, какой длины одиночное выражение - либо до конца атома, либо до соответствующей круглой скобки списка - нам не нужен явный знак пунктуации, чтобы сообщить нам, где заканчивается выражение.
Кавычки могут использоваться в списках, как в `'(Pat Kim)`, в символах, как в `'Robin`, и фактически в любом другом месте.
Вот некоторые примеры:

```lisp
> 'John => JOHN

> '(John Q Public) => (JOHN Q PUBLIC)

> '2 => 2

> 2 => 2

> '(+  2 2) => (+  2 2)

> (+  2 2) 4

> John => *Error: JOHN is not a bound variable*

> (John Q Public) => *Error: JOHN is not a function*
```

Обратите внимание, что `'2` вычисляется как `2`, потому что это выражение в кавычках, а `2` вычисляется как `2`, потому что числа вычисляются сами в себя.
Тот же результат, другая причина.
Напротив, '`John` вычисляется как `John`, потому что это выражение в кавычках, но вычисление `John` приводит к ошибке, потому что вычисление символа означает получение значения символа, а значение `John` присвоено не было.

Символьные вычисления могут быть вложенными и даже смешиваться с числовыми вычислениями.
Следующее выражение создает список имен немного другим способом, чем мы видели ранее, используя встроенную функцию `list`.
Затем мы увидим, как найти количество элементов в списке, используя встроенную функцию `length:`

```lisp
> (append '(Pat Kim) (list '(John Q Public) 'Sandy))
(PAT KIM (JOHN Q PUBLIC) SANDY)

> (length (append '(Pat Kim) (list '(John Q Public) 'Sandy)))
4
```

Есть четыре важных момента, которые нужно отметить о символах:

*   Во-первых, важно помнить, что Lisp не придает никакого внешнего значения объектам, которыми он манипулирует.
Например, мы, естественно, думаем о (`Robin Sandy`) как о списке двух имен, а (`John Q Public`) как о списке состоящем из имени, среднего инициала и фамилии одного человека.
У Лиспа нет таких предубеждений.
Для Лиспа, как `Robin`, так и `xyzzy`, оба очень хорошие символы.

*   Во-вторых, чтобы выполнить приведенные выше вычисления, мы должны были знать, что `append, length` и + являются определенными функциями в Common Lisp.
Изучение языка включает в себя запоминание словарных единиц (или знание того, где их искать), а также изучение основных правил формирования выражений и определения того, что они означают.
Common Lisp предоставляет более 700 встроенных функций.
В какой-то момент читатель должен пролистать справочный текст, чтобы увидеть, что там есть, но большинство важных функций представлены в части I этой книги.

*   В-третьих, обратите внимание, что символы в Common Lisp не чувствительны к регистру символьных знаков.
<a id="tfn01-2"></a>
Под этим я подразумеваю, что входные данные `John, john,` и `jOhN` относятся к одному и тому же символу, который обычно печатается как `JOHN.`[2](#fn01-2)

*   В-четвертых, обратите внимание, что в символах допускается большое разнообразие символьных знаков: цифры, буквы и другие знаки препинания, такие как `'+'`  или  `'!'`
Точные правила для того, что представляет собой символ, немного сложны, но нормальное соглашение заключается в использовании символов, состоящих в основном из букв, со словами, разделенными тире   `(-)`, и, возможно, с числом в конце.
Некоторые программисты более либеральны в именовании переменных и включают такие символы, как   `'?!$/<=>'`.
Например, функция конвертации долларов в иены может иметь имя, начинающееся с символа   `$-to-yen`   или   `$->yen`    в Лиспе, хотя можно было бы использовать что-то вроде   `DollarsToYen, dollars_to_yen`   или   `dol2yen`   в Pascal или C.
Есть несколько исключений из этих соглашений об именовании, которые будут рассмотрены по мере их появления.

## 1.2 Переменные

Мы познакомились с некоторыми основами символических вычислений.
Теперь мы перейдем к, пожалуй, самой важной характеристике языка программирования: способности определять новые объекты в терминах других и давать им имена для дальнейшего использования.
Здесь символы снова играют важную роль - они используются для именования переменных.
Переменная может принимать значение, которое может быть любым объектом Lisp.
Один из способов дать значение переменной использовать `setf`:

```lisp
> (setf p '(John Q Public)) => (JOHN Q PUBLIC)
> p => (JOHN Q PUBLIC)
> (setf x 10) => 10
> (+ x x) => 20
> (+ x (length p)) => 13
```

После присвоения значения (`John Q Public`) переменной с именем `p`, мы можем обратиться к значению с именем `p`.
Аналогично, после присвоения значения переменной с именем `x`, мы можем ссылаться как на `x`, так и на `p`.

Символы также используются для именования функций в Common Lisp.
Каждый символ может быть использован в качестве имени переменной или функции, или и того, и другого, хотя редко (и потенциально запутанно), чтобы символы становились именами обоих.
Например, `append` и `length`  -  это символы, которые именуют функции, но не имеют значений в качестве переменных, а `pi` - это не имя функции, а переменная, значение которой равно 3.1415926535897936 (или около того).

## 1.3 Специальные Формы

Внимательный читатель заметит, что `setf` нарушает правило вычисления выражений.
Ранее мы говорили, что такие функции, как `+`, -  и  `append` работают, сначала вычисляя все свои аргументы, а затем применяя функцию к результату.
Но `setf` не следует этому правилу, потому что `setf` - это вообще не функция.
Скорее, это часть базового синтаксиса Lisp.
Помимо синтаксиса атомов и вызова функций, Lisp имеет небольшое количество синтаксических выражений.
Они известны как *специальные формы.*
Они служат той же цели, что и операторы в других языках программирования, и действительно имеют некоторые из тех же синтаксических маркеров, таких как `if` и `loop`.
Существует два основных различия между синтаксисом Lisp и другими языками.
Во-первых, синтаксические формы Lisp-это всегда списки, в которых первый элемент является одним из небольшого числа привилегированных символов.
`setf` - один из этих символов, поэтому (`setf x 10`) - это специальная форма.
Во-вторых, специальные формы-это выражения, возвращающие значение.
В этом отличие их от операторов большинства других языков, которые имеют эффект, но не возвращают значение.

При вычислении выражения подобного `(setf x (+1 2)`), мы устанавливаем переменную, обозначаемую символом `x`, значением  `(+1 2)`, которое равно `3`.
Если бы `setf` была нормальной функцией, мы бы вычислили и символ `x` и выражение `(+  1 2)` и сделали что-то с этими двумя значениями, что совсем не то, что мы хотим.
`setf` называется специальной формой, потому что она делает нечто особенное: если бы её не существовало, было бы невозможно написать функцию, которая присваивает значение переменной.
Философия Lisp состоит в том, чтобы предоставить небольшое количество специальных форм для выполнения вещей, которые иначе не могли бы быть выполнены, а затем ожидать, что пользователь напишет все остальное, например функции.

Термин "специальная форма" используется путано для обозначения как символов типа `setf`, так и выражений, которые начинаются с них, например `(setf x 3)`.
В книге *Common LISPcraft,* Wilensky устраняет неоднозначность называя `setf` С *специальной функцией* и резервируя термин *специальная форма* для (`setf x 3`).
Эта терминология подразумевает, что `setf` - это просто еще одна функция, но особая в том смысле, что ее первый аргумент не вычисляется.
Такая точка зрения имела смысл в те дни, когда Лисп был главным образом интерпретируемым языком.
Современная точка зрения состоит в том, что `setf` не следует рассматривать как какую-то ненормальную функцию, а скорее как маркер особого синтаксиса, который будет специально обработан компилятором.
Таким образом, специальная форма `(setf x (+  2 1))` должна рассматриваться как эквивалент `x = 2 + 1` в `C`.
Когда есть риск путаницы, мы будем называть `setf` *оператором специальной формы* и `(setf x 3)` *выражением специальной формы.*

Оказывается, что кавычка - это просто аббревиатура для другой специальной формы.
Выражение '*x* является эквивалентом `(quote x)`, выражения особой формы , которое вычисляется в *x.*
Специальные операторы форм, используемые в этой главе:

| Спец.форма      | Действие                                     |
|-----------------|----------------------------------------------|
| `defun`         | определяет функцию                           |
| `defparameter`  | определяет специальную переменную            |
| `setf`          | устанавливает переменную или поле новым значением
| `let`           | связывает локальную(ные) переменную(ные)     |
| `case`          | выбор из нескольких альтернатив              |
| `if`            | выполняет одно или другое выражение, в зависимости от теста
| `function (#')` | ссылка на функцию                            |
| `quote (')`     | ввести постоянные данные                     |

## 1.4 Списки

До сих пор мы видели две функции, которые работают со списками: `append` and `length.` Поскольку списки важны, давайте рассмотрим еще несколько функций обработки списков:

```lisp
> p => (JOHN Q PUBLIC)

> (first p) JOHN

> (rest p) => (Q PUBLIC)

> (second p) => Q

> (third p) => PUBLIC

> (fourth p) => NIL

> (length p) => 3
```

Функции `first, second, third` и `fourth` называются точно: `first` возвращает первый элемент списка, `second` дает вам второй элемент и так далее.
Функция `rest` не столь очевидна; ее название означает "остальная часть списка после первого элемента". Символ `nil` и форма `()` полностью синонимичны; они оба являются представлениями пустого списка.
`nil` также используется для обозначения значения "false" в Lisp.
Таким образом, `(fourth p)` это `nil`, потому что нет четвертого элемента `p`.
Обратите внимание, что списки не обязательно должны состоять только из атомов, но могут содержать подсписки в виде элементов:

```lisp
> (setf x '((1st element) 2 (element 3) ((4)) 5))
((1ST ELEMENT) 2 (ELEMENT 3) ((4)) 5)

> (length x) => 5

> (first x) => (1ST ELEMENT)

> (second x) => 2

> (third x) => (ELEMENT 3)

> (fourth x) => ((4))

> (first (fourth x)) => (4)

> (first (first (fourth x))) => 4

> (fifth x) => 5

> (first x) => (1ST ELEMENT)

> (second (first x)) => ELEMENT
```

До сих пор мы видели, как получить доступ к частям списков.
Кроме того, можно создавать новые списки, как показывают эти примеры:

```lisp
> p => (JOHN Q PUBLIC)

> (cons 'Mr p) => (MR JOHN Q PUBLIC)

> (cons (first p) (rest p)) => (JOHN Q PUBLIC)

> (setf town (list 'Anytown 'USA)) => (ANYTOWN USA)

> (list p 'of town 'may 'have 'already 'won!) =>
((JOHN Q PUBLIC) OF (ANYTOWN USA) MAY HAVE ALREADY WON!)

> (append p '(of) town '(may have already won!)) =>
(JOHN Q PUBLIC OF ANYTOWN USA MAY HAVE ALREADY WON!)

> p => (JOHN Q PUBLIC)
```

Функция cons расшифровывается как " построить(construct)."
<a id="tfn01-3"></a>
Она принимает в качестве аргументов элемент и список, [3](#fn01-3) и строит новый список, первым элементом в котором является переданный элемент, а rest(остальные) - исходным списком.
`list` принимает любое количество элементов в качестве аргументов и возвращает новый список, содержащий эти элементы по порядку.
Мы уже видели `append`, который похож на `list`; он принимает в качестве аргументов любое количество списков и соединяет их все вместе, образуя один большой список.
Таким образом, аргументы для `append` должны быть списками, в то время как аргументы для `list` могут быть списками или атомами.
Важно отметить, что эти функции создают новые списки, а не изменяют старые.
Когда мы говорим `(append p q)`, результатом является создание совершенно нового списка, который начинается с тех же элементов, которые были в `p`.
Сам `p`  остается неизменным.

Теперь давайте отойдем от абстрактных функций над списками и рассмотрим простую проблему: если имя человека представлено в виде списка, как мы можем извлечь его фамилию?
Для `(JOHN Q PUBLIC)` мы могли бы просто использовать функцию `third`, но это не сработало бы для кого-то без второго имени.
В Common Lisp есть функция под названием `last`; возможно, это сработает.
Мы можем поэкспериментировать:

```lisp
> (last p) => (PUBLIC)

> (first (last p)) => PUBLIC
```

<a id="tfn01-4"></a>
Оказывается, что `last` порочно возвращает список последнего элемента, а не сам последний элемент.[4](#fn01-4)
Таким образом, нам нужно объединить `first` и `last`, чтобы выбрать фактический последний элемент.
Мы хотели бы сохранить проделанную работу и дать ей правильное описание, например фамилия - `last-name`.
Мы могли бы использовать `setf`, чтобы сохранить фамилию в `p`, но это не помогло бы определить любую другую фамилию.
Вместо этого мы хотим определить новую функцию, которая вычисляет последнее имя *любого* имени, представленного в виде списка.
Следующий раздел делает именно это.

## 1.5 Определение Новых Функций

Специальная форма "defun" расшифровывается как "define function/определить функцию"."
Она используется здесь для определения новой функции, называемой фамилия/`last-name`:

```lisp
(defun last-name (name)
  "Select the last name from a name represented as a list."
  (first (last name)))
```

Мы даем нашей новой функции имя `last-name.` Она имеет  *список параметров*, состоящий из одного параметра: (`name`).
Это означает, что функция принимает один аргумент, который мы будем называть `name`.
В ней также есть строка документации(*documentation string*), в которой указано, что делает функция.
Она не используется ни в каких вычислениях, но строки документации являются важными инструментами для отладки и понимания больших систем.
Тело определения - это `(first (last name))`, которое мы использовали раньше, чтобы выбрать фамилию из `p`.
Разница в том, что здесь мы хотим выбрать фамилию из любого `name,` а не только конкретного имени `p`.

В общем случае определение функции принимает следующий вид (где строка документации необязательна, а все остальные части обязательны):

```lisp
(defun *function-name* (*parameter...*)
      "*documentation string*"
      *function-body...*)
```

Имя функции должно быть символом, параметры обычно являются символами (с некоторыми осложнениями, которые будут объяснены позже), а тело функции состоит из одного или нескольких выражений, которые вычисляются при вызове функции.
Значение последнего выражения возвращается как значение вызова функции.

Как только мы определили `last-name,` мы можем использовать ее так же, как и любую другую функцию Lisp:

```lisp
> (last-name p) => PUBLIC

> (last-name '(Rear Admiral Grace Murray Hopper)) => HOPPER

> (last-name '(Rex Morgan MD)) => MD

> (last-name '(Spot)) => SPOT

> (last-name '(Aristotle)) => ARISTOTLE
```

Последние три примера указывают на неотъемлемое ограничение занятия программированием.
Когда мы говорим `(defun last-name...)` мы на самом деле не определяем, что означает для человека иметь фамилию; мы просто определяем операцию над представлением имен в терминах списков.
Наши интуитивные представления о том, что MD - это титул, Spot - это имя собаки, а Aristotle(Аристотель) жил до того, как было изобретено понятие фамилии, не представлены в этой операции.
Однако мы всегда можем изменить определение `last-name`, чтобы включить в него эти проблемные случаи.

Мы также можем определить функцию имя - `first-name`.
Даже если это определение тривиально (оно совпадает с функцией `first`), все равно хорошей практикой является явное определение `first-name`.
Затем мы можем использовать функцию `first-name`, когда мы имеем дело с именами, и `first`, когда мы имеем дело с произвольными списками.
Компьютер будет выполнять одну и ту же операцию в каждом конкретном случае, но мы как программисты (и читатели программ) будем меньше путаться.
Еще одно преимущество определения конкретных функций, таких как `first-name`, заключается в том, что если мы решим изменить представление имен, нам придется изменить только определение `first-name`.
Это гораздо более простая задача, чем поиск по большой программе и изменение использования `first`, которые ссылаются на имена, оставляя другие виды использования в покое.

```lisp
(defun first-name (name)
  "Select the first name from a name represented as a list."
  (first name))

> p => (JOHN Q PUBLIC)`

> (first-name p) => JOHN`

> (first-name '(Wilma Flintstone)) => WILMA`

> (setf names '((John Q Public) (Malcolm X)
              (Admiral Grace Murray Hopper) (Spot) 
              (Aristotle) (A A Milne) (Z Z Top)
              (Sir Larry Olivier) (Miss Scarlet))) => 

((JOHN Q PUBLIC) (MALCOLM X) (ADMIRAL GRACE MURRAY HOPPER)
 (SPOT) (ARISTOTLE) (A A MILNE) (Z Z TOP) (SIR LARRY OLIVIER)
 (MISS SCARLET))

> (first-name (first names)) => JOHN
```

В последнем выражении мы использовали функцию `first`, чтобы выбрать первый элемент в списке имен, а затем функцию `first-name`, чтобы выбрать первое имя этого элемента.
Мы могли бы также сказать `(first (first names))` или даже `(first (first-name names))` и все так же получить `JOHN,` но мы не будем точно представлять, что считается именем и что считается списком имен.

## 1.6 Использование Функций

Одна хорошая вещь в определении списка имен, как мы сделали выше, заключается в том, что он облегчает тестирование наших функций.
Рассмотрим следующее выражение, которое можно использовать для проверки функции `last-name` :

```lisp
> (mapcar #'last-name names)
(PUBLIC X HOPPER SPOT ARISTOTLE MILNE TOP OLIVIER SCARLET)
```

Странная нотация `#'` ссылается по имени функции к самой функции.
Она аналогична обозначению `'x`.
Встроенной функции `mapcar` передается два аргумента, функция и список.
Она возвращает список, построенный путем вызова функции для каждого элемента входного списка.
Другими словами, приведенный выше вызов `mapcar` эквивалентен:

```lisp
(list (last-name (first names))
      (last-name (second names))
      (last-name (third names))
```

название `mapcar` происходит от того, что она "maps/отображает" функцию для каждого из аргументов.
Часть названия `car`  относится к Лисп функция `car`, старое название для `first`.
`cdr` - это старое название для `rest`("остаток").
Эти имена означали абривиатуру "contents of the address register" и "contents of the decrement register," - инструкций, которые использовались в первой реализации Lisp на IBM 704.
Я уверен, вы согласитесь, что `first` и `rest` - гораздо лучшие имена, и они будут использоваться вместо `car` и `cdr` всякий раз, когда мы говорим о списках.
Однако мы будем продолжать использовать `car` и `cdr` в некоторых случаях, когда мы рассматриваем пару значений, которые не рассматриваются как список.
Имейте в виду, что некоторые программисты все еще используют `car` и `cdr` для списков.

Вот еще несколько примеров `mapcar`:

```lisp
> (mapcar #'- '(1 2 3 4)) => (-1 -2 -3 -4)

> (mapcar #'+ '(1 2 3 4) '(10 20 30 40)) => (11 22 33 44)
```

Этот последний пример показывает, что `mapcar` может быть передано три аргумента, и в этом случае первый аргумент должен быть функцией двух аргументов, которая будет применена к соответствующим элементам двух других списков.
В общем случае `mapcar` ожидает в качестве своего первого аргумента функцию *n* - арности, за которой следуют *n* списков.
Сначала она применяет функцию к списку аргументов, полученному путем сбора первого элемента из каждого списка.
Затем она применяет функцию ко второму элементу каждого списка и так далее, пока один из списков не будет исчерпан.
Она возвращает список всех вычисленных значений функции.

Теперь, когда мы понимаем `mapcar`, давайте использовать её для тестирования функции `first-name` :

```lisp
> (mapcar #'first-name names)
(JOHN MALCOLM ADMIRAL SPOT ARISTOTLE A Z SIR MISS)
```

Мы можем быть разочарованы этими результатами.
Предположим, нам нужна версия `first-name`, которая игнорировала бы такие титулы, как Admiral и Miss, и добралась бы до "настоящего" имени.
Мы могли бы действовать следующим образом:

```lisp
(defparameter *titles*
  '(Mr Mrs Miss Ms Sir Madam Dr Admiral Major General)
  "A list of titles that can appear at the start of a name.")
```

Мы ввели еще одну новую специальную форму, `defparameter`, которая определяет параметр - переменную, которая не меняется в ходе вычислений, но может измениться, когда мы думаем о новых вещах, которые нужно добавить (например, французский Mme или военное Lt.).
Форма `defparameter` одновременно дает значение переменной и позволяет использовать переменную в последующих определениях функций.
В этом примере мы воспользовались возможностью предоставления строки документации, описывающей переменную.
Это широко используемое соглашение среди программистов Lisp, чтобы отметить специальные переменные, их имена пишут со звездочками на обоих концах.
Это просто условность; в Lisp звездочка - это просто еще один знак, который не имеет особого значения.

<a id="tfn01-5"></a>
Затем мы дадим новое определение `first-name`, которое заменяет предыдущее определение.[5](#fn01-5)
Это определение гласит, что если первое слово имени является членом списка титулов(titles), то нам надо проигнорировать это слово и вернуть `first-name` от остатка слов в имени.
В противном случае мы используем первое слово, как и раньше.
Другая встроенная функция, `member`, проверяет, является ли ее первый аргумент элементом списка, переданного в качестве второго аргумента.

Специальная форма `if`(если) имеет форму `(if *test then-part else-part*)`.
Существует много специальных форм для выполнения условных проверок в Lisp; `if` является наиболее подходящим для этого примера.
Форма `if` вычисляется путем вычисления первого выражения* test*.
Если оно верно, то вычисляется *then-part* и возвращается как значение формы `if`; в противном случае вычисляется *else-part* и возвращается.
В то время как некоторые языки настаивают на том, что значение условного теста должно быть либо `true` или `false`, Lisp гораздо более снисходителен.
Тест может законно вычислять любое значение вообще.
Только значение `nil` считается ложным; все остальные значения считаются истинными.
*(ред. Примечание: считается ли значение `false` истинным?)*
В приведенном ниже определении `first-name` функция `member` возвращает не nil (следовательно, истинное) значение, если первый элемент имени находится в списке титулов, и возвращает `nil` (следовательно, false), если его нет.
Хотя все не-nil значения считаются истинными, по соглашению константа `t` обычно используется для представления истины.

```lisp
(defun first-name (name)
  "Select the first name from a name represented as a list."
  (if (member (first name) *titles*)
      (first-name (rest name))
      (first name)))
```

Когда мы сопоставляем новое `first-name` со списком имен, результаты становятся более обнадеживающими.
Кроме того, функция получает "правильный" результат для `'(Madam Major General Paula Jones)`, отбрасывая титулы по одному за раз.

```lisp
> (mapcar #'first-name names)
(JOHN MALCOLM GRACE SPOT ARISTOTLE A Z LARRY SCARLET)

> (first-name '(Madam Major General Paula Jones))
PAULA
```

Мы можем видеть, как это работает , *трассируя* выполнение `first-name` и видя значения, передаваемые в функцию и возвращаемые из нее.
Для этого используются специальные формы `trace` и `untrace`.

```lisp
> (trace first-name)
(FIRST-NAME)

> (first-name '(John Q Public))
(1 ENTER FIRST-NAME: (JOHN Q PUBLIC))
(1 EXIT FIRST-NAME: JOHN)
JOHN
```

Когда вызывается `first-name`, определение вводится с единственным аргументом `name,` принимающим значение `(JOHN Q PUBLIC)`.
Возвращаемое значение - `JOHN`.
Трассировка выводит две строки, указывающие на вход и выход из функции, а затем Lisp, как обычно, выводит конечный результат `JOHN`.

Следующий пример более сложен.
Функция `first-name` используется четыре раза.
Во-первых, она вводится с `name` связанным со списком `(Madam Major General Paula Jones).`
Первый элемент этого списка - `Madam,` и поскольку это член списка титулов, результат вычисляется путем вызова  `first-name` снова для оставшейся части имени- `(Major General Paula Jones).`
Этот процесс повторяется еще два раза, и мы, наконец, вводим `first-name` с привязкой к имени (`Paula Jones`)
Поскольку `Paula` -это не титул, он становится результатом этого вызова `first-name,` и, таким образом, результатом всех четырех вызовов, как показывает трассировка.
Как только мы довольны работой `first-name,` специальная форма `untrace` отключает трассировку.

```lisp
> (first-name '(Madam Major General Paula Jones)) =>
(1 ENTER FIRST-NAME: (MADAM MAJOR GENERAL PAULA JONES))
  (2 ENTER FIRST-NAME: (MAJOR GENERAL PAULA JONES))
    (3 ENTER FIRST-NAME: (GENERAL PAULA JONES))
      (4 ENTER FIRST-NAME: (PAULA JONES))
      (4 EXIT FIRST-NAME: PAULA)
    (3 EXIT FIRST-NAME: PAULA)
  (2 EXIT FIRST-NAME: PAULA)
(1 EXIT FIRST-NAME: PAULA)
PAULA

> (untrace first-name) => (FIRST-NAME)

> (first-name '(Mr Blue Jeans)) => BLUE
```

Функция `first-name` называется рекурсивной, потому что ее определение включает вызов самой себя.
Программисты, которые не знакомы с концепцией рекурсии, иногда находят ее загадочной.
Но рекурсивные функции на самом деле ничем не отличаются от нерекурсивных.
Любая функция должна возвращать правильное значение для данного входна(ов).
Другой способ взглянуть на это требование-разбить его на две части: функция должна возвращать значение, и она не должна возвращать никаких неправильных значений.
Это требование из двух частей эквивалентно первому, но оно облегчает обдумывание и разработку определений функций.

Далее я показываю абстрактное описание проблемы "`first-name`, чтобы подчеркнуть дизайн функции и тот факт, что рекурсивные решения никоим образом не связаны с Lisp:

```lisp
function first-name(name):
  if *the first element of name is a title*
    then *do something complicated to get the first-name*
    else *return the first element of the name*
```

Это разбивает проблему на два случая.
Во втором случае мы возвращаем ответ, и это на самом деле правильный ответ.
Мы еще не определили, что делать в первом случае.
Но мы знаем, что это имеет какое-то отношение к остальной части имени после первого элемента, и что мы хотим извлечь первое имя из этих элементов.
Прыжок веры заключается в том, чтобы идти вперед и использовать `first-name`, даже если оно еще не полностью определено:

```lisp
function first-name(name):
  if *the first element of name is a title*
    then *return the* first-name *of the rest of the name*
    else *return the first element of the name*
```

Теперь первый случай в `first-name` является рекурсивным, а второй случай остается неизменным.
Мы уже договорились, что второй случай возвращает правильный ответ, а первый случай возвращает только то, что возвращает `first-name`.
Таким образом, `first-name` в целом может возвращать только правильные ответы.
Таким образом, мы находимся на полпути к тому, чтобы показать, что функция верна; другая половина-показать, что она в конечном итоге возвращает некоторый ответ.
Но каждый рекурсивный вызов отсекает первый элемент и смотрит на остаток, так что для списка *n*-элементов может быть не более *n* рекурсивных вызовов.
Это завершает демонстрацию того, что функция верна.
Программисты, которые учатся думать таким образом, находят рекурсию ценным инструментом, а не запутанной тайной.

## 1.7 Функции Высшего Порядка

Функции в Lisp можно не только "вызывать" или применять к аргументам, но и манипулировать ими, как и любыми другими объектами.
Функция, принимающая в качестве аргумента другую функцию, называется *higher-order function/функцией высшего порядка.*
`mapcar` - это пример.
Чтобы продемонстрировать стиль программирования функций высшего порядка, мы определим новую функцию под названием `mappend`(map append). Для неё нужны два аргумента: функция и список.
`mappend` отображает функцию для каждого элемента списка и складывает вместе все результаты.
Первое определение следует непосредственно из описания и того факта, что функция `apply` может быть использована для применения функции к списку аргументов.

```lisp
(defun mappend (fn the-list)
  "Apply fn to each element of list and append the results."
  (apply #'append (mapcar fn the-list)))
```

Теперь мы немного поэкспериментируем, чтобы увидеть, как работают `apply` и `mappend`.
В первом примере функция сложения применяется к списку из четырех чисел.

```lisp
> (apply #'+ '(1 2 3 4)) => 10
```

В следующем примере append применяется к списку из двух аргументов, где каждый аргумент является списком.
Если бы аргументы не были списками, это было бы ошибкой.

```lisp
> (apply #'append '((1 2 3) (a b c))) => (1 2 3 A B C)
```

Теперь мы определяем новую функцию `self-and-double` и применяем ее к различным аргументам.

```lisp
> (defun self-and-double (x) (list x (+ x x)))

> (self-and-double 3) => (3 6)

> (apply #'self-and-double '(3)) => (3 6)
```

Если бы мы попытались применить(apply) `self-and-double` к списку из более чем одного аргумента или к списку, который не содержит числа, это было бы ошибкой, точно так же, как это было бы ошибкой вычислять (`self-and-double 3 4`) или (`self-and-double 'Kim`)
Теперь вернемся к функциям отображения:

```lisp
> (mapcar #'self-and-double '(1 10 300)) => ((1 2) (10 20) (300 600))

> (mappend #'self-and-double '(1 10 300)) => (1 2 10 20 300 600)
```

Когда `mapcar` передается функция и список из трех аргументов, она всегда возвращает список из трех значений.
Каждое значение является результатом вызова функции с соответствующим аргументом.
Напротив, когда вызывается `mappend`, она возвращает один большой список, который равен всем значениям, которые `mapcar` будет генерировать.
Было бы ошибкой вызывать `mappend` с функцией, которая не возвращает списки, потому что `append` ожидает увидеть списки в качестве своих аргументов.

Теперь рассмотрим следующую задачу: задан список элементов, вернуть список, состоящий из всех чисел из исходного списка и отрицания этих чисел.
Например, задан список (`testing 1 2 3 test`), вернуть (`1 -1 2 -2 3 -3`)
Эта проблема может быть решена очень легко с помощью `mappend` в качестве компонента:

```lisp
(defun numbers-and-negations (input)
  "Given a list, return only the numbers and their negations."
  (mappend #'number-and-negation input))

(defun number-and-negation (x)
  "If x is a number, return a list of x and -x."
  (if (numberp x)
      (list x (- x))
      nil))

> (numbers-and-negations '(testing 1 2 3 test)) => (1 -1 2 -2 3 -3)
```

Альтернативное определение `mappend`, показанное ниже, не использует `mapcar`; вместо этого он строит список по одному элементу за раз:

```lisp
(defun mappend (fn the-list)
  "Apply fn to each element of list and append the results."
  (if (null the-list)
      nil
      (append (funcall fn (first the-list))
              (mappend fn (rest the-list)))))
```

`funcall` аналогичен `apply`; он также принимает функцию в качестве своего первого аргумента и применяет её к списку аргументов, но в случае `funcall` аргументы перечислены отдельно:

```lisp
> (funcall #'+ 2 3) => 5

> (apply #' + '(2 3)) => 5

> (funcall #' + '(2 3)) => *Error: (2 3) is not a number.*
```

Они эквивалентны `(+  2 3), (+ 2 3)` и `(+ '(2 3))`, соответственно.

До сих пор каждая функция, которую мы использовали, была либо предопределена в Common Lisp, либо введена с помощью `defun`, которая связывает функцию с именем.
Кроме того, можно ввести функцию, не давая ей имени, используя специальный синтаксис `lambda`.

Название *lambda* происходит от обозначения функций математиком Алонсо Черчем (Church 1941).
Лисп обычно предпочитает выразительные имена кратким греческим буквам, но лямбда-исключение.
Лучшим названием будет `make-function`.
Лямбда происходит от обозначения в Расселле и Уайтхеде *Principia Mathematica*, которое использовало "крышку" над связанными переменными: *x&#x302;*(*x + x*).

Черчу нужна была одномерная строка, поэтому он передвинул крышку вперед: *^x*(*x + x*).
Крышка выглядела забавно, когда под ней ничего не было, поэтому Черч переключился на похожую вещь, заглавную лямбду, *&Lambda;x*(*x + x*).
&Lambda; легко было перепутать с другими символами, поэтому в конце концов строчная лямбда была заменена: *&lambda;x*(*x + x*).
Джон Маккарти был студентом Черча в Принстоне, поэтому, когда Маккарти изобрел Lisp в 1958 году, он принял лямбда-нотацию.
В ту эпоху на клавиатурах не было греческих букв, поэтому Маккарти использовал (`lambda (x) (+ x x)`), и он сохранился до наших дней.
В общем случае форма лямбда-выражения такова:

```lisp
(lambda (*parameters...*) *body...*)
```

Лямбда-выражение-это просто неатомарное *имя* для функции, так же как `append` -атомарное имя для встроенной функции.
Таким образом, оно подходит для использования в первой позиции вызова функции, но если мы хотим получить фактическую функцию, а не ее имя, мы все равно должны использовать обозначение `#'`.
Например:

```lisp
> ((lambda (x) (+ x 2)) 4) => 6

> (funcall #'(lambda (x) (+ x 2)) 4) => 6
```

Чтобы понять это различие, мы должны быть понимать то, как выражения вычисляются в Lisp.
Нормальное правило вычисления гласит, что символы вычисляются путем поиска значения переменной, на которую ссылается символ.
Поэтому `x` в `(+ x 2)` при вычислении ищется значение переменной с именем `x`.
Список вычисляется одним из двух способов.
Если первый элемент списка является оператором специальной формы, то список вычисляется в соответствии с синтаксическим правилом для этой специальной формы.
В противном случае список представляет собой вызов функции.
Первый элемент вычисляется уникальным образом, как функция.
Это означает, что он может быть либо символом, либо лямбда-выражением.
В любом случае функция, именуемая первым элементом, применяется к значениям остальных элементов в списке.
Эти значения определяются нормальными правилами вычисления.
Если мы хотим сослаться на функцию в позиции, отличной от первого элемента вызова функции, мы должны использовать обозначение `#'`.
В противном случае выражения будут вычисляться по нормальному правилу вычисления и не будут рассматриваться как функции.
Например:

```lisp
> append => *Error: APPEND is not a bound variable*

> (lambda (x) (+ x 2)) => *Error: LAMBDA is not a function*
```

Вот еще несколько примеров правильного использования функций:

```lisp
>(mapcar #'(lambda (x) (+ x x))
         '(1 2 3 4 5)) =>
(2 4 6 8 10)

> (mappend #'(lambda (l) (list l (reverse l)))
           ((1 2 3) (a b c))) =>
((1 2 3) (3 2 1) (A B C) (C B A))
```

Программисты, привыкшие к другим языкам, иногда не видят смысла в лямбда-выражениях.
Есть две причины, по которым лямбда-выражения очень полезны.

Во-первых, загромождение программы лишними именами приводит к бардаку и хаосу.
Точно так же, как понятнее написать `(a+b)*(c+d)`, а не изобретать имена переменных, такие как `temp1` и `temp2`, чтобы хранить `a+b` и `c+d`, так же может быть яснее определить функцию как лямбда-выражение, а не изобретать для нее имя.

Во-вторых, что еще более важно, лямбда-выражения позволяют создавать новые функции во время выполнения.
Это мощный метод, который невозможен в большинстве языков программирования.
Эти функции времени выполнения, известные как замыкания - *closures*, будут рассмотрены в разделе 3.16.

## 1.8 Другие Типы Данных

До сих пор мы видели только четыре вида объектов Lisp: числа, символы, списки и функции.
Lisp фактически определяет около 25 различных типов объектов: векторы, массивы, структуры, символьные знаки, потоки, хэш-таблицы и другие.
На этом этапе мы введем еще один, строки.
Как вы можете видеть далее, строки, как и числа, вычисляют себя сами.
Строки используются главным образом для печати сообщений, в то время как символы используются для установки отношений/связей с другими объектами и для именования переменных.
Печатное представление строки имеет двойную кавычку `(")` на каждом конце.

```lisp
> "a string" => "a string"

> (length "a string") => 8

> (length "") => 0
```

## 1.9 Резюме: Правило Вычисления(Оценки) в Lisp

Теперь мы можем обобщить правило вычисления для Lisp.

*   Каждое выражение - это либо список(*list*), либо атом(*atom*).

*   Каждый список, подлежащий вычислению/оценке, является либо *выражением специальной формы*, либо *применением функции*.

*   *Выражение специальной формы* определяется как список, первым элементом которого является оператор специальной формы.
Выражение вычисляется в соответствии с правилом идиосинкразической(своеобразного) вычисления оператора.
Например, правило вычисления для `setf` состоит в том, чтобы вычислить второй аргумент в соответствии с обычным правилом вычисления, установить первый аргумент в это значение и вернуть значение в качестве результата.
Правило для `defun` состоит в том, чтобы определить новую функцию и вернуть ее имя.
Правило для `quote`(цитаты) состоит в том, чтобы вернуть первый аргумент не вычисленным.
Обозначение `'x` на самом деле является аббревиатурой выражения специальной формы `(quote x)`.
Аналогично, обозначение `#'f` является аббревиатурой для выражения специальной формы `(function f)`.

```lisp
'John = (quote John) => JOHN

(setf p 'John) => JOHN

(defun twice (x) (+ x x)) => TWICE

(if (=  2 3) (error) (+  5 6)) => 11
```

*   *Применение функции* вычисляется путем вычисления, в первую очередь, аргументов (остальная часть списка), а затем нахождения функции, именуемой первым элементом списка, и применения её к списку вычисляемых аргументов.

```lisp
(+  2 3) => 5
(- (+  90 9) (+  50 5 (length '(Pat Kim)))) => 42
```

Обратите внимание, что если бы у `'(Pat Kim)` не было кавычки, то она была бы интерпретирована как применение функции   `pat` к значению переменной   `kim`.

*   Каждый атом является либо *символом*, либо *несимволом*.

*   *Символ* вычисляет самое последнее значение, которое было присвоено переменной, именуемой этим символом.
Символы состоят из букв, и возможно, цифр и, реже, знаков препинания.
<a id="tfn01-6"></a>
Чтобы избежать путаницы, мы будем использовать символы, состоящие в основном из букв `a-z` и знака `'-'`, за некоторыми исключениями.[6](#fn01-6)

```lisp
names
p
*print-pretty*
```

*   *Несимвольный атом* вычисляет себя.
На данный момент числа и строки-единственные известные нам атомы не являющиеся символами.
Числа состоят из цифр и, возможно, десятичной точки и знака.
Существуют также положения о научной нотации, рациональных и комплексных числел, а также числах с различными основаниями, но мы не будем описывать здесь детали.
Строки выделяются двойными кавычками с обеих сторон.

```lisp
42 => 42
-273.15 => -273.15
"a string" => "a string"
```

Есть некоторые незначительные детали Common Lisp, которые усложняют правила вычисления, но пока этого определения будет достаточно.

Одно из осложнений, которое вызывает путаницу у начинающих Лисперов, - это разница между "чтением" и "вычислением/оценкой" выражения.
Новички часто представляют себе, что когда они вводят выражение, например

```lisp
> (+ (* 3 4) (* 5 6))
```

система Lisp сначала считывает (`+` , затем извлекает функцию сложения, затем считывает `(* 3 4)` и вычисляет `12`, затем читает `(* 5 6)` и вычисляет 30, и, наконец, вычисляет 42.
На самом деле, происходит то, что система сначала считывает все выражение, список `(+ (* 3 4) (* 5 6))`.
Только после того, как оно было прочитано, система начинает его вычилять.
Это вычиление может быть выполнено интерпретатором, который непосредственно смотрит на список, или компилятором, который переводит список в инструкции машинного языка и затем выполняет эти инструкции.

Теперь мы видим, что было бы несколько неточно сказать: "числа состоят из цифр и, возможно, десятичной точки и знака." Было бы более точным сказать, что печатное представление числа, ожидаемое функцией read и производимое функцией print, состоит из цифр и, возможно, десятичной точки и знака.
Внутреннее представление числа варьируется от одного компьютера к другому, но вы можете быть уверены, что это будет битовый шаблон в определенной ячейке памяти, и он больше не будет содержать исходные знаки, используемые для представления числа в десятичной системе счисления.
Аналогично, это печатное представление строки, которая окружена двойными кавычками; внутреннее представление-это ячейка памяти, отмечающая начало вектора знаков.

Новички, которые не понимают разницы между чтением и вычислением, могут иметь хорошую модель того, что выражения вычисляют, но у них обычно есть ужасная модель эффективности вычисления выражений.
Один студент использовал только однобуквенные имена переменных, потому что он чувствовал, что для компьютера было бы быстрее найти однобуквенное имя, чем многобуквенное имя.
Хотя это может быть правдой, что более короткие имена могут сэкономить микросекунду во время чтения, это не имеет никакого значения во время вычисления.
Каждая переменная, независимо от ее имени, является просто ячейкой памяти, и время доступа к ней не зависит от имени переменной.

## 1.10 Что Делает Лисп - Особенным?

Что же отличает Lisp от других языков?
Почему это хороший язык для приложений искусственного интеллекта?
Существует по меньшей мере восемь важных факторов:

* Встроенная поддержка списков
* Автоматическое Управление Хранилищем
* Динамическая типизация
* Функции Первого Класса
* Единообразный Синтаксис
* Интерактивная Среда
* Расширяемость
* История

В сумме, эти факторы позволяют программисту откладывать принятие решений.
В Примере, связанном с именами, мы смогли использовать встроенные функции списка для построения и манипулирования именами, не принимая много явных решений об их представлении.
Если бы мы решили изменить представление, было бы легко вернуться назад и изменить части программы, оставив другие части неизменными.

Эта способность откладывать принятие решений или, точнее, принимать временные, не обязывающие решения-обычно является хорошей вещью, потому что это означает, что несущественные детали могут быть проигнорированы.
Есть и некоторые негативные моменты затягивания принятия решений.
Во-первых, чем меньше мы сообщаем компилятору, тем больше вероятность того, что он будет выдавать неэффективный код.
Во-вторых, чем меньше мы сообщаем компилятору, тем меньше у него шансов заметить несоответствия и предупредить нас.
Ошибки могут быть обнаружены только после запуска программы.
Рассмотрим каждый фактор более подробно, взвешивая достоинства и недостатки:

*   *Встроенная поддержка списков.*
Список - это очень универсальная структура данных, и хотя списки могут быть реализованы на любом языке, Lisp упрощает их использование.
Многие приложения искусственного интеллекта включают в себя списки постоянно меняющегося размера, что затрудняет использование структур данных фиксированной длины, таких как векторы.
Ранние версии Lisp использовали списки как единственную структуру агрегированных данных.
Common Lisp предоставляет и другие типы, поскольку списки не всегда являются наиболее эффективным выбором.

*   *Автоматическое Управление Хранилищем.*
Программисту Lisp не нужно следить за распределением памяти; все это делается автоматически.
Это освобождает программиста от больших усилий и облегчает использование функционального стиля программирования.
Другие языки предоставляют программистам возможность выбора.
Переменные могут быть выделены в стеке, что означает, что они создаются при вводе процедуры и исчезают, когда процедура завершена.
Это эффективное использование хранилища, но оно исключает функции, возвращающие сложные значения.
Другой выбор заключается в том, чтобы программист явно выделял и освобождал хранилище.
Это делает функциональный стиль возможным, но может привести к ошибкам.

Например, рассмотрим тривиальную задачу вычисления выражения *a* x (b + c), где *a*, *b* и *c* - числа.
Код тривиален на любом языке; здесь он приводиться на Pascal и Lisp:

| []()           |                 |
|----------------|-----------------|
| `/* Pascal */` | `;;; Lisp`      |
| `a * (b + c)`  | `(* a (+ b c))` |

Единственная разница заключается в том, что Pascal использует инфиксную нотацию, а Lisp-префиксную.
Теперь рассмотрим вычисление *a* x (b + c), когда *a*, *b* и *c* являются матрицами.
Предположим, что у нас есть процедуры умножения и сложения матриц.
В Lisp форма точно такая же, меняются только названия функций.
В Паскале мы имеем выбор подходов, упомянутых выше.
Мы могли бы объявить временные переменные для хранения промежуточных результатов в стеке и заменить функциональное выражение серией вызовов процедур:

| []()                        |                      |
|-----------------------------|----------------------|
| `/* Pascal */`              | `;;; Lisp`           |
| `var temp, result: matrix;` |                      |
| `add(b,c,temp);`            | `(mult a (add b c))` |
| `mult(a,temp,result);`      |                      |
| `return(result);`           |                      |

Другой вариант-написать функции Pascal, которые выделяют новые матрицы в куче.
Тогда можно написать хорошие функциональные выражения типа `mult(a,add(b,c))` даже на языке Паскаля.
Однако на практике это редко работает так хорошо из-за необходимости явно управлять хранилищем:

| []()                     |                      |
|--------------------------|----------------------|
| `/* Pascal */`           | `;;; Lisp`           |
| `var a,b,c,x,y: matrix;` |                      |
| `x := add(b.c);`         | `(mult a (add b c))` |
| `y := mult(a,x);`        |                      |
| `free(x);`               |                      |
| `return(y);`             |                      |

В общем, решить, какие структуры освободить, - сложная задача для программиста Pascal.
Если программист что-то пропустит, то у программы может закончиться память.
Хуже того, если программист освобождает структуру, которая все еще используется, то при перераспределении этого фрагмента памяти могут возникнуть странные ошибки.
Lisp автоматически выделяет и освобождает структуры, поэтому эти два типа ошибок могут *никогда* не возникать.

*   *динамическая типизация.*
Программистам Lisp не нужно предоставлять объявления типов, потому что язык отслеживает тип каждого объекта во время выполнения, а не вычисляет все типы во время компиляции.
Это делает Лисп-программы короче и, следовательно, они быстрее разрабатываются, а также означает, что функции часто могут быть расширены для работы с объектами, к которым они изначально не предназначались.
В Pascal мы можем написать процедуру сортировки массива из 100 целых чисел, но мы не можем использовать ту же самую процедуру для сортировки 200 целых чисел или 100 строк.
В Лиспе один `sort` подходит всем.
Один из способов оценить такую гибкость заключается в том, чтобы увидеть, насколько трудно достичь ее на других языках.
Это невозможно в Паскале; на самом деле, язык Modula был изобретен в первую очередь для решения этой проблемы в Паскале.
Язык Ada был разработан для обеспечения гибких универсальных функций, и в книге Муссера и Степанова (1989) описан пакет Ada, который дает некоторые функциональные возможности функций роботы с последовательностями Common Lisp.
Но решение Ada далеко не идеально: требуется 264-страничная книга, чтобы дублировать только часть функциональности 20-страничной главы 14 из Steele (1990), и Мюссер и Степанов прошли через пять компиляторов Ada, прежде чем нашли тот, который правильно скомпилировал бы их пакет.
Кроме того, их пакет значительно менее мощный, так как он не обрабатывает векторы или необязательные параметры ключевых слов.
В Common Lisp вся эта функциональность поставляется бесплатно,и ее легко добавить.
С другой стороны, динамическая типизация означает, что некоторые ошибки останутся незамеченными до времени выполнения.
Большим преимуществом строго типизированных языков является то, что они способны выдавать сообщения об ошибках во время компиляции.
Большое разочарование в строго типизированных языках заключается в том, что они способны предупреждать только о небольшом классе ошибок.
Они могут сказать вам, что вы ошибочно передаете строку функции, которая ожидает целое число, но они не могут сказать вам, что вы передаете нечетное число функции, которая ожидает четное число.

*   *Функции Первого Класса*
Объект первого класса - это объект, который можно использовать где угодно и которым можно манипулировать так же, как и любым другим типом объекта.
В Pascal или C, например, функции могут передаваться в качестве аргументов другим функциям, но они не являются первоклассными, поскольку невозможно создать новые функции во время работы программы, а также невозможно создать анонимную функцию, не дав ей имени.
В Lisp мы можем делать обе эти вещи, используя `lambda`.
Это объясняется в разделе 3.16, стр. 92.

*   *Единый Синтаксис.*
Синтаксис Лисп-программ прост.
Это облегчает изучение языка, и очень мало времени тратится на исправление опечаток.
Кроме того, легко писать программы, которые управляют другими программами или определяют целые новые языки-очень мощная техника.
Простой синтаксис также позволяет программам редактирования текста легко анализировать Lisp.
Ваша программа-редактор должна иметь возможность автоматически делать отступы в выражениях и показывать соответствующие скобки.
Это труднее сделать для языков со сложным синтаксисом.
С другой стороны, некоторые люди возражают против всех скобок.
На это возражение есть два ответа.
Во-первых, рассмотрим альтернативу: в языке с "обычным" синтаксисом пары скобок Lisp будут заменены либо неявным правилом приоритета операторов (в случае арифметических и логических выражений), либо парой `begin/end` (в случае управляющих структур).
Но ни то, ни другое не обязательно является преимуществом.
Неявный приоритет, как известно, подвержен ошибкам, и пары `begin/end` загромождают страницу без добавления какого-либо информационного содержания.
Многие языки отходят от `begin/end: C` использует { и }, которые эквивалентны скобкам, а некоторые современные функциональные языки (такие как Haskell) используют горизонтальное пустое пространство, вообще не имея явной группировки.
Во-вторых, многие Лисп-программисты рассматривали альтернативу.
Существует ряд препроцессоров, которые переводят с "обычного" синтаксиса на Лисп.
Ни одна из них не прижилась.
Дело не в том, что Лисп-программисты находят это *терпимым*, чтобы использовать все эти скобки, скорее, они находят это *выгодным.*
Имея небольшой опыт, вы тоже сможете.
Также важно, чтобы синтаксис данных Lisp был таким же, как и синтаксис программ.
Очевидно, что это позволяет легко конвертировать данные в программу.
Менее очевидным является экономия времени за счет наличия универсальных функций для обработки ввода и вывода.
Функции Lisp `read` и `print` автоматически обрабатывают любой список, структуру, строку или число.
Это делает тривиальным тестирование отдельных функций при разработке вашей программы.
В традиционном языке, таком как C или Pascal, вам придется написать специальные функции для чтения и печати каждого типа данных, который вы хотите отладить, а также специальный драйвер для вызова подпрограмм.
Поскольку это отнимает много времени и подвержено ошибкам, возникает соблазн вообще избежать тестирования.
Таким образом, Lisp поощряет более проверенные программы и облегчает их быструю разработку.

*   *интерактивная среда.*
Обычно программист пишет полную программу, компилирует ее, исправляет все ошибки, обнаруженные компилятором, а затем запускает и отлаживает ее.
Это называется *пакетный* режим взаимодействия.
Для длинных программ ожидание компилятора занимало большую часть времени отладки.
В Lisp обычно пишется несколько небольших функций одновременно, получая обратную связь от системы Lisp после оценки каждой из них.
Это называется *интерактивная* среда.
Когда приходит время вносить изменения, только измененные функции должны быть перекомпилированы, поэтому ожидание намного короче.
Кроме того, программист Lisp может выполнять отладку, вводя произвольные выражения в любое время.
Это большое улучшение по сравнению с редактированием программы для введения инструкций печати и перекомпиляции.
Обратите внимание, что различие между *интерактивными* и *пакетными* языками отличается от различия между *интерпретируемыми* и *компилируемыми* языками.
Часто неверно утверждается, что Lisp имеет преимущество в силу того, что он является интерпретируемым языком.
На самом деле, опытные программисты Common Lisp, как правило, используют почти исключительно компилятор.
Важным моментом является взаимодействие, а не интерпретация.
Идея интерактивной среды настолько хороша, что даже традиционные языки, такие как C и Pascal, начинают предлагать интерактивные версии, так что это не является исключительным преимуществом Lisp.
Однако Lisp по-прежнему обеспечивает гораздо лучший доступ к интерактивным функциям.
Интерпретатор языка Си может позволить программисту ввести выражение и немедленно вычислить его, но он не позволит программисту написать программу, которая, скажем, проходит через таблицу символов и находит все пользовательские функции и печатает информацию о них.
В C-даже интерпретируемом C-символьная таблица-это просто Чеширский кот-изобретение воображения интерпретатора, которое исчезает при запуске программы.
<a id="tfn01-7"></a>
В Lisp таблица символов является первоклассным объектом[7](#fn01-7), доступ к которому можно получить и изменить с помощью таких функций, как `read, intern` и `do-symbols`.
Common Lisp предлагает необычайно богатый набор полезных инструментов, включая более 700 встроенных функций (ANSI Common Lisp имеет более 900).
Таким образом, написание новой программы предполагает больше сбора существующих фрагментов кода и меньше написания нового кода с нуля.
Помимо стандартных функций, реализации Common Lisp обычно предоставляют расширения для взаимодействия с редактором, отладчиком и оконной системой.

*   *Расширяемость*.
Когда Lisp был изобретен в 1958 году, никто не мог предвидеть те успехи в теории программирования и разработке языков, которые произошли за последние тридцать лет.
Другие ранние языки были отброшены, заменены теми, которые основаны на более новых идеях.
Тем не менее, Лисп смог выжить, потому что он смог адаптироваться.
Поскольку Lisp является расширяемым, он был изменен, чтобы включить новейшие функции по мере того, как они становятся популярными.
Самый простой способ расширить язык-это использовать макросы.
Когда возникли так называемые конструкции структурированного программирования, такие как *case* и *if-then-else*, они были включены в Lisp как макросы.
Но гибкость Lisp выходит за рамки добавления отдельных конструкций.
Совершенно новые стили программирования могут быть легко реализованы.
Многие приложения искусственного интеллекта основаны на идее программирования, основанного на правилах.
<a id="tfn01-8"></a>
Еще одним новым стилем является объектно-ориентированное программирование, которое было включено в объектную систему Common Lisp (CLOS) [8](#fn01-8) - набор макросов, функций и типов данных, интегрированных в ANSI Common Lisp.

Чтобы показать, как далеко продвинулся Lisp, вот единственный пример программы, приведенный в *Руководстве программиста Lisp/MTS* (Hafner и Wilcox 1974):

```lisp
(PROG (LIST DEPTH TEMP RESTLIST)
(SETQ RESTLIST (LIST (CONS (READ) O)))
A (COND
((NOT RESTLIST) (RETURN 'DONE))
(T (SETQ LIST (UNCONS (UNCONS RESTLIST
     RESTLIST) DEPTH))
(COND ((ATOM LIST)
(MAPC 'PRIN1 (LIST '"ATOM:" LIST '"," 'DEPTH DEPTH))
(TERPRI))
(T (SETQ TEMP (UNCONS LIST LIST))
(COND (LIST
(SETQ RESTLIST (CONS(CONS LIST DEPTH) RESTLIST))))
(SETQ RESTLIST (CONS (CONS TEMP
     (ADD1 DEPTH)) RESTLIST))
))))
))))(GO A))
```

Обратите внимание на использование теперь устаревшего оператора goto `(GO)` и отсутствие последовательных соглашений об отступах.
В руководстве также приводится рекурсивная версия той же программы:

```lisp
(PROG NIL (
(LABEL ATOMPRINT (LAMBDA (RESTLIST)
(COND ((NOT RESTLIST) (RETURN 'DONE))
((ATOM (CAAR RESTLIST)) (MAPC 'PRIN1
     (LIST '"ATOM:" (CAAR RESTLIST)
          '"," 'DEPTH (CDAR RESTLIST)))
(TERPRI)
(ATOMPRINT (CDR RESTLIST)))
( T (ATOMPRINT (GRAFT
(LIST (CONS (CAAAR RESTLIST) (ADD1 (CDAR RESTLIST))))
(AND (CDAAR RESTLIST) (LIST (CONS (CDAAR RESTLIST)
     (CDAR RESTLIST))))
           (CDR RESTLIST)))))))
(LIST (CONS (READ) 0))))
```

Обе версии очень трудно читать.
С нашим современным пониманием (и текстовыми редакторами, которые автоматически делают отступ), возможна гораздо более простая программа:

```lisp
(defun atomprint (exp &optional (depth 0))
  "Print each atom in exp, along with its depth of nesting."
  (if (atom exp)
      (format t "~&ATOM: ~a, DEPTH ~d" exp depth)
      (dolist (element exp)
        (atomprint element (+ depth 1)))))
```

## 1.11 упражнения

&#9635; **Exercise  1.1 [m]** Определите версию `last-name`, которая обрабатывает "Rex Morgan MD," "Morton Downey, Jr.," и любые другие случаи, которые вы можете придумать.

&#9635; **Exercise  1.2 [m]** Напишите функцию для возведения в степень или возведения числа в целочисленную степень.
Например: `(power 3 2)` = 3<sup>2</sup> = 9.

&#9635; **Exercise  1.3 [m]** Напишите функцию, которая подсчитывает количество атомов в выражении.
Например: `(count-atoms '(a (b) c)) = 3`.
Заметьте, что в этом есть некоторая двусмысленность: следует ли (`a nil c`) считать тремя атомами или двумя, потому что это эквивалентно (`a () c`)?

&#9635; **Exercise  1.4 [m]** Напишите функцию, которая подсчитывает количество раз, когда выражение встречается в любом месте другого выражения.
Пример: `(count-anywhere 'a '(a ((a) b) a)) => 3.`

&#9635; **Exercise  1.5 [m]** Напишите функцию для вычисления точечного произведения двух последовательностей чисел, представленных в виде списков.
Точечное произведение вычисляется путем умножения соответствующих элементов и последующего сложения полученных произведений.
Пример:

```lisp
(dot-product '(10 20) '(3 4)) = 10 x 3 + 20 x 4 = 110
```

## 1.12 ответы

### Answer 1.2
```lisp
(defun power (x n)
  "Power raises x to the nth power.  N must be an integer >= 0.
   This executes in log n time, because of the check for even n."
  (cond ((= n 0) 1)
        ((evenp n) (expt (power x (/ n 2)) 2))
        (t (* x (power x (- n 1))))))
```

### Answer 1.3

```lisp
(defun count-atoms (exp)
  "Return the total number of non-nil atoms in the expression."
  (cond ((null exp) 0)
        ((atom exp) 1)
        (t (+ (count-atoms (first exp))
              (count-atoms (rest exp))))))

(defun count-all-atoms (exp &optional (if-null 1))
  "Return the total number of atoms in the expression,
  counting nil as an atom only in non-tail position."
  (cond ((null exp) if-null)
        ((atom exp) 1)
        (t (+ (count-all-atoms (first exp) 1)
              (count-all-atoms (rest exp) 0)))))
```

### Answer 1.4

```lisp
(defun count-anywhere (item tree)
  "Count the times item appears anywhere within tree."
  (cond ((eql item tree) 1)
        ((atom tree) 0)
        (t (+ (count-anywhere item (first tree))
              (count-anywhere item (rest tree))))))
```

### Answer 1.5
Here are three versions:

```lisp
(defun dot-product (a b)
  "Compute the mathematical dot product of two vectors."
  (if (or (null a) (null b))
      0
      (+ (* (first a) (first b))
         (dot-product (rest a) (rest b)))))

(defun dot-product (a b)
  "Compute the mathematical dot product of two vectors."
  (let ((sum 0))
    (dotimes (i (length a))
      (incf sum (* (elt a i) (elt b i))))
    sum))

(defun dot-product (a b)
  "Compute the mathematical dot product of two vectors."
  (apply #'+ (mapcar #'* a b)))
```

----------------------

<a id="fn01-1"></a>
[1](#tfn01-1) Этот список символов не является законным оператором присвоения Lisp, но это объект данных Lisp.

<a id="fn01-2"></a>
[2](#tfn01-2) Переменная `*print-case*` управляет тем, как будут печататься символы.
По умолчанию значение этой переменной равно: `upcase`, но его можно изменить на:`downcase` или `:capitalize`.

<a id="fn01-3"></a>
[3](#tfn01-3) Позже мы увидим, что происходит, когда второй аргумент не является списком.

<a id="fn01-4"></a>
[4](#tfn01-4) В ANSI Common Lisp `last` определяется как возвращающий список последних *n* элементов, где n по умолчанию равно 1.
Таким образом, `(last p) = (last p 1) = (PUBLIC)`,и `(last p 2) = (Q PUBLIC)`..
Это может сделать определение `last` менее извращенным.

<a id="fn01-5"></a>
[5](#tfn01-5) Точно так же, как мы можем изменить значение переменной, мы можем также изменить значение функции в Lisp.
Нет необходимости перекомпилировать все, когда вносятся изменения, как это было бы в других языках.

<a id="fn01-6"></a>
[6](#tfn01-6) Например, символы, обозначающие так называемые специальные(*special*) переменные, обычно начинаются и заканчиваются звездочками.
Кроме того, обратите внимание, что я не колеблясь использовал символ `won!`- на странице 11.

<a id="fn01-7"></a>
[7](#tfn01-7) На самом деле, может быть несколько таблиц символов.
Они известны как пакеты - *packages* в Common Lisp.

<a id="fn01-8"></a>
[8](#tfn01-8) Произносится "вижу-потерю/see-loss".- Альтернативное произношение, "klaus," - кажется, теряет свою популярность.