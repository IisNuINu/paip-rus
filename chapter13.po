#
# NuINu <don't@send.my>, 2020, 2021.
#
#. extracted from in/chapter13.md
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-10 12:08+0300\n"
"PO-Revision-Date: 2021-02-08 13:10+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter13.md:3
msgid ""
"# Chapter 13\n"
"## Object-Oriented Programming"
msgstr ""
"# Глава 13\n"
"## Объектно-Ориентированное Программирование"

#: in/chapter13.md:8
msgid ""
"The programs in this book cover a wide range of problems.\n"
"It is only natural that a wide range of programming styles have been "
"introduced to attack these problems.\n"
"One style not yet covered that has gained popularity in recent years is "
"called *object-oriented programming*.\n"
"To understand what object-oriented programming entails, we need to place it "
"in the context of other styles."
msgstr ""
"Программы в этой книге охватывают широкий круг задач.\n"
"Вполне естественно, что для решения этих проблем был введен широкий спектр "
"стилей программирования.\n"
"Еще не рассмотренный стиль, завоевавший популярность в последние годы, "
"называется объектно-ориентированным программированием.\n"
"Чтобы понять, что влечет за собой объектно-ориентированное программирование, "
"нам нужно поместить его в контекст других стилей."

#: in/chapter13.md:12
msgid ""
"Historically, the first computer programs were written in an *imperative "
"programming* style.\n"
"A program was construed as a series of instructions, where each instruction "
"performs some action: changing the value of a memory location, printing a "
"result, and so forth.\n"
"Assembly language is an example of an imperative language."
msgstr ""
"Исторически первые компьютерные программы были написаны в стиле "
"*императивного программирования*.\n"
"Программа была построена как последовательность инструкций, каждая из "
"которых выполняет какое-либо действие: изменение значения ячейки памяти, "
"печать результата и т. д.\n"
"Ассемблер - пример императивного языка."

#: in/chapter13.md:17
msgid ""
"As experience (and ambition) grew, programmers looked for ways of "
"controlling the complexity of programs.\n"
"The invention of subroutines marked the *algorithmic* or *procedural "
"programming* style, a subclass of the imperative style.\n"
"Subroutines are helpful for two reasons: breaking up the problem into small "
"pieces makes each piece easier to understand, and it also makes it possible "
"to reuse pieces.\n"
"Examples of procedural languages are FORTRAN, C, Pascal, and Lisp with "
"`setf`."
msgstr ""
"По мере роста опыта (и амбиций) программисты искали способы контролировать "
"сложность программ.\n"
"Изобретение подпрограмм обозначило стиль *алгоритмического* или "
"*процедурного программирования*, подкласса императивного стиля.\n"
"Подпрограммы полезны по двум причинам: разбиение проблемы на маленькие части "
"упрощает понимание каждой части, а также дает возможность повторно "
"использовать части.\n"
"Примерами процедурных языков являются FORTRAN, C, Pascal и Lisp с `setf`."

#: in/chapter13.md:24
msgid ""
"Subroutines are still dependent on global state, so they are not completely "
"separate pieces.\n"
"The use of a large number of global variables has been criticized as a "
"factor that makes it difficult to develop and maintain large programs.\n"
"To eliminate this problem, the *functional programming* style insists that "
"functions access only the parameters that are passed to them, and always "
"return the same result for the same inputs.\n"
"Functional programs have the advantage of being mathematically clean-it is "
"easy to prove properties about them.\n"
"However, some applications are more naturally seen as taking action rather "
"than calculating functional values, and are therefore unnatural to program "
"in a functional style.\n"
"Examples of functional languages are FP and Lisp without `setf`."
msgstr ""
"Подпрограммы по-прежнему зависят от глобального состояния, поэтому они не "
"являются полностью отдельными частями.\n"
"Использование большого количества глобальных переменных подвергалось критике "
"как фактор, затрудняющий разработку и сопровождение больших программ.\n"
"Чтобы устранить эту проблему, придуман стиль *функционального "
"программирования* требующий, чтобы функции обращались только к переданным им "
"параметрам и всегда возвращали один и тот же результат для тех же входных "
"данных.\n"
"Функциональные программы имеют то преимущество, что они математически чисты "
"- их свойства легко доказать.\n"
"Однако некоторые приложения более естественно воспринимаются как выполняющие "
"действия, а не вычисляющие функциональные значения, и поэтому их "
"неестественно программировать в функциональном стиле.\n"
"Примерами функциональных языков являются FP и Lisp без `setf`."

#: in/chapter13.md:27
msgid ""
"In contrast to imperative languages are *declarative* languages, which "
"attempt to express \"what to do\" rather than \"how to do it.\" One type of "
"declarative programming is *rule-based* programming, where a set of rules "
"states how to transform a problem into a solution.\n"
"Examples of rule-based systems are ELIZA and STUDENT."
msgstr ""
"В отличие от императивных языков есть *декларативные* языки, которые "
"пытаются выразить \"что делать\", а не \"как это сделать\". Один из типов "
"декларативного программирования - это программирование *основанное на "
"правилах*, где набор правил определяет, как преобразовать проблему в "
"решение.\n"
"Примерами систем на основе правил являются ELIZA и STUDENT."

#: in/chapter13.md:30
msgid ""
"An important kind of declarative programming is *logic programming*, where "
"axioms are used to describe constraints, and computation is done by a "
"constructive proof of a goal.\n"
"An example of logic language is Prolog."
msgstr ""
"Важным видом декларативного программирования является *логическое "
"программирование*, в котором аксиомы используются для описания ограничений, "
"а вычисления выполняются путем конструктивного доказательства цели.\n"
"Примером логичесого языка является Пролог."

#: in/chapter13.md:34
msgid ""
"*Object-oriented programming* is another way to tame the problem of global "
"state.\n"
"Instead of prohibiting global state (as functional programming does), object-"
"oriented programming breaks up the unruly mass of global state and "
"encapsulates it into small, manageable pieces, or objects.\n"
"This chapter covers the object-oriented approach."
msgstr ""
"*Объектно-ориентированное программирование* - еще один способ решить "
"проблему глобального состояния.\n"
"Вместо того, чтобы запрещать глобальное состояние (как это делает "
"функциональное программирование), объектно-ориентированное программирование "
"разбивает непослушную массу глобального состояния и инкапсулирует его на "
"небольшие управляемые части или объекты.\n"
"В этой главе рассматривается объектно-ориентированный подход."

#: in/chapter13.md:36
msgid "## 13.1 Object-Oriented Programming"
msgstr ""
"## 13.1 Объектно-Ориентированное Программирование(Object-Oriented "
"Programming)"

#: in/chapter13.md:43
msgid ""
"Object-oriented programming turns the world of computing on its side: "
"instead of viewing a program primarily as a set of actions which manipulate "
"objects, it is viewed as a set of objects that are manipulated by actions.\n"
"The state of each object and the actions that manipulate that state are "
"defined once and for all when the object is created.\n"
"This can lead to modular, robust systems that are easy to use and extend.\n"
"It also can make systems correspond more closely to the \"real world,\" "
"which we humans perceive more easily as being made up of objects rather than "
"actions.\n"
"Examples of object-oriented languages are Simula, C++, and CLOS, the Common "
"Lisp Object System.\n"
"This chapter will first introduce object-oriented programming in general, "
"and then concentrate on the Common Lisp Object System."
msgstr ""
"Объектно-ориентированное программирование переворачивает мир вычислений на "
"свою сторону: вместо того, чтобы рассматривать программу в первую очередь "
"как набор действий, которые манипулируют объектами, она рассматривается как "
"набор объектов, которыми управляют действия.\n"
"Состояние каждого объекта и действия, которые управляют этим состоянием, "
"определяются раз и навсегда при создании объекта.\n"
"Это может привести к появлению модульных и надежных систем, которые легко "
"использовать и расширять.\n"
"Это также может сделать системы более близкими к \"реальному миру\", который "
"нам, людям, легче воспринимается как состоящий из объектов, а не действий.\n"
"Примерами объектно-ориентированных языков являются Simula, C++ и CLOS - "
"объектная система Common Lisp.\n"
"Эта глава сначала представит объектно-ориентированное программирование в "
"целом, а затем сконцентрируется на объектной системе Common Lisp."

#: in/chapter13.md:46
msgid ""
"Many people are promoting object-oriented programming as the solution to the "
"software development problem, but it is hard to get people to agree on just "
"what object-orientation means.\n"
"[Peter Wegner 1987](B9780080571157500285.xhtml#bb1355) proposes the "
"following formula as a definition:"
msgstr ""
"Многие люди продвигают объектно-ориентированное программирование как решение "
"проблемы разработки программного обеспечения, но трудно заставить людей "
"прийти к единому мнению о том, что такое объектная ориентация.\n"
"[Питер Вегнер, 1987](B9780080571157500285.xhtml#bb1355) предлагает следующую "
"формулу в качестве определения:"

#: in/chapter13.md:48
msgid "*Object-orientation = Objects + Classes + Inheritance*"
msgstr ""
"*Object-orientation = Objects + Classes + Inheritance* (Объектно "
"ориентированное = Объекты + Классы + Наследование)"

#: in/chapter13.md:55
msgid ""
"Briefly, *objects* are modules that encapsulate some data and operations on "
"that data.\n"
"The idea of *information hiding*-insulating the representation of that data "
"from operations outside of the object-is an important part of this concept.\n"
"*Classes* are groups of similar objects with identical behavior.\n"
"Objects are said to be instances of classes.\n"
"*Inheritance* is a means of defining new classes as variants of existing "
"classes.\n"
"The new class inherits the behavior of the parent class, and the programmer "
"need only specify how the new class is different."
msgstr ""
"Вкратце, *объекты* - это модули, которые инкапсулируют некоторые данные и "
"операции с этими данными.\n"
"Идея *сокрытия информации* - изоляции представления этих данных от операций "
"вне объекта - является важной частью этой концепции.\n"
"*Классы* - это группы похожих объектов с одинаковым поведением.\n"
"Объекты называются экземплярами классов.\n"
"*Наследование* - это средство определения новых классов как вариантов "
"существующих классов.\n"
"Новый класс наследует поведение родительского класса, и программисту нужно "
"только указать, чем новый класс отличается."

#: in/chapter13.md:58
msgid ""
"The object-oriented style brings with it a new vocabulary, which is "
"summarized in the following glossary.\n"
"Each term will be explained in more detail when it comes up."
msgstr ""
"Объектно-ориентированный стиль приносит с собой новый словарь, который "
"кратко изложен в следующем глоссарии.\n"
"Каждый термин будет объяснен более подробно, когда он появится."

#: in/chapter13.md:60
msgid "*class:* A group of similar objects with identical behavior."
msgstr "*Класс(class):* Группа похожих объектов с одинаковым поведением."

#: in/chapter13.md:62
msgid "*class variable:* A variable shared by all members of a class."
msgstr ""
"*переменная класса(class variable):* Переменная, совместно используемая "
"всеми членами класса."

#: in/chapter13.md:64
msgid ""
"*delegation:* Passing a message from an object to one of its components."
msgstr ""
"*делегирование(delegation): * Передача сообщения от объекта одному из его "
"компонентов."

#: in/chapter13.md:66
msgid ""
"*generic function:* A function that accepts different types or classes of "
"arguments."
msgstr ""
"*Обобщенная функция(generic function):* Функция, которая принимает различные "
"типы или классы аргументов."

#: in/chapter13.md:68
msgid ""
"*inheritance:* A means of defining new classes as variants of existing "
"classes."
msgstr ""
"*наследование(inheritance): * средство определения новых классов как "
"вариантов существующих классов."

#: in/chapter13.md:70
msgid "*instance:* An instance of a class is an object."
msgstr "*Экземпляр(instance):* Экземпляр класса - это объект."

#: in/chapter13.md:72
msgid "*instance variable:* A variable encapsulated within an object."
msgstr ""
"*экземпляр переменной(instance variable):* Переменная, заключенная в объект."

#: in/chapter13.md:75
msgid ""
"*message:* A name for an action.\n"
"Equivalent to generic function."
msgstr ""
"*Сообщение(message):* Имя действия.\n"
"Эквивалентно обобщенной функции."

#: in/chapter13.md:77
msgid "*method:* A means of handling a message for a particular class."
msgstr ""
"*Метод(method):* Средство обработки сообщения для определенного класса."

#: in/chapter13.md:79
msgid "*multimethod:* A method that depends on more than one argument."
msgstr "*Мультиметод(multimethod):* Метод, зависящий от нескольких аргументов."

#: in/chapter13.md:81
msgid "*multiple inheritance:* Inheritance from more than one parent class."
msgstr ""
"*Множественное наследование(multiple inheritance):* Наследование от более "
"чем одного родительского класса."

#: in/chapter13.md:83
msgid "*object:* An encapsulation of local state and behavior."
msgstr "*Объект(object):* Инкапсуляция локального состояния и поведения."

#: in/chapter13.md:85
msgid "## 13.2 Objects"
msgstr "## 13.2 Объекты"

#: in/chapter13.md:90
msgid ""
"Object-oriented programming, by definition, is concerned with *objects*.\n"
"Any datum that can be stored in computer memory can be thought of as an "
"object.\n"
"Thus, the number 3, the atom `x`, and the string `\"hello\"` are all "
"objects.\n"
"Usually, however, the term *object* is used to denote a more complex object, "
"as we shall see."
msgstr ""
"Объектно-ориентированное программирование, по определению, связано с "
"*объектами*.\n"
"Любые данные, которые могут быть сохранены в памяти компьютера, можно "
"рассматривать как объект.\n"
"Таким образом, число 3, атом x и строка `\"hello\"` - это всё объекты.\n"
"Обычно, как мы увидим, термин *объект* используется для обозначения более "
"сложного объекта."

#: in/chapter13.md:97
msgid ""
"Of course, all programming is concerned with objects, and with procedures "
"operating on those objects.\n"
"Writing a program to solve a particular problem will necessarily involve "
"writing definitions for both objects and procedures.\n"
"What distinguishes object-oriented programming is that the primary way of "
"decomposing the problem into modules is based on the objects rather than on "
"the procedures.\n"
"The difference can best be seen with an example.\n"
"Here is a simple program to create bank accounts and keep track of "
"withdrawals, deposits, and accumulation of interest.\n"
"First, the program is written in traditional procedural style:"
msgstr ""
"Конечно, всё программирование связано с объектами и процедурами, работающими "
"с этими объектами.\n"
"Написание программы для решения конкретной проблемы обязательно потребует "
"написания определений как для объектов, так и для процедур.\n"
"Что отличает объектно-ориентированное программирование, так это то, что "
"основной способ декомпозиции проблемы на модули основан на объектах, а не на "
"процедурах.\n"
"Разницу лучше всего увидеть на примере.\n"
"Вот простая программа для создания банковских счетов и отслеживания снятия "
"средств, депозитов и накопления процентов.\n"
"Во-первых, программа написана в традиционном процедурном стиле:"

#: in/chapter13.md:101
msgid ""
"```lisp\n"
"(defstruct account\n"
"  (name \"\") (balance 0.00) (interest-rate .06))"
msgstr ""

#: in/chapter13.md:107
msgid ""
"(defun account-withdraw (account amt)\n"
"  \"Make a withdrawal from this account.\"\n"
"  (if (<= amt (account-balance account))\n"
"      (decf (account-balance account) amt)\n"
"      'insufficient-funds))"
msgstr ""

#: in/chapter13.md:111
msgid ""
"(defun account-deposit (account amt)\n"
"  \"Make a deposit to this account.\"\n"
"  (incf (account-balance account) amt))"
msgstr ""

#: in/chapter13.md:118
msgid ""
"(defun account-interest (account)\n"
"  \"Accumulate interest in this account.\"\n"
"  (incf (account-balance account)\n"
"        (* (account-interest-rate account)\n"
"           (account-balance account))))\n"
"```"
msgstr ""

#: in/chapter13.md:125
msgid ""
"We can create new bank accounts with `make-account` and modify them with "
"`account-withdraw, account-deposit,` and `account-interest.` This is a "
"simple problem, and this simple solution suffices.\n"
"Problems appear when we change the specification of the problem, or when we "
"envision ways that this implementation could be inadvertently used in "
"error.\n"
"For example, suppose a programmer looks at the `account` structure and "
"decides to use `(decf (account-balance account)`) directly instead of going "
"through the `account-withdraw` function.\n"
"This could lead to negative account balances, which were not intended.\n"
"Or suppose that we want to create a new kind of account, where only a "
"certain maximum amount can be withdrawn at one time.\n"
"There would be no way to ensure that `account-withdraw` would not be applied "
"to this new, limited account."
msgstr ""
"Мы можем создавать новые банковские счета с помощью `make-account` и "
"изменять их с помощью `account-withdraw, account-deposit` и `account-"
"interest`. Это простая проблема, и этого простого решения достаточно.\n"
"Проблемы возникают, когда мы меняем спецификацию проблемы или когда мы "
"предполагаем, что эта реализация может быть случайно использована по "
"ошибке.\n"
"Например, предположим, что программист смотрит на структуру `account` и "
"решает использовать `(decf (account-balance account) `) напрямую вместо "
"того, чтобы использовать функцию `account-remove`.\n"
"Это могло привести к отрицательному сальдо счетов, чего не планировалось.\n"
"Или предположим, что мы хотим создать новый тип учетной записи, в которой "
"одновременно может быть снята только определенная максимальная сумма.\n"
"Невозможно гарантировать, что `account-withdraw` не будет применяться к этой "
"новой ограниченной учетной записи."

#: in/chapter13.md:129
msgid ""
"The problem is that once we have created an account, we have no control over "
"what actions are applied to it.\n"
"The object-oriented style is designed to provide that control.\n"
"Here is the same program written in object-oriented style (using plain Lisp):"
msgstr ""
"Проблема в том, что после создания счета(account) мы не можем "
"контролировать, какие действия к нему будут применены.\n"
"Объектно-ориентированный стиль предназначен для обеспечения такого "
"контроля.\n"
"Вот та же программа, написанная в объектно-ориентированном стиле (с "
"использованием простого Lisp):"

#: in/chapter13.md:147
msgid ""
"```lisp\n"
"(defun new-account (name &optional (balance 0.00)\n"
"                    (interest-rate .06))\n"
"  \"Create a new account that knows the following messages:\"\n"
"  #'(lambda (message)\n"
"      (case message\n"
"        (withdraw #'(lambda (amt)\n"
"                      (if (<= amt balance)\n"
"                          (decf balance amt)\n"
"                          'insufficient-funds)))\n"
"        (deposit  #'(lambda (amt) (incf balance amt)))\n"
"        (balance  #'(lambda () balance))\n"
"        (name     #'(lambda () name))\n"
"        (interest #'(lambda ()\n"
"                      (incf balance\n"
"                            (* interest-rate balance)))))))\n"
"```"
msgstr ""

#: in/chapter13.md:155
msgid ""
"The function `new-account` creates account objects, which are implemented as "
"closures that encapsulate three variables: the name, balance, and interest "
"rate of the account.\n"
"An account object also encapsulates functions to handle the five messages to "
"which the object can respond.\n"
"An account object can do only one thing: receive a message and return the "
"appropriate function to execute that message.\n"
"For example, if you pass the message `withdraw` to an account object, it "
"will return a function that, when applied to a single argument (the amount "
"to withdraw), will perform the withdrawal action.\n"
"This function is called the *method* that implements the message.\n"
"The advantage of this approach is that account objects are completely "
"encapsulated; the information corresponding to the name, balance, and "
"interest rate is only accessible through the five messages.\n"
"We have a guarantee that no other code can manipulate the information in the "
"account in any other way.[1](#fn0015)"
msgstr ""
"Функция `new-account` создает объекты счета, которые реализованы как "
"замыкания, которые инкапсулируют три переменные: имя, баланс и процентную "
"ставку счета.\n"
"Объект счет(account) также инкапсулирует функции для обработки пяти "
"сообщений, на которые объект может ответить.\n"
"Объект account может делать только одно: получать сообщение и возвращать "
"соответствующую функцию для выполнения этого сообщения.\n"
"Например, если вы передадите сообщение объекту account `withdraw`, он вернет "
"функцию, которая при применении к одному аргументу (сумме для снятия) "
"выполнит действие по снятию средств.\n"
"Эта функция называется *методом*, реализующим сообщение.\n"
"Преимущество этого подхода в том, что объекты account полностью "
"инкапсулированы; информация, соответствующая имени, балансу и процентной "
"ставке, доступна только через пять сообщений.\n"
"У нас есть гарантия, что никакой другой код не сможет манипулировать "
"информацией в account каким-либо иным образом. [1](#fn0015)"

#: in/chapter13.md:159
msgid ""
"The function `get-method` finds the method that implements a message for a "
"given object.\n"
"The function send gets the method and applies it to a list of arguments.\n"
"The name send comes from the Flavors object-oriented system, which is "
"discussed in the history section ([page 456](#p456))."
msgstr ""
"Функция `get-method` находит метод, реализующий сообщение для данного "
"объекта.\n"
"Функция `send` получает метод и применяет его к списку аргументов.\n"
"Название `send` происходит от объектно-ориентированной системы Flavors, "
"которая обсуждается в разделе истории.([page 456](#p456))."

#: in/chapter13.md:164
msgid ""
"```lisp\n"
"(defun get-method (object message)\n"
"  \"Return the method that implements message for this object.\"\n"
"  (funcall object message))"
msgstr ""

#: in/chapter13.md:170
msgid ""
"(defun send (object message &rest args)\n"
"  \"Get the function to implement the message,\n"
"  and apply the function to the args.\"\n"
"  (apply (get-method object message) args))\n"
"```"
msgstr ""

#: in/chapter13.md:172
msgid "Here is an example of the use of `new-account` and `send`:"
msgstr "Вот пример использования `new-account` и `send`:"

#: in/chapter13.md:175
msgid ""
"`> (setf acct (new-account \"J.\n"
"Random Customer\" 1000.00))`=>"
msgstr ""

#: in/chapter13.md:181
msgid ""
"```lisp\n"
"#<CLOSURE 23652465>\n"
"> (send acct 'withdraw 500.00) => 500.0\n"
"> (send acct 'deposit 123.45) => 623.45\n"
"```"
msgstr ""

#: in/chapter13.md:184
msgid ""
"`> (send acct 'name) => \"J.\n"
"Random Customer\"`"
msgstr ""

#: in/chapter13.md:188
msgid ""
"```lisp\n"
"> (send acct 'balance) => 623.45\n"
"```"
msgstr ""

#: in/chapter13.md:190
msgid "## 13.3 Generic Functions"
msgstr "## 13.3 Обобщенные функции"

#: in/chapter13.md:193
msgid ""
"The send syntax is awkward, as it is different from the normal Lisp function-"
"calling syntax, and it doesn't fit in with the other Lisp tools.\n"
"For example, we might like to say (`mapcar 'balance accounts`), but with "
"messages we would have to write that as:"
msgstr ""
"Синтаксис send неудобен, так как он отличается от обычного синтаксиса вызова "
"функций Lisp и не подходит для других инструментов Lisp.\n"
"Например, мы могли бы сказать (`mapcar 'balance accounts`), но в сообщениях "
"мы должны написать это как:"

#: in/chapter13.md:197
msgid ""
"```lisp\n"
"(mapcar #'(lambda (acct) (send acct 'balance)) accounts)\n"
"```"
msgstr ""

#: in/chapter13.md:200
msgid ""
"We can fix this problem by defining *generic* functions that find the right "
"method to execute a message.\n"
"For example, we could define:"
msgstr ""
"Мы можем решить эту проблему, определив *обобщенные* функции, которые "
"находят правильный метод для выполнения сообщения.\n"
"Например, мы могли бы определить:"

#: in/chapter13.md:206
msgid ""
"```lisp\n"
"(defun withdraw (object &rest args)\n"
"  \"Define withdraw as a generic function on objects.\"\n"
"  (apply (get-method object 'withdraw) args))\n"
"```"
msgstr ""

#: in/chapter13.md:212
msgid ""
"and then write `(withdraw acct x)` instead of `(send acct 'withdraw x)`.\n"
"The function `withdraw` is generic because it not only works on account "
"objects but also works on any other class of object that handles the "
"`withdraw` message.\n"
"For example, we might have a totally unrelated class, `army,` which also "
"implements a `withdraw` method.\n"
"Then we could say `(send 5th-army 'withdraw)` or `(withdraw 5th-army)` and "
"have the correct method executed.\n"
"So object-oriented programming eliminates many problems with name clashes "
"that arise in conventional programs."
msgstr ""
"а затем написать `(withdraw acct x)` вместо `(send acct 'withdraw x)`.\n"
"Функция `withdraw` является обобщенной, потому что она работает не только с "
"объектами account, но также работает с любым другим классом объектов, "
"которые обрабатывают сообщение `withdraw`.\n"
"Например, у нас может быть совершенно не связанный класс, `army`, который "
"также реализует метод `withdraw`.\n"
"Затем мы могли бы сказать `(send 5th-army 'withdraw)` или `(withdraw 5th-"
"army)` и выполнить правильный метод.\n"
"Таким образом, объектно-ориентированное программирование устраняет многие "
"проблемы, связанные с конфликтами имен, которые возникают в обычных "
"программах."

#: in/chapter13.md:217
msgid ""
"Many of the built-in Common Lisp functions can be considered generic "
"functions, in that they operate on different types of data.\n"
"For example, `sqrt` does one thing when passed an integer and quite another "
"when passed an imaginary number.\n"
"The sequence functions (like `find` or `delete`) operate on lists, vectors, "
"or strings.\n"
"These functions are not implemented like `withdraw,` but they still act like "
"generic functions.[2](#fn0020)"
msgstr ""
"Многие встроенные функции Common Lisp можно считать обобщенными, поскольку "
"они работают с разными типами данных.\n"
"Например, sqrt выполняет одно действие при передаче целого числа и совсем "
"другое при передаче мнимого числа.\n"
"Функции работы с последовательностями (например, find или delete) работают "
"со списками, векторами или строками.\n"
"Эти функции не реализованы, как `withdraw`, но они по-прежнему действуют как "
"обобщенные функции.[2](#fn0020)"

#: in/chapter13.md:219
msgid "## 13.4 Classes"
msgstr "## 13.4 Классы"

#: in/chapter13.md:225
msgid ""
"It is possible to write macros to make the object-oriented style easier to "
"read and write.\n"
"The macro `define-class` defines a class with its associated message-"
"handling methods.\n"
"It also defines a generic function for each message.\n"
"Finally, it allows the programmer to make a distinction between variables "
"that are associated with each object and those that are associated with a "
"class and are shared by all member s of the class.\n"
"For example, you might want to have all instances of the class `account` "
"share the same interest rate, but you wouldn't want them to share the same "
"balance."
msgstr ""
"Можно писать макросы, чтобы упростить чтение и запись в объектно-"
"ориентированном стиле.\n"
"Макрос `define-class` определяет класс со связанными с ним методами "
"обработки сообщений.\n"
"Он также определяет обобщенную функцию для каждого сообщения.\n"
"Наконец, он позволяет программисту различать переменные, которые связаны с "
"каждым объектом, и переменные, которые связаны с классом и являются общими "
"для всех членов класса.\n"
"Например, вы можете захотеть, чтобы все экземпляры класса `account` имели "
"одинаковую процентную ставку, но не хотели бы, чтобы у них был одинаковый "
"баланс."

#: in/chapter13.md:236
msgid ""
"```lisp\n"
"(defmacro define-class (class inst-vars class-vars &body methods)\n"
"  \"Define a class for object-oriented programming.\"\n"
"  ;; Define constructor and generic functions for methods\n"
"  `(let ,class-vars\n"
"     (mapcar #'ensure-generic-fn ',(mapcar #'first methods))\n"
"     (defun ,class ,inst-vars\n"
"       #'(lambda (message)\n"
"           (case message\n"
"             ,@(mapcar #'make-clause methods))))))"
msgstr ""

#: in/chapter13.md:240
msgid ""
"(defun make-clause (clause)\n"
"  \"Translate a message from define-class into a case clause.\"\n"
"  `(,(first clause) #'(lambda ,(second clause) .,(rest2 clause))))"
msgstr ""

#: in/chapter13.md:249
msgid ""
"(defun ensure-generic-fn (message)\n"
"  \"Define an object-oriented dispatch function for a message,\n"
"  unless it has already been defined as one.\"\n"
"  (unless (generic-fn-p message)\n"
"    (let ((fn #'(lambda (object &rest args)\n"
"                  (apply (get-method object message) args))))\n"
"      (setf (symbol-function message) fn)\n"
"      (setf (get message 'generic-fn) fn))))"
msgstr ""

#: in/chapter13.md:255
msgid ""
"(defun generic-fn-p (fn-name)\n"
"  \"Is this a generic function?\"\n"
"  (and (fboundp fn-name)\n"
"       (eq (get fn-name 'generic-fn) (symbol-function fn-name))))\n"
"```"
msgstr ""

#: in/chapter13.md:258
msgid ""
"Now we define the class account with this macro.\n"
"We make `interest-rate` a class variable, one that is shared by all accounts:"
msgstr ""
"Теперь мы определяем класс account с помощью этого макроса.\n"
"Мы делаем процентную ставку - `interest-rate` переменной класса, которая "
"используется всеми экземплярами account:"

#: in/chapter13.md:262
msgid ""
"```lisp\n"
"(define-class account (name &optional (balance 0.00))\n"
"```"
msgstr ""

#: in/chapter13.md:264
msgid "                `((interest-rate .06))`"
msgstr ""

#: in/chapter13.md:266
msgid "  `(withdraw (amt) (if (<= amt balance)`"
msgstr ""

#: in/chapter13.md:268
msgid "                        `(decf balance amt)`"
msgstr ""

#: in/chapter13.md:270
msgid "                        `'insufficient-funds))`"
msgstr ""

#: in/chapter13.md:272
msgid "  `(deposit (amt) (incf balance amt))`"
msgstr ""

#: in/chapter13.md:274
msgid "  `(balance () balance)`"
msgstr ""

#: in/chapter13.md:276
msgid "  `(name () name)`"
msgstr ""

#: in/chapter13.md:278
msgid "  `(interest () (incf balance (* interest-rate balance))))`"
msgstr ""

#: in/chapter13.md:280
msgid "Here we use the generic functions defined by this macro:"
msgstr "Здесь мы используем обобщенные функции, определенные этим макросом:"

#: in/chapter13.md:283
msgid ""
"`> (setf acct2 (account \"A.\n"
"User\" 2000.00)) => #<CLOSURE 24003064>`"
msgstr ""

#: in/chapter13.md:290
msgid ""
"```lisp\n"
"> (deposit acct2 42.00) => 2042.0\n"
"> (interest acct2) => 2164.52\n"
"> (balance acct2) => 2164.52\n"
"> (balance acct) => 623.45\n"
"```"
msgstr ""

#: in/chapter13.md:292
msgid ""
"In this last line, the generic function `balance` is applied to `acct,` an "
"object that was created before we even defined the account class and the "
"function `balance.` But `balance` still works properly on this object, "
"because it obeys the message-passing protocol."
msgstr ""
"В этой последней строке обобщенная функция `balance` применяется к `acct`, "
"объекту, который был создан до того, как мы даже определили класс account и "
"функцию `balance`. Но `balance` по-прежнему правильно работает с этим "
"объектом, потому что он подчиняется протоколу передачи сообщений."

#: in/chapter13.md:294
msgid "## 13.5 Delegation"
msgstr "## 13.5 Делегирование"

#: in/chapter13.md:298
msgid ""
"Suppose we want to create a new kind of account, one that requires a "
"password for each action.\n"
"We can define a new class, `password-account,` that has two message "
"clauses.\n"
"The first clause allows for changing the password (if you have the original "
"password), and the second is an `otherwise` clause, which checks the "
"password given and, if it is correct, passes the rest of the arguments on to "
"the account that is being protected by the password."
msgstr ""
"Предположим, мы хотим создать account нового типа, в котором для каждого "
"действия требуется пароль.\n"
"Мы можем определить новый класс `password-account`, который имеет два "
"предложения сообщений.\n"
"Первое предложение позволяет изменить пароль (если у вас есть исходный "
"пароль), а второе - предложение `otherwise`, которое проверяет заданный "
"пароль и, если он правильный, передает остальные аргументы account, который "
"защищен паролем."

#: in/chapter13.md:301
msgid ""
"The definition of `password-account` takes advantage of the internal details "
"of `define-class` in two ways: it makes use of the fact that `otherwise` can "
"be used as a catch-all clause in a `case` form, and it makes use of the fact "
"that the dispatch variable is called `message.` Usually, it is not a good "
"idea to rely on details about the implementation of a macro, and soon we "
"will see cleaner ways of defining classes.\n"
"But for now, this simple approach works:"
msgstr ""
"Определение `password-account` использует внутренние детали `define-class` "
"двумя способами: оно использует тот факт, что `otherwise` может "
"использоваться как универсальное предложение в форме `case`, и он использует "
"тот факт, что диспетчерская переменная называется `message`. Обычно "
"полагаться на подробности реализации макроса - не лучшая идея, и вскоре мы "
"увидим более чистые способы определения классов.\n"
"Но пока работает и этот простой подход:"

#: in/chapter13.md:305
msgid ""
"```lisp\n"
"(define-class password-account (password acct) ()\n"
"```"
msgstr ""

#: in/chapter13.md:307
msgid "  `(change-password (pass new-pass)`"
msgstr ""

#: in/chapter13.md:309
msgctxt "in/chapter13.md:309"
msgid "              `(if (equal pass password)`"
msgstr ""

#: in/chapter13.md:311
msgid "                `(setf password new-pass)`"
msgstr ""

#: in/chapter13.md:313
msgid "                `'wrong-password))`"
msgstr ""

#: in/chapter13.md:315
msgid "  `(otherwise (pass &rest args)`"
msgstr ""

#: in/chapter13.md:317
msgctxt "in/chapter13.md:317"
msgid "              `(if (equal pass password)`"
msgstr ""

#: in/chapter13.md:319
msgid "                `(apply message acct args)`"
msgstr ""

#: in/chapter13.md:321
msgid "                `'wrong-password)))`"
msgstr ""

#: in/chapter13.md:323
msgid ""
"Now we see how the class `password-account` can be used to provide "
"protection for an existing account:"
msgstr ""
"Теперь мы видим, как класс `password-account` может использоваться для "
"защиты существующего account:"

#: in/chapter13.md:330
msgid ""
"```lisp\n"
"(setf acct3 (password-account \"secret\" acct2)) => #<CLOSURE 33427277>\n"
"> (balance acct3 \"secret\") => 2164.52\n"
"> (withdraw acct3 \"guess\" 2000.00) => WRONG-PASSWORD\n"
"> (withdraw acct3 \"secret\" 2000.00) => 164.52\n"
"```"
msgstr ""

#: in/chapter13.md:334
msgid ""
"Now let's try one more example.\n"
"Suppose we want to have a new class of account where only a limited amount "
"of money can be withdrawn at any time.\n"
"We could define the class `limited-account`:"
msgstr ""
"А теперь попробуем еще один пример.\n"
"Предположим, мы хотим иметь новый класс счетов - account, у которого в любое "
"время может быть снята только ограниченная сумма денег.\n"
"Мы могли бы определить класс `limited-account`:"

#: in/chapter13.md:338
msgid ""
"```lisp\n"
"(define-class limited-account (limit acct) ()\n"
"```"
msgstr ""

#: in/chapter13.md:340
msgctxt "in/chapter13.md:340"
msgid "  `(withdraw (amt)`"
msgstr ""

#: in/chapter13.md:342
msgid "              `(if (> amt limit)`"
msgstr ""

#: in/chapter13.md:344
msgctxt "in/chapter13.md:344"
msgid "                    `'over-limit`"
msgstr ""

#: in/chapter13.md:346
msgid "                    `(withdraw acct amt)))`"
msgstr ""

#: in/chapter13.md:348
msgid "  `(otherwise (&rest args)`"
msgstr ""

#: in/chapter13.md:350
msgid "              `(apply message acct args)))`"
msgstr ""

#: in/chapter13.md:353
msgid ""
"This definition redefines the `withdraw` message to check if the limit is "
"exceeded before passing on the message, and it uses the `otherwise` clause "
"simply to pass on all other messages unchanged.\n"
"In the following example, we set up an account with both a password and a "
"limit:"
msgstr ""
"Это определение переопределяет сообщение `withdraw`, чтобы проверить, "
"превышен ли лимит перед передачей сообщения, и использует предложение "
"`withdraw` просто для передачи всех других сообщений без изменений.\n"
"В следующем примере мы настраиваем account с паролем и лимитом:"

#: in/chapter13.md:357
msgid ""
"```lisp\n"
"> (setf acct4 (password-account \"pass\"\n"
"```"
msgstr ""

#: in/chapter13.md:359
msgid "              `(limited-account 100.00`"
msgstr ""

#: in/chapter13.md:362
msgid ""
"                `(account \"A.\n"
"Thrifty Spender\" 500.00))))`=>"
msgstr ""

#: in/chapter13.md:369
msgid ""
"```lisp\n"
"#<CLOSURE 34136775>\n"
"> (withdraw acct4 \"pass\" 200.00) => OVER-LIMIT\n"
"> (withdraw acct4 \"pass\" 20.00) => 480.0\n"
"> (withdraw acct4 \"guess\" 20.00) => WRONG-PASSWORD\n"
"```"
msgstr ""

#: in/chapter13.md:377
msgid ""
"Note that functions like `withdraw` are still simple generic functions that "
"just find the right method and apply it to the arguments.\n"
"The trick is that each class defines a different way to handle the withdraw "
"message.\n"
"Calling `withdraw` with `acct4` as argument results in the following flow of "
"control.\n"
"First, the method in the `password-account` class checks that the password "
"is correct.\n"
"If it is, it calls the method from the `limited-account` class.\n"
"If the limit is not exceeded, we finally call the method from the `account` "
"class, which decrements the balance.\n"
"Passing control to the method of a component is called *delegation*."
msgstr ""
"Обратите внимание, что такие функции, как `withdraw`, по-прежнему являются "
"простыми обобщенными функциями, которые просто находят правильный метод и "
"применяют его к аргументам.\n"
"Хитрость в том, что каждый класс определяет свой способ обработки сообщения "
"withdraw.\n"
"Вызов `withdraw` с acct4 в качестве аргумента приводит к следующему потоку "
"управления.\n"
"Сначала метод класса `password-account` проверяет правильность пароля.\n"
"Если это так, он вызывает метод из класса `limited-account`.\n"
"Если лимит не превышен, мы, наконец, вызываем метод из класса `account`, "
"который уменьшает баланс.\n"
"Передача управления/контроля методу компонента называется *делегированием*."

#: in/chapter13.md:380
msgid ""
"The advantage of the object-oriented style is that we can introduce a new "
"class by writing one definition that is localized and does not require "
"changing any existing code.\n"
"If we had written this in traditional procedural style, we would end up with "
"functions like the following:"
msgstr ""
"Преимущество объектно-ориентированного стиля состоит в том, что мы можем "
"ввести новый класс, написав одно локализованное определение, не требующее "
"изменения какого-либо существующего кода.\n"
"Если бы мы написали это в традиционном процедурном стиле, мы бы получили "
"следующие функции:"

#: in/chapter13.md:384
msgid ""
"```lisp\n"
"(defun withdraw (acct amt &optional pass)\n"
"```"
msgstr ""

#: in/chapter13.md:386
msgid "  `(cond ((and (typep acct 'password-account)`"
msgstr ""

#: in/chapter13.md:388
msgid "                `(not (equal pass (account-password acct))))`"
msgstr ""

#: in/chapter13.md:390
msgid "            `'wrong-password)`"
msgstr ""

#: in/chapter13.md:392
msgid "            `((and (typep acct 'limited-account)`"
msgstr ""

#: in/chapter13.md:394
msgid "                `(> amt (account-limit account)))`"
msgstr ""

#: in/chapter13.md:396
msgid "            `'over-limit)`"
msgstr ""

#: in/chapter13.md:398
msgid "            `((> amt balance)`"
msgstr ""

#: in/chapter13.md:400
msgid "            `'insufficient-funds)`"
msgstr ""

#: in/chapter13.md:402
msgid "            `(t (decf balance amt))))`"
msgstr ""

#: in/chapter13.md:406
msgid ""
"There is nothing wrong with this, as an individual function.\n"
"The problem is that when the bank decides to offer a new kind of account, we "
"will have to change this function, along with all the other functions that "
"implement actions.\n"
"The \"definition\" of the new account is scattered rather than localized, "
"and altering a bunch of existing functions is usually more error prone than "
"writing a new class definition."
msgstr ""
"В этом нет ничего плохого, как в индивидуальной функции.\n"
"Проблема в том, что, когда банк решает предложить новый тип счета(account), "
"нам придется изменить эту функцию вместе со всеми другими функциями, "
"реализующими действия.\n"
"\"Определение\" нового счета(account) разрознено, а не локализовано, и "
"изменение набора существующих функций обычно более подвержено ошибкам, чем "
"написание нового определения класса."

#: in/chapter13.md:408
msgid "## 13.6 Inheritance"
msgstr "## 13.6 Наследование"

#: in/chapter13.md:414
msgid ""
"In the following table, data types (classes) are listed across the "
"horizontal axis, and functions (messages) are listed up and down the "
"vertical axis.\n"
"A complete program needs to fill in all the boxes, but the question is how "
"to organize the process of filling them in.\n"
"In the traditional procedural style, we write function definitions that fill "
"in a row at a time.\n"
"In the object-oriented style, we write class definitions that fill in a "
"column at a time.\n"
"A third style, the *data-driven* or *generic* style, fills in only one box "
"at a time."
msgstr ""
"В следующей таблице типы данных (классы) перечислены по горизонтальной оси, "
"а функции (сообщения) перечислены сверху в вниз по вертикальной оси.\n"
"Полная программа должна заполнить все поля, но вопрос в том, как "
"организовать процесс их заполнения.\n"
"В традиционном процедурном стиле мы пишем определения функций, которые "
"заполняют строку за раз.\n"
"В объектно-ориентированном стиле мы пишем определения классов, которые "
"заполняют столбец за раз.\n"
"Третий стиль, *управляемый данными* или *обобщенный* стиль, заполняет только "
"одно поле за раз."

#: in/chapter13.md:423
msgid ""
"|            | `account limited-account` | `password-account` | `...` |\n"
"| ---        | ---                       | ---                | ---   |\n"
"| `name`     |                           | *object*           |       |\n"
"| `deposit`  |                           | *oriented*         |       |\n"
"| `withdraw` | *function oriented*       |                    |       |\n"
"| `balance`  |                           |                    |       |\n"
"| `interest` | *generic*                 |                    |       |\n"
"| `...`      |                           |                    |       |"
msgstr ""

#: in/chapter13.md:428
msgid ""
"In this table there is no particular organization to either axis; both "
"messages and classes are listed in random order.\n"
"This ignores the fact that classes are organized hierarchically: both "
"limited-account and password-account are subclasses of account.\n"
"This was implicit in the definition of the classes, because both `limited-"
"account` and `password-account` contain accounts as components and delegate "
"messages to those components.\n"
"But it would be cleaner to make this relationship explicit."
msgstr ""
"В этой таблице нет определенной организации ни для одной из осей; и "
"сообщения, и классы перечислены в случайном порядке.\n"
"Это игнорирует тот факт, что классы организованы иерархически: как limited-"
"account, так и password-account являются подклассами account.\n"
"Это подразумевается в определении классов, потому что и `limited-account` и "
"`password-account` содержат счета в качестве компонентов и делегируют "
"сообщения этим компонентам.\n"
"Но было бы проще сделать эту связь явной."

#: in/chapter13.md:431
msgid ""
"The `defstruct` mechanism does allow for just this kind of explicit "
"inheritance.\n"
"If we had defined `account` as a structure, then we could define `limited-"
"account` with:"
msgstr ""
"Механизм `defstruct` допускает именно такое явное наследование.\n"
"Если бы мы определили `account` как структуру, то мы могли бы определить "
"`limited-account` с помощью:"

#: in/chapter13.md:435
msgid ""
"```lisp\n"
"(defstruct (limited-account (:include account)) limit)\n"
"```"
msgstr ""

#: in/chapter13.md:442
msgid ""
"Two things are needed to provide an inheritance facility for classes.\n"
"First, we should modify `define-class` so that it takes the name of the "
"class to inherit from as the second argument.\n"
"This will signal that the new class will inherit all the instance variables, "
"class variables, and methods from the parent class.\n"
"The new class can, of course, define new variables and methods, or it can "
"shadow the parent's variables and methods.\n"
"In the form below, we define `limited-account` to be a subclass of `account` "
"that adds a new instance variable, `limit`, and redefines the `withdraw` "
"method so that it checks for amounts that are over the limit.\n"
"If the amount is acceptable, then it uses the function `call-next-method` "
"(not yet defined) to get at the `withdraw` method for the parent class, "
"`account`."
msgstr ""
"Для обеспечения возможности наследования классов необходимы две вещи.\n"
"Во-первых, мы должны изменить `define-class` так, чтобы он принимал имя "
"класса для наследования в качестве второго аргумента.\n"
"Это будет сигналом того, что новый класс унаследует все переменные "
"экземпляра, переменные класса и методы от родительского класса.\n"
"Новый класс, конечно, может определять новые переменные и методы или может "
"затенять родительские переменные и методы.\n"
"В приведенной ниже форме мы определяем `limited-account` как подкласс "
"`account`, который добавляет новую переменную экземпляра `limit` и "
"переопределяет метод `withdraw`, чтобы он проверял суммы, превышающие "
"лимит.\n"
"Если сумма приемлема, то он использует функцию `call-next-method` (еще не "
"определенную), чтобы получить метод `withdraw`  для родительского класса "
"`account`."

#: in/chapter13.md:446
msgid ""
"```lisp\n"
"(define-class limited-account account (limit) ()\n"
"```"
msgstr ""

#: in/chapter13.md:448
msgctxt "in/chapter13.md:448"
msgid "  `(withdraw (amt)`"
msgstr ""

#: in/chapter13.md:450
msgid "                `(if (> amt limit)`"
msgstr ""

#: in/chapter13.md:452
msgctxt "in/chapter13.md:452"
msgid "                    `'over-limit`"
msgstr ""

#: in/chapter13.md:454
msgid "                    `(call-next-method))))`"
msgstr ""

#: in/chapter13.md:457
msgid ""
"If inheritance is a good thing, then multiple inheritance is an even better "
"thing.\n"
"For example, assuming we have defined the classes `limited-account` and "
"`password-account`, it is very convenient to define the following class, "
"which inherits from both of them:"
msgstr ""
"Если наследование - это хорошо, то множественное наследование еще лучше.\n"
"Например, предполагая, что мы определили классы `limited-account` и "
"`password-account`, очень удобно определить следующий класс, который "
"наследуется от них обоих:"

#: in/chapter13.md:461
msgid ""
"```lisp\n"
"(define-class limited-account-with-password\n"
"```"
msgstr ""

#: in/chapter13.md:463
msgid "                      `(password-account limited-account))`"
msgstr ""

#: in/chapter13.md:466
msgid ""
"Notice that this new class adds no new variables or methods.\n"
"All it does is combine the functionality of two parent classes into one."
msgstr ""
"Обратите внимание, что этот новый класс не добавляет новых переменных или "
"методов.\n"
"Все, что он делает, это объединяет функциональность двух родительских "
"классов в один."

#: in/chapter13.md:468
msgid ""
"**Exercise  13.1 [d]** Define a version of `define-class` that handles "
"inheritance and `call-next-method`."
msgstr ""
"**Exercise  13.1 [d]** Определите версию `define-class`, которая "
"обрабатывает наследование и `call-next-method`"

#: in/chapter13.md:470
msgid ""
"**Exercise  13.2 [d]** Define a version of `define-class` that handles "
"multiple inheritance."
msgstr ""
"**Exercise  13.2 [d]** Определите версию `define-class`, которая "
"обрабатывает множественное наследование."

#: in/chapter13.md:472
msgid "## 13.7 CLOS: The Common Lisp Object System"
msgstr ""
"## 13.7 CLOS: Common Lisp Object System - Объектная Система Common Lisp"

#: in/chapter13.md:477
msgid ""
"So far, we have developed an object-oriented programming system using a "
"macro, `define-class`, and a protocol for implementing objects as closures.\n"
"There have been many proposals for adding object-oriented features to Lisp, "
"some similar to our approach, some quite different.\n"
"Recently, one approach has been approved to become an official part of "
"Common Lisp, so we will abandon our ad hoc approach and devote the rest of "
"this chapter to CLOS, the Common Lisp Object System.\n"
"The correspondence between our system and CLOS is summarized here:"
msgstr ""
"До сих пор мы разрабатывали объектно-ориентированную систему "
"программирования с использованием макроса, `define-class` и протокола для "
"реализации объектов как замыканий.\n"
"Было много предложений по добавлению объектно-ориентированных функций в "
"Lisp, некоторые из них похожи на наш подход, некоторые совсем другие.\n"
"Недавно был одобрен один подход, который стал официальной частью Common "
"Lisp, поэтому мы откажемся от нашего специального подхода и посвятим "
"оставшуюся часть этой главы CLOS, объектной системе Common Lisp.\n"
"Соответствие между нашей системой и CLOS резюмируется здесь:"

#: in/chapter13.md:485
msgid ""
"| our system                   | CLOS                      |\n"
"|------------------------------|---------------------------|\n"
"| `define-class`               | `defclass`                |\n"
"| *`methods defined in class`* | `defmethod`               |\n"
"| *`class-name`*               | `make-instance`           |\n"
"| `call-next-method`           | `call-next-method`        |\n"
"| `ensure-generic-fn`          | `ensure-generic-function` |"
msgstr ""

#: in/chapter13.md:489
msgid ""
"Like most object-oriented systems, CLOS is primarily concerned with defining "
"classes and methods for them, and in creating instances of the classes.\n"
"In CLOS the macro `defclass` defines a class, `defmethod` defines a method, "
"and `make-instance` creates an instance of a class-an object.\n"
"The general form of the macro `defclass` is:"
msgstr ""
"Как и большинство объектно-ориентированных систем, CLOS в первую очередь "
"занимается определением классов и методов для них, а также созданием "
"экземпляров этих классов.\n"
"В CLOS макрос `defclass` определяет класс, `defmethod` определяет метод, а "
"`make-instance` создает экземпляр класса - как объект.\n"
"Общая форма макроса `defclass`:"

#: in/chapter13.md:491
msgid ""
"(`defclass`*class-name* (*superclass...*) (*slot-specifier...*) *optional-"
"class-option...*)"
msgstr ""

#: in/chapter13.md:494
msgid ""
"The class-options are rarely used.\n"
"`defclass` can be used to define the class `account`:"
msgstr ""
"Опции классов используются редко.\n"
"`defclass` может использоваться для определения класса `account`:"

#: in/chapter13.md:498
msgid ""
"```lisp\n"
"(defclass account ()\n"
"```"
msgstr ""

#: in/chapter13.md:500
msgid "  `((name :initarg :name ireader name)`"
msgstr ""

#: in/chapter13.md:502
msgid "      `(balance :initarg :balance :initform 0.00 :accessor balance)`"
msgstr ""

#: in/chapter13.md:504
msgid "      `(interest-rate :allocation :class :initform .06`"
msgstr ""

#: in/chapter13.md:506
msgid "                `:reader interest-rate)))`"
msgstr ""

#: in/chapter13.md:512
msgid ""
"In the definition of account, we see that the list of superclasses is empty, "
"because account does not inherit from any classes.\n"
"There are three slot specifiers, for the `name`, `balance`, and `interest-"
"rate` slots.\n"
"Each slot name can be followed by optional keyword/value pairs defining how "
"the slot is used.\n"
"The `name` slot has an `:initarg` option, which says that the name can be "
"specified when a new account is created with `make-instance`.\n"
"The `:reader` slot creates a method called `name` to get at the current "
"value of the slot."
msgstr ""
"В определении учетной записи мы видим, что список суперклассов пуст, потому "
"что account не наследуется ни от каких классов.\n"
"Есть три спецификатора слотов: для слотов `name`, `balance` и `interest-"
"rate`.\n"
"За каждым именем слота могут следовать необязательные пары ключевое слово/"
"значение, определяющие, как используется слот.\n"
"В слоте `name` есть опция `:initarg`, которая говорит, что имя может быть "
"указано при создании новой учетной записи с помощью `make-instance`.\n"
"Слот `:reader` создает метод с именем `name` для получения текущего значения "
"слота."

#: in/chapter13.md:514
msgid ""
"The balance slot has three options: another `:initarg`, saying that the "
"balance can be specified when a new account is made; an `:initform`, which "
"says that if the balance is not specified, it defaults to `0.00`, and an `:"
"accessor`, which creates a method for getting at the slot's value just as `:"
"reader` does, and also creates a method for updating the slot with `setf`."
msgstr ""
"Слот баланса - balance имеет три опции: еще один `: initarg`, говорящий о "
"том, что баланс может быть указан при создании новой учетной записи; `: "
"initform`, который говорит, что если баланс не указан, по умолчанию он равен "
"`0.00` и `: accessor`, который создает метод для получения значения слота "
"так же, как `:reader`, а также создает метод обновления слота с помощью "
"`setf`."

#: in/chapter13.md:516
msgid ""
"The `interest-rate` slot has an `:initform` option to give it a default "
"value and an `:allocation` option to say that this slot is part of the "
"class, not of each instance of the class."
msgstr ""
"В слоте (процентная ставка)`interest-rate` есть опция `:initform` для "
"присвоения ему значения по умолчанию и опция `:allocation`, указывающая, что "
"этот слот является частью класса, а не каждого экземпляра класса."

#: in/chapter13.md:518
msgid ""
"Here we see the creation of an object, and the application of the "
"automatically defined methods to it."
msgstr ""
"Здесь мы видим создание объекта и применение к нему автоматически "
"определенных методов."

#: in/chapter13.md:522
msgid ""
"```lisp\n"
"> (setf al (make-instance 'account :balance 5000.00\n"
"```"
msgstr ""

#: in/chapter13.md:524
msgid "                          `:name \"Fred\")) => #<ACCOUNT 26726272>`"
msgstr ""

#: in/chapter13.md:530
msgid ""
"```lisp\n"
"> (name al) => \"Fred\"\n"
"> (balance al) => 5000.0\n"
"> (interest-rate al) => 0.06\n"
"```"
msgstr ""

#: in/chapter13.md:534
msgid ""
"CLOS differs from most object-oriented systems in that methods are defined "
"separately from classes.\n"
"To define a method (besides the ones defined automatically by `:reader`, `:"
"writer`, or `:accessor` options) we use the `defmethod` macro.\n"
"It is similar to defun in form:"
msgstr ""
"CLOS отличается от большинства объектно-ориентированных систем тем, что "
"методы определяются отдельно от классов.\n"
"Чтобы определить метод (помимо тех, которые автоматически определяются "
"параметрами `:reader`, `:writer` или `:accessor`), мы используем макрос "
"`defmethod`.\n"
"По форме он похож на defun:"

#: in/chapter13.md:536
msgid "`(defmethod`*method-name* (*parameter...*) *body...*)"
msgstr ""

#: in/chapter13.md:541
msgid ""
"Required parameters to a `defmethod` can be of the form (*var class*), "
"meaning that this is a method that applies only to arguments of that class.\n"
"Here is the method for withdrawing from an account.\n"
"Note that CLOS does not have a notion of instance variable, only instance "
"slot.\n"
"So we have to use the method (`balance acct`) rather than the instance "
"variable `balance`:"
msgstr ""
"Обязательные параметры для `defmethod` могут иметь форму (*var class*), что "
"означает, что это метод, который применяется только когда аргументы являются "
"экземплярами этого класса.\n"
"Вот способ вывода средств(withdrawing) со счета.\n"
"Обратите внимание, что CLOS не имеет понятия переменной экземпляра(instance "
"variable), только слот экземпляра(instance slot).\n"
"Поэтому мы должны использовать метод (`balance acct`), а не переменную "
"экземпляра `balance`:"

#: in/chapter13.md:545
msgid ""
"```lisp\n"
"(defmethod withdraw ((acct account) amt)\n"
"```"
msgstr ""

#: in/chapter13.md:547
msgid "  `(if (< amt (balance acct))`"
msgstr ""

#: in/chapter13.md:549
msgid "    `(decf (balance acct) amt)`"
msgstr ""

#: in/chapter13.md:551
msgid "    `'insufficient-funds))`"
msgstr ""

#: in/chapter13.md:553
msgid ""
"With CLOS it is easy to define a `limited-account` as a subclass of "
"`account`, and to define the `withdraw` method for `limited-accounts`:"
msgstr ""
"С помощью CLOS легко определить `limited-account` как подкласс `account` и "
"определить метод `withdraw` для `limited-accounts`:"

#: in/chapter13.md:557
msgid ""
"```lisp\n"
"(defclass limited-account (account)\n"
"```"
msgstr ""

#: in/chapter13.md:559
msgid "  `((limit :initarg :limit :reader limit)))`"
msgstr ""

#: in/chapter13.md:563
msgid ""
"```lisp\n"
"(defmethod withdraw ((acct limited-account) amt)\n"
"```"
msgstr ""

#: in/chapter13.md:565
msgid "  `(if (> amt (limit acct))`"
msgstr ""

#: in/chapter13.md:567
msgid "          `'over-limit`"
msgstr ""

#: in/chapter13.md:569
msgid "          `(call-next-method)))`"
msgstr ""

#: in/chapter13.md:572
msgid ""
"Note the use of `call-next-method` to invoke the `withdraw` method for the "
"`account` class.\n"
"Also note that all the other methods for accounts automatically work on "
"instances of the class limited-account, because it is defined to inherit "
"from `account.` In the following example, we show that the `name` method is "
"inherited, that the `withdraw` method for `limited-account` is invoked "
"first, and that the `withdraw` method for `account` is invoked by the `call-"
"next-method` function:"
msgstr ""
"Обратите внимание на использование `call-next-method` для вызова метода "
"`withdraw` для класса `account`.\n"
"Также обратите внимание, что все другие методы для счетов(account) "
"автоматически работают с экземплярами класса `limited-account`, поскольку он "
"определен как наследованик от `account`. В следующем примере мы показываем, "
"что метод `name` наследуется, а метод `withdraw` для `limited-account` "
"вызывается первым, а метод `withdraw` для account вызывается функцией `call-"
"next-method`:"

#: in/chapter13.md:576
msgid ""
"```lisp\n"
"> (setf a2 (make-instance 'limited-account\n"
"```"
msgstr ""

#: in/chapter13.md:579
msgid ""
"                        `:name \"A.\n"
"Thrifty Spender\"`"
msgstr ""

#: in/chapter13.md:581
msgid "                        `:balance 500.00 :limit 100.00))`=>"
msgstr ""

#: in/chapter13.md:585
msgid ""
"```lisp\n"
"#<LIMITED-ACCOUNT 24155343>\n"
"```"
msgstr ""

#: in/chapter13.md:588
msgid ""
"`> (name a2) => \"A.\n"
"Thrifty Spender\"`"
msgstr ""

#: in/chapter13.md:593
msgid ""
"```lisp\n"
"> (withdraw a2 200.00) => OVER-LIMIT\n"
"> (withdraw a2 20.00) => 480.0\n"
"```"
msgstr ""

#: in/chapter13.md:598
msgid ""
"In general, there may be several methods appropriate to a given message.\n"
"In that case, all the appropriate methods are gathered together and sorted, "
"most specific first.\n"
"The most specific method is then called.\n"
"That is why the method for `limited-account` is called first rather than the "
"method for `account.` The function `call-next-method` can be used within the "
"body of a method to call the next most specific method."
msgstr ""
"В общем, для данного сообщения может быть несколько методов.\n"
"В этом случае все подходящие методы собираются вместе и сортируются, в "
"первую очередь ставяться наиболее конкретные/специфичные.\n"
"Затем вызывается наиболее конкретный метод.\n"
"Вот почему сначала вызывается метод для `limited-account`, а не метод для "
"`account.`. Функция `call-next-method` может использоваться в теле метода "
"для вызова следующего наиболее конкретного метода."

#: in/chapter13.md:602
msgid ""
"The complete story is actually even more complicated than this.\n"
"As one example of the complication, consider the class `audited-account`, "
"which prints and keeps a trail of all deposits and withdrawals.\n"
"It could be defined as follows using a new feature of CLOS, `:before` and `:"
"after` methods:"
msgstr ""
"Полная история на самом деле даже сложнее, чем эта.\n"
"В качестве одного из примеров усложнения рассмотрим класс `audited-account`, "
"который распечатывает и отслеживает все депозиты и снятие средств.\n"
"Его можно определить следующим образом, используя новую функциональность "
"CLOS, методы `:before` и `:after`:"

#: in/chapter13.md:606
msgid ""
"```lisp\n"
"(defclass audited-account (account)\n"
"```"
msgstr ""

#: in/chapter13.md:608
msgid "  `((audit-trail :initform nil :accessor audit-trail)))`"
msgstr ""

#: in/chapter13.md:612
msgid ""
"```lisp\n"
"(defmethod withdraw :before ((acct audited-account) amt)\n"
"```"
msgstr ""

#: in/chapter13.md:614
msgid "  `(push (print '(withdrawing ,amt))`"
msgstr ""

#: in/chapter13.md:616
msgctxt "in/chapter13.md:616"
msgid "    `(audit-trail acct)))`"
msgstr ""

#: in/chapter13.md:620
msgid ""
"```lisp\n"
"(defmethod withdraw :after ((acct audited-account) amt)\n"
"```"
msgstr ""

#: in/chapter13.md:622
msgid "  `(push (print '(withdrawal (,amt) done))`"
msgstr ""

#: in/chapter13.md:624
msgctxt "in/chapter13.md:624"
msgid "    `(audit-trail acct)))`"
msgstr ""

#: in/chapter13.md:631
msgid ""
"Now a call to `withdraw` with a `audited-account` as the first argument "
"yields three applicable methods: the primary method from `account` and the :"
"`before` and :`after` methods.\n"
"In general, there might be several of each kind of method.\n"
"In that case, all the :`before` methods are called in order, most specific "
"first.\n"
"Then the most specific primary method is called.\n"
"It may choose to invoke `cal1-next-method` to get at the other methods.\n"
"(It is an error for a :`before` or :`after` method to use `call-next-"
"method.)` Finally, all the :`after` methods are called, least specific first."
msgstr ""
"Теперь вызов функции `withdraw` с `audited-account` в качестве первого "
"аргумента дает три применимых метода: основной метод из `account` и методы `:"
"before` и `:after`.\n"
"В общем, таких методов может быть несколько.\n"
"В этом случае все методы `:before` вызываются по порядку, сначала наиболее "
"конкретные.\n"
"Затем вызывается наиболее конкретный первичный метод.\n"
"Он может выбрать вызов `cal1-next-method` для доступа к другим методам.\n"
"(Для метода :`before` или :`after` использование метода `call-next-method` "
"является ошибкой.) Наконец, вызываются все методы :`after`, наименее "
"специфичные в первую очередь."

#: in/chapter13.md:634
msgid ""
"The values from the `:before` and `:after` methods are ignored, and the "
"value from the primary method is returned.\n"
"Here is an example:"
msgstr ""
"Значения из методов `:before` и `:after` игнорируются, и возвращается "
"значение из основного метода.\n"
"Вот пример:"

#: in/chapter13.md:647
msgid ""
"```lisp\n"
"> (setf a3 (make-instance 'audited-account :balance 1000.00))\n"
"#<AUDITED-ACCOUNT 33555607>\n"
"> (withdraw a3 100.00)\n"
"(WITHDRAWING 100.0)\n"
"(WITHDRAWAL (100.0) DONE)\n"
"900.0\n"
"> (audit-trail a3)\n"
"((WITHDRAWAL (100.0) DONE) (WITHDRAWING 100.0))\n"
"> (setf (audit-trail a3) nil)\n"
"NIL\n"
"```"
msgstr ""

#: in/chapter13.md:652
msgid ""
"The last interaction shows the biggest flaw in CLOS: it fails to encapsulate "
"information.\n"
"In order to make the `audit-trail` accessible to the `withdraw` methods, we "
"had to give it accessor methods.\n"
"We would like to encapsulate the writer function for `audit-trail` so that "
"it can only be used with deposit and `withdraw`.\n"
"But once the writer function is defined it can be used anywhere, so an "
"unscrupulous outsider can destroy the audit trail, setting it to nil or "
"anything else."
msgstr ""
"Последнее взаимодействие показывает самый большой недостаток CLOS: он не "
"может инкапсулировать информацию.\n"
"Чтобы сделать `audit-trail` доступным для методов `withdraw`, мы должны были "
"предоставить ему методы доступа.\n"
"Мы хотели бы инкапсулировать функцию записи для `audit-trail`, чтобы ее "
"можно было использовать только с `депозитом` и `withdraw`.\n"
"Но как только функция записи определена, ее можно использовать где угодно, "
"поэтому недобросовестный посторонний может уничтожить журнал аудита(`audit-"
"trail`), установив для него значение nil или что-то еще."

#: in/chapter13.md:654
msgid "## 13.8 A CLOS Example: Searching Tools"
msgstr "## 13.8 A CLOS Example: Searching Tools"

#: in/chapter13.md:659
msgid ""
"CLOS is most appropriate whenever there are several types that share related "
"behavior.\n"
"A good example of an application that fits this description is the set of "
"searching tools defined in [section 6.4](B9780080571157500066.xhtml#s0025).\n"
"There we defined functions for breadth-first, depth-first, and best-first "
"search, as well as tree- and graph-based search.\n"
"We also defined functions to search in particular domains, such as planning "
"a route between cities."
msgstr ""
"CLOS является наиболее подходящим, когда есть несколько типов, которые "
"разделяют связанное поведение.\n"
"Хорошим примером приложения, которое соответствует этому описанию, является "
"набор инструментов для поиска, определенных в  [разделе 6.4]"
"(B9780080571157500066.xhtml#s0025).\n"
"Там мы определили функции для поиска в ширину(breadth-first), в "
"глубину(depth-first) и поиска первого лучшего(best-first), а также по дереву "
"или графу.\n"
"Мы также определили функции для поиска в определенных доменах(областях), "
"таких как планирование маршрута между городами."

#: in/chapter13.md:663
msgid ""
"If we had written the tools in a straightforward procedural style, we would "
"have ended up with dozens of similar functions.\n"
"Instead, we used higher-order functions to control the complexity.\n"
"In this section, we see how CLOS can be used to break up the complexity in a "
"slightly different fashion."
msgstr ""
"Если бы мы писали инструменты в простом, процедурном стиле, мы получили бы "
"десятки похожих функций.\n"
"Вместо этого мы использовали функции высшего порядка для управления "
"сложностью.\n"
"В этом разделе мы увидим как CLOS можно использовать для уменьшения "
"сложности немного другим способом."

#: in/chapter13.md:669
msgid ""
"We begin by defining the class of search problems.\n"
"Problems will be classified according to their domain (route planning, "
"etc.), their topology (tree or graph) and their search strategy (breadth-"
"first or depth-first, etc.).\n"
"Each combination of these features results in a new class of problem.\n"
"This makes it easy for the user to add a new class to represent a new "
"domain, or a new search strategy.\n"
"The basic class, `problem`, contains a single-instance variable to hold the "
"unexplored states of the problem."
msgstr ""
"Начнем мы с определения класса поисковых задач.\n"
"Задачи будут классифицироваться в соответствии с их предметной областью "
"(планирование маршрутов и т.д.), их топологией (дерево или граф) и их "
"стратегией поиска(в ширину(breadth-first) или в глубину(depth-first) и т."
"д.).\n"
"Каждая комбинация этих признаков приводит к  новому классу задач.\n"
"Это позволяет пользователю легко добавлять новый класс для представления  "
"нового домена(области) или  новой стратегии поиска.\n"
"Базовый класс поисковых задач - `problem`, содержит переменную существующую "
"в одном экземпляре для хранения неисследованных состояний задачи."

#: in/chapter13.md:673
msgid ""
"```lisp\n"
"(defclass problem ()\n"
"```"
msgstr ""

#: in/chapter13.md:675
msgid "  `((states :initarg :states :accessor problem-states)))`"
msgstr ""

#: in/chapter13.md:678
msgid ""
"The function searcher is similar to the function `tree-search` of [section "
"6.4](B9780080571157500066.xhtml#s0025).\n"
"The main difference is that searcher uses generic functions instead of "
"passing around functional arguments."
msgstr ""
"Функция поиска - searcher аналогична функции `tree-search` из [раздела 6.4]"
"(B9780080571157500066.xhtml#s0025).\n"
"Основное отличие состоит в том, что searcher использует обобщенные функции "
"вместо передачи функциональных аргументов."

#: in/chapter13.md:682
msgid ""
"```lisp\n"
"(defmethod searcher ((prob problem))\n"
"```"
msgstr ""

#: in/chapter13.md:684
msgid "  `\"Find a state that solves the search problem.\"`"
msgstr ""

#: in/chapter13.md:686
msgid "  `(cond ((no-states-p prob) fail)`"
msgstr ""

#: in/chapter13.md:688
msgid "    `((goal-p prob) (current-state prob))`"
msgstr ""

#: in/chapter13.md:690
msgid "    `(t (let ((current (pop-state prob)))`"
msgstr ""

#: in/chapter13.md:692
msgid "              `(setf (problem-states prob)`"
msgstr ""

#: in/chapter13.md:694
msgid "                  `(problem-combiner`"
msgstr ""

#: in/chapter13.md:696
msgid "                    `prob`"
msgstr ""

#: in/chapter13.md:698
msgid "                    `(problem-successors prob current)`"
msgstr ""

#: in/chapter13.md:700
msgid "                    `(problem-states prob))))`"
msgstr ""

#: in/chapter13.md:702
msgid "            `(searcher prob))))`"
msgstr ""

#: in/chapter13.md:705
msgid ""
"searcher does not assume that the problem states are organized in a list; "
"rather, it uses the generic function `no-states-p` to test if there are any "
"states, `pop-state` to remove and return the first state, and `current-"
"state` to access the first state.\n"
"For the basic `problem` class, we will in fact implement the states as a "
"list, but another class of problem is free to use another representation."
msgstr ""
"searcher не предполагает, что состояния проблемы организованы в виде списка; "
"скорее он использует обобщенную функцию `no-states-p` для проверки наличия "
"каких-либо состояний, `pop-state` для удаления и возврата первого состояния "
"и `current-state` для доступа к первому состоянию.\n"
"Для базового класса `problem`, мы фактически реализуем состояния в виде "
"списка, но другой класс задач(проблем) может использовать другое "
"представление."

#: in/chapter13.md:709
msgid ""
"```lisp\n"
"(defmethod current-state ((prob problem))\n"
"```"
msgstr ""

#: in/chapter13.md:711
msgid "  `\"The current state is the first of the possible states.\"`"
msgstr ""

#: in/chapter13.md:713
msgid "  `(first (problem-states prob)))`"
msgstr ""

#: in/chapter13.md:717
msgid ""
"```lisp\n"
"(defmethod pop-state ((prob problem))\n"
"```"
msgstr ""

#: in/chapter13.md:719
msgid "  `\"Remove and return the current state.\"`"
msgstr ""

#: in/chapter13.md:721
msgid "  `(pop (problem-states prob)))`"
msgstr ""

#: in/chapter13.md:725
msgid ""
"```lisp\n"
"(defmethod no-states-p ((prob problem))\n"
"```"
msgstr ""

#: in/chapter13.md:727
msgid "  `\"Are there any more unexplored states?\"`"
msgstr ""

#: in/chapter13.md:729
msgid "  `(null (problem-states prob)))`"
msgstr ""

#: in/chapter13.md:733
msgid ""
"In `tree-search`, we included a statement to print debugging information.\n"
"We can do that here, too, but we can hide it in a separate method so as not "
"to clutter up the main definition of `searcher`.\n"
"It is a `:before` method because we want to see the output before carrying "
"out the operation."
msgstr ""
"В `tree-search` мы включили оператор для вывода отладочной информации.\n"
"Мы можем сделать это и здесь, но мы можем скрыть это в отдельном методе, "
"чтобы не загромождать основное определение `searcher`.\n"
"Это метод `:before`, поскольку мы ходтим увидеть вывод перед выполнением "
"операции."

#: in/chapter13.md:737
msgid ""
"```lisp\n"
"(defmethod searcher :before ((prob problem))\n"
"```"
msgstr ""

#: in/chapter13.md:739
msgid "  `(dbg 'search \";; Search: ~a\" (problem-states prob)))`"
msgstr ""

#: in/chapter13.md:744
msgid ""
"The generic functions that remain to be defined are `goal-p, probl em-"
"combiner,` and `problem-successors`.\n"
"We will address `goal-p` first, by recognizing that for many problems we "
"will be searching for a state that is `eql` to a specified goal state.\n"
"We define the class `eql-problem` to refer to such problems, and specify "
"`goal-p` for that class.\n"
"Note that we make it possible to specify the goal when a problem is created, "
"but not to change the goal:"
msgstr ""
"Обобщенные функции, которе еще предстоит определить, это `goal-p, problem-"
"combiner,` и `problem-successors`.\n"
"Сначала мы обратимся к `goal-p`, осознавая, что для многих проблем мы будем "
"скать состояние, которое соответствует, в смысле - `eql` указанному "
"состоянию цели.\n"
"Мы определяем класс `eql-problem` для ссылки на такие проблемы, и указываем "
"`goal-p` для этого класса.\n"
"Обратите внимание, что мы позволяем указывать цель при создании проблемы, но "
"не изменять цель:"

#: in/chapter13.md:748
msgid ""
"```lisp\n"
"(defclass eql-problem (problem)\n"
"```"
msgstr ""

#: in/chapter13.md:750
msgid "  `((goal rinitarg :goal :reader problem-goal)))`"
msgstr ""

#: in/chapter13.md:754
msgid ""
"```lisp\n"
"(defmethod goal-p ((prob eql-problem))\n"
"```"
msgstr ""

#: in/chapter13.md:756
msgid "  `(eql (current-state prob) (problem-goal prob)))`"
msgstr ""

#: in/chapter13.md:759
msgid ""
"Now we are ready to specify two search strategies: depth-first search and "
"breadth-first search.\n"
"We define problem classes for each strategy and specify the `problem-"
"combiner` function:"
msgstr ""
"Теперь мы готовы определить две стратегии: поиск в глубину(depth-first) и "
"поиск в ширину(breadth-first).\n"
"Мы определяем классы задач для каждой стратегии и указываем функцию `problem-"
"combiner`:"

#: in/chapter13.md:763
msgid ""
"```lisp\n"
"(defclass dfs-problem (problem) ()\n"
"```"
msgstr ""

#: in/chapter13.md:765
msgid "  `(:documentation \"Depth-first search problem.\"))`"
msgstr ""

#: in/chapter13.md:769
msgid ""
"```lisp\n"
"(defclass bfs-problem (problem) ()\n"
"```"
msgstr ""

#: in/chapter13.md:771
msgid "  `(:documentation \"Breadth-first search problem.\"))`"
msgstr ""

#: in/chapter13.md:775
msgid ""
"```lisp\n"
"(defmethod problem-combiner ((prob dfs-problem) new old)\n"
"```"
msgstr ""

#: in/chapter13.md:777
msgid "  `\"Depth-first search looks at new states first.\"`"
msgstr ""

#: in/chapter13.md:779
msgid "  `(append new old))`"
msgstr ""

#: in/chapter13.md:783
msgid ""
"```lisp\n"
"(defmethod problem-combiner ((prob bfs-problem) new old)\n"
"```"
msgstr ""

#: in/chapter13.md:785
msgid "  `\"Depth-first search looks at old states first.\"`"
msgstr ""

#: in/chapter13.md:787
msgid "  `(append old new))`"
msgstr ""

#: in/chapter13.md:792
msgid ""
"While this code will be sufficient for our purposes, it is less than ideal, "
"because it breaks an information-hiding barrier.\n"
"It treats the set of old states as a list, which is the default for the "
"`problem` class but is not necessarily the implementation that every class "
"will use.\n"
"It would have been cleaner to define generic functions `add-states-to-end` "
"and `add-states-to-front` and then define them with `append` in the default "
"class.\n"
"But Lisp provides such nice list-manipulation primitives that it is "
"difficult to avoid the temptation of using them directly."
msgstr ""
"Хотя этого кода будет достаточно длял наших целей, он далеко не идеален, "
"поскольку разрушает барьер, скрывающей информацию.\n"
"Он обрабатывает набор старых состояний как список, который используется по "
"умолчанию для класса `problem`, но это не обзяательно является реализацией, "
"которую будет использовать каждый класс.\n"
"Было бы проще(чище) определить обобщенные функции `add-states-to-end` и `add-"
"states-to-front`,  а затем определить с их помощью `append` в классе по "
"умолчанию.\n"
"Но Лисп предоставляет такие удобные примитивы для работы со списками, что "
"трудно избежать соблазна использовать их напрямую."

#: in/chapter13.md:794
msgid ""
"Of course, the user who defines a new implementation for `problem-states` "
"could just redefine `problem-combiner` for the offending classes, but this "
"is precisely what object-oriented programming is designed to avoid: "
"specializing one abstraction (states) should not force us to change anything "
"in another abstraction (search strategy)."
msgstr ""
"Конечно, пользователь определяющий новую реализацию для `problem-states` "
"может просто переопределить `problem-combiner` для нарушающих классов, но "
"это именно то, чего объектно-ориентированное программирование призвано "
"избегать: указание однойо асбтрации (состояний/states) не долна нас "
"заставлять что-либо менять в другой абстракции (стратегии поиска)."

#: in/chapter13.md:798
msgid ""
"The last step is to define a class that represents a particular domain, and "
"define `problem-successors` for that domain.\n"
"As the first example, consider the simple binary tree search from [section "
"6.4](B9780080571157500066.xhtml#s0025).\n"
"Naturally, this gets represented as a class:"
msgstr ""
"Последний шаг - это определение класса, представляющего определенный "
"домен(область), и определение `problem-successors` для этого домена.\n"
"В качестве первого примера рассмотрим простой поиск по бинарному дереву из "
"[раздела 6.4](B9780080571157500066.xhtml#s0025).\n"
"Естественно, он будет представлен в виде класса:"

#: in/chapter13.md:803
msgid ""
"```lisp\n"
"(defclass binary-tree-problem (problem) ())\n"
"(defmethod problem-successors ((prob binary-tree-problem) state)\n"
"```"
msgstr ""

#: in/chapter13.md:805
msgid "  `(let ((n (* 2 state)))`"
msgstr ""

#: in/chapter13.md:807
msgid "      `(list n (+ n 1))))`"
msgstr ""

#: in/chapter13.md:810
msgid ""
"Now suppose we want to solve a binary-tree problem with breadth-first "
"search, searching for a particular goal.\n"
"Simply create a class that mixes in `binary-tree-problem, eql-problem` and "
"`bfs-problem,` create an instance of that class, and call `searcher` on that "
"instance:"
msgstr ""
"Теперь предположим мы хотим решить проблему определенную в виде бинарного "
"дерева (binary-tree problem) с помощью поиска в ширину, ища конкретную "
"цель.\n"
"Просто создадим класс, который сочетает в `binary-tree-problem, eql-problem` "
"и `bfs-problem,` создадим экземпляр этого класса и вызовем `searcher` для "
"этого экземпляра:"

#: in/chapter13.md:814
msgid ""
"```lisp\n"
"(defclass binary-tree-eql-bfs-problem\n"
"```"
msgstr ""

#: in/chapter13.md:816
msgid "            `(binary-tree-problem eql-problem bfs-problem) ())`"
msgstr ""

#: in/chapter13.md:820
msgid ""
"```lisp\n"
"> (setf pl (make-instance 'binary-tree-eql-bfs-problem\n"
"```"
msgstr ""

#: in/chapter13.md:822
msgid "                          `:states '(1) :goal 12))`"
msgstr ""

#: in/chapter13.md:840
msgid ""
"```lisp\n"
"#<BINARY-TREE-EQL-BFS-PROBLEM 26725536>\n"
"> (searcher pl)\n"
";; Search: (1)\n"
";; Search: (2 3)\n"
";; Search: (3 4 5)\n"
";; Search: (4 5 6 7)\n"
";; Search: (5 6 7 8 9)\n"
";; Search: (6 7 8 9 10 11)\n"
";; Search: (7 8 9 10 11 12 13)\n"
";; Search: (8 9 10 11 12 13 14 15)\n"
";; Search: (9 10 11 12 13 14 15 16 17)\n"
";; Search: (10 11 12 13 14 15 16 17 18 19)\n"
";; Search: (11 12 13 14 15 16 17 18 19 20 21)\n"
";; Search: (12 13 14 15 16 17 18 19 20 21 22 23)\n"
"12\n"
"```"
msgstr ""

#: in/chapter13.md:842
msgid "### Best-First Search"
msgstr "### Поиск первого лучшего(Best-First)"

#: in/chapter13.md:845
msgid ""
"It should be clear how to proceed to define best-first search: define a "
"class to represent best-first search problems, and then define the necessary "
"methods for that class.\n"
"Since the search strategy only affects the order in which states are "
"explored, the only method necessary will be for `problem-combiner`."
msgstr ""
"Должно быть ясно, как продолжить определение поиска первый лучший(best-"
"first): определить класс для представления задачи поиска первого лучшего, а "
"затем определить необходимые методы для этого класса.\n"
"Так как стратегия поиска влияет только на порядок в котором исследуются "
"состояния, единственный необходимый метод - это `problem-combiner`."

#: in/chapter13.md:849
msgid ""
"```lisp\n"
"(defclass best-problem (problem) ()\n"
"```"
msgstr ""

#: in/chapter13.md:851
msgid "  `(:documentation \"A Best-first search problem.\"))`"
msgstr ""

#: in/chapter13.md:855
msgid ""
"```lisp\n"
"(defmethod problem-combiner ((prob best-problem) new old)\n"
"```"
msgstr ""

#: in/chapter13.md:857
msgid "  `\"Best-first search sorts new and old according to cost-fn.\"`"
msgstr ""

#: in/chapter13.md:859
msgid "  `(sort (append new old) #'<`"
msgstr ""

#: in/chapter13.md:861
msgid "            `:key #'(lambda (state) (cost-fn prob state))))`"
msgstr ""

#: in/chapter13.md:864
msgid ""
"This introduces the new function `cost-fn`; naturally it will be a generic "
"function.\n"
"The following is a `cost-fn` that is reasonable for any `eql-problem` "
"dealing with numbers, but it is expected that most domains will specialize "
"this function."
msgstr ""
"Здесь вводится новая функция `cost-fn`; естественно, это будет обобщенная "
"функция.\n"
"Ниже приводится `cost-fn`, которая подходит для любой `eql-problem` имеющей "
"дело с числами, но ожидается что большинство доменов(областей) будут сами "
"определять эту функцию."

#: in/chapter13.md:868
msgid ""
"```lisp\n"
"(defmethod cost-fn ((prob eql-problem) state)\n"
"```"
msgstr ""

#: in/chapter13.md:870
msgid "  `(abs (- state (problem-goal prob))))`"
msgstr ""

#: in/chapter13.md:876
msgid ""
"Beam search is a modification of best-first search where all but the best "
"*b* states are thrown away on each iteration.\n"
"A beam search problem is represented by a class where the instance variable "
"`beam-width` holds the parameter *b*.\n"
"If this nil, then full best-first search is done.\n"
"Beam search is implemented by an `:around` method on `problem-combiner`.\n"
"It calls the next method to get the list of states produced by best-first "
"search, and then extracts the first *b* elements."
msgstr ""
"Поиск по лучу - это модификация поиска первый лучший(best-first), где все "
"состояния, кроме b лучших состояний, отбрасываются на каждой итерации.\n"
"Задача поиска по лучу представлена классом, в котором переменная экземпляра "
"`beam-width` содержит параметр *b*.\n"
"Если он nil, то выполняется полный поиск первого лучшего(best-first).\n"
"Поиск по лучу реализуется методом `:around` над `problem-combiner`.\n"
"Он вызывает следующий метод, чтобы получить список состояний, полученных с "
"помощью поиска первого лучшего(best-first), а затем извлекает *b* первых "
"элементов."

#: in/chapter13.md:880
msgid ""
"```lisp\n"
"(defclass beam-problem (problem)\n"
"```"
msgstr ""

#: in/chapter13.md:882
msgid "  `((beam-width :initarg :beam-width :initform nil`"
msgstr ""

#: in/chapter13.md:884
msgid "                  `:reader problem-beam-width)))`"
msgstr ""

#: in/chapter13.md:888
msgid ""
"```lisp\n"
"(defmethod problem-combiner :around ((prob beam-problem) new old)\n"
"```"
msgstr ""

#: in/chapter13.md:890
msgid "  `(let ((combined (call-next-method)))`"
msgstr ""

#: in/chapter13.md:892
msgid "      `(subseq combined 0 (min (problem-beam-width prob)`"
msgstr ""

#: in/chapter13.md:894
msgid "                          `(length combined)))))`"
msgstr ""

#: in/chapter13.md:897
msgid ""
"Now we apply beam search to the binary-tree problem.\n"
"As usual, we have to make up another class to represent this type of problem:"
msgstr ""
"Теперь мы применяем поиск по лучу к задаче бинарного дерева(binary-tree "
"problem).\n"
"Как обычно, мы должны создать другой класс, чтобы представить этот тип "
"проблемы:"

#: in/chapter13.md:901
msgid ""
"```lisp\n"
"(defclass binary-tree-eql-best-beam-problem\n"
"```"
msgstr ""

#: in/chapter13.md:903
msgid "  `(binary-tree-problem eql-problem best-problem beam-problem)`"
msgstr ""

#: in/chapter13.md:905
msgid "  `())`"
msgstr ""

#: in/chapter13.md:909
msgid ""
"```lisp\n"
"> (setf p3 (make-instance 'binary-tree-eql-best-beam-problem\n"
"```"
msgstr ""

#: in/chapter13.md:911
msgid "                          `:states '(1) :goal 12 :beam-width 3))`"
msgstr ""

#: in/chapter13.md:924
msgid ""
"```lisp\n"
"#<BINARY-TREE-EQL-BEST-BEAM-PROBLEM 27523251>\n"
"> (searcher p3)\n"
";; Search: (1)\n"
";; Search: (3 2)\n"
";; Search: (7 6 2)\n"
";; Search: (14 15 6)\n"
";; Search: (15 6 28)\n"
";; Search: (6 28 30)\n"
";; Search: (12 13 28)\n"
"12\n"
"```"
msgstr ""

#: in/chapter13.md:935
msgid ""
"So far the case for CLOS has not been compelling.\n"
"The code in this section duplicates the functionality of code in [section "
"6.4](B9780080571157500066.xhtml#s0025), but the CLOS code tends to be more "
"verbose, and it is somewhat disturbing that we had to make up so many long "
"class names.\n"
"However, this verbosity leads to flexibility, and it is easier to extend the "
"CLOS code by adding new specialized classes.\n"
"It is useful to make a distinction between the systems programmer and the "
"applications programmer.\n"
"The systems programmer would supply a library of classes like `dfs-problem` "
"and generic functions like `searcher`.\n"
"The applications programmer then just picks what is needed from the "
"library.\n"
"From the following we see that it is not too difficult to pick out the right "
"code to define a trip-planning searcher.\n"
"Compare this with the definition of `trip` on page 198 to see if you prefer "
"CLOS in this case.\n"
"The main difference is that here we say that the cost function is `air-"
"distance` and the successors are the `neighbors` by defining methods; in "
"`trip` we did it by passing parameters.\n"
"The latter is a little more succint, but the former may be more clear, "
"especially as the number of parameters grows."
msgstr ""
"Пока аргументы в пользу CLOS неубедительны.\n"
"Код в этом разделе дублирует функциональность кода из [раздела 6.4]"
"(B9780080571157500066.xhtml#s0025), но код CLOS имеет тенденцию быть более "
"многословным, и несколько беспокоит то, что нам пришлось составлять так "
"много длинных имен классов.\n"
"Однако, такая многословность прибодит к гибкости и код CLOS проще расширить, "
"добавив н овые специализированные классы.\n"
"Полезно проводить различие между системным программистом и прикладным "
"программистом.\n"
"Системный программист предоставит библиотеку классов, подобную `dfs-problem` "
"и обобщенных функций, таких как `searcher`.\n"
"Затем прикладной программист просто выбирает из библиотеки то, что нужно.\n"
"Из следующего мы видим, что выбрать правильный код для определения "
"поисковика(searcher) планирования поездки не так уж и сложно.\n"
"Сравните его с определением `trip` со страници 198, чтобы увидеть "
"предпочтете ли вы CLOS в этом случае.\n"
"Основное отличие состоит в том, что здесь мы говорим, что функция стоимости "
"это `air-distance`, а преемники(successors) являются соседями - `neighbors` "
"по определению методов; в `trip` мы сделали это, передав их в виде "
"параметров.\n"
"Последнее немного более кратко, но первое может быть более понятным, тем "
"более что количество параметров растет."

#: in/chapter13.md:939
msgid ""
"```lisp\n"
"(defclass trip-problem (binary-tree-eql-best-beam-problem)\n"
"```"
msgstr ""

#: in/chapter13.md:941
msgid "  `((beam-width :initform 1)))`"
msgstr ""

#: in/chapter13.md:945
msgid ""
"```lisp\n"
"(defmethod cost-fn ((prob trip-problem) city)\n"
"```"
msgstr ""

#: in/chapter13.md:947
msgid "  `(air-distance (problem-goal prob) city))`"
msgstr ""

#: in/chapter13.md:951
msgid ""
"```lisp\n"
"(defmethod problem-successors ((prob trip-problem) city)\n"
"```"
msgstr ""

#: in/chapter13.md:953
msgid "  `(neighbors city))`"
msgstr ""

#: in/chapter13.md:955
msgid "With the definitions in place, it is easy to use the searching tool:"
msgstr ""

#: in/chapter13.md:959
msgid ""
"```lisp\n"
"> (setf p4 (make-instance 'trip-problem\n"
"```"
msgstr ""

#: in/chapter13.md:961
msgid "                        `:states (list (city 'new-york))`"
msgstr ""

#: in/chapter13.md:963
msgid "                        `:goal (city 'san-francisco)))`"
msgstr ""

#: in/chapter13.md:977
msgid ""
"```lisp\n"
"#<TRIP-PROBLEM 31572426>\n"
"> (searcher p4)\n"
";; Search: ((NEW-YORK 73.58 40.47))\n"
";; Search: ((PITTSBURG 79.57 40.27))\n"
";; Search: ((CHICAGO 87.37 41.5))\n"
";; Search: ((KANSAS-CITY 94.35 39.06))\n"
";; Search: ((DENVER 105.0 39.45))\n"
";; Search: ((FLAGSTAFF 111.41 35.13))\n"
";; Search: ((RENO 119.49 39.3))\n"
";; Search: ((SAN-FRANCISCO 122.26 37.47))\n"
"(SAN-FRANCISCO 122.26 37.47)\n"
"```"
msgstr ""

#: in/chapter13.md:979
msgid "## 13.9 Is CLOS Object-Oriented?"
msgstr "## 13.9 Действительно ли CLOS Объектно-Ориентированный?"

#: in/chapter13.md:982
msgid ""
"There is some argument whether CLOS is really object-oriented at all.\n"
"The arguments are:"
msgstr ""
"Есть некоторые аргументы в пользу того, действительно ли CLOS вообще "
"объектно-ориентирован.\n"
"Аргументы следующие:"

#: in/chapter13.md:984
msgid ""
"CLOS *is* an object-oriented system because it provides all three of the "
"main criteria for object-orientation: objects with internal state, classes "
"of objects with specialized behavior for each class, and inheritance between "
"classes."
msgstr ""
"CLOS *является* объектно-ориентированной системой, потому что она "
"обеспечивает все три основных критерия объектной ориентации: объекты с "
"внутренним состоянием, классы объектов со специализированным поведением для "
"каждого класса и наследованием между классами."

#: in/chapter13.md:990
msgid ""
"CLOS is *not* an object-oriented system because it does not provide modular "
"objects with information-hiding.\n"
"In the `audited-account` example, we would like to encapsulate the `audit-"
"trail` instance variable so that only the `withdraw` methods can change it.\n"
"But because methods are written separately from class definitions, we could "
"not do that.\n"
"Instead, we had to define an accessor for `audit-trail`.\n"
"That enabled us to write the `withdraw` methods, but it also made it "
"possible for anyone else to alter the audit trail as well."
msgstr ""
"CLOS *не* объектно-ориентированная система, потому что она не предоставляет "
"модульным объектам сокрытие информации.\n"
"В примере `audited-account` мы хотели бы инкапсулировать переменную "
"экземпляра `audit-trail`, чтобы только методы `withdraw` могли ее изменить.\n"
"Но поскольку методы написаны отдельно от определений классов, мы не можем "
"этого сделать.\n"
"Вместо этого нам пришлось определить метод доступа для `audit-trail`.\n"
"Это позволило нам написать методы `withdraw`, но также позволяет кому-либо "
"еще изменить контрольный журнал."

#: in/chapter13.md:995
msgid ""
"CLOS is *more general than* an object-oriented system because it allows for "
"methods that specialize on more than one argument.\n"
"In true object-oriented systems, methods are associated with objects of a "
"particular class.\n"
"This association is lexically obvious (and the message-passing metaphor is "
"clear) when we write the methods inside the definition of the class, as in "
"our `define-class` macro.\n"
"The message-passing metaphor is still apparent when we write generic "
"functions that dispatch on the class of their first argument, which is how "
"we've been using CLOS so far."
msgstr ""
"CLOS является *более общей, чем* объектно-ориентированная система, потому "
"что позволяет использовать методы, которые специализируются на более чем "
"одном аргументе.\n"
"В настоящих объектно-ориентированных системах методы связаны с объектами "
"определенного класса.\n"
"Эта ассоциация лексически очевидна (и метафора передачи сообщений ясна), "
"когда мы пишем методы внутри определения класса, как в нашем макросе `define-"
"class`.\n"
"Метафора передачи сообщений по-прежнему очевидна, когда мы пишем обобщенные "
"функции, применение которых определяется/выбирается по классу их первого "
"аргумента, как мы до сих пор использовали CLOS."

#: in/chapter13.md:1000
msgid ""
"But CLOS methods can dispatch on the class of any required argument, or any "
"combination of them.\n"
"Consider the following definition of `conc,` which is like `append` except "
"that it works for vectors as well as lists.\n"
"Rather than writing `conc` using conditional statements, we can use the "
"multimethod dispatch capabilities of CLOS to define the four cases: (1) the "
"first argument is nil, (2) the second argument is nil, (3) both arguments "
"are lists, and (4) both arguments are vectors.\n"
"Notice that if one of the arguments is nil there will be two applicable "
"methods, but the method for `null` will be used because the class `null` is "
"more specific than the class `list.`"
msgstr ""
"Но методы CLOS могут определяться по классу любого требуемого аргумента или "
"любой их комбинации.\n"
"Рассмотрим следующее определение `conc`, которое похоже на `append`, за "
"исключением того, что оно работает как для векторов, так и для списков.\n"
"Вместо того, чтобы писать `conc` с использованием условных операторов, мы "
"можем использовать возможности диспетчеризации мультиметодов CLOS для "
"определения четырех случаев: (1) первый аргумент равен nil, (2) второй "
"аргумент равен nil, (3) оба аргумента являются списками , и (4) оба "
"аргумента являются векторами.\n"
"Обратите внимание, что если один из аргументов равен nil, будут применяться "
"два метода, но будет использоваться метод для `null`, потому что класс "
"`null` более специфичен, чем класс `list`."

#: in/chapter13.md:1006
msgid ""
"```lisp\n"
"(defmethod conc ((x null) y) y)\n"
"(defmethod conc (x (y null)) x)\n"
"(defmethod conc ((x list) (y list))\n"
"```"
msgstr ""

#: in/chapter13.md:1008
msgid "  `(cons (first x) (conc (rest x) y)))`"
msgstr ""

#: in/chapter13.md:1012
msgid ""
"```lisp\n"
"(defmethod conc ((x vector) (y vector))\n"
"```"
msgstr ""

#: in/chapter13.md:1014
msgid "  `(let ((vect (make-array (+ (length x) (length y)))))`"
msgstr ""

#: in/chapter13.md:1016
msgid "      `(replace vect x)`"
msgstr ""

#: in/chapter13.md:1018
msgid "      `(replace vect y :startl (length x))))`"
msgstr ""

#: in/chapter13.md:1020
msgid "Here we see that this definition works:"
msgstr "Здесь мы видим, что это определение работает:"

#: in/chapter13.md:1026
msgid ""
"```lisp\n"
"> (conc nil '(a b c)) => (A B C)\n"
"> (conc '(a b c) nil) => (A B C)\n"
"> (conc '(a b c) '(d e f)) => (A B C D E F)\n"
"```"
msgstr ""

#: in/chapter13.md:1028
msgid "`> (conc '#(a b c) '#(d e f))`=> `#(A B C D E F)`"
msgstr ""

#: in/chapter13.md:1031
msgid ""
"It works, but one might well ask: where are the objects?\n"
"The metaphor of passing a message to an object does not apply here, unless "
"we consider the object to be the list of arguments, rather than a single "
"privileged argument."
msgstr ""
"Это работает, но можно спросить: а где объекты?\n"
"Метафора передачи сообщения объекту здесь неприменима, если только мы не "
"рассматриваем объект как список аргументов, а не как один привилегированный "
"аргумент."

#: in/chapter13.md:1034
msgid ""
"It is striking that this style of method definition is very similar to the "
"style used in Prolog.\n"
"As another example, compare the following two definitions of `len`, a "
"relation/function to compute the length of a list:"
msgstr ""
"Поразительно, что этот стиль определения метода очень похож на стиль, "
"используемый в Prolog.\n"
"В качестве другого примера сравним следующие два определения `len`, "
"отношения/функции для вычисления длины списка:"

#: in/chapter13.md:1041
msgid ""
"```\n"
";; CLOS\n"
"(defmethod len ((x null)) 0)\n"
"(defmethod len ((x cons))\n"
"(+  1 (len (rest x))))\n"
"```"
msgstr ""

#: in/chapter13.md:1048
msgid ""
"```\n"
"%% Prolog\n"
"len([],0).\n"
"len(CXIL].N1) :-\n"
"len(L.N). NI is N+1.\n"
"```"
msgstr ""

#: in/chapter13.md:1050
msgid "## 13.10 Advantages of Object-Oriented Programming"
msgstr "## 13.10 Преимущества объектно-ориентированного программирования"

#: in/chapter13.md:1052
msgid ""
"Bertrand Meyer, in his book on the object-oriented language Eiffel (1988), "
"lists five qualities that contribute to software quality:"
msgstr ""
"Бертран Мейер в своей книге об объектно-ориентированном языке Eiffel (1988) "
"перечисляет пять качеств, которые влияют на качество программного "
"обеспечения:"

#: in/chapter13.md:1055
msgid ""
"*   *Correctness*.\n"
"Clearly, a correct program is of the upmost importance."
msgstr ""
"*   *Правильность*.\n"
"Ясно, что правильная программа имеет первостепенное значение."

#: in/chapter13.md:1058
msgid ""
"*   *Robustness*.\n"
"Programs should continue to function in a reasonable manner even for input "
"that is beyond the original specifications."
msgstr ""
"*   *Надежность*.\n"
"Программы должны продолжать работать надлежащим образом даже при вводе, "
"выходящем за рамки исходных спецификаций."

#: in/chapter13.md:1061
msgid ""
"*   *Extendability*.\n"
"Programs should be easy to modify when the specifications change."
msgstr ""
"*   *Расширяемость*.\n"
"Программы должны легко изменяться при изменении технических характеристик."

#: in/chapter13.md:1064
msgid ""
"*   *Reusability*.\n"
"Program components should be easy to transport to new programs, thus "
"amortizing the cost of software development over several projects."
msgstr ""
"*   *Возможность повторного использования *.\n"
"Компоненты программы должны легко переноситься в новые программы, тем самым "
"окупая затраты на разработку программного обеспечения на нескольких проектах."

#: in/chapter13.md:1068
msgid ""
"*   *Compatibility*.\n"
"Programs should interface well with other programs.\n"
"For example, a spreadsheet program should not only manipulate numbers "
"correctly but also be compatible with word processing programs, so that "
"spreadsheets can easily be included in documents."
msgstr ""
"*   *Совместимость*.\n"
"Программы должны хорошо взаимодействовать с другими программами.\n"
"Например, программа для работы с электронными таблицами должна не только "
"правильно манипулировать числами, но и быть совместимой с программами "
"обработки текстов, чтобы таблицы можно было легко включать в документы."

#: in/chapter13.md:1070
msgid ""
"Here we list how the object-oriented approach in general and CLOS in "
"particular can effect these measures of quality:"
msgstr ""
"Здесь мы перечисляем, как объектно-ориентированный подход в целом и CLOS в "
"частности могут повлиять на эти показатели качества:"

#: in/chapter13.md:1075
msgid ""
"*   *Correctness*.\n"
"Correctness is usually achieved in two stages: correctness of individual "
"modules and correctness of the whole system.\n"
"The object-oriented approach makes it easier to prove correctness for "
"modules, since they are clearly defined, and it may make it easier to "
"analyze interactions between modules, since the interface is strictly "
"limited.\n"
"CLOS does not provide for information-hiding the way other systems do."
msgstr ""
"*   *Правильность *.\n"
"Правильность обычно достигается в два этапа: правильность отдельных модулей "
"и правильность всей системы.\n"
"Объектно-ориентированный подход упрощает доказательство правильности "
"модулей, поскольку они четко определены, и может облегчить анализ "
"взаимодействия между модулями, поскольку интерфейс строго ограничен.\n"
"CLOS не обеспечивает сокрытие информации, как это делают другие системы."

#: in/chapter13.md:1079
msgid ""
"*   *Robustness*.\n"
"Generic functions make it possible for a function to accept, at run time, a "
"class of argument that the programmer did not anticipate at compile time.\n"
"This is particularly true in CLOS, because multiple inheritance makes it "
"feasible to write default methods that can be used by a wide range of "
"classes."
msgstr ""
"*   *Надежность*.\n"
"Обобщенные функции дают возможность функциям принимать во время выполнения "
"класс аргумента, который программист не ожидал во время компиляции.\n"
"Это особенно верно в случае CLOS, потому что множественное наследование "
"позволяет писать методы по умолчанию, которые могут использоваться широким "
"спектром классов."

#: in/chapter13.md:1083
msgid ""
"*   *Extendability*.\n"
"Object-oriented systems with inheritance make it easy to define new classes "
"that are slight variants on existing ones.\n"
"Again, CLOS's multiple inheritance makes extensions even easier than in "
"single-inheritance systems."
msgstr ""
"*   *Расширяемость *.\n"
"Объектно-ориентированные системы с наследованием позволяют легко определять "
"новые классы, которые являются незначительными отличиями существующих.\n"
"Опять же, множественное наследование CLOS делает процесс расширения даже "
"проще, чем в системах с одиночным наследованием."

#: in/chapter13.md:1089
msgid ""
"*   *Reusability*.\n"
"This is the area where the object-oriented style makes the biggest "
"contribution.\n"
"Instead of writing each new program from scratch, object-oriented "
"programmers can look over a library of classes, and either reuse existing "
"classes as is, or specialize an existing class through inheritance.\n"
"Large libraries of CLOS classes have not emerged yet.\n"
"Perhaps they will when the language is more established."
msgstr ""
"*   *Возможность повторного использования*.\n"
"Это та область, где объектно-ориентированный стиль вносит наибольший вклад.\n"
"Вместо того, чтобы писать каждую новую программу с нуля, объектно-"
"ориентированные программисты могут просматривать библиотеку классов и либо "
"повторно использовать существующие классы как есть, либо специализировать "
"существующий класс посредством наследования.\n"
"Большие библиотеки классов CLOS еще не появились.\n"
"Возможно, они сделают это, когда язык станет более устоявшимся."

#: in/chapter13.md:1093
msgid ""
"*   *Compatibility*.\n"
"The more programs use standard components, the more they will be able to "
"communicate with each other.\n"
"Thus, an object-oriented program will probably be compatible with other "
"programs developed from the same library of classes."
msgstr ""
"*   *Совместимость*.\n"
"Чем больше программ использует стандартные компоненты, тем больше они смогут "
"взаимодействовать друг с другом.\n"
"Таким образом, объектно-ориентированная программа, вероятно, будет "
"совместима с другими программами, разработанными на основе той же библиотеки "
"классов."

#: in/chapter13.md:1095
msgid "## 13.11 History and References"
msgstr "## 13.11 История и Ссылки"

#: in/chapter13.md:1103
msgid ""
"The first object-oriented language was Simula, which was designed by Ole-"
"Johan Dahl and Krysten Nygaard ([1966](B9780080571157500285.xhtml#bb0265), "
"[Nygaard and Dahl 1981](B9780080571157500285.xhtml#bb0920)) as an extension "
"of Algol 60.\n"
"It is still in use today, mostly in Norway and Sweden.\n"
"Simula provides the ability to define classes with single inheritance.\n"
"Methods can be inherited from a superclass or overridden by a subclass.\n"
"It also provides *coroutines*, class instances that execute continuously, "
"saving local state in instance variables but periodically pausing to let "
"other coroutines run.\n"
"Although Simula is a general-purpose language, it provides special support "
"for simulation, as the name implies.\n"
"The built-in class `simulation` allows a programmer to keep track of "
"simulated time while running a set of processes as coroutines."
msgstr ""

#: in/chapter13.md:1111
msgid ""
"In 1969 Alan Kay was a graduate student at the University of Utah.\n"
"He became aware of Simula and realized that the object-oriented style was "
"well suited to his research in graphies ([Kay 1969](B9780080571157500285."
"xhtml#bb0600)).\n"
"A few years later, at Xerox, he joined with Adele Goldberg and Daniel "
"Ingalls to develop the Smalltalk language (see [Goldberg and Robinson 1983]"
"(B9780080571157500285.xhtml#bb0475)).\n"
"While Simula can be viewed as an attempt to add object-oriented features to "
"strongly typed Algol 60, Smalltalk can be seen as an attempt to use the "
"dynamic, loosely typed features of Lisp, but with methods and objects "
"replacing functions and s-expressions.\n"
"In Simula, objects existed alongside traditional data types like numbers and "
"strings; in Smalltalk, every datum is an object.\n"
"This gave Smalltalk the feel of an integra ted Lisp environment, where the "
"user can inspect, copy, or edit any part of the environment.\n"
"In fact, it was not the object-oriented features of Smalltalk per se that "
"have made a lasting impression but rather the then-innovative idea that "
"every user would have a large graphical display and could interact with the "
"system using a mouse and menus rather than by typing commands."
msgstr ""

#: in/chapter13.md:1115
msgid ""
"Guy Steele's *LAMBDA: The Ultimate Declarative* (1976a and b) was perhaps "
"the first paper to demonstrate how object-oriented programming can be done "
"in Lisp.\n"
"As the title suggests, it was all done using `lambda,` in a similar way to "
"our `define-class` example.\n"
"Steele summarized the approach with the equation \"Actors = Closures (mod "
"Syntax),\" refering to Cari Hewitt's \"Actors\" object-oriented formalism."
msgstr ""

#: in/chapter13.md:1119
msgid ""
"In 1979, the MIT Lisp Machine group developed the Flavors system based on "
"this approach but offering considerable extensions ([Cannon 1980]"
"(B9780080571157500285.xhtml#bb0155), [Weinreb 1980](B9780080571157500285."
"xhtml#bb1360), [Moon et al.\n"
"1983](B9780080571157500285.xhtml#bb0860)).\n"
"\"Flavor\" was a popular jargon word for \"type\" or \"kind\" at MIT, so it "
"was natural that it became the term for what we call classes."
msgstr ""

#: in/chapter13.md:1130
msgid ""
"The Flavor system was the first to support multiple inheritance.\n"
"Other languages shunned multiple inheritance because it was too dynamic.\n"
"With single inheritance, each instance variable and method could be assigned "
"a unique offset number, and looking up a variable or method was therefore "
"trivial.\n"
"But with multiple inheritance, these computations had to be done at run "
"time.\n"
"The Lisp tradition enabled programmers to accept this dynamic computation, "
"when other languages would not.\n"
"Once it was accepted, the MIT group soon came to embrace it.\n"
"They developed complex protocols for combining different flavors into new "
"ones.\n"
"The concept of *mix-ins* was developed by programmers who frequented Steve's "
"Ice Cream parlor in nearby Davis Square.\n"
"Steve's offered a list of ice cream flavors every day but also offered to "
"create new flavors-dynamically-by mixing in various cookies, candies, or "
"fruit, at the request of the individual customer.\n"
"For example, Steve's did not have chocolate-chip ice cream on the menu, but "
"you could always order vanilla ice cream with chocolate chips mixed in.[3]"
"(#fn0025)"
msgstr ""

#: in/chapter13.md:1136
msgid ""
"This kind of \"flavor hacking\" appealed to the MIT Lisp Machine group, who "
"adopted the metaphor for their object-oriented programming system.\n"
"All flavors inherited from the top-mostflavor in the hierarchy: vanilla.\n"
"In the window system, for example, the flavor `basic-window` was defined to "
"support the minimal functionality of all windows, and then new flavors of "
"window were defined by combining mix-in flavors such as `scroll-bar-mixin`, "
"`label-mixin`, and `border-mixin`.\n"
"These mix-in flavors were used only to define other flavors.\n"
"Just as you couldn't go into Steve's and order \"crushed Heath bars, hold "
"the ice cream,\" there was a mechanism to prohibit instantiation of mix-ins."
msgstr ""

#: in/chapter13.md:1145
msgid ""
"A complicated repetoire of *method combinations* was developed.\n"
"The default method combination on Flavors was similar to CLOS: first do all "
"the :`before` methods, then the most specific primary method, then the `:"
"after` methods.\n"
"But it was possible to combine methods in other ways as well.\n"
"For example, consider the `inside-width` method, which returns the width in "
"pixels of the usuable portion of a window.\n"
"A programmer could specify that the combined method for `inside-width` was "
"to be computed by calling all applicable methods and summing them.\n"
"Then an `inside-width` method for the `basic-window` flavor would be defined "
"to return the width of the full window, and each mix-in would have a simple "
"method to say how much of the width it consumed.\n"
"For example, if borders are 8 pixels wide and scroll bars are 12 pixels "
"wide, then the `inside-width` method for `border-mixin` returns `-8` and "
"`scroll-bar-mixin` returns `-  12`.\n"
"Then any window, no matter how many mix-ins it is composed of, automatically "
"computes the proper inside width."
msgstr ""

#: in/chapter13.md:1152
msgid ""
"In 1981, Symbolics came out with a more efficient implementation of "
"Flavors.\n"
"Objects were no longer just closures.\n"
"They were still funcallable, but there was additional hardware support that "
"distinguished them from other functions.\n"
"After a few years Symbolics abandoned the (send *object message*) syntax in "
"favor of a new syntax based on generic functions.\n"
"This system was known as New Flavors.\n"
"It had a strong influence on the eventual CLOS design."
msgstr ""

#: in/chapter13.md:1156
msgid ""
"The other strong influence on CLOS was the CommonLoops system developed at "
"Xerox PARC.\n"
"(See [Bobrow 1982](B9780080571157500285.xhtml#bb0095), [Bobrow et al.\n"
"1986](B9780080571157500285.xhtml#bb0105), [Stefik and Bobrow 1986]"
"(B9780080571157500285.xhtml#bb1185).) CommonLoops continued the New Flavors "
"trend away from message passing by introducing *multimethods*: methods that "
"specialize on more than one argument."
msgstr ""

#: in/chapter13.md:1160
msgid ""
"As of summer 1991, CLOS itself is in a state of limbo.\n"
"It was legitimized by its appearance in *Common Lisp the Language*, 2d "
"edition, but it is not yet official, and an important part, the metaobject "
"protocol, is not yet complete.\n"
"A tutorial on CLOS is [Keene 1989](B9780080571157500285.xhtml#bb0620)."
msgstr ""

#: in/chapter13.md:1165
msgid ""
"We have seen how easy it is to build an object-oriented system on top of "
"Lisp, using `lambda` as the primary tool.\n"
"An interesting alternative is to build Lisp on top of an object-oriented "
"system.\n"
"That is the approach taken in the Oaklisp system of [Lang and Perlmutter "
"(1988)](B9780080571157500285.xhtml#bb0695).\n"
"Instead of defining methods using `lambda` as the primitive, Oaklisp has "
"`add-method` as a primitive and defines `lambda` as a macro that adds a "
"method to an anonymous, empty operation."
msgstr ""

#: in/chapter13.md:1173
msgid ""
"Of course, object-oriented systems are thriving outside the Lisp world.\n"
"With the success of UNIX-based workstations, C has become one of the most "
"widely available programming languages.\n"
"C is a fairly low-level language, so there have been several attempts to use "
"it as a kind of portable assembly language.\n"
"The most successful of these attempts is C++, a language developed by Bjarne "
"Stroustrup of AT&T Bell Labs ([Stroustrup 1986](B9780080571157500285."
"xhtml#bb1210)).\n"
"C++ provides a number of extensions, including the ability to define "
"classes.\n"
"However, as an add-on to an existing language, it does not provide as many "
"features as the other languages discussed here.\n"
"Crucially, it does not provide garbage collection, nor does it support fully "
"generic functions."
msgstr ""

#: in/chapter13.md:1176
msgid ""
"Eiffel ([Meyer 1988](B9780080571157500285.xhtml#bb0830)) is an attempt to "
"define an object-oriented system from the ground up rather than tacking it "
"on to an existing language.\n"
"Eiffel supports multiple inheritance and garbage collection and a limited "
"amount of dynamic dispatching."
msgstr ""

#: in/chapter13.md:1178
msgid ""
"So-called modern languages like Ada and Modula support information-hiding "
"through generic functions and classes, but they do not provide inheritance, "
"and thus can not be classified as true object-oriented languages."
msgstr ""

#: in/chapter13.md:1180
msgid ""
"Despite these other languages, the Lisp-based object-oriented systems are "
"the only ones since Smalltalk to introduce important new concepts: multiple "
"inheritance and method combination from Flavors, and multimethods from "
"CommonLoops."
msgstr ""

#: in/chapter13.md:1182
msgid "## 13.12 Exercises"
msgstr "## 13.12 Упражнения"

#: in/chapter13.md:1184
msgid ""
"**Exercise  13.3 [m]** Implement `deposit` and `interest` methods for the "
"`account` class using CLOS."
msgstr ""

#: in/chapter13.md:1188
msgid ""
"**Exercise  13.4 [m]** Implement the `password-account` class using CLOS.\n"
"Can it be done as cleanly with inheritance as it was done with delegation?\n"
"Or should you use delegation within CLOS?"
msgstr ""

#: in/chapter13.md:1190
msgid ""
"**Exercise  13.5 [h]** Implement graph searching, search paths, and A* "
"searching as classes in CLOS."
msgstr ""

#: in/chapter13.md:1197
msgid ""
"**Exercise  13.6 [h]** Implement a priority queue to hold the states of a "
"problem.\n"
"Instead of a list, the `problem-states` will be a vector of lists, each "
"initially null.\n"
"Each new state will have a priority (determined by the generic function "
"`priority`) which must be an integer between zero and the length of the "
"vector, where zero indicates the highest priority.\n"
"A new state with priority *p* is pushed onto element *p* of the vector, and "
"the state to be explored next is the first state in the first nonempty "
"position.\n"
"As stated in the text, some of the previously defined methods made the "
"unwarranted assumption that `problem-states` would always hold a list.\n"
"Change these methods."
msgstr ""

#: in/chapter13.md:1199
msgid "----------------------"
msgstr ""

#: in/chapter13.md:1205
msgid ""
"[1](#xfn0015) More accurately, we have a guarantee that there is no way to "
"get at the inside of a closure using portable Common Lisp code.\n"
"Particular implementations may provide debugging tools for getting at this "
"hidden information, such as `inspect`.\n"
"So closures are not perfect at hiding information from these tools.\n"
"Of course, no information-hiding method will be guaranteed against such "
"covert channels-even with the most sophisticated software security measures, "
"it is always possible to, say, wipe a magnet over the computer's disks and "
"alter sensitive data.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter13.md:1209
msgid ""
"[2](#xfn0020) There is a technical sense of \"generic function\" that is "
"used within CLOS.\n"
"These functions are not generic according to this technical sense.\n"
"!!!(p) {:.ftnote1}"
msgstr ""

#: in/chapter13.md:1215
msgid ""
"[3](#xfn0025) Flavor fans will be happy to know that Steve's Ice Cream is "
"now sold nationally in the United States.\n"
"Alas, it is not possible to create flavors dynamically.\n"
"Also, be warned that Steve's was bought out by his Teal Square rival, "
"Joey's.\n"
"The original Steve retired from the business for years, then came back with "
"a new line of stores under his last name, Harrell.\n"
"!!!(p) {:.ftnote1}"
msgstr ""
